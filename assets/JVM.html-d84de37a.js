const e=JSON.parse('{"key":"v-6d18ab1e","path":"/interview/java/JVM.html","title":"JVM","lang":"zh-CN","frontmatter":{"title":"JVM","author":"Vingkin","date":"2022-04-24T00:00:00.000Z","description":"双亲委派机制 工作原理 如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制 优点 避免类的重复加载 保护程序安全，防止核心API被随意篡改（比如：java.lang.String)","head":[["meta",{"property":"og:url","content":"https://vingkin.github.io/Blog/Blog/interview/java/JVM.html"}],["meta",{"property":"og:site_name","content":"Vingkin的学习博客"}],["meta",{"property":"og:title","content":"JVM"}],["meta",{"property":"og:description","content":"双亲委派机制 工作原理 如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制 优点 避免类的重复加载 保护程序安全，防止核心API被随意篡改（比如：java.lang.String)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-25T15:52:09.000Z"}],["meta",{"property":"article:author","content":"Vingkin"}],["meta",{"property":"article:published_time","content":"2022-04-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-25T15:52:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-24T00:00:00.000Z\\",\\"dateModified\\":\\"2023-09-25T15:52:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Vingkin\\"}]}"]]},"headers":[{"level":2,"title":"双亲委派机制","slug":"双亲委派机制","link":"#双亲委派机制","children":[]},{"level":2,"title":"沙箱安全机制","slug":"沙箱安全机制","link":"#沙箱安全机制","children":[]},{"level":2,"title":"使用PC寄存器存储字节码指令地址有什么用呢？","slug":"使用pc寄存器存储字节码指令地址有什么用呢","link":"#使用pc寄存器存储字节码指令地址有什么用呢","children":[]},{"level":2,"title":"举例栈溢出的情况","slug":"举例栈溢出的情况","link":"#举例栈溢出的情况","children":[]},{"level":2,"title":"方法中定义的局部变量是否线程安全","slug":"方法中定义的局部变量是否线程安全","link":"#方法中定义的局部变量是否线程安全","children":[]},{"level":2,"title":"Minor GC、Major GC、Full GC","slug":"minor-gc、major-gc、full-gc","link":"#minor-gc、major-gc、full-gc","children":[]},{"level":2,"title":"创建对象的方式","slug":"创建对象的方式","link":"#创建对象的方式","children":[]},{"level":2,"title":"创建对象的步骤","slug":"创建对象的步骤","link":"#创建对象的步骤","children":[]},{"level":2,"title":"对象的内存布局","slug":"对象的内存布局","link":"#对象的内存布局","children":[]},{"level":2,"title":"字符串拼接","slug":"字符串拼接","link":"#字符串拼接","children":[]},{"level":2,"title":"GC大厂面试题","slug":"gc大厂面试题","link":"#gc大厂面试题","children":[]},{"level":2,"title":"增量收集算法","slug":"增量收集算法","link":"#增量收集算法","children":[]},{"level":2,"title":"System.gc()的理解","slug":"system-gc-的理解","link":"#system-gc-的理解","children":[]},{"level":2,"title":"内存溢出和内存泄漏的原因","slug":"内存溢出和内存泄漏的原因","link":"#内存溢出和内存泄漏的原因","children":[]},{"level":2,"title":"评估GC的性能指标","slug":"评估gc的性能指标","link":"#评估gc的性能指标","children":[]},{"level":2,"title":"7种经典的垃圾回收器","slug":"_7种经典的垃圾回收器","link":"#_7种经典的垃圾回收器","children":[]},{"level":2,"title":"垃圾回收器的选择","slug":"垃圾回收器的选择","link":"#垃圾回收器的选择","children":[]},{"level":2,"title":"JDK 后续版本中 CMS 的变化","slug":"jdk-后续版本中-cms-的变化","link":"#jdk-后续版本中-cms-的变化","children":[]}],"git":{"createdTime":1695657129000,"updatedTime":1695657129000,"contributors":[{"name":"vingkin","email":"1830053226@qq.com","commits":1}]},"readingTime":{"minutes":12.96,"words":3889},"filePathRelative":"interview/java/JVM.md","localizedDate":"2022年4月24日","excerpt":"<h2> 双亲委派机制</h2>\\n<p><strong>工作原理</strong></p>\\n<ol>\\n<li>如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li>\\n<li>如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li>\\n<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li>\\n</ol>\\n<p><strong>优点</strong></p>\\n<ol>\\n<li>避免类的重复加载</li>\\n<li>保护程序安全，防止核心API被随意篡改（比如：java.lang.String)</li>\\n</ol>","copyright":{"author":"Vingkin"},"autoDesc":true}');export{e as data};
