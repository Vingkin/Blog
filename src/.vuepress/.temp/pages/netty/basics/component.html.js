export const data = JSON.parse("{\"key\":\"v-54862980\",\"path\":\"/netty/basics/component.html\",\"title\":\"组件\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"组件\",\"author\":\"vingkin\",\"date\":\"2022-07-25T00:00:00.000Z\",\"description\":\"EventLoop 事件循环对象 EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。 它的继承关系比较复杂 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法 另一条线是继承自 netty 自己的 OrderedEventExecutor， 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://vingkin.github.io/Blog/new_blog/netty/basics/component.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Vingkin的学习博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"组件\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"EventLoop 事件循环对象 EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。 它的继承关系比较复杂 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法 另一条线是继承自 netty 自己的 OrderedEventExecutor， 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2023-09-25T02:33:51.000Z\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"vingkin\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2022-07-25T00:00:00.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2023-09-25T02:33:51.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"组件\\\",\\\"image\\\":[\\\"\\\"],\\\"datePublished\\\":\\\"2022-07-25T00:00:00.000Z\\\",\\\"dateModified\\\":\\\"2023-09-25T02:33:51.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"vingkin\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"EventLoop\",\"slug\":\"eventloop\",\"link\":\"#eventloop\",\"children\":[{\"level\":3,\"title\":\"优雅关闭💡\",\"slug\":\"优雅关闭💡\",\"link\":\"#优雅关闭💡\",\"children\":[]},{\"level\":3,\"title\":\"演示 NioEventLoop 处理 io 事件\",\"slug\":\"演示-nioeventloop-处理-io-事件\",\"link\":\"#演示-nioeventloop-处理-io-事件\",\"children\":[]},{\"level\":3,\"title\":\"handler 执行中如何换人？💡\",\"slug\":\"handler-执行中如何换人-💡\",\"link\":\"#handler-执行中如何换人-💡\",\"children\":[]},{\"level\":3,\"title\":\"演示 NioEventLoop 处理普通任务\",\"slug\":\"演示-nioeventloop-处理普通任务\",\"link\":\"#演示-nioeventloop-处理普通任务\",\"children\":[]},{\"level\":3,\"title\":\"演示 NioEventLoop 处理定时任务\",\"slug\":\"演示-nioeventloop-处理定时任务\",\"link\":\"#演示-nioeventloop-处理定时任务\",\"children\":[]}]},{\"level\":2,\"title\":\"Channel\",\"slug\":\"channel\",\"link\":\"#channel\",\"children\":[{\"level\":3,\"title\":\"ChannelFuture\",\"slug\":\"channelfuture\",\"link\":\"#channelfuture\",\"children\":[]},{\"level\":3,\"title\":\"CloseFuture\",\"slug\":\"closefuture\",\"link\":\"#closefuture\",\"children\":[]},{\"level\":3,\"title\":\"异步提升的是什么💡\",\"slug\":\"异步提升的是什么💡\",\"link\":\"#异步提升的是什么💡\",\"children\":[]}]},{\"level\":2,\"title\":\"Future & Promise\",\"slug\":\"future-promise\",\"link\":\"#future-promise\",\"children\":[{\"level\":3,\"title\":\"JDK Future\",\"slug\":\"jdk-future\",\"link\":\"#jdk-future\",\"children\":[]},{\"level\":3,\"title\":\"Netty Future\",\"slug\":\"netty-future\",\"link\":\"#netty-future\",\"children\":[]},{\"level\":3,\"title\":\"Promise\",\"slug\":\"promise\",\"link\":\"#promise\",\"children\":[]},{\"level\":3,\"title\":\"例1\",\"slug\":\"例1\",\"link\":\"#例1\",\"children\":[]},{\"level\":3,\"title\":\"例2\",\"slug\":\"例2\",\"link\":\"#例2\",\"children\":[]},{\"level\":3,\"title\":\"例3\",\"slug\":\"例3\",\"link\":\"#例3\",\"children\":[]},{\"level\":3,\"title\":\"例4\",\"slug\":\"例4\",\"link\":\"#例4\",\"children\":[]},{\"level\":3,\"title\":\"例5\",\"slug\":\"例5\",\"link\":\"#例5\",\"children\":[]},{\"level\":3,\"title\":\"例6\",\"slug\":\"例6\",\"link\":\"#例6\",\"children\":[]}]},{\"level\":2,\"title\":\"Handler & Pipeline\",\"slug\":\"handler-pipeline\",\"link\":\"#handler-pipeline\",\"children\":[]},{\"level\":2,\"title\":\"ByteBuf\",\"slug\":\"bytebuf\",\"link\":\"#bytebuf\",\"children\":[{\"level\":3,\"title\":\"1）创建\",\"slug\":\"_1-创建\",\"link\":\"#_1-创建\",\"children\":[]},{\"level\":3,\"title\":\"2）直接内存 vs 堆内存\",\"slug\":\"_2-直接内存-vs-堆内存\",\"link\":\"#_2-直接内存-vs-堆内存\",\"children\":[]},{\"level\":3,\"title\":\"3）池化 vs 非池化\",\"slug\":\"_3-池化-vs-非池化\",\"link\":\"#_3-池化-vs-非池化\",\"children\":[]},{\"level\":3,\"title\":\"4）组成\",\"slug\":\"_4-组成\",\"link\":\"#_4-组成\",\"children\":[]},{\"level\":3,\"title\":\"5）写入\",\"slug\":\"_5-写入\",\"link\":\"#_5-写入\",\"children\":[]},{\"level\":3,\"title\":\"6）扩容\",\"slug\":\"_6-扩容\",\"link\":\"#_6-扩容\",\"children\":[]},{\"level\":3,\"title\":\"7）读取\",\"slug\":\"_7-读取\",\"link\":\"#_7-读取\",\"children\":[]},{\"level\":3,\"title\":\"8）retain & release\",\"slug\":\"_8-retain-release\",\"link\":\"#_8-retain-release\",\"children\":[]},{\"level\":3,\"title\":\"9）slice\",\"slug\":\"_9-slice\",\"link\":\"#_9-slice\",\"children\":[]},{\"level\":3,\"title\":\"10）duplicate\",\"slug\":\"_10-duplicate\",\"link\":\"#_10-duplicate\",\"children\":[]},{\"level\":3,\"title\":\"11）copy\",\"slug\":\"_11-copy\",\"link\":\"#_11-copy\",\"children\":[]},{\"level\":3,\"title\":\"12）CompositeByteBuf\",\"slug\":\"_12-compositebytebuf\",\"link\":\"#_12-compositebytebuf\",\"children\":[]},{\"level\":3,\"title\":\"13）Unpooled\",\"slug\":\"_13-unpooled\",\"link\":\"#_13-unpooled\",\"children\":[]},{\"level\":3,\"title\":\"ByteBuf 优势💡\",\"slug\":\"bytebuf-优势💡\",\"link\":\"#bytebuf-优势💡\",\"children\":[]}]}],\"git\":{\"createdTime\":1695609231000,\"updatedTime\":1695609231000,\"contributors\":[{\"name\":\"Vingkin\",\"email\":\"1830053226@qq.com\",\"commits\":1}]},\"readingTime\":{\"minutes\":27.51,\"words\":8252},\"filePathRelative\":\"netty/basics/component.md\",\"localizedDate\":\"2022年7月25日\",\"excerpt\":\"<h2> EventLoop</h2>\\n<p>事件循环对象</p>\\n<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>\\n<p>它的继承关系比较复杂</p>\\n<ul>\\n<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\\n<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，\\n<ul>\\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\\n<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>\\n</ul>\\n</li>\\n</ul>\",\"copyright\":{\"author\":\"vingkin\"},\"autoDesc\":true}")
