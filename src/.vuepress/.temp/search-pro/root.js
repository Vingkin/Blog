export default "{\"documentCount\":1563,\"nextId\":1563,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-184f4da6#todo\",\"2\":\"v-2e3eac9e\",\"3\":\"v-f66aca42\",\"4\":\"v-f66aca42#概述\",\"5\":\"v-f66aca42#结构\",\"6\":\"v-f66aca42#类适配器模式\",\"7\":\"v-f66aca42#对象适配器模式\",\"8\":\"v-f66aca42#应用场景\",\"9\":\"v-f66aca42#jdk源码解析\",\"10\":\"v-f66aca42#代理-v-s-桥接-v-s-装饰器-v-s-适配器\",\"11\":\"v-42d31e13\",\"12\":\"v-42d31e13#概述\",\"13\":\"v-42d31e13#结构\",\"14\":\"v-42d31e13#实例\",\"15\":\"v-42d31e13#优缺点\",\"16\":\"v-42d31e13#使用场景\",\"17\":\"v-42d31e13#模式扩展\",\"18\":\"v-42d31e13#创建者模式对比\",\"19\":\"v-42d31e13#工厂方法模式vs建造者模式\",\"20\":\"v-42d31e13#抽象工厂模式vs建造者模式\",\"21\":\"v-c683763a\",\"22\":\"v-c683763a#单例模式\",\"23\":\"v-c683763a#工厂模式\",\"24\":\"v-4b132bf8\",\"25\":\"v-4b132bf8#概述\",\"26\":\"v-4b132bf8#简单工厂模式\",\"27\":\"v-4b132bf8#结构\",\"28\":\"v-4b132bf8#实现\",\"29\":\"v-4b132bf8#优缺点\",\"30\":\"v-4b132bf8#扩展\",\"31\":\"v-4b132bf8#工厂方法模式\",\"32\":\"v-4b132bf8#概念\",\"33\":\"v-4b132bf8#结构-1\",\"34\":\"v-4b132bf8#实现-1\",\"35\":\"v-4b132bf8#优缺点-1\",\"36\":\"v-4b132bf8#抽象工厂模式\",\"37\":\"v-4b132bf8#概念-1\",\"38\":\"v-4b132bf8#结构-2\",\"39\":\"v-4b132bf8#实现-2\",\"40\":\"v-4b132bf8#优缺点-2\",\"41\":\"v-4b132bf8#使用场景\",\"42\":\"v-4b132bf8#模式扩展\",\"43\":\"v-4b132bf8#jdk源码解析-collection-iterator方法\",\"44\":\"v-f06d0324\",\"45\":\"v-f06d0324#概述\",\"46\":\"v-f06d0324#结构\",\"47\":\"v-f06d0324#示例\",\"48\":\"v-41c3c8a8\",\"49\":\"v-41c3c8a8#概述\",\"50\":\"v-41c3c8a8#结构\",\"51\":\"v-41c3c8a8#实现\",\"52\":\"v-41c3c8a8#案例\",\"53\":\"v-41c3c8a8#使用场景\",\"54\":\"v-41c3c8a8#扩展-深克隆\",\"55\":\"v-3b988860\",\"56\":\"v-3b988860#概述\",\"57\":\"v-3b988860#结构\",\"58\":\"v-3b988860#静态代理\",\"59\":\"v-3b988860#jdk动态代理\",\"60\":\"v-3b988860#cglib动态代理\",\"61\":\"v-3b988860#三种代理的对比\",\"62\":\"v-3b988860#优缺点\",\"63\":\"v-3b988860#使用场景\",\"64\":\"v-5e039b3a\",\"65\":\"v-5e039b3a#单例模式的结构\",\"66\":\"v-5e039b3a#单例模式的实现\",\"67\":\"v-5e039b3a#存在的问题\",\"68\":\"v-5e039b3a#问题演示\",\"69\":\"v-5e039b3a#问题的解决\",\"70\":\"v-5e039b3a#jdk源码解析-runtime类\",\"71\":\"v-75236f30\",\"72\":\"v-75236f30#开闭原则\",\"73\":\"v-75236f30#里氏代换原则\",\"74\":\"v-75236f30#依赖倒转原则\",\"75\":\"v-75236f30#接口隔离原则\",\"76\":\"v-75236f30#迪米特法则\",\"77\":\"v-75236f30#合成复用原则\",\"78\":\"v-1e9c07f1\",\"79\":\"v-1e9c07f1#概述\",\"80\":\"v-1e9c07f1#结构\",\"81\":\"v-1e9c07f1#示例\",\"82\":\"v-4d746b4a\",\"83\":\"v-4d746b4a#概述\",\"84\":\"v-4d746b4a#结构\",\"85\":\"v-4d746b4a#案例实现\",\"86\":\"v-4d746b4a#优缺点\",\"87\":\"v-4d746b4a#适用场景\",\"88\":\"v-4d746b4a#jdk源码解析\",\"89\":\"v-eda93786\",\"90\":\"v-eda93786#一、maven简介\",\"91\":\"v-eda93786#_1-maven介绍\",\"92\":\"v-eda93786#_2-maven功能配置\",\"93\":\"v-eda93786#二、基于idea进行maven工程构建\",\"94\":\"v-eda93786#_1-构建概念和构建过程\",\"95\":\"v-eda93786#_2-命令方式项目构建\",\"96\":\"v-eda93786#三、基于idea-进行maven依赖管理\",\"97\":\"v-eda93786#_1-依赖管理概念\",\"98\":\"v-eda93786#_2-maven工程核心信息配置和解读-gavp\",\"99\":\"v-eda93786#_3-maven工程依赖管理配置\",\"100\":\"v-eda93786#_4-依赖范围\",\"101\":\"v-eda93786#_5-maven工程依赖下载失败错误解决-重点\",\"102\":\"v-eda93786#_6-maven工程build构建配置\",\"103\":\"v-eda93786#四、maven依赖传递和依赖冲突\",\"104\":\"v-eda93786#_1-maven依赖传递特性\",\"105\":\"v-eda93786#_2-maven依赖冲突特性\",\"106\":\"v-eda93786#五、maven工程继承和聚合关系\",\"107\":\"v-eda93786#_1-maven工程继承关系\",\"108\":\"v-eda93786#_2-maven工程聚合关系\",\"109\":\"v-eda93786#六、maven综合案例\",\"110\":\"v-eda93786#_1-项目需求和结构分析\",\"111\":\"v-eda93786#_2-项目搭建和统一构建\",\"112\":\"v-eda93786#_1父模块-micro-shop\",\"113\":\"v-eda93786#_2通用模块-common-service\",\"114\":\"v-eda93786#_3用户模块-user-service\",\"115\":\"v-eda93786#_4订单模块-order-service\",\"116\":\"v-dde31c18\",\"117\":\"v-dde31c18#附录\",\"118\":\"v-dde31c18#趣味应用\",\"119\":\"v-dde31c18#作者相关\",\"120\":\"v-dde31c18#博客\",\"121\":\"v-dde31c18#代码复现\",\"122\":\"v-b548c708\",\"123\":\"v-b548c708#附录\",\"124\":\"v-b548c708#生成对抗网络gan开山之作\",\"125\":\"v-b548c708#趣味demo\",\"126\":\"v-b548c708#作者相关\",\"127\":\"v-b548c708#博客\",\"128\":\"v-b548c708#代码复现\",\"129\":\"v-0a003464\",\"130\":\"v-0a003464#附录\",\"131\":\"v-0a003464#主页\",\"132\":\"v-0a003464#趣味案例\",\"133\":\"v-0a003464#代码\",\"134\":\"v-61b2520c\",\"135\":\"v-61b2520c#网络结构\",\"136\":\"v-61b2520c#backbone-darknet-53\",\"137\":\"v-61b2520c#neck\",\"138\":\"v-61b2520c#head\",\"139\":\"v-61b2520c#正负样本\",\"140\":\"v-61b2520c#损失函数\",\"141\":\"v-61b2520c#训练过程\",\"142\":\"v-61b2520c#测试过程\",\"143\":\"v-61b2520c#附录\",\"144\":\"v-61b2520c#官方\",\"145\":\"v-61b2520c#博客\",\"146\":\"v-61b2520c#代码复现\",\"147\":\"v-61b2520c#ms-coco目标检测数据集80个类别\",\"148\":\"v-2f366b20\",\"149\":\"v-2f366b20#_1\",\"150\":\"v-2f366b20#_2\",\"151\":\"v-2f366b20#_3\",\"152\":\"v-1d1fa55e\",\"153\":\"v-1d1fa55e#_1、操作系统的概念\",\"154\":\"v-1d1fa55e#_2、操作系统需要实现的功能\",\"155\":\"v-1d1fa55e#_3、操作系统的四个特征\",\"156\":\"v-1d1fa55e#_4、os的运行机制和体系结构\",\"157\":\"v-1d1fa55e#_5、中断\",\"158\":\"v-1d1fa55e#_6、系统调用\",\"159\":\"v-1d1fa55e#_7、进程\",\"160\":\"v-1d1fa55e#_8、进程的状态\",\"161\":\"v-1d1fa55e#_9、进程控制\",\"162\":\"v-1d1fa55e#_10、进程通信\",\"163\":\"v-1d1fa55e#_11、线程、多线程模型\",\"164\":\"v-1d1fa55e#_12、处理机的调度\",\"165\":\"v-1d1fa55e#_13、进程调度的时机、切换与过程的调度方式\",\"166\":\"v-1d1fa55e#_14、调度算法评价指标\",\"167\":\"v-1d1fa55e#_15、调度算法\",\"168\":\"v-1d1fa55e#_16、进程同步、进程互斥\",\"169\":\"v-1d1fa55e#_17、进程互斥的软件实现方法\",\"170\":\"v-1d1fa55e#_18、进程互斥的硬件实现方法\",\"171\":\"v-1d1fa55e#_19、信号量机制\",\"172\":\"v-1d1fa55e#_20、用信号量机制实现进程互斥、同步、前驱关系\",\"173\":\"v-1d1fa55e#_21、管程\",\"174\":\"v-1ed47dfd\",\"175\":\"v-1ed47dfd#_1、死锁的概念\",\"176\":\"v-1ed47dfd#_2、死锁的处理策略-预防死锁\",\"177\":\"v-1ed47dfd#_3、死锁的处理策略-避免死锁\",\"178\":\"v-1ed47dfd#_4、死锁的处理策略-检测和解除\",\"179\":\"v-1ed47dfd#_5、内存的基础知识\",\"180\":\"v-1ed47dfd#_6、内存管理的概念\",\"181\":\"v-1ed47dfd#_7、内存空间的扩充-覆盖与交换\",\"182\":\"v-1ed47dfd#_8、内存空间的分配-连续分配管理方式\",\"183\":\"v-1ed47dfd#_9、动态分区分配算法\",\"184\":\"v-1ed47dfd#_10、基本分页存储管理的基本概念\",\"185\":\"v-1ed47dfd#_11、基地址变换机构\",\"186\":\"v-1ed47dfd#_12、两级页表\",\"187\":\"v-1ed47dfd#_13、基本分段存储管理方式\",\"188\":\"v-1ed47dfd#_14、段页式管理方式\",\"189\":\"v-1ed47dfd#_15、虚拟内存的概念\",\"190\":\"v-1ed47dfd#_16、请求分页存储管理\",\"191\":\"v-1ed47dfd#_17、页面置换算法\",\"192\":\"v-1ed47dfd#_18、页面分配策略\",\"193\":\"v-2089569c\",\"194\":\"v-2089569c#_1、初识文件管理\",\"195\":\"v-2089569c#_2、文件的逻辑结构\",\"196\":\"v-2089569c#_3、文件目录\",\"197\":\"v-2089569c#_4、文件的物理结构\",\"198\":\"v-2089569c#_5、文件存储空间管理\",\"199\":\"v-2089569c#_6、文件的基本操作\",\"200\":\"v-2089569c#_7、文件共享\",\"201\":\"v-2089569c#_8、文件保护\",\"202\":\"v-2089569c#_9、文件系统的层次结构\",\"203\":\"v-2089569c#_10、磁盘的结构\",\"204\":\"v-2089569c#_11、磁盘调度算法\",\"205\":\"v-2089569c#_12、减少延迟时间的方法\",\"206\":\"v-2089569c#_13、磁盘的管理\",\"207\":\"v-2089569c#_14、i-o设备的基本概念和分类\",\"208\":\"v-2089569c#_15、i-o控制器\",\"209\":\"v-2089569c#_16、i-o控制方式\",\"210\":\"v-2089569c#_17、i-o软件层次结构\",\"211\":\"v-2089569c#_18、i-o核心子系统\",\"212\":\"v-2089569c#_19、假脱机技术\",\"213\":\"v-2089569c#_20、设备的分配与回收\",\"214\":\"v-2089569c#_21、缓冲区管理\",\"215\":\"v-127111b8\",\"216\":\"v-6f53fa1c\",\"217\":\"v-c9bbd27a\",\"218\":\"v-44f26549\",\"219\":\"v-44f26549#_1-数据仓库\",\"220\":\"v-44f26549#_1-1-数据仓库、数据库、数据集市\",\"221\":\"v-44f26549#_1-1-1-oltp、olap\",\"222\":\"v-44f26549#_1-1-2-数据仓库、数据库\",\"223\":\"v-44f26549#_1-1-3-数据仓库、数据集市\",\"224\":\"v-44f26549#_1-2-数据仓库分层架构\",\"225\":\"v-44f26549#_1-2-1-ods层-operation-data-store\",\"226\":\"v-44f26549#_1-2-2-dw层-data-warehouse\",\"227\":\"v-44f26549#_1-2-3-da层-或ads层\",\"228\":\"v-44f26549#_1-2-4-etl、elt\",\"229\":\"v-44f26549#_2-apache-hive-入门\",\"230\":\"v-44f26549#_2-1-apache-hive-架构、组件\",\"231\":\"v-44f26549#_2-1-1-架构图\",\"232\":\"v-44f26549#_2-1-2-组件\",\"233\":\"v-44f26549#_2-2-apache-hive-数据模型\",\"234\":\"v-44f26549#_2-2-1-databases-数据库\",\"235\":\"v-44f26549#_2-2-2-tables-表\",\"236\":\"v-44f26549#_2-2-3-partitions-分区\",\"237\":\"v-44f26549#_2-2-4-buckets-分桶\",\"238\":\"v-44f26549#_2-3-apache-hive-元数据\",\"239\":\"v-44f26549#_2-3-1-hive-metadata\",\"240\":\"v-44f26549#_2-3-2-hive-metastore\",\"241\":\"v-44f26549#_2-4-metastore-三种配置方式\",\"242\":\"v-44f26549#_2-4-1-内嵌模式\",\"243\":\"v-44f26549#_2-4-2-本地模式\",\"244\":\"v-44f26549#_2-4-3-远程模式\",\"245\":\"v-46a73de8\",\"246\":\"v-46a73de8#_1-hive-sql-ddl建表基础语法\",\"247\":\"v-46a73de8#_1-1-hive建表完整语法树\",\"248\":\"v-46a73de8#_1-2-hive数据类型详解\",\"249\":\"v-46a73de8#_1-3-hive读写文件机制\",\"250\":\"v-46a73de8#_1-3-1-hive读写文件流程\",\"251\":\"v-46a73de8#_1-3-2-serde相关语法\",\"252\":\"v-46a73de8#_1-3-3-lazysimpleserde分隔符指定\",\"253\":\"v-46a73de8#_1-4-hive数据存储路径\",\"254\":\"v-46a73de8#_1-4-1-默认存储路径\",\"255\":\"v-46a73de8#_1-4-2-指定存储路径\",\"256\":\"v-46a73de8#_1-5-基础建表语法联系\",\"257\":\"v-46a73de8#_2-hive-sql-ddl-建表高阶语法\",\"258\":\"v-46a73de8#_2-1-hive-内部表、外部表\",\"259\":\"v-46a73de8#_2-2-hive-partitioned-tables-分区表\",\"260\":\"v-46a73de8#_2-2-1-创建分区表\",\"261\":\"v-46a73de8#_2-2-2-分区表数据加载\",\"262\":\"v-46a73de8#_2-2-3-多重分区\",\"263\":\"v-46a73de8#_2-3-hive-bucketed-tables-分桶表\",\"264\":\"v-46a73de8#_2-3-1-基本语法\",\"265\":\"v-46a73de8#_2-3-2-创建分桶表\",\"266\":\"v-46a73de8#_2-3-3-分桶表数据加载\",\"267\":\"v-46a73de8#_2-4-hive-transactional-tables-事务表\",\"268\":\"v-46a73de8#_2-4-1-创建事务表\",\"269\":\"v-46a73de8#_2-5-hive-view-视图\",\"270\":\"v-46a73de8#_2-5-1-视图的相关概念\",\"271\":\"v-46a73de8#_2-5-2-视图的相关语法\",\"272\":\"v-46a73de8#_2-5-3-使用视图的好处\",\"273\":\"v-46a73de8#_2-6-materialized-views物化视图\",\"274\":\"v-46a73de8#_2-6-1-物化视图相关概念\",\"275\":\"v-46a73de8#_2-6-2-物化视图和视图的区别\",\"276\":\"v-46a73de8#_2-6-3-物化视图相关语法\",\"277\":\"v-46a73de8#_3-hive-sql-ddl-其他语法\",\"278\":\"v-46a73de8#_3-1-database-schema-数据库-ddl-操作\",\"279\":\"v-46a73de8#_3-2-table-表-ddl操作\",\"280\":\"v-46a73de8#_3-3-partition-分区-ddl操作\",\"281\":\"v-46a73de8#_3-3-1-msck-修复分区\",\"282\":\"v-485c1687\",\"283\":\"v-485c1687#_1-hive-sql-dml-load加载数据\",\"284\":\"v-485c1687#_1-1-基本操作\",\"285\":\"v-485c1687#_1-2-hive3-0-新特性\",\"286\":\"v-485c1687#_2-hive-sql-dml-insert插入数据\",\"287\":\"v-485c1687#_2-1-基本操作\",\"288\":\"v-485c1687#_2-2-from-多重插入\",\"289\":\"v-485c1687#_2-3-dynamic-partition-inserts-动态分区插入\",\"290\":\"v-485c1687#_2-4-insert-directory导出数据\",\"291\":\"v-485c1687#_3-hive-transaction-事务表\",\"292\":\"v-485c1687#_3-1-实现原理\",\"293\":\"v-485c1687#_3-1-1-delta文件详解\",\"294\":\"v-485c1687#_3-1-2-合并器\",\"295\":\"v-485c1687#_3-2-hive-事务表使用设置与局限性\",\"296\":\"v-485c1687#_3-2-1-局限性\",\"297\":\"v-485c1687#_3-2-2-参数设置\",\"298\":\"v-485c1687#_3-3-使用事务表\",\"299\":\"v-485c1687#_4-hive-sql-dml-update、delete\",\"300\":\"v-485c1687#_5-hive-sql-dql-select-查询数据\",\"301\":\"v-485c1687#_5-1-hive-sql-select查询基础语法\",\"302\":\"v-485c1687#_5-1-1-select-expr\",\"303\":\"v-485c1687#_5-1-2-all-、distinct\",\"304\":\"v-485c1687#_5-1-3-where\",\"305\":\"v-485c1687#_5-1-4-分区查询\",\"306\":\"v-485c1687#_5-1-5-group-by\",\"307\":\"v-485c1687#_5-1-6-having\",\"308\":\"v-485c1687#_5-1-7-having和where的区别\",\"309\":\"v-485c1687#_5-1-8-limit\",\"310\":\"v-485c1687#_5-1-9-执行顺序\",\"311\":\"v-485c1687#_5-2-hive-sql-select查询高阶语法\",\"312\":\"v-485c1687#_5-2-1-order-by\",\"313\":\"v-485c1687#_5-2-2-cluster-by\",\"314\":\"v-485c1687#_5-2-3-cluster、distribute、sort、order-by对比\",\"315\":\"v-485c1687#_5-2-4-union联合查询\",\"316\":\"v-485c1687#_5-2-5-form-子句中的子查询\",\"317\":\"v-485c1687#_5-2-6-where-子句中的子查询\",\"318\":\"v-485c1687#_5-2-7-common-table-expressions-cte\",\"319\":\"v-485c1687#_6-hive-sql-join连接操作\",\"320\":\"v-485c1687#_6-1-inner-join-内连接\",\"321\":\"v-485c1687#_6-2-left-join-左连接\",\"322\":\"v-485c1687#_6-3-right-join-右连接\",\"323\":\"v-485c1687#_6-4-full-outer-join-全外连接\",\"324\":\"v-485c1687#_6-5-left-semi-join-左半开连接\",\"325\":\"v-485c1687#_6-6-cross-join-交叉连接\",\"326\":\"v-485c1687#_6-7-hive-join使用注意事项\",\"327\":\"v-4a10ef26\",\"328\":\"v-4a10ef26#_1-hive内置运算符\",\"329\":\"v-4a10ef26#_1-1-测试环境准备\",\"330\":\"v-4a10ef26#_1-2-关系运算符\",\"331\":\"v-4a10ef26#_1-3-算术运算符\",\"332\":\"v-4a10ef26#_1-4-逻辑运算符\",\"333\":\"v-4a10ef26#_2-hive-函数入门\",\"334\":\"v-4a10ef26#_2-1-hive函数概述及分类标准\",\"335\":\"v-4a10ef26#_2-2-hive内置函数\",\"336\":\"v-4a10ef26#_2-2-1-字符串函数\",\"337\":\"v-4a10ef26#_2-2-2-日期函数\",\"338\":\"v-4a10ef26#_2-2-3-数学函数\",\"339\":\"v-4a10ef26#_2-2-4-集合函数\",\"340\":\"v-4a10ef26#_2-2-5-条件函数\",\"341\":\"v-4a10ef26#_2-2-6-类型转换函数\",\"342\":\"v-4a10ef26#_2-2-7-数据脱敏函数\",\"343\":\"v-4a10ef26#_2-2-8-其他杂项函数\",\"344\":\"v-4a10ef26#_2-3-案例-udf实现手机号加密\",\"345\":\"v-4a10ef26#_3-hive-函数高阶\",\"346\":\"v-4a10ef26#_3-1-udtf之explode函数\",\"347\":\"v-4a10ef26#_3-1-1-示例\",\"348\":\"v-4a10ef26#_3-1-2-案例-nba总冠军球队名单分析\",\"349\":\"v-4a10ef26#_3-1-3-hive-lateral-view-侧视图\",\"350\":\"v-4a10ef26#_3-2-udaf之聚合函数\",\"351\":\"v-4a10ef26#_3-2-1-基础聚合\",\"352\":\"v-4a10ef26#_3-2-2-增强聚合\",\"353\":\"v-4a10ef26#grouping-sets\",\"354\":\"v-4a10ef26#cube\",\"355\":\"v-4a10ef26#rollup\",\"356\":\"v-4a10ef26#_3-3-窗口函数\",\"357\":\"v-4a10ef26#_3-3-1-示例\",\"358\":\"v-4a10ef26#_3-3-2-语法树\",\"359\":\"v-4a10ef26#_3-3-3-后续数据准备\",\"360\":\"v-4a10ef26#_3-3-4-窗口聚合函数\",\"361\":\"v-4a10ef26#_3-3-5-窗口表达式\",\"362\":\"v-4a10ef26#_3-3-6-窗口排序函数-topn\",\"363\":\"v-4a10ef26#row-number家族-topn\",\"364\":\"v-4a10ef26#ntile-frac-n-m\",\"365\":\"v-4a10ef26#_3-3-7-窗口分析函数\",\"366\":\"v-4a10ef26#_3-4-抽样函数\",\"367\":\"v-4a10ef26#_3-4-1-随机抽样\",\"368\":\"v-4a10ef26#_3-4-2-基于数据块抽样\",\"369\":\"v-4a10ef26#_3-4-3-基于分桶表抽样\",\"370\":\"v-4bc5c7c5\",\"371\":\"v-4bc5c7c5#_1-hive中多字节分隔符处理\",\"372\":\"v-4bc5c7c5#_1-1-问题和需求\",\"373\":\"v-4bc5c7c5#_1-2-解决方案一-替换分隔符\",\"374\":\"v-4bc5c7c5#_1-3-解决方案二-regexserde正则加载\",\"375\":\"v-4bc5c7c5#_1-4-解决方案三-自定义inputformat\",\"376\":\"v-4bc5c7c5#_2-url解析函数\",\"377\":\"v-4bc5c7c5#_2-1-parse-url\",\"378\":\"v-4bc5c7c5#_2-2-parse-url-tuple\",\"379\":\"v-4bc5c7c5#_3-行列转换应用与实现\",\"380\":\"v-4bc5c7c5#_3-1-行转列-多行转多列\",\"381\":\"v-4bc5c7c5#_3-1-1-需求\",\"382\":\"v-4bc5c7c5#_3-1-2-实现\",\"383\":\"v-4bc5c7c5#_3-2-行转列-多行转单列\",\"384\":\"v-4bc5c7c5#_3-2-1-需求\",\"385\":\"v-4bc5c7c5#_3-2-2-实现\",\"386\":\"v-4bc5c7c5#_3-3-列转行-多列转多行\",\"387\":\"v-4bc5c7c5#_3-3-1-需求\",\"388\":\"v-4bc5c7c5#_3-3-2-实现\",\"389\":\"v-4bc5c7c5#_3-4-列转行-单列转多行\",\"390\":\"v-4bc5c7c5#_3-4-1-需求\",\"391\":\"v-4bc5c7c5#_3-4-2-实现\",\"392\":\"v-4bc5c7c5#_4-json数据处理\",\"393\":\"v-4bc5c7c5#_4-1-hive中的json处理方式\",\"394\":\"v-4bc5c7c5#_4-2-json函数\",\"395\":\"v-4bc5c7c5#_4-2-1-get-json-object\",\"396\":\"v-4bc5c7c5#_4-2-2-json-tuple\",\"397\":\"v-4bc5c7c5#_4-3-json-serde\",\"398\":\"v-4bc5c7c5#_5-窗口函数应用实例\",\"399\":\"v-4bc5c7c5#_5-1-案例1-连续登录用户\",\"400\":\"v-4bc5c7c5#_5-1-1-实现\",\"401\":\"v-4bc5c7c5#_5-2-案例2-级联累加求和\",\"402\":\"v-4bc5c7c5#_5-2-1-实现\",\"403\":\"v-4bc5c7c5#_5-3-案例3-分组topn\",\"404\":\"v-4bc5c7c5#_5-3-1-实现\",\"405\":\"v-4bc5c7c5#_6-拉链表的设计与实现\",\"406\":\"v-4bc5c7c5#_6-1-实现过程\",\"407\":\"v-4bc5c7c5#_6-1-1-创建拉链表\",\"408\":\"v-4bc5c7c5#_6-1-2-创建增量表\",\"409\":\"v-4bc5c7c5#_6-1-3-临时表操作\",\"410\":\"v-4bc5c7c5#_6-1-4-覆盖到拉链表\",\"411\":\"v-4d7aa064\",\"412\":\"v-4d7aa064#_1-hive表设计优化\",\"413\":\"v-4d7aa064#_1-1-分区表结构设计\",\"414\":\"v-4d7aa064#_1-1-1-普通表结构问题\",\"415\":\"v-4d7aa064#_1-1-2-分区设计思想\",\"416\":\"v-4d7aa064#_1-2-分桶表结构设计\",\"417\":\"v-4d7aa064#_1-2-1-分桶表设计思想\",\"418\":\"v-4d7aa064#_1-2-2-优化join\",\"419\":\"v-4d7aa064#_1-3-索引设计\",\"420\":\"v-4d7aa064#_1-3-1-hive中的索引\",\"421\":\"v-4d7aa064#_1-3-2-索引的原理\",\"422\":\"v-4d7aa064#_1-3-3-索引的目的\",\"423\":\"v-4d7aa064#_1-3-4-索引的使用\",\"424\":\"v-4d7aa064#_1-3-5-索引的问题\",\"425\":\"v-4d7aa064#_2-hive表数据优化\",\"426\":\"v-4d7aa064#_2-1-文件格式\",\"427\":\"v-4d7aa064#_2-1-1-textfile\",\"428\":\"v-4d7aa064#_2-1-2-sequencefile\",\"429\":\"v-4d7aa064#_2-1-3-parquet\",\"430\":\"v-4d7aa064#_2-1-4-orc\",\"431\":\"v-4d7aa064#_2-2-数据压缩\",\"432\":\"v-4d7aa064#_2-2-1-概述\",\"433\":\"v-4d7aa064#_2-2-2-使用\",\"434\":\"v-4d7aa064#_2-3-存储优化\",\"435\":\"v-4d7aa064#_2-3-1-避免小文件生成\",\"436\":\"v-4d7aa064#_2-3-2-如何读取小文件\",\"437\":\"v-4d7aa064#_2-3-3-orc文件索引\",\"438\":\"v-4d7aa064#_2-3-4-orc矢量查询\",\"439\":\"v-4d7aa064#_3-job作业执行优化\",\"440\":\"v-4d7aa064#_3-1-explain查询计划\",\"441\":\"v-4d7aa064#_3-1-1-语法\",\"442\":\"v-4d7aa064#_3-1-2-输出组成\",\"443\":\"v-4d7aa064#_3-2-mapreduce属性优化\",\"444\":\"v-4d7aa064#_3-2-1-本地模式\",\"445\":\"v-4d7aa064#_3-2-2-jvm重用\",\"446\":\"v-4d7aa064#_3-2-3-并行执行\",\"447\":\"v-4d7aa064#_3-3-join优化\",\"448\":\"v-4d7aa064#_3-3-1-map-join\",\"449\":\"v-4d7aa064#_3-3-2-reduce-join\",\"450\":\"v-4d7aa064#_3-3-3-bucket-join\",\"451\":\"v-4d7aa064#_3-4-优化器\",\"452\":\"v-4d7aa064#_3-4-1-背景\",\"453\":\"v-4d7aa064#_3-4-2-使用\",\"454\":\"v-4d7aa064#_3-4-3-优化器介绍\",\"455\":\"v-4d7aa064#背景\",\"456\":\"v-4d7aa064#rbo\",\"457\":\"v-4d7aa064#cbo\",\"458\":\"v-4d7aa064#anayze分析器\",\"459\":\"v-4d7aa064#_3-5-谓词下推-ppd\",\"460\":\"v-4d7aa064#_3-5-1-示例\",\"461\":\"v-4d7aa064#_3-5-2-规则\",\"462\":\"v-4d7aa064#_3-6-数据倾斜\",\"463\":\"v-4d7aa064#_3-6-1-group-by-count-distinct-时的倾斜\",\"464\":\"v-4d7aa064#方案一-开启map端聚合\",\"465\":\"v-4d7aa064#方案二-实现随机分区\",\"466\":\"v-4d7aa064#方案三-数据倾斜时自动负载均衡\",\"467\":\"v-4d7aa064#_3-6-2-join时的倾斜\",\"468\":\"v-4d7aa064#方案一-提前过滤-将大数据变成小数据-实现map-join\",\"469\":\"v-4d7aa064#方案二-使用bucket-join\",\"470\":\"v-4d7aa064#方案三-使用skew-join\",\"471\":\"v-4d7aa064#_4-hive3新特性\",\"472\":\"v-4d7aa064#_4-1-hive-on-tez\",\"473\":\"v-4d7aa064#_4-2-hive-llap更新\",\"474\":\"v-4d7aa064#_4-3-metastore独立模式\",\"475\":\"v-8ff06b78\",\"476\":\"v-8ff06b78#题目描述\",\"477\":\"v-8ff06b78#解法1-存在问题\",\"478\":\"v-8ff06b78#解法2\",\"479\":\"v-caef7fe4\",\"480\":\"v-caef7fe4#建表规约\",\"481\":\"v-caef7fe4#索引规约\",\"482\":\"v-caef7fe4#sql语句\",\"483\":\"v-caef7fe4#orm映射\",\"484\":\"v-c682b678\",\"485\":\"v-c682b678#说说对mysql索引的理解\",\"486\":\"v-c682b678#为了减少io-索引树会一次性加载吗\",\"487\":\"v-c682b678#b-树的存储能力如何-为何说一般查找行记录-最多只需1-3次磁盘io-为什么索引使用b-树\",\"488\":\"v-c682b678#为什么b-树比b树更适合做索引\",\"489\":\"v-c682b678#innodb为什么不建议用过长的字段作为主键\",\"490\":\"v-c682b678#innodb为什么使用自增主键是一个很好的选择\",\"491\":\"v-c682b678#hash结构效率高-那为什么还要使用b-树索引呢\",\"492\":\"v-c682b678#索引的分类\",\"493\":\"v-c682b678#哪些情况适合创建索引\",\"494\":\"v-c682b678#哪些情况不适合创建索引\",\"495\":\"v-c682b678#索引下推\",\"496\":\"v-c682b678#exists和in的区分\",\"497\":\"v-c682b678#count-count-1-和count-具体字段\",\"498\":\"v-c682b678#关于select\",\"499\":\"v-c682b678#多使用commit\",\"500\":\"v-c682b678#主键如何设计\",\"501\":\"v-c682b678#自增id的问题\",\"502\":\"v-c682b678#推荐的主键设计\",\"503\":\"v-c682b678#谈谈你对mvcc的了解\",\"504\":\"v-c682b678#where和having的区别\",\"505\":\"v-c682b678#数据库索引失效了怎么办\",\"506\":\"v-c682b678#事务的四大特性以及如何实现\",\"507\":\"v-c682b678#mysql的悲观锁和乐观锁\",\"508\":\"v-c682b678#根据锁的类型分类\",\"509\":\"v-c682b678#根据锁的粒度进行分类\",\"510\":\"v-c682b678#表锁\",\"511\":\"v-c682b678#行锁\",\"512\":\"v-c682b678#innodb中行级锁是怎么实现的\",\"513\":\"v-c682b678#数据库死锁问题以及解决办法\",\"514\":\"v-1b639f8b\",\"515\":\"v-1b639f8b#redis常见数据结构以及使用场景\",\"516\":\"v-1b639f8b#redis到底是单线程还是多线程\",\"517\":\"v-1b639f8b#redis单线程为什么还快\",\"518\":\"v-1b639f8b#redis底层数据是如何用跳表来存储的\",\"519\":\"v-1b639f8b#redis-key过期了为什么内存没释放\",\"520\":\"v-1b639f8b#过期数据删除策略\",\"521\":\"v-1b639f8b#redis-key没设置过期时间为什么被redis主动删除了\",\"522\":\"v-1b639f8b#redis内存淘汰机制\",\"523\":\"v-1b639f8b#删除key的命令会阻塞redis吗\",\"524\":\"v-1b639f8b#redis高可用方案\",\"525\":\"v-1b639f8b#主从模式\",\"526\":\"v-1b639f8b#哨兵模式\",\"527\":\"v-1b639f8b#集群模式\",\"528\":\"v-1b639f8b#reids集群模式下数据hash分片算法\",\"529\":\"v-1b639f8b#redis执行命令出现死循环bug\",\"530\":\"v-1b639f8b#主从切换导致缓存雪崩具体场景\",\"531\":\"v-21d65c9c\",\"532\":\"v-21d65c9c#start-和run\",\"533\":\"v-21d65c9c#sleep-与yield\",\"534\":\"v-21d65c9c#interrupt\",\"535\":\"v-21d65c9c#线程优先级\",\"536\":\"v-21d65c9c#两阶段终止模式\",\"537\":\"v-21d65c9c#守护线程\",\"538\":\"v-21d65c9c#线程状态\",\"539\":\"v-21d65c9c#变量的线程安全分析\",\"540\":\"v-21d65c9c#对象头\",\"541\":\"v-21d65c9c#monitor原理\",\"542\":\"v-21d65c9c#自旋优化\",\"543\":\"v-21d65c9c#轻量级锁\",\"544\":\"v-21d65c9c#偏向锁\",\"545\":\"v-21d65c9c#wait-和notify\",\"546\":\"v-21d65c9c#sleep-和wait-的区别\",\"547\":\"v-21d65c9c#保护性暂停模式\",\"548\":\"v-21d65c9c#生产者消费者模式\",\"549\":\"v-21d65c9c#park-和unpark\",\"550\":\"v-21d65c9c#死锁-活锁-饥饿\",\"551\":\"v-21d65c9c#死锁\",\"552\":\"v-21d65c9c#活锁\",\"553\":\"v-21d65c9c#饥饿\",\"554\":\"v-21d65c9c#固定线程运行顺序\",\"555\":\"v-21d65c9c#线程交替输出\",\"556\":\"v-21d65c9c#并发编程的三大特性\",\"557\":\"v-21d65c9c#volatile原理\",\"558\":\"v-21d65c9c#volatile和synchronized\",\"559\":\"v-21d65c9c#volatile和synchronized在有序性上的不同\",\"560\":\"v-21d65c9c#i-是否线程安全\",\"561\":\"v-21d65c9c#cas的特点\",\"562\":\"v-21d65c9c#atomic原子类\",\"563\":\"v-21d65c9c#原子引用aba问题\",\"564\":\"v-21d65c9c#longadder原理\",\"565\":\"v-21d65c9c#unsafe\",\"566\":\"v-21d65c9c#不可变类\",\"567\":\"v-21d65c9c#final原理\",\"568\":\"v-21d65c9c#享元模式\",\"569\":\"v-21d65c9c#线程池\",\"570\":\"v-21d65c9c#线程池的好处\",\"571\":\"v-21d65c9c#线程池状态\",\"572\":\"v-21d65c9c#threadpoolexecutor参数\",\"573\":\"v-21d65c9c#拒绝策略\",\"574\":\"v-21d65c9c#executors创建的线程池\",\"575\":\"v-21d65c9c#执行-execute-方法和-submit-方法的区别是什么呢\",\"576\":\"v-21d65c9c#线程池创建多少线程合适\",\"577\":\"v-21d65c9c#threadlocal\",\"578\":\"v-21d65c9c#copyonwritearraylist\",\"579\":\"v-21d65c9c#concurrenthashmap\",\"580\":\"v-21d65c9c#aqs\",\"581\":\"v-21d65c9c#aqs是什么\",\"582\":\"v-21d65c9c#状态变量state\",\"583\":\"v-21d65c9c#aqs队列\",\"584\":\"v-21d65c9c#condition队列\",\"585\":\"v-21d65c9c#模板方法\",\"586\":\"v-21d65c9c#reentrantlock\",\"587\":\"v-21d65c9c#reentrantlock与synchronized的区别\",\"588\":\"v-21d65c9c#reentrantlock的公平锁和非公平锁\",\"589\":\"v-21d65c9c#reentrantreadwritelock\",\"590\":\"v-21d65c9c#stampedlock\",\"591\":\"v-21d65c9c#semaphore\",\"592\":\"v-21d65c9c#countdownlatch\",\"593\":\"v-21d65c9c#cyclicbarrier\",\"594\":\"v-79599e71\",\"595\":\"v-79599e71#接口和抽象类有什么共同点和区别\",\"596\":\"v-79599e71#equals和hashcode\",\"597\":\"v-79599e71#与equals的区别\",\"598\":\"v-79599e71#包装类型的常量池技术\",\"599\":\"v-79599e71#自动装箱与自动拆箱\",\"600\":\"v-79599e71#arraylist和linkedlist的区别\",\"601\":\"v-79599e71#arraylist的扩容机制\",\"602\":\"v-79599e71#list删除元素问题\",\"603\":\"v-79599e71#comparable和comparator的区别\",\"604\":\"v-79599e71#hashset、linkedhashset和treeset三者的异同\",\"605\":\"v-79599e71#hashmap的底层实现\",\"606\":\"v-79599e71#hashmap的扩容机制\",\"607\":\"v-79599e71#hashmap在jdk-1-7的死链问题\",\"608\":\"v-79599e71#bio-nio-aio\",\"609\":\"v-79599e71#bio\",\"610\":\"v-79599e71#nio\",\"611\":\"v-79599e71#aio\",\"612\":\"v-79599e71#总结\",\"613\":\"v-e7963868\",\"614\":\"v-e7963868#lambda\",\"615\":\"v-e7963868#stream\",\"616\":\"v-e7963868#筛选与切片\",\"617\":\"v-e7963868#映射\",\"618\":\"v-e7963868#排序\",\"619\":\"v-e7963868#查找与匹配\",\"620\":\"v-e7963868#规约\",\"621\":\"v-e7963868#收集\",\"622\":\"v-6d18ab1e\",\"623\":\"v-6d18ab1e#双亲委派机制\",\"624\":\"v-6d18ab1e#沙箱安全机制\",\"625\":\"v-6d18ab1e#使用pc寄存器存储字节码指令地址有什么用呢\",\"626\":\"v-6d18ab1e#举例栈溢出的情况\",\"627\":\"v-6d18ab1e#方法中定义的局部变量是否线程安全\",\"628\":\"v-6d18ab1e#minor-gc、major-gc、full-gc\",\"629\":\"v-6d18ab1e#创建对象的方式\",\"630\":\"v-6d18ab1e#创建对象的步骤\",\"631\":\"v-6d18ab1e#对象的内存布局\",\"632\":\"v-6d18ab1e#字符串拼接\",\"633\":\"v-6d18ab1e#gc大厂面试题\",\"634\":\"v-6d18ab1e#增量收集算法\",\"635\":\"v-6d18ab1e#system-gc-的理解\",\"636\":\"v-6d18ab1e#内存溢出和内存泄漏的原因\",\"637\":\"v-6d18ab1e#评估gc的性能指标\",\"638\":\"v-6d18ab1e#_7种经典的垃圾回收器\",\"639\":\"v-6d18ab1e#垃圾回收器的选择\",\"640\":\"v-6d18ab1e#jdk-后续版本中-cms-的变化\",\"641\":\"v-ef155d36\",\"642\":\"v-ef155d36#排序\",\"643\":\"v-ef155d36#选择排序\",\"644\":\"v-ef155d36#插入排序\",\"645\":\"v-ef155d36#快排\",\"646\":\"v-ef155d36#埃氏筛\",\"647\":\"v-ef155d36#背包\",\"648\":\"v-ef155d36#_01背包\",\"649\":\"v-ef155d36#完全背包\",\"650\":\"v-eafd00da\",\"651\":\"v-eafd00da#get和post的区别\",\"652\":\"v-eafd00da#输入网址到网页显示期间发生了什么\",\"653\":\"v-eafd00da@0\",\"654\":\"v-eafd00da@1\",\"655\":\"v-d2bd2386\",\"656\":\"v-d2bd2386#红黑树\",\"657\":\"v-d2bd2386#布隆过滤器\",\"658\":\"v-d2bd2386#什么是布隆过滤器\",\"659\":\"v-d2bd2386#布隆过滤器的原理介绍\",\"660\":\"v-d2bd2386#布隆过滤器使用场景\",\"661\":\"v-d2bd2386#sds\",\"662\":\"v-d2bd2386#c-语言字符串的缺陷\",\"663\":\"v-d2bd2386#sds-结构设计\",\"664\":\"v-d2bd2386#压缩列表\",\"665\":\"v-d2bd2386#压缩列表结构设计\",\"666\":\"v-d2bd2386#连锁更新\",\"667\":\"v-d2bd2386#压缩列表的缺陷\",\"668\":\"v-d2bd2386#前缀树-字典树\",\"669\":\"v-d2bd2386#二叉树构建\",\"670\":\"v-d2bd2386#图的构建\",\"671\":\"v-d2bd2386#并查集\",\"672\":\"v-d2bd2386#树状数组\",\"673\":\"v-d2bd2386#单点更新-区间求和\",\"674\":\"v-8d0611f0\",\"675\":\"v-8d0611f0#操作系统io介绍\",\"676\":\"v-8d0611f0#用户空间和内核空间-用户态和内核态\",\"677\":\"v-8d0611f0#文件描述符\",\"678\":\"v-8d0611f0#缓存-i-o\",\"679\":\"v-8d0611f0#i-o-模式\",\"680\":\"v-8d0611f0#select、poll和epoll的区别\",\"681\":\"v-8d0611f0#操作系统内存管理介绍\",\"682\":\"v-8d0611f0#内存管理主要是做什么\",\"683\":\"v-8d0611f0#常见的几种内存管理机制\",\"684\":\"v-8d0611f0#逻辑地址和物理地址\",\"685\":\"v-8d0611f0#为什么要有虚拟地址空间呢\",\"686\":\"v-8d0611f0#操作系统虚拟内存介绍\",\"687\":\"v-8d0611f0#局部性原理\",\"688\":\"v-8d0611f0#虚拟内存-虚拟存储器\",\"689\":\"v-8d0611f0#虚拟存储器的实现方法\",\"690\":\"v-8d0611f0#页面置换算法\",\"691\":\"v-494a56f8\",\"692\":\"v-494a56f8#粘包现象\",\"693\":\"v-494a56f8#半包现象\",\"694\":\"v-494a56f8#现象分析\",\"695\":\"v-494a56f8#解决方案\",\"696\":\"v-494a56f8#方法1-短链接\",\"697\":\"v-494a56f8#方法2-固定长度\",\"698\":\"v-494a56f8#方法3-固定分隔符\",\"699\":\"v-494a56f8#方法4-预设长度\",\"700\":\"v-7621adb3\",\"701\":\"v-7621adb3#聊天室业务介绍\",\"702\":\"v-7621adb3#聊天室业务-登录\",\"703\":\"v-7621adb3#聊天室业务-单聊\",\"704\":\"v-7621adb3#聊天室业务-群聊\",\"705\":\"v-7621adb3#聊天室业务-退出\",\"706\":\"v-7621adb3#聊天室业务-空闲检测\",\"707\":\"v-7621adb3#连接假死\",\"708\":\"v-672afe6e\",\"709\":\"v-672afe6e#为什么需要协议\",\"710\":\"v-672afe6e#redis-协议举例\",\"711\":\"v-672afe6e#http-协议举例\",\"712\":\"v-672afe6e#自定义协议要素\",\"713\":\"v-672afe6e#编解码器\",\"714\":\"v-672afe6e#什么时候可以加-sharable💡\",\"715\":\"v-1c913b6f\",\"716\":\"v-1c913b6f#概念\",\"717\":\"v-1c913b6f#示例1\",\"718\":\"v-1c913b6f#示例2\",\"719\":\"v-1c913b6f#背压\",\"720\":\"v-69732fad\",\"721\":\"v-69732fad#todo\",\"722\":\"v-16d38cb0\",\"723\":\"v-16d38cb0#扩展序列化算法\",\"724\":\"v-16d38cb0#参数调优\",\"725\":\"v-16d38cb0#_1-connect-timeout-millis\",\"726\":\"v-16d38cb0#_2-so-backlog\",\"727\":\"v-16d38cb0#_3-ulimit-n\",\"728\":\"v-16d38cb0#_4-tcp-nodelay\",\"729\":\"v-16d38cb0#_5-so-sndbuf-so-rcvbuf\",\"730\":\"v-16d38cb0#_6-allocator\",\"731\":\"v-16d38cb0#_7-rcvbuf-allocator\",\"732\":\"v-16d38cb0#rpc-框架\",\"733\":\"v-16d38cb0#_1-准备工作\",\"734\":\"v-16d38cb0#_2-服务器-handler\",\"735\":\"v-16d38cb0#_3-客户端代码第一版\",\"736\":\"v-16d38cb0#_4-客户端-handler-第一版\",\"737\":\"v-16d38cb0#_5-客户端代码-第二版\",\"738\":\"v-16d38cb0#_6-客户端-handler-第二版\",\"739\":\"v-821a7378\",\"740\":\"v-821a7378#启动剖析\",\"741\":\"v-821a7378#nioeventloop-剖析\",\"742\":\"v-821a7378#注意⚠️\",\"743\":\"v-821a7378#accept-剖析\",\"744\":\"v-821a7378#read-剖析\",\"745\":\"v-54862980\",\"746\":\"v-54862980#eventloop\",\"747\":\"v-54862980#优雅关闭💡\",\"748\":\"v-54862980#演示-nioeventloop-处理-io-事件\",\"749\":\"v-54862980#handler-执行中如何换人-💡\",\"750\":\"v-54862980#演示-nioeventloop-处理普通任务\",\"751\":\"v-54862980#演示-nioeventloop-处理定时任务\",\"752\":\"v-54862980#channel\",\"753\":\"v-54862980#channelfuture\",\"754\":\"v-54862980#closefuture\",\"755\":\"v-54862980#异步提升的是什么💡\",\"756\":\"v-54862980#future-promise\",\"757\":\"v-54862980#jdk-future\",\"758\":\"v-54862980#netty-future\",\"759\":\"v-54862980#promise\",\"760\":\"v-54862980#例1\",\"761\":\"v-54862980#例2\",\"762\":\"v-54862980#例3\",\"763\":\"v-54862980#例4\",\"764\":\"v-54862980#例5\",\"765\":\"v-54862980#例6\",\"766\":\"v-54862980#handler-pipeline\",\"767\":\"v-54862980#bytebuf\",\"768\":\"v-54862980#_1-创建\",\"769\":\"v-54862980#_2-直接内存-vs-堆内存\",\"770\":\"v-54862980#_3-池化-vs-非池化\",\"771\":\"v-54862980#_4-组成\",\"772\":\"v-54862980#_5-写入\",\"773\":\"v-54862980#_6-扩容\",\"774\":\"v-54862980#_7-读取\",\"775\":\"v-54862980#_8-retain-release\",\"776\":\"v-54862980#_9-slice\",\"777\":\"v-54862980#_10-duplicate\",\"778\":\"v-54862980#_11-copy\",\"779\":\"v-54862980#_12-compositebytebuf\",\"780\":\"v-54862980#_13-unpooled\",\"781\":\"v-54862980#bytebuf-优势💡\",\"782\":\"v-75b94215\",\"783\":\"v-75b94215#目标\",\"784\":\"v-75b94215#服务器端\",\"785\":\"v-75b94215#客户端\",\"786\":\"v-75b94215#流程梳理\",\"787\":\"v-75b94215#提示💡\",\"788\":\"v-2f1bb992\",\"789\":\"v-2f1bb992#netty-是什么\",\"790\":\"v-2f1bb992#netty-的作者\",\"791\":\"v-2f1bb992#netty-的地位\",\"792\":\"v-2f1bb992#netty-的优势\",\"793\":\"v-079c0eac\",\"794\":\"v-079c0eac#练习\",\"795\":\"v-079c0eac#读和写的误解💡\",\"796\":\"v-151d81e0\",\"797\":\"v-151d81e0#bytebuffer-正确使用姿势\",\"798\":\"v-151d81e0#bytebuffer-结构\",\"799\":\"v-151d81e0#调试工具类💡\",\"800\":\"v-151d81e0#bytebuffer-常见方法\",\"801\":\"v-151d81e0#分配空间\",\"802\":\"v-151d81e0#向-buffer-写入数据\",\"803\":\"v-151d81e0#从-buffer-读取数据\",\"804\":\"v-151d81e0#mark-和-reset\",\"805\":\"v-151d81e0#字符串与-bytebuffer-互转\",\"806\":\"v-151d81e0#buffer-的线程安全⚠️\",\"807\":\"v-151d81e0#scattering-reads分散读\",\"808\":\"v-151d81e0#gathering-writes集中写\",\"809\":\"v-151d81e0#练习\",\"810\":\"v-26c53942\",\"811\":\"v-26c53942#filechannel\",\"812\":\"v-26c53942#filechannel-工作模式⚠️\",\"813\":\"v-26c53942#获取\",\"814\":\"v-26c53942#读取\",\"815\":\"v-26c53942#写入\",\"816\":\"v-26c53942#关闭\",\"817\":\"v-26c53942#位置\",\"818\":\"v-26c53942#大小\",\"819\":\"v-26c53942#强制写入\",\"820\":\"v-26c53942#两个-channel-传输数据\",\"821\":\"v-26c53942#path\",\"822\":\"v-26c53942#files\",\"823\":\"v-26c53942#删除很危险⚠️\",\"824\":\"v-04a5c7f2\",\"825\":\"v-04a5c7f2#非阻塞-vs-阻塞\",\"826\":\"v-04a5c7f2#阻塞\",\"827\":\"v-04a5c7f2#非阻塞\",\"828\":\"v-04a5c7f2#多路复用\",\"829\":\"v-04a5c7f2#selector\",\"830\":\"v-04a5c7f2#创建\",\"831\":\"v-04a5c7f2#绑定-channel-事件\",\"832\":\"v-04a5c7f2#监听-channel-事件\",\"833\":\"v-04a5c7f2#select-何时不阻塞💡\",\"834\":\"v-04a5c7f2#处理-accept-事件\",\"835\":\"v-04a5c7f2#事件发生后能否不处理💡\",\"836\":\"v-04a5c7f2#处理-read-事件\",\"837\":\"v-04a5c7f2#为何要-iter-remove-💡\",\"838\":\"v-04a5c7f2#cancel-的作用💡\",\"839\":\"v-04a5c7f2#不处理边界的问题⚠️\",\"840\":\"v-04a5c7f2#处理消息的边界\",\"841\":\"v-04a5c7f2#bytebuffer-大小分配\",\"842\":\"v-04a5c7f2#处理-write-事件\",\"843\":\"v-04a5c7f2#一次无法写完例子\",\"844\":\"v-04a5c7f2#write-为何要取消💡\",\"845\":\"v-04a5c7f2#更进一步\",\"846\":\"v-04a5c7f2#利用多线程优化💡\",\"847\":\"v-04a5c7f2#如何拿到-cpu-个数💡\",\"848\":\"v-04a5c7f2#udp\",\"849\":\"v-20d8b3e1\",\"850\":\"v-20d8b3e1#stream-vs-channel\",\"851\":\"v-20d8b3e1#io-模型\",\"852\":\"v-20d8b3e1#参考🔖\",\"853\":\"v-20d8b3e1#零拷贝\",\"854\":\"v-20d8b3e1#传统-io-问题\",\"855\":\"v-20d8b3e1#nio-优化\",\"856\":\"v-20d8b3e1#aio\",\"857\":\"v-20d8b3e1#文件-aio\",\"858\":\"v-20d8b3e1#守护线程💡\",\"859\":\"v-20d8b3e1#网络-aio\",\"860\":\"v-2ca4ecc4\",\"861\":\"v-2ca4ecc4#channel-buffer\",\"862\":\"v-2ca4ecc4#selector\",\"863\":\"v-2ca4ecc4#多线程版设计\",\"864\":\"v-2ca4ecc4#多线程版缺点⚠️\",\"865\":\"v-2ca4ecc4#线程池版设计\",\"866\":\"v-2ca4ecc4#线程池版缺点⚠️\",\"867\":\"v-2ca4ecc4#selector-版设计\",\"868\":\"v-0069c1a2\",\"869\":\"v-0069c1a2#_1-distcp\",\"870\":\"v-0069c1a2#_2-安全模式\",\"871\":\"v-0069c1a2#_3-hdfs高阶优化方案\",\"872\":\"v-0069c1a2#_3-1-短路本地读取\",\"873\":\"v-0069c1a2#_3-2-hdfs-block负载平衡器-balancer\",\"874\":\"v-0069c1a2#_3-3-磁盘均衡器-hdfs-disk-balancer-3-0\",\"875\":\"v-0069c1a2#_3-4-纠删码技术-erasure-coding-3-0\",\"876\":\"v-0069c1a2#hadoop纠删码算法启用isa-l加速库\",\"877\":\"v-0069c1a2#_4-hdfs动态节点管理\",\"878\":\"v-0069c1a2#_4-1-节点扩容\",\"879\":\"v-0069c1a2#_4-2-动态缩容\",\"880\":\"v-0069c1a2#_4-3-黑白名单机制\",\"881\":\"v-0069c1a2#_5-hdfs-ha高可用\",\"882\":\"v-0069c1a2#_5-1-背景知识\",\"883\":\"v-0069c1a2#_5-2-namenode单点故障问题\",\"884\":\"v-0069c1a2#_5-3-hdfs-ha解决方案-qjm\",\"885\":\"v-0069c1a2#zk-failover-controller-zkfc\",\"886\":\"v-0069c1a2#journal-node-jn\",\"887\":\"v-0069c1a2#_6-hdfs-federation联邦机制\",\"888\":\"v-0069c1a2#_6-1-当前hdfs体系架构\",\"889\":\"v-0069c1a2#_6-2-联邦federation架构\",\"890\":\"v-0069c1a2#_7-hdfs集群滚动升级\",\"891\":\"v-0069c1a2#_8-hdfs集群滚动降级\",\"892\":\"v-0069c1a2#_8-1-降级和回滚的区别\",\"893\":\"v-021e9a41\",\"894\":\"v-021e9a41#_1-hdfs架构剖析\",\"895\":\"v-021e9a41#_2-hdfs-web-interfaces\",\"896\":\"v-021e9a41#_3-hdfs读写流程\",\"897\":\"v-021e9a41#_3-1-hdfs写数据流程\",\"898\":\"v-021e9a41#pipeline管道\",\"899\":\"v-021e9a41#ack应答响应\",\"900\":\"v-021e9a41#默认三副本存储策略\",\"901\":\"v-021e9a41#写流程\",\"902\":\"v-021e9a41#_3-2-hdfs读数据流程\",\"903\":\"v-021e9a41#_3-3-hdfs集群角色职责\",\"904\":\"v-021e9a41#_4-namenode元数据管理\",\"905\":\"v-021e9a41#_4-1-元数据管理综述\",\"906\":\"v-021e9a41#_5-hdfs小文件解决方案\",\"907\":\"v-03d372e0\",\"908\":\"v-03d372e0#_1-hdfs-trash垃圾桶\",\"909\":\"v-03d372e0#_1-1-功能描述\",\"910\":\"v-03d372e0#_1-2-功能开启\",\"911\":\"v-03d372e0#_2-hdfs-snapshot快照\",\"912\":\"v-03d372e0#_2-1-快照的作用\",\"913\":\"v-03d372e0#_2-2-快照功能的理论实现\",\"914\":\"v-03d372e0#_2-3-快照功能的命令实现\",\"915\":\"v-03d372e0#_3-hdfs权限管理\",\"916\":\"v-03d372e0#_3-1-aaa\",\"917\":\"v-03d372e0#_3-2-ugo权限管理\",\"918\":\"v-03d372e0#_3-2-1-读、写、执行权限\",\"919\":\"v-03d372e0#_3-2-2-umask权限掩码\",\"920\":\"v-03d372e0#_3-2-3-ugo相关命令\",\"921\":\"v-03d372e0#_3-3-hdfs用户身份认证\",\"922\":\"v-03d372e0#_3-3-1-simple认证\",\"923\":\"v-03d372e0#_3-3-2-kerberos认证\",\"924\":\"v-03d372e0#_3-4-hdfs-group-mapping组映射\",\"925\":\"v-03d372e0#_3-5-acl权限管理\",\"926\":\"v-03d372e0#_3-5-1-相关命令\",\"927\":\"v-03d372e0#_4-hdfs-proxy-user代理用户\",\"928\":\"v-03d372e0#_5-hdfs透明加密\",\"929\":\"v-03d372e0#_5-1-相关概念\",\"930\":\"v-03d372e0#加密区域\",\"931\":\"v-03d372e0#密钥\",\"932\":\"v-03d372e0#密钥库\",\"933\":\"v-03d372e0#密钥管理服务-kms\",\"934\":\"v-03d372e0#写入加密文件的过程\",\"935\":\"v-03d372e0#读取解密文件的过程\",\"936\":\"v-03d372e0#_5-2-kms配置\",\"937\":\"v-05884b7f\",\"938\":\"v-05884b7f#todo\",\"939\":\"v-1ae6be72\",\"940\":\"v-1ae6be72#_1-yarn架构体系\",\"941\":\"v-1ae6be72#_1-1-官方架构图\",\"942\":\"v-1ae6be72#_1-2-核心交互流程\",\"943\":\"v-1ae6be72#_2-yarn组件及功能\",\"944\":\"v-1ae6be72#_2-1-三大组件\",\"945\":\"v-1ae6be72#resourcemanager\",\"946\":\"v-1ae6be72#nodemanager\",\"947\":\"v-1ae6be72#applicationmaster\",\"948\":\"v-1ae6be72#_2-2-container容器\",\"949\":\"v-1ae6be72#_3-yarn通信协议\",\"950\":\"v-1ae6be72#_4-yarn交互流程\",\"951\":\"v-1ae6be72#_4-1-yarn上的应用类型\",\"952\":\"v-1ae6be72#_4-2-整体概述\",\"953\":\"v-1ae6be72#_4-3-mr提交yarn交互流程\",\"954\":\"v-5f8df061\",\"955\":\"v-5f8df061#_1-mapreduce相关介绍\",\"956\":\"v-5f8df061#_1-1-hadoop-writable序列化机制\",\"957\":\"v-5f8df061#_2-wordcount\",\"958\":\"v-5f8df061#map阶段\",\"959\":\"v-5f8df061#相关解析\",\"960\":\"v-5f8df061#reduce阶段\",\"961\":\"v-5f8df061#相关解析-1\",\"962\":\"v-5f8df061#driver阶段\",\"963\":\"v-5f8df061#_3-mapreduce程序运行模式\",\"964\":\"v-5f8df061#_4-mapreduce流程梳理\",\"965\":\"v-5f8df061#_4-1-map阶段执行过程\",\"966\":\"v-5f8df061#_4-2-reduce阶段执行过程\",\"967\":\"v-6142c900\",\"968\":\"v-6142c900#_1-mapreduce-partition分区\",\"969\":\"v-6142c900#_2-mapreduce-combiner规约\",\"970\":\"v-6142c900#_2-1-combiner组件的使用\",\"971\":\"v-6142c900#_3-covid-19病例统计\",\"972\":\"v-6142c900#_3-1-各州累计病例数量统计\",\"973\":\"v-6142c900#_3-2-各州累计病例分区统计\",\"974\":\"v-6142c900#_3-3-各州累计病例数最多top1县\",\"975\":\"v-6142c900#_4-mapreduce并行度机制\",\"976\":\"v-6142c900#_4-1-maptask并行度机制\",\"977\":\"v-6142c900#_4-2-reducetask并行度机制\",\"978\":\"v-6142c900#_5-mapreduce工作流程详解\",\"979\":\"v-6142c900#_5-1-maptask工作机制详解\",\"980\":\"v-6142c900#_5-2-reducetask工作机制详解\",\"981\":\"v-62f7a19f\",\"982\":\"v-62f7a19f#_1-mapreduce-counter计数器\",\"983\":\"v-62f7a19f#_1-1-自定义counter计数器\",\"984\":\"v-62f7a19f#_2-mapreduce读取数据库操作\",\"985\":\"v-62f7a19f#_2-1-mapreduce读取mysql操作\",\"986\":\"v-62f7a19f#_2-2-mapreducer写入mysql操作\",\"987\":\"v-62f7a19f#_3-mapreduce-join操作\",\"988\":\"v-62f7a19f#_3-1-reduce-side-join\",\"989\":\"v-62f7a19f#_3-2-mapreduce分布式缓存\",\"990\":\"v-62f7a19f#_3-3-map-side-join\",\"991\":\"v-62f7a19f#_4-mapreduce-工作流\",\"992\":\"v-64ac7a3e\",\"993\":\"v-666152dd\",\"994\":\"v-666152dd#_1-io性能优化-文件类型\",\"995\":\"v-666152dd#_1-1-行式存储、列式存储\",\"996\":\"v-f5762fde\",\"997\":\"v-f5762fde#背景\",\"998\":\"v-f5762fde#snowflake-雪花算法\",\"999\":\"v-f5762fde#算法实现\",\"1000\":\"v-f5762fde#算法优缺点\",\"1001\":\"v-f5762fde#注意事项\",\"1002\":\"v-6d94a1ab\",\"1003\":\"v-6d94a1ab#为什么需要幂等性\",\"1004\":\"v-6d94a1ab#http的幂等性\",\"1005\":\"v-6d94a1ab#幂等性的实现方式\",\"1006\":\"v-623319fe\",\"1007\":\"v-623319fe#_1、kafka简介\",\"1008\":\"v-623319fe#_1-1、消息队列\",\"1009\":\"v-623319fe#_1-2、kafka的应用场景\",\"1010\":\"v-623319fe#_1-3、消息队列的两种模型\",\"1011\":\"v-623319fe#_2、kafka-环境搭建\",\"1012\":\"v-623319fe#_2-1、搭建-kafka-环境\",\"1013\":\"v-623319fe#_2-2、目录结构分析\",\"1014\":\"v-623319fe#_3、基础操作\",\"1015\":\"v-623319fe#_3-1、创建-topic\",\"1016\":\"v-623319fe#_3-2、生产消息到-kafka\",\"1017\":\"v-623319fe#_3-3、从-kafka-消费消息\",\"1018\":\"v-623319fe#_3-4、kafka-tool\",\"1019\":\"v-623319fe#_4、kafka-基准测试\",\"1020\":\"v-623319fe#_4-1、创建-topic\",\"1021\":\"v-623319fe#_4-2、生产消息基准测试\",\"1022\":\"v-623319fe#_5、kafka-java-api开发\",\"1023\":\"v-623319fe#_5-1、生产者程序开发\",\"1024\":\"v-623319fe#_5-2、消费者程序开发\",\"1025\":\"v-623319fe#_5-3、生产者使用异步方式生产消息\",\"1026\":\"v-623319fe#_6、kafka中的重要概念\",\"1027\":\"v-623319fe#_7、幂等性\",\"1028\":\"v-623319fe#_7-1、配置幂等性\",\"1029\":\"v-623319fe#_7-2、幂等性原理\",\"1030\":\"v-623319fe#_8、kafka中的分区副本机制\",\"1031\":\"v-623319fe#_8-1、生产者的分区写入策略\",\"1032\":\"v-623319fe#轮询策略\",\"1033\":\"v-623319fe#随即策略\",\"1034\":\"v-623319fe#按-key-分配策略\",\"1035\":\"v-623319fe#自定义分区策略\",\"1036\":\"v-623319fe#_8-2、消费组-rebalance-机制\",\"1037\":\"v-623319fe#rebalance-再均衡\",\"1038\":\"v-623319fe#rebalance-的不良影响\",\"1039\":\"v-623319fe#_8-3、消费者的分区分配策略\",\"1040\":\"v-623319fe#range-范围分配策略\",\"1041\":\"v-623319fe#roundrobin轮询策略\",\"1042\":\"v-623319fe#stricky-粘性分配策略\",\"1043\":\"v-623319fe#_8-4、副本的ack机制\",\"1044\":\"v-623319fe#_9、kafka-eagle\",\"1045\":\"v-623319fe#_9-1、开启-jmx-端口\",\"1046\":\"v-623319fe#_9-2、安装kafka-eagle\",\"1047\":\"v-623319fe#kafka原理-todo\",\"1048\":\"v-623319fe#leader和follower\",\"1049\":\"v-623319fe#ar-isr-osr\",\"1050\":\"v-623319fe#leader选举\",\"1051\":\"v-623319fe#kafka读写流程\",\"1052\":\"v-623319fe#kafka的物理存储\",\"1053\":\"v-623319fe#消息传递的语义性\",\"1054\":\"v-623319fe#kafka的消息不丢失\",\"1055\":\"v-623319fe#数据积压\",\"1056\":\"v-623319fe#数据清理-配额限速\",\"1057\":\"v-810985aa\",\"1058\":\"v-810985aa#todo\",\"1059\":\"v-b1547596\",\"1060\":\"v-b1547596#_1-基本概念\",\"1061\":\"v-b1547596#_1-1-索引-index\",\"1062\":\"v-b1547596#_1-2-类型-type\",\"1063\":\"v-b1547596#_1-3-文档-document\",\"1064\":\"v-b1547596#_1-4-字段-field\",\"1065\":\"v-b1547596#_1-5-映射-mapping\",\"1066\":\"v-b1547596#_1-6-分片-shards\",\"1067\":\"v-b1547596#_1-7-副本-replicas\",\"1068\":\"v-b1547596#_1-8-分配-allocation\",\"1069\":\"v-b1547596#_2-入门操作\",\"1070\":\"v-b1547596#_2-1-引入依赖\",\"1071\":\"v-b1547596#_2-2-客户端对象\",\"1072\":\"v-b1547596#_2-3-索引操作\",\"1073\":\"v-b1547596#_2-4-文档操作\",\"1074\":\"v-b1547596#_3-高级查询\",\"1075\":\"v-b1547596#_3-1-查询索引中所有的数据\",\"1076\":\"v-b1547596#_3-2-条件查询\",\"1077\":\"v-b1547596#_3-3-分页查询\",\"1078\":\"v-b1547596#_3-4-查询排序\",\"1079\":\"v-b1547596#_3-5-查询字段过滤\",\"1080\":\"v-b1547596#_3-6-组合查询\",\"1081\":\"v-b1547596#_3-7-范围查询\",\"1082\":\"v-b1547596#_3-8-模糊查询\",\"1083\":\"v-b1547596#_3-9-高亮查询\",\"1084\":\"v-b1547596#_3-10-聚合查询\",\"1085\":\"v-b1547596#_3-11-分组查询\",\"1086\":\"v-b1547596#_4-框架集成\",\"1087\":\"v-b1547596#_4-1-引入依赖\",\"1088\":\"v-b1547596#_4-2-配置类编写\",\"1089\":\"v-b1547596#_4-3-实现\",\"1090\":\"v-359fa3f2\",\"1091\":\"v-359fa3f2#_1、短信登录\",\"1092\":\"v-359fa3f2#_1-1、导入黑马点评项目\",\"1093\":\"v-359fa3f2#_1-1-1-、导入sql\",\"1094\":\"v-359fa3f2#_1-1-2、有关当前模型\",\"1095\":\"v-359fa3f2#_1-1-3、导入后端项目\",\"1096\":\"v-359fa3f2#_1-1-4、导入前端工程\",\"1097\":\"v-359fa3f2#_1-1-5-运行前端项目\",\"1098\":\"v-359fa3f2#_1-2-、基于session实现登录流程\",\"1099\":\"v-359fa3f2#_1-3、实现发送短信验证码功能\",\"1100\":\"v-359fa3f2#_1-4、实现登录拦截功能\",\"1101\":\"v-359fa3f2#_1-5、隐藏用户敏感信息\",\"1102\":\"v-359fa3f2#_1-6、session共享问题\",\"1103\":\"v-359fa3f2#_1-7、redis代替session的业务流程\",\"1104\":\"v-359fa3f2#_1-7-1、设计key的结构\",\"1105\":\"v-359fa3f2#_1-7-2、设计key的具体细节\",\"1106\":\"v-359fa3f2#_1-7-3、整体访问流程\",\"1107\":\"v-359fa3f2#_1-8、基于redis实现短信登录\",\"1108\":\"v-359fa3f2#_1-9、解决状态登录刷新问题\",\"1109\":\"v-359fa3f2#_1-9-1、初始方案思路总结\",\"1110\":\"v-359fa3f2#_1-9-2、优化方案\",\"1111\":\"v-359fa3f2#_1-9-3、代码\",\"1112\":\"v-359fa3f2#_2、商户查询缓存\",\"1113\":\"v-359fa3f2#_2-1、什么是缓存\",\"1114\":\"v-359fa3f2#_2-1-1、为什么要使用缓存\",\"1115\":\"v-359fa3f2#_2-1-2、如何使用缓存\",\"1116\":\"v-359fa3f2#_2-2、添加商户缓存\",\"1117\":\"v-359fa3f2#_2-2-1、缓存模型和思路\",\"1118\":\"v-359fa3f2#_2-1-2、代码如下\",\"1119\":\"v-359fa3f2#_2-3、缓存更新策略\",\"1120\":\"v-359fa3f2#_2-3-1、数据库缓存不一致解决方案\",\"1121\":\"v-359fa3f2#_2-3-2、数据库和缓存不一致采用什么方案\",\"1122\":\"v-359fa3f2#_2-4、实现商铺和缓存与数据库双写一致\",\"1123\":\"v-359fa3f2#_2-5、缓存穿透问题的解决思路\",\"1124\":\"v-359fa3f2#_2-6、编码解决商品查询的缓存穿透问题\",\"1125\":\"v-359fa3f2#_2-7、缓存雪崩问题及解决思路\",\"1126\":\"v-359fa3f2#_2-8、缓存击穿问题及解决思路\",\"1127\":\"v-359fa3f2#_2-9、利用互斥锁解决缓存击穿问题\",\"1128\":\"v-359fa3f2#_2-10、利用逻辑过期解决缓存击穿问题\",\"1129\":\"v-359fa3f2#_2-11、封装redis工具类\",\"1130\":\"v-359fa3f2#_3、优惠卷秒杀\",\"1131\":\"v-359fa3f2#_3-1、全局唯一id\",\"1132\":\"v-359fa3f2#_3-2、redis实现全局唯一id\",\"1133\":\"v-359fa3f2#_3-3、添加优惠卷\",\"1134\":\"v-359fa3f2#_3-4、实现秒杀下单\",\"1135\":\"v-359fa3f2#_3-5、库存超卖问题分析\",\"1136\":\"v-359fa3f2#_3-6、乐观锁解决超卖问题\",\"1137\":\"v-359fa3f2#_3-7、优惠券秒杀-一人一单\",\"1138\":\"v-359fa3f2#_3-8、集群环境下的并发问题\",\"1139\":\"v-359fa3f2#_4、分布式锁\",\"1140\":\"v-359fa3f2#_4-1、基本原理和实现方式对比\",\"1141\":\"v-359fa3f2#_4-2、redis分布式锁的实现核心思路\",\"1142\":\"v-359fa3f2#_4-3、实现分布式锁版本一\",\"1143\":\"v-359fa3f2#_4-4、redis分布式锁误删情况说明\",\"1144\":\"v-359fa3f2#_4-5、解决redis分布式锁误删问题\",\"1145\":\"v-359fa3f2#_4-6、分布式锁的原子性问题\",\"1146\":\"v-359fa3f2#_4-7、lua脚本解决多条命令原子性问题\",\"1147\":\"v-359fa3f2#_4-8、利用java代码调用lua脚本改造分布式锁\",\"1148\":\"v-359fa3f2#_5、分布式锁-redisson\",\"1149\":\"v-359fa3f2#_5-1、分布式锁-redisson-功能介绍\",\"1150\":\"v-359fa3f2#_5-2、分布式锁-redisson-快速入门\",\"1151\":\"v-359fa3f2#_5-3、分布式锁-redisson-可重入锁原理\",\"1152\":\"v-359fa3f2#_5-4、分布式锁-redisson-锁重试和-watchdog-机制\",\"1153\":\"v-359fa3f2#_5-5、分布式锁-redission锁的mutilock原理\",\"1154\":\"v-359fa3f2#_6、秒杀优化\",\"1155\":\"v-359fa3f2#_6-1、秒杀优化-异步秒杀思路\",\"1156\":\"v-359fa3f2#_6-2、秒杀优化-redis-完成秒杀资格判断\",\"1157\":\"v-359fa3f2#_6-3、秒杀优化-基于阻塞队列实现秒杀优化\",\"1158\":\"v-359fa3f2#_7、达人探店\",\"1159\":\"v-359fa3f2#_7-1、达人探店-发布探店笔记\",\"1160\":\"v-359fa3f2#_7-2、达人探店-查看探店笔记\",\"1161\":\"v-359fa3f2#_7-3、达人探店-点赞功能\",\"1162\":\"v-359fa3f2#_7-4、达人探店-点赞排行榜\",\"1163\":\"v-359fa3f2#_8、好友关注\",\"1164\":\"v-359fa3f2#_8-1、好友关注-关注和取消关注\",\"1165\":\"v-359fa3f2#_8-2、好友关注-共同关注\",\"1166\":\"v-359fa3f2#_8-3、好友关注-feed流实现方案\",\"1167\":\"v-359fa3f2#_8-4、好友关注-推送到粉丝收件箱\",\"1168\":\"v-359fa3f2#_8-5、好友关注-实现分页查询收邮箱\",\"1169\":\"v-359fa3f2#_9、附近商户\",\"1170\":\"v-359fa3f2#_9-1、附近商户-geo-数据结构的基本用法\",\"1171\":\"v-359fa3f2#_9-2、附近商户-导入店铺数据到-geo\",\"1172\":\"v-359fa3f2#_9-3、附近商户-实现附近商户功能\",\"1173\":\"v-359fa3f2#_10、用户签到\",\"1174\":\"v-359fa3f2#_10-1、用户签到-bitmap-功能演示\",\"1175\":\"v-359fa3f2#_10-2、用户签到-实现签到功能\",\"1176\":\"v-359fa3f2#_10-3、用户签到-签到统计\",\"1177\":\"v-359fa3f2#_10-4、额外加餐-关于使用-bitmap-来解决缓存穿透的方案\",\"1178\":\"v-359fa3f2#_11、uv-统计\",\"1179\":\"v-359fa3f2#_11-1-、uv-统计-hyperloglog\",\"1180\":\"v-359fa3f2#_11-2、uv统计-测试百万数据的统计\",\"1181\":\"v-383eefd9\",\"1182\":\"v-383eefd9#_1、redis简单介绍\",\"1183\":\"v-383eefd9#_2、初始redis\",\"1184\":\"v-383eefd9#_2-1、认识nosql\",\"1185\":\"v-383eefd9#_2-1-1、结构化与非结构化\",\"1186\":\"v-383eefd9#_2-1-2、关联和非关联\",\"1187\":\"v-383eefd9#_2-1-3、查询方式\",\"1188\":\"v-383eefd9#_2-1-4、事务\",\"1189\":\"v-383eefd9#_2-1-5、总结\",\"1190\":\"v-383eefd9#_2-2、认识redis\",\"1191\":\"v-383eefd9#_2-3、安装redis\",\"1192\":\"v-383eefd9#_2-3-1、依赖库\",\"1193\":\"v-383eefd9#_2-3-2、上传安装包并解压\",\"1194\":\"v-383eefd9#_2-3-3、启动\",\"1195\":\"v-383eefd9#_2-3-4、默认启动\",\"1196\":\"v-383eefd9#_2-3-5、指定配置启动\",\"1197\":\"v-383eefd9#_2-3-6、开机自启\",\"1198\":\"v-383eefd9#_2-4、redis桌面客户端\",\"1199\":\"v-383eefd9#_2-4-1、redis命令行客户端\",\"1200\":\"v-383eefd9#_2-4-2、图形化桌面客户端\",\"1201\":\"v-383eefd9#_2-4-3、安装\",\"1202\":\"v-383eefd9#_2-4-4、建立连接\",\"1203\":\"v-383eefd9#_3、redis常见命令\",\"1204\":\"v-383eefd9#_3-1、redis数据结构介绍\",\"1205\":\"v-383eefd9#_3-2、redis-通用命令\",\"1206\":\"v-383eefd9#_3-3、redis命令-string命令\",\"1207\":\"v-383eefd9#_3-4、redis命令-key的层级结构\",\"1208\":\"v-383eefd9#_3-5、redis命令-hash命令\",\"1209\":\"v-383eefd9#_3-6、redis命令-list命令\",\"1210\":\"v-383eefd9#_3-7、redis命令-set命令\",\"1211\":\"v-383eefd9#_3-8、redis命令-sortedset类型\",\"1212\":\"v-383eefd9#_4、redis的java客户端-jedis\",\"1213\":\"v-383eefd9#_4-1、jedis快速入门\",\"1214\":\"v-383eefd9#_4-2、jedis连接池\",\"1215\":\"v-383eefd9#_4-2-1、创建jedis的连接池\",\"1216\":\"v-383eefd9#_4-2-2、改造原始代码\",\"1217\":\"v-383eefd9#_5、redis的java客户端-springdataredis\",\"1218\":\"v-383eefd9#_5-1、快速入门\",\"1219\":\"v-383eefd9#_5-1-1、导入pom坐标\",\"1220\":\"v-383eefd9#_5-1-2、配置文件\",\"1221\":\"v-383eefd9#_5-1-3、测试代码\",\"1222\":\"v-383eefd9#_5-2、数据序列化器\",\"1223\":\"v-383eefd9#_5-3、stringredistemplate\",\"1224\":\"v-383eefd9#_5-4、hash结构操作\",\"1225\":\"v-383eefd9@0\",\"1226\":\"v-383eefd9@1\",\"1227\":\"v-3c587b52\",\"1228\":\"v-3c587b52#mybatis\",\"1229\":\"v-3c587b52#param-requestbody\",\"1230\":\"v-3c587b52#和\",\"1231\":\"v-3c587b52#mybatis分页操作\",\"1232\":\"v-3c587b52#mybatis动态表模式实现\",\"1233\":\"v-3c587b52#mybatis-plus\",\"1234\":\"v-3c587b52#前端传来不定条件mybatis-plus的解决方案\",\"1235\":\"v-3c587b52#函数式sql\",\"1236\":\"v-3c587b52#mybatis-plus多数据源\",\"1237\":\"v-3c587b52#通过mybatisx插件自动生成代码\",\"1238\":\"v-86824a00\",\"1239\":\"v-86824a00#容器与-bean\",\"1240\":\"v-86824a00#_1-容器接口\",\"1241\":\"v-86824a00#演示1-beanfactory-与-applicationcontext-的区别\",\"1242\":\"v-86824a00#代码参考\",\"1243\":\"v-86824a00#收获💡\",\"1244\":\"v-86824a00#演示2-国际化\",\"1245\":\"v-86824a00#_2-容器实现\",\"1246\":\"v-86824a00#演示1-defaultlistablebeanfactory\",\"1247\":\"v-86824a00#代码参考-1\",\"1248\":\"v-86824a00#收获💡-1\",\"1249\":\"v-86824a00#演示2-常见-applicationcontext-实现\",\"1250\":\"v-86824a00#代码参考-2\",\"1251\":\"v-86824a00#收获💡-2\",\"1252\":\"v-86824a00#_3-bean-的生命周期\",\"1253\":\"v-86824a00#演示1-bean-生命周期\",\"1254\":\"v-86824a00#代码参考-3\",\"1255\":\"v-86824a00#收获💡-3\",\"1256\":\"v-86824a00#演示2-模板方法设计模式\",\"1257\":\"v-86824a00#关键代码\",\"1258\":\"v-86824a00#演示3-bean-后处理器排序\",\"1259\":\"v-86824a00#代码参考-4\",\"1260\":\"v-86824a00#收获💡-4\",\"1261\":\"v-86824a00#_4-bean-后处理器\",\"1262\":\"v-86824a00#演示1-后处理器作用\",\"1263\":\"v-86824a00#代码参考-5\",\"1264\":\"v-86824a00#收获💡-5\",\"1265\":\"v-86824a00#演示2-autowired-bean-后处理器运行分析\",\"1266\":\"v-86824a00#代码参考-6\",\"1267\":\"v-86824a00#收获💡-6\",\"1268\":\"v-86824a00#_5-beanfactory-后处理器\",\"1269\":\"v-86824a00#演示1-beanfactory-后处理器的作用\",\"1270\":\"v-86824a00#代码参考-7\",\"1271\":\"v-86824a00#收获💡-7\",\"1272\":\"v-86824a00#演示2-模拟解析-componentscan\",\"1273\":\"v-86824a00#代码参考-8\",\"1274\":\"v-86824a00#收获💡-8\",\"1275\":\"v-86824a00#演示3-模拟解析-bean\",\"1276\":\"v-86824a00#代码参考-9\",\"1277\":\"v-86824a00#收获💡-9\",\"1278\":\"v-86824a00#演示4-模拟解析-mapper-接口\",\"1279\":\"v-86824a00#代码参考-10\",\"1280\":\"v-86824a00#收获💡-10\",\"1281\":\"v-86824a00#_6-aware-接口\",\"1282\":\"v-86824a00#演示-aware-接口及-initializingbean-接口\",\"1283\":\"v-86824a00#代码参考-11\",\"1284\":\"v-86824a00#收获💡-11\",\"1285\":\"v-86824a00#配置类-autowired-失效分析\",\"1286\":\"v-86824a00#_7-初始化与销毁\",\"1287\":\"v-86824a00#演示-初始化销毁顺序\",\"1288\":\"v-86824a00#代码参考-12\",\"1289\":\"v-86824a00#收获💡-12\",\"1290\":\"v-86824a00#_8-scope\",\"1291\":\"v-86824a00#演示1-request-session-application-作用域\",\"1292\":\"v-86824a00#代码参考-13\",\"1293\":\"v-86824a00#收获💡-13\",\"1294\":\"v-86824a00#分析-singleton-注入其它-scope-失效\",\"1295\":\"v-86824a00#演示2-4种解决方法\",\"1296\":\"v-86824a00#代码参考-14\",\"1297\":\"v-86824a00#收获💡-14\",\"1298\":\"v-86824a00#aop\",\"1299\":\"v-86824a00#_9-aop-实现之-ajc-编译器\",\"1300\":\"v-86824a00#收获💡-15\",\"1301\":\"v-86824a00#_10-aop-实现之-agent-类加载\",\"1302\":\"v-86824a00#收获💡-16\",\"1303\":\"v-86824a00#_11-aop-实现之-proxy\",\"1304\":\"v-86824a00#演示1-jdk-动态代理\",\"1305\":\"v-86824a00#收获💡-17\",\"1306\":\"v-86824a00#演示2-cglib-代理\",\"1307\":\"v-86824a00#收获💡-18\",\"1308\":\"v-86824a00#_12-jdk-动态代理进阶\",\"1309\":\"v-86824a00#演示1-模拟-jdk-动态代理\",\"1310\":\"v-86824a00#收获💡-19\",\"1311\":\"v-86824a00#演示2-方法反射优化\",\"1312\":\"v-86824a00#代码参考-15\",\"1313\":\"v-86824a00#收获💡-20\",\"1314\":\"v-86824a00#_13-cglib-代理进阶\",\"1315\":\"v-86824a00#演示-模拟-cglib-代理\",\"1316\":\"v-86824a00#代码参考-16\",\"1317\":\"v-86824a00#收获💡-21\",\"1318\":\"v-86824a00#_14-cglib-避免反射调用\",\"1319\":\"v-86824a00#演示-cglib-如何避免反射\",\"1320\":\"v-86824a00#代码参考-17\",\"1321\":\"v-86824a00#收获💡-22\",\"1322\":\"v-86824a00#_15-jdk-和-cglib-在-spring-中的统一\",\"1323\":\"v-86824a00#演示-底层切点、通知、切面\",\"1324\":\"v-86824a00#代码参考-18\",\"1325\":\"v-86824a00#收获💡-23\",\"1326\":\"v-86824a00#_16-切点匹配\",\"1327\":\"v-86824a00#演示-切点匹配\",\"1328\":\"v-86824a00#代码参考-19\",\"1329\":\"v-86824a00#收获💡-24\",\"1330\":\"v-86824a00#_17-从-aspect-到-advisor\",\"1331\":\"v-86824a00#演示1-代理创建器\",\"1332\":\"v-86824a00#代码参考-20\",\"1333\":\"v-86824a00#收获💡-25\",\"1334\":\"v-86824a00#演示2-代理创建时机\",\"1335\":\"v-86824a00#代码参考-21\",\"1336\":\"v-86824a00#收获💡-26\",\"1337\":\"v-86824a00#演示3-before-对应的低级通知\",\"1338\":\"v-86824a00#代码参考-22\",\"1339\":\"v-86824a00#收获💡-27\",\"1340\":\"v-86824a00#_18-静态通知调用\",\"1341\":\"v-86824a00#演示1-通知调用过程\",\"1342\":\"v-86824a00#代码参考-23\",\"1343\":\"v-86824a00#收获💡-28\",\"1344\":\"v-86824a00#演示2-模拟-methodinvocation\",\"1345\":\"v-86824a00#代码参考-24\",\"1346\":\"v-86824a00#收获💡-29\",\"1347\":\"v-86824a00#_19-动态通知调用\",\"1348\":\"v-86824a00#演示-带参数绑定的通知方法调用\",\"1349\":\"v-86824a00#代码参考-25\",\"1350\":\"v-86824a00#收获💡-30\",\"1351\":\"v-86824a00#web\",\"1352\":\"v-86824a00#_20-requestmappinghandlermapping-与-requestmappinghandleradapter\",\"1353\":\"v-86824a00#演示1-dispatcherservlet-初始化\",\"1354\":\"v-86824a00#代码参考-26\",\"1355\":\"v-86824a00#收获💡-31\",\"1356\":\"v-86824a00#演示2-自定义参数与返回值处理器\",\"1357\":\"v-86824a00#代码参考-27\",\"1358\":\"v-86824a00#收获💡-32\",\"1359\":\"v-86824a00#_21-参数解析器\",\"1360\":\"v-86824a00#演示-常见参数解析器\",\"1361\":\"v-86824a00#代码参考-28\",\"1362\":\"v-86824a00#收获💡-33\",\"1363\":\"v-86824a00#_22-参数名解析\",\"1364\":\"v-86824a00#演示-两种方法获取参数名\",\"1365\":\"v-86824a00#代码参考-29\",\"1366\":\"v-86824a00#收获💡-34\",\"1367\":\"v-86824a00#_23-对象绑定与类型转换\",\"1368\":\"v-86824a00#底层第一套转换接口与实现\",\"1369\":\"v-86824a00#底层第二套转换接口\",\"1370\":\"v-86824a00#高层接口与实现\",\"1371\":\"v-86824a00#演示1-类型转换与数据绑定\",\"1372\":\"v-86824a00#代码参考-30\",\"1373\":\"v-86824a00#收获💡-35\",\"1374\":\"v-86824a00#演示2-数据绑定工厂\",\"1375\":\"v-86824a00#代码参考-31\",\"1376\":\"v-86824a00#收获💡-36\",\"1377\":\"v-86824a00#演示3-获取泛型参数\",\"1378\":\"v-86824a00#代码参考-32\",\"1379\":\"v-86824a00#收获💡-37\",\"1380\":\"v-86824a00#_24-controlleradvice-之-initbinder\",\"1381\":\"v-86824a00#演示-准备-initbinder\",\"1382\":\"v-86824a00#收获💡-38\",\"1383\":\"v-86824a00#_25-控制器方法执行流程\",\"1384\":\"v-86824a00#图1\",\"1385\":\"v-86824a00#图2\",\"1386\":\"v-86824a00#图3\",\"1387\":\"v-86824a00#_26-controlleradvice-之-modelattribute\",\"1388\":\"v-86824a00#演示-准备-modelattribute\",\"1389\":\"v-86824a00#代码参考-33\",\"1390\":\"v-86824a00#收获💡-39\",\"1391\":\"v-86824a00#_27-返回值处理器\",\"1392\":\"v-86824a00#演示-常见返回值处理器\",\"1393\":\"v-86824a00#代码参考-34\",\"1394\":\"v-86824a00#收获💡-40\",\"1395\":\"v-86824a00#_28-messageconverter\",\"1396\":\"v-86824a00#演示-messageconverter-的作用\",\"1397\":\"v-86824a00#代码参考-35\",\"1398\":\"v-86824a00#收获💡-41\",\"1399\":\"v-86824a00#_29-controlleradvice-之-responsebodyadvice\",\"1400\":\"v-86824a00#演示-responsebodyadvice-增强\",\"1401\":\"v-86824a00#代码参考-36\",\"1402\":\"v-86824a00#收获💡-42\",\"1403\":\"v-86824a00#_30-异常解析器\",\"1404\":\"v-86824a00#演示-exceptionhandlerexceptionresolver\",\"1405\":\"v-86824a00#代码参考-37\",\"1406\":\"v-86824a00#收获💡-43\",\"1407\":\"v-86824a00#_31-controlleradvice-之-exceptionhandler\",\"1408\":\"v-86824a00#演示-准备-exceptionhandler\",\"1409\":\"v-86824a00#代码参考-38\",\"1410\":\"v-86824a00#收获💡-44\",\"1411\":\"v-86824a00#_32-tomcat-异常处理\",\"1412\":\"v-86824a00#演示1-错误页处理\",\"1413\":\"v-86824a00#关键代码-1\",\"1414\":\"v-86824a00#收获💡-45\",\"1415\":\"v-86824a00#演示2-basicerrorcontroller\",\"1416\":\"v-86824a00#关键代码-2\",\"1417\":\"v-86824a00#收获💡-46\",\"1418\":\"v-86824a00#_33-beannameurlhandlermapping-与-simplecontrollerhandleradapter\",\"1419\":\"v-86824a00#演示-本组映射器和适配器\",\"1420\":\"v-86824a00#关键代码-3\",\"1421\":\"v-86824a00#收获💡-47\",\"1422\":\"v-86824a00#_34-routerfunctionmapping-与-handlerfunctionadapter\",\"1423\":\"v-86824a00#演示-本组映射器和适配器-1\",\"1424\":\"v-86824a00#关键代码-4\",\"1425\":\"v-86824a00#收获💡-48\",\"1426\":\"v-86824a00#_35-simpleurlhandlermapping-与-httprequesthandleradapter\",\"1427\":\"v-86824a00#演示1-本组映射器和适配器\",\"1428\":\"v-86824a00#代码参考-39\",\"1429\":\"v-86824a00#关键代码-5\",\"1430\":\"v-86824a00#收获💡-49\",\"1431\":\"v-86824a00#演示2-静态资源解析优化\",\"1432\":\"v-86824a00#关键代码-6\",\"1433\":\"v-86824a00#收获💡-50\",\"1434\":\"v-86824a00#演示3-欢迎页\",\"1435\":\"v-86824a00#关键代码-7\",\"1436\":\"v-86824a00#收获💡-51\",\"1437\":\"v-86824a00#映射器与适配器小结\",\"1438\":\"v-86824a00#_36-mvc-处理流程\",\"1439\":\"v-86824a00#boot\",\"1440\":\"v-86824a00#_37-boot-骨架项目\",\"1441\":\"v-86824a00#_38-boot-war项目\",\"1442\":\"v-86824a00#测试\",\"1443\":\"v-86824a00#启示\",\"1444\":\"v-86824a00#_39-boot-启动过程\",\"1445\":\"v-86824a00#演示-启动过程\",\"1446\":\"v-86824a00#收获💡-52\",\"1447\":\"v-86824a00#_40-tomcat-内嵌容器\",\"1448\":\"v-86824a00#演示1-tomcat-内嵌容器\",\"1449\":\"v-86824a00#关键代码-8\",\"1450\":\"v-86824a00#演示2-集成-spring-容器\",\"1451\":\"v-86824a00#关键代码-9\",\"1452\":\"v-86824a00#_41-boot-自动配置\",\"1453\":\"v-86824a00#aopautoconfiguration\",\"1454\":\"v-86824a00#datasourceautoconfiguration\",\"1455\":\"v-86824a00#mybatisautoconfiguration\",\"1456\":\"v-86824a00#transactionautoconfiguration\",\"1457\":\"v-86824a00#servletwebserverfactoryautoconfiguration\",\"1458\":\"v-86824a00#dispatcherservletautoconfiguration\",\"1459\":\"v-86824a00#webmvcautoconfiguration\",\"1460\":\"v-86824a00#errormvcautoconfiguration\",\"1461\":\"v-86824a00#multipartautoconfiguration\",\"1462\":\"v-86824a00#httpencodingautoconfiguration\",\"1463\":\"v-86824a00#演示-自动配置类原理\",\"1464\":\"v-86824a00#关键代码-10\",\"1465\":\"v-86824a00#收获💡-53\",\"1466\":\"v-86824a00#_42-条件装配底层\",\"1467\":\"v-86824a00#收获💡-54\",\"1468\":\"v-86824a00#其它\",\"1469\":\"v-86824a00#_43-factorybean\",\"1470\":\"v-86824a00#演示-factorybean\",\"1471\":\"v-86824a00#代码参考-40\",\"1472\":\"v-86824a00#收获💡-55\",\"1473\":\"v-86824a00#_44-indexed-原理\",\"1474\":\"v-86824a00#演示-indexed\",\"1475\":\"v-86824a00#代码参考-41\",\"1476\":\"v-86824a00#收获💡-56\",\"1477\":\"v-86824a00#_45-代理进一步理解\",\"1478\":\"v-86824a00#演示-代理\",\"1479\":\"v-86824a00#代码参考-42\",\"1480\":\"v-86824a00#收获💡-57\",\"1481\":\"v-86824a00#_46-value-装配底层\",\"1482\":\"v-86824a00#按类型装配的步骤\",\"1483\":\"v-86824a00#演示-value-装配过程\",\"1484\":\"v-86824a00#代码参考-43\",\"1485\":\"v-86824a00#收获💡-58\",\"1486\":\"v-86824a00#_47-autowired-装配底层\",\"1487\":\"v-86824a00#演示-autowired-装配过程\",\"1488\":\"v-86824a00#代码参考-44\",\"1489\":\"v-86824a00#收获💡-59\",\"1490\":\"v-86824a00#_48-事件监听器\",\"1491\":\"v-86824a00#演示-事件监听器\",\"1492\":\"v-86824a00#代码参考-45\",\"1493\":\"v-86824a00#收获💡-60\",\"1494\":\"v-86824a00#_49-事件发布器\",\"1495\":\"v-86824a00#演示-事件发布器\",\"1496\":\"v-86824a00#代码参考-46\",\"1497\":\"v-86824a00#收获💡-61\",\"1498\":\"v-4cfe1d20\",\"1499\":\"v-4cfe1d20#列举一些重要的spring模块\",\"1500\":\"v-4cfe1d20#请你说说spring的核心是什么\",\"1501\":\"v-4cfe1d20#说一说对spring容器的了解\",\"1502\":\"v-4cfe1d20#说一说对beanfactory的了解\",\"1503\":\"v-4cfe1d20#spring是如何管理bean的\",\"1504\":\"v-4cfe1d20#bean的作用域\",\"1505\":\"v-4cfe1d20#bean的生命周期\",\"1506\":\"v-4cfe1d20#单例bean的线程安全问题了解吗\",\"1507\":\"v-4cfe1d20#component和-bean的区别是什么\",\"1508\":\"v-4cfe1d20#aspectj\",\"1509\":\"v-4cfe1d20#spring-aop和aspectj-aop的区别\",\"1510\":\"v-4cfe1d20#说说aop的应用场景\",\"1511\":\"v-4cfe1d20#spring-aop不能对哪些类进行增强\",\"1512\":\"v-4cfe1d20#既然没有接口都可以用cglib-为什么spring还要使用jdk动态代理\",\"1513\":\"v-4cfe1d20#spring是如何管理事务的\",\"1514\":\"v-4cfe1d20#spring中的事务传播行为\",\"1515\":\"v-4cfe1d20#spring的事务如何配置-常用注解有那些\",\"1516\":\"v-4cfe1d20#transactional-rollbackfor-exception-class-注解了解吗\",\"1517\":\"v-4cfe1d20#transactional失效场景\",\"1518\":\"v-4cfe1d20#spring是怎么解决循环依赖的\",\"1519\":\"v-b5b4e464\",\"1520\":\"v-b5b4e464#说说你对spring-boot的理解\",\"1521\":\"v-b5b4e464#spring-boot-starter有什么用\",\"1522\":\"v-b5b4e464#介绍spring-boot的启动流程\",\"1523\":\"v-b5b4e464#spring-boot项目是如何导入包的\",\"1524\":\"v-b5b4e464#spring-boot自动装配过程\",\"1525\":\"v-b5b4e464#说说你对spring-boot的注解的了解\",\"1526\":\"v-b5b4e464#spring-boot全局异常处理器\",\"1527\":\"v-3c7e43b8\",\"1528\":\"v-3c7e43b8#什么是mvc\",\"1529\":\"v-3c7e43b8#dao层是做什么的\",\"1530\":\"v-3c7e43b8#介绍一下spring-mvc的执行流程\",\"1531\":\"v-3c7e43b8#说一说你知道的spring-mvc注解\",\"1532\":\"v-3c7e43b8#介绍一下sprig-mvc的拦截器\",\"1533\":\"v-04b17156\",\"1534\":\"v-2d0aa4d7\",\"1535\":\"v-2d0a3132\",\"1536\":\"v-d440f426\",\"1537\":\"v-7f1afa7e\",\"1538\":\"v-02bc92be\",\"1539\":\"v-23603f68\",\"1540\":\"v-71b3ae87\",\"1541\":\"v-6fc3d76d\",\"1542\":\"v-7dcae826\",\"1543\":\"v-32311dcd\",\"1544\":\"v-4fdba49a\",\"1545\":\"v-e9d02874\",\"1546\":\"v-7e2e1571\",\"1547\":\"v-0314b485\",\"1548\":\"v-66fcfb48\",\"1549\":\"v-1590f844\",\"1550\":\"v-22443161\",\"1551\":\"v-4e5855da\",\"1552\":\"v-5f3df42c\",\"1553\":\"v-4f46b4bf\",\"1554\":\"v-a60b804e\",\"1555\":\"v-f5e726ec\",\"1556\":\"v-17014c1a\",\"1557\":\"v-1b48f263\",\"1558\":\"v-76b165fb\",\"1559\":\"v-0a634f38\",\"1560\":\"v-ab01ff6c\",\"1561\":\"v-49e06168\",\"1562\":\"v-953a93a8\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[1,2],\"4\":[1,24],\"5\":[1,18],\"6\":[1,73],\"7\":[1,57],\"8\":[1,5],\"9\":[1,45],\"10\":[6,21],\"11\":[1],\"12\":[1,23],\"13\":[1,25],\"14\":[1,90],\"15\":[1,28],\"16\":[1,13],\"17\":[1,66],\"18\":[1],\"19\":[1,17],\"20\":[1,12],\"21\":[1],\"22\":[1,29],\"23\":[1,63],\"24\":[1],\"25\":[1,35],\"26\":[1,3],\"27\":[1,10],\"28\":[1,45],\"29\":[1,14],\"30\":[1,27],\"31\":[1,4],\"32\":[1,4],\"33\":[1,20],\"34\":[1,53],\"35\":[1,10],\"36\":[1,22],\"37\":[1,6],\"38\":[1,23],\"39\":[1,48],\"40\":[1,7],\"41\":[1,15],\"42\":[1,76],\"43\":[3,48],\"44\":[5,3],\"45\":[1,15],\"46\":[1,24],\"47\":[1,86],\"48\":[1],\"49\":[1,3],\"50\":[1,13],\"51\":[1,47],\"52\":[1,53],\"53\":[1,4],\"54\":[3,94],\"55\":[1],\"56\":[1,9],\"57\":[1,17],\"58\":[1,48],\"59\":[1,162],\"60\":[1,90],\"61\":[1,37],\"62\":[1,8],\"63\":[1,26],\"64\":[1,16],\"65\":[1,5],\"66\":[1,136],\"67\":[1],\"68\":[1,86],\"69\":[1,100],\"70\":[2,82],\"71\":[1,7],\"72\":[1,37],\"73\":[1,70],\"74\":[1,98],\"75\":[1,44],\"76\":[1,77],\"77\":[1,52],\"78\":[1,3],\"79\":[1,13],\"80\":[1,14],\"81\":[1,126],\"82\":[1],\"83\":[1,24],\"84\":[1,33],\"85\":[1,68],\"86\":[1,19],\"87\":[1,8],\"88\":[1,64],\"89\":[1,1],\"90\":[2],\"91\":[2,61],\"92\":[2,88],\"93\":[2],\"94\":[2,19],\"95\":[2,28],\"96\":[3],\"97\":[2,20],\"98\":[4,44],\"99\":[2,62],\"100\":[2,82],\"101\":[4,50],\"102\":[2,112],\"103\":[2],\"104\":[2,89],\"105\":[2,68],\"106\":[2],\"107\":[2,95],\"108\":[2,48],\"109\":[2],\"110\":[2,35],\"111\":[2],\"112\":[4,129],\"113\":[4,100],\"114\":[4,72],\"115\":[4,81],\"116\":[1],\"117\":[1,49],\"118\":[1,8],\"119\":[1,10],\"120\":[1,23],\"121\":[1,10],\"122\":[1,6],\"123\":[1],\"124\":[1,42],\"125\":[1,45],\"126\":[1,12],\"127\":[1,23],\"128\":[1,30],\"129\":[1],\"130\":[1,23],\"131\":[1,27],\"132\":[1,16],\"133\":[1,22],\"134\":[1,1],\"135\":[1,2],\"136\":[4,3],\"137\":[1,5],\"138\":[1,22],\"139\":[1,11],\"140\":[1,18],\"141\":[1,2],\"142\":[1,2],\"143\":[1],\"144\":[1,17],\"145\":[1,33],\"146\":[1,20],\"147\":[2,88],\"148\":[1],\"149\":[1,1],\"150\":[1,1],\"151\":[1],\"152\":[1],\"153\":[2,11],\"154\":[2,44],\"155\":[2,65],\"156\":[2,41],\"157\":[2,42],\"158\":[2,23],\"159\":[2,72],\"160\":[2,50],\"161\":[2,44],\"162\":[2,64],\"163\":[3,131],\"164\":[2,44],\"165\":[3,42],\"166\":[2,45],\"167\":[2,213],\"168\":[3,60],\"169\":[2,48],\"170\":[2,44],\"171\":[2,41],\"172\":[4,28],\"173\":[2,18],\"174\":[1],\"175\":[2,78],\"176\":[3,61],\"177\":[3,22],\"178\":[3,37],\"179\":[2,121],\"180\":[2,25],\"181\":[3,61],\"182\":[3,113],\"183\":[2,39],\"184\":[2,53],\"185\":[2,16],\"186\":[2,34],\"187\":[2,47],\"188\":[2,54],\"189\":[2,70],\"190\":[2,45],\"191\":[2,135],\"192\":[2,67],\"193\":[1],\"194\":[2,20],\"195\":[2,56],\"196\":[2,52],\"197\":[2,96],\"198\":[2,42],\"199\":[2,15],\"200\":[2,17],\"201\":[2,35],\"202\":[2,3],\"203\":[2,15],\"204\":[2,67],\"205\":[2,19],\"206\":[2,32],\"207\":[3,11],\"208\":[3,28],\"209\":[3,89],\"210\":[3,39],\"211\":[3,31],\"212\":[2,44],\"213\":[2,58],\"214\":[2,31],\"215\":[1],\"216\":[1],\"217\":[2],\"218\":[4],\"219\":[2,14],\"220\":[4],\"221\":[3,15],\"222\":[4,13],\"223\":[4,15],\"224\":[3,10],\"225\":[7,12],\"226\":[6,23],\"227\":[6,10],\"228\":[5,28],\"229\":[4,12],\"230\":[6],\"231\":[3,2],\"232\":[3,46],\"233\":[4,7],\"234\":[4,21],\"235\":[3,17],\"236\":[4,21],\"237\":[4,27],\"238\":[5,14],\"239\":[5,11],\"240\":[4,12],\"241\":[4,17],\"242\":[4,13],\"243\":[3,19],\"244\":[4,35],\"245\":[5],\"246\":[4],\"247\":[2,8],\"248\":[3,55],\"249\":[3,5],\"250\":[3,27],\"251\":[4,22],\"252\":[3,26],\"253\":[3],\"254\":[3,13],\"255\":[4,7],\"256\":[3,88],\"257\":[5],\"258\":[5,35],\"259\":[5,31],\"260\":[3,52],\"261\":[2,95],\"262\":[3,43],\"263\":[6,20],\"264\":[4,20],\"265\":[3,63],\"266\":[3,54],\"267\":[6,19],\"268\":[4,78],\"269\":[5],\"270\":[4,19],\"271\":[3,57],\"272\":[4,29],\"273\":[4],\"274\":[4,16],\"275\":[3,18],\"276\":[4,145],\"277\":[5],\"278\":[6,59],\"279\":[5,105],\"280\":[4,92],\"281\":[4,88],\"282\":[7],\"283\":[5,30],\"284\":[2,7],\"285\":[5,63],\"286\":[5,31],\"287\":[3,39],\"288\":[3,28],\"289\":[6,48],\"290\":[4,88],\"291\":[4,3],\"292\":[3,23],\"293\":[3,70],\"294\":[4,21],\"295\":[4],\"296\":[4,24],\"297\":[3,38],\"298\":[2,67],\"299\":[6,1],\"300\":[6,27],\"301\":[5],\"302\":[4,29],\"303\":[5,21],\"304\":[4,9],\"305\":[4,7],\"306\":[4,20],\"307\":[4,42],\"308\":[4,4],\"309\":[4,13],\"310\":[4,29],\"311\":[5],\"312\":[5,8],\"313\":[4,56],\"314\":[8,16],\"315\":[4,39],\"316\":[4,25],\"317\":[5,39],\"318\":[8,54],\"319\":[4],\"320\":[5,21],\"321\":[5,24],\"322\":[5,24],\"323\":[6,21],\"324\":[6,26],\"325\":[4,33],\"326\":[4,64],\"327\":[3],\"328\":[2,15],\"329\":[2,29],\"330\":[3,39],\"331\":[3,36],\"332\":[3,54],\"333\":[3],\"334\":[3,29],\"335\":[2],\"336\":[3,133],\"337\":[2,81],\"338\":[3,48],\"339\":[3,41],\"340\":[3,112],\"341\":[3,16],\"342\":[3,28],\"343\":[3,46],\"344\":[4,147],\"345\":[3],\"346\":[3,6],\"347\":[3,16],\"348\":[5,73],\"349\":[6,35],\"350\":[3],\"351\":[4,129],\"352\":[3,53],\"353\":[2,55],\"354\":[1,30],\"355\":[1,24],\"356\":[2,18],\"357\":[3,40],\"358\":[3,41],\"359\":[2,39],\"360\":[3,37],\"361\":[3,46],\"362\":[9],\"363\":[4,53],\"364\":[6,43],\"365\":[3,52],\"366\":[3],\"367\":[4,16],\"368\":[4,34],\"369\":[3,73],\"370\":[2],\"371\":[2,7],\"372\":[2,4],\"373\":[4,46],\"374\":[4,64],\"375\":[4,3],\"376\":[2,10],\"377\":[4,17],\"378\":[4,47],\"379\":[2],\"380\":[4,12],\"381\":[3],\"382\":[4,30],\"383\":[4,6],\"384\":[4],\"385\":[3,25],\"386\":[3,6],\"387\":[3],\"388\":[3,25],\"389\":[4,2],\"390\":[4],\"391\":[4,23],\"392\":[2],\"393\":[3,7],\"394\":[3],\"395\":[6,42],\"396\":[4,30],\"397\":[4,32],\"398\":[2],\"399\":[4,27],\"400\":[3,45],\"401\":[4,4],\"402\":[4,25],\"403\":[4,13],\"404\":[4,37],\"405\":[2,15],\"406\":[3],\"407\":[3,21],\"408\":[4,24],\"409\":[4,67],\"410\":[4,10],\"411\":[4],\"412\":[2],\"413\":[2,6],\"414\":[2,10],\"415\":[3,11],\"416\":[3],\"417\":[3,5],\"418\":[3,21],\"419\":[3,7],\"420\":[3,29],\"421\":[4,6],\"422\":[3,12],\"423\":[4,37],\"424\":[4,8],\"425\":[2],\"426\":[3,11],\"427\":[3,9],\"428\":[3,4],\"429\":[4,11],\"430\":[4,9],\"431\":[2],\"432\":[3,17],\"433\":[2,33],\"434\":[3],\"435\":[4,32],\"436\":[3,15],\"437\":[3,99],\"438\":[4,22],\"439\":[2],\"440\":[3,9],\"441\":[3,14],\"442\":[4,24],\"443\":[3],\"444\":[4,39],\"445\":[3,27],\"446\":[3,29],\"447\":[2,13],\"448\":[4,33],\"449\":[4,11],\"450\":[3,41],\"451\":[3],\"452\":[4,24],\"453\":[4,12],\"454\":[3],\"455\":[1,33],\"456\":[1,5],\"457\":[1,27],\"458\":[1,28],\"459\":[5,28],\"460\":[4,23],\"461\":[4,18],\"462\":[3,9],\"463\":[8,11],\"464\":[2,5],\"465\":[2,10],\"466\":[2,15],\"467\":[4,14],\"468\":[5,1],\"469\":[3,9],\"470\":[3,39],\"471\":[2],\"472\":[5,2],\"473\":[4,2],\"474\":[3,12],\"475\":[2,2],\"476\":[1,5],\"477\":[3,64],\"478\":[1,44],\"479\":[1,2],\"480\":[1,147],\"481\":[1,157],\"482\":[1,111],\"483\":[1,88],\"484\":[1],\"485\":[1,29],\"486\":[2,9],\"487\":[5,18],\"488\":[1,24],\"489\":[1,2],\"490\":[1,5],\"491\":[2,22],\"492\":[1,9],\"493\":[1,134],\"494\":[1,15],\"495\":[1,42],\"496\":[1,24],\"497\":[5,38],\"498\":[2,11],\"499\":[1,12],\"500\":[1],\"501\":[1,19],\"502\":[1,18],\"503\":[1,58],\"504\":[1,15],\"505\":[1,22],\"506\":[1,153],\"507\":[1,27],\"508\":[1,18],\"509\":[1,2],\"510\":[1,46],\"511\":[1,22],\"512\":[1,2],\"513\":[1,26],\"514\":[1],\"515\":[1,61],\"516\":[1,12],\"517\":[1,13],\"518\":[1,8],\"519\":[2,17],\"520\":[1,10],\"521\":[2,4],\"522\":[1,50],\"523\":[1,17],\"524\":[1],\"525\":[1,3],\"526\":[1,51],\"527\":[1,32],\"528\":[1,19],\"529\":[1,34],\"530\":[1,22],\"531\":[1],\"532\":[3,14],\"533\":[3,20],\"534\":[2,10],\"535\":[1,10],\"536\":[1,59],\"537\":[1,7],\"538\":[1,54],\"539\":[1,15],\"540\":[1,13],\"541\":[1,59],\"542\":[1,18],\"543\":[1,11],\"544\":[1,11],\"545\":[3,11],\"546\":[3,8],\"547\":[1,14],\"548\":[1,11],\"549\":[3,51],\"550\":[3],\"551\":[1,57],\"552\":[1,16],\"553\":[1,4],\"554\":[1,50],\"555\":[1,60],\"556\":[1,15],\"557\":[1,15],\"558\":[1,18],\"559\":[1,8],\"560\":[1,39],\"561\":[1,24],\"562\":[1,98],\"563\":[1,13],\"564\":[1,40],\"565\":[1,23],\"566\":[1,53],\"567\":[1,40],\"568\":[1,5],\"569\":[1],\"570\":[1,14],\"571\":[1,34],\"572\":[1,37],\"573\":[1,16],\"574\":[1,90],\"575\":[6,6],\"576\":[1,36],\"577\":[1,25],\"578\":[1,15],\"579\":[1,241],\"580\":[1,3],\"581\":[1,9],\"582\":[1,27],\"583\":[1,14],\"584\":[1,16],\"585\":[1,69],\"586\":[1,2],\"587\":[1],\"588\":[1,33],\"589\":[1,5],\"590\":[1,57],\"591\":[1,54],\"592\":[1,26],\"593\":[1,58],\"594\":[1],\"595\":[1,21],\"596\":[1,17],\"597\":[1,9],\"598\":[1,12],\"599\":[1,16],\"600\":[1,13],\"601\":[1,19],\"602\":[1,21],\"603\":[1,13],\"604\":[2,14],\"605\":[1,28],\"606\":[1,37],\"607\":[3,4],\"608\":[3,3],\"609\":[1,28],\"610\":[1,120],\"611\":[1,22],\"612\":[1,30],\"613\":[1],\"614\":[1,79],\"615\":[1,27],\"616\":[1,32],\"617\":[1,52],\"618\":[1,15],\"619\":[1,39],\"620\":[1,42],\"621\":[1,45],\"622\":[1],\"623\":[1,22],\"624\":[1,14],\"625\":[2,6],\"626\":[1,5],\"627\":[1,14],\"628\":[4,41],\"629\":[1,17],\"630\":[1,68],\"631\":[1,21],\"632\":[1,16],\"633\":[1,56],\"634\":[1,19],\"635\":[3,11],\"636\":[1,12],\"637\":[1,36],\"638\":[1,62],\"639\":[1,16],\"640\":[4,18],\"641\":[1],\"642\":[1,1],\"643\":[1,5],\"644\":[1,7],\"645\":[1,48],\"646\":[1,33],\"647\":[1],\"648\":[1,86],\"649\":[1,60],\"650\":[1],\"651\":[1,14],\"652\":[1,9],\"653\":[null,null,1],\"654\":[null,null,1],\"655\":[1],\"656\":[1,8],\"657\":[1,1],\"658\":[1,54],\"659\":[1,39],\"660\":[1,14],\"661\":[1,36],\"662\":[2,118],\"663\":[2,248],\"664\":[1,30],\"665\":[1,83],\"666\":[1,81],\"667\":[1,34],\"668\":[3,68],\"669\":[1,60],\"670\":[1],\"671\":[1,32],\"672\":[1,4],\"673\":[2,42],\"674\":[1],\"675\":[1,6],\"676\":[3,60],\"677\":[1,16],\"678\":[3,19],\"679\":[3,151],\"680\":[2,203],\"681\":[1],\"682\":[1,5],\"683\":[1,161],\"684\":[1,6],\"685\":[2,11],\"686\":[1,5],\"687\":[1,27],\"688\":[3,38],\"689\":[1,54],\"690\":[1,44],\"691\":[1],\"692\":[1,168],\"693\":[1,121],\"694\":[1,145],\"695\":[1,16],\"696\":[2,96],\"697\":[2,171],\"698\":[2,182],\"699\":[2,199],\"700\":[1],\"701\":[1,78],\"702\":[2,166],\"703\":[2,61],\"704\":[2,82],\"705\":[2,33],\"706\":[2],\"707\":[1,88],\"708\":[1],\"709\":[2,82],\"710\":[2,78],\"711\":[2,86],\"712\":[1,23],\"713\":[1,109],\"714\":[2,103],\"715\":[1],\"716\":[1,46],\"717\":[1,91],\"718\":[1,123],\"719\":[1,32],\"720\":[1],\"721\":[1],\"722\":[1],\"723\":[1,238],\"724\":[1],\"725\":[4,103],\"726\":[3,160],\"727\":[3,1],\"728\":[3,9],\"729\":[4,14],\"730\":[2,8],\"731\":[3,15],\"732\":[2],\"733\":[2,175],\"734\":[3,53],\"735\":[2,76],\"736\":[4,21],\"737\":[3,142],\"738\":[4,47],\"739\":[1],\"740\":[1,324],\"741\":[2,194],\"742\":[1,189],\"743\":[2,235],\"744\":[2,102],\"745\":[1],\"746\":[1,76],\"747\":[1,9],\"748\":[5,193],\"749\":[3,44],\"750\":[3,35],\"751\":[3,35],\"752\":[1,19],\"753\":[1,93],\"754\":[1,81],\"755\":[1,63],\"756\":[2,73],\"757\":[2,35],\"758\":[2,39],\"759\":[1,44],\"760\":[1,43],\"761\":[1,48],\"762\":[1,83],\"763\":[1,55],\"764\":[1,49],\"765\":[1,78],\"766\":[2,173],\"767\":[1,1],\"768\":[2,46],\"769\":[4,21],\"770\":[4,36],\"771\":[2,7],\"772\":[2,100],\"773\":[2,64],\"774\":[2,59],\"775\":[3,172],\"776\":[2,113],\"777\":[2,13],\"778\":[2,5],\"779\":[2,94],\"780\":[2,72],\"781\":[2,18],\"782\":[2],\"783\":[1,22],\"784\":[1,71],\"785\":[1,84],\"786\":[1],\"787\":[1,51],\"788\":[1],\"789\":[3,23],\"790\":[2,3],\"791\":[2,37],\"792\":[2,53],\"793\":[1],\"794\":[1,81],\"795\":[1,84],\"796\":[1,77],\"797\":[2,19],\"798\":[2,24],\"799\":[1,147],\"800\":[2],\"801\":[1,23],\"802\":[3,17],\"803\":[3,30],\"804\":[3,16],\"805\":[3,50],\"806\":[2,2],\"807\":[2,57],\"808\":[2,65],\"809\":[1,70],\"810\":[1],\"811\":[1],\"812\":[2,2],\"813\":[1,18],\"814\":[1,13],\"815\":[1,18],\"816\":[1,11],\"817\":[1,19],\"818\":[1,3],\"819\":[1,9],\"820\":[3,64],\"821\":[1,41],\"822\":[1,99],\"823\":[1,45],\"824\":[1],\"825\":[3],\"826\":[1,95],\"827\":[1,91],\"828\":[1,24],\"829\":[1,11],\"830\":[1,5],\"831\":[3,30],\"832\":[3,24],\"833\":[2,29],\"834\":[3,80],\"835\":[1,9],\"836\":[3,131],\"837\":[4,27],\"838\":[2,10],\"839\":[1,66],\"840\":[1,191],\"841\":[2,44],\"842\":[3],\"843\":[1,131],\"844\":[2,9],\"845\":[1],\"846\":[1,134],\"847\":[3,21],\"848\":[1,82],\"849\":[3],\"850\":[3,16],\"851\":[2,30],\"852\":[1,4],\"853\":[1],\"854\":[3,78],\"855\":[2,89],\"856\":[1,25],\"857\":[2,84],\"858\":[1,8],\"859\":[2,93],\"860\":[1],\"861\":[2,32],\"862\":[1,3],\"863\":[1],\"864\":[1,3],\"865\":[1],\"866\":[1,5],\"867\":[2,22],\"868\":[2],\"869\":[2,41],\"870\":[2,65],\"871\":[2],\"872\":[3,63],\"873\":[5,32],\"874\":[7,45],\"875\":[7,189],\"876\":[2,83],\"877\":[2],\"878\":[3,82],\"879\":[3,54],\"880\":[3,24],\"881\":[3],\"882\":[3,50],\"883\":[3,19],\"884\":[5,16],\"885\":[5,26],\"886\":[4,19],\"887\":[3],\"888\":[3,22],\"889\":[3,20],\"890\":[2,3],\"891\":[2],\"892\":[3,10],\"893\":[2],\"894\":[2,1],\"895\":[4,1],\"896\":[2],\"897\":[3],\"898\":[1,14],\"899\":[1,8],\"900\":[1,9],\"901\":[1,47],\"902\":[3,29],\"903\":[2,46],\"904\":[2],\"905\":[3,17],\"906\":[2,5],\"907\":[2],\"908\":[3,2],\"909\":[2,15],\"910\":[3,59],\"911\":[3,6],\"912\":[3,18],\"913\":[2,14],\"914\":[3,34],\"915\":[2],\"916\":[3,18],\"917\":[3,15],\"918\":[6,17],\"919\":[3,35],\"920\":[3,38],\"921\":[2,6],\"922\":[3,9],\"923\":[3,58],\"924\":[5,35],\"925\":[3,15],\"926\":[4,44],\"927\":[4,31],\"928\":[2,8],\"929\":[3],\"930\":[1,1],\"931\":[1,16],\"932\":[1,7],\"933\":[3,13],\"934\":[1,31],\"935\":[1,9],\"936\":[3,88],\"937\":[2],\"938\":[1],\"939\":[2],\"940\":[2],\"941\":[2,1],\"942\":[3,12],\"943\":[2],\"944\":[3,27],\"945\":[1,20],\"946\":[1,13],\"947\":[1,14],\"948\":[2,30],\"949\":[2,55],\"950\":[2],\"951\":[3,37],\"952\":[3,12],\"953\":[3,58],\"954\":[2],\"955\":[2,3],\"956\":[3,56],\"957\":[2,66],\"958\":[1,48],\"959\":[1,23],\"960\":[1,43],\"961\":[1,39],\"962\":[1,116],\"963\":[2,26],\"964\":[2],\"965\":[3,35],\"966\":[3,11],\"967\":[2],\"968\":[3,56],\"969\":[3,7],\"970\":[3,25],\"971\":[3],\"972\":[3,159],\"973\":[3,157],\"974\":[2,185],\"975\":[2],\"976\":[3,42],\"977\":[3,5],\"978\":[2],\"979\":[3,101],\"980\":[3,36],\"981\":[2],\"982\":[3],\"983\":[2,56],\"984\":[2,18],\"985\":[3,176],\"986\":[2,149],\"987\":[3],\"988\":[5,212],\"989\":[3,39],\"990\":[4,119],\"991\":[3,128],\"992\":[2,10],\"993\":[2],\"994\":[3],\"995\":[3,20],\"996\":[1,2],\"997\":[1,40],\"998\":[2,49],\"999\":[1,153],\"1000\":[1,21],\"1001\":[1,20],\"1002\":[1,8],\"1003\":[1,32],\"1004\":[1,29],\"1005\":[1,57],\"1006\":[1,1],\"1007\":[2],\"1008\":[2,17],\"1009\":[3,26],\"1010\":[3,12],\"1011\":[3],\"1012\":[5,61],\"1013\":[2,27],\"1014\":[2],\"1015\":[4,20],\"1016\":[4,14],\"1017\":[4,16],\"1018\":[4,15],\"1019\":[3,23],\"1020\":[4,15],\"1021\":[3,60],\"1022\":[4,92],\"1023\":[3,98],\"1024\":[3,83],\"1025\":[3,74],\"1026\":[2,71],\"1027\":[2,6],\"1028\":[3,10],\"1029\":[3,21],\"1030\":[2],\"1031\":[3],\"1032\":[1,6],\"1033\":[1,8],\"1034\":[3,12],\"1035\":[1,57],\"1036\":[5],\"1037\":[2,33],\"1038\":[2,15],\"1039\":[3],\"1040\":[2,30],\"1041\":[1,20],\"1042\":[2,50],\"1043\":[3,34],\"1044\":[3],\"1045\":[5,28],\"1046\":[4,108],\"1047\":[3],\"1048\":[1,22],\"1049\":[3,14],\"1050\":[1,40],\"1051\":[1,18],\"1052\":[1,18],\"1053\":[1,20],\"1054\":[1,22],\"1055\":[1,17],\"1056\":[2,27],\"1057\":[2],\"1058\":[1],\"1059\":[2],\"1060\":[2],\"1061\":[4,19],\"1062\":[5,21],\"1063\":[5,17],\"1064\":[5,3],\"1065\":[5,12],\"1066\":[5,30],\"1067\":[5,50],\"1068\":[5,6],\"1069\":[2],\"1070\":[3,51],\"1071\":[2,34],\"1072\":[3,43],\"1073\":[3,73],\"1074\":[2],\"1075\":[3,34],\"1076\":[3,34],\"1077\":[2,39],\"1078\":[3,39],\"1079\":[3,40],\"1080\":[3,43],\"1081\":[3,41],\"1082\":[3,42],\"1083\":[3,49],\"1084\":[3,40],\"1085\":[3,40],\"1086\":[2],\"1087\":[3,31],\"1088\":[3,34],\"1089\":[3,127],\"1090\":[2,1],\"1091\":[2],\"1092\":[2],\"1093\":[2],\"1094\":[3,38],\"1095\":[3,2],\"1096\":[3],\"1097\":[3],\"1098\":[3,33],\"1099\":[3,75],\"1100\":[3,120],\"1101\":[3,44],\"1102\":[3,27],\"1103\":[3],\"1104\":[3,14],\"1105\":[4,18],\"1106\":[4,16],\"1107\":[3,106],\"1108\":[3],\"1109\":[4,8],\"1110\":[4,9],\"1111\":[4,89],\"1112\":[2],\"1113\":[4,65],\"1114\":[3,18],\"1115\":[3,23],\"1116\":[2,17],\"1117\":[3,7],\"1118\":[3,7],\"1119\":[3,20],\"1120\":[5,29],\"1121\":[3,44],\"1122\":[3,90],\"1123\":[3,51],\"1124\":[4,84],\"1125\":[3,8],\"1126\":[3,97],\"1127\":[3,123],\"1128\":[3,148],\"1129\":[3,220],\"1130\":[2],\"1131\":[3,41],\"1132\":[3,127],\"1133\":[2,67],\"1134\":[3,90],\"1135\":[3,112],\"1136\":[3,59],\"1137\":[4,185],\"1138\":[3,31],\"1139\":[2],\"1140\":[3,56],\"1141\":[3,48],\"1142\":[3,114],\"1143\":[2,32],\"1144\":[3,85],\"1145\":[3,21],\"1146\":[3,90],\"1147\":[3,100],\"1148\":[3],\"1149\":[5,60],\"1150\":[5,135],\"1151\":[5,97],\"1152\":[7,158],\"1153\":[3,41],\"1154\":[2],\"1155\":[4,129],\"1156\":[5,144],\"1157\":[4,181],\"1158\":[2],\"1159\":[4,83],\"1160\":[4,36],\"1161\":[4,150],\"1162\":[4,132],\"1163\":[2],\"1164\":[4,101],\"1165\":[4,142],\"1166\":[4,105],\"1167\":[4,125],\"1168\":[4,141],\"1169\":[2],\"1170\":[5,45],\"1171\":[5,117],\"1172\":[4,184],\"1173\":[2],\"1174\":[5,133],\"1175\":[4,73],\"1176\":[4,143],\"1177\":[6,87],\"1178\":[3],\"1179\":[5,52],\"1180\":[4,38],\"1181\":[2,3],\"1182\":[2,21],\"1183\":[2],\"1184\":[3,11],\"1185\":[3,13],\"1186\":[3,29],\"1187\":[4,5],\"1188\":[4,5],\"1189\":[4,24],\"1190\":[2,30],\"1191\":[3,6],\"1192\":[4,8],\"1193\":[3,35],\"1194\":[3,5],\"1195\":[4,13],\"1196\":[4,80],\"1197\":[4,47],\"1198\":[3,8],\"1199\":[4,29],\"1200\":[3,13],\"1201\":[4,8],\"1202\":[3,18],\"1203\":[2],\"1204\":[3,19],\"1205\":[4,89],\"1206\":[3,124],\"1207\":[4,48],\"1208\":[4,72],\"1209\":[4,47],\"1210\":[4,79],\"1211\":[4,61],\"1212\":[3,26],\"1213\":[3,87],\"1214\":[3,10],\"1215\":[4,48],\"1216\":[3,33],\"1217\":[3,25],\"1218\":[3,3],\"1219\":[3,111],\"1220\":[4,26],\"1221\":[4,37],\"1222\":[3,49],\"1223\":[3,90],\"1224\":[3,32],\"1225\":[null,null,1],\"1226\":[null,null,1],\"1227\":[2],\"1228\":[1],\"1229\":[3,15],\"1230\":[2,137],\"1231\":[1,1],\"1232\":[1,60],\"1233\":[2],\"1234\":[2,30],\"1235\":[1,25],\"1236\":[2,79],\"1237\":[1,1],\"1238\":[2],\"1239\":[2],\"1240\":[2,26],\"1241\":[5],\"1242\":[1,4],\"1243\":[1,74],\"1244\":[2,58],\"1245\":[2,48],\"1246\":[2],\"1247\":[1,4],\"1248\":[1,43],\"1249\":[4],\"1250\":[1,4],\"1251\":[1,7],\"1252\":[3,37],\"1253\":[3],\"1254\":[1,32],\"1255\":[1,8],\"1256\":[2],\"1257\":[1,44],\"1258\":[3],\"1259\":[1,4],\"1260\":[1,9],\"1261\":[3],\"1262\":[2],\"1263\":[1,4],\"1264\":[1,29],\"1265\":[4],\"1266\":[1,4],\"1267\":[1,21],\"1268\":[3],\"1269\":[3],\"1270\":[1,13],\"1271\":[1,13],\"1272\":[3],\"1273\":[1,4],\"1274\":[1,16],\"1275\":[3],\"1276\":[1,4],\"1277\":[1,3],\"1278\":[4],\"1279\":[1,4],\"1280\":[1,13],\"1281\":[3],\"1282\":[5],\"1283\":[1,4],\"1284\":[1,26],\"1285\":[3,50],\"1286\":[2],\"1287\":[2],\"1288\":[1,4],\"1289\":[1,28],\"1290\":[2,51],\"1291\":[5],\"1292\":[1,22],\"1293\":[1,18],\"1294\":[5,72],\"1295\":[2],\"1296\":[1,16],\"1297\":[1,19],\"1298\":[1,38],\"1299\":[5,5],\"1300\":[1,27],\"1301\":[5,5],\"1302\":[1,5],\"1303\":[4],\"1304\":[3,39],\"1305\":[1,4],\"1306\":[3,40],\"1307\":[1,9],\"1308\":[3],\"1309\":[4,72],\"1310\":[1,24],\"1311\":[2],\"1312\":[1,4],\"1313\":[1,24],\"1314\":[3],\"1315\":[4],\"1316\":[1,4],\"1317\":[1,79],\"1318\":[3],\"1319\":[3],\"1320\":[1,5],\"1321\":[1,55],\"1322\":[7,39],\"1323\":[4],\"1324\":[1,4],\"1325\":[1,27],\"1326\":[2],\"1327\":[2],\"1328\":[1,4],\"1329\":[1,7],\"1330\":[5],\"1331\":[2],\"1332\":[1,6],\"1333\":[1,29],\"1334\":[2],\"1335\":[1,7],\"1336\":[1,9],\"1337\":[3],\"1338\":[1,7],\"1339\":[1,20],\"1340\":[2,34],\"1341\":[2],\"1342\":[1,5],\"1343\":[1,30],\"1344\":[3],\"1345\":[1,6],\"1346\":[1,8],\"1347\":[2],\"1348\":[2],\"1349\":[1,6],\"1350\":[1,15],\"1351\":[1],\"1352\":[4,10],\"1353\":[3],\"1354\":[1,4],\"1355\":[1,45],\"1356\":[2],\"1357\":[1,5],\"1358\":[1,2],\"1359\":[2],\"1360\":[2],\"1361\":[1,4],\"1362\":[1,40],\"1363\":[2],\"1364\":[2],\"1365\":[1,4],\"1366\":[1,22],\"1367\":[2],\"1368\":[1,22],\"1369\":[1,10],\"1370\":[1,42],\"1371\":[2],\"1372\":[1,4],\"1373\":[1,5],\"1374\":[2],\"1375\":[1,4],\"1376\":[1,23],\"1377\":[2],\"1378\":[1,5],\"1379\":[1,4],\"1380\":[4],\"1381\":[3,11],\"1382\":[1,15],\"1383\":[2],\"1384\":[1,18],\"1385\":[1],\"1386\":[1],\"1387\":[4],\"1388\":[3],\"1389\":[1,9],\"1390\":[1,15],\"1391\":[2],\"1392\":[2],\"1393\":[1,4],\"1394\":[1,31],\"1395\":[2],\"1396\":[3],\"1397\":[1,4],\"1398\":[1,19],\"1399\":[4],\"1400\":[3],\"1401\":[1,9],\"1402\":[1,2],\"1403\":[2],\"1404\":[2],\"1405\":[1,4],\"1406\":[1,4],\"1407\":[4],\"1408\":[3],\"1409\":[1,4],\"1410\":[1,11],\"1411\":[3,88],\"1412\":[2],\"1413\":[1,21],\"1414\":[1,2],\"1415\":[2],\"1416\":[1,55],\"1417\":[1,5],\"1418\":[4],\"1419\":[2],\"1420\":[1,20],\"1421\":[1,14],\"1422\":[4],\"1423\":[2],\"1424\":[1,21],\"1425\":[1,10],\"1426\":[4],\"1427\":[2],\"1428\":[1,7],\"1429\":[1,30],\"1430\":[1,9],\"1431\":[2],\"1432\":[1,23],\"1433\":[1,2],\"1434\":[2],\"1435\":[1,20],\"1436\":[1,18],\"1437\":[1,41],\"1438\":[3,118],\"1439\":[1],\"1440\":[3,25],\"1441\":[3,53],\"1442\":[1,45],\"1443\":[1,13],\"1444\":[3,70],\"1445\":[2,24],\"1446\":[1,39],\"1447\":[3,42],\"1448\":[3],\"1449\":[1,70],\"1450\":[4],\"1451\":[1,35],\"1452\":[3],\"1453\":[1,31],\"1454\":[1,43],\"1455\":[1,57],\"1456\":[1,31],\"1457\":[1,2],\"1458\":[1,3],\"1459\":[1,10],\"1460\":[1,4],\"1461\":[1,13],\"1462\":[1,25],\"1463\":[2],\"1464\":[1,51],\"1465\":[1,18],\"1466\":[2,71],\"1467\":[1,3],\"1468\":[1],\"1469\":[2],\"1470\":[2],\"1471\":[1,4],\"1472\":[1,31],\"1473\":[3,15],\"1474\":[2],\"1475\":[1,4],\"1476\":[1,27],\"1477\":[2],\"1478\":[2],\"1479\":[1,4],\"1480\":[1,16],\"1481\":[3],\"1482\":[1,59],\"1483\":[3],\"1484\":[1,4],\"1485\":[1,10],\"1486\":[3],\"1487\":[3],\"1488\":[1,4],\"1489\":[1,65],\"1490\":[2],\"1491\":[2],\"1492\":[1,4],\"1493\":[1,14],\"1494\":[2],\"1495\":[2],\"1496\":[1,4],\"1497\":[1,22],\"1498\":[1],\"1499\":[1,80],\"1500\":[2,36],\"1501\":[1,38],\"1502\":[1,20],\"1503\":[1,34],\"1504\":[1,31],\"1505\":[1,84],\"1506\":[1,17],\"1507\":[3,15],\"1508\":[1,14],\"1509\":[4,6],\"1510\":[1,12],\"1511\":[2,6],\"1512\":[2,11],\"1513\":[1,11],\"1514\":[1,47],\"1515\":[3,27],\"1516\":[7,8],\"1517\":[2,7],\"1518\":[1,1],\"1519\":[1],\"1520\":[2,24],\"1521\":[3,19],\"1522\":[2,23],\"1523\":[2,8],\"1524\":[2,24],\"1525\":[2,210],\"1526\":[2,47],\"1527\":[1],\"1528\":[1,16],\"1529\":[1,7],\"1530\":[2,54],\"1531\":[2,48],\"1532\":[2,47],\"1533\":[1],\"1534\":[1],\"1535\":[2],\"1536\":[1],\"1537\":[1],\"1538\":[1],\"1539\":[1],\"1540\":[1],\"1541\":[1],\"1542\":[1],\"1543\":[1],\"1544\":[1],\"1545\":[1],\"1546\":[1],\"1547\":[1],\"1548\":[1],\"1549\":[1],\"1550\":[1],\"1551\":[1],\"1552\":[1],\"1553\":[1],\"1554\":[1],\"1555\":[1],\"1556\":[1],\"1557\":[1],\"1558\":[1],\"1559\":[1],\"1560\":[1],\"1561\":[1],\"1562\":[1]},\"averageFieldLength\":[2.2356894367356217,40.20535794645005,0.004678449890193297],\"storedFields\":{\"0\":{\"h\":\"介绍\"},\"1\":{\"h\":\"TODO\"},\"2\":{\"h\":\"幻灯片页\"},\"3\":{\"h\":\"适配器模式\",\"t\":[\"程序媛教你一看就懂的适配器设计模式！\"]},\"4\":{\"h\":\"概述\",\"t\":[\"如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\",\"定义：\",\"​ 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\",\"​ 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\"]},\"5\":{\"h\":\"结构\",\"t\":[\"适配器模式（Adapter）包含以下主要角色：\",\"目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\",\"适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\",\"适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\"]},\"6\":{\"h\":\"类适配器模式\",\"t\":[\"实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。\",\"【例】读卡器\",\"现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。\",\"类图如下：\",\"代码如下：\",\"//SD卡的接口 public interface SDCard { //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg); } //SD卡实现类 public class SDCardImpl implements SDCard { public String readSD() { String msg = \\\"sd card read a msg :hello word SD\\\"; return msg; } public void writeSD(String msg) { System.out.println(\\\"sd card write msg : \\\" + msg); } } //电脑类 public class Computer { public String readSD(SDCard sdCard) { if(sdCard == null) { throw new NullPointerException(\\\"sd card null\\\"); } return sdCard.readSD(); } } //TF卡接口 public interface TFCard { //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg); } //TF卡实现类 public class TFCardImpl implements TFCard { public String readTF() { String msg =\\\"tf card read msg : hello word tf card\\\"; return msg; } public void writeTF(String msg) { System.out.println(\\\"tf card write a msg : \\\" + msg); } } //定义适配器类（SD兼容TF） public class SDAdapterTF extends TFCardImpl implements SDCard { public String readSD() { System.out.println(\\\"adapter read tf card \\\"); return readTF(); } public void writeSD(String msg) { System.out.println(\\\"adapter write tf card\\\"); writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\\\"------------\\\"); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); } } \",\"类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。\"]},\"7\":{\"h\":\"对象适配器模式\",\"t\":[\"实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。\",\"【例】读卡器\",\"我们使用对象适配器模式将读卡器的案例进行改写。类图如下：\",\"代码如下：\",\"类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。\",\"//创建适配器对象（SD兼容TF） public class SDAdapterTF implements SDCard { private TFCard tfCard; public SDAdapterTF(TFCard tfCard) { this.tfCard = tfCard; } public String readSD() { System.out.println(\\\"adapter read tf card \\\"); return tfCard.readTF(); } public void writeSD(String msg) { System.out.println(\\\"adapter write tf card\\\"); tfCard.writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\\\"------------\\\"); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); } } \",\"注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。\"]},\"8\":{\"h\":\"应用场景\",\"t\":[\"以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。\",\"使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。\"]},\"9\":{\"h\":\"JDK源码解析\",\"t\":[\"Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。\",\"InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：\",\"public int read() throws IOException { return sd.read(); } public int read(char cbuf[], int offset, int length) throws IOException { return sd.read(cbuf, offset, length); } \",\"如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：\",\"从上图可以看出：\",\"InputStreamReader是对同样实现了Reader的StreamDecoder的封装。\",\"StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。\",\"​ 从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。\"]},\"10\":{\"h\":\"代理 V.S 桥接 V.S 装饰器 V.S 适配器\",\"t\":[\"都可称为Wrapper模式，即通过Wrapper类二次封装原始类。代码结构相似，但要解决的问题、应用场景不同。\",\"代理模式不改变原始类接口的条件下，为原始类定义一个代理类，主要为控制访问，而非加强功能，这是和装饰器模式的最大不同\",\"桥接模式将接口部分和实现部分分离，让它们更容易、也相对独立地改变\",\"装饰器模式不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用\",\"适配器模式适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\"]},\"11\":{\"h\":\"建造者模式\"},\"12\":{\"h\":\"概述\",\"t\":[\"将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\",\"分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。\",\"由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。\",\"建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。\"]},\"13\":{\"h\":\"结构\",\"t\":[\"建造者（Builder）模式包含如下角色：\",\"抽象建造者类（Builder）：这个接口（可以是接口或者抽象类）规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建。\",\"具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。\",\"产品类（Product）：要创建的复杂对象。\",\"指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。\",\"类图如下：\"]},\"14\":{\"h\":\"实例\",\"t\":[\"创建共享单车\",\"生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\",\"这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\",\"具体的代码如下：\",\"//自行车类 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.seat = seat; } } // 抽象 builder 类 （定义各种抽象组件） public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); } //摩拜单车Builder类 public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\\\"铝合金车架\\\"); } @Override public void buildSeat() { mBike.setSeat(\\\"真皮车座\\\"); } @Override public Bike createBike() { return mBike; } } //ofo单车Builder类 public class OfoBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\\\"碳纤维车架\\\"); } @Override public void buildSeat() { mBike.setSeat(\\\"橡胶车座\\\"); } @Override public Bike createBike() { return mBike; } } //指挥者类 （对组件进行一定顺序的组装） public class Director { private Builder mBuilder; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); } } //测试类 public class Client { public static void main(String[] args) { showBike(new OfoBuilder()); showBike(new MobikeBuilder()); } private static void showBike(Builder builder) { Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); } } \",\"注意：\",\"上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\",\"// 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() { this.buildFrame(); this.BuildSeat(); return this.createBike(); } } \",\"说明：\",\"这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\"]},\"15\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。\",\"在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\",\"可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\",\"建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。\",\"缺点：\",\"造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\"]},\"16\":{\"h\":\"使用场景\",\"t\":[\"建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\",\"创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。\",\"创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。\"]},\"17\":{\"h\":\"模式扩展\",\"t\":[\"建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\",\"重构前代码如下：\",\"public class Phone { private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) { this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; } public String getCpu() { return cpu; } public void setCpu(String cpu) { this.cpu = cpu; } public String getScreen() { return screen; } public void setScreen(String screen) { this.screen = screen; } public String getMemory() { return memory; } public void setMemory(String memory) { this.memory = memory; } public String getMainboard() { return mainboard; } public void setMainboard(String mainboard) { this.mainboard = mainboard; } @Override public String toString() { return \\\"Phone{\\\" + \\\"cpu='\\\" + cpu + '\\\\'' + \\\", screen='\\\" + screen + '\\\\'' + \\\", memory='\\\" + memory + '\\\\'' + \\\", mainboard='\\\" + mainboard + '\\\\'' + '}'; } } public class Client { public static void main(String[] args) { //构建Phone对象 Phone phone = new Phone(\\\"intel\\\",\\\"三星屏幕\\\",\\\"金士顿\\\",\\\"华硕\\\"); System.out.println(phone); } } \",\"上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\",\"重构后代码：\",\"public class Phone { private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public Phone build() { return new Phone(this); } } @Override public String toString() { return \\\"Phone{\\\" + \\\"cpu='\\\" + cpu + '\\\\'' + \\\", screen='\\\" + screen + '\\\\'' + \\\", memory='\\\" + memory + '\\\\'' + \\\", mainboard='\\\" + mainboard + '\\\\'' + '}'; } } public class Client { public static void main(String[] args) { Phone phone = new Phone.Builder() .cpu(\\\"intel\\\") .mainboard(\\\"华硕\\\") .memory(\\\"金士顿\\\") .screen(\\\"三星\\\") .build(); System.out.println(phone); } } \",\"重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\"]},\"18\":{\"h\":\"创建者模式对比\"},\"19\":{\"h\":\"工厂方法模式VS建造者模式\",\"t\":[\"工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\",\"我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\"]},\"20\":{\"h\":\"抽象工厂模式VS建造者模式\",\"t\":[\"抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\",\"建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\",\"如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\"]},\"21\":{\"h\":\"设计模式\"},\"22\":{\"h\":\"单例模式\",\"t\":[\"单例模式的应用场景 | HefeiJoe Blog\",\"懒汉式线程不安全\",\"public class Singleton1 { private static Singleton1 instance; private Singleton1() { } public static Singleton1 getInstance() { if (instance == null) { instance = new Singleton1(); } return instance; } } \",\"懒汉式线程安全\",\"public class Singleton2 { public static Singleton2 instance; public Singleton2() { } public static synchronized Singleton2 getInstance() { if (instance == null) { instance = new Singleton2(); } return instance; } } \",\"饿汉式\",\"public class Singleton3 { private static Singleton3 instance = new Singleton3(); private Singleton3() { } public static Singleton3 getInstance() { return instance; } } \",\"懒汉式双重锁校验\",\"public class Singleton4 { private volatile static Singleton4 instance; private Singleton4() {} public static Singleton4 getInstance() { // instanceb if (instance == null) { // 首次创建会同步 synchronized (Singleton4.class) { if (instance == null) { instance = new Singleton4(); } } } return instance; } } \",\"双重校验锁\"]},\"23\":{\"h\":\"工厂模式\",\"t\":[\"意图： 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\",\"主要解决： 主要解决接口选择的问题。\",\"何时使用： 我们明确地计划不同条件下创建不同实例时。\",\"如何解决： 让其子类实现工厂接口，返回的也是一个抽象的产品。\",\"优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\",\"缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\",\"Shape.java\",\"public interface Shape { void draw(); } \",\"Rectangle.java\",\"public class Rectangle implements Shape { @Override public void draw() { System.out.println(\\\"Inside Rectangle::draw() method.\\\"); } } \",\"Square.java\",\"public class Square implements Shape { @Override public void draw() { System.out.println(\\\"Inside Square::draw() method.\\\"); } } \",\"Circle.java\",\"public class Circle implements Shape { @Override public void draw() { System.out.println(\\\"Inside Circle::draw() method.\\\"); } } \",\"ShapeFactory.java\",\"public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\\\"CIRCLE\\\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\\\"RECTANGLE\\\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\\\"SQUARE\\\")){ return new Square(); } return null; } } \"]},\"24\":{\"h\":\"工厂模式\"},\"25\":{\"h\":\"概述\",\"t\":[\"需求：设计一个咖啡店点餐系统。\",\"设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\",\"具体类的设计如下：\",\"在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。\",\"在本教程中会介绍三种工厂的使用\",\"简单工厂模式（不属于GoF的23种经典设计模式）\",\"工厂方法模式\",\"抽象工厂模式\"]},\"26\":{\"h\":\"简单工厂模式\",\"t\":[\"简单工厂不是一种设计模式，反而比较像是一种编程习惯。\"]},\"27\":{\"h\":\"结构\",\"t\":[\"简单工厂包含如下角色：\",\"抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\",\"具体产品 ：实现或者继承抽象产品的子类\",\"具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\"]},\"28\":{\"h\":\"实现\",\"t\":[\"现在使用简单工厂对上面案例进行改进，类图如下：\",\"工厂类代码如下：\",\"public class SimpleCoffeeFactory { public Coffee createCoffee(String type) { Coffee coffee = null; if(\\\"americano\\\".equals(type)) { coffee = new AmericanoCoffee(); } else if(\\\"latte\\\".equals(type)) { coffee = new LatteCoffee(); } else { throw new RuntimeException(\\\"对不起，您所点的咖啡没有\\\"); } return coffee; } } \",\"工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。\",\"后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。\"]},\"29\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\",\"缺点：\",\"增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\"]},\"30\":{\"h\":\"扩展\",\"t\":[\"静态工厂\",\"在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\",\"public class SimpleCoffeeFactory { public static Coffee createCoffee(String type) { Coffee coffee = null; if(\\\"americano\\\".equals(type)) { coffee = new AmericanoCoffee(); } else if(\\\"latte\\\".equals(type)) { coffee = new LatteCoffee(); } return coffe; } } \"]},\"31\":{\"h\":\"工厂方法模式\",\"t\":[\"针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。\"]},\"32\":{\"h\":\"概念\",\"t\":[\"定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\"]},\"33\":{\"h\":\"结构\",\"t\":[\"工厂方法模式的主要角色：\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\",\"具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\"]},\"34\":{\"h\":\"实现\",\"t\":[\"使用工厂方法模式对上例进行改进，类图如下：\",\"代码如下：\",\"咖啡抽象类：\",\"public abstract class Coffee { public abstract String getName(); public void addMilk() { System.out.println(\\\"add milk\\\"); } public void addSugar() { System.out.println(\\\"add sugar\\\"); } } \",\"咖啡具体类：\",\"public class LatteCoffee extends Coffee { @Override public String getName() { return \\\"latte coffee\\\"; } } \",\"抽象工厂：\",\"public interface CoffeeFactory { Coffee createCoffee(); } \",\"具体工厂：\",\"public class LatteCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new LatteCoffee(); } } public class AmericanCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new AmericanCoffee(); } } \",\"咖啡店类：\",\"public class CoffeeStore { private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) { this.factory = factory; } public Coffee orderCoffee() { Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; } } \",\"从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\",\"工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\"]},\"35\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；\",\"在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；\",\"缺点：\",\"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。\"]},\"36\":{\"h\":\"抽象工厂模式\",\"t\":[\"前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\",\"这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\",\"本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\"]},\"37\":{\"h\":\"概念\",\"t\":[\"是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\",\"抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\"]},\"38\":{\"h\":\"结构\",\"t\":[\"抽象工厂模式的主要角色如下：\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\",\"具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\"]},\"39\":{\"h\":\"实现\",\"t\":[\"现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\",\"代码如下：\",\"抽象工厂：\",\"public interface DessertFactory { Coffee createCoffee(); Dessert createDessert(); } \",\"具体工厂：\",\"//美式甜点工厂 public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); } } //意大利风味甜点工厂 public class ItalyDessertFactory implements DessertFactory { public Coffee createCoffee() { return new LatteCoffee(); } public Dessert createDessert() { return new Tiramisu(); } } \",\"如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\"]},\"40\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\",\"缺点：\",\"当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\"]},\"41\":{\"h\":\"使用场景\",\"t\":[\"当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\",\"系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\",\"系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\",\"如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。\"]},\"42\":{\"h\":\"模式扩展\",\"t\":[\"简单工厂+配置文件解除耦合\",\"可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\",\"第一步：定义配置文件\",\"为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\",\"american=com.itheima.pattern.factory.config_factory.AmericanCoffee latte=com.itheima.pattern.factory.config_factory.LatteCoffee \",\"第二步：改进工厂类\",\"public class CoffeeFactory { private static Map<String,Coffee> map = new HashMap(); static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\\\"bean.properties\\\"); try { p.load(is); // 遍历Properties集合对象 Set<Object> keys = p.keySet(); for (Object key : keys) { // 根据键获取值（全类名） String className = p.getProperty((String) key); // 获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); } } catch (Exception e) { e.printStackTrace(); } } public static Coffee createCoffee(String name) { return map.get(name); } } \",\"静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\"]},\"43\":{\"h\":\"JDK源码解析-Collection.iterator方法\",\"t\":[\"public class Demo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"令狐冲\\\"); list.add(\\\"风清扬\\\"); list.add(\\\"任我行\\\"); //获取迭代器对象 Iterator<String> it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) { String ele = it.next(); System.out.println(ele); } } } \",\"对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：\",\"Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。\",\"另：\",\"​ 1,DateForamt类中的getInstance()方法使用的是工厂模式；\",\"​\\t2,Calendar类中的getInstance()方法使用的是工厂模式；\"]},\"44\":{\"h\":\"观察者模式 / 发布-订阅模式 / 生产-消费模式\",\"t\":[\"可见《图解设计模式》Observer模式篇\"]},\"45\":{\"h\":\"概述\",\"t\":[\"在Observer模式中，当观察对象的状态发生变化时，会通知给观察者。Observer模式适用于根据对象状态进行相应处理的场景。Observer本来的意思是“观察者”，但实际上Observer角色并非主动地去观察，而是被动地接受来自Subject角色的通知。因此，Observer模式也被称为Publish-Subscribe（发布-订阅） 模式。\"]},\"46\":{\"h\":\"结构\",\"t\":[\"Subject（观察对象）\",\"Subject角色表示观察对象。Subject角色定义了注册观察者和删除观察者的方法。此外，它还声明了“获取现在状态”的方法。\",\"ConcreteSubject（具体的观察对象）\",\"ConcreteSubject角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的Observer角色。\",\"Observer（观察者）\",\"Observer角色负责接收来自Subject角色的状态变化的通知。为此，它声明了update方法。\",\"ConcreteObserver（具体的观察者）\",\"ConcreteObserver角色表示具体的Observer。当它的update方法被调用后，会去获取要观察的对象的最新状态。\"]},\"47\":{\"h\":\"示例\",\"t\":[\"类和接口一览表：\",\"名字\",\"说明\",\"Observer\",\"表示观察者的接口（Observer）\",\"NunberGenerator\",\"表示生成数值的对象的抽象类（Subject）\",\"RandomNumberGenerator\",\"生成随机数的类（ConcreteSubject）\",\"DigitObserver\",\"表示以数字形式显示数值的类（ConcreteObserver）\",\"GraphObserver\",\"表示以简单图示形式显示熟知的类（ConcreteObserver）\",\"public interface Observer { void update(NumberGenerator generator); } \",\"public abstract class NumberGenerator { private final List<Observer> observers = new ArrayList<>(); public void addObserver(Observer o) { observers.add(o); } public void deleteObserver(Observer o) { observers.remove(o); } public void notifyObservers() { observers.forEach(o -> o.update(this)); } public abstract int getNumber(); public abstract void execute(); } \",\"public class RandomNumberGenerator extends NumberGenerator { private Random random = new Random(); private int number; @Override public int getNumber() { return number; } @Override public void execute() { for (int i = 0; i < 20; i++) { number = random.nextInt(50); notifyObservers(); } } } \",\"public class DigitObserver implements Observer { @Override public void update(NumberGenerator generator) { System.out.println(\\\"DigitObserver:\\\" + generator.getNumber()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } \",\"public class GraphObserver implements Observer { @Override public void update(NumberGenerator generator) { System.out.print(\\\"GraphObserver:\\\"); int count = generator.getNumber(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < count; i++) { System.out.print(\\\"*\\\"); } System.out.println(); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } \",\"public class Main { public static void main(String[] args) { NumberGenerator generator = new RandomNumberGenerator(); Observer observer1 = new DigitObserver(); Observer observer2 = new GraphObserver(); generator.addObserver(observer1); generator.addObserver(observer2); generator.execute(); } } \",\"DigitObserver:38 GraphObserver:************************************** DigitObserver:17 GraphObserver:***************** DigitObserver:39 GraphObserver:*************************************** ... \"]},\"48\":{\"h\":\"原型模式\"},\"49\":{\"h\":\"概述\",\"t\":[\"用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\"]},\"50\":{\"h\":\"结构\",\"t\":[\"原型模式包含如下角色：\",\"抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\",\"具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\",\"访问类：使用具体原型类中的 clone() 方法来复制新的对象。\",\"接口类图如下：\"]},\"51\":{\"h\":\"实现\",\"t\":[\"原型模式的克隆分为浅克隆和深克隆。\",\"浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\",\"深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\",\"Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：\",\"Realizetype（具体的原型类）：\",\"public class Realizetype implements Cloneable { public Realizetype() { System.out.println(\\\"具体的原型对象创建完成！\\\"); } @Override protected Realizetype clone() throws CloneNotSupportedException { System.out.println(\\\"具体原型复制成功！\\\"); return (Realizetype) super.clone(); } } \",\"PrototypeTest（测试访问类）：\",\"public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone(); System.out.println(\\\"对象r1和r2是同一个对象？\\\" + (r1 == r2)); } } \"]},\"52\":{\"h\":\"案例\",\"t\":[\"用原型模式生成“三好学生”奖状\",\"同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\",\"类图如下：\",\"代码如下：\",\"//奖状类 public class Citation implements Cloneable { private String name; public void setName(String name) { this.name = name; } public String getName() { return (this.name); } public void show() { System.out.println(name + \\\"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\\\"); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //测试访问类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); c1.setName(\\\"张三\\\"); //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(\\\"李四\\\"); c1.show(); c2.show(); } } \"]},\"53\":{\"h\":\"使用场景\",\"t\":[\"对象的创建非常复杂，可以使用原型模式快捷的创建对象。\",\"性能和安全要求比较高。\"]},\"54\":{\"h\":\"扩展（深克隆）\",\"t\":[\"将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\",\"//奖状类 public class Citation implements Cloneable { private Student stu; public Student getStu() { return stu; } public void setStu(Student stu) { this.stu = stu; } void show() { System.out.println(stu.getName() + \\\"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\\\"); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //学生类 public class Student { private String name; private String address; public Student(String name, String address) { this.name = name; this.address = address; } public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } //测试类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); Student stu = new Student(\\\"张三\\\", \\\"西安\\\"); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\\\"李四\\\"); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\\\"stu和stu1是同一个对象？\\\" + (stu == stu1)); c1.show(); c2.show(); } } \",\"运行结果为：\",\"stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\",\"public class CitationTest1 { public static void main(String[] args) throws Exception { Citation c1 = new Citation(); Student stu = new Student(\\\"张三\\\", \\\"西安\\\"); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\b.txt\\\")); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\b.txt\\\")); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\\\"李四\\\"); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\\\"stu和stu1是同一个对象？\\\" + (stu == stu1)); c1.show(); c2.show(); } } \",\"运行结果为：\",\"注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\"]},\"55\":{\"h\":\"代理模式\"},\"56\":{\"h\":\"概述\",\"t\":[\"由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\",\"Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\"]},\"57\":{\"h\":\"结构\",\"t\":[\"代理（Proxy）模式分为三种角色：\",\"抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\",\"真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\",\"代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\"]},\"58\":{\"h\":\"静态代理\",\"t\":[\"我们通过案例来感受一下静态代理。\",\"【例】火车站卖票\",\"如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\",\"代码如下：\",\"//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代售点 public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); public void sell() { System.out.println(\\\"代理点收取一些服务费用\\\"); station.sell(); } } //测试类 public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); } } \",\"从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\"]},\"59\":{\"h\":\"JDK动态代理\",\"t\":[\"接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\",\"代码如下：\",\"//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代理工厂，用来创建代理对象 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象，和proxyObject是同一个对象，在invoke方法中基本不用 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(JDK动态代理方式)\\\"); //执行真实对象 Object result = method.invoke(station, args); return result; } }); return proxyObject; } } //测试类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \",\"ProxyFactory是代理类吗？\",\"ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：\",\"package com.sun.proxy; import com.itheima.proxy.dynamic.jdk.SellTickets; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements SellTickets { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { try { m1 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"equals\\\", Class.forName(\\\"java.lang.Object\\\")); m2 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"toString\\\", new Class[0]); m3 = Class.forName(\\\"com.itheima.proxy.dynamic.jdk.SellTickets\\\").getMethod(\\\"sell\\\", new Class[0]); m0 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"hashCode\\\", new Class[0]); return; } catch (NoSuchMethodException noSuchMethodException) { throw new NoSuchMethodError(noSuchMethodException.getMessage()); } catch (ClassNotFoundException classNotFoundException) { throw new NoClassDefFoundError(classNotFoundException.getMessage()); } } public final boolean equals(Object object) { try { return (Boolean)this.h.invoke(this, m1, new Object[]{object}); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return (Integer)this.h.invoke(this, m0, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void sell() { try { this.h.invoke(this, m3, null); // 调用的就是自己实现的invoke方法 return; } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } } \",\"从上面的类中，我们可以看到以下几个信息：\",\"代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。\",\"代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。\",\"动态代理的执行流程是什么样？\",\"下面是摘取的重点代码：\",\"//程序运行过程中动态生成的代理类 public final class $Proxy0 extends Proxy implements SellTickets { private static Method m3; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { m3 = Class.forName(\\\"com.itheima.proxy.dynamic.jdk.SellTickets\\\").getMethod(\\\"sell\\\", new Class[0]); } public final void sell() { this.h.invoke(this, m3, null); } } //Java提供的动态代理相关类 public class Proxy implements java.io.Serializable { protected InvocationHandler h; protected Proxy(InvocationHandler h) { this.h = h; } } //代理工厂类 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(JDK动态代理方式)\\\"); Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试访问类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \",\"执行流程如下：\",\"在测试类中通过代理对象调用sell()方法\",\"根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\",\"代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\",\"invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\"]},\"60\":{\"h\":\"CGLIB动态代理\",\"t\":[\"同样是上面的案例，我们再次使用CGLIB代理实现。\",\"如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\",\"CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\",\"CGLIB是第三方提供的包，所以需要引入jar包的坐标：\",\"<dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> <version>2.2.2</version> </dependency> \",\"代码如下：\",\"//火车站 public class TrainStation { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代理工厂 public class ProxyFactory implements MethodInterceptor { private TrainStation target = new TrainStation(); public TrainStation getProxyObject() { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; } /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(CGLIB动态代理方式)\\\"); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; } } //测试类 public class Client { public static void main(String[] args) { //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \"]},\"61\":{\"h\":\"三种代理的对比\",\"t\":[\"jdk代理和CGLIB代理\",\"使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\",\"在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\",\"动态代理和静态代理\",\"动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\",\"如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\"]},\"62\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\",\"代理对象可以扩展目标对象的功能；\",\"代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\",\"缺点：\",\"增加了系统的复杂度；\"]},\"63\":{\"h\":\"使用场景\",\"t\":[\"远程（Remote）代理\",\"本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\",\"防火墙（Firewall）代理\",\"当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\",\"保护（Protect or Access）代理\",\"控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\"]},\"64\":{\"h\":\"单例模式\",\"t\":[\"为什么要使用单例模式详解\",\"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\"]},\"65\":{\"h\":\"单例模式的结构\",\"t\":[\"单例模式的主要有以下角色：\",\"单例类。只能创建一个实例的类\",\"访问类。使用单例类\"]},\"66\":{\"h\":\"单例模式的实现\",\"t\":[\"单例设计模式分类两种：\",\"​ 饿汉式：类加载就会导致该单实例对象被创建\",\"​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\",\"饿汉式-方式1（静态变量方式）\",\"/** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } \",\"​ 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\",\"饿汉式-方式2（静态代码块方式）\",\"/** * 恶汉式 * 在静态代码块中创建该类对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } \",\"该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\",\"懒汉式-方式1（线程不安全）\",\"/** * 懒汉式 * 线程不安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\",\"懒汉式-方式2（线程安全）\",\"/** * 懒汉式 * 线程安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\",\"懒汉式-方式3（双重检查锁）\",\"再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\",\"/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为null if(instance == null) { instance = new Singleton(); } } } return instance; } } \",\"双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题（此处会问Java对象的创建过程），出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\",\"要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。\",\"/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为空 if(instance == null) { instance = new Singleton(); } } } return instance; } } \",\"添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\",\"懒汉式-方式4（静态内部类方式）\",\"静态内部类单例模式中实例由内部类创建（静态内部类的初始化时机），由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。\",\"/** * 静态内部类方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } \",\"第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder\",\"并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\",\"静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\",\"枚举方式\",\"枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\",\"/** * 枚举方式 */ public enum Singleton { INSTANCE; } \",\"枚举方式属于饿汉式方式。\"]},\"67\":{\"h\":\"存在的问题\"},\"68\":{\"h\":\"问题演示\",\"t\":[\"破坏单例模式：\",\"使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。\",\"序列化反序列化\",\"Singleton类：\",\"public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } \",\"Test类：\",\"public class Test { public static void main(String[] args) throws Exception { //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile(); //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); } private static Singleton readObjectFromFile() throws Exception { //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\a.txt\\\")); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject(); return instance; } public static void writeObject2File() throws Exception { //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\a.txt\\\")); //将instance对象写出到文件中 oos.writeObject(instance); } } \",\"上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。\",\"反射\",\"Singleton类：\",\"public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } \",\"Test类：\",\"public class Test { public static void main(String[] args) throws Exception { //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true); //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance(); //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); } } \",\"上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式\",\"枚举方式不会出现这两个问题。\"]},\"69\":{\"h\":\"问题的解决\",\"t\":[\"序列化、反序列方式破坏单例模式的解决方法\",\"在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。\",\"Singleton类：\",\"public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() { return SingletonHolder.INSTANCE; } } \",\"源码解析：\",\"ObjectInputStream类\",\"public final Object readObject() throws IOException, ClassNotFoundException{ ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false);//重点查看readObject0方法 ..... } private Object readObject0(boolean unshared) throws IOException { ... try { switch (tc) { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... } } finally { depth--; bin.setBlockDataMode(oldMode); } } private Object readOrdinaryObject(boolean unshared) throws IOException { ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) { // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... } return obj; } \",\"反射方式破解单例的解决方法\",\"public class Singleton { //私有构造方法 private Singleton() { /* 反射破解单例模式需要添加的代码 */ if(instance != null) { throw new RuntimeException(); } } private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } \",\"这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。\"]},\"70\":{\"h\":\"JDK源码解析-Runtime类\",\"t\":[\"Runtime类就是使用的单例设计模式。\",\"通过源代码查看使用的是哪儿种单例模式\",\"public class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class <code>Runtime</code> are instance * methods and must be invoked with respect to the current runtime object. * * @return the <code>Runtime</code> object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don't let anyone else instantiate this class */ private Runtime() {} ... } \",\"从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。\",\"使用Runtime类中的方法\",\"public class RuntimeDemo { public static void main(String[] args) throws IOException { //获取Runtime类对象 Runtime runtime = Runtime.getRuntime(); //返回 Java 虚拟机中的内存总量。 System.out.println(runtime.totalMemory()); //返回 Java 虚拟机试图使用的最大内存量。 System.out.println(runtime.maxMemory()); //创建一个新的进程执行指定的字符串命令，返回进程对象 Process process = runtime.exec(\\\"ipconfig\\\"); //获取命令执行后的结果，通过输入流获取 InputStream inputStream = process.getInputStream(); byte[] arr = new byte[1024 * 1024* 100]; int b = inputStream.read(arr); System.out.println(new String(arr,0,b,\\\"gbk\\\")); } } \"]},\"71\":{\"h\":\"软件设计原则\",\"t\":[\"在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\"]},\"72\":{\"h\":\"开闭原则\",\"t\":[\"对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\",\"想要达到这样的效果，我们需要使用接口和抽象类。\",\"因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\",\"下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。\",\"【例】搜狗输入法 的皮肤设计。\",\"分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\"]},\"73\":{\"h\":\"里氏代换原则\",\"t\":[\"面向对象中的继承性的思考和说明\",\"继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\",\"继承在 给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障\",\"问题提出：在编程中，如何正确的使用继承 ? => 里氏替换原则\",\"在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方 法\",\"里氏替换原则告诉我们，继承实际上让两个类耦合性增强了， 在适当的情况下，可以通过聚合，组合，依赖 来解决问题。\",\"class Base { // 把更基础的方法和成员写到Base类 } class A extends Base { public int func1(int a, int b) { return a - b; } } class B extends Base { // 需要在B中使用A类的方法，使用组合关系 private A a = new A(); @Override public int func1(int a, int b) { return a + b; } public int func2(int a, int b) { return func1(a, b) + 9; } // 在B中使用A中的方法 public int func3(int a, int b) { return a.func1(a, b); } } public class Client { public static void main(String[] args) { A a = new A(); System.out.println(\\\"11-3=\\\" + a.func1(11, 3)); B b = new B(); System.out.println(\\\"11-3=\\\" + b.func3(11, 3)); } } \"]},\"74\":{\"h\":\"依赖倒转原则\",\"t\":[\"高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\",\"下面看一个例子来理解依赖倒转原则\",\"【例】组装电脑\",\"现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\",\"类图如下：\",\"代码如下：\",\"希捷硬盘类（XiJieHardDisk）:\",\"public class XiJieHardDisk implements HardDisk { public void save(String data) { System.out.println(\\\"使用希捷硬盘存储数据\\\" + data); } public String get() { System.out.println(\\\"使用希捷希捷硬盘取数据\\\"); return \\\"数据\\\"; } } \",\"Intel处理器（IntelCpu）：\",\"public class IntelCpu implements Cpu { public void run() { System.out.println(\\\"使用Intel处理器\\\"); } } \",\"金士顿内存条（KingstonMemory）：\",\"public class KingstonMemory implements Memory { public void save() { System.out.println(\\\"使用金士顿作为内存条\\\"); } } \",\"电脑（Computer）：\",\"public class Computer { private XiJieHardDisk hardDisk; private IntelCpu cpu; private KingstonMemory memory; public IntelCpu getCpu() { return cpu; } public void setCpu(IntelCpu cpu) { this.cpu = cpu; } public KingstonMemory getMemory() { return memory; } public void setMemory(KingstonMemory memory) { this.memory = memory; } public XiJieHardDisk getHardDisk() { return hardDisk; } public void setHardDisk(XiJieHardDisk hardDisk) { this.hardDisk = hardDisk; } public void run() { System.out.println(\\\"计算机工作\\\"); cpu.run(); memory.save(); String data = hardDisk.get(); System.out.println(\\\"从硬盘中获取的数据为：\\\" + data); } } \",\"测试类（TestComputer）：\",\"测试类用来组装电脑。\",\"public class TestComputer { public static void main(String[] args) { Computer computer = new Computer(); computer.setHardDisk(new XiJieHardDisk()); computer.setCpu(new IntelCpu()); computer.setMemory(new KingstonMemory()); computer.run(); } } \",\"上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\",\"根据依赖倒转原则进行改进：\",\"代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\",\"类图如下：\",\"电脑（Computer）：\",\"public class Computer { private HardDisk hardDisk; private Cpu cpu; private Memory memory; public HardDisk getHardDisk() { return hardDisk; } public void setHardDisk(HardDisk hardDisk) { this.hardDisk = hardDisk; } public Cpu getCpu() { return cpu; } public void setCpu(Cpu cpu) { this.cpu = cpu; } public Memory getMemory() { return memory; } public void setMemory(Memory memory) { this.memory = memory; } public void run() { System.out.println(\\\"计算机工作\\\"); } } \",\"面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\"]},\"75\":{\"h\":\"接口隔离原则\",\"t\":[\"客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\",\"下面看一个例子来理解接口隔离原则\",\"【例】安全门案例\",\"我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\",\"上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：\",\"代码如下：\",\"AntiTheft（接口）：\",\"public interface AntiTheft { void antiTheft(); } \",\"Fireproof（接口）：\",\"public interface Fireproof { void fireproof(); } \",\"Waterproof（接口）：\",\"public interface Waterproof { void waterproof(); } \",\"HeiMaSafetyDoor（类）：\",\"public class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof { public void antiTheft() { System.out.println(\\\"防盗\\\"); } public void fireproof() { System.out.println(\\\"防火\\\"); } public void waterproof() { System.out.println(\\\"防水\\\"); } } \",\"ItcastSafetyDoor（类）：\",\"public class ItcastSafetyDoor implements AntiTheft,Fireproof { public void antiTheft() { System.out.println(\\\"防盗\\\"); } public void fireproof() { System.out.println(\\\"防火\\\"); } } \"]},\"76\":{\"h\":\"迪米特法则\",\"t\":[\"迪米特法则又叫最少知识原则。\",\"只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。\",\"其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\",\"迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\",\"下面看一个例子来理解迪米特法则\",\"【例】明星与经纪人的关系实例\",\"明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\",\"类图如下：\",\"代码如下：\",\"明星类（Star）\",\"public class Star { private String name; public Star(String name) { this.name=name; } public String getName() { return name; } } \",\"粉丝类（Fans）\",\"public class Fans { private String name; public Fans(String name) { this.name=name; } public String getName() { return name; } } \",\"媒体公司类（Company）\",\"public class Company { private String name; public Company(String name) { this.name=name; } public String getName() { return name; } } \",\"经纪人类（Agent）\",\"public class Agent { private Star star; private Fans fans; private Company company; public void setStar(Star star) { this.star = star; } public void setFans(Fans fans) { this.fans = fans; } public void setCompany(Company company) { this.company = company; } public void meeting() { System.out.println(fans.getName() + \\\"与明星\\\" + star.getName() + \\\"见面了。\\\"); } public void business() { System.out.println(company.getName() + \\\"与明星\\\" + star.getName() + \\\"洽淡业务。\\\"); } } \"]},\"77\":{\"h\":\"合成复用原则\",\"t\":[\"合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\",\"通常类的复用分为继承复用和合成复用两种。\",\"继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\",\"继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。\",\"子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\",\"它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运 行时不可能发生变化。\",\"采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\",\"它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\",\"对象间的耦合度低。可以在类的成员位置声明抽象。\",\"复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\",\"下面看一个例子来理解合成复用原则\",\"【例】汽车分类管理程序\",\"汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：\",\"从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\"]},\"78\":{\"h\":\"策略模式\",\"t\":[\"可见《图解设计模式》Strategy模式篇\"]},\"79\":{\"h\":\"概述\",\"t\":[\"使用Strategy模式可以整体地替换算法的实现部分。能够整体地替换算法，能让我们轻松地以不同的算法去解决同一个问题，这种模式就是Strategy模式。\",\"通常在编程时算法会被写在具体的方法中。Strategy模式却特意将算法与其他部分分离开，只是定义了与算法相关的接口（API），然后再程序中以委托的方式来使用算法。**使用委托这种弱关联关系可以很方便地整体替换算法。**例如使用Strategy模式编写象棋程序时，可以方便地根据棋手的选择切换AI例程的水平。\"]},\"80\":{\"h\":\"结构\",\"t\":[\"Strategy（策略）\",\"Strategy角色负责决定实现策略所必需的接口（API）。\",\"ConcreteStrategy（具体的策略）\",\"ConcreteStrategy角色负责实现Strategy角色的接口（API），即负责实现具体的策略。\",\"Context（上下文）\",\"负责使用Strategy角色。Context角色保存了ConcreteStrategy角色的实例，并使用ConcreteStrategy角色去实现需求。\"]},\"81\":{\"h\":\"示例\",\"t\":[\"名字\",\"说明\",\"Hand\",\"表示猜拳中的”手势“的类\",\"Strategy\",\"表示猜拳游戏中的策略的类\",\"WinningStrategy\",\"表示“如果这局猜拳获胜，那么下一局也出一样的手势”这一策略的类\",\"ProbStrategy\",\"表示“根据上一局的手势从概率上计算出下一局的手势从这前的猜拳结果计算下一局出各种拳的概率”这一策略的类\",\"Player\",\"表示进行猜拳游戏的选手类\",\"public class Hand { public static final int HANDVALUE_GUU = 0; public static final int HANDVALUE_CHO = 1; public static final int HANDVALUE_PAA = 2; public static final Hand[] hand = { new Hand(HANDVALUE_GUU), new Hand(HANDVALUE_CHO), new Hand(HANDVALUE_PAA) }; private static final String[] name = { \\\"石头\\\", \\\"剪刀\\\", \\\"布\\\" }; // 表示猜拳中出的手势值 private int handvalue; private Hand(int handvalue) { this.handvalue = handvalue; } public static Hand getHand(int handvalue) { return hand[handvalue]; } // 如果this战胜了h返回true public boolean isStrongerThan(Hand h) { return fight(h) == 1; } // 如果this输给了h返回true public boolean isWeakerThan(Hand h) { return fight(h) == -1; } // 计分：平 0，胜 1，负-1 private int fight(Hand h) { if (this == h) { return 0; } else if ((this.handvalue + 1) % 3 == h.handvalue) { return 1; } else { return -1; } } @Override public String toString() { return name[handvalue]; } } \",\"public interface Strategy { // 获取下一局要出的手势 Hand nextHand(); // 上一局的手势是否获胜 void study(boolean win); } \",\"public class WinningStrategy implements Strategy { private Random random; private boolean won = false; private Hand prevHand; public WinningStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { if (!won) { prevHand = Hand.getHand(random.nextInt(3)); } return prevHand; } @Override public void study(boolean win) { won = win; } } \",\"public class ProbStrategy implements Strategy { private Random random; private int preHandValue = 0; private int currentHandValue = 0; private int[][] history = { {1, 1, 1,}, {1, 1, 1,}, {1, 1, 1,} }; public ProbStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { int bet = random.nextInt(getSum(currentHandValue)); int handvalue = 0; if (bet < history[currentHandValue][0]) { handvalue = 0; } else if (bet < history[currentHandValue][0] + history[currentHandValue][1]) { handvalue = 1; } else { handvalue = 2; } preHandValue = currentHandValue; currentHandValue = handvalue; return Hand.getHand(handvalue); } private int getSum(int hv) { int sum = 0; for (int i = 0; i < 3; i++) { sum += history[hv][i]; } return sum; } @Override public void study(boolean win) { if (win) { history[preHandValue][(currentHandValue + 1) % 3]++; history[preHandValue][(currentHandValue + 2) % 3]++; } } } \",\"public class Player { private String name; private Strategy strategy; private int wincount; private int losecount; private int gamecount; public Player(String name, Strategy strategy) { this.name = name; this.strategy = strategy; } public Hand nextHand() { return strategy.nextHand(); } public void win() { strategy.study(true); wincount++; gamecount++; } public void lose() { strategy.study(false); losecount++; gamecount++; } public void even() { gamecount++; } @Override public String toString() { return \\\"[\\\" + name + \\\":\\\" + gamecount + \\\" games, \\\" + wincount + \\\" win, \\\" + losecount + \\\" lose\\\" + \\\"]\\\"; } } \",\"public class Main { public static void main(String[] args) { int seed1 = 314; int seed2 = 15; Player tara = new Player(\\\"Tara\\\", new WinningStrategy(seed1)); Player hana = new Player(\\\"Hana\\\", new ProbStrategy(seed2)); for (int i = 0; i < 10000; i++) { Hand nextHand1 = tara.nextHand(); Hand nextHand2 = hana.nextHand(); if (nextHand1.isStrongerThan(nextHand2)) { System.out.println(\\\"Winner:\\\" + tara); tara.win(); hana.lose(); } else if (nextHand2.isStrongerThan(nextHand1)) { System.out.println(\\\"Winner:\\\" + hana); tara.lose(); hana.win(); } else { System.out.println(\\\"Even...\\\"); tara.even(); hana.even(); } System.out.println(\\\"Total result:\\\"); System.out.println(tara); System.out.println(hana); } } } \",\"... Winner:[Hana:9999 games, 3079 win, 3493 lose] Total result: [Tara:10000 games, 3493 win, 3080 lose] [Hana:10000 games, 3080 win, 3493 lose] \"]},\"82\":{\"h\":\"模板方法模式\"},\"83\":{\"h\":\"概述\",\"t\":[\"在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\",\"例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\",\"定义：\",\"定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\"]},\"84\":{\"h\":\"结构\",\"t\":[\"模板方法（Template Method）模式包含以下主要角色：\",\"抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\",\"模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\",\"基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\",\"抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\",\"具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\",\"钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\",\"一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\",\"具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\"]},\"85\":{\"h\":\"案例实现\",\"t\":[\"【例】炒菜\",\"炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：\",\"代码如下：\",\"public abstract class AbstractClass { public final void cookProcess() { //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); } public void pourOil() { System.out.println(\\\"倒油\\\"); } //第二步：热油是一样的，所以直接实现 public void heatOil() { System.out.println(\\\"热油\\\"); } //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry(){ System.out.println(\\\"炒啊炒啊炒到熟啊\\\"); } } public class ConcreteClass_BaoCai extends AbstractClass { @Override public void pourVegetable() { System.out.println(\\\"下锅的蔬菜是包菜\\\"); } @Override public void pourSauce() { System.out.println(\\\"下锅的酱料是辣椒\\\"); } } public class ConcreteClass_CaiXin extends AbstractClass { @Override public void pourVegetable() { System.out.println(\\\"下锅的蔬菜是菜心\\\"); } @Override public void pourSauce() { System.out.println(\\\"下锅的酱料是蒜蓉\\\"); } } public class Client { public static void main(String[] args) { //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); } } \",\"注意：为防止恶意操作，一般模板方法都加上 final 关键词。\"]},\"86\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"提高代码复用性\",\"将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\",\"实现了反向控制\",\"通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\",\"缺点：\",\"对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\",\"父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\"]},\"87\":{\"h\":\"适用场景\",\"t\":[\"算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\",\"需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\"]},\"88\":{\"h\":\"JDK源码解析\",\"t\":[\"InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法，如下：\",\"public abstract class InputStream implements Closeable { //抽象方法，要求子类必须重写 public abstract int read() throws IOException; public int read(byte b[]) throws IOException { return read(b, 0, b.length); } public int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off < 0 || len < 0 || len > b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据 if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i < len ; i++) { c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; } } \",\"从上面代码可以看到，无参的 read() 方法是抽象方法，要求子类必须实现。而 read(byte b[]) 方法调用了 read(byte b[], int off, int len) 方法，所以在此处重点看的方法是带三个参数的方法。\",\"在该方法中第18行、27行，可以看到调用了无参的抽象的 read() 方法。\",\"总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\"]},\"89\":{\"h\":\"Maven\",\"t\":[\"目录\"]},\"90\":{\"h\":\"一、Maven简介\"},\"91\":{\"h\":\"1. Maven介绍\",\"t\":[\"https://maven.apache.org/what-is-maven.html\",\"Maven 是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。\",\"Maven就是一个软件，掌握安装、配置、以及基本功能 （项目构建、依赖管理） 的理解和使用即可！\",\"依赖管理：\",\"Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。\",\"构建管理：\",\"项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程\",\"Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。\",\"场景1： 例如我们项目需要第三方依赖如：Druid连接池、MySQL数据库驱动和Jackson JSON等处理。那么我们可以将想要的依赖项的信息编写到Maven工程的配置文件，Maven就会自动下载并复制这些依赖项到项目中，无需自己导入jar包，管理jar!\",\"场景2： 项目完成开发，我们想要打成war部署到服务器中，使用maven的构建命令可以快速打包！节省大量时间！\"]},\"92\":{\"h\":\"2. Maven功能配置\",\"t\":[\"我们需要需改maven/conf/settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：\",\"1.依赖本地缓存位置（本地仓库位置）\",\"2.maven下载镜像\",\"3.maven选用编译项目的jdk版本\",\"配置本地仓库地址\",\" <!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository <localRepository>/path/to/local/repo</localRepository> --> <!-- conf/settings.xml 55行 --> <localRepository>D:\\\\maven-repository</localRepository> \",\"配置国内阿里镜像\",\"<!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--> <mirror> <id>alimaven</id> <name>aliyun maven</name> <url>http://maven.aliyun.com/nexus/content/groups/public/</url> <mirrorOf>central</mirrorOf> </mirror> \",\"配置jdk8版本项目构建\",\"<!--在profiles节点(标签)下添加jdk编译版本 268行附近--> <profile> <id>jdk-8</id> <activation> <activeByDefault>true</activeByDefault> <jdk>1.8</jdk> </activation> <properties> <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion> </properties> </profile> \"]},\"93\":{\"h\":\"二、基于IDEA进行Maven工程构建\"},\"94\":{\"h\":\"1. 构建概念和构建过程\",\"t\":[\"项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。\",\"项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。\",\"同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。\"]},\"95\":{\"h\":\"2. 命令方式项目构建\",\"t\":[\"命令\",\"描述\",\"mvn compile\",\"编译项目，生成target文件\",\"mvn package\",\"打包项目，生成jar或war文件\",\"mvn clean\",\"清理编译或打包后的项目结构\",\"mvn install\",\"打包后上传到maven本地仓库\",\"mvn deploy\",\"只打包，上传到maven私服仓库\",\"mvn site\",\"生成站点\",\"mvn test\",\"执行测试源码\",\"打包（package）和安装（install）的区别是什么\",\"打包是将工程打成jar或war文件，保存在target目录下\",\"安装是将当前工程所生成的jar或war文件，安装到本地仓库，会按照坐标保存到指定位置\"]},\"96\":{\"h\":\"三、基于IDEA 进行Maven依赖管理\"},\"97\":{\"h\":\"1. 依赖管理概念\",\"t\":[\"Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。\",\"我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。\",\"总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。\"]},\"98\":{\"h\":\"2. Maven工程核心信息配置和解读（GAVP）\",\"t\":[\"位置：pom.xml\",\"<!-- 模型版本 --> <modelVersion>4.0.0</modelVersion> <!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --> <groupId>com.companyname.project-group</groupId> <!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --> <artifactId>project</artifactId> <!-- 版本号 --> <version>1.0.0</version> <!--打包方式 默认：jar jar指的是普通的java项目打包方式！ 项目打成jar包！ war指的是web项目打包方式！项目打成war包！ pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念 --> <packaging>jar/pom/war</packaging> \"]},\"99\":{\"h\":\"3. Maven工程依赖管理配置\",\"t\":[\"位置：pom.xml\",\"依赖管理和依赖添加\",\"<!-- 通过编写依赖jar包的gav必要属性，引入第三方依赖！ scope属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --> <dependencies> <!-- 引入具体的依赖包 --> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.17</version> <!-- 依赖范围 --> <scope>runtime</scope> </dependency> </dependencies> \",\"依赖版本统一提取和维护\",\"<!--声明版本--> <properties> <!--命名随便,内部制定版本号即可！--> <junit.version>4.12</junit.version> <!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding> </properties> <dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <!--引用properties声明版本 --> <version>${junit.version}</version> </dependency> </dependencies> \"]},\"100\":{\"h\":\"4. 依赖范围\",\"t\":[\"通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境\",\"依赖范围\",\"描述\",\"compile\",\"编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。\",\"test\",\"测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。\",\"provided\",\"已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。\",\"runtime\",\"运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。\",\"system\",\"系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。\",\"import\",\"导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。\"]},\"101\":{\"h\":\"5. Maven工程依赖下载失败错误解决（重点）\",\"t\":[\"在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：\",\"下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。\",\"依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。\",\"本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。\",\"解决方案：\",\"检查网络连接和 Maven 仓库服务器状态。\",\"确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。\",\"清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！\",\"例如： pom.xml依赖\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.8</version> </dependency> \",\"文件：\"]},\"102\":{\"h\":\"6. Maven工程Build构建配置\",\"t\":[\"项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。\",\"默认情况下，构建不需要额外配置，都有对应的缺省配置。当然了，我们也可以在pom.xml定制一些配置，来修改默认构建的行为和产物！\",\"例如：\",\"指定构建打包文件的名称，非默认名称\",\"制定构建打包时，指定包含文件格式和排除文件\",\"打包插件版本过低，配置更高版本插件\",\"构建配置是在pom.xml / build标签中指定！\",\"指定打包命名\",\"<!-- 默认的打包名称：artifactid+verson.打包方式 --> <build> <finalName>定义打包名称</finalName> </build> \",\"指定打包文件\",\"如果在java文件夹中添加java类，会自动打包编译到classes文件夹下！\",\"但是在java文件夹中添加xml文件，默认不会被打包！\",\"默认情况下，按照maven工程结构放置的文件会默认被编译和打包！\",\"除此之外、我们可以使用resources标签，指定要打包资源的文件夹要把哪些静态资源打包到 classes根目录下！\",\"应用场景：mybatis中有时会将用于编写SQL语句的映射文件和mapper接口都写在src/main/java下的某个包中，此时映射文件就不会被打包，如何解决\",\"<build> <!--设置要打包的资源位置--> <resources> <resource> <!--设置资源所在目录--> <directory>src/main/java</directory> <includes> <!--设置包含的资源类型--> <include>**/*.xml</include> </includes> </resource> </resources> </build> \",\"配置依赖插件\",\"dependencies标签下引入开发需要的jar包！我们可以在build/plugins/plugin标签引入插件！\",\"常用的插件：修改jdk版本、tomcat插件、mybatis分页插件、mybatis逆向工程插件等等！\",\"<build> <plugins> <!-- java编译插件，配jdk的编译版本 --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> </configuration> </plugin> <!-- tomcat插件 --> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.2</version> <configuration> <port>8090</port> <path>/</path> <uriEncoding>UTF-8</uriEncoding> <server>tomcat7</server> </configuration> </plugin> </plugins> </build> \"]},\"103\":{\"h\":\"四、Maven依赖传递和依赖冲突\"},\"104\":{\"h\":\"1. Maven依赖传递特性\",\"t\":[\"概念\",\"假如有Maven项目A，项目B依赖A，项目C依赖B。那么我们可以说 C依赖A。也就是说，依赖的关系为：C—>B—>A， 那么我们执行项目C时，会自动把B、A都下载导入到C项目的jar包文件夹中，这就是依赖的传递性。\",\"作用\",\"简化依赖导入过程\",\"确保依赖版本正确\",\"传递的原则\",\"在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围以及配置\",\"B 依赖 C 时使用 compile 范围：可以传递\",\"B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。\",\"B 依赖 C 时，若配置了以下标签，则不能传递\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.2.15</version> <optional>true</optional> </dependency> \",\"依赖传递终止\",\"非compile范围进行依赖传递\",\"使用optional配置终止传递\",\"依赖冲突（传递的依赖已经存在）\",\"案例：导入jackson依赖\",\"分析：jackson需要三个依赖\",\"依赖传递关系：data-bind中，依赖其他两个依赖\",\"最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖\",\"<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.10.0</version> </dependency> \"]},\"105\":{\"h\":\"2. Maven依赖冲突特性\",\"t\":[\"当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！\",\"maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！\",\"解决依赖冲突（如何选择重复依赖）方式：\",\"自动选择原则\",\"短路优先原则（第一原则）\",\"A—>B—>C—>D—>E—>X(version 0.0.1)\",\"A—>F—>X(version 0.0.2)\",\"则A依赖于X(version 0.0.2)。\",\"依赖路径长度相同情况下，则“先声明优先”（第二原则）\",\"A—>E—>X(version 0.0.1)\",\"A—>F—>X(version 0.0.2)\",\"在<depencies></depencies>中，先声明的，路径相同，会优先选择！\",\"手动排除\",\"<dependency> <groupId>com.atguigu.maven</groupId> <artifactId>pro01-maven-java</artifactId> <version>1.0-SNAPSHOT</version> <scope>compile</scope> <!-- 使用excludes标签配置依赖的排除 --> <exclusions> <!-- 在exclude标签中配置一个具体的排除 --> <exclusion> <!-- 指定要排除的依赖的坐标（不需要写version） --> <groupId>commons-logging</groupId> <artifactId>commons-logging</artifactId> </exclusion> </exclusions> </dependency> \"]},\"106\":{\"h\":\"五、Maven工程继承和聚合关系\"},\"107\":{\"h\":\"1. Maven工程继承关系\",\"t\":[\"继承概念\",\"Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。\",\"继承作用\",\"在父工程中统一管理项目中的依赖信息。\",\"它的背景是：\",\"对一个比较大型的项目进行了模块拆分。\",\"一个 project 下面，创建了很多个 module。\",\"每一个 module 都需要配置自己的依赖信息。\",\"它背后的需求是：\",\"在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。\",\"使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。\",\"使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。\",\"继承语法\",\"父工程\",\" <groupId>com.atguigu.maven</groupId> <artifactId>pro03-maven-parent</artifactId> <version>1.0-SNAPSHOT</version> <!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --> <packaging>pom</packaging> \",\"子工程\",\"<!-- 使用parent标签指定当前工程的父工程 --> <parent> <!-- 父工程的坐标 --> <groupId>com.atguigu.maven</groupId> <artifactId>pro03-maven-parent</artifactId> <version>1.0-SNAPSHOT</version> </parent> <!-- 子工程的坐标 --> <!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --> <!-- <groupId>com.atguigu.maven</groupId> --> <artifactId>pro04-maven-module</artifactId> <!-- <version>1.0-SNAPSHOT</version> --> \",\"父工程依赖统一管理\",\"父工程声明版本\",\"<!-- 使用dependencyManagement标签配置对依赖的管理 --> <!-- 被管理的依赖并没有真正被引入到工程 --> <dependencyManagement> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> <version>6.0.10</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> <version>6.0.10</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>6.0.10</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-expression</artifactId> <version>6.0.10</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-aop</artifactId> <version>6.0.10</version> </dependency> </dependencies> </dependencyManagement> \",\"子工程引用版本\",\"<!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --> <!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --> <!-- 具体来说是由父工程的dependencyManagement来决定。 --> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-core</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-beans</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-expression</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-aop</artifactId> </dependency> </dependencies> \"]},\"108\":{\"h\":\"2. Maven工程聚合关系\",\"t\":[\"聚合概念\",\"Maven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。\",\"聚合作用\",\"管理多个子项目：通过聚合，可以将多个子项目组织在一起，方便管理和维护。\",\"构建和发布一组相关的项目：通过聚合，可以在一个命令中构建和发布多个相关的项目，简化了部署和维护工作。\",\"优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。\",\"统一管理依赖项：通过聚合，可以在父项目中管理公共依赖项和插件，避免重复定义。\",\"聚合语法\",\"父项目中包含的子项目列表。\",\"<project> <groupId>com.example</groupId> <artifactId>parent-project</artifactId> <packaging>pom</packaging> <version>1.0.0</version> <modules> <module>child-project1</module> <module>child-project2</module> </modules> </project> \",\"聚合演示\",\"通过触发父工程构建命令、引发所有子模块构建！产生反应堆！\"]},\"109\":{\"h\":\"六、Maven综合案例\"},\"110\":{\"h\":\"1. 项目需求和结构分析\",\"t\":[\"需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。\",\"项目架构：\",\"用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。 \",\"spring-context 6.0.6\",\"spring-core 6.0.6\",\"spring-beans 6.0.6\",\"common-service\",\"订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。 \",\"spring-context 6.0.6\",\"spring-core 6.0.6\",\"spring-beans 6.0.6\",\"spring-security 6.0.6\",\"common-service\",\"通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。 \",\"commons-io 2.11.0\",\"junit 5.9.2\"]},\"111\":{\"h\":\"2. 项目搭建和统一构建\"},\"112\":{\"h\":\"①父模块 (micro-shop)\",\"t\":[\"pom.xml配置：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.atguigu</groupId> <artifactId>micro-shop</artifactId> <version>1.0-SNAPSHOT</version> <!--知识点：父工程的打包方式为pom--> <packaging>pom</packaging> <properties> <spring.version>6.0.6</spring.version> <jackson.version>2.15.0</jackson.version> <commons.version>2.11.0</commons.version> <junit.version>5.9.2</junit.version> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> <!-- 依赖管理 --> <dependencyManagement> <dependencies> <!-- spring-context会依赖传递core/beans --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>${spring.version}</version> </dependency> <!-- jackson-databind会依赖传递core/annotations --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>${jackson.version}</version> </dependency> <!-- commons-io --> <dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> <version>${commons.version}</version> </dependency> <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-api</artifactId> <version>${junit.version}</version> <scope>test</scope> </dependency> </dependencies> </dependencyManagement> <!-- 统一更新子工程打包插件--> <build> <!-- jdk17 和 war包版本插件不匹配 --> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> </plugin> </plugins> </build> </project> \",\"可选操作：删除src目录\"]},\"113\":{\"h\":\"②通用模块 (common-service)\",\"t\":[\"pom.xml配置：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <parent> <artifactId>micro-shop</artifactId> <groupId>com.atguigu</groupId> <version>1.0-SNAPSHOT</version> </parent> <modelVersion>4.0.0</modelVersion> <artifactId>common-service</artifactId> <!--知识点：打包方式默认就是jar，因此可以省略--> <packaging>jar</packaging> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> <dependencies> <!-- 配置spring-context，继承父工程版本，自动传递 core / beans --> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> </dependency> <!-- 配置jackson-databind，继承父工程版本，自动传递 core / annotations --> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> </dependency> <!-- 配置commons-io，继承父工程版本 --> <dependency> <groupId>commons-io</groupId> <artifactId>commons-io</artifactId> </dependency> <!-- 配置junit，继承父工程版本 --> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter-api</artifactId> <scope>test</scope> </dependency> </dependencies> </project> \"]},\"114\":{\"h\":\"③用户模块 (user-service)\",\"t\":[\"pom.xml配置：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <parent> <artifactId>micro-shop</artifactId> <groupId>com.atguigu</groupId> <version>1.0-SNAPSHOT</version> </parent> <modelVersion>4.0.0</modelVersion> <artifactId>user-service</artifactId> <!-- web工程打包方式为jar --> <packaging>jar</packaging> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> <dependencies> <!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --> <dependency> <groupId>com.atguigu</groupId> <artifactId>common-service</artifactId> <version>1.0-SNAPSHOT</version> </dependency> </dependencies> </project> \"]},\"115\":{\"h\":\"④订单模块 (order-service)\",\"t\":[\"pom.xml配置：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <parent> <artifactId>micro-shop</artifactId> <groupId>com.atguigu</groupId> <version>1.0-SNAPSHOT</version> </parent> <modelVersion>4.0.0</modelVersion> <artifactId>order-service</artifactId> <!-- web工程打包方式为jar --> <packaging>jar</packaging> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> <dependencies> <!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --> <dependency> <groupId>com.atguigu</groupId> <artifactId>common-service</artifactId> <version>1.0-SNAPSHOT</version> </dependency> </dependencies> </project> \",\"此时，查看父工程的pom.xml，会发现其中已经自动聚合了子工程：\",\"<modules> <module>common-service</module> <module>user-service</module> <module>order-service</module> </modules> \"]},\"116\":{\"h\":\"CycleGAN\"},\"117\":{\"h\":\"附录\",\"t\":[\"Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks\",\"ICCV 2017\",\"论文主页：https://junyanz.github.io/CycleGAN/\",\"原始论文：https://arxiv.org/pdf/1703.10593.pdf\",\"子豪兄精读论文视频：https://www.bilibili.com/video/BV1Ya411a78P\",\"代码实战，CycleGAN照片转梵高莫奈油画：https://www.bilibili.com/video/BV1wv4y1T71F\",\"CycleGAN是Image Translation（图像转译）领域的经典深度学习算法，巧妙实现了两个非配对图像域的相互迁移，通过构造两个GAN网络和两个Cycle-consistency自监督损失函数，在图像迁移之后仍保留原始输入图像信息，在防止模式崩溃的同时，间接实现了图像配对。\",\"CycleGAN在照片转莫奈油画、野马转斑马花纹、夏天转冬天景色、街景转语义分割标签等图像转译应用上表现出色。\",\"7991651743003_.pic_hd.jpg\"]},\"118\":{\"h\":\"趣味应用\",\"t\":[\"见论文主页\",\"人脸图像自动戴口罩：https://www.zhihu.com/zvideo/1284840958643646464\"]},\"119\":{\"h\":\"作者相关\",\"t\":[\"作者Jun-Yan Zhu主页：https://www.cs.cmu.edu/~junyanz/\"]},\"120\":{\"h\":\"博客\",\"t\":[\"李宏毅生成对抗网络公开课：https://www.bilibili.com/video/av24011528/\",\"理解生成对抗网络：https://danieltakeshi.github.io/2017/03/05/understanding-generative-adversarial-networks/\",\"GAN动物园：https://github.com/hindupuravinash/the-gan-zoo\"]},\"121\":{\"h\":\"代码复现\",\"t\":[\"官方Github：https://github.com/junyanz/CycleGAN\",\"OpenMMLab开源图像生成算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\"]},\"122\":{\"h\":\"GAN\",\"t\":[\"DG∗​(x)=pdata ​(x)+pg​(x)pdata ​(x)​\"]},\"123\":{\"h\":\"附录\"},\"124\":{\"h\":\"生成对抗网络GAN开山之作\",\"t\":[\"生成对抗神经网络GAN开山之作论文：Generative Adversarial Nets。\",\"论文作者为“生成对抗网络之父”Ian Goodfellow和图灵奖得主Youshua Bengio。\",\"GAN近年来成为人工智能和深度学习的热门研究领域。GAN广泛应用于图像生成、风格迁移、AI艺术、黑白老照片上色修复。你可以使用GAN实现照片转成油画、野马转成斑马、黑夜转成白天，简笔画的猫转成真猫，模糊图像转成高清图像等酷炫好玩的应用。\",\"子豪兄会带你逐句精读GAN开山之作经典论文，讲解GAN精巧的自监督对抗学习范式背后的算法和数学原理。\",\"OpenMMLab图像生成开源算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\",\"原始论文：https://proceedings.neurips.cc/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf\",\"论文主页：https://proceedings.neurips.cc/paper/2014/hash/5ca3e9b122f61f8f06494c97b1afccf3-Abstract.html\"]},\"125\":{\"h\":\"趣味demo\",\"t\":[\"交互式可视化GAN Lab：https://poloclub.github.io/ganlab\",\"交互式可视化GAN Lab视频讲解：https://www.bilibili.com/video/BV1R44y1377T\",\"照片转动漫AnimeGAN：https://github.com/TachibanaYoshino/AnimeGAN\",\"英伟达GauGAN2神笔马良：http://gaugan.org/gaugan2/\",\"不存在的人脸：https://thispersondoesnotexist.com/\",\"不存在的花瓶：https://thisvesseldoesnotexist.com\",\"不存在的梗图：https://imgflip.com/ai-meme\",\"黑白老照片上色：https://deepai.org/machine-learning-model/colorizer\",\"黑白老照片上色：https://github.com/jantic/DeOldify\",\"黑白老照片上色：https://www.myheritage.com/incolor\",\"OpenAI DALLE-2：https://openai.com/dall-e-2\"]},\"126\":{\"h\":\"作者相关\",\"t\":[\"Schmidhuber在2016年NIPS大会上打断Goodfellow的GAN Tutorial：https://zhuanlan.zhihu.com/p/27159510\",\"【AI大咖】扒一下低调的Yoshua Bengio大神\",\"https://zhuanlan.zhihu.com/p/66259338\"]},\"127\":{\"h\":\"博客\",\"t\":[\"李宏毅生成对抗网络公开课：https://www.bilibili.com/video/av24011528/\",\"理解生成对抗网络：https://danieltakeshi.github.io/2017/03/05/understanding-generative-adversarial-networks/\",\"GAN动物园：https://github.com/hindupuravinash/the-gan-zoo\"]},\"128\":{\"h\":\"代码复现\",\"t\":[\"官方论文复现：https://github.com/goodfeli/adversarial\",\"OpenMMLab开源图像生成算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\",\"各种GAN的Keras实现：https://github.com/eriklindernoren/Keras-GAN\",\"GAN的推导及Keras手把手实现（老版本Keras）：http://srome.github.io/An-Annotated-Proof-of-Generative-Adversarial-Networks-with-Implementation-Notes/\"]},\"129\":{\"h\":\"CycleGAN\"},\"130\":{\"h\":\"附录\",\"t\":[\"图像转译和生成对抗网络GAN必读论文 pix2pix\",\"Image-to-Image Translation with Conditional Adversarial Nets\",\"CVPR 2017\",\"使用条件式生成对抗网络，提出图像转译的通用框架。生成器采用U-Net网络结构，融合底层细粒度特征和高层抽象语义特征。判别器采用patchGAN网络结构，在图块尺度提取纹理等高频信息。\",\"pix2pix在语义标签图转真实照片、简笔画转真图、黑白图像上色、卫星航拍图转地图等图像转译任务上表现优秀。\"]},\"131\":{\"h\":\"主页\",\"t\":[\"论文主页：https://phillipi.github.io/pix2pix/\",\"子豪兄论文精读视频：https://www.bilibili.com/video/BV1wY4y1k7Tc/\",\"论文：https://arxiv.org/abs/1611.07004\",\"代码：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix\",\"交互式趣味Demo：https://affinelayer.com/pixsrv/\"]},\"132\":{\"h\":\"趣味案例\",\"t\":[\"床单充电线作画Gommy Sunday：https://vimeo.com/260612034\",\"调色板生成：http://colormind.io/blog/\",\"人脸简笔画转肖像画：https://twitter.com/quasimondo/status/826065030944870400\"]},\"133\":{\"h\":\"代码\",\"t\":[\"https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/generative/pix2pix.ipynb\",\"https://github.com/TommyZihao/MMGeneration_Tutorials/blob/main/【E】图像转译-pix2pix.ipynb\"]},\"134\":{\"h\":\"YOLOv3\",\"t\":[\"整理自同济子豪兄\"]},\"135\":{\"h\":\"网络结构\",\"t\":[\"image-20220518142711194\"]},\"136\":{\"h\":\"Backbone（Darknet-53）\",\"t\":[\"对于输入为256∗256的图像，其Backbone如下图所示：\"]},\"137\":{\"h\":\"Neck\",\"t\":[\"neck部分就是多尺度特征融合的过程。其中concat就是在上采样之后，将相同尺度的特征沿通道方向摞起来。就像将相同大小的作业本摞起来。\"]},\"138\":{\"h\":\"Head\",\"t\":[\"YOLOv3的head部分，受到了特征金字塔的启发，使用了多尺度特征。\",\"对于输入是416∗416的图像，产生13∗13,26∗26,52∗52三个尺度的特征。其中小尺度特征（比如13∗13）负责预测大物体，大尺度特征负责预测小物体。因为小尺度每个grid ceil对应更大的感受野。\",\"三个尺度的特征，每个特征的grid ceil都会生成3个anchor，一共9个anchor。其中在9个anchor中，与ground truth的IOU最大的anchor负责预测这个ground truth。\"]},\"139\":{\"h\":\"正负样本\",\"t\":[\"假设IOU阈值为0.5，其中与ground truth的IOU小于阈值的anchor为负样本。超过阈值，且与ground truth的IOU最大的anchor为正样本。查过阈值，但是与ground truth的IOU不是最大的anchor既不是正样本也不是负样本。\"]},\"140\":{\"h\":\"损失函数\",\"t\":[\"λcoord​i=0∑S2​j=0∑B​1i,jobj​⋅[(bx​−bx​^​)2+(by​−by​^​)2+(bw​−bw​^​)2+(bh​−bh​^​)2]+i=0∑S2​j=0∑B​1i,jobj​⋅[−log(pc​)+i=1∑n​BCE(ci​^​,ci​)]+λnoobj​i=0∑S2​j=0∑B​1i,jnoobj​⋅[−log(1−pc​)]​​​\"]},\"141\":{\"h\":\"训练过程\",\"t\":[\"image-20220518144159747\"]},\"142\":{\"h\":\"测试过程\",\"t\":[\"image-20220518144241994\"]},\"143\":{\"h\":\"附录\"},\"144\":{\"h\":\"官方\",\"t\":[\"YOLOV3目标检测Demo视频：https://www.youtube.com/watch?v=MPU2HistivI\",\"https://pjreddie.com/darknet/yolo/\",\"https://github.com/pjreddie/darknet\",\"论文地址：https://arxiv.org/abs/1804.02767\"]},\"145\":{\"h\":\"博客\",\"t\":[\"江大白：https://zhuanlan.zhihu.com/p/143747206\",\"郭冠华：https://zhuanlan.zhihu.com/p/40332004\",\"Netron可视化YOLOV3网络结构：https://blog.csdn.net/nan355655600/article/details/106246355\",\"木盏：https://blog.csdn.net/leviopku/article/details/82660381\",\"太阳花的小绿豆：https://blog.csdn.net/qq_37541097/article/details/81214953\",\"B站工程师Algernon鉴黄YOLO：https://github.com/thisiszhou/SexyYolo\",\"B站工程师Algernon博客：https://zhuanlan.zhihu.com/p/76802514\",\"损失函数：https://blog.csdn.net/qq_34795071/article/details/92803741\"]},\"146\":{\"h\":\"代码复现\",\"t\":[\"Ultralytics公司：https://github.com/ultralytics/yolov3\",\"https://github.com/qqwweee/keras-yolo3\",\"https://github.com/bubbliiiing/yolo3-pytorch\",\"cvpods：https://github.com/Megvii-BaseDetection/cvpods/blob/master/cvpods/modeling/meta_arch/yolov3.py\"]},\"147\":{\"h\":\"MS COCO目标检测数据集80个类别\",\"t\":[\"交通：人、自行车、汽车、摩托车、飞机、公交车、火车、卡车、船\",\"市政：红绿灯、消防栓、STOP标志、停车收费米表、长椅\",\"动物：鸟、猫、狗、马、绵羊、奶牛、大象、熊、斑马、长颈鹿\",\"随身物品：双肩背包、雨伞、手提包、领带、行李箱\",\"运动：飞盘、雪橇、滑雪板、篮球、风筝、棒球棒、棒球手套、滑板、冲浪板、网球拍\",\"器皿餐具：瓶子、玻璃酒杯、茶杯、叉子、餐刀、勺子、碗\",\"食物：香蕉、苹果、三明治、橘子、西兰花、胡萝卜、热狗、匹萨、甜甜圈、蛋糕\",\"家具：椅子、沙发、盆栽、床、餐桌、厕所、电视、笔记本电脑、鼠标、遥控器、键盘、手机、微波炉、烤箱、烤吐司炉、洗碗槽、冰箱、书、钟表、花瓶、剪刀、泰迪熊、电吹风、牙刷\"]},\"148\":{\"h\":\"读前须知\"},\"149\":{\"h\":\"1\",\"t\":[\"x→∞lim​x222​−∫15​xdx+n=1∑20​n2=j=1∏3​yj​+x→−2lim​xx−2​\"]},\"150\":{\"h\":\"2\",\"t\":[\"🤪😒🎈🔥😊😂💕😘👌😍❤️🤣👍✌️🤞🙌🤦‍♀️😉😎🤦‍♂️🤷‍♀️🎶🎆🎈🧨✨🎉🎎🎁🎀🎍🎋🧧🍟🌭🧇🍳🥗🍞🥨🥖🫓❤️🧡💛💚💙💜❤️‍🩹❤️‍🔥💔🤍🖤🤎🚗🚓🚘🚜🚎🚑🚑🚔\"]},\"151\":{\"h\":\"3\"},\"152\":{\"h\":\"操作系统上\"},\"153\":{\"h\":\"1、操作系统的概念\",\"t\":[\"操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境(从下往上看)，他是计算机系统中最基本的系统软件(从上往下看)\",\"从任务管理器可以看出操作系统对硬件和软件资源的分配\"]},\"154\":{\"h\":\"2、操作系统需要实现的功能\",\"t\":[\"操作系统作为系统资源的管理者需要实现的功能和目标\",\"补充：进程是一个程序的执行过程，执行前需要将该程序放到内存中，才能被CPU处理\",\"需要实现的功能和目标：\",\"文件管理\",\"存储器管理\",\"处理机管理\",\"设备管理\",\"目标：安全、高效\",\"操作系统作为用户和计算机硬件之间的接口(从下往上看)需要实现的功能\",\"用户接口：\",\"命令接口：允许用户直接使用\",\"联机命令接口 = 交互式命令接口\",\"脱机命令接口 = 批处理命令接口\",\"程序接口：允许用户通过程序间接使用，由一组系统调用组成\",\"GUI：图形用户接口\",\"用户可以通过使用形象的图形界面进行操作，不需要记忆复杂的指令 、参数。比如将文件拖拽到垃圾箱\",\"目标：方便用户使用\",\"操作系统作为最接近硬件的层次(从上往下看)需要实现的功能和目标\",\"功能和目标：实现对硬件机器的拓展\",\"没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造为功能更强、使用更方便的机器\",\"通常把覆盖了软件的机器称为扩充机器，又称为虚拟机\"]},\"155\":{\"h\":\"3、操作系统的四个特征\",\"t\":[\"四个特征：并发，共享，虚拟，异步。其中并发和共享是两个最基本的特征，二者互为存在的条件\",\"并发：指两个或多个事件在同一个时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。\",\"并行：指两个或多个事件在同一时刻同时发生\",\"操作系统的并发性：计算机系统中同时存在着多个运行着程序\",\"一个单核CPU同一时刻只能执行一个程序\",\"共享：资源共享，系统中的资源可供内存中多个并发执行的进程共同使用\",\"资源共享分为：互斥共享方式和同时共享方式\",\"互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。比如：摄像头\",\"同时共享方式：系统中的某些资源，允许一个时间段内由多个进程同时对他们进行访问(此处的同时往往是宏观上的，微观上可能是交替访问，比如扬声器可以同时播放两个地方的)。比如：发送文件\",\"并发和共享的关系：互为存在的条件\",\"如果失去并发性，系统中只有一个程序正在执行，则共享性失去存在的意义\",\"如果失去共享性，如果提供vx和qq同时发送文件则不能实现，因为不能同时访问硬盘资源，也就无法并发\",\"虚拟：一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的(后续讲解)\",\"虚拟技术分为：空分复用技术(比如虚拟存储技术，一个电脑供4G运行内存，运行一个GTA需要4G内存，但我们能够同时运行GTA和其他软件)和时分复用技术(虚拟处理器，比如：我们同时运行多个程序)\",\"如果没有并发性，则一个时间段内只有一个程序运行，那么也就失去实现虚拟性的意义，没有并发性就谈不上虚拟性\",\"异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进\",\"只有系统拥有并发性，才可能导致异步性\"]},\"156\":{\"h\":\"4、OS的运行机制和体系结构\",\"t\":[\"两种指令\",\"指令：就是让CPU能够识别、执行的最基本命令\",\"两种指令：\",\"特权指令：如内存清零指令，此指令不允许用户程序使用\",\"非特权指令：普通的运算指令\",\"两种处理器状态\",\"CPU如何判断当前是否可以执行特权指令？\",\"CPU有两种处理器状态(用程序状态字寄存器(PSW)中的某标志位来表示当前处理器处于什么状态，如0表示用户态，1表示核心态)\",\"用户态(目态)：此时CPU只能执行非特权指令\",\"核心态(管态)：特权指令和非特权指令都可执行\",\"两种程序\",\"内核程序：是系统的管理者，可以执行特权和非特权指令，运行在核心态\",\"应用程序：为了保证系统能够安全运行，普通应用程序只能执行非特权指令，运行在用户态\",\"操作系统的内核\",\"内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分，实现操作系统的内核功能的程序就是内核程序\",\"操作系统的体系结构\",\"操作系统的体系结构分为大内核和微内核\",\"小结：\"]},\"157\":{\"h\":\"5、中断\",\"t\":[\"当中断发生时，CPU立即进入核心态\",\"当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理\",\"对于不同的中断信号，会进行不同的处理\",\"发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行\",\"用户态 → 核心态：通过中断\",\"核心态 → 用户态：执行一个特权指令，将程序状态字(PSW)的标志位设置为用户态\",\"中断的分类\",\"外中断的处理过程\",\"执行完每个指令之后，CPU都要检查当前是否有外部中断的信号\",\"如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字、程序计数器、通用寄存器)\",\"根据中断信号类型转入相应的中断处理程序(此时进入核心态)\",\"恢复原进程的CPU环境并退出中断，返回原进程继续往下执行\",\"小结：\"]},\"158\":{\"h\":\"6、系统调用\",\"t\":[\"系统调用概念：系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。\",\"应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作\",\"系统调用和库函数的区别\",\"库函数在应用程序和系统调用之间，在系统函数之上，内部有一些系统调用的封装\",\"系统调用的过程\",\"小结：\"]},\"159\":{\"h\":\"7、进程\",\"t\":[\"进程的定义\",\"程序：就是一个指令序列\",\"进程实体：\",\"问题：在有了并发之后，在CPU中运行不止一个程序。在内存中放入多个程序，各个程序的代码、运算数据存放的位置不同，操作系统如何找到各个程序代码以及数据存储的位置？\",\"解决：系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(比如代码和数据存储的位置)\",\"为了方便操作系统管理、完成各程序并发执行，引入了进程、进程实体的概念\",\"进程实体(进程映像)的组成\",\"PCB：操作系统通过PCB来管理进程，存储管理所需要的各种信息\",\"程序段：程序代码存放的位置\",\"数据段：程序运行时产生的数据存储的位置\",\"PCB的组成\",\"进程：是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。可以说进程是由PCB，程序段和数据段组成的。所谓创建进程就是创建PCB，撤销进程，就是撤销进程实体中的PCB。\",\"区别：进程实体是静态的，进程是动态的\",\"进程的组织\",\"一个系统中有很多个PCB，为了能够进行有效的管理，应该采取适当的方式将这些PCB组织起来\",\"链接方式\",\"索引方式\",\"进程特征\",\"动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的，是进程最基本的特征\",\"并发性：内存中有多个进程实体，各进程可以并发的执行\",\"独立性：进程是能够独立运行，独立获得资源、独立接收调度的基本单位\",\"异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统需要提供进程同步机制来解决异步问题，进程是资源分配、接收调度的基本单位\",\"结构性：每个进程配置一个PCB。结构上看进程由PCB、程序段、数据段组成\",\"小结：\"]},\"160\":{\"h\":\"8、进程的状态\",\"t\":[\"进程的基本状态\",\"进程是程序的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时候等待CPU的服务，为了对各个进程进行管理，操作系统将进程划分为几种状态\",\"1、运行态(Running)：占有CPU，并在CPU运行(单核CP每次最多处理一个进程)\",\"2、就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能够运行(除了CPU以外，其他条件全部具备，比如获取打印机等)\",\"3、阻塞态(Waiting/Blocked)：因等待某一事件而暂时不能运行(比如：等待分配打印机、等待读取磁盘。CPU最昂贵的部件，为了提高CPU的利用率，需要先将其他资源分配到位，才能得到CPU的服务)\",\"4、创建态(New)：进程正在被创建，操作系统为进程分配资源、初始化PCB\",\"5、终止态(Terminate)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\",\"前三个是基本状态\",\"进程状态的转换\",\"小结：\"]},\"161\":{\"h\":\"9、进程控制\",\"t\":[\"进程控制\",\"进程控制的主要功能就是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换\",\"如何实现进程控制\",\"问题：是否会发生从一个事件到另一个事件转换的时候出现中断，导致状态转移不完整？\",\"答：不会，进程控制是使用原语进行的\",\"用原语实现进程控制\",\"原语的特点是执行期间不允许中断，1只能一气呵成，这种不可被中断的操作就是原子操作\",\"原语使用\\\"关中断指令\\\"和\\\"开中断指令\\\"实现，开关中断权限非常大，所以只允许在核心态下执行特权指令\",\"进程控制相关的原语。无论哪个原语，要做的无非三类事情\",\"1、更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境) \",\"a、修改进程状态标志\",\"b、保存其运行环境\",\"c、恢复运行环境\",\"2、将PCB插入合适的队列\",\"3、分配/回收资源\",\"小结：\"]},\"162\":{\"h\":\"10、进程通信\",\"t\":[\"进程通信概念\",\"进程通信是指进程之间信息交换，进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立\",\"进程通信方法\",\"为了保证安全，一个进程不能直接访问另一个进程的地址空间，但各个进程之间信息交换又是必须的，为了保证进程间的安全通信，操作系统提供了一些方法\",\"1、共享存储：操作系统在内存中开辟一个区域供进程间共同使用，两个进程对共享空间的访问必须是互斥的(一个操作时另一个不能够访问)。操作系统只负责提供共享空间和同步互斥工具(如P,V操作)。有两种共享存储的方式\",\"1、基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种方式速度慢、限制多、是一种低级通信方式\",\"2、基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置都由进程控制，而不是操作系统。这种方式速度更快，是一种高级通信的方式\",\"2、管道通信：\",\"1、管道只能采用半双工通信，在某一时间段内只能实现单向传输，如果需要实现双向同时通信，则需要设置两个管道\",\"2、各进程要互斥的访问管道\",\"3、数据以字符流的形式写入管道，当管道写满的时候，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走以后，管道变空，此时读进程的read()系统调用将被阻塞\",\"4、如果管道没写满，就不允许读。如果没读空，就不允许写\",\"5、数据一旦被读出，就从管道中被抛弃，故读进程最多只能有一个\",\"3、消息传递：进程之间的数据交换以格式化消息为单位，进程通过操作系统提供的\\\"发送消息/接收消息\\\"两个原语进行数据交换\",\"小结：\"]},\"163\":{\"h\":\"11、线程、多线程模型\",\"t\":[\"线程概念\",\"有的进程可能需要同时做很多事情，比如qq要发送文件、要视频，而传统的进程只能串行的执行一系列程序，为此引入线程来增加并发度。即将进程再细分为很多的线程。\",\"传统的进程是程序执行流的最小单位，引入线程后，线程是程序执行流的最小单位\",\"线程是一个基本的CPU执行单位，也是程序执行流的最小单位\",\"引入线程之后，不仅是进程之间可以并发，进程内各线程也可以并发，进一步提高了系统的并发度，使得一个进程内可以并发处理各种任务\",\"引入线程之后，进程只作为除CPU之外的系统资源的分配单元(比如打印机、内存地址空间是分配给进程的)\",\"引入线程之后的变化\",\"1、对于资源的分配、调度 \",\"传统进程中、进程是资源分配和调度的基本单位\",\"引入线程之后，进程是资源分配的基本单位，线程是调度的基本单位\",\"2、对于并发性 \",\"传统进程中，只能进程间并发\",\"引入线程之后，各线程间也能并发，提升了并发度\",\"3、对于系统开销 \",\"传统进程间并发，需要切换进程的运行环境，系统开销大\",\"线程间并发，如果是同一进程内的线程切换，不需要切换进程环境，系统开销小\",\"引入线程后，系统的开销减小\",\"线程的属性\",\"1、线程是处理机调度的单位\",\"2、在多CPU的计算机中，各个线程可占用不同的CPU\",\"3、每个线程都有一个线程ID、线程控制块(TCB)\",\"4、线程也有就绪、阻塞、运行三种基本状态\",\"5、线程几乎不拥有系统资源，系统资源是分配给进程的\",\"6、同一进程的不同线程间可以共享进程的资源\",\"7、由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预\",\"8、同一进程中的线程切换，不会引起进程切换\",\"9、不同进程中的线程切换，会引起进程切换\",\"10、切换同进程内的线程，系统开销很小\",\"11、切换进程，系统开销大\",\"线程的实现方式\",\"1、用户级线程：由应用程序提供线程库实现\",\"所有的线程管理工作都是由应用程序负责(包括线程切换)\",\"用户级线程中，线程切换可以在用户态下完成，无需操作系统干预\",\"在用户看来是有多个线程，在操作系统内核看来，并不意识到线程的存在(即用户级线程对用户不透明(不透明就是能看见)，对操作系统透明)\",\"2、内核级线程\",\"线程的管理工作是操作系统内核完成，因此线程调度、切换的工作都是由内核负责，所以内核级线程的切换必须要在核心态下完成\",\"对操作系统不透明\",\"3、支持用户级线程和内核级线程的系统中，可采用上述二者组合的方式：将n各用户及线程映射到m各内核级线程上(n > m)\",\"操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位\",\"由几个用户级线程映射到几个内核级线程可引出多线程模型\",\"1、多对一模型：多个用户级线程映射到一个内核级线程\",\"优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\",\"缺点：当一个用户级线程被阻塞以后，整个进程都会被阻塞，并发度不高。多个线程不可以在多核处理机上并行运行\",\"2、一对一模型：一个用户级线程映射到一个内核级线程\",\"优点：当一个线程被阻塞以后，别的线程还可以执行。多线程可以在多核处理机上执行\",\"缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大\",\"3、多对多模型：n个用户级线程映射到m个内核级线程(n > m)，每个用户进程对应m个内核级线程\",\"优点：集上面二者的优点，客服了他们的缺点\",\"小结：\"]},\"164\":{\"h\":\"12、处理机的调度\",\"t\":[\"处理机调度的概念：从就绪队列中按照一定的算法选中一个进程并将处理机分配给它运行，以实现进程的并发执行\",\"调度的三个层次：\",\"高级调度(作业调度)：按一定的原则从外存上处于后备队列的作业中选中一个或多个作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使他们获得竞争处理机的权利。高级调度是外存和内存之间的调度，每个作业只调入一次，调出一次，作业调入时创建PCB，作业调出时撤销PCB。高级调度主要指的是调入问题，只有调入的时机是由操作系统来确定，调出必然是作业运行结束\",\"中级调度：\",\"挂起介绍：在引入虚拟存储技术以后，可以将暂时不能运行的进程调至外存等待，等它重新具备运行条件并且内存有空闲，再重新调入内存。这样做的目的是提高内存的利用率和系统吞吐量。暂时调到外存的进程状态为挂起状态，其中PCB不会被调到外存，而是会常驻内存，PCB记录进程数据。被挂起的进程PCB会被放到挂起队列中。\",\"中级调度就是决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会多次调入，调出，所以中级调度发生的频率比高级调度高\",\"低级调度(进程调度)：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，其频率很高，一般几十毫秒一次\",\"小结：\"]},\"165\":{\"h\":\"13、进程调度的时机、切换与过程的调度方式\",\"t\":[\"进程调度的时机\",\"进程调度的方式\",\"非剥夺调度方式：又称非抢占方式。即，只允许进程主动放弃处理机。在允许过程中即便有更紧迫的任务到达，也不会放弃处理器\",\"特点：实现简单，系统开销小但是无法及时处理紧急任务，适合早期批处理系统\",\"剥夺调度方式，又称抢占方式。当一个进程正在CPU上执行的时候，如果有更加紧急的进程需要CPU，则立即暂停正在执行的，将CPU分给紧急的那个进程\",\"特点：可以优先处理紧急的，也可以让各进程按时间片轮流执行。适合分时操作系统、实时操作系统\",\"进程切换\",\"进程调度指的是从就绪队列中选中一个要执行的进程，这个进程可以是刚刚被暂停执行的进程，也可以是另一个进程，后一种情况就需要进程切换\",\"进程切换主要完成了： \",\"1、对原来运行进程各种数据的保存\",\"2、对新的进程各种数据的恢复(如：程序计数器、各种数据寄存器等，这些信息一般保存在进程控制块中)\",\"进程切换是有代价的，因此过于频繁的进行进程调度、切换，会使整个系统的效率降低\",\"小结：\"]},\"166\":{\"h\":\"14、调度算法评价指标\",\"t\":[\"CPU利用率：指CPU\\\"忙碌\\\" 的时间占总时间的比例\",\"系统吞吐量：单位时间内完成的作业的数量\",\"周转时间、平均周转时间、带权周转时间、平均带权周转时间 \",\"周转时间：从作业被提交到系统开始，到作业完成为止的这段时间间隔。 \",\"周转时间包括四个部分：高级调度时间、低级调度的时间、进程在CPU执行的时间、进程等待I/O操作完成的时间\",\"周转时间 = 作业完成时间 - 作业提交时间\",\"平均周转时间 = (各作业周转时间之和) / 作业数\",\"带权周转时间 = (作业周转时间 / 作业实际运行的时间) = (作业完成时间 - 作业提交时间) / 作业实际运行时间 \",\"带权周转时间肯定是大于1的，带权周转时间与周转时间都是越小越好\",\"平均带权周转时间 = (各作业带权周转时间之和) / 作业数\",\"等待时间：指进程/作业处于等待处理机状态时间之和 \",\"对于进程来说，等待时间就是进程建立以后等待被服务的时间之和，在等待IO完成期间进程也是在被服务的，所以不计入等待时间\",\"对于作业来说，等待时间为：建立进程后的等待时间 + 作业在外存后备队列中等待的时间\",\"响应时间：用户提交请求到首次产生响应所用时间\",\"小结：\"]},\"167\":{\"h\":\"15、调度算法\",\"t\":[\"先来先服务算法(FCFS,First Come First Serve)\",\"算法规则：按照作业/进程到达的先后顺序进行服务\",\"用于作业/进程调度： \",\"作业调度：考虑哪个作业先到达后备队列\",\"进程调度：考虑哪个进程先达到就绪队列\",\"是否可抢占？非抢占式算法\",\"优缺点： \",\"优点：公平、算法实现简单\",\"缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利\",\"是否会导致饥饿：不会\",\"短作业优先算法(SJF，Shortest Job First)\",\"算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间\",\"算法规则：每次调度时选中最短的作业/进程优先得到服务(所谓最短，就是服务时间最短)\",\"用于作业/进程调度：可用于作业调度也可用于进程调度，用于进程调度时候称为\\\"短进程优先(SPF，Shortest Process First)\\\"\",\"是否可抢占？SJF和SPF都是非抢占式算法。但是也有抢占式的版本----最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)，每当有进程加入的时候，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列\",\"优缺点 \",\"优点：最短的平均等待时间、平均周转时间(SRNT)\",\"缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先\",\"是否会导致饥饿：会。如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生\\\"饥饿\\\"现象。如果一直得不到服务，就称为饿死\",\"高响应比优先(HRRN,Highest Response Ratio Next)\",\"算法思想：综合考虑作业/进程的等待时间和要求服务的时间\",\"算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比 = (等待时间 + 要求服务时间) / 要求服务时间\",\"用于作业/进程调度：可\",\"是否可抢占？非抢占式算法\",\"优缺点：综合考虑了等待时间和运行时间。等待时间相同时，要求服务时间短的优先(SJF优点)。要求服务时间相同时，等待时间长的邮箱(FCFS优点)。对于长作业来说，随着等待时间越来越长，其响应比也会越来越大，从而避免了长作业饥饿问题\",\"是否会导致饥饿：否\",\"上述算法一般适合用于早期的批处理系统\",\"时间片轮转算法(RR,Round - Robin)\",\"算法思想：公平的，轮流的为各个进程服务，让每一个进程在一定时间间隔内都可以得到响应\",\"算法规则：按照各个进程到达就绪队列的顺序，轮流的让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完毕，则剥夺处理机，将进程重新方法就绪队列队尾重新排队\",\"用于作业/进程调度：可用于进程调度\",\"是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片RR属于抢占式算法，由时钟装置发出时钟中断来通知CPU时间片已到\",\"优缺点： \",\"优点：公平；响应快，适用于分时操作系统\",\"缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度\",\"是否会导致饥饿：不会\",\"补充关于时间片的大小 \",\"如果时间片太大，使得每个进程都可以在一个时间片内完成，则RR退化为FCFS调度算法，并且会增大进程的响应时间，因此时间片不能太大\",\"如果时间片太小，进程切换比较频繁，系统开销会增大\",\"优先级调度算法\",\"算法思想：随着分时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理的顺序\",\"算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程\",\"用于作业/进程调度：都可\",\"是否可抢占：抢占式和非抢占式都有。对于非抢占式只需要在进程主动放弃处理机时进程调度即可，对于抢占式还需要在就绪队列变化时，检查是否会发生抢占\",\"优缺点： \",\"优点：用优先级区分紧急程度、重要程度，适用于分时操作系统，可灵活地的调整对各种作业/进程的偏好程度\",\"缺点：若源源不断的有高优先级进程到来，则可能会导致饥饿\",\"是否会导致饥饿：会\",\"补充 \",\"根据优先级是否可以动态改变，可以将优先级分为静态优先级和动态优先级两种 \",\"采用动态优先级，什么时候调整？ \",\"如果进程在就绪队列中等待了很长时间，可以适当提升优先级\",\"如果进程占用处理机很长时间，可以适当降低其优先级\",\"如果一个进程频繁的进行I/O操作，可以适当提升其优先级\",\"如何合理的设置各类进程的优先级： \",\"系统进程优先级高于用于进程\",\"前台进程优先级高于后台进程\",\"操作系统更偏向I/O型进程(或称I/O繁忙型进程)，因为I/O设备可以和CPU并行工作。如果让I/O繁忙型进程优先运行，则I/O设备可以尽早投入使用\",\"多级反馈队列调度算法\",\"算法思想：对其他调度算法的折中权衡\",\"算法规则：\",\"1、设置多级就绪队列，各级队列优先级从高到低，时间片从小到大\",\"2、新进程到达时先进入第一级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还没有结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾\",\"3、只有第k级队列为空时，才会为K + 1级队头的进程分配时间片\",\"用于作业/进程调度：用于进程调度\",\"是否可抢占式：抢占式算法。在k级队列的进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾\",\"优缺点：上述算法优点的集合\",\"是否会导致饥饿：会，如果源源不断的有短进程到达，就会饥饿\",\"上面的三种更加适合于交互式系统\"]},\"168\":{\"h\":\"16、进程同步、进程互斥\",\"t\":[\"进程同步：\",\"同步也称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程为了完成某种任务，需要协调他们工作的次序。进程同步是为了结局进程异步的问题(进程异步是指：各并发执行的进程以各自独立的、不可预知的速度向前推进)。比如：管道通信中，写数据必须在读数据之前完成\",\"进程互斥\",\"临界资源：一个时间段内只允许一个进程使用的资源。比如摄像头，打印机、内存缓冲区等\",\"对于临界资源的访问，必须是互斥的进程。互斥，也称为间接制约关系\",\"进程互斥：当一个进程访问某临界资源的时候，另一个访问该临界资源的进程必须等待。等待当前访问临界资源的进程结束才可以访问\",\"对于临界资源的互斥访问可以分为四个部分\",\"1、进入区：负责检查是否可以进入临界区，如果可以进入，则设置正在访问临界资源的标志(上锁)，以阻止其他进程同时进入临界区\",\"2、临界区：访问临界资源的那段代码\",\"3、退出区：负责接触正在访问临界资源的标志(解锁)\",\"4、剩余区：做其他处理\",\"进程互斥需要遵循的原则：\",\"1、空闲让进。当临界区空闲的时候，可以允许一个请求进入临界区的进程立即进入临界区\",\"2、忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待\",\"3、有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)\",\"4、让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待\",\"小结：\"]},\"169\":{\"h\":\"17、进程互斥的软件实现方法\",\"t\":[\"单标志法\",\"算法思想：当前有两个进程都要访问临界资源，在一个进程访问完临界资源以后会把使用临界区的权限转交给另一个进程。即：每个进程访问临界资源的权限只能被另一个进程赋予\",\"turn表示当前允许进入临界区的进程号，也就是只有一个进程访问临界资源后，才会修改turn。这违背了空闲让进的原则，因为当P1进程想访问资源，需要P0进程先访问才行，而P0又不需要访问\",\"双标志先检查法\",\"算法思想：试着一个boolean类型的数组flag[],数组中的各个元素用来标志各进程想进入临界区的意愿，比如flag[0] = true，表示0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程进入临界区，如果没有就把自身的标志位置为true，之后开始访问临界区\",\"按照152637....的顺序执行，P0和P1将会同时访问临界区，违背了忙则等待的原则。产生的原因：进入区的检查和上锁两个处理不是一气呵成的，检查后，上锁前可能会发生进程切换\",\"双标志后检查法\",\"算法思想：是双标志先检查法的改良版本，先上锁后检查\",\"按照152637顺序执行，P0和P1都无法进入临界区\",\"双标志发虽然解决了忙则等待的问题，但是又违背了空闲让进以及有限等待原则，因此会产生饥饿现象\",\"Peterson算法\",\"算法思想：如果两个进程都想着进入临界区，可以让进程尝试让对方先使用临界区\",\"该算法解决了进程互斥问题，遵循了空闲让进，忙则等待，有限等待三个原则，但是没有遵循让权等待\"]},\"170\":{\"h\":\"18、进程互斥的硬件实现方法\",\"t\":[\"中断屏蔽方法\",\"利用\\\"开/关中断指令\\\"实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也就不会发生两个同时访问临界区的情况)\",\"优点：简单、高效\",\"缺点：不适用在多处理机，因为开关中断只是相对一个处理机来说的；只适用于操作系统内核进程，不适用于用户进程(开关中断权限比较大，需要在内核态)\",\"TestAndSet指令\",\"简称TS或TSL指令，指令是用硬件实现的\",\"相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作\",\"优点：实现简单，适用于多处理机环境\",\"缺点：不满足让权等待\",\"Swap指令\",\"也称为Exchange指令，或简称XCHG指令，也是用硬件实现，执行过程中不允许中断，只能一气呵成\",\"优点：实现简单，适用于多处理机环境\",\"缺点：不满足让权等待\",\"Swap指令和Swap指令的区别\",\"在实现上，swap需要两个参数，不需要返回值，而test_and_set则是需要借助一个共享变量来实现互斥\",\"进程互斥的实现方式：四种软件实现方式 + 三种硬件实现方式\"]},\"171\":{\"h\":\"19、信号量机制\",\"t\":[\"用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步\",\"信号量就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示当前系统中某种资源的数量。比如：系统中打印机的数量为1，可以设置一个初值为1的信号量\",\"原语：是一段特殊的程序段，使用开关中断实现，执行只能一气呵成，不可中断\",\"一对原语：wait(S)原语和signal(S)原语，这就是两个函数，信号量S就是传入的参数\",\"wait、signal原语简称为P、V操作\",\"整型信号量 \",\"用一个整数型变量作为信号量，用来表示系统中某种资源的数量。对信号量的操作只有三种：初始化、P操作、V操作\",\"问题：不满足让权等待\",\"记录型信号量 \",\"是为了解决让权等待问题，用记录型数据结构表示信号量\",\"当资源已经分配完毕，进程会调用wait里面的block原语进行自我阻塞，由运行态到阻塞态，主动放弃处理机，因此该机制遵循了让权等待\",\"小结：\"]},\"172\":{\"h\":\"20、用信号量机制实现进程互斥、同步、前驱关系\",\"t\":[\"信号量机制实现进程互斥\",\"设置互斥信号量，初值为1\",\"在临界区之前执行P，减少信号量的数目，并且小于0的时候需要阻塞\",\"在临界区之后执行V，释放资源\",\"对不同的临界资源需要设置不同的互斥信号量，并且P,V必须成对的出现\",\"信号量机制实现进程同步\",\"进程同步：即必须保证\\\"一前一后\\\"执行两个操作\",\"设置同步信号量S，初始值为0\",\"在前操作之后执行V(S)\",\"在后操作之前执行P(S)\",\"信号量机制实现前驱关系\",\"步骤：\",\"要为每一对前驱关系各设置一个同步变量\",\"在前操作之后对相应的同步变量执行V操作\",\"在后操作之前对相应的同步变量执行P操作\",\"小结：\"]},\"173\":{\"h\":\"21、管程\",\"t\":[\"为什么要引入管程 \",\"信号量机制存在的问题：编写程序困难、易出错\",\"管程的定义和基本特征 \",\"管程作用：实现进程同步与互斥\",\"管程的组成：(类似类) \",\"共享的数据结构\",\"对数据结构操作的一组过程(函数)\",\"对共享数据设置初始值\",\"管程有一个名字\",\"管程的基本特征 \",\"管程中定义的数据结构，只能被管程中定义的过程访问\",\"每次仅允许一个进程在管程内执行某个内部过程\"]},\"174\":{\"h\":\"操作系统中\"},\"175\":{\"h\":\"1、死锁的概念\",\"t\":[\"什么是死锁\",\"在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象\",\"发生死锁至少有两个或两个以上的进程同时发生死锁，发生死锁后，若无外力干涉，这些进程都无法向前推进，发生死锁的进程一定是在阻塞态\",\"饥饿的概念： \",\"由于长期得不到想要的资源，某进程无法向前推进的现象，比如SPF如果有源源不断的短进程到来，则长进程一直无法获得处理机\",\"死循环的概念 \",\"某进程在执行的过程中一直跳不出某个循环的现象，有时是因为程序bug导致的，有时是程序员故意为之\",\"死锁、饥饿、死循环的异同 \",\"异如上\",\"同：都是进程无法顺利向前推进的现象(故意设计的死循环除外)\",\"死锁产生的条件\",\"1、互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁\",\"2、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放\",\"3、请求和保持条件：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放\",\"4、循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求\",\"注意：发生死锁的时候一定有循环等待，但是发生循环等待的时候未必死锁，因为如果同类资源的数量大于1，当该类资源又进程释放的时候，死锁结束。如果每类资源只有1个，那就是充分必要条件了\",\"什么时候会发生死锁\",\"1、对系统资源的竞争。对不可剥夺资源的竞争可能会引起死锁，对可剥夺的资源不会产生\",\"2、进程推进顺序非法。请求和释放资源的顺序不当，比如，并发执行的进程P1、P2分别申请并占有了资源R1,R2,但是之后P1进程又申请资源R2，P2进程申请资源R1，这样会导致死锁\",\"3、信号量的使用不当。比如，实现互斥的P操作在实现同步的P操作之前\",\"死锁的处理策略\",\"1、预防死锁：破坏死锁产生的四个必要条件中的一个或几个\",\"2、避免死锁：用某种方法阻止系统进入不安全的状态\",\"3、死锁的检测和解除：允许死锁的产生，不过操作系统会负责检测出死锁的产生，然后采取某种措施解除死锁\"]},\"176\":{\"h\":\"2、死锁的处理策略----预防死锁\",\"t\":[\"破坏互斥条件\",\"把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如使用SPOOLing技术。\",\"缺点：并不是所有的资源都可以改造成可共享使用资源，并且为了系统安全，在很多地方还必须保护这种互斥性，无法破坏\",\"破坏不剥夺条件\",\"方案一：当某个进程请求的资源得不到满足的时候，它必须立即释放保持的所有资源，待以后需要的时候再重新申请一下\",\"方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式需要考虑进程的优先级\",\"缺点： \",\"1、实现起来比较复杂\",\"2、释放已经获得的资源可能造成前一阶段工作的失效，因此一般只适用于易保存和恢复状态的资源，如CPU\",\"3、反复的申请和释放资源会增加系统的开销，降低系统吞吐量\",\"4、如果采用方案一，如果一直重复这样会导致饥饿\",\"破坏请求和保持条件\",\"采用静态分配方法：进程在运行前一次申请完它所需要的全部资源\",\"缺点：会造成严重的资源浪费，资源利用率低，也有可能导致饥饿(比如有三个进程A,B,C，其中A，B分别使用资源1,2，进程C需要用到A资源1和2，如果有源源不断的进程使用1或者2，则C一直不执行 )\",\"破坏循环等待条件\",\"采用顺序资源分配法：首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，编号相同资源一次申请完\",\"原理分析：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源，不可以大编号资源的进程逆向申请小编号的资源，这样就不会产生循环等待\",\"缺点： \",\"1、不方便增加新设备，因为可能需要重新分配所有的编号\",\"2、进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费\",\"3、必须按规定次序申请资源，用户编程麻烦\"]},\"177\":{\"h\":\"3、死锁的处理策略----避免死锁\",\"t\":[\"什么是安全序列 \",\"所谓安全序列，就是指系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找到一个安全序列，系统就是安全状态。当然安全序列可能有多个\",\"如果分配资源后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利执行下去。如果有进程提前归还了一些资源，系统还是有可能重新回到安全状态\",\"如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必发生了死锁，但发生死锁的时候就一定是处于不安全状态)\",\"可以在资源分配之前预先判断这次分配会不会导致系统进入不安全状态，以此决定是否答应资源分配请求，这是银行家算法核心思想\"]},\"178\":{\"h\":\"4、死锁的处理策略----检测和解除\",\"t\":[\"为了能对系统死锁进行检测需要满足的条件\",\"1、用某种数据结构来保存资源的请求和分配信息\",\"上图中绿色表示已经分配的资源，蓝色表示正在请求的资源。按照上述过程，最终能够消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁。比如P2中申请一个R1，但是此时R1已经分配出去三个了，所以P2进入阻塞的状态，要等P1释放资源\",\"解除死锁\",\"用死锁检测算法化简资源分配图之后，还连着的边的那些进程就是死锁进程，解除死锁的主要方法：\",\"1、资源剥夺法：挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程\",\"2、撤销进程法(或终止进程法)：强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但代价有点大，撤销进程之前的运行都芜湖了\",\"3、进程回退法：让一个或多个死锁进程回退到避免死锁的地步。这要求系统记录进程的历史信息，设置还原点\"]},\"179\":{\"h\":\"5、内存的基础知识\",\"t\":[\"什么是内存？有何作用？\",\"内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理\",\"如何区分各个程序的数据在内存的什么地方？ \",\"给内存的存储单元编地址 \",\"内存地址从0开始，每个单元对应一个存储单元(相当于宾馆的房间)\",\"如果计算机按字节编址，则每个存储单元大小为1字节，即1B，即8个二进制位\",\"如果字长为16位的计算机按字编址，则每个存储单元大小为1个字，每个字的大小为16个二进制位(取决于计算机的字长)\",\"几个常用的数量单位\",\"2^10 = 1K (千)\",\"2^20 = 1M (兆，百万)\",\"2^30 = 1G (亿，千兆)\",\"一台手机有4GB内存，是什么意思？ \",\"指该手机内存可以存放4 * 2^30 个字节，如果按照字节编址的话，也就是有4 * 2^30 = 2^32 个存储单元(个房间)\",\"需要 2^32个地址才能一一标识，也就是地址需要用32个二进制位来表示\",\"进程的运行原理 --- 指令\",\"我们写的代码最终被翻译成CPU能够识别的指令，这些指令会告诉CPU去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在编译生成的指令中一般使用的是逻辑地址(相对地址)\",\"逻辑地址(相对地址) VS 物理地址(绝对地址) \",\"逻辑地址就是相对初始位置的距离，在内存中实际存放的位置 = 起始位置 + 逻辑地址\",\"物理地址即绝对地址，就是数据存放在内存中的实际位置\",\"从写程序到程序运行\",\"装入的三种方式(逻辑地址 -> 物理地址的转换)\",\"1、绝对装入：在编译的时候就知道程序存放在内存的哪个位置，编译程序产生绝对地址的目标代码(目标模块中的指令就是内存中的绝对地址)，装入程序按照装入模块中的地址，将程序和数据装入内存。\",\"绝对装入只适用于单道程序的环境(因为地址已经写死，如果多道程序的话会冲突)。程序中使用的绝对地址，可以在编译或者汇编的时候给出，也可由程序员直接赋予，但通常都是编译或汇编时在转换为绝对地址\",\"2、静态重定位：又称可重定位装入，编译和链接之后指令中的地址都是从0开始的逻辑地址，根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变换为物理地址(地址变换是在装入的时候一次性完成的)\",\"特点：一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存空间，就不能装入该作业，作业一旦进入内存之后，在运行期间不能再移动，也不能再申请内存空间\",\"3、动态重定位(现在使用)：又称为动态运行时装入。编译和链接之后装入模块的地址都是从0开始，装入程序将装入模块装入到内存之后也不会立即将逻辑地址变换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入到内存中的地址依旧是逻辑地址，这种方式需要一个重定位寄存器(存放起始地址)的支持\",\"特点：动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区，在程序运行前只需要装入它的部分代码就可以运行，在程序运行期间，可以动态申请内存分配\",\"链接的三种方式\",\"1、静态链接：在程序运行之前，将各个目标模块连接到装入模块\",\"2、装入时动态链接：将各个目标模块装入内存时，边装入边链接\",\"3、运行时动态链接：在程序执行中需要改目标模块时，才对他进行连接\"]},\"180\":{\"h\":\"6、内存管理的概念\",\"t\":[\"操作系统负责内存空间的分配和回收\",\"操作系统需要提供某种技术从逻辑上对内存空间进程扩充-----覆盖技术、交换技术、虚拟存储技术\",\"操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换----三种装入方式\",\"操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行互不干扰 \",\"方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址的时候，CPU检查是否越界\",\"方法二：采用**重定位寄存器(又称为基址寄存器)和界地址寄存器(又称限长寄存器)**进行越界检查。\"]},\"181\":{\"h\":\"7、内存空间的扩充-----覆盖与交换\",\"t\":[\"覆盖技术：用来解决程序大小超过物理内存总和的问题\",\"思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存\",\"内存中分为一个固定区和若干个覆盖区\",\"需要常驻内存的段放入固定区，调入后就不再调出(除非运行结束)\",\"不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存\",\"特点：必须由程序员声明覆盖结构，操作系统完成自动覆盖，缺点：对用户不透明，增加了用户编程的负担，现在不使用了\",\"交换技术\",\"设计思想：内存空间紧张的时候，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。就是将某些进程挂起。中级调度：就是决定将哪个处于挂起状态的进程重新调入内存。(PCB会常驻内存，不会被换出内存)\",\"应该在外存(磁盘)的什么位置保存被换出的进程？ \",\"具有对换功能的操作系统中，通常将磁盘空间分为文件区和对换区两部分。文件区主要存放文件，主要追求存储空间的利用率，因此文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区，因为需要对换的速度，所以对换区空间的管理主要追求换入换出速度，通常采用连续分配方式。总之对换区的I/O速度比文件区的更快\",\"什么时候应该交换？ \",\"交换通常发生在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程，如果缺页率明显下降，就可以暂停换出\",\"应该换出哪些进程？ \",\"可优先换出阻塞进程；可换出低优先级的进程；为了防止低优先级进程发生饥饿，有的系统还会考虑进程在内存中的驻留时间\"]},\"182\":{\"h\":\"8、内存空间的分配-----连续分配管理方式\",\"t\":[\"连续分配：就是为用户进程分配的必须是一个连续的内存空间\",\"单一连续分配方式\",\"内存被分为系统区和用户区，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据，用户区用于存放用户进程的相关数据\",\"内存中只能有一道用户程序，用户程序独占整个用户区空间\",\"特点： \",\"优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护\",\"缺点：只能用于单用户、单任务的操作系统中；有内部碎片(分配给某进程的内存区域中，如果有些部分没有用上，就是内部碎片)；存储器利用率极低\",\"固定分区分配\",\"将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的多道程序的内存管理方式。\",\"固定分区分配分为两种：\",\"分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合\",\"分区大小不等：增加了灵活性，可以满足不同大小的进程的需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)\",\"操作系统如何记录各个分区空闲或者分配的情况？\",\"操作系统需要建立一个数据结构---分区说明表，来实现各个分区的分配和回收。每个表项对应一个分区，包括分区号、对应分区的大小、起始地址、状态(是否已分配)\",\"当用户进程要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个满足条件的分区，然后修改分区状态\",\"特点：\",\"优点：实现简单；无外部碎片\",\"缺点： \",\"1、当用户程序太大时，可能所有的分区都不能满足，此时不得不采取覆盖技术来解决，但是这回降低系统性能\",\"2、会产生内部碎片，内存利用率低\",\"动态分区分配(可变分区分配)\",\"原理：在线程装入内存时，根据进程的大小动态建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的\",\"系统要用什么样的数据结构记录内存的使用情况？\",\"空闲分区表：每个空闲分区对应一个表项。表项中包含分区、分区信息、分区起始地址、状态等信息\",\"空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。\",\"当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\",\"按照动态分区分配算法\",\"如何进行分区的分配和回收操作？\",\"如何进行分配：假设采用的数据结构是空闲分区表，则修改对应分区号，以及剩余的分区大小和起始地址等信息\",\"如何进行回收： \",\"情况一：回收区的前或后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个\",\"情况二：回收区的前、后各有一个相邻的空闲分区，需要将一整块的空闲分区合并\",\"情况三：回收区的前、后都没有相邻的空闲分区，需要新增一个空闲分区\",\"注意：各表项的顺序不一定按照地址递增的顺序排序，具体的排序方式需要依据动态分配算法来确定\",\"特点：没有内部碎片，但是有外部碎片\",\"内部碎片：分配给某进程的内存区域中，如果有些部分没有用上\",\"外部碎片：内存中的某些空闲分区由于太小难以利用\",\"如果内存中空闲空间的总和本来可以满足某进程的要求，但由于该进程需要连续的内存空间，因此这些碎片不能满足进程的需求，可以通过紧凑(拼凑) 的技术来解决(把已占的内存挪位)\"]},\"183\":{\"h\":\"9、动态分区分配算法\",\"t\":[\"首次适应算法\",\"算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区\",\"实现：**空闲分区以地址递增的次序排列。**每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：导致低地址出现很多小的难以利用的空闲区\",\"最佳适应算法(先用小的)\",\"算法思想：优先使用更小的空闲区，尽可能更多的留下大片的空闲区\",\"实现：空闲分区按照容量递增次序链接。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：每次都选最小的分区，会留下越来越多的又小又难利用的内存块，会产生很多的外部碎片\",\"最坏适应算法(先用大的)\",\"算法思想：优先使用最大的连续空闲区，这样留下的空闲区就不会太小，更方便使用\",\"实现：空闲分区按照容量递减的次序链接。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：每次都选最大的分区，会导致大的空闲区迅速被用完，如果还有大进程到来，就没有内存分区可以用了\",\"邻近适应算法\",\"算法思想：每次查找从上次使用地址的下一个开始\",\"实现：空闲分区以地址递增的次序排列(第一次排，后面不需要再排)，每次分配内存时从上次查找结束的位置开始查找空闲分区，找到大小能够满足要求的第一个空闲分区\",\"缺点：每个空闲分区都用相同的概率被使用，也就导致高地址的大分区更可能被使用。划分为小分区，最后也就导致无大分区可用\",\"image-20220508143045462\"]},\"184\":{\"h\":\"10、基本分页存储管理的基本概念\",\"t\":[\"内存空间非连续分配管理方式\",\"基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分\",\"内存拆分为一个个大小相等的分区,每个分区就是一个页框(或称为页帧)。每个页框有一个编号，就是页框号，页框号从0开始\",\"进程根据页框大小拆分为一个个区域，称为页(或页面)。每个页面也有一个编号，即页号，页号也是从0开始(进程的最后一个页面可能没有一个页框那么大，页框不能太大，否则会产生过大的内部碎片)\",\"页面与页框有一一对应关系，页面不必连续存放，可以放到不相邻的页框中\",\"逻辑地址如何转换为物理地址 \",\"1、算出逻辑地址对应的页号：页号 = 逻辑地址 / 页面长度\",\"2、页号在内存中的起始地址：操作系统用某种数据结构记录\",\"3、逻辑地址在页面的偏移量：页内偏移量 = 逻辑地址 % 页面长度\",\"4、物理地址= 起始地址 + 偏移量\",\"结论：如果每个页面大小是2^k,用二进制表示逻辑地址，则末尾K位标识页内偏移量，其余部分就是页号\",\"页表：为了能够知道进程的每一个页面在内存中的存放位置\",\"1、一个进程对应一个页表\",\"2、页表由页号和块号(页框号)组成\",\"页表项：页表中的一条记录\"]},\"185\":{\"h\":\"11、基地址变换机构\",\"t\":[\"基地址变换机构可以借助页表将逻辑地址变换为物理地址\",\"系统中设置一个页表寄存器，存放页表的起始地址(页表的开始地址)和页表长度(页表项的个数)，进程未执行时，页表起始地址和长度放在PCB在，当进程被调度时，才会放入页表寄存器\",\"08589340b276ee29a357f080ed4012b\",\"快表(联想寄存器)：访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项。\",\"541a75aa1efce984b24df67aea29aa4\"]},\"186\":{\"h\":\"12、两级页表\",\"t\":[\"单级页表的问题\",\"页表必须连续存放，当页表很大的时候，需要占用很多个连续的页框\",\"没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面(后面讲解)\",\"两级页表的原理---- 解决上面第一个问题\",\"为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶级页表(套娃)\",\"将页表继续根据页框大小进行拆分\",\"f7cd987ba102ecf12110ee6a4416034\",\"根据拆分的很多个页表建立页目录表\",\"3361d94ab3623353f7997137296d8eb\",\"案例\",\"484c54717461b527d7e199d942448f1\",\"注意：\",\"各级页表的大小不能超过一个面\",\"两级页表访问内存的次数 \",\"1、第一次：访问页目录表\",\"2、第二次：访问二级页表\",\"3、第三次：访问目标单元\",\"小结：\"]},\"187\":{\"h\":\"13、基本分段存储管理方式\",\"t\":[\"与分页的最大区别：离散分配时所分配地址空间的基本单位不同\",\"分段：程序按照自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编程\",\"内存分配规则：**以段为单位进行分配，每个段在内存中占据连续空间，**但各段之间可以不相邻\",\"f6fbed833a9af8b9e4df67b0c17c3fc\",\"分段系统的逻辑地址结构由**段号(段名)和段内地址(段内偏移量)**所组成\",\"段号的位数决定了每个进程最多可以分几个段\",\"段内地址位数决定了每个段的最大长度是多少\",\"段表：能够从物理内存中找到各个逻辑段的存放位置\",\"31fd5ca9ccd980db93b6088ea0e1d58\",\"每个段对应一个段表项，其中记录了该段在内存中的起始位置(基址)和段的长度\",\"各个段表项的长度是相同的，段号是可以隐含的，不占存储空间\",\"段表寄存器：在PCB中存放段表始址和段表长度\",\"19fda1f5ff23a13b9e546eba14effc6\",\"分页与分段的区别\",\"3dd975466ed41bb250ad2f71beec3fb\",\"分段比分页相比更容易实现信息的共享和保护\",\"实现共享：只需要让各个进程的段表项执行同一个段即可实现共享。不能被修改的代码称为纯代码或可重入代码，这样的代码可实现共享。可修改的代码不能实现共享(比如：有一个代码段中有很多变量，各进程并发同时访问可能造成数据不一致)。\",\"实现保护与实现共享的原因相似：允许访问的部分应该隔离出来可以访问\",\"小结：\"]},\"188\":{\"h\":\"14、段页式管理方式\",\"t\":[\"分页和分段的优缺点\",\"优点\",\"缺点\",\"分页管理\",\"内存空间利用率高，不会产生外部碎片，只会产生少量的页内碎片\",\"不方便实现信息的共享和保护\",\"分段管理\",\"很方便实现信息的共享和保护\",\"如果段过大，为其分配很大的连续空间会很不方便，会产生外部碎片(产生原因与动态分区分配相似)\",\"段页式管理 = 分段 + 分页\",\"将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的页框，进程前将各页面装入各内存块中\",\"9b68045565ab516f5f3e723c7b11f0c\",\"段页式系统的逻辑地址结构由段号、页号、页内地址组成\",\"image-20220513152328116\",\"分段对用户是可见的，程序员编程时需要显示的给出段号、段内地址。而将各段分页是对用户不可见的。系统会根据段内地址自动划分页号和页内偏移地址\",\"段表、页表\",\"每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表的起始地址)组成。每个段表项的长度相等，段号是隐含的\",\"每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含。\",\"image-20220513153925493\",\"逻辑地址转物理地址\",\"image-20220513154609606\",\"也可以引入快表机构\",\"image-20220513193835377\"]},\"189\":{\"h\":\"15、虚拟内存的概念\",\"t\":[\"也是为了进行内存空间的扩充\",\"传统存储管理方式的问题\",\"作业很大时，不能全部装入内存，导致大作业无法运行\",\"当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降\",\"一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源\",\"局部性原理\",\"时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久后该数据很可能再次被访问(因为程序中存在着大量的循环)\",\"空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序的在内存中存放)\",\"高速缓冲技术\",\"将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中\",\"虚拟内存\",\"在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。\",\"在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行\",\"若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存\",\"虚拟内存实际的物理内存大小没有变，只是在逻辑上进行了扩充\",\"虚拟内存的三个主要特征\",\"多次性：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存\",\"对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出\",\"虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量\",\"如何实现虚拟内存技术\",\"虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配的方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上\",\"image-20220515155525114\",\"image-20220515155622275\"]},\"190\":{\"h\":\"16、请求分页存储管理\",\"t\":[\"请求分页存储管理与基本分页存储管理的主要区别：\",\"在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行\",\"若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存\",\"请求分页管理的方式\",\"页表机制\",\"缺页中断机构\",\"地址变换机构\",\"页表机制\",\"image-20220515160709826\",\"缺页中断机构\",\"在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断\",\"此时缺页的进程阻塞，放入阻塞队列，调页完成之后再将其唤醒，放回就绪队列\",\"如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项\",\"如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存\",\"​ 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。一条指令在执行期间，可能产生多次缺页中断(比如copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)\",\"地址变换机构\",\"image-20220515204309592\",\"image-20220515204850109\"]},\"191\":{\"h\":\"17、页面置换算法\",\"t\":[\"算法种类：最佳置换算法(OPT)，先进先出置换算法(FIFO)，最近最久未使用置换算法(LRU)，时钟置换算法(CLOCK)，改进型的时钟置换算法\",\"页面的换入、换出需要磁盘的I/O，会有较大的开销，因此页面置换算法应该追求更少的缺页率。\",\"最佳置换算法(OPT)\",\"每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。追求的是最低的缺页率，但在实际过程中，只有在进程执行的过程中才能知道接下来会访问的是哪个页面，操作系统无法提前预判页面访问序列。因此最佳置换算法是无法实现的\",\"image-20220521130218677\",\"上图缺页中断发生了9次，页面置换发生了6次(注意：缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换)\",\"缺页率 = 9 / 20 = 45%\",\"先进先出置换算法(FIFO)\",\"每次选择淘汰的页面是最早进入内存的页面\",\"实现方法：将调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。\",\"先进入的页面在之后也有可能经常的访问到，所以算法性能较差\",\"image-20220521131041972\",\"缺页9次。当分配四个内存块的时候，缺页发生10次，分配三个内存块时，缺页发生9次\",\"Belady异常---当为进程分配的物理块数增大时，缺页次数不减反增的异常现象\",\"最近最久未使用置换算法(LRU)\",\"每次淘汰的页面是最近最久未使用的页面\",\"页表项中的访问字段记录页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值的最大的，即最近最久未使用的页面\",\"image-20220521132954826\",\"找最晚出现的淘汰掉\",\"算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大\",\"时钟置换算法(CLOCK)\",\"时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未使用算法(NRU)\",\"简单的CLOCK算法实现方法：为每一个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描所有页面都是1，则将这些页面的访问依次置为0，再进行第二轮扫描(第二轮扫描一定会有访问位为0的页面)\",\"image-20220521133823507\",\"改进型时钟置换算法思想：简单的时钟置换算法仅仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，在其他条件都相同时，应该优先淘汰没有修改过的页面，避免I/O操作。修改为=0，表示页面没有被修改过；修改为=1，表示页面被修改过，用**(访问位，修改位)**的形式表示各页面的状态，比如(1,1)表示一个页面近期被访问过，且被修改过。\",\"算法规则：将所有可能被置换的页面排成一个循环队列 \",\"第一轮：从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近没有访问且没有修改过的页面)\",\"第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (最近没访问，但修改过的页面)\",\"第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近访问过，但没有修改过的页面)\",\"第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换(最近访问过，且修改过的页面)\",\"由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，所有淘汰一个页面最多进行四轮扫描\",\"image-20220521141844658\"]},\"192\":{\"h\":\"18、页面分配策略\",\"t\":[\"驻留集：指请求分页存储管理中给进程分配的物理块的集合，采用虚拟内存技术的系统中，驻留集大小一般小于进程的总大小\",\"驻留集太小，会导致缺页频繁，系统要花大量的时间来处理分页，实际用于进程推进的时间很少\",\"驻留集太大，又会导致多道程序并发度下降，资源利用率低\",\"固定分配：操作系统为每一个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变\",\"可变分配：先为进程分配一定数目的物理块，在进程运行期间，可以根据情况做出适当的增加或减少。即，驻留集大小可变\",\"局部置换：发生缺页时只能选进程自己的物理块进行置换\",\"全局置换：可将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程\",\"局部置换\",\"全局置换\",\"固定分配\",\"√\",\"---\",\"可变分配\",\"√\",\"√\",\"image-20220521200544645\",\"何时调入页面\",\"1、预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更加高效。但如果提前调入的页面大多数都没被访问过，则又是低效的。故这种策略主要用于进程首次调入，由程序员指出应该先调入哪些部分(运行前调入)\",\"2、请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由于这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大(运行时调入)\",\"从何处调入页面\",\"image-20220521202834105\",\"抖动(颠簸)现象\",\"刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)\",\"工作集：指在某段时间间隔里，进程实际访问页面的集合\",\"驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页\",\"image-20220521203500688\"]},\"193\":{\"h\":\"操作系统下\"},\"194\":{\"h\":\"1、初识文件管理\",\"t\":[\"文件内部的数据组织形式\",\"image-20220521220755154\",\"文件组织形式\",\"image-20220521220941143\",\"操作系统向上提供的功能\",\"image-20220521221245106\",\"可以使用几个基本操作完成更加复杂的操作，比如：复制文件：先创建一个新的空文件夹，再把源文件读入内存，再将内存中的数据写入到新文件中\",\"文件如何存放在外存？\",\"image-20220521221810990\",\"其他需要操作系统实现的文件管理功能\",\"文件共享：使多个用户可以共享使用一个文件\",\"文件保护：如何保证不同的用户对文件由不同的操作权限\"]},\"195\":{\"h\":\"2、文件的逻辑结构\",\"t\":[\"文件逻辑结构：指在用户看来，文件内部的数据应该是如何组织起来的\",\"文件的物理结构：在操作系统看来，文件的数据是如何存放在外存中的\",\"image-20220522125526046\",\"无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。比如：.txt文件\",\"有结构文件：由一组相似的记录组成，又称为“记录式文件”。每条记录又由若干个数据项组成。如\",\"image-20220522125936141\",\"根据各条记录的长度(占用的存储空间)是否相等，又可以分为定长记录和可变长记录\",\"定长记录\",\"image-20220522131645588\",\"可变长记录\",\"image-20220522131805969\",\"顺序文件\",\"文件中的记录一个接一个的顺序排列(逻辑上)，记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储\",\"image-20220522132423543\",\"已经知道文件的起始地址，能否找到第i个记录对应的地址即能否实现随机存储，能否根据关键字实现随机查找？\",\"image-20220522134405761\",\"索引文件\",\"解决的问题：对于可变长记录文件，要找到第i个记录，必须先顺序查找第i - 1个记录。\",\"image-20220522135220091\",\"索引顺序文件\",\"解决问题：每个记录对应一个索引表项，因此索引表可能会很大\",\"image-20220522141420657\",\"文件检索效率\",\"image-20220522142220989\",\"多级索引顺序文件\",\"image-20220522142404913\",\"image-20220522142638847\"]},\"196\":{\"h\":\"3、文件目录\",\"t\":[\"image-20220522143959739\",\"文件控制块\",\"image-20220522144708324\",\"image-20220522144900273\",\"需要对目录进行哪些操作？\",\"搜索：当用户需要使用一个文件的时候，系统要根据文件名搜索目录，找到该文件对应的目录项\",\"创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项\",\"删除文件：当删除一个文件时，需要在目录中删除相应的目录项\",\"显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应的属性\",\"修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项\",\"目录结构----单级目录结构\",\"整个系统只建立一张目录表，每个文件占一个目录项\",\"image-20220522202312578\",\"目录结构---两级目录结构\",\"早期的多用户操作系统，采用两级目录结构。分为主文件目录(MFD)和用户文件目录(UFD)\",\"image-20220522203520109\",\"目录结构---多级目录结构(又称树形目录结构)\",\"image-20220522203842838\",\"image-20220522204512602\",\"目录结构---无环图目录结构\",\"解决的问题：树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。\",\"image-20220522213646590\",\"索引结点(FCB的改进)\",\"image-20220522213950345\",\"image-20220522214100918\",\"image-20220522214148310\"]},\"197\":{\"h\":\"4、文件的物理结构\",\"t\":[\"类似内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”，磁盘块的大小与内存块、页面的大小相同\",\"内存与磁盘之间的数据交换(即读/写操作、磁盘I/O)都是以块为单位进行的，即每次读入一块，或每次写出一块\",\"image-20220524133535599\",\"文件分配方式----连续分配\",\"连续分配方式要求每个文件在磁盘上占有一组连续的块\",\"优点：支持顺序访问和直接访问(即随机访问)；连续分配的文件在顺序访问时速度最快\",\"image-20220524134337470\",\"image-20220524134541056\",\"缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片\",\" ![image-20220524142132631](https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220524142132631.png) \",\"文件分配方式---链接分配\",\"链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种\",\"隐式链接\",\"image-20220529212115224\",\"image-20220529212212817\",\"隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块指针\",\"优点：方便文件拓展，不会有碎片问题，外存利用率高\",\"缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。\",\"显示链接\",\"image-20220529212901703\",\"image-20220529213416885\",\"显示链接---把用于链接文件各个物理块的指针显示的存放在一张表中，即文件分配表(FAT)。一个磁盘只会建立一张文件分配表，开机时文件分配表放入内存，并常驻内存。\",\"优点：方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问，相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高\",\"缺点：文件分配表需要占用一定的内存\",\"索引分配\",\"image-20220529214611813\",\"如何实现文件的逻辑块号到物理块号的转换？\",\"image-20220529215048681\",\"若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放256个索引项，如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决？\",\"①链接方案\",\"②多层索引\",\"③混合索引\",\"链接方案\",\"image-20220529222421721\",\"多层索引\",\"image-20220530143548528\",\"采用k层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要k + 1次读磁盘操作\",\"混合索引\",\"image-20220530144020397\"]},\"198\":{\"h\":\"5、文件存储空间管理\",\"t\":[\"存储空间的划分与初始化\",\"image-20220530144632343\",\"存储空间管理---空闲表法\",\"适用于连续分配方式\",\"image-20220530145112083\",\"存储空间管理---空闲链表法\",\"image-20220530145400964\",\"空闲盘块链\",\"image-20220530145536142\",\"空闲盘区链\",\"image-20220530145757007\",\"存储空间管理---位视图法\",\"image-20220530193310886\",\"image-20220530193511600\",\"连续分配、离散分配都适用\",\"存储空间管理---成组链接法\",\"image-20220530193750402\",\"image-20220530194728231\",\"如何进行空闲块的分配？\",\"比如：需要100个空闲块\",\"①检查第一个分组的块数是否足够。100 = 100，足够。\",\"②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中\",\"image-20220530195251537\",\"image-20220530195308743\",\"如何回收？\",\"假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组\",\"image-20220530195708965\",\"image-20220530195918540\"]},\"199\":{\"h\":\"6、文件的基本操作\",\"t\":[\"创建文件\",\"image-20220530201101036\",\"删除文件\",\"image-20220530201342594\",\"打开文件\",\"image-20220530201818071\",\"打开文件\",\"image-20220530202619445\",\"关闭文件\",\"image-20220530202718681\",\"读文件\",\"image-20220530204655334\",\"写文件\",\"image-20220530204953730\",\"image-20220530205021424\"]},\"200\":{\"h\":\"7、文件共享\",\"t\":[\"文件共享是操作系统为用户提供文件共享功能，可以让多个用户共享的适用同一个文件，多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件数据，其他用户也可以看到文件数据的变化\",\"基于索引节点的共享方式(硬链接)\",\"image-20220530205956876\",\"基于符号链的共享方式(软链接)\",\"image-20220530210148637\",\"image-20220530210336394\",\"image-20220530210456044\"]},\"201\":{\"h\":\"8、文件保护\",\"t\":[\"口令保护\",\"image-20220530210706405\",\"加密保护\",\"image-20220530210923203\",\"每五位就与01001进行异或操作\",\"优点：保密性强，不需要再系统中存储“密码”\",\"缺点：编码/译码(加密/解密)要花费一定时间\",\"访问控制\",\"image-20220530212222775\",\"精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。比如：分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组\",\"当用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限\",\"image-20220530212539209\",\"image-20220530212817688\"]},\"202\":{\"h\":\"9、文件系统的层次结构\",\"t\":[\"image-20220530213756966\",\"image-20220530214006044\"]},\"203\":{\"h\":\"10、磁盘的结构\",\"t\":[\"磁盘、磁道、扇区\",\"image-20220530214532180\",\"如何在磁盘中读/写数据\",\"盘面/柱面\",\"image-20220530220243511\",\"柱面：具有相同编号的磁道形成的圆柱\",\"磁盘的分类\",\"image-20220530220354717\",\"image-20220530220421638\",\"image-20220530220453740\"]},\"204\":{\"h\":\"11、磁盘调度算法\",\"t\":[\"一次磁盘读/写操作需要的时间\",\"寻找时间(寻道时间)Ts​ :在读/写数据前，将磁头移动到指定磁盘所花的时间\",\"启动磁头臂时间为s\",\"移动磁头时间，假设是匀速移动，每跨越一个磁道耗时为m，总共需要跨越n个磁道\",\"寻道时间 Ts​=s+m∗n\",\"延迟时间TR​ :通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r，则平均所需的延迟时间$T_R = \\\\frac{1}{2} * \\\\frac{1}{r} = \\\\frac{1}{2r} $ (r1​ 是转动一圈需要的时间，找到目标扇区平均需要转半圈，因此乘21​)\",\"传输时间Ts​ :从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁盘上的字节数为N。则\",\"传输时间Ts​=r1​∗Nb​=rNb​ (每个磁道可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储，而读/写一个磁道所需的时间刚好又是转一圈所需要的时间r1​ )\",\"总的平均存储时间Ta​=Ts​+2r1​+rNb​\",\"延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件固有的属性，因此操作系统也无法优化延迟时间和传输时间。\",\"磁盘调度算法\",\"先来先服务算法(FCFS)\",\"image-20220530224610670\",\"最短寻找时间优先(SSTF)\",\"image-20220531113725569\",\"扫描算法(SCAN)\",\"image-20220531114050634\",\"LOOK调度算法\",\"image-20220531114605608\",\"循环扫描算法(C-SCAN)\",\"image-20220531114848212\",\"C-LOOK调度算法\",\"image-20220531115047482\",\"image-20220531115101881\"]},\"205\":{\"h\":\"12、减少延迟时间的方法\",\"t\":[\"image-20220531200459574\",\"减少延迟时间的方法：交替编号\",\"image-20220531201414435\",\"image-20220531223117841\",\"转两圈读完的原因：因为要一个隔着一个的读，所以需要两圈\",\"image-20220531223412094\",\"减少延迟时间的方法：错位命名\",\"image-20220607112210165\",\"0号盘面是在1号盘面上面的，扇区都一一对应，转两圈读取完0号盘面的数据以后，读取1号盘面的0扇区时无法立即开始读，增加了延迟时间\",\"image-20220607112458312\",\"image-20220607112703160\"]},\"206\":{\"h\":\"13、磁盘的管理\",\"t\":[\"磁盘初始化\",\"image-20220607113400305\",\"引导块\",\"计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行**初始化程序(自举程序)**完成的\",\"在ROM中存放了很小的\\\"自举装入程序\\\"，开机时计算机先运行\\\"自举装入程序\\\"，通过执行该程序就可以找到引导块，并将完整的自举程序读入内存，完成初始化\",\"完整的自举程序放在磁盘的启动块(即引导块/启动分区)上，启动块位于磁盘的固定位置，拥有启动分区的磁盘为启动磁盘或系统磁盘(C:盘)\",\"坏块管理\",\"坏块：无法正常使用的扇区，属于硬件故障，操作系统是无法修复的，应该将坏块标记出来，以免错误的使用到它\",\"image-20220608103307481\",\"image-20220608103332891\"]},\"207\":{\"h\":\"14、I/O设备的基本概念和分类\",\"t\":[\"I/O设备介绍\",\"image-20220608104012756\",\"I/O设备的分类\",\"按照使用特性分类\",\"按照传输速率分类\",\"image-20220608104500993\",\"按信息交换的单位分类\",\"image-20220608104632049\",\"image-20220608104719687\"]},\"208\":{\"h\":\"15、I/O控制器\",\"t\":[\"I/O设备的机械部件\",\"I/O设备的电子部件(I/O控制器)\",\"image-20220608105259812\",\"I/O控制器的组成\",\"image-20220608105835197\",\"注意：\",\"一个I/O控制器可能会对应多个设备\",\"数据寄存器、控制寄存器、状态寄存器可能也有多个，每个控制/状态寄存器对应一个具体的设备，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O;另一些计算机则采用I/O专用地址，即寄存器独立编址\",\"内存映像I/O与寄存器独立编址\",\"image-20220608110542490\",\"image-20220608110604462\"]},\"209\":{\"h\":\"16、I/O控制方式\",\"t\":[\"程序直接控制方式\",\"完成一次读/写操作的流程(轮询)\",\"image-20220608132930223\",\"image-20220608133444265\",\"CPU干预的频率\",\"很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断的轮询检查\",\"数据传送的单位\",\"每次读/写一个字\",\"数据的流向\",\"读操作(数据输入)：I/O设备 ---> CPU --> 内存\",\"写操作(数据输出)：内存 ---> CPU ---> I/O设备\",\"每个字的读/写都需要CPU的帮助\",\"优缺点\",\"优点：实现简单，在读/写指令之后，加上实现循环检查的一系列指令即可\",\"缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低\",\"中断驱动方式\",\"完成一次读/写操作的流程\",\"CPU干预的频率\",\"每次I/O操作开始之前、完成之后需要CPU介入\",\"等待I/O完成的过程中CPU可以切换到别的进程执行\",\"数据传送单位\",\"每次读/写一个字\",\"数据的流向\",\"读操作(数据输入)：I/O设备 ---> CPU --> 内存\",\"写操作(数据输出)：内存 ---> CPU ---> I/O设备\",\"优缺点\",\"优点：与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停的轮询。CPU与I/O设备可并行工作，CPU利用率得到明显的提升\",\"缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间，每次中断只能传输一个字\",\"DMA方式(直接存储器存取)\",\"完成一次读/写操作的流程\",\"DMA控制器\",\"image-20220608140914035\",\"CPU干预的频率\",\"在传送一个或多个数据块的开始和结束时，才需要CPU的干预\",\"数据传送的单位\",\"每次读/写一个或多个块(注意每次读写的只能是连续的多个块，且这些块读入内存后在)\",\"数据的流向(不再需要经过CPU)\",\"读操作(数据输入)：I/O设备 ---> 内存\",\"写操作(数据输出)：内存 ---> I/O设备\",\"优缺点\",\"优点：数据传输以\\\"块\\\"为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升\",\"缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读写多个离散存储的数据块，或者要将数据分别写到不同内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成\",\"通道控制方式\",\"image-20220608144106793\",\"image-20220608144250495\",\"image-20220608144448647\"]},\"210\":{\"h\":\"17、I/O软件层次结构\",\"t\":[\"用户层系统\",\"image-20220608145040522\",\"设备独立性软件\",\"设备独立性软件，又称设备无关性软件，与设备的硬件特性无关的功能都几乎在这一层实现。\",\"主要实现的功能：\",\"向上层提供统一的调用接口(如read/write系统调用)\",\"设备的保护：设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样\",\"差错处理：对一些设备的错误进行处理\",\"设备的分配与回收\",\"数据缓冲区管理：通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\",\"建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序\",\"image-20220608150454000\",\"image-20220608150624784\",\"image-20220608150637422\",\"设备驱动程序\",\"负责对硬件设备的具体控制，将上层发出的一系列命令(如read/write)转化成特定设备能听得懂的一些列操作，包括设置设备寄存器，检查设备状态等。不同的I/O设备有不同的硬件特性，具体细节只有设备厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序\",\"中断处理程序\",\"image-20220608152211751\",\"image-20220608153523239\"]},\"211\":{\"h\":\"18、I/O核心子系统\",\"t\":[\"I/O系统(I/O核心子系统)属于操作系统的内核部分，主要包括：设备独立性软件、设备驱动程序、中断处理程序\",\"image-20220608154426249\",\"I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求\",\"比如：磁盘调度 ，当多个磁盘I/O请求到来时，用某种调度算法来确定满足I/O请求的顺序\",\"设备保护：\",\"操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限(如：只读、读和写等)\",\"在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现设备保护功能\"]},\"212\":{\"h\":\"19、假脱机技术\",\"t\":[\"脱机技术简介\",\"手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快，人机速度矛盾明显，主机要浪费很多时间来等待设备\",\"image-20220609095039255\",\"批处理阶段引入了脱机输入/输出技术(用磁带完成)：\",\"image-20220609095427515\",\"假脱机技术，又称\\\"SPOOLing技术\\\"是用软件的方式模拟脱机技术。系统的组成如下：\",\"image-20220609095722677\",\"输入井：模拟脱机输入时的磁带，用于收容I/O设备输入的数据\",\"输出井：模拟脱机输出时的磁带，用于收容用户进程输出的数据\",\"输入进程：模拟脱机输入时的外围控制机\",\"输出进程：模拟脱机输出时的外围控制机\",\"输入缓冲区：在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后在转存到输入井中\",\"输出缓冲区：在输出进程的控制下，用于暂存从输出井传来的数据，之后再传送到输出设备上\",\"共享打印机原理分析\",\"image-20220609100750640\",\"image-20220609101627441\",\"image-20220609101720564\",\"image-20220609101958603\"]},\"213\":{\"h\":\"20、设备的分配与回收\",\"t\":[\"设备分配时应考虑的因素\",\"设备的固有属性：\",\"独占设备—一个时段只能分配一个进程\",\"共享设备—可同时分配给多个进程使用，各进程往往是宏观上同时共享使用设备，而在微观上交替使用\",\"虚拟设备—采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用\",\"设备的分配算法：\",\"先来先服务、优先级高者优先、短任务优先.....\",\"设备分配中的安全性：\",\"image-20220609103338474\",\"静态分配和动态分配\",\"静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源，不会发生死锁\",\"动态分配：进程运行过程中动态申请设备资源\",\"设备分配管理中的数据结构\",\"image-20220609103645775\",\"image-20220609103942129\",\"image-20220609104134198\",\"image-20220609104233122\",\"image-20220609104330037\",\"设备分配的步骤\",\"根据进程请求的物理设备名查找SDT(物理设备名是进程请求分配时提供的参数)\",\"根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程\",\"根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程\",\"根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配个进程\",\"缺点：\",\"用户编程时必须使用\\\"物理设备名\\\"，底层细节对用户不透明，不方便编程\",\"若换了一个物理设备，则程序无法运行\",\"若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待\",\"改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名\",\"设备分配改进\",\"image-20220610212414867\",\"image-20220610212527979\"]},\"214\":{\"h\":\"21、缓冲区管理\",\"t\":[\"缓冲区介绍以及作用\",\"image-20220610212917960\",\"image-20220610213119470\",\"单缓冲\",\"image-20220610213442230\",\"image-20220610213728733\",\"image-20220610214210814\",\"结论：采用单缓冲策略，处理一块数据平均耗时Max(C,T) + M\",\"双缓冲\",\"image-20220610214717158\",\"image-20220610215055371\",\"结论：采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)\",\"使用单/双缓冲在通信时的区别\",\"image-20220610215815431\",\"image-20220610215848171\",\"image-20220610220013207\",\"循环缓冲区\",\"image-20220610220150678\",\"缓冲池\",\"image-20220610221353573\",\"image-20220610221431032\"]},\"215\":{\"h\":\"AI\"},\"216\":{\"h\":\"书籍\"},\"217\":{\"h\":\"Windows 工具\"},\"218\":{\"h\":\"数据仓库基础与 Apache Hive 入门\"},\"219\":{\"h\":\"1. 数据仓库\",\"t\":[\"数据仓库（英语：Data Warehouse，简称数仓、DW）,是一个用于存储、分析、报告的数据系统。 数据仓库的目的是构建面向分析的集成化数据环境，分析结果为企业提供决策支持（Decision Support）。\"]},\"220\":{\"h\":\"1.1 数据仓库、数据库、数据集市\"},\"221\":{\"h\":\"1.1.1 OLTP、OLAP\",\"t\":[\"联机事务处理 OLTP（On-Line Transaction Processing） 联机分析处理 OLAP（On-Line Analytical Processing）\",\"这两个主要记住\",\"OLTP目标是做数据处理，比如常见的关系型数据库系统（RDBMS）\",\"OLAP目标是做数据分析，比如数据仓库\"]},\"222\":{\"h\":\"1.1.2 数据仓库、数据库\",\"t\":[\"数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别\",\"区别：\",\"数据仓库不是大型的数据库，虽然数据仓库存储数据规模大。\",\"数据仓库的出现，并不是要取代数据库。\",\"数据库是面向事务的设计，数据仓库是面向主题设计的。\",\"数据库一般存储业务数据，数据仓库存储的一般是历史数据。\",\"数据库是为捕获数据而设计，数据仓库是为分析数据而设计。\"]},\"223\":{\"h\":\"1.1.3 数据仓库、数据集市\",\"t\":[\"数据仓库（Data Warehouse）是面向整个集团组织的数据，数据集市( Data Mart ) 是面向单个部门使用的\",\"可以认为数据集市是数据仓库的子集，也有人把数据集市叫做小型数据仓库。数据集市通常只涉及一个主题领域，例如市场营销或销售。因为它们较小且更具体，所以它们通常更易于管理和维护，并具有更灵活的结构。\"]},\"224\":{\"h\":\"1.2 数据仓库分层架构\",\"t\":[\"每个企业根据自己的业务需求可以分成不同的层次。但是最基础的分层思想，理论上分为三个层：操作型数据层（ODS）、数据仓库层(DW)和数据应用层(DA)。\",\"阿里巴巴数仓3层架构\"]},\"225\":{\"h\":\"1.2.1 ODS层（Operation Data Store）\",\"t\":[\"操作型数据层，也称之为源数据层、数据引入层、数据暂存层、临时缓存层。\",\"此层存放未经过处理的原始数据至数据仓库系统，结构上与源系统保持一致，是数据仓库的数据准备区。\",\"主要完成基础数据引入到数仓的职责，和数据源系统进行解耦合，同时记录基础数据的历史变化。\"]},\"226\":{\"h\":\"1.2.2 DW层（Data Warehouse）\",\"t\":[\"数据仓库层，由ODS层数据加工而成。主要完成数据加工与整合，建立一致性的维度，构建可复用的面向分析和统计的明细事实表，以及汇总公共粒度的指标。内部具体划分如下：\",\"公共维度层（DIM）：基于维度建模理念思想，建立整个企业一致性维度。\",\"公共汇总粒度事实层（DWS、DWB）：以分析的主题对象作为建模驱动，基于上层的应用和产品的指标需求，构建公共粒度的汇总指标事实表，以宽表化手段物理化模型\",\"明细粒度事实层（DWD）: 将明细事实表的某些重要维度属性字段做适当冗余，即宽表化处理。\"]},\"227\":{\"h\":\"1.2.3 DA层（或ADS层）\",\"t\":[\"数据应用层，面向最终用户，面向业务定制提供给产品和数据分析使用的数据。\",\"包括前端报表、分析图表、KPI、仪表盘、OLAP专题、数据挖掘等分析。\"]},\"228\":{\"h\":\"1.2.4 ETL、ELT\",\"t\":[\"数据仓库从各数据源获取数据及在数据仓库内的数据转换和流动都可以认为是ETL（抽取Extra, 转化Transfer, 装载Load）的过程。\",\"这两个只是理论上的三个步骤，具体如何排列组合还是得看具体的项目，了解即可。\",\"ETL：\",\"首先从数据源池中提取数据，这些数据源通常是事务性数据库。数据保存在临时暂存数据库中（ODS）。然后执行转换操作，将数据结构化并转换为适合目标数据仓库系统的形式。然后将结构化数据加载到仓库中，以备分析。\",\"ELT：\",\"使用ELT，数据在从源数据池中提取后立即加载。没有专门的临时数据库（ODS），这意味着数据会立即加载到单一的集中存储库中。数据在数据仓库系统中进行转换，以便与商业智能工具（BI工具）一起使用。大数据时代的数仓这个特点很明显。\"]},\"229\":{\"h\":\"2. Apache Hive 入门\",\"t\":[\"Apache Hive是一款建立在Hadoop之上的开源数据仓库系统，可以将存储在Hadoop文件中的结构化、半结构化数据文件映射为一张数据库表，基于表提供了一种类似SQL的查询模型，称为Hive查询语言（HQL），用于访问和分析存储在Hadoop文件中的大型数据集。\",\"Hive核心是将HQL转换为MapReduce程序，然后将程序提交到Hadoop群集执行。\",\"Hive由Facebook实现并开源。\"]},\"230\":{\"h\":\"2.1 Apache Hive 架构、组件\"},\"231\":{\"h\":\"2.1.1 架构图\",\"t\":[\"Apache Hive架构\"]},\"232\":{\"h\":\"2.1.2 组件\",\"t\":[\"用户接口 包括 CLI、JDBC/ODBC、WebGUI。其中，CLI(command line interface)为shell命令行；Hive中的Thrift服务器允许外部客户端通过网络与Hive进行交互，类似于JDBC或ODBC协议。WebGUI是通过浏览器访问Hive。\",\"元数据存储 通常是存储在关系数据库如 mysql/derby中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。\",\"Driver驱动程序，包括语法解析器、计划编译器、优化器、执行器 完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有执行引擎调用执行。\",\"执行引擎 Hive本身并不直接处理数据文件。而是通过执行引擎处理。当下Hive支持MapReduce、Tez、Spark3种执行引擎。\"]},\"233\":{\"h\":\"2.2 Apache Hive 数据模型\",\"t\":[\"用来描述数据、组织数据和对数据进行操作，是对现实世界数据特征的描述\",\"Hive中的数据可以在粒度级别上分为三类：\",\"Table表\",\"Partition分区\",\"Bucket分桶\"]},\"234\":{\"h\":\"2.2.1 Databases 数据库\",\"t\":[\"Hive作为一个数据仓库，在结构上积极向传统数据库看齐，也分数据库（Schema），每个数据库下面有各自的表组成。默认数据库default\",\"Hive的数据都是存储在HDFS上的，默认有一个根目录，在hive-site.xml中，由参数hive.metastore.warehouse.dir指定。默认值为/user/hive/warehouse\",\"比如名为vingkin的数据库的存储路径为：/user/hive/warehouse/vingkin.db\"]},\"235\":{\"h\":\"2.2.2 Tables 表\",\"t\":[\"Hive表与关系数据库中的表相同。Hive中的表所对应的数据通常是存储在HDFS中，而表相关的元数据是存储在RDBMS中\",\"Hive中的表的数据在HDFS上的存储路径为：${hive.metastore.warehouse.dir}/databasename.db/tablename\",\"比如vingkin数据库下的t_user表的路径为：/user/hive/warehouse/vingkin.db/t_user\"]},\"236\":{\"h\":\"2.2.3 Partitions 分区\",\"t\":[\"Partition分区是hive的一种优化手段表。分区是指根据分区列（例如“日期day”）的值将表划分为不同分区。这样可以更快地对指定分区数据进行查询\",\"分区在存储层面上的表现是:table表目录下以子文件夹形式存在。\",\"一个文件夹表示一个分区。子文件命名标准：分区列=分区值\",\"/user/hive/warehouse/vingkin.db/t_user /day=20200825/ /day=20200826/ /day=20200827/ \"]},\"237\":{\"h\":\"2.2.4 Buckets 分桶\",\"t\":[\"Bucket分桶表是hive的一种优化手段表。分桶是指根据表中字段（例如“编号ID”）的值,经过hash计算规则将数据文件划分成指定的若干个小文件\",\"分桶规则：hashfunc(字段) % 桶个数，余数相同的分到同一个文件\",\"分桶的好处是可以优化join查询和方便抽样查询。\",\"Bucket分桶表在HDFS中表现为同一个表目录下数据根据hash散列之后变成多个文件。\",\"# 未分桶表 /user/hive/warehouse/vingkin.db/t_user/user.txt # 分桶表（%3） /user/hive/warehouse/vingkin.db/t_user /0.txt /1.txt /2.txt \"]},\"238\":{\"h\":\"2.3 Apache Hive 元数据\",\"t\":[\"元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能\"]},\"239\":{\"h\":\"2.3.1 Hive Metadata\",\"t\":[\"Hive Metadata即Hive的元数据\",\"包含用Hive创建的database、table、表的位置、类型、属性，字段顺序类型等元信息\",\"元数据存储在关系型数据库中。如hive内置的Derby、或者第三方如MySQL等\"]},\"240\":{\"h\":\"2.3.2 Hive Metastore\",\"t\":[\"Metastore即元数据服务。Metastore服务的作用是管理metadata元数据，对外暴露服务地址，让各种客户端通过连接metastore服务，由metastore再去连接MySQL数据库来存取元数据。\",\"有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。某种程度上也保证了hive元数据的安全。\"]},\"241\":{\"h\":\"2.4 Metastore 三种配置方式\",\"t\":[\"Metastore服务配置有3种模式：内嵌模式、本地模式、远程模式\",\"区分3种配置方式的关键是弄清楚两个问题：\",\"Metastore服务是否需要单独配置、单独启动\",\"Metadata是存储在内置的derby中，还是第三方RDBMS,比如MySQL\",\"内嵌模式\",\"本地模式\",\"远程模式\",\"Metastore单独配置、启动\",\"否\",\"否\",\"是\",\"Metadata存储介质\",\"Derby\",\"Mysql\",\"Mysql\"]},\"242\":{\"h\":\"2.4.1 内嵌模式\",\"t\":[\"内嵌模式（Embedded Metastore）是metastore默认部署模式\",\"此种模式下，元数据存储在内置的Derby数据库，并且Derby数据库和metastore服务都嵌入在主HiveServer进程中，当启动HiveServer进程时，Derby和metastore都会启动。不需要额外起Metastore服务。\",\"但是一次只能支持一个活动用户，适用于测试体验，不适用于生产环境。\",\"内嵌模式\"]},\"243\":{\"h\":\"2.4.2 本地模式\",\"t\":[\"本地模式（Local Metastore）下，Metastore服务与主HiveServer进程在同一进程中运行，但是存储元数据的数据库在单独的进程中运行，并且可以在单独的主机上。Metastore服务将通过JDBC与Metastore数据库进行通信\",\"本地模式采用外部数据库来存储元数据，推荐使用MySQL。\",\"hive根据hive.metastore.uris 参数值来判断，如果为空，则为本地模式。\",\"缺点是：每启动一次hive服务，都内置启动了一个Metastore\",\"本地模式\"]},\"244\":{\"h\":\"2.4.3 远程模式\",\"t\":[\"远程模式（Remote Metastore）下，Metastore服务在其自己的单独JVM上运行，而不在HiveServer的JVM中运行。如果其他进程希望与Metastore服务器通信，则可以使用Thrift Network API进行通信\",\"远程模式下，需要配置hive.metastore.uris 参数来指定Metastore服务运行的机器ip和端口，并且需要单独手动启动Metastore服务。元数据也采用外部数据库来存储元数据，推荐使用MySQL\",\"在生产环境中，建议用远程模式来配置Hive Metastore。在这种情况下，其他依赖hive的软件都可以通过Metastore访问hive。由于还可以完全屏蔽数据库层，因此这也带来了更好的可管理性/安全性\",\"远程模式\",\"启动方式：\",\"nohup /export/server/hive/bin/hive --service metastore &，后台启动Metastore\",\"/export/server/hive/bin/beeline，使用第二代命令行工具执行\"]},\"245\":{\"h\":\"Hive SQL 数据定义语言（DDL）\"},\"246\":{\"h\":\"1 Hive SQL DDL建表基础语法\"},\"247\":{\"h\":\"1.1 Hive建表完整语法树\",\"t\":[\"蓝色字体是建表语法的关键字，用于指定某些功能。\",\"**[ ]**中括号的语法表示可选。\",\"**|**表示使用的时候，左右语法二选一。\",\"建表语句中的语法顺序要和语法树中顺序保持一致。\",\"Hive建表完整语法树\"]},\"248\":{\"h\":\"1.2 Hive数据类型详解\",\"t\":[\"指的是表中列的字段类型\",\"原生数据类型(primitive data type)：数值类型、时间日期类型、字符串类型、杂项数据类型\",\"复杂数据类型(complex data type)：array数组、map映射、struct结构、union联合体\",\"原生数据类型\",\"复杂数据类型\",\"注意事项：\",\"Hive SQL中，数据类型英文字母大小写不敏感；\",\"除SQL数据类型外，还支持Java数据类型，比如字符串string；\",\"复杂数据类型的使用通常需要和分隔符指定语法配合使用；\",\"如果定义的数据类型和文件不一致，Hive会尝试隐式转换，但是不保证成功。\",\"隐式转换：\",\"原生类型从窄类型到宽类型的转换称为隐式转换，反之，则不允许。 （也就是小数据变成大数据可以隐式转换）\",\"void\",\"boolean\",\"tinyint\",\"smallint\",\"int\",\"bigint\",\"float\",\"double\",\"void to\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"boolean to\",\"false\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"tinyint to\",\"false\",\"false\",\"true\",\"true\",\"true\",\"true\",\"true\",\"true\",\"smallint to\",\"false\",\"false\",\"false\",\"true\",\"true\",\"true\",\"true\",\"true\",\"int to\",\"false\",\"false\",\"false\",\"false\",\"true\",\"true\",\"true\",\"true\",\"bigint to\",\"false\",\"false\",\"false\",\"false\",\"false\",\"true\",\"true\",\"true\",\"float to\",\"false\",\"false\",\"false\",\"false\",\"false\",\"false\",\"true\",\"true\",\"double to\",\"false\",\"false\",\"false\",\"false\",\"false\",\"false\",\"false\",\"true\",\"显示转换：\",\"显式类型转换使用CAST函数\",\"例如，CAST('100' as INT)会将100字符串转换为100整数值。 如果强制转换失败，例如CAST('Allen' as INT)，该函数返回NULL。\"]},\"249\":{\"h\":\"1.3 Hive读写文件机制\",\"t\":[\"SerDe是Serializer、Deserializer的简称，目的是用于序列化和反序列化\",\"序列化是对象转化为字节码的过程\",\"反序列化是字节码转换为对象的过程\"]},\"250\":{\"h\":\"1.3.1 Hive读写文件流程\",\"t\":[\"Hive读取文件机制：首先调用InputFormat（默认TextInputFormat），返回一条一条kv键值对记录（默认是一行对应一条键值对）。然后调用SerDe（默认LazySimpleSerDe）的Deserializer，将一条记录中的value根据分隔符切分为各个字段。(HDFS files - TextInputFormat - <key, value> - Deserializer - Row object )\",\"Hive写文件机制：将Row写入文件时，首先调用SerDe（默认LazySimpleSerDe）的Serializer将对象转换成字节序列，然后调用OutputFormat（默认HiveIgnoreKeyTextOutputFormat）将数据写入HDFS文件中。(Row object - Serializer - <key, value> - HiveIgnoreKeyTextOutputFormat - HDFS files)\"]},\"251\":{\"h\":\"1.3.2 SerDe相关语法\",\"t\":[\" [ROW FORMAT DELIMITED|SERDE serde_name WITH SERDEPROPERTIES (property_name=property_value,...)]\",\"表创建语句中的ROW FORMAT这一行所代表的是跟读写文件、序列化SerDe相关的语法：\",\"使用哪个SerDe类进行序列化（默认LazySimpleSerDe）\",\"如何指定分隔符\",\"如果使用delimited表示使用默认的LazySimpleSerDe类来处理数据\",\"如果数据文件格式比较特殊可以使用ROW FORMAT SERDE serde_name指定其他的SerDe类来处理数据,甚至支持用户自定义SerDe类。\"]},\"252\":{\"h\":\"1.3.3 LazySimpleSerDe分隔符指定\",\"t\":[\"LazySimpleSerDe是Hive默认的序列化类，包含4种子语法，分别用于指定字段之间、集合元素之间、map映射 kv之间、换行的分隔符号\",\"ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] -- 字段之间分隔符 [COLLECTION ITEMS TERMINATED BY char] -- 集合元素之间分隔符 [MAP KEY TERMINATED BY char] -- Map映射KV之间的分隔符 [LINES TERMINATED BY char] -- 行数据之间的分隔符 \",\"Hive默认分隔符：'\\\\001'\"]},\"253\":{\"h\":\"1.4 Hive数据存储路径\"},\"254\":{\"h\":\"1.4.1 默认存储路径\",\"t\":[\"Hive表默认存储路径是由${HIVE_HOME}/conf/hive-site.xml配置文件的hive.metastore.warehouse.dir属性指定，默认值是：/user/hive/warehouse。\"]},\"255\":{\"h\":\"1.4.2 指定存储路径\",\"t\":[\"在Hive建表的时候，可以通过location语法来更改数据在HDFS上的存储路径\",\"语法：LOCATION '<hdfs_location>'\"]},\"256\":{\"h\":\"1.5 基础建表语法联系\",\"t\":[\"数据文件：\",\"字段：id、name（英雄名称）、win_rate（胜率）、skin_price（皮肤及价格）\",\"1,孙悟空,53,西部大镖客:288-大圣娶亲:888-全息碎片:0-至尊宝:888-地狱火:1688 2,鲁班七号,54,木偶奇遇记:288-福禄兄弟:288-黑桃队长:60-电玩小子:2288-星空梦想:0 3,后裔,53,精灵王:288-阿尔法小队:588-辉光之辰:888-黄金射手座:1688-如梦令:1314 4,铠,52,龙域领主:288-曙光守护者:1776 5,韩信,52,飞衡:1788-逐梦之影:888-白龙吟:1188-教廷特使:0-街头霸王:888 \",\"建表语句：\",\"create table if not exists t_hot_hero_skin_price ( id int, name string comment \\\"英雄名称\\\", win_rate double comment \\\"胜率\\\", skin_price map<string, int> comment \\\"皮肤价格\\\" ) comment \\\"热门英雄胜率及皮肤价格\\\" row format delimited fields terminated by \\\",\\\" -- 指定字段之间的分隔符 collection items terminated by \\\"-\\\" -- 指定集合元素之间的分隔符 map keys terminated by \\\":\\\"; -- 指定map元素kv之间的分隔符 \"]},\"257\":{\"h\":\"2 Hive SQL DDL 建表高阶语法\"},\"258\":{\"h\":\"2.1 Hive 内部表、外部表\",\"t\":[\"在创建表的时候通过EXTERNAL关键字指定，不指定表示内部表\",\"create [external] table xxx ();\",\"内部表和外部表的主要区别是外部表再删除时会删除HDFS上的源数据。而外部表不会，外部表只会删除表的元数据，对于其元数据并不会删除。\",\"内部表 / 托管表\",\"外部表\",\"创建方式\",\"默认\",\"使用EXTERNAL关键字\",\"Hive管理范围\",\"元数据、表数据\",\"元数据\",\"删除表结果\",\"删除元数据、删除HDFS上的表数据\",\"只会删除元数据\",\"操作\",\"支持ARCHIVE，UNARCHIVE，TRUNCATE，MERGE，CONCATENATE\",\"不支持\",\"事务\",\"支持ACID / 事务性\",\"不支持\",\"缓存\",\"支持结果缓存\",\"不支持\"]},\"259\":{\"h\":\"2.2 Hive Partitioned Tables 分区表\",\"t\":[\"当Hive表对应的数据量大、文件个数多时，为了避免查询时全表扫描数据，Hive支持根据指定的字段对表进行分区，分区的字段可以是日期、地域、种类等具有标识意义的字段。\",\"本质：\",\"分区的概念提供了一种将Hive表数据分离为多个文件/目录的方法。\",\"不同分区对应着不同的文件夹，同一分区的数据存储在同一个文件夹下。\",\"查询过滤的时候只需要根据分区值找到对应的文件夹，扫描本文件夹下本分区下的文件即可，避免全表数据扫描。\",\"这种指定分区查询的方式叫做分区裁剪。\",\"注意事项：\",\"分区表不是建表的必要语法规则，是一种优化手段表，可选；\",\"分区字段不能是表中已有的字段，不能重复；\",\"分区字段是虚拟字段，其数据并不存储在底层的文件中；\",\"分区字段值的确定来自于用户价值数据手动指定（静态分区）或者根据查询结果位置自动推断（动态分区）\",\"Hive支持多重分区，也就是说在分区的基础上继续分区，划分更加细粒度\"]},\"260\":{\"h\":\"2.2.1 创建分区表\",\"t\":[\"针对《王者荣耀》英雄数据，重新创建一张分区表t_all_hero_part，以role角色作为分区字段\",\"create table if not exists t_all_hero_part ( id int, name string, hp_max int, mp_max int, attack_max int, defense_max int, attack_range string, role_main string, role_assist string ) partitioned by (role string) -- 分区字段不能和表字段重复 row format delimited fields terminated by \\\"\\\\t\\\"; \",\"创建完成后当使用select * from t_all_hero_part时会发现有多了个role字段，该字段是虚拟字段，查询的时候尽量先使用where进行分区过滤，查询指定分区的数据，避免全表扫描，比如下述代码：\",\"-- 先基于分区过滤 再查询 select * from t_all_hero_part where role=\\\"sheshou\\\" and hp_max >6000; \"]},\"261\":{\"h\":\"2.2.2 分区表数据加载\",\"t\":[\"分区表数据加载主要分为静态加载和动态加载两种。其实还可以通过MSCK实现分区表数据的加载，后面进行具体阐述。\",\"静态分区加载：\",\"load data [local] inpath 'filepath ' into table tablename partition(分区字段='分区值'...)，其中local为可选字段，写了表示客户端路径，没写表示HDFS路径。通过下面代码可以发现**静态分区的属性值由用户加载数据时手动指定。\",\"-- 静态分区 load data local inpath '/root/hivedata/archer.txt' into table t_all_hero partition (role = 'sheshou'); load data local inpath '/root/hivedata/assassin.txt' into table t_all_hero partition (role = 'cike'); load data local inpath '/root/hivedata/mage.txt' into table t_all_hero partition (role = 'fashi'); load data local inpath '/root/hivedata/support.txt' into table t_all_hero partition (role = 'fuzhu'); load data local inpath '/root/hivedata/tank.txt' into table t_all_hero partition (role = 'tanke'); load data local inpath '/root/hivedata/warrior.txt' into table t_all_hero partition (role = 'zhanshi'); \",\"动态分区加载：\",\"分区的字段值是基于查询结果（参数位置）自动推断出来的。核心语法就是insert+select\",\"使用动态分区要设置两个参数：\",\"# 是否开启动态分区功能 set hive.exec.dynamic.partition=true; # 指定动态分区模式，分为nonstick非严格模式和strict严格模式。 # strict严格模式要求至少有一个分区为静态分区。 set hive.exec.dynamic.partition.mode=nonstrict; \",\"-- --创建一张新的分区表 t_all_hero_part_dynamic create table if not exists t_all_hero_dynamic ( id int, name string, hp_max int, mp_max int, attack_max int, defense_max int, attack_range string, role_main string, role_assist string ) partitioned by (role string) -- 分区字段不能和表字段重复 row format delimited fields terminated by \\\"\\\\t\\\"; \",\"-- 执行动态分区插值 insert into table t_all_hero_dynamic partition (role) -- 注意这里 分区值没有手动写死 select tmp.*, tmp.role_main from t_all_hero tmp; -- 其中有两个参数tmp.* tmp.role_main。表示tmp.role_main分区插入tmp.*值 \"]},\"262\":{\"h\":\"2.2.3 多重分区\",\"t\":[\"多重 分区就是对分区进行继续分区，比如说先按省分区，省里面再按市分区。从HDFS的角度来看就是文件夹下继续划分文件夹。\",\"-- 多分区表，按省份和市划分 create table t_user_province_city ( id int, name string, age int ) partitioned by (province string, city string) row format delimited fields terminated by \\\",\\\"; \",\"-- 双分区表的数据加载 静态加载方式 load data local inpath '/root/hivedata/user.txt' into table t_user_province_city partition (province = 'zhejiang', city = 'hangzhou'); load data local inpath '/root/hivedata/user.txt' into table t_user_province_city partition (province = 'zhejiang', city = 'ningbi'); load data local inpath '/root/hivedata/user.txt' into table t_user_province_city partition (province = 'shanghai', city = 'pudong'); \"]},\"263\":{\"h\":\"2.3 Hive Bucketed Tables 分桶表\",\"t\":[\"根据表的某个字段进行hash求值，对桶的个数进行取模，从而将单个文件分成多个文件。其原理类似于MapReduce中的分区。\",\"好处：\",\"基于分桶字段查询可以减少全表扫描。因为可以先计算出在哪一个桶文件中，然后在该文件中进行查找。\",\"JOIN时可以提高MR程序效率，减少笛卡尔积数量（前提是对JOIN的字段进行分桶）\",\"分桶表数据进行高效抽样。当数据量特别大时，对全体数据进行处理存在困难时，抽样就显得尤其重要了。抽样可以从被抽取的数据中估计和推断出整体的特性，是科学实验、质量检验、社会调查普遍采用的一种经济有效的工作和研究方法。\"]},\"264\":{\"h\":\"2.3.1 基本语法\",\"t\":[\"[CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]\",\"CLUSTERED BY (col_name)表示根据哪个字段进行分；\",\"SORTED BY (col_name [ASC|DESC], ...)表示根据那个字段进行升序/降序排序，可选\",\"INTO N BUCKETS表示分为几桶（也就是几个部分）\",\"需要注意的是，分桶的字段必须是表中已经存在的字段\"]},\"265\":{\"h\":\"2.3.2 创建分桶表\",\"t\":[\"**案例：**对美国新冠疫情的一份数据进行按state进行分成5桶，并且按累计确诊病例进行倒序排序\",\"**数据字段含义：**count_date（统计日期）,county（县）,state（州）,fips（县编码code）,cases（累计确诊病例）,deaths（累计死亡病例）\",\"部分数据展示：\",\"2021-01-28,Autauga,Alabama,01001,5554,69 2021-01-28,Baldwin,Alabama,01003,17779,225 2021-01-28,Barbour,Alabama,01005,1920,40 2021-01-28,Bibb,Alabama,01007,2271,51 2021-01-28,Blount,Alabama,01009,5612,98 \",\"分桶表创建语句：\",\"create table t_usa_covid19_bucket_sort ( count_data string comment \\\"统计日期\\\", county string comment \\\"县\\\", state string comment \\\"州\\\", fips int comment \\\"县编码\\\", cases int comment \\\"累计确诊病例\\\", deaths int comment \\\"累计死亡病例\\\" ) clustered by (state) sorted by (cases desc) into 5 buckets; \"]},\"266\":{\"h\":\"2.3.3 分桶表数据加载\",\"t\":[\"分桶表数据加载是通过对普通表select，然后insert到分桶表实现的\",\"step1：开启分桶功能（hive2.0开始已经不需要）\",\"set hive.enforce.bucketing=true; \",\"step2：创建普通数据表并载入数据\",\"create table t_usa_covid19 ( count_data string comment \\\"统计日期\\\", county string comment \\\"县\\\", state string comment \\\"州\\\", fips int comment \\\"县编码\\\", cases int comment \\\"累计确诊病例\\\", deaths int comment \\\"累计死亡病例\\\" ) row format delimited fields terminated by \\\",\\\"; \",\"step3：使用insert+select语法将数据加载到分桶表中\",\"insert into t_usa_covid19_bucket_sort select * from t_usa_covid19; \",\"在HDFS中，/user/hive/warehouse/vingkin.db/t_usa_covid19_bucket_sort目录下就有有5个对应的分桶文件。\"]},\"267\":{\"h\":\"2.4 Hive Transactional Tables 事务表\",\"t\":[\"事务表使用时的相关局限性：\",\"尚不支持BEGIN，COMMIT和ROLLBACK。所有语言操作都是自动提交的。\",\"仅支持ORC文件格式（STORED AS ORC）。\",\"默认情况下事务配置为关闭。需要配置参数开启使用。\",\"表必须是**分桶表（Bucketed）**才可以使用事务功能。\",\"表参数transactional必须为true；\",\"外部表不能成为ACID表，不允许从非ACID会话读取/写入ACID表。\"]},\"268\":{\"h\":\"2.4.1 创建事务表\",\"t\":[\"step1：开启事务配置（可以使用set设置当前session生效，也可以配置在hive-site.xml中）\",\"set hive.support.concurrency = true; -- Hive是否支持高并发 set hive.enforce.bucketing = true; -- 从Hive2.0开始不再需要 是否开启分桶功能 set hive.exec.dynamic.partition.mode = nonstrict; -- 动态分区模式 非严格 set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; set hive.compactor.initiator.on = true; -- 是否在Metastore实例上运行启动线程和清理线程 set hive.compactor.worker.threads = 1; -- 在此Metastore实例上运行多少个压缩程序工作线程 \",\"step2：创建Hive事务表\",\"-- 注意 事务表创建要素：开启参数、分桶表、orc、表属性 create table trans_student ( id int, name string, age int -- 存储为orc 并且表的属性设置transactional=true ) clustered by (id) into 2 buckets stored as orc TBLPROPERTIES ('transactional' = 'true'); \",\"step3：针对事务表进行insert update delete操作\",\"insert into trans_student values (1, 'vingkin', 18); \"]},\"269\":{\"h\":\"2.5 Hive View 视图\"},\"270\":{\"h\":\"2.5.1 视图的相关概念\",\"t\":[\"Hive中的视图（view）是一种虚拟表，只保存定义，不实际存储数据。\",\"通常从真实的物理表查询中创建生成视图，也可以从已经存在的视图上创建新视图。\",\"创建视图时，将冻结视图的架构，如果删除或更改基础表，则视图将失败。\",\"视图是用来简化操作的，不缓冲记录，也没有提高查询性能。\",\"视图不能进行修改操作（insert update delete）\"]},\"271\":{\"h\":\"2.5.2 视图的相关语法\",\"t\":[\"创建视图\",\"create view v_usa_covid19 as select count_date, county,state,deaths from t_usa_covid19 limit 5; -- 从已有视图创建新视图 create view v_usa_covid19_from_view as select * from v_usa_covid19 limit 2; \",\"显示当前已有视图\",\"show tables; show views;--hive v2.2.0之后支持 \",\"查询视图\",\"select * from v_usa_covid19; \",\"视图插入演示\",\"-- 报错 SemanticException:A view cannot be used as target table for LOAD or INSERT insert into v_usa_covid19 select count_date,county,state,deaths from t_usa_covid19; \",\"查看视图定义\",\"show create table v_usa_covid19; -- 注意是table \",\"删除视图\",\"drop view v_usa_covid19_from_view; \",\"更改视图属性\",\"alter view v_usa_covid19 set TBLPROPERTIES ('comment' = 'This is a view'); \",\"更改视图定义\",\"alter view v_usa_covid19 as select county,deaths from t_usa_covid19 limit 2; \"]},\"272\":{\"h\":\"2.5.3 使用视图的好处\",\"t\":[\"将真实表中特定的列数据提供给用户，保护数据隐私\",\"--通过视图来限制数据访问可以用来保护信息不被随意查询: create table userinfo(firstname string, lastname string, ssn string, password string); create view safer_user_info as select firstname, lastname from userinfo; --可以通过where子句限制数据访问，比如，提供一个员工表视图，只暴露来自特定部门的员工信息: create table employee(firstname string, lastname string, ssn string, password string, department string); create view techops_employee as select firstname, lastname, ssn from userinfo where department = 'java'; \",\"使用视图优化嵌套查询\"]},\"273\":{\"h\":\"2.6 Materialized Views物化视图\"},\"274\":{\"h\":\"2.6.1 物化视图相关概念\",\"t\":[\"Hive3.0开始尝试引入物化视图，并提供对于物化视图的查询自动重写机制。（基于Apache Calcite实现）。\",\"Hive的物化视图还提供了物化视图存储选择机制，可以本地存储在Hive，也可以通过用户自定义storage handlers存储在其他系统（如Druid）。\",\"Hive引入物化视图的目的就是为了优化数据查询访问的效率,相当于从数据预处理的角度优化数据访问。\",\"Hive从3.0丢弃了index索引的语法支持，推荐使用物化视图和列式存储文件格式来加快查询的速度。\"]},\"275\":{\"h\":\"2.6.2 物化视图和视图的区别\",\"t\":[\"视图是虚拟的，逻辑存在的，只有定义没有存储数据。\",\"物化视图是真实的，物理存在的，里面存储着预计算的数据。\",\"物化视图能够缓存数据，在创建物化视图的时候就把数据缓存起来了，Hive把物化视图当成一张“表”，将数据缓存。而视图只是创建一个虚表，只有表结构，没有数据，实际查询的时候再去改写SQL去访问实际的数据表。\",\"视图的目的是简化降低查询语句的复杂度，而物化视图的目的是提高查询性能。\"]},\"276\":{\"h\":\"2.6.3 物化视图相关语法\",\"t\":[\"查询自动重写的意思是：对一个表进行查询，如果查询的字段在该表的物化视图中都有，那么系统会自动重写查询语句，对物化视图进行查询并返回结果\",\"是否重写查询使用物化视图可以通过全局参数控制，默认为true： hive.materializedview.rewriting=true;\",\"用户可选择性的控制指定的物化视图查询重写机制，语法如下：\",\"ALTER MATERIALIZED VIEW [db_name.]materialized_view_name ENABLE|DISABLE REWRITE;\",\"目前仅支持对物化视图的drop和show操作\",\"-- Drops a materialized view DROP MATERIALIZED VIEW [db_name.]materialized_view_name; -- Shows materialized views (with optional filters) SHOW MATERIALIZED VIEWS [IN database_name]; -- Shows information about a specific materialized view DESCRIBE [EXTENDED | FORMATTED] [db_name.]materialized_view_name; \",\"新建一张事务表 student_trans\",\"set hive.support.concurrency = true; -- Hive是否支持并发 set hive.enforce.bucketing = true; -- 从Hive2.0开始不再需要 是否开启分桶功能 set hive.exec.dynamic.partition.mode = nonstrict; -- 动态分区模式 非严格 set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; set hive.compactor.initiator.on = true; -- 是否在Metastore实例上运行启动线程和清理线程 set hive.compactor.worker.threads = 1; -- 在此metastore实例上运行多少个压缩程序工作线程。 drop table if exists student_trans; CREATE TABLE student_trans ( sno int, sname string, sdept string) clustered by (sno) into 2 buckets stored as orc TBLPROPERTIES('transactional'='true'); \",\"导入数据到student_trans中\",\"insert overwrite table student_trans select num,name,dept from student; \",\"对student_trans建立物化视图\",\"-- 注意 这里当执行CREATE MATERIALIZED VIEW，会启动一个MR对物化视图进行构建 CREATE MATERIALIZED VIEW student_trans_agg AS SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept; \",\"显示已有的物化视图\",\"show tables; show materialized views; \",\"对原始表student_trans查询\",\"-- 由于会命中物化视图，重写query查询物化视图，查询速度会加快（没有启动MR，只是普通的table scan） SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept; \",\"查询执行计划可以发现 查询被自动重写为TableScan alias: itcast.student_trans_agg\",\"-- 转换成了对物化视图的查询 提高了查询效率 explain SELECT sdept, count(*) as sdept_cnt from student_trans group by sdept; \",\"禁用自动重写\",\"-- 禁用物化视图自动重写，禁用后对原表的查询通过MR实现 ALTER MATERIALIZED VIEW student_trans_agg DISABLE REWRITE; \",\"当原表发生改变时，使用REBUILD进行重构\",\"ALTER MATERIALIZED VIEW [db_name.]materialized_view_name REBUILD; \",\"删除物化视图\",\"drop materialized view student_trans_agg; \"]},\"277\":{\"h\":\"3 Hive SQL DDL 其他语法\"},\"278\":{\"h\":\"3.1 Database|Schema（数据库）DDL 操作\",\"t\":[\"-- 创建数据库 create database if not exists itcast comment \\\"this is my first db\\\" with dbproperties ('createdBy'='Allen'); -- 描述数据库信息 describe database itcast; describe database extended itcast; desc database extended itcast; -- 切换数据库 use default; use itcast; create table t_1(id int); -- 删除数据库 -- 注意 CASCADE关键字慎重使用 DROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE]; drop database itcast cascade ; -- 更改数据库属性 ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...); -- 更改数据库所有者 ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role; -- 更改数据库位置 ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; \"]},\"279\":{\"h\":\"3.2 Table（表）DDL操作\",\"t\":[\"-- 查询指定表的元数据信息 describe formatted vingkin.student_partition; -- 1、更改表名 ALTER TABLE table_name RENAME TO new_table_name; -- 2、更改表属性 ALTER TABLE table_name SET TBLPROPERTIES (property_name = property_value, ... ); --更改表注释 ALTER TABLE student SET TBLPROPERTIES ('comment' = \\\"new comment for student table\\\"); -- 3、更改SerDe属性 ALTER TABLE table_name SET SERDE serde_class_name [WITH SERDEPROPERTIES (property_name = property_value, ... )]; ALTER TABLE table_name [PARTITION partition_spec] SET SERDEPROPERTIES serde_properties; ALTER TABLE table_name SET SERDEPROPERTIES ('field.delim' = ','); --移除SerDe属性 ALTER TABLE table_name [PARTITION partition_spec] UNSET SERDEPROPERTIES (property_name, ... ); -- 4、更改表的文件存储格式 该操作仅更改表元数据。现有数据的任何转换都必须在Hive之外进行。 ALTER TABLE table_name SET FILEFORMAT file_format; -- 5、更改表的存储位置路径 ALTER TABLE table_name SET LOCATION \\\"new location\\\"; -- 6、更改列名称/类型/位置/注释 CREATE TABLE test_change (a int, b int, c int); -- First change column a's name to a1. ALTER TABLE test_change CHANGE a a1 INT; -- Next change column a1's name to a2, its data type to string, and put it after column b. ALTER TABLE test_change CHANGE a1 a2 STRING AFTER b; -- The new table's structure is: b int, a2 string, c int. -- Then change column c's name to c1, and put it as the first column. ALTER TABLE test_change CHANGE c c1 INT FIRST; -- The new table's structure is: c1 int, b int, a2 string. -- Add a comment to column a1 ALTER TABLE test_change CHANGE a1 a1 INT COMMENT 'this is column a1'; -- 7、添加/替换列 --使用ADD COLUMNS，您可以将新列添加到现有列的末尾但在分区列之前。 -- REPLACE COLUMNS 将删除所有现有列，并添加新的列集。 ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type,...); \"]},\"280\":{\"h\":\"3.3 Partition（分区）DDL操作\",\"t\":[\"-- 1、增加分区 -- step1: 创建表 手动加载分区数据 drop table if exists t_user_province; create table t_user_province ( num int, name string, sex string, age int, dept string) partitioned by (province string); load data local inpath '/root/hivedata/students.txt' into table t_user_province partition(province =\\\"SH\\\"); -- step2：添加一个分区 ALTER TABLE t_user_province ADD PARTITION (province='BJ') location '/user/hive/warehouse/vingkin.db/t_user_province/province=BJ'; -- step3:必须自己把数据加载到增加的分区中 hive不会帮你添加 -- 此外还支持一次添加多个分区 ALTER TABLE table_name ADD PARTITION (dt='2008-08-08', country='us') location '/path/to/us/part080808' PARTITION (dt='2008-08-09', country='us') location '/path/to/us/part080809'; -- 2、重命名分区 ALTER TABLE t_user_province PARTITION (province =\\\"SH\\\") RENAME TO PARTITION (province =\\\"Shanghai\\\"); -- 3、删除分区 ALTER TABLE table_name DROP [IF EXISTS] PARTITION (dt='2008-08-08', country='us'); ALTER TABLE table_name DROP [IF EXISTS] PARTITION (dt='2008-08-08', country='us') PURGE; --直接删除数据 不进垃圾桶 -- 4、修复分区 MSCK [REPAIR] TABLE table_name [ADD/DROP/SYNC PARTITIONS]; -- 5、修改分区 -- 更改分区文件存储格式 ALTER TABLE table_name PARTITION (dt='2008-08-09') SET FILEFORMAT file_format; -- 更改分区位置 ALTER TABLE table_name PARTITION (dt='2008-08-09') SET LOCATION \\\"new location\\\"; \"]},\"281\":{\"h\":\"3.3.1 MSCK 修复分区\",\"t\":[\"Hive将每个表的分区列表信息存储在其metastore中。但是，如果将新分区直接添加到HDFS（例如通过使用hadoop fs -put命令）或从HDFS中直接删除分区文件夹，则除非用户ALTER TABLE table_name ADD/DROP PARTITION在每个新添加的分区上运行命令，否则metastore（也就是Hive）将不会意识到分区信息的这些更改。\",\"MSCK是metastore check的缩写，表示元数据检查操作，可用于元数据的修复。\",\"step1：创建分区表\",\"create table t_all_hero_part_msck( id int, name string, hp_max int, mp_max int, attack_max int, defense_max int, attack_range string, role_main string, role_assist string ) partitioned by (role string) row format delimited fields terminated by \\\"\\\\t\\\"; \",\"step2：使用HDFS命令创建分区文件夹\",\"hadoop fs -mkdir -p /user/hive/warehouse/vingkin.db/t_all_hero_part_msck/role=sheshou hadoop fs -mkdir -p /user/hive/warehouse/vingkin.db/t_all_hero_part_msck/role=tanke \",\"step3：把数据文件上传到对应的分区文件夹\",\"hadoop fs -put archer.txt /user/hive/warehouse/vingkin.db/t_all_hero_part_msck/role=sheshou hadoop fs -put tank.txt /user/hive/warehouse/vinngkin.db/t_all_hero_part_msck/role=tanke \",\"step4：使用MSCK命令进行修复\",\"-- add partitions可以不写 因为默认就是增加分区 MSCK repair table t_all_hero_part_msck add partitions; \",\"删除分区操作差不多\",\"-- Step1：直接使用HDFS命令删除分区表的某一个分区文件夹 hadoop fs -rm -r /user/hive/warehouse/itheima.db/t_all_hero_part_msck/role=sheshou -- Step2：查询发现还有分区信息 -- 因为元数据信息没有删除 show partitions t_all_hero_part_msck; -- Step3：使用MSCK命令进行修复 MSCK repair table t_all_hero_part_msck drop partitions; \"]},\"282\":{\"h\":\"Hive SQL 数据操控、查询语言（DML，DQL）\"},\"283\":{\"h\":\"1. Hive SQL-DML-Load加载数据\",\"t\":[\"所谓加载是指：将数据文件移动到与Hive表对应的位置，移动时是纯复制、移动操作。\",\"对于local（Hiveserver2所在机器）是复制操作，HDFS中的文件时移动操作。\",\"------ load语法规则 ---- LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)] LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)] [INPUTFORMAT 'inputformat' SERDE 'serde'] (3.0 or later) \"]},\"284\":{\"h\":\"1.1 基本操作\",\"t\":[\"对于加载数据的一些基本操作看之前的文章即可。\",\"其中包含：\",\"静态数据加载\",\"动态数据加载\",\"分区数据加载\",\"!!!Load加载数据基本操作 !!!\"]},\"285\":{\"h\":\"1.2 Hive3.0 新特性\",\"t\":[\"这个新特性就是：假设一个一级分区表有两个字段，对于载入的数据又三个字段，那么数据的前两个字段作为表的字段载入表中，数据的最后一个字段作为分区字段进行分区。具体看下面的例子：\",\"创建一个含有两个字段的表tab1\",\"CREATE TABLE if not exists tab1 (col1 int, col2 int) PARTITIONED BY (col3 int) row format delimited fields terminated by ','; \",\"有一个数据文件tab1.txt具体内容如下所示：\",\"11,22,1 33,44,2 55,66,1 \",\"通过load命令向分区表载入数据：\",\"LOAD DATA LOCAL INPATH '/root/hivedata/tab1.txt' INTO TABLE tab1; \",\"载入数据后，Hive会根据最后一个字段进行自动分区，在HDFS中的表现形式为：\",\"/user/hive/warehouse/vinkgin.db/tab1 /col3=1/000000_0 /col3=2/000000_0 \",\"对于多级分区表来说也是一样的，就以二级分区表为例，应设计好数据文件中的字段，其字段数为表字段数+2，数据文件的倒数第二个字段为一级分区，最后一个字段为二级分区。\"]},\"286\":{\"h\":\"2. Hive SQL-DML-insert插入数据\",\"t\":[\"Hive执行insert本质上是通过MR程序来实现的，所以如果通过insert来逐条插入(insert into table1 valules(xx, xx, ...))那么在大数据的环境中耗时是十分恐怖的，并不推荐使用。但这并不是说明insert没有用武之地，比如分桶表就需要通过insert+select语句加载数据，通过一个MR程序，一次性加载整个表的所有数据。\",\"-- 语法规则 INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...) [IF NOT EXISTS]] select_statement1 FROM from_statement; INSERT INTO TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement; \"]},\"287\":{\"h\":\"2.1 基本操作\",\"t\":[\"在下面的案例中，student_from_insert表的数据就是通过student表中的数据先导出再导入实现的(insert+select)。\",\"创建一张源表student\",\"create table student(num int,name string,sex string,age int,dept string) row format delimited fields terminated by ','; \",\"加载student表数据\",\"load data local inpath '/root/hivedata/students.txt' into table student; \",\"创建一张目标表student_from_insert\",\"create table student_from_insert(sno int,sname string); \",\"从student表中select数据insert到student_from_insert中\",\"insert into table student_from_insert select num,name from student; \"]},\"288\":{\"h\":\"2.2 FROM 多重插入\",\"t\":[\"一次扫描，多次插入。目的是减少扫描的次数，在一次扫描中，完成多次insert操作。\",\"案例：通过select上面的student表，通过多重插入进行一次扫描，插入两个表\",\"我通过yarn发现下面的案例依然是执行了两次MR程序\",\"-- 创建两张新表 create table student_insert1(sno int); create table student_insert2(sname string); -- 多重插入 一次扫描 多次插入 from student insert overwrite table student_insert1 select num insert overwrite table student_insert2 select name; \"]},\"289\":{\"h\":\"2.3 Dynamic Partition Inserts 动态分区插入\",\"t\":[\"还有一个案例如下：\",\"!!!Load加载数据基本操作 !!!\",\"-----------案例：动态分区插入----------- -- 1、首先设置动态分区模式为非严格模式 默认已经开启了动态分区功能 set hive.exec.dynamic.partition = true; set hive.exec.dynamic.partition.mode = nonstrict; -- 2、当前库下已有一张表student select * from student; -- 3、创建分区表 以sdept作为分区字段 create table student_partition(Sno int,Sname string,Sex string,Sage int) partitioned by(Sdept string); -- 4、执行动态分区插入操作 insert into table student_partition partition(Sdept) select num,name,sex,age,dept from student; -- 其中，num,name,sex,age作为表的字段内容插入表中 -- dept作为分区字段值 \"]},\"290\":{\"h\":\"2.4 Insert Directory导出数据\",\"t\":[\"数据导出操作使用的是OVERWRITE操作，谨慎使用\",\"-- 标准语法: INSERT OVERWRITE [LOCAL] DIRECTORY directory1 [ROW FORMAT row_format] [STORED AS file_format] (Note: Only available starting with Hive 0.11.0) SELECT ... FROM ... -- Hive extension (multiple inserts): FROM from_statement INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1 [INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ... -- row_format : DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char] [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] \",\"目录可以是完整的URI。如果未指定scheme，则Hive将使用hadoop配置变量fs.default.name来决定导出位置；\",\"如果使用LOCAL关键字，则Hive会将数据写入本地文件系统上的目录；\",\"写入文件系统的数据被序列化为文本，列之间用\\\\001隔开，行之间用换行符隔开。如果列都不是原始数据类型，那么这些列将序列化为JSON格式。也可以在导出的时候指定分隔符换行符和文件格式。\",\"-- 1、导出查询结果到HDFS指定目录下 insert overwrite directory '/tmp/hive_export/e1' select num,name,age from student limit 2; -- 2、导出时指定分隔符和文件存储格式 insert overwrite directory '/tmp/hive_export/e2' row format delimited fields terminated by ',' stored as orc select * from student; -- 3、导出数据到本地文件系统指定目录下 insert overwrite local directory '/root/hive_export/e1' select * from student; \"]},\"291\":{\"h\":\"3. Hive Transaction 事务表\",\"t\":[\"Hive事务表的部分知识见下面链接：\",\"!!!事务表基本操作 !!!\"]},\"292\":{\"h\":\"3.1 实现原理\",\"t\":[\"Hive的文件是存储在HDFS上的，而HDFS上又不支持对文件的任意修改，只能是采取另外的手段来完成\",\"用HDFS文件作为原始数据（基础数据），用delta保存事务操作的记录增量数据\",\"正在执行中的事务，是以一个staging开头的文件夹维护的，执行结束就是delta文件夹。每次执行一次事务操作都会有这样的一个delta增量文件夹\",\"当访问Hive数据时，根据HDFS原始文件和delta增量文件做合并，查询最新的数据\",\"其中：\",\"INSERT语句会直接创建delta目录\",\"DELETE目录的前缀是delete_delta\",\"UPDATE语句采用了split-update特性，即先删除、后插入；\",\"下图中，红框标出的就是一次update操作\"]},\"293\":{\"h\":\"3.1.1 delta文件详解\",\"t\":[\"delta_minWID_maxWID_stmtID，即delta前缀、写事务的ID范围、以及语句ID；删除时前缀是delete_delta，里面包含了要删除的文件\",\"Hive会为写事务（INSERT、DELETE等）创建一个写事务ID（Write ID），该ID在表范围内唯一\",\"语句ID（Statement ID）则是当一个事务中有多条写入语句时使用的，用作唯一标识。\",\"每个事务的delta文件夹下，都有两个文件：\",\"_orc_acid_version的内容是2,即当前ACID版本号是2。和版本1的主要区别是UPDATE语句采用了split-update特性，即先删除、后插入。这个文件不是ORC文件，可以下载下来直接查看。\",\"bucket_00000文件则是写入的数据内容。如果事务表没有分区和分桶，就只有一个这样的文件。文件都以ORC格式存储，底层二级制，需要使用ORC TOOLS查看，详见附件资料。\",\"对于bucket_00000文件：\",\"operation：0 表示插入，1 表示更新，2 表示删除。由于使用了split-update，1是不会出现的，所以delta文件中的operation是0 ， delete_delta 文件中的operation是2\",\"originalTransaction、currentTransaction：该条记录的原始写事务ID，当前的写事务ID。\",\"rowId：一个自增的唯一ID，在写事务和分桶的组合中唯一。\",\"row：具体数据。对于DELETE语句，则为null，对于INSERT就是插入的数据，对于UPDATE就是更新后的数据。\"]},\"294\":{\"h\":\"3.1.2 合并器\",\"t\":[\"合并器Compactor是一套在Hive Metastore内运行，支持ACID系统的后台进程。所有合并都是在后台完成的，不会阻止数据的并发读、写。合并后，系统将等待所有旧文件的读操作完成后，删除旧文件\",\"合并操作分为两种，minor compaction（小合并）、major compaction（大合并）：\",\"小合并会将一组delta增量文件重写为单个增量文件，默认触发条件为10个delta文件\",\"大合并将一个或多个增量文件和基础文件重写为新的基础文件，默认触发条件为delta文件相应于基础文件占比，10%\"]},\"295\":{\"h\":\"3.2 Hive 事务表使用设置与局限性\"},\"296\":{\"h\":\"3.2.1 局限性\",\"t\":[\"好像不用分桶表也可以？\",\"尚不支持BEGIN，COMMIT和ROLLBACK，所有语言操作都是自动提交的；\",\"表文件存储格式仅支持ORC（STORED AS ORC）；\",\"需要配置参数开启事务使用；\",\"外部表无法创建为事务表，因为Hive只能控制元数据，无法管理数据；\",\"表属性参数transactional必须设置为true；\",\"必须将Hive事务管理器设置为org.apache.hadoop.hive.ql.lockmgr.DbTxnManager才能使用ACID表；\",\"事务表不支持LOAD DATA ...语句。\"]},\"297\":{\"h\":\"3.2.2 参数设置\",\"t\":[\"-- Client端 set hive.support.concurrency = true; --Hive是否支持并发 set hive.enforce.bucketing = true; --从Hive2.0开始不再需要 是否开启分桶功能 set hive.exec.dynamic.partition.mode = nonstrict; --动态分区模式 非严格 set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; -- Server端 set hive.compactor.initiator.on = true; --是否在Metastore实例上运行启动压缩合并 set hive.compactor.worker.threads = 1; --在此metastore实例上运行多少个压缩程序工作线程。 \"]},\"298\":{\"h\":\"3.3 使用事务表\",\"t\":[\"-- 1、开启参数 set hive.support.concurrency = true; --Hive是否支持并发 set hive.enforce.bucketing = true; --从Hive2.0开始不再需要 是否开启分桶功能 set hive.exec.dynamic.partition.mode = nonstrict; --动态分区模式 非严格 set hive.txn.manager = org.apache.hadoop.hive.ql.lockmgr.DbTxnManager; -- set hive.compactor.initiator.on = true; --是否在Metastore实例上运行启动压缩合并 set hive.compactor.worker.threads = 1; --在此metastore实例上运行多少个压缩程序工作线程。 -- 2、创建Hive事务表 create table trans_student( id int, name String, age int )stored as orc TBLPROPERTIES('transactional'='true'); -- 3、针对事务表进行insert update delete操作 insert into trans_student (id, name, age) values (1,\\\"vingkin\\\",18); update trans_student set age = 20 where id = 1; delete from trans_student where id =1; \"]},\"299\":{\"h\":\"4. Hive SQL-DML-Update、Delete\",\"t\":[\"其实这边就是事务表的相关操作没什么好说的\"]},\"300\":{\"h\":\"5. Hive SQL-DQL-Select 查询数据\",\"t\":[\"--------- select语法树 ------------ [WITH CommonTableExpression (, CommonTableExpression)*] SELECT [ALL | DISTINCT] select_expr, select_expr, ... FROM table_reference [WHERE where_condition] [GROUP BY col_list] [ORDER BY col_list] [CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list] ] [LIMIT [offset,] rows]; \"]},\"301\":{\"h\":\"5.1 Hive SQL select查询基础语法\"},\"302\":{\"h\":\"5.1.1 select expr\",\"t\":[\"-- 查询所有字段或者指定字段 select * from t_usa_covid19_p; select county, cases, deaths from t_usa_covid19_p; -- 查询匹配正则表达式的所有字段 SET hive.support.quoted.identifiers = none; -- 反引号不在解释为其他含义，被解释为正则表达式 select `^c.*` from t_usa_covid19_p; -- 查询当前数据库 select current_database(); -- 省去from关键字 -- 查询使用函数 select count(county) from t_usa_covid19_p; \"]},\"303\":{\"h\":\"5.1.2 ALL 、DISTINCT\",\"t\":[\"默认不写为ALL，DISTINCT删除重复的行，当有多个字段时，多个字段看成一个整体。\",\"-- 返回所有匹配的行 select state from t_usa_covid19_p; -- 相当于 select all state from t_usa_covid19_p; -- 返回所有匹配的行 去除重复的结果 select distinct state from t_usa_covid19_p; -- 多个字段distinct整体去重 select county,state from t_usa_covid19_p; select distinct county,state from t_usa_covid19_p; select distinct sex from student; \"]},\"304\":{\"h\":\"5.1.3 WHERE\",\"t\":[\"WHERE后面是一个布尔表达式，用来过滤查询。WHERE后面可以跟着Hive支持的任何表达式和运算符，但是不能跟着聚合函数，比如说这个count()用来统计查询计数，但是此时的查询结果还不能确定，具有歧义。\"]},\"305\":{\"h\":\"5.1.4 分区查询\",\"t\":[\"针对的是分区表\",\"对分区表进行查询时，会检查WHERE子句或JOIN中的ON子句中是否有分区字段，如果有，就会仅访问符合条件的分区，裁剪掉没有必要访问的分区。\"]},\"306\":{\"h\":\"5.1.5 GROUP BY\",\"t\":[\"GROUP BY语句用于结合聚合函数，根据一个或多个列对结果集进行分组\",\"上面引用的意思就是出现在GROUP BY中select expr中的字段，要么是GROUP BY分组的字段，要么是被聚合函数引用的字段。\",\"出现上面加粗的限制原因，主要是为了避免一个字段产生多个值的歧义\",\"分组字段出现select_expr中，一定没有歧义，因为就是基于该字段分组的，同一组中必相同\",\"被聚合函数应用的字段，也没歧义，因为聚合函数的本质就是多进一出，最终返回一个结果\"]},\"307\":{\"h\":\"5.1.6 HAVING\",\"t\":[\"出现HAVING的原因是WHERE关键字无法与聚合函数一起使用\",\"-- 统计死亡病例数大于10000的州 -- where语句中不能使用聚合函数 语法报错 select state,sum(deaths) from t_usa_covid19_p where count_date = \\\"2021-01-28\\\" and sum(deaths) >10000 group by state; -- 先where分组前过滤（此处是分区裁剪），再进行group by分组， 分组后每个分组结果集确定 再使用having过滤 select state,sum(deaths) from t_usa_covid19_p where count_date = \\\"2021-01-28\\\" group by state having sum(deaths) > 10000; -- 这样写更好 即在group by的时候聚合函数已经作用得出结果 having直接引用结果过滤 不需要再单独计算一次了 select state,sum(deaths) as cnts from t_usa_covid19_p where count_date = \\\"2021-01-28\\\" group by state having cnts> 10000; \"]},\"308\":{\"h\":\"5.1.7 HAVING和WHERE的区别\",\"t\":[\"having是在分组后对数据进行过滤\",\"where是在分组前对数据进行过滤\",\"having后面可以使用聚合函数\",\"where后面不可以使用聚合函数\"]},\"309\":{\"h\":\"5.1.8 LIMIT\",\"t\":[\"显示SELECT返回的行数\",\"一个参数n：返回结果集前n条limit 5\",\"两个参数m,n：第一个参数m表示相对第一行的偏移量，第二个参数n表示返回的行数 limit 4, 5\",\"注意：只有一个参数时相当于limit 0, n\"]},\"310\":{\"h\":\"5.1.9 执行顺序\",\"t\":[\"在查询过程中执行顺序：from > where > group（含聚合）> having >order > select\",\"select state, sum(deaths) as cnts from t_usa_covid19_p where count_data = \\\"2021-01-28\\\" group by state having cnts > 10000 order by cnts desc; \"]},\"311\":{\"h\":\"5.2 Hive SQL select查询高阶语法\"},\"312\":{\"h\":\"5.2.1 ORDER BY\",\"t\":[\"和RDMBS中的ORDER BY差不多，用于全局排序。\",\"默认ASC（升序），可以手动指定为DESC（降序）\"]},\"313\":{\"h\":\"5.2.2 CLUSTER BY\",\"t\":[\"根据指定字段分组，每组内再根据该字段进行正序排序**（只能正序）**。注意：分组的个数取决于ReduceTask的个数，可以通过set mapreduce.job.reduces=n来手动设定ReduceTask的个数。\",\"分组规则hash散列（分桶表规则一样）：Hash_Func(col_name) % reducetask个数\",\"分为几组取决于reducetask的个数\",\"比如下面的案例就是先手动设定ReduceTask的个数为2，然后根据num分组，然后进行正序排序。由于只有两个组，所以根据学号，偶数分为一组，奇数分为一组。\",\"set mapreduce.job.reduces = 2; select * from student cluster by num; \",\"通过上面的案例可以发现CLUSTER BY的弊端就是只能通过一个字段进行分组且排序，而且只能进行正序排序。\",\"DISTRIBUTE BY 和 SORT BY就相当于把CLUSTER BY的功能一分为二：\",\"DISTRIBUTE BY：用于分组\",\"SORT BY：用于排序\",\"分组和排序使用的字段可以不同，而且排序可以指定倒序排序\",\"案例：根据sex进行分组，并且每个分组内再按照age进行倒序排序\",\"select * from student distribute by sex sort by age desc; \"]},\"314\":{\"h\":\"5.2.3 CLUSTER、DISTRIBUTE、SORT、ORDER BY对比\",\"t\":[\"order by全局排序，因此只有一个reducer，结果输出在一个文件中，当输入规模大时，需要较长的计算时间。\",\"distribute by根据指定字段将数据分组，算法是hash散列。sort by是在分组之后，每个组内局部排序\",\"cluster by既有分组，又有排序，但是两个字段只能是同一个字段\"]},\"315\":{\"h\":\"5.2.4 UNION联合查询\",\"t\":[\"用于将多个SELECT语句的结果合并成一个结果集，注意每个select语句返回的列的数量和名称必须相同。\",\"目前版本的HIVE使用UNION时，默认使用DISTINCT删除重复行，可以使用ALL来指定不删除\",\"-- 语法规则 select_statement UNION [ALL | DISTINCT] select_statement UNION [ALL | DISTINCT] select_statement ...; \",\"如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT应用于单个SELECT，需要将子句放在括住SELECT的括号内\",\"SELECT num,name FROM (select num,name from student_local LIMIT 2) subq1 UNION SELECT num,name FROM (select num,name from student_hdfs LIMIT 3) subq2; \",\"如果要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT子句应用于整个UNION结果，需要将ORDER BY，SORT BY，CLUSTER BY，DISTRIBUTE BY或LIMIT放在最后一个之后。\",\"select num,name from student_local UNION select num,name from student_hdfs order by num desc; \"]},\"316\":{\"h\":\"5.2.5 FORM 子句中的子查询\",\"t\":[\"必须要给子查询一个名称，因为FROM子句中的每个表都必须有一个名称。\",\"子查询返回结果中的列必须具有唯一的名称。\",\"子查询返回结果中的列在外部查询中可用，就像真实表的列一样。\",\"子查询也可以是带有UNION的查询表达式。\",\"可以理解为把FROM语句中查询到的看成一张表，对这张表进行查询\",\"-- 子查询 SELECT num FROM ( select num,name from student_local ) tmp; -- 包含UNION ALL的子查询的示例 SELECT t3.name FROM ( select num,name from student_local UNION distinct select num,name from student_hdfs ) t3; \"]},\"317\":{\"h\":\"5.2.6 WHERE 子句中的子查询\",\"t\":[\"**不相关子查询：**该子查询不引用父查询中的列，可以将查询结果视为IN和NOT IN语句的常量\",\"**相关子查询：**子查询引用父查询中的列\",\"不相关子查询，相当于IN、NOT IN,子查询只能选择一个列。\",\"执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。\",\"执行外部查询，并显示整个结果。\",\"SELECT * FROM student_hdfs WHERE student_hdfs.num IN (select num from student_local limit 2); \",\"相关子查询，指EXISTS和NOT EXISTS子查询\",\"子查询的WHERE子句中支持对父查询的引用\",\"SELECT A FROM T1 WHERE EXISTS (SELECT B FROM T2 WHERE T1.X = T2.Y); \"]},\"318\":{\"h\":\"5.2.7 Common Table Expressions (CTE)\",\"t\":[\"公用表表达式（CTE）是一个临时结果集：该结果集是从WITH子句中指定的简单查询派生而来的，紧接在SELECT或INSERT关键字之前。\",\"CTE仅在单个语句的执行范围内定义。\",\"CTE可以在 SELECT，INSERT， CREATE TABLE AS SELECT或CREATE VIEW AS SELECT语句中使用。\",\"CTE的使用\",\"----------------- Common Table Expressions（CTE）----------------------------------- -- select语句中的CTE with q1 as (select num, name, age from student where num = 95002) select * from q1; -- from风格 with q1 as (select num, name, age from student where num = 95002) from q1 select *; -- chaining CTEs 链式 with q1 as (select * from student where num = 95002), q2 as (select num, name, age from q1) select * from (select num from q2) a; -- union with q1 as (select * from student where num = 95002), q2 as (select * from student where num = 95004) select * from q1 union all select * from q2; -- 视图，CTAS和插入语句中的CTE -- insert create table s1 like student; with q1 as (select * from student where num = 95002) from q1 insert overwrite table s1 select *; -- ctas create table s2 as with q1 as (select * from student where num = 95002) select * from q1; -- view create view v1 as with q1 as (select * from student where num = 95002) select * from q1; \"]},\"319\":{\"h\":\"6. Hive SQL Join连接操作\"},\"320\":{\"h\":\"6.1 inner join 内连接\",\"t\":[\"只有进行连接的两个表中都存在与连接条件相匹配的数据才会被留下来\",\"-- 1、inner join select e.id,e.name,e_a.city,e_a.street from employee e inner join employee_address e_a on e.id =e_a.id; -- 等价于 inner join=join select e.id,e.name,e_a.city,e_a.street from employee e join employee_address e_a on e.id =e_a.id; -- 等价于 隐式连接表示法 select e.id,e.name,e_a.city,e_a.street from employee e , employee_address e_a where e.id =e_a.id; \"]},\"321\":{\"h\":\"6.2 left join 左连接\",\"t\":[\"又称为左外连接，join时以左表的全部数据为准，右边与之关联；左表数据全部返回，右表关联上的显示返回，关联不上的显示null返回\",\"-- 2、left join select e.id,e.name,e_conn.phno,e_conn.email from employee e left join employee_connection e_conn on e.id =e_conn.id; -- 等价于 left outer join select e.id,e.name,e_conn.phno,e_conn.email from employee e left outer join employee_connection e_conn on e.id =e_conn.id; \"]},\"322\":{\"h\":\"6.3 right join 右连接\",\"t\":[\"又称为右外连接，join时以右表的全部数据为准，左边与之关联；右表数据全部返回，左表关联上的显示返回，关联不上的显示null返回\",\"-- 3、right join select e.id,e.name,e_conn.phno,e_conn.email from employee e right join employee_connection e_conn on e.id =e_conn.id; -- 等价于 right outer join select e.id,e.name,e_conn.phno,e_conn.email from employee e right outer join employee_connection e_conn on e.id =e_conn.id; \"]},\"323\":{\"h\":\"6.4 full outer join 全外连接\",\"t\":[\"又称为外连接，等价于对这两个数据集合分别进行左外连接和右外连接，然后再使用消去重复行的操作将上述两个结果集合并为一个结果集\",\"-- 4、full outer join select e.id,e.name,e_a.city,e_a.street from employee e full outer join employee_address e_a on e.id =e_a.id; -- 等价于 select e.id,e.name,e_a.city,e_a.street from employee e full join employee_address e_a on e.id =e_a.id; \"]},\"324\":{\"h\":\"6.5 left semi join 左半开连接\",\"t\":[\"左半开连接（LEFT SEMI JOIN）会返回左边表的记录，前提是其记录对于右边的表满足ON语句中的判定条件。\",\"从效果上来看有点像inner join之后只返回左表的结果。\",\"-- 5、left semi join select * from employee e left semi join employee_address e_addr on e.id =e_addr.id; -- 相当于 inner join,但是只返回左表全部数据， 只不过效率高一些 select e.* from employee e inner join employee_address e_addr on e.id =e_addr.id; \"]},\"325\":{\"h\":\"6.6 cross join 交叉连接\",\"t\":[\"交叉连接cross join，将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积。对于大表来说，cross join慎用。\",\"对于下面的代码：一般不建议使用方法A和B，因为如果有WHERE子句的话，往往会先生成两个表行数乘积的行的数据表然后才根据WHERE条件从中选择。因此，如果两个需要求交集的表太大，将会非常非常慢，不建议使用。\",\"-- 下列A、B、C 执行结果相同，但是效率不一样： -- A: select a.*,b.* from employee a,employee_address b where a.id=b.id; -- B: select * from employee a cross join employee_address b on a.id=b.id; select * from employee a cross join employee_address b where a.id=b.id; -- C: select * from employee a inner join employee_address b on a.id=b.id; \"]},\"326\":{\"h\":\"6.7 Hive Join使用注意事项\",\"t\":[\"允许使用复杂的联接表达式,支持非等值连接\",\"同一查询中可以连接2个以上的表\",\"SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) \",\"如果每个表在联接子句中使用相同的列，则Hive将多个表上的联接转换为单个MR作业\",\"SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1) -- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行 SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) -- 会转换为两个MR作业，因为在第一个连接条件中使用了b中的key1列，而在第二个连接条件中使用了b中的key2列。 -- 第一个map / reduce作业将a与b联接在一起，然后将结果与c联接到第二个map / reduce作业中。 \",\"join时的最后一个表会通过reducer流式传输，并在其中缓冲之前的其他表，因此，将大表放置在最后有助于减少reducer阶段缓存数据所需要的内存，当然也可以手动指定需要流式传输的表。\",\"SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1) -- 由于联接中仅涉及b的key1列，因此被转换为1个MR作业来执行，并且表a和b的键的特定值的值被缓冲在reducer的内存中。然后，对于从c中检索的每一行，将使用缓冲的行来计算联接。 SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) -- 计算涉及两个MR作业。其中的第一个将a与b连接起来，并缓冲a的值，同时在reducer中流式传输b的值。 -- 在第二个MR作业中，将缓冲第一个连接的结果，同时将c的值通过reducer流式传输。 \",\"在join的时候，可以通过语法STREAMTABLE提示指定要流式传输的表。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。\",\"SELECT /*+ STREAMTABLE(a) */ a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1) -- a,b,c三个表都在一个MR作业中联接，并且表b和c的键的特定值的值被缓冲在reducer的内存中。 -- 然后，对于从a中检索到的每一行，将使用缓冲的行来计算联接。如果省略STREAMTABLE提示，则Hive将流式传输最右边的表。 \",\"join在WHERE条件之前进行。\",\"如果除一个要连接的表之外的所有表都很小，则可以将其作为仅map作业执行（mapjoin）\",\"SELECT /*+ MAPJOIN(b) */ a.key, a.value FROM a JOIN b ON a.key = b.key -- 不需要reducer。对于A的每个Mapper，B都会被完全读取。限制是不能执行FULL / RIGHT OUTER JOIN b。 \"]},\"327\":{\"h\":\"Hive 函数、运算符使用\"},\"328\":{\"h\":\"1. Hive内置运算符\",\"t\":[\"关系运算符、算术运算符、逻辑运算符\",\"-- 显示所有的函数和运算符 show functions; -- 查看运算符或者函数的使用说明 describe function +; -- 使用extended 可以查看更加详细的使用说明 describe function extended count; \"]},\"329\":{\"h\":\"1.1 测试环境准备\",\"t\":[\"创建空表dual，用于测试运算符\",\"-- 1、创建表dual create table dual ( id string ); -- 2、加载一个文件dual.txt到dual表中 -- dual.txt只有一行内容：内容为一个空格 load data local inpath '/root/hivedata/dual.txt' into table dual; -- 3、在select查询语句中使用dual表完成运算符、函数功能测试 select 1 + 1 from dual; \"]},\"330\":{\"h\":\"1.2 关系运算符\",\"t\":[\"关系运算符返回的都是boolean结果\",\"---------------- Hive中关系运算符 ------------------------- -- is null空值判断 select 1 from dual where 'vingkin' is null; -- is not null 非空值判断 select 1 from dual where 'vingkin' is not null; -- like比较： _表示任意单个字符 %表示任意数量字符 -- 否定比较： NOT A like B select 1 from dual where 'vingkin' like 'it_'; select 1 from dual where 'vingkin' like 'it%'; select 1 from dual where 'vingkin' not like 'hadoo_'; select 1 from dual where not 'vingkin' like 'hadoo_'; -- rlike：确定字符串是否匹配正则表达式，是REGEXP_LIKE()的同义词。 select 1 from dual where 'vingkin' rlike '^i.*t$'; select 1 from dual where '123456' rlike '^\\\\\\\\d+$'; -- 判断是否全为数字 select 1 from dual where '123456aa' rlike '^\\\\\\\\d+$'; -- regexp：功能与rlike相同 用于判断字符串是否匹配正则表达式 select 1 from dual where 'vingkin' regexp '^i.*t$'; \"]},\"331\":{\"h\":\"1.3 算术运算符\",\"t\":[\"算术运算符操作数必须是数值类型。 分为一元运算符和二元运算符：一元运算符,只有一个操作数; 二元运算符有两个操作数,运算符在两个操作数之间。\",\"-------------------Hive中算术运算符--------------------------------- -- 取整操作: div 给出将A除以B所得的整数部分。例如17 div 3得出5。 select 17 div 3; -- 取余操作: % 也叫做取模mod A除以B所得的余数部分 select 17 % 3; -- 位与操作: & A和B按位进行与操作的结果。 与表示两个都为1则结果为1 select 4 & 8 from dual; select 6 & 4 from dual; -- 位或操作: | A和B按位进行或操作的结果 或表示有一个为1则结果为1 select 4 | 8 from dual; select 6 | 4 from dual; -- 位异或操作: ^ A和B按位进行异或操作的结果 异或表示两者的值不同,则结果为1 select 4 ^ 8 from dual; select 6 ^ 4 from dual; \"]},\"332\":{\"h\":\"1.4 逻辑运算符\",\"t\":[\"逻辑是否存在: [NOT] EXISTS (subquery)\",\"-- 3、Hive逻辑运算符 -- 与操作: A AND B 如果A和B均为TRUE，则为TRUE，否则为FALSE。如果A或B为NULL，则为NULL。 select 1 from dual where 3 > 1 and 2 > 1; -- 或操作: A OR B 如果A或B或两者均为TRUE，则为TRUE，否则为FALSE。 select 1 from dual where 3 > 1 or 2 != 2; -- 非操作: NOT A 、!A 如果A为FALSE，则为TRUE；如果A为NULL，则为NULL。否则为FALSE。 select 1 from dual where not 2 > 1; select 1 from dual where ! 1 = 2; -- 在:A IN (val1, val2, ...) 如果A等于任何值，则为TRUE。 select 1 from dual where 11 in (11, 22, 33); -- 不在:A NOT IN (val1, val2, ...) 如果A不等于任何值，则为TRUE select 1 from dual where 11 not in (22, 33, 44); -- 逻辑是否存在: [NOT] EXISTS (subquery) -- 将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE 或 FALSE）来决定主查询的数据结果是否得以保留。 select A.* from A where exists (select B.id from B where A.id = B.id); \"]},\"333\":{\"h\":\"2. Hive 函数入门\"},\"334\":{\"h\":\"2.1 Hive函数概述及分类标准\",\"t\":[\"Hive函数可以分成两大类：\",\"内置函数（Built-in Functions）\",\"用户定义函数（UDF User-Defined Functions）\",\"其中用户定义可以分成三类：\",\"UDF（User-Defined-Function）：普通函数，一进一出\",\"UDAF（User-Defined Aggregation Function）：聚合函数，多进一出\",\"UDTF（User-Defined Table-Generating Function）：表生成函数，一进多出\",\"但是由于UDF分类标准扩大化，UDF分类标准可以扩大到Hive的所有函数中：包括内置函数和用户自定义函数。所以现在没有内置函数和用户定义函数之分，所有函数可以分成UDF，UDAF，UDTF三类。\"]},\"335\":{\"h\":\"2.2 Hive内置函数\"},\"336\":{\"h\":\"2.2.1 字符串函数\",\"t\":[\"函数名\",\"函数作用\",\"length\",\"字符串长度函数\",\"reverse\",\"字符串反转函数\",\"concat\",\"字符串连接函数\",\"concat_ws\",\"带分隔符字符串连接函数\",\"substr，substring\",\"字符串截取函数\",\"upper，ucase\",\"字符串转大写函数\",\"lower，lcase\",\"字符串转小写函数\",\"trim\",\"去空格函数\",\"ltrim\",\"左边去空格函数\",\"rtrim\",\"右边去空格函数\",\"regexp_replace\",\"正则表达式替换函数\",\"regexp_extract\",\"正则表达式解析函数\",\"parse_url\",\"URL解析函数\",\"get_json_object\",\"json解析函数\",\"space\",\"空格字符串函数\",\"repeat\",\"重复字符串函数\",\"ascii\",\"首字符ascii函数\",\"lpad\",\"左补足函数\",\"rpad\",\"右补足函数\",\"split\",\"分隔字符串函数\",\"find_in_set\",\"集合查找函数\",\"------------ String Functions 字符串函数 ------------ select concat(\\\"angela\\\", \\\"baby\\\"); -- 带分隔符字符串连接函数：concat_ws(separator, [string | array(string)]+) select concat_ws('.', 'www', array('vingkin', 'cn')); -- 字符串截取函数：substr(str, pos[, len]) 或者 substring(str, pos[, len]) select substr(\\\"angelababy\\\", -2); -- pos是从1开始的索引，如果为负数则倒着数 select substr(\\\"angelababy\\\", 2, 2); -- 正则表达式替换函数：regexp_replace(str, regexp, rep) select regexp_replace('100-200', '(\\\\\\\\d+)', 'num'); -- 正则表达式解析函数：regexp_extract(str, regexp[, idx]) 提取正则匹配到的指定组内容 select regexp_extract('100-200', '(\\\\\\\\d+)-(\\\\\\\\d+)', 2); -- URL解析函数：parse_url 注意要想一次解析出多个 可以使用parse_url_tuple这个UDTF函数 select parse_url('http://www.vingkin.cn/path/p1.php?query=1', 'HOST'); -- 分割字符串函数: split(str, regex) select split('apache hive', '\\\\\\\\s+'); -- \\\\\\\\s+表示用来匹配空白符，一个或多个都行 -- json解析函数：get_json_object(json_txt, path) -- $表示json对象 select get_json_object( '[{\\\"website\\\":\\\"www.vingkin.cn\\\",\\\"name\\\":\\\"allenwoon\\\"}, {\\\"website\\\":\\\"cloud.vingkin.com\\\",\\\"name\\\":\\\"carbondata 中文文档\\\"}]', '$.[1].website'); -- 字符串长度函数：length(str | binary) select length(\\\"angelababy\\\"); -- 字符串反转函数：reverse select reverse(\\\"angelababy\\\"); -- 字符串连接函数：concat(str1, str2, ... strN) -- 字符串转大写函数：upper,ucase select upper(\\\"angelababy\\\"); select ucase(\\\"angelababy\\\"); -- 字符串转小写函数：lower,lcase select lower(\\\"ANGELABABY\\\"); select lcase(\\\"ANGELABABY\\\"); -- 去空格函数：trim 去除左右两边的空格 select trim(\\\" angelababy \\\"); -- 左边去空格函数：ltrim select ltrim(\\\" angelababy \\\"); -- 右边去空格函数：rtrim select rtrim(\\\" angelababy \\\"); -- 空格字符串函数：space(n) 返回指定个数空格 select space(4); -- 重复字符串函数：repeat(str, n) 重复str字符串n次 select repeat(\\\"angela\\\", 2); -- 首字符ascii函数：ascii select ascii(\\\"angela\\\");-- a对应ASCII 97 -- 左补足函数：lpad select lpad('hi', 5, '??'); -- ???hi select lpad('hi', 1, '??'); -- h -- 右补足函数：rpad select rpad('hi', 5, '??'); --集合查找函数: find_in_set(str,str_array) select find_in_set('a', 'abc,b,ab,c,def'); -- 0，表示没找到 \"]},\"337\":{\"h\":\"2.2.2 日期函数\",\"t\":[\"函数名\",\"函数作用\",\"获取当前日期\",\"current_date\",\"获取当前时间戳\",\"current_timestamp\",\"UNIX时间戳转日期函数\",\"from_unixtime\",\"获取当前UNIX时间戳函数\",\"unix_timestamp\",\"日期转UNIX时间戳函数\",\"unix_timestamp\",\"抽取日期函数\",\"to_date\",\"日期转年函数\",\"year\",\"...\",\"month\",\"...\",\"day\",\"...\",\"hour\",\"...\",\"minute\",\"...\",\"second\",\"日期转周函数\",\"weekofyear\",\"日期比较函数\",\"datediff\",\"日期增加函数\",\"date_add\",\"日期减少函数\",\"date_sub\",\"----------- Date Functions 日期函数 ----------------- -- 获取当前日期: current_date select current_date(); -- 获取当前时间戳: current_timestamp -- 同一查询中对current_timestamp的所有调用均返回相同的值。 select current_timestamp(); -- 2021-09-06 01:18:22.871000000 -- 获取当前UNIX时间戳函数: unix_timestamp select unix_timestamp(); -- 1630916306 -- 日期转UNIX时间戳函数: unix_timestamp select unix_timestamp(\\\"2011-12-07 13:01:03\\\"); -- 指定格式日期转UNIX时间戳函数: unix_timestamp select unix_timestamp('20111207 13:01:03', 'yyyyMMdd HH:mm:ss'); -- UNIX时间戳转日期函数: from_unixtime select from_unixtime(1618238391); select from_unixtime(0, 'yyyy-MM-dd HH:mm:ss'); -- 日期比较函数: datediff 日期格式要求'yyyy-MM-dd HH:mm:ss' or 'yyyy-MM-dd' select datediff('2012-12-08', '2012-05-09'); -- 日期增加函数: date_add select date_add('2012-02-28', 10); -- 日期减少函数: date_sub select date_sub('2012-01-1', 10); -- 抽取日期函数: to_date select to_date('2009-07-30 04:17:52'); -- 日期转年函数: year select year('2009-07-30 04:17:52'); -- 日期转月函数: month select month('2009-07-30 04:17:52'); -- 日期转天函数: day select day('2009-07-30 04:17:52'); -- 日期转小时函数: hour select hour('2009-07-30 04:17:52'); -- 日期转分钟函数: minute select minute('2009-07-30 04:17:52'); -- 日期转秒函数: second select second('2009-07-30 04:17:52'); -- 日期转周函数: weekofyear 返回指定日期所示年份第几周 select weekofyear('2009-07-30 04:17:52'); \"]},\"338\":{\"h\":\"2.2.3 数学函数\",\"t\":[\"函数名\",\"函数功能\",\"round\",\"四舍五入\",\"round\",\"指定精度取整函数\",\"floor\",\"向下取整函数\",\"ceil\",\"向上取整函数\",\"rand\",\"取随机数函数\",\"bin\",\"二进制函数\",\"conv\",\"进制转换函数\",\"abs\",\"绝对值函数\",\"----Mathematical Functions 数学函数------------- -- 取整函数: round 返回double类型的整数值部分 （遵循四舍五入） select round(3.1415926); -- 指定精度取整函数: round(double a, int d) 返回指定精度d的double类型 select round(3.1415926, 4); -- 向下取整函数: floor select floor(3.1415926); select floor(-3.1415926); -- 向上取整函数: ceil select ceil(3.1415926); select ceil(-3.1415926); -- 取随机数函数: rand 每次执行都不一样 返回一个0到1范围内的随机数 select rand(); -- 指定种子取随机数函数: rand(int seed) 得到一个稳定的随机数序列 select rand(3); -- 二进制函数: bin(BIGINT a) select bin(18); -- 进制转换函数: conv(BIGINT num, int from_base, int to_base) select conv(17, 10, 16); -- 绝对值函数: abs select abs(-3.9); \"]},\"339\":{\"h\":\"2.2.4 集合函数\",\"t\":[\"函数名\",\"函数功能\",\"size()\",\"集合元素个数函数\",\"map_keys()\",\"取map集合keys函数\",\"map_values()\",\"取map集合values函数\",\"array_contains()\",\"判断数组是否包含指定元素\",\"sort_array()\",\"数组排序函数\",\"-------Collection Functions 集合函数-------------- -- 集合元素size函数: size(Map<K.V>) size(Array<T>) select size(`array`(11, 22, 33)); select size(`map`(\\\"id\\\", 10086, \\\"name\\\", \\\"zhangsan\\\", \\\"age\\\", 18)); select `array`(11, 22, 33) from dual; select `map`(\\\"id\\\", 10086, \\\"name\\\", \\\"zhangsan\\\", \\\"age\\\", 18) from dual; -- 取map集合keys函数: map_keys(Map<K.V>) select map_keys(`map`(\\\"id\\\", 10086, \\\"name\\\", \\\"zhangsan\\\", \\\"age\\\", 18)); -- 取map集合values函数: map_values(Map<K.V>) select map_values(`map`(\\\"id\\\", 10086, \\\"name\\\", \\\"zhangsan\\\", \\\"age\\\", 18)); -- 判断数组是否包含指定元素: array_contains(Array<T>, value) select array_contains(`array`(11, 22, 33), 11); select array_contains(`array`(11, 22, 33), 66); -- 数组排序函数:sort_array(Array<T>) select sort_array(`array`(12, 2, 32)); \"]},\"340\":{\"h\":\"2.2.5 条件函数\",\"t\":[\"函数名\",\"函数功能\",\"if()\",\"if条件判断\",\"isnull()\",\"空判断函数\",\"isnotnull()\",\"非空判断函数\",\"nvl()\",\"空值转换函数\",\"coalesce\",\"非空查找函数\",\"case a when b then c [when * then * ... else *] end\",\"条件转换函数\",\"nullif(a, b)\",\"a=b返回NULL，否则返回a\",\"assert_true(condition)\",\"condition为false报错，否则返回NULL\",\"使用之前课程创建好的student表数据\",\"create table student( num int, name string, sex string, age int, dept string ) row format delimited fields terminated by ','; load data local inpath '/root/hivedata/students.txt' into table student; \",\"-- if条件判断: if(boolean testCondition, T valueTrue, T valueFalseOrNull) select if(1 = 2, 100, 200); -- 200 select if(sex = '男', 'M', 'W') from student limit 3; -- 空判断函数: isnull( a ) select isnull(\\\"allen\\\"); select isnull(null); -- 非空判断函数: isnotnull ( a ) select isnotnull(\\\"allen\\\"); select isnotnull(null); -- 空值转换函数: nvl(T value, T default_value) select nvl(\\\"allen\\\", \\\"vingkin\\\"); select nvl(null, \\\"vingkin\\\"); -- 非空查找函数: COALESCE(T v1, T v2, ...) -- 返回参数中的第一个非空值；如果所有值都为NULL，那么返回NULL select COALESCE(null, 11, 22, 33); select COALESCE(null, null, null, 33); select COALESCE(null, null, null); -- 条件转换函数: CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END select case 100 when 50 then 'tom' when 100 then 'mary' else 'tim' end; select case sex when '男' then 'male' else 'female' end from student limit 3; -- nullif( a, b ): -- 如果a = b，则返回NULL，否则返回第一个 select nullif(11, 11); select nullif(11, 12); -- assert_true(condition) -- 如果'condition'不为真，则引发异常，否则返回null SELECT assert_true(11 >= 0); SELECT assert_true(-1 >= 0); \"]},\"341\":{\"h\":\"2.2.6 类型转换函数\",\"t\":[\"主要用于显式数据类型转换\",\"----Type Conversion Functions 类型转换函数----------------- -- 任意数据类型之间转换:cast select cast(12.14 as bigint); select cast(12.14 as string); select cast(\\\"hello\\\" as int); \"]},\"342\":{\"h\":\"2.2.7 数据脱敏函数\",\"t\":[\"----Data Masking Functions 数据脱敏函数------------ -- mask -- 将查询回的数据，大写字母转换为X，小写字母转换为x，数字转换为n。 select mask(\\\"abc123DEF\\\"); select mask(\\\"abc123DEF\\\", '-', '.', '^'); -- 自定义替换的字母 -- mask_first_n(string str[, int n] -- 对前n个进行脱敏替换 select mask_first_n(\\\"abc123DEF\\\", 4); -- mask_last_n(string str[, int n]) select mask_last_n(\\\"abc123DEF\\\", 4); -- mask_show_first_n(string str[, int n]) -- 除了前n个字符，其余进行掩码处理 select mask_show_first_n(\\\"abc123DEF\\\", 4); -- mask_show_last_n(string str[, int n]) select mask_show_last_n(\\\"abc123DEF\\\", 4); -- mask_hash(string|char|varchar str) -- 返回字符串的hash编码。 select mask_hash(\\\"abc123DEF\\\"); \"]},\"343\":{\"h\":\"2.2.8 其他杂项函数\",\"t\":[\"----- Misc. Functions 其他杂项函数--------------- -- 如果你要调用的java方法所在的jar包不是hive自带的 可以使用add jar添加进来 -- hive调用java方法: java_method(class, method[, arg1[, arg2..]]) select java_method(\\\"java.lang.Math\\\", \\\"max\\\", 11, 22); -- 反射函数: reflect(class, method[, arg1[, arg2..]]) select reflect(\\\"java.lang.Math\\\", \\\"max\\\", 11, 22); -- 取哈希值函数:hash select hash(\\\"allen\\\"); -- current_user()、logged_in_user()、current_database()、version() -- SHA-1加密: sha1(string/binary) select sha1(\\\"allen\\\"); -- SHA-2家族算法加密：sha2(string/binary, int) (SHA-224, SHA-256, SHA-384, SHA-512) select sha2(\\\"allen\\\", 224); select sha2(\\\"allen\\\", 512); -- crc32加密: select crc32(\\\"allen\\\"); -- MD5加密: md5(string/binary) select md5(\\\"allen\\\"); \"]},\"344\":{\"h\":\"2.3 案例：UDF实现手机号加密\",\"t\":[\"在企业中处理数据的时候，对于敏感数据往往需要进行脱敏处理。比如手机号。我们常见的处理方式是将手机号中间4位进行****处理。\",\"需求：\",\"能够对输入数据进行非空判断、手机号位数判断\",\"能够实现校验手机号格式，把满足规则的进行****处理\",\"对于不符合手机号规则的数据直接返回，不处理\",\"实现步骤：\",\"写一个java类，继承UDF，并重载evaluate方法，方法中实现函数的业务逻辑；\",\"重载意味着可以在一个java类中实现多个函数功能；\",\"程序打成jar包，上传HS2服务器本地或者HDFS;\",\"客户端命令行中添加jar包到Hive的classpath： hive>add JAR xxx.jar;\",\"注册成为临时函数（给UDF命名）：create temporary function encrypt_phonum as 'com.vingkin.hive.udf.PhoneNumberUDF';\",\"HQL中使用函数:select encrypt_phonum('13888888888')\",\"相关依赖：\",\"<dependencies> <dependency> <groupId>org.apache.hive</groupId> <artifactId>hive-exec</artifactId> <version>3.1.2</version> </dependency> <dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-common</artifactId> <version>3.1.4</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>2.2</version> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <filters> <filter> <artifact>*:*</artifact> <excludes> <exclude>META-INF/*.SF</exclude> <exclude>META-INF/*.DSA</exclude> <exclude>META-INF/*.RSA</exclude> </excludes> </filter> </filters> </configuration> </execution> </executions> </plugin> </plugins> </build> \",\"业务代码：PhoneNumberUDF.java\",\"public class PhoneNumberUDF extends UDF { public String evaluate(String phoNum) { String encryptPhoNum = null; if (StringUtils.isNotEmpty(phoNum) && phoNum.trim().length() == 11) { String regex = \\\"^(1[3-9]\\\\\\\\d{9}$)\\\"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(phoNum); if (m.matches()) { encryptPhoNum = phoNum.trim().replaceAll(\\\"(\\\\\\\\d{3})\\\\\\\\d{4}(\\\\\\\\d{4})\\\", \\\"$1****$2\\\"); } else { encryptPhoNum = phoNum; } } else { encryptPhoNum = phoNum; } return encryptPhoNum; } // public static void main(String[] args) { // System.out.println(new PhoneNumberUDF().evaluate(\\\"13888888888\\\")); // } } \"]},\"345\":{\"h\":\"3. Hive 函数高阶\"},\"346\":{\"h\":\"3.1 UDTF之explode函数\",\"t\":[\"explode接收map、array类型的数据作为输入，然后把输入数据中的每个元素拆开变成一行数据，一个元素一行。\",\"对于map每行有两列分别为key，value\"]},\"347\":{\"h\":\"3.1.1 示例\",\"t\":[\"select explode(`array`(11,22,33)) as item; select explode(`map`(\\\"id\\\",10086,\\\"name\\\",\\\"zhangsan\\\",\\\"age\\\",18)); \"]},\"348\":{\"h\":\"3.1.2 案例：NBA总冠军球队名单分析\",\"t\":[\"有一份数据The_NBA_Championship.txt，关于部分年份的NBA总冠军球队名单；第一个字段表示球队名称，第二个字段是获取总冠军的年份；字段之间以，分割；总冠军年份之间以|进行分割。\",\"建表加载数据：\",\"-- step1:建表 create table the_nba_championship( team_name string, champion_year array<string> ) row format delimited fields terminated by ',' collection items terminated by '|'; -- step2:加载数据文件到表中 load data local inpath '/root/hivedata/The_NBA_Championship.txt' into table the_nba_championship; \",\"错误的演示：\",\"select team_name,explode(champion_year) from the_nba_championship; \",\"explode函数属于UDTF表生成函数，explode执行返回的结果可以理解为一张虚拟的表，其数据来源于源表；\",\"在select中只查询源表数据没有问题，只查询explode生成的虚拟表数据也没问题，但是不能在只查询源表的时候，既想返回源表字段又想返回explode生成的虚拟表字段；通俗点讲，有两张表，不能只查询一张表但是又想返回分别属于两张表的字段；\",\"解决方法：\",\"从SQL层面上来说上述问题的解决方案是：对两张表进行join关联查询;\",\"Hive专门提供了语法lateral View侧视图，专门用于搭配explode这样的UDTF函数，以满足上述需要。\",\"select a.team_name,b.year from the_nba_championship a lateral view explode(champion_year) b as year order by b.year desc; \",\"image-20210906174525863\"]},\"349\":{\"h\":\"3.1.3 Hive Lateral View 侧视图\",\"t\":[\"Lateral View是一种特殊的语法，主要搭配UDTF类型函数一起使用，用于解决UDTF函数的一些查询限制的问题。\",\"一般只要使用UDTF，就会固定搭配lateral view使用。\",\"针对explode案例中NBA冠军球队年份排名案例，使用explode函数+lateral view侧视图\",\"-- 根据年份倒序排序 select a.team_name ,b.year from the_nba_championship a lateral view explode(champion_year) b as year order by b.year desc; \",\"-- 统计每个球队获取总冠军的次数 并且根据倒序排序 select a.team_name ,count(*) as nums from the_nba_championship a lateral view explode(champion_year) b as year group by a.team_name order by nums desc; \"]},\"350\":{\"h\":\"3.2 UDAF之聚合函数\"},\"351\":{\"h\":\"3.2.1 基础聚合\",\"t\":[\"student\",\"create table student ( num int, name string, sex string, age int, dept string ) row format delimited fields terminated by ','; -- 加载数据 load data local inpath '/root/hivedata/students.txt' into table student; \",\"-- 场景1：没有group by子句的聚合操作 -- count(*)：所有行进行统计，包括NULL行 -- count(1)：所有行进行统计，包括NULL行 -- count(column)：对column中非Null进行统计 select count(*) as cnt1, count(1) as cnt2 from student; select count(sex) as cnt3 from student; -- 场景2：带有group by子句的聚合操作 注意group by语法限制 select sex, count(*) as cnt from student group by sex; -- 场景3：select时多个聚合函数一起使用 select count(*) as cnt1, avg(age) as cnt2 from student; -- 场景4：聚合函数和case when条件转换函数、coalesce函数、if函数使用 select sum(CASE WHEN sex = '男' THEN 1 ELSE 0 END) from student; select sum(if(sex = '男', 1, 0)) from student; -- 场景5：聚合参数不支持嵌套聚合函数 select avg(count(*)) from student; -- 报错 -- 场景6：聚合操作时针对null的处理 CREATE TABLE tmp_1(val1 int, val2 int); INSERT INTO TABLE tmp_1 VALUES (1, 2),(null, 2),(2, 3); -- 第二行数据(NULL, 2) 在进行sum(val1 + val2)的时候会被忽略 select sum(val1), sum(val1 + val2) from tmp_1; -- 可以使用coalesce函数解决（返回第一个不为空的值） select sum(coalesce(val1, 0)), sum(coalesce(val1, 0) + val2) from tmp_1; -- 场景7：配合distinct关键字去重聚合 -- 此场景下，会编译期间会自动设置只启动一个reduce task处理数据 可能造成数据拥堵 select count(distinct sex) as cnt1 from student; -- 可以先去重 在聚合 通过子查询完成 -- 因为先执行distinct的时候 可以使用多个reducetask来跑数据 select count(*) as gender_uni_cnt from (select distinct sex from student) a; -- 案例需求：找出student中男女学生年龄最大的及其名字 -- 这里使用了struct来构造数据 然后针对struct应用max找出最大元素 然后取值 select case sex when '男' then '男' when '女' then '女' else '其他' end, max(struct(age, name)).col1 as age, max(struct(age, name)).col2 as name from student where sex != '\\\\N' group by sex order by age desc; select struct(age, name) from student; -- {\\\"col1\\\":20,\\\"col2\\\":\\\"李勇\\\"}... select struct(age, name).col1 from student; -- 所有年龄 select max(struct(age, name)) from student; -- 最大年龄 \"]},\"352\":{\"h\":\"3.2.2 增强聚合\",\"t\":[\"grouping_sets：一种将多个group by逻辑写在一个sql语句中的便利写法。等价于将不同维度的GROUP BY结果集进行UNION ALL。GROUPING__ID表示结果属于哪一个分组集合。\",\"cube：根据GROUP BY的维度的所有组合进行聚合。比如cube有a,b,c 3个维度，则所有组合情况是： (a,b,c),(a,b),(b,c),(a,c),(a),(b),(c),()，总个数是2n\",\"rollup：rollup是cube的子集，以最左侧的维度为主，从该维度进行层级聚合。比如ROLLUP有a,b,c3个维度，则所有组合情况是：(a,b,c),(a,b),(a),()\",\"cookie_info\",\"CREATE TABLE cookie_info ( month STRING, -- 2018-03 day STRING, -- 2018-03-30 cookieid STRING -- cookie1... ) ROW FORMAT DELIMITED FIELDS TERMINATED BY ','; load data local inpath '/root/hivedata/cookie_info.txt' into table cookie_info; \"]},\"353\":{\"h\":\"grouping_sets\",\"t\":[\"对于grouping__id，原则上是通过将group by中的字段倒序排序，然后通过二进制来表示的\",\"比如说下面的month，day，倒序排序后为（day，month），出现的位置置1\",\"但是我运行出来的grouping__id与理论上有点出入，具体问题还不知道\",\"字段\",\"二进制表示\",\"十进制表示\",\"month\",\"(0, 1)\",\"1\",\"day\",\"(1, 0)\",\"2\",\"(month, day)\",\"(1, 1)\",\"3\",\"SELECT month, day, COUNT(DISTINCT cookieid) AS nums, GROUPING__ID FROM cookie_info GROUP BY month, day GROUPING SETS (month, day) -- 这里是关键 ORDER BY GROUPING__ID; -- 等价于 select month, NULL as day, count(distinct cookieid) as nums, 1 as grouping__id from cookie_info group by month union all select NULL as month, day, count(distinct cookieid) as nums, 2 as grouping__id from cookie_info group by day; \",\"对于有(month, day)的情况，如下，grouping__id与理论情况有点出入\",\"SELECT month, day, COUNT(DISTINCT cookieid) AS nums, grouping__id FROM cookie_info GROUP BY month, day GROUPING SETS ( month, day, ( month, day)) -- 1 month 2 day 3 (month,day) ORDER BY grouping__id; -- 等价于 SELECT month, NULL, COUNT(DISTINCT cookieid) AS nums, 1 AS GROUPING__ID FROM cookie_info GROUP BY month UNION ALL SELECT NULL, day, COUNT(DISTINCT cookieid) AS nums, 2 AS GROUPING__ID FROM cookie_info GROUP BY day UNION ALL SELECT month, day, COUNT(DISTINCT cookieid) AS nums, 3 AS GROUPING__ID FROM cookie_info GROUP BY month, day; \"]},\"354\":{\"h\":\"cube\",\"t\":[\"cube下，grouping__id依然有出入\",\"SELECT month, day, COUNT(DISTINCT cookieid) AS nums, GROUPING__ID FROM cookie_info GROUP BY month, day WITH CUBE ORDER BY GROUPING__ID; -- 等价于 SELECT NULL, NULL, COUNT(DISTINCT cookieid) AS nums, 0 AS GROUPING__ID FROM cookie_info UNION ALL SELECT month, NULL, COUNT(DISTINCT cookieid) AS nums, 1 AS GROUPING__ID FROM cookie_info GROUP BY month UNION ALL SELECT NULL, day, COUNT(DISTINCT cookieid) AS nums, 2 AS GROUPING__ID FROM cookie_info GROUP BY day UNION ALL SELECT month, day, COUNT(DISTINCT cookieid) AS nums, 3 AS GROUPING__ID FROM cookie_info GROUP BY month, day; \"]},\"355\":{\"h\":\"rollup\",\"t\":[\"-- 比如，以month维度进行层级聚合： SELECT month, day, COUNT(DISTINCT cookieid) AS nums, GROUPING__ID FROM cookie_info GROUP BY month, day WITH ROLLUP ORDER BY GROUPING__ID; \",\"-- 把month和day调换顺序，则以day维度进行层级聚合： SELECT day, month, COUNT(DISTINCT cookieid) AS uv, GROUPING__ID FROM cookie_info GROUP BY day, month WITH ROLLUP ORDER BY GROUPING__ID; \"]},\"356\":{\"h\":\"3.3 窗口函数\",\"t\":[\"窗口函数（Window functions）也叫做开窗函数、OLAP函数，其最大特点是：输入值是从SELECT语句的结果集中的一行或多行的“窗口”中获取的。\",\"如果函数具有OVER子句，则它是窗口函数。\",\"窗口函数可以简单地解释为类似于聚合函数的计算函数，但是通过GROUP BY子句组合的常规聚合会隐藏正在聚合的各个行，最终输出一行，窗口函数聚合后还可以访问当中的各个行，并且可以将这些行中的某些属性添加到结果集中。\"]},\"357\":{\"h\":\"3.3.1 示例\",\"t\":[\"表数据：\",\"--建表加载数据 CREATE TABLE employee ( id int, name string, deg string, salary int, dept string ) row format delimited fields terminated by ','; load data local inpath '/root/hivedata/employee.txt' into table employee; \",\"普通聚合：\",\"----sum+group by普通常规聚合操作------------ select dept, sum(salary) as total from employee group by dept; \",\"窗口函数聚合：\",\"select id, name, deg, salary, dept, sum(salary) over (partition by dept) as total from employee; \"]},\"358\":{\"h\":\"3.3.2 语法树\",\"t\":[\"------- 窗口函数语法树 -------- Function(arg1,..., argn) OVER ([PARTITION BY <...>] [ORDER BY <....>] [<window_expression>]) -- 其中Function(arg1,..., argn) 可以是下面分类中的任意一个 -- 聚合函数：比如sum max avg等 -- 排序函数：比如rank row_number等 -- 分析函数：比如lead lag first_value等 -- OVER [PARTITION BY <...>] 类似于group by 用于指定分组 每个分组你可以把它叫做窗口 -- 如果没有PARTITION BY 那么整张表的所有行就是一组 -- [ORDER BY <....>] 用于指定每个分组内的数据排序规则 支持ASC、DESC -- [<window_expression>] 窗口表达式，用于指定每个窗口中 操作的数据范围 默认是窗口中所有行 \"]},\"359\":{\"h\":\"3.3.3 后续数据准备\",\"t\":[\"create table website_pv_info ( cookieid string, -- cookie1 / cookie2 createtime string, -- 2018-04-14 ... pv int -- 2 浏览量 ) row format delimited fields terminated by ','; create table website_url_info ( cookieid string, -- cookie1 / cookie2 createtime string, -- 访问时间 2018-04-10 10:00:02 url string -- 访问页面 url1 / url2 .... ) row format delimited fields terminated by ','; load data local inpath '/root/hivedata/website_pv_info.txt' into table website_pv_info; load data local inpath '/root/hivedata/website_url_info.txt' into table website_url_info; \"]},\"360\":{\"h\":\"3.3.4 窗口聚合函数\",\"t\":[\"所谓窗口聚合函数指的是sum、max、min、avg这样的聚合函数在窗口中的使用\",\"对于sum+窗口函数，总共有四种用法\",\"sum(...) over( )对表所有行求和\",\"sum(...) over( order by ... ) 连续累积求和\",\"sum(...) over( partition by... ) 同组内所行求和\",\"sum(...) over( partition by... order by ... ) 在每个分组内，连续累积求和\",\"需求：求出每个用户的pv数\",\"select cookieid, sum(pv) as total_pv from website_pv_info group by cookieid; \",\"需求：求出网站总的pv数 所有用户所有访问加起来\",\"select cookieid, createtime, pv, sum(pv) over () as total_pv -- 所有行求和 from website_pv_info; \",\"需求：求出每个用户总pv数\",\"select cookieid, createtime, pv, sum(pv) over (partition by cookieid) as total_pv -- 同一组所有行求和 from website_pv_info; \",\"需求：求出每个用户截止到当天，累计的总pv\",\"select cookieid, createtime, pv, -- 同一组内累计求和 sum(pv) over (partition by cookieid order by createtime) as current_total_pv from website_pv_info; \"]},\"361\":{\"h\":\"3.3.5 窗口表达式\",\"t\":[\"在sum(...) over( partition by... order by ... )语法完整的情况下，进行累积聚合操作，默认累积聚合行为是：从第一行聚合到当前行。\",\"Window expression窗口表达式给我们提供了一种控制行范围的能力，比如向前2行，向后3行。\",\"其实就是前缀和\",\"关键字：row between\",\"preceding：往前\",\"following：往后\",\"current row：当前行\",\"unbounded：边界\",\"unbounded preceding 表示从前面的起点\",\"unbounded following：表示到后面的终点\",\"需求：第一行到当前行，写不写都一样\",\"select cookieid, createtime, pv, sum(pv) over (partition by cookieid order by createtime rows between unbounded preceding and current row) as pv2 from website_pv_info; \",\"需求：向前三行至当前行\",\"select cookieid, createtime, pv, sum(pv) over (partition by cookieid order by createtime rows between 3 preceding and current row) as pv4 from website_pv_info; \"]},\"362\":{\"h\":\"3.3.6 窗口排序函数（TOPN / n m \\\\frac{n}{m} m n ​ ）\"},\"363\":{\"h\":\"row_number家族(TOPN)\",\"t\":[\"row_number：在每个分组中，为每行分配一个从1开始的唯一序列号，递增，不考虑重复；(1,2,3,4,5,6,7)\",\"rank: 在每个分组中，为每行分配一个从1开始的序列号，考虑重复，挤占后续位置；(1,2,3,3,5,6,7)\",\"dense_rank: 在每个分组中，为每行分配一个从1开始的序列号，考虑重复，不挤占后续位置；(1,2,3,3,4,5,6)\",\"SELECT cookieid, createtime, pv, RANK() OVER (PARTITION BY cookieid ORDER BY pv desc) AS rn1, DENSE_RANK() OVER (PARTITION BY cookieid ORDER BY pv desc) AS rn2, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY pv DESC) AS rn3 FROM website_pv_info WHERE cookieid = 'cookie1'; \",\"需求：找出每个用户访问pv的最多的Top3，重复并列的不考虑\",\"SELECT * from (SELECT cookieid, createtime, pv, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY pv DESC) AS seq FROM website_pv_info) as tmp where tmp.seq < 4; \"]},\"364\":{\"h\":\"ntile($ \\\\frac{n}{m}$)\",\"t\":[\"将每个分组内的数据分为指定的若干个桶里（分为若干个部分），并且为每一个桶分配一个桶编号。\",\"如果不能平均分配，则优先分配较小编号的桶，并且各个桶中能放的行数最多相差1。\",\"有时会有这样的需求:如果数据排序后分为三部分，业务人员只关心其中的一部分，如何将这中间的三分之一数据拿出来呢?NTILE函数即可以满足。\",\"-- 把每个分组内的数据分为3桶 SELECT cookieid, createtime, pv, NTILE(3) OVER (PARTITION BY cookieid ORDER BY createtime) AS rn2 FROM website_pv_info ORDER BY cookieid, createtime; \",\"需求：统计每个用户pv最多的前1/3天\",\"-- 理解：将数据根据cookieid分 根据pv倒序排序 排序之后分为3个部分 取第一部分 SELECT * from (SELECT cookieid, createtime, pv, NTILE(3) OVER (PARTITION BY cookieid ORDER BY pv DESC) AS rn FROM website_pv_info) tmp where rn = 1; \"]},\"365\":{\"h\":\"3.3.7 窗口分析函数\",\"t\":[\"LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值。第一个参数为列名，第二个参数为往上第n行（可选，默认为1），第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）；\",\"LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值。第一个参数为列名，第二个参数为往下第n行（可选，默认为1），第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）；\",\"FIRST_VALUE 取分组内排序后，截止到当前行，第一个值\",\"LAST_VALUE 取分组内排序后，截止到当前行，最后一个值\",\"LAG\",\"-- LAG SELECT cookieid, createtime, url, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY createtime) AS rn, LAG(createtime, 1, '1970-01-01 00:00:00') OVER (PARTITION BY cookieid ORDER BY createtime) AS last_1_time, LAG(createtime, 2) OVER (PARTITION BY cookieid ORDER BY createtime) AS last_2_time FROM website_url_info; \",\"LEAD\",\"-- LEAD SELECT cookieid, createtime, url, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY createtime) AS rn, LEAD(createtime, 1, '1970-01-01 00:00:00') OVER (PARTITION BY cookieid ORDER BY createtime) AS next_1_time, LEAD(createtime, 2) OVER (PARTITION BY cookieid ORDER BY createtime) AS next_2_time FROM website_url_info; \",\"FIRST_VALUE\",\"-- FIRST_VALUE SELECT cookieid, createtime, url, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY createtime) AS rn, FIRST_VALUE(url) OVER (PARTITION BY cookieid ORDER BY createtime) AS first1 FROM website_url_info; \",\"LAST_VALUE，到当前最后一个值其实就是自己\",\"-- LAST_VALUE SELECT cookieid, createtime, url, ROW_NUMBER() OVER (PARTITION BY cookieid ORDER BY createtime) AS rn, LAST_VALUE(url) OVER (PARTITION BY cookieid ORDER BY createtime) AS last1 FROM website_url_info; \"]},\"366\":{\"h\":\"3.4 抽样函数\"},\"367\":{\"h\":\"3.4.1 随机抽样\",\"t\":[\"需求：随机抽取2个学生的情况进行查看\",\"SELECT * FROM student DISTRIBUTE BY rand() SORT BY rand() LIMIT 2; -- 使用order by+rand也可以实现同样的效果 但是效率不高 SELECT * FROM student ORDER BY rand() LIMIT 2; \"]},\"368\":{\"h\":\"3.4.2 基于数据块抽样\",\"t\":[\"意思就是随机一个数据块进行抽样，当只有一个数据块时，每次结果都一样\",\"Block块采样允许随机获取n行数据、百分比数据或指定大小的数据。\",\"采样粒度是HDFS块大小\",\"优点是速度快，缺点是不随机\",\"-- 根据行数抽样（获得随机数据块的第一行数据） SELECT * FROM student TABLESAMPLE (1 ROWS); -- 根据数据大小百分比抽样（获得随机数据块的前50%数据） SELECT * FROM student TABLESAMPLE (50 PERCENT); -- 根据数据大小抽样（获得随机数据块的前1K数据） -- 支持数据单位 b/B, k/K, m/M, g/G SELECT * FROM student TABLESAMPLE (1K); \"]},\"369\":{\"h\":\"3.4.3 基于分桶表抽样\",\"t\":[\"这是一种特殊的采样方法，针对分桶表进行了优化。优点是既随机速度也很快。\",\"语法如下：\",\"TABLESAMPLE (BUCKET x OUT OF y [ON colname]) -- 1、y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例。 -- 例如，table总共分了4份（4个bucket），当y=2时，抽取(4/2=)2个bucket的数据，当y=8时，抽取(4/8=)1/2个bucket的数据。 -- 2、x表示从哪个bucket开始抽取。 -- 例如，table总bucket数为4，tablesample(bucket 4 out of 4)，表示总共抽取（4/4=）1个bucket的数据，抽取第4个bucket的数据。 -- 注意：x的值必须小于等于y的值，否则FAILED:Numerator should not be bigger than denominator in sample clause for table stu_buck -- 3、ON colname表示基于什么抽 -- ON rand()表示随机抽 -- ON 分桶字段 表示基于分桶字段抽样 效率更高 推荐 \",\"-- 根据整行数据进行抽样 SELECT * FROM t_usa_covid19_bucket TABLESAMPLE (BUCKET 1 OUT OF 5 ON rand()); \",\"-- 根据分桶字段进行抽样 效率更高（对于该案例就是抽取第一桶的数据） SELECT * FROM t_usa_covid19_bucket TABLESAMPLE (BUCKET 1 OUT OF 5 ON state); \"]},\"370\":{\"h\":\"Hive 函数重要应用案例\"},\"371\":{\"h\":\"1. Hive中多字节分隔符处理\",\"t\":[\"Hive默认序列化类是LazySimpleSerDe，其只支持使用单字节分隔符（char）来加载文本数据，所以遇到多字符或者数据字段中包含了分隔符，那么LazySimpleSerDe就不再适用了。\"]},\"372\":{\"h\":\"1.1 问题和需求\",\"t\":[\"比如下面的两种情况：\",\"多字符分隔符：\",\"数据字段中包含了分隔符：\",\"这个时候就需要提出新的解决方案了\"]},\"373\":{\"h\":\"1.2 解决方案一：替换分隔符\",\"t\":[\"当数据量小的时候，可以写个Java程序来清洗数据即可。当数据量大的时候就需要使用MapReduce的Map阶段来进行数据清洗了。\",\"主要Map阶段的代码如下：\",\"public class ChangeSplitMapper extends Mapper<LongWritable,Text,Text,NullWritable>{ //定义输出的Key private Text outputKey = new Text(); //定义输出的Value private NullWritable outputValue = NullWritable.get(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //获取每条数据 String line = value.toString(); //将里面的||转换为| String newLine = line.replaceAll(\\\"\\\\\\\\|\\\\\\\\|\\\", \\\"|\\\"); //替换后的内容作为Key this.outputKey.set(newLine); //输出结果 context.write(this.outputKey,this.outputValue); } } \"]},\"374\":{\"h\":\"1.3 解决方案二：RegexSerDe正则加载\",\"t\":[\"除了LazySimpleSerDe外，Hive还内置了很多SerDe类，比如ORCSerDe，RegexSerDe，JsonSerDe等。通过RegexSerDe类，就可以解决分隔符问题。\",\"通过正则表达式匹配每一行数据即可。重点就是能写好正则表达式\",\"对于上面两个问题的解决方案如下：\",\"create table singer ( id string,-- 歌手id name string,-- 歌手名称 country string,-- 国家 province string,-- 省份 gender string,-- 性别 works string-- 作品 ) -- 指定使用RegexSerde加载数据 ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.RegexSerDe' WITH SERDEPROPERTIES (\\\"input.regex\\\" = \\\"([0-9]*)\\\\\\\\|\\\\\\\\|(.*)\\\\\\\\|\\\\\\\\|(.*)\\\\\\\\|\\\\\\\\|(.*)\\\\\\\\|\\\\\\\\|(.*)\\\\\\\\|\\\\\\\\|(.*)\\\"); \",\"create table apachelog ( ip string, -- IP地址 stime string, -- 时间 mothed string, -- 请求方式 url string, -- 请求地址 policy string, -- 请求协议 stat string, -- 请求状态 body string -- 字节大小 ) -- 指定使用RegexSerde加载数据 ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.RegexSerDe' -- 指定正则表达式 WITH SERDEPROPERTIES ( \\\"input.regex\\\" = \\\"([^ ]*) ([^}]*) ([^ ]*) ([^ ]*) ([^ ]*) ([0-9]*) ([^ ]*)\\\" ) stored as textfile; \"]},\"375\":{\"h\":\"1.4 解决方案三：自定义InputFormat\",\"t\":[\"过于繁琐，不推荐使用。\"]},\"376\":{\"h\":\"2. URL解析函数\",\"t\":[\"Hive中为了实现对URL的解析，专门提供了解析URL的函数parse_url和parse_url_tuple。其中parse_url_tuple是一个UDTF，注意要和侧视图Lateral View配套使用。\"]},\"377\":{\"h\":\"2.1 parse_url\",\"t\":[\"SELECT parse_url('http://facebook.com/path/p1.php?id=10086', 'PROTOCOL'); -- http \",\"SELECT parse_url('http://facebook.com/path/p1.php?id=10086', 'HOST'); -- facebook.com \",\"SELECT parse_url('http://facebook.com/path/p1.php?id=10086', 'PATH'); -- /path/p1.php \",\"SELECT parse_url('http://facebook.com/path/p1.php?id=10086', 'QUERY'); -- id=10086 \",\"SELECT parse_url('http://facebook.com/path/p1.php?id=10086', 'QUERY', 'id'); -- 10086 \"]},\"378\":{\"h\":\"2.2 parse_url_tuple\",\"t\":[\"创建实验用表tb_url\",\"create table tb_url ( id int, url string ) row format delimited fields terminated by '\\\\t'; \",\"tb_url\",\"select parse_url_tuple(url, \\\"PROTOCOL\\\", \\\"HOST\\\", \\\"PATH\\\", \\\"QUERY\\\") as (protocol, host, path, query) from tb_url; \",\"注意下面写法的错误示范：\",\"select id, parse_url_tuple(url, \\\"HOST\\\", \\\"PATH\\\", \\\"QUERY\\\") as (host, path, query) from tb_url; \",\"UDTF函数对于很多场景下有使用限制，例如：select时不能包含其他字段、不能嵌套调用、不能与group by等放在一起调用等等\",\"UDTF函数的调用方式，主要有以下两种方式：\",\"直接在select后单独使用\",\"与Lateral View配套使用\",\"使用UDTF时的正确做法：\",\"select a.id as id, b.host as host, b.path as path, c.protocol as protocol, c.query as query from tb_url a lateral view parse_url_tuple(url, \\\"HOST\\\", \\\"PATH\\\") b as host, path lateral view parse_url_tuple(url, \\\"PROTOCOL\\\", \\\"QUERY\\\") c as protocol, query; \"]},\"379\":{\"h\":\"3. 行列转换应用与实现\"},\"380\":{\"h\":\"3.1 行转列：多行转多列\",\"t\":[\"使用case when语句\",\"case when 条件1 then value1 ... else 默认值 end\",\"case 列 when v1 then value1 ... else 默认值 end\"]},\"381\":{\"h\":\"3.1.1 需求\"},\"382\":{\"h\":\"3.1.2 实现\",\"t\":[\"create table row2col1 ( col1 string, col2 string, col3 int ) row format delimited fields terminated by '\\\\t'; \",\"select col1 as col1, max(case col2 when 'c' then col3 else 0 end) as c, max(case col2 when 'd' then col3 else 0 end) as d, max(case col2 when 'e' then col3 else 0 end) as e from row2col1 group by col1; \"]},\"383\":{\"h\":\"3.2 行转列：多行转单列\",\"t\":[\"使用concat,concat_ws,collect_list,collect_set等函数\"]},\"384\":{\"h\":\"3.2.1 需求\"},\"385\":{\"h\":\"3.2.2 实现\",\"t\":[\"create table row2col2 ( col1 string, col2 string, col3 int ) row format delimited fields terminated by '\\\\t'; \",\"select col1, col2, concat_ws(\\\",\\\", collect_list(cast(col3 as string))) as col3 from row2col2 group by col1, col2; \"]},\"386\":{\"h\":\"3.3 列转行：多列转多行\",\"t\":[\"关键使用union关键字，将多个select合并成一个\",\"union：去重且排序\",\"union all：不去重不排序\"]},\"387\":{\"h\":\"3.3.1 需求\"},\"388\":{\"h\":\"3.3.2 实现\",\"t\":[\"create table col2row1 ( col1 string, col2 int, col3 int, col4 int ) row format delimited fields terminated by '\\\\t'; \",\"select col1, 'c' as col2, col2 as col3 from col2row1 UNION ALL select col1, 'd' as col2, col3 as col3 from col2row1 UNION ALL select col1, 'e' as col2, col4 as col3 from col2row1; \"]},\"389\":{\"h\":\"3.4 列转行：单列转多行\",\"t\":[\"explode函数的使用，注意explode的参数只能是Map或者Array\"]},\"390\":{\"h\":\"3.4.1 需求\"},\"391\":{\"h\":\"3.4.2 实现\",\"t\":[\"create table col2row2 ( col1 string, col2 string, col3 string ) row format delimited fields terminated by '\\\\t'; \",\"select col1, col2, lv.col3 as col3 from col2row2 lateral view explode(split(col3, ',')) lv as col3; \"]},\"392\":{\"h\":\"4. Json数据处理\"},\"393\":{\"h\":\"4.1 Hive中的Json处理方式\",\"t\":[\"使用Json函数处理：get_json_object,json_tuple\",\"Json SerDe加载数据\"]},\"394\":{\"h\":\"4.2 Json函数\"},\"395\":{\"h\":\"4.2.1 get_json_object\",\"t\":[\"用于解析JSON字符串，可以从JSON字符串中返回指定的某个对象列的值\",\"特点是每次只能返回Json对象中一列的值\",\"[scode type=\\\"green\\\"]\",\"如果数据中每一行只有个别字段是JSON格式字符串，就可以使用JSON函数来实现处理，但是如果数据加载的文件整体就是JSON文件，每一行数据就是一个JSON数据，那么建议直接使用JSONSerde来实现处理最为方便。\",\"[/scode]\",\"参数：\",\"第一个参数：指定要解析的JSON字符串\",\"第二个参数：指定要返回的字段，通过**$.columnName**的方式来指定path\",\"示例：\",\"create table tb_json_test1 ( json string ); \",\"select -- 获取设备名称 get_json_object(json, \\\"$.device\\\") as device, -- 获取设备类型 get_json_object(json, \\\"$.deviceType\\\") as deviceType, -- 获取设备信号强度 get_json_object(json, \\\"$.signal\\\") as signal, -- 获取时间 get_json_object(json, \\\"$.time\\\") as stime from tb_json_test1; \"]},\"396\":{\"h\":\"4.2.2 json_tuple\",\"t\":[\"用于实现JSON字符串的解析，可以通过指定多个参数来解析JSON返回多列的值\",\"属于UDTF，需要搭配Lateral View来使用\",\"参数：\",\"第一个参数：指定解析的Json字符串\",\"可变参数：指定返回的字段\",\"示例：\",\"-- 单独使用 select --解析所有字段 json_tuple(json, \\\"device\\\", \\\"deviceType\\\", \\\"signal\\\", \\\"time\\\") as (device, deviceType, signal, stime) from tb_json_test1; \",\"-- 搭配侧视图使用 select json, device, deviceType, signal, stime from tb_json_test1 lateral view json_tuple(json, \\\"device\\\", \\\"deviceType\\\", \\\"signal\\\", \\\"time\\\") b as device, deviceType, signal, stime; \"]},\"397\":{\"h\":\"4.3 Json SerDe\",\"t\":[\"Hive中为了简化对于JSON文件的处理，内置了一种专门用于解析JSON文件的Serde解析器，在创建表时，只要指定使用JSONSerde解析表的文件，就会自动将JSON文件中的每一列进行解析\",\"drop table if exists tb_json_test2; create table tb_json_test2 ( device string, deviceType string, signal double, `time` string ) ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe' STORED AS TEXTFILE; \"]},\"398\":{\"h\":\"5. 窗口函数应用实例\"},\"399\":{\"h\":\"5.1 案例1：连续登录用户\",\"t\":[\"窗口函数lead\",\"功能：用于从当前数据中基于当前行的数据向后取偏移值\",\"语法：lead(colName, N, defaultValue)\",\"colName：取哪一列的值\",\"N：向后偏移几行\",\"defaultValue：如果取不到返回的默认值\",\"分析\",\"我们可以基于用户的登陆信息，找到如下规律： 连续两天登陆 ： 用户下次登陆时间 = 本次登陆以后的第二天 连续三天登陆 ： 用户下下次登陆时间 = 本次登陆以后的第三天 …… 我们可以对用户ID进行分区，按照登陆时间进行排序，通过lead函数计算出用户下次登陆时间 通过日期函数计算出登陆以后第二天的日期，如果相等即为连续两天登录。\"]},\"400\":{\"h\":\"5.1.1 实现\",\"t\":[\"create table tb_login ( userid string, logintime string ) row format delimited fields terminated by '\\\\t'; \",\"-- 连续登陆2天 select userid, logintime, -- 本次登陆日期的第二天 date_add(logintime, 1) as nextday, -- 按照用户id分区，按照登陆日期排序，取下一次登陆时间，取不到就为0 lead(logintime, 1, 0) over (partition by userid order by logintime) as nextlogin from tb_login; \",\"通过判断nextday和nextlogin是否相等就可以判断有没有连续登录2天\",\"with t1 as ( select userid, logintime, -- 本次登陆日期的第二天 date_add(logintime, 1) as nextday, -- 按照用户id分区，按照登陆日期排序，取下一次登陆时间，取不到就为0 lead(logintime, 1, 0) over (partition by userid order by logintime) as nextlogin from tb_login) select distinct userid from t1 where nextday = nextlogin; \",\"连续登录三天的只需要略作修改即可，实现如下：\",\"with t1 as ( select userid, logintime, -- 本次登陆日期的第三天 date_add(logintime, 2) as nextday, -- 按照用户id分区，按照登陆日期排序，取下下一次登陆时间，取不到就为0 lead(logintime, 2, 0) over (partition by userid order by logintime) as nextlogin from tb_login) select distinct userid from t1 where nextday = nextlogin; \"]},\"401\":{\"h\":\"5.2 案例2：级联累加求和\",\"t\":[\"需求：统计每个用户每个月的消费总金额以及当前累计消费总金额\",\"窗口函数sum默认就是从第一列到当前列求和，也就是满足当前累计消费总金额这个需求\"]},\"402\":{\"h\":\"5.2.1 实现\",\"t\":[\"create table tb_money ( userid string, mth string, money int ) row format delimited fields terminated by '\\\\t'; \",\"select userid, mth, m_money, sum(m_money) over (partition by userid order by mth) as t_money from tb_money_mtn; \"]},\"403\":{\"h\":\"5.3 案例3：分组TopN\",\"t\":[\"需求：统计每个部门工资最高的前两名\",\"TopN函数：row_number,rank,dense_rank\",\"row_number：对每个分区的数据进行编号，如果值相同，继续编号\",\"rank：对每个分区的数据进行编号，如果值相同，编号相同，但留下空位\",\"dense_rank：对每个分区的数据进行编号，如果值相同，编号相同，不留下空位\"]},\"404\":{\"h\":\"5.3.1 实现\",\"t\":[\"create table tb_emp ( empno string, ename string, job string, managerid string, hiredate string, salary double, bonus double, deptno string ) row format delimited fields terminated by '\\\\t'; \",\"-- 过滤每个部门的薪资最高的前两名 with t1 as ( select empno, ename, salary, deptno, row_number() over (partition by deptno order by salary desc) as rn from tb_emp) select * from t1 where rn < 3; \"]},\"405\":{\"h\":\"6. 拉链表的设计与实现\",\"t\":[\"拉链表专门用于解决在数据仓库中数据发生变化如何实现数据存储的问题，也就是解决Hive数仓中数据如何更新这个问题。\",\"[scode type=\\\"green\\\"]\",\"拉链表的设计是将更新的数据进行状态记录，没有发生更新的数据不进行状态存储，用于存储所有数据在不同时间上的所有状态，通过时间进行标记每个状态的生命周期，查询时，根据需求可以获取指定时间范围状态的数据，默认用9999-12-31等最大值来表示最新状态。\",\"[/scode]\"]},\"406\":{\"h\":\"6.1 实现过程\"},\"407\":{\"h\":\"6.1.1 创建拉链表\",\"t\":[\"create table dw_zipper ( userid string, phone string, nick string, gender int, addr string, starttime string, endtime string ) row format delimited fields terminated by '\\\\t'; \"]},\"408\":{\"h\":\"6.1.2 创建增量表\",\"t\":[\"-- 创建ods层增量表 加载数据 create table ods_zipper_update ( userid string, phone string, nick string, gender int, addr string, starttime string, endtime string ) row format delimited fields terminated by '\\\\t'; \"]},\"409\":{\"h\":\"6.1.3 临时表操作\",\"t\":[\"合并拉链表和增量表，并写入临时表\",\"对于新增的数据，直接通过union all操作合并即可；对于修改的数据，将之前endtime的9999-12-31修改为新数据starttime的starttime-1，然后通过union all合并修改后的数据即可。\",\"创建临时表：\",\"create table tmp_zipper ( userid string, phone string, nick string, gender int, addr string, starttime string, endtime string ) row format delimited fields terminated by '\\\\t'; \",\"合并数据到临时表中：\",\"第一个select是union所有新增数据，第二个select是将修改的数据的endtime修改为新数据starttime的starttime-1\",\"insert overwrite table tmp_zipper select userid, phone, nick, gender, addr, starttime, endtime from ods_zipper_update union all -- 查询原来拉链表的所有数据，并将这次需要更新的数据的endTime更改为更新值的startTime select a.userid, a.phone, a.nick, a.gender, a.addr, a.starttime, -- 如果这条数据没有更新或者这条数据不是要更改的数据，就保留原来的值，否则就改为新数据的开始时间-1 if(b.userid is null or a.endtime < '9999-12-31', a.endtime, date_sub(b.starttime, 1)) as endtime from dw_zipper a left join ods_zipper_update b on a.userid = b.userid; \"]},\"410\":{\"h\":\"6.1.4 覆盖到拉链表\",\"t\":[\"-- 覆盖拉链表 insert overwrite table dw_zipper select * from tmp_zipper; \"]},\"411\":{\"h\":\"Hive 性能优化及 Hive3 新特性\"},\"412\":{\"h\":\"1. Hive表设计优化\"},\"413\":{\"h\":\"1.1 分区表结构设计\",\"t\":[\"Hive在执行查询计划时，会使用表的最后一级目录作为底层处理数据的输入。如果不使用分区表，那么表目录下的所有文件将都会被加载，会导致大量磁盘和网络的IO损耗。\"]},\"414\":{\"h\":\"1.1.1 普通表结构问题\",\"t\":[\"假设每天有1G的数据增量，一年就是365GB的数据，按照业务需求，每次只需要对其中一天的数据进行处理，也就是处理1GB的数据；\",\"程序会先加载365GB的数据，然后将364GB的数据过滤掉，只保留一天的数据再进行计算，导致了大量的磁盘和网络的IO的损耗。\"]},\"415\":{\"h\":\"1.1.2 分区设计思想\",\"t\":[\"根据查询的需求，将数据按照查询的条件【一般以时间】进行划分分区存储，将不同分区的数据单独使用一个HDFS目录来进行存储，当底层实现计算时，根据查询的条件，只读取对应分区的数据作为输入，减少不必要的数据加载，提高程序的性能。\"]},\"416\":{\"h\":\"1.2 分桶表结构设计\"},\"417\":{\"h\":\"1.2.1 分桶表设计思想\",\"t\":[\"分桶表的设计是按照一定的规则【底层通过MapReduce中的多个Reduce来实现】将数据划分到不同的文件中进行存储，构建分桶表。\"]},\"418\":{\"h\":\"1.2.2 优化Join\",\"t\":[\"Hive中Join的问题：\",\"默认情况下，Hive底层是通过MapReduce来实现的；\",\"MapReduce在处理数据之间join的时候有两种方式：MapJoin、ReduceJoin，其中MapJoin效率较高；\",\"如果有两张非常大的表要进行Join，底层无法使用MapJoin提高Join的性能，只能走默认的ReduceJoin；\",\"而ReduceJoin必须经过Shuffle过程，相对性能比较差，而且容易产生数据倾斜。\",\"如果有两张表按照相同的划分规则【比如按照Join的关联字段】将各自的数据进行划分；在Join时，就可以实现Bucket与Bucket的Join，避免不必要的比较，减少笛卡尔积数量。\"]},\"419\":{\"h\":\"1.3 索引设计\",\"t\":[\"实际工作场景中，一般不推荐使用Hive Index，推荐使用ORC文件格式中的索引、物化视图来代替Hive Index提高查询性能。\"]},\"420\":{\"h\":\"1.3.1 Hive中的索引\",\"t\":[\"在传统的关系型数据库例如MySQL、Oracle中，为了提高数据的查询效率，可以为表中的字段单独构建索引，查询时，可以基于字段的索引快速的实现查询、过滤等操作。\",\"Hive中也同样提供了索引的设计，允许用户为字段构建索引，提高数据的查询效率。但是Hive的索引与关系型数据库中的索引并不相同，比如，Hive不支持主键或者外键索引。\",\"Hive索引可以建立在表中的某些列上，以提升一些操作的效率。\",\"在可以预见到分区数据非常庞大的情况下，分桶和索引常常是优于分区的；\",\"而分桶由于SMB Join对关联键（join字段）要求严格，所以并不是总能生效；\",\"注意：官方明确表示，索引功能支持是从Hive0.7版本开始，到Hive3.0不再支持。\"]},\"421\":{\"h\":\"1.3.2 索引的原理\",\"t\":[\"当为某张表的某个字段创建索引时，Hive中会自动创建一张索引表，该表记录了该字段的每个值与数据实际物理位置之间的关系，例如数据所在的HDFS文件地址，以及所在文件中偏移量offset等信息。\"]},\"422\":{\"h\":\"1.3.3 索引的目的\",\"t\":[\"提高Hive表指定列的查询速度。没有索引时，类似WHERE tab1.col1 = 10的查询，Hive会加载整张表或分区，然后处理所有的行，但是如果在字段col1上面存在索引时，那么只会加载和处理文件的一部分。\"]},\"423\":{\"h\":\"1.3.4 索引的使用\",\"t\":[\"创建索引：\",\"-- 为表中的userid构建索引 create index idx_user_id_login on table tb_login_part(userid) -- 索引类型为Compact，Hive支持Compact和Bitmap类型，存储的索引内容不同 as 'COMPACT' -- 延迟构建索引 with deferred rebuild; \",\"构建/更新索引：通过运行一个MapReduce程序来构建索引\",\"alter index idx_user_id_login ON tb_login_part rebuild; \",\"查看索引结构：\",\"desc default__tb_login_part_idx_user_id_login__; \",\"查看索引内容：\",\"select * from default__tb_login_part_idx_user_id_login__; \",\"删除索引：\",\"DROP INDEX idx_user_id_login ON tb_login_part; \"]},\"424\":{\"h\":\"1.3.5 索引的问题\",\"t\":[\"Hive构建索引的过程是通过一个MapReduce程序来实现的；\",\"每次Hive中原始数据表的数据发生更新时，索引表不会自动更新；\",\"必须手动执行一个Alter index命令来实现通过MapReduce更新索引表，导致整体性能较差，维护相对繁琐。\"]},\"425\":{\"h\":\"2. Hive表数据优化\"},\"426\":{\"h\":\"2.1 文件格式\",\"t\":[\"通过不同的文件格式，可以降低存储空间，提高查询性能。主要推荐使用ORC格式。具体见Hadoop中的讲解。\",\"主要的存储格式如下，在创建表的时候通过stored as 关键字指定，具体使用见前面DDL。\"]},\"427\":{\"h\":\"2.1.1 TextFile\",\"t\":[\"TextFile是Hive中默认的文件格式，存储形式为按行存储。\",\"工作中最常见的数据文件格式就是TextFile文件，几乎所有的原始数据生成都是TextFile格式，所以Hive设计时考虑到为了避免各种编码及数据错乱的问题，选用了TextFile作为默认的格式。\",\"建表时不指定存储格式即为TextFile，导入数据时把数据文件拷贝至HDFS不进行处理。\"]},\"428\":{\"h\":\"2.1.2 SequenceFile\",\"t\":[\"SequenceFile是Hadoop里用来存储序列化的键值对即二进制的一种文件格式。\",\"SequenceFile文件也可以作为MapReduce作业的输入和输出，hive也支持这种格式。\"]},\"429\":{\"h\":\"2.1.3 Parquet\",\"t\":[\"Parquet是一种支持嵌套结构的列式存储文件格式，最早是由Twitter和Cloudera合作开发，2015年5月从Apache孵化器里毕业成为Apache顶级项目。\",\"是一种支持嵌套数据模型对的列式存储系统，作为大数据系统中OLAP查询的优化方案，它已经被多种查询引擎原生支持，并且部分高性能引擎将其作为默认的文件存储格式。\",\"通过数据编码和压缩，以及映射下推和谓词下推功能，Parquet的性能也较之其它文件格式有所提升。\"]},\"430\":{\"h\":\"2.1.4 ORC\",\"t\":[\"ORC（OptimizedRC File）文件格式也是一种Hadoop生态圈中的列式存储格式；\",\"它的产生早在2013年初，最初产生自Apache Hive，用于降低Hadoop数据存储空间和加速Hive查询速度；\",\"2015年ORC项目被Apache项目基金会提升为Apache顶级项目\"]},\"431\":{\"h\":\"2.2 数据压缩\"},\"432\":{\"h\":\"2.2.1 概述\",\"t\":[\"Hive中的压缩就是使用了Hadoop中的压缩实现的，所以Hadoop中支持的压缩在Hive中都可以直接使用。\",\"Hadoop中支持的压缩算法：\",\"Hive底层运行MapReduce程序时，磁盘I/O操作、网络数据传输、shuffle和merge要花大量的时间，尤其是数据规模很大和工作负载密集的情况下。\",\"鉴于磁盘I/O和网络带宽是Hadoop的宝贵资源，数据压缩对于节省资源、最小化磁盘I/O和网络传输非常有帮助。\",\"Hive压缩实际上说的就是MapReduce的压缩。\",\"MapReduce的压缩主要可以在下面四个阶段：\"]},\"433\":{\"h\":\"2.2.2 使用\",\"t\":[\"-- 开启hive中间传输数据压缩功能 -- 1）开启hive中间传输数据压缩功能 set hive.exec.compress.intermediate=true; -- 2）开启mapreduce中map输出压缩功能 set mapreduce.map.output.compress=true; -- 3）设置mapreduce中map输出数据的压缩方式 set mapreduce.map.output.compress.codec= org.apache.hadoop.io.compress.SnappyCodec; -- 开启Reduce输出阶段压缩 -- 1）开启hive最终输出数据压缩功能 set hive.exec.compress.output=true; -- 2）开启mapreduce最终输出数据压缩 set mapreduce.output.fileoutputformat.compress=true; -- 3）设置mapreduce最终数据输出压缩方式 set mapreduce.output.fileoutputformat.compress.codec = org.apache.hadoop.io.compress.SnappyCodec; -- 4）设置mapreduce最终数据输出压缩为块压缩 set mapreduce.output.fileoutputformat.compress.type=BLOCK; \"]},\"434\":{\"h\":\"2.3 存储优化\"},\"435\":{\"h\":\"2.3.1 避免小文件生成\",\"t\":[\"Hive的存储本质还是HDFS，HDFS是不利于小文件存储的，因为每个小文件会产生一条元数据信息，并且不利用MapReduce的处理，MapReduce中每个小文件会启动一个MapTask计算处理，导致资源的浪费，所以在使用Hive进行处理分析时，要尽量避免小文件的生成。\",\"Hive中提供了一个特殊的机制，可以自动的判断是否是小文件，如果是小文件可以自动将小文件进行合并。\",\"-- 如果hive的程序，只有maptask，将MapTask产生的所有小文件进行合并 set hive.merge.mapfiles=true; -- 如果hive的程序，有Map和ReduceTask,将ReduceTask产生的所有小文件进行合并 set hive.merge.mapredfiles=true; -- 每一个合并的文件的大小（244M） set hive.merge.size.per.task=256000000; -- 平均每个文件的大小，如果小于这个值就会进行合并(15M) set hive.merge.smallfiles.avgsize=16000000; \"]},\"436\":{\"h\":\"2.3.2 如何读取小文件\",\"t\":[\"Hive中也提供一种输入类CombineHiveInputFormat，用于将小文件合并以后，再进行处理\",\"-- 设置Hive中底层MapReduce读取数据的输入类：将所有文件合并为一个大文件作为输入 set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; \"]},\"437\":{\"h\":\"2.3.3 ORC文件索引\",\"t\":[\"在使用ORC文件时，为了加快读取ORC文件中的数据内容，ORC提供了两种索引机制：Row Group Index 和 Bloom Filter Index可以帮助提高查询ORC文件的性能\",\"当用户写入数据时，可以指定构建索引，当用户查询数据时，可以根据索引提前对数据进行过滤，避免不必要的数据扫描。\",\"Row Group Index\",\"一个ORC文件包含一个或多个stripes(groups of row data)，每个stripe中包含了每个column的min/max值的索引数据；\",\"当查询中有大于等于小于的操作时，会根据min/max值，跳过扫描不包含的stripes。\",\"而其中为每个stripe建立的包含min/max值的索引，就称为Row Group Index行组索引，也叫min-max Index大小对比索引，或者Storage Index。\",\"建立ORC格式表时，指定表参数orc.create.index=true之后，便会建立Row Group Index；\",\"为了使Row Group Index有效利用，向表中加载数据时，必须对需要使用索引的字段进行排序\",\"-- 1、开启索引配置 set hive.optimize.index.filter=true; -- 2、创建表并制定构建索引 create table tb_sogou_orc_index stored as orc tblproperties (\\\"orc.create.index\\\"=\\\"true\\\") as select * from tb_sogou_source distribute by stime sort by stime; -- 3、当进行范围或者等值查询（**<,>,=**）时就可以基于构建的索引进行查询 select count(*) from tb_sogou_orc_index where stime > '12:00:00' and stime < '18:00:00'; \",\"Bloom Filter Index\",\"建表时候通过表参数”orc.bloom.filter.columns”=”columnName……”来指定为哪些字段建立BloomFilter索引，在生成数据的时候，会在每个stripe中，为该字段建立BloomFilter的数据结构；\",\"当查询条件中包含对该字段的等值过滤时候，先从BloomFilter中获取以下是否包含该值，如果不包含，则跳过该stripe。\",\"-- 创建表指定创建布隆索引 create table tb_sogou_orc_bloom stored as orc tblproperties (\\\"orc.create.index\\\"=\\\"true\\\",\\\"orc.bloom.filter.columns\\\"=\\\"stime,userid\\\") as select * from tb_sogou_source distribute by stime sort by stime; -- stime的范围过滤可以走row group index，userid的过滤可以走bloom filter index select count(*) from tb_sogou_orc_index where stime > '12:00:00' and stime < '18:00:00' and userid = '3933365481995287' ; \"]},\"438\":{\"h\":\"2.3.4 ORC矢量查询\",\"t\":[\"Hive的默认查询执行引擎一次处理一行，而矢量化查询执行是一种Hive针对ORC文件操作的特性，目的是按照每批1024行读取数据，并且一次性对整个记录整合（而不是对单条记录）应用操作，提升了像过滤, 联合, 聚合等等操作的性能。\",\"注意：要使用矢量化查询执行，就必须以ORC格式存储数据。\",\"-- 开启矢量化查询 set hive.vectorized.execution.enabled = true; set hive.vectorized.execution.reduce.enabled = true; \"]},\"439\":{\"h\":\"3. Job作业执行优化\"},\"440\":{\"h\":\"3.1 explain查询计划\",\"t\":[\"explain命令可以帮助用户了解一条HQL语句在底层的实现过程。通俗来说就是Hive打算如何去做这件事。\",\"explain会解析HQL语句，将整个HQL语句的实现步骤、依赖关系、实现过程都会进行解析返回，可以了解一条HQL语句在底层是如何实现数据的查询及处理的过程，辅助用户对Hive进行优化。\"]},\"441\":{\"h\":\"3.1.1 语法\",\"t\":[\"EXPLAIN [FORMATTED|EXTENDED|DEPENDENCY|AUTHORIZATION|] query \",\"FORMATTED：对执行计划进行格式化，返回JSON格式的执行计划\",\"EXTENDED：提供一些额外的信息，比如文件的路径信息\",\"DEPENDENCY：以JSON格式返回查询所依赖的表和分区的列表\",\"AUTHORIZATION：列出需要被授权的条目，包括输入与输出\"]},\"442\":{\"h\":\"3.1.2 输出组成\",\"t\":[\"The Abstract Syntax Tree for the query（抽象语法树AST）：Hive使用Antlr解析生成器，可以自动地将HQL生成为抽象语法树\",\"The dependencies between the different stages of the plan（Stage依赖关系）：会列出运行查询划分的stage阶段以及之间的依赖关系\",\"The description of each of the stages（Stage内容）：包含了每个stage非常重要的信息，比如运行时的operator和sort orders等具体的信息\"]},\"443\":{\"h\":\"3.2 MapReduce属性优化\"},\"444\":{\"h\":\"3.2.1 本地模式\",\"t\":[\"使用Hive的过程中，有一些数据量不大的表也会转换为MapReduce处理，提交到集群时，需要申请资源，等待资源分配，启动JVM进程，再运行Task，一系列的过程比较繁琐，本身数据量并不大，提交到YARN运行返回会导致性能较差的问题。\",\"Hive为了解决这个问题，延用了MapReduce中的设计，提供本地计算模式，允许程序不提交给YARN，直接在本地运行，以便于提高小数据量程序的性能。\",\"配置\",\"-- 开启本地模式 set hive.exec.mode.local.auto = true; \",\"使用条件：\",\"输入文件的总大小小于：hive.exec.mode.local.auto.inputbytesmax(128MB by default)\",\"map-task个数小于：hive.exec.mode.local.auto.tasks.max(4 by default)\",\"reduce task的个数只能为1或者0\"]},\"445\":{\"h\":\"3.2.2 JVM重用\",\"t\":[\"Hadoop3不再支持\",\"Hadoop默认会为每个Task启动一个JVM来运行，而在JVM启动时内存开销大；\",\"Job数据量大的情况，如果单个Task数据量比较小，也会申请JVM，这就导致了资源紧张及浪费的情况；\",\"JVM重用可以使得JVM实例在同一个job中重新使用N次，当一个Task运行结束以后，JVM不会进行释放，而是继续供下一个Task运行，直到运行了N个Task以后，就会释放；\",\"N的值可以在Hadoop的mapred-site.xml文件中进行配置，通常在10-20之间。\",\"-- Hadoop3之前的配置，在mapred-site.xml中添加以下参数 -- Hadoop3中已不再支持该选项 mapreduce.job.jvm.numtasks=10 \"]},\"446\":{\"h\":\"3.2.3 并行执行\",\"t\":[\"没有依赖的stage并行执行\",\"Hive在实现HQL计算运行时，会解析为多个Stage，有时候Stage彼此之间有依赖关系，只能挨个执行，但是在一些别的场景下，很多的Stage之间是没有依赖关系的；\",\"例如Union语句，Join语句等等，这些Stage没有依赖关系，但是Hive依旧默认挨个执行每个Stage，这样会导致性能非常差，我们可以通过修改参数，开启并行执行，当多个Stage之间没有依赖关系时，允许多个Stage并行执行，提高性能。\",\"-- 开启Stage并行化，默认为false SET hive.exec.parallel=true; -- 指定并行化线程数，默认为8 SET hive.exec.parallel.thread.number=16; \"]},\"447\":{\"h\":\"3.3 Join优化\",\"t\":[\"Join是数据分析处理过程中必不可少的操作，Hive同样支持Join的语法；\",\"Hive Join的底层是通过MapReduce来实现的，Hive实现Join时，为了提高MapReduce的性能，提供了多种Join方案来实现；\",\"例如适合小表Join大表的Map Join，大表Join大表的Reduce Join，以及大表Join的优化方案Bucket Join等。\"]},\"448\":{\"h\":\"3.3.1 Map Join\",\"t\":[\"Map端Join的关键是将小表文件做一个分布式缓存（distributed cache），把他发送到各台机器上，再启动一个或多个MapTask，去读大表的数据，分别与缓存之间进行关联，关联的结果直接输出\",\"应用场景：适合于小表join大表或者小表Join小表\",\"原理：将小的那份数据给每个MapTask的内存都放一份完整的数据，大的数据每个部分都可以与小数据的完整数据进行join。底层不需要经过shuffle，需要占用内存空间存放小的数据文件\",\"尽量使用Map Join来实现Join过程，Hive中默认自动开启了MapJoin：hive.auto.convert.join=true\",\"Hive中小表的大小限制\",\"-- 2.0版本之前的控制属性 hive.mapjoin.smalltable.filesize=25M -- 2.0版本开始由以下参数控制 hive.auto.convert.join.noconditionaltask.size=512000000 \"]},\"449\":{\"h\":\"3.3.2 Reduce Join\",\"t\":[\"应用场景：适合于大表Join大表\",\"原理：将两张表的数据在shuffle阶段利用shuffle的分组来将数据按照关联字段进行合并。必须经过shuffle，利用Shuffle过程中的分组来实现关联\",\"使用：Hive会自动判断是否满足Map Join，如果不满足Map Join，则自动执行Reduce Join\"]},\"450\":{\"h\":\"3.3.3 Bucket Join\",\"t\":[\"应用场景：适合于大表Join大表\",\"原理：将两张表按照相同的规则将数据划分。根据对应的规则的数据进行join。减少了比较次数，提高了性能\",\"使用Bucket Join\",\"语法：clusterd by colName\",\"参数：set hive.optimize.bucketmapjoin = **true**;\",\"要求：分桶字段 = Join字段 ，桶的个数相等或者成倍数\",\"使用Sort Merge Bucket Join（SMB）\",\"基于有序数据的Join\",\"语法：distribute by colName sorted by colName\",\"参数：见下面\",\"要求：分桶字段 = Join字段 = 排序字段 ，桶的个数相等或者成倍数\",\"set hive.optimize.bucketmapjoin = true; set hive.auto.convert.sortmerge.join=true; set hive.optimize.bucketmapjoin.sortedmerge = true; set hive.auto.convert.sortmerge.join.noconditionaltask=true; \"]},\"451\":{\"h\":\"3.4 优化器\"},\"452\":{\"h\":\"3.4.1 背景\",\"t\":[\"出现原因：当一个程序中如果有一些操作彼此之间有关联性，是可以在一个MapReduce中实现的，但是Hive会不智能的选择，Hive会使用两个MapReduce来完成这两个操作。\",\"例如：当我们执行 select …… from table group by id order by id desc。该SQL语句转换为MapReduce时，我们可以有两种方案来实现：\",\"方案一：第一个MapReduce做group by，经过shuffle阶段对id做分组；第二个MapReduce对第一个MapReduce的结果做order by，经过shuffle阶段对id进行排序\",\"因为都是对id处理，可以使用一个MapReduce的shuffle既可以做分组也可以排序\"]},\"453\":{\"h\":\"3.4.2 使用\",\"t\":[\"在这种场景下，Hive会默认选择用第一种方案来实现，这样会导致性能相对较差\",\"可以在Hive中开启关联优化，对有关联关系的操作进行解析时，可以尽量放在同一个MapReduce中实现。\",\"配置：\",\"set hive.optimize.correlation=true; \"]},\"454\":{\"h\":\"3.4.3 优化器介绍\"},\"455\":{\"h\":\"背景\",\"t\":[\"Hive默认的优化器在解析一些聚合统计类的处理时，底层解析的方案有时候不是最佳的方案。\",\"例如当前有一张表【共1000条数据】，id构建了索引，id =100值有900条。需求：查询所有id = 100的数据，SQL语句为：select * from table where id = 100;\",\"方案一：由于id这一列构建了索引，索引默认的优化器引擎RBO，会选择先从索引中查询id = 100的值所在的位置，再根据索引记录位置去读取对应的数据，但是这并不是最佳的执行方案。\",\"方案二：有id=100的值有900条，占了总数据的90%，这时候是没有必要检索索引以后再检索数据的，可以直接检索数据返回，这样的效率会更高，更节省资源，这种方式就是CBO优化器引擎会选择的方案。\"]},\"456\":{\"h\":\"RBO\",\"t\":[\"rule basic optimise：基于规则的优化器，根据设定好的规则来对程序进行优化\"]},\"457\":{\"h\":\"CBO\",\"t\":[\"cost basic optimise：基于代价的优化器，根据不同场景所需要付出的代价来合适选择优化的方案\",\"对数据的分布的信息【数值出现的次数，条数，分布】来综合判断用哪种处理的方案是最佳方案\",\"Hive中支持RBO与CBO这两种引擎，默认使用的是RBO优化器引擎。\",\"很明显CBO引擎更加智能，所以在使用Hive时，我们可以配置底层的优化器引擎为CBO引擎。\",\"set hive.cbo.enable=true; set hive.compute.query.using.stats=true; set hive.stats.fetch.column.stats=true; \"]},\"458\":{\"h\":\"Anayze分析器\",\"t\":[\"CBO计算代价的手段\",\"功能：用于提前运行一个MapReduce程序将表或者分区的信息构建一些元数据【表的信息、分区信息、列的信息】，搭配CBO引擎一起使用\",\"用法：\",\"-- 分析优化器 use tb_part; -- 构建表中分区数据的元数据信息 ANALYZE TABLE tb_login_part PARTITION(logindate) COMPUTE STATISTICS; -- 构建表中列的数据的元数据信息 ANALYZE TABLE tb_login_part COMPUTE STATISTICS FOR COLUMNS userid; -- 查看构建的列的元数据 desc formatted tb_login_part userid; \"]},\"459\":{\"h\":\"3.5 谓词下推（PPD）\",\"t\":[\"谓词：用来描述或判定客体性质、特征或者客体之间关系的词项。比如\\\"3 大于 2\\\"中\\\"大于\\\"是一个谓词。\",\"谓词下推Predicate Pushdown（PPD）基本思想：将过滤表达式尽可能移动至靠近数据源的位置，以使真正执行时能直接跳过无关的数据。简单点说就是在不影响最终结果的情况下，尽量将过滤条件提前执行。\",\"Hive中谓词下推后，过滤条件会下推到map端，提前执行过滤，减少map到reduce的传输数据，提升整体性能。\",\"开启参数：hive.optimize.ppd=**true**;\"]},\"460\":{\"h\":\"3.5.1 示例\",\"t\":[\"-- 使用了谓词下推，先过滤再join select a.id,a.value1,b.value2 from table1 a join (select b.* from table2 b where b.ds>='20181201' and b.ds<'20190101') c on (a.id=c.id) select a.id,a.value1,b.value2 from table1 a join table2 b on a.id=b.id where b.ds>='20181201' and b.ds<'20190101' \"]},\"461\":{\"h\":\"3.5.2 规则\",\"t\":[\"对于Join(Inner Join)、Full outer Join，条件写在on后面，还是where后面，性能上面没有区别；\",\"对于Left outer Join ，右侧的表写在on后面、左侧的表写在where后面，性能上有提高；\",\"对于Right outer Join，左侧的表写在on后面、右侧的表写在where后面，性能上有提高；\",\"当条件分散在两个表时，谓词下推可按上述结论2和3自由组合。\"]},\"462\":{\"h\":\"3.6 数据倾斜\",\"t\":[\"数据倾斜的现象是，当提交运行一个程序时，这个程序的大多数的Task都已经运行结束了，只有某一个Task一直在运行，迟迟不能结束，导致整体的进度卡在99%或者100%，这时候就可以判定程序出现了数据倾斜的问题。\"]},\"463\":{\"h\":\"3.6.1 group by, count(distinct)时的倾斜\",\"t\":[\"当程序中出现group by或者count（distinct）等分组聚合的场景时，如果数据本身是倾斜的，根据MapReduce的Hash分区规则，肯定会出现数据倾斜的现象。\",\"根本原因是因为分区规则导致的，所以可以通过以下几种方案来解决group by导致的数据倾斜的问题。\"]},\"464\":{\"h\":\"方案一：开启Map端聚合\",\"t\":[\"hive.map.aggr=true;\",\"通过减少shuffle数据量和Reducer阶段的执行时间，避免每个Task数据差异过大导致数据倾斜\"]},\"465\":{\"h\":\"方案二：实现随机分区\",\"t\":[\"select from table distribute by rand();\",\"distribute by用于指定底层按照哪个字段作为Key实现分区、分组等\",\"通过rank函数随机值实现随机分区，避免数据倾斜\"]},\"466\":{\"h\":\"方案三：数据倾斜时自动负载均衡\",\"t\":[\"hive.groupby.skewindata=true;\",\"开启该参数以后，当前程序会自动通过两个MapReduce来运行\",\"第一个MapReduce自动进行随机分布到Reducer中，每个Reducer做部分聚合操作，输出结果\",\"第二个MapReduce将上一步聚合的结果再按照业务（group by key）进行处理，保证相同的分布到一起，最终聚合得到结果\"]},\"467\":{\"h\":\"3.6.2 join时的倾斜\",\"t\":[\"Join操作时，如果两张表比较大，无法实现Map Join，只能走Reduce Join，那么当关联字段中某一种值过多的时候依旧会导致数据倾斜的问题；\",\"面对Join产生的数据倾斜，核心的思想是尽量避免Reduce Join的产生，优先使用Map Join来实现；\",\"但往往很多的Join场景不满足Map Join的需求，那么可以以下几种方案来解决Join产生的数据倾斜问题\"]},\"468\":{\"h\":\"方案一：提前过滤，将大数据变成小数据，实现Map Join\",\"t\":[\"也就是谓词下推\"]},\"469\":{\"h\":\"方案二：使用Bucket Join\",\"t\":[\"如果使用方案一，过滤后的数据依旧是一张大表，那么最后的Join依旧是一个Reduce Join\",\"这种场景下，可以将两张表的数据构建为桶表，实现Bucket Map Join，避免数据倾斜\"]},\"470\":{\"h\":\"方案三：使用Skew Join\",\"t\":[\"Skew Join是Hive中一种专门为了避免数据倾斜而设计的特殊的Join过程\",\"这种Join的原理是将Map Join和Reduce Join进行合并，如果某个值出现了数据倾斜，就会将产生数据倾斜的数据单独使用Map Join来实现\",\"其他没有产生数据倾斜的数据由Reduce Join来实现，这样就避免了Reduce Join中产生数据倾斜的问题\",\"最终将Map Join的结果和Reduce Join的结果进行Union合并\",\"原理：\",\"配置：\",\"-- 开启运行过程中skewjoin set hive.optimize.skewjoin=true; -- 如果这个key的出现的次数超过这个范围 set hive.skewjoin.key=100000; -- 在编译时判断是否会产生数据倾斜 set hive.optimize.skewjoin.compiletime=true; -- 不合并，提升性能 set hive.optimize.union.remove=true; -- 如果Hive的底层走的是MapReduce，必须开启这个属性，才能实现不合并 set mapreduce.input.fileinputformat.input.dir.recursive=true; \"]},\"471\":{\"h\":\"4. Hive3新特性\"},\"472\":{\"h\":\"4.1 Hive on Tez\",\"t\":[\"一般都使用Spark了，所以了解就行\"]},\"473\":{\"h\":\"4.2 Hive LLAP更新\",\"t\":[\"只能与Tez配套使用，了解\"]},\"474\":{\"h\":\"4.3 Metastore独立模式\",\"t\":[\"从Hive 3.0开始，Metastore可以在不安装Hive其他部分的情况下单独运行，作为一个单独的发行版提供，用于实现允许其他非Hive的系统，例如Spark、Impala等轻松地与Metastore集成。\",\"目前来说为了方便起见，依旧建议将Metastore放在Hive中，一起安装部署。\"]},\"475\":{\"h\":\"如何从海量数据中找出高频词？\",\"t\":[\"如何从海量数据中找出高频词？\"]},\"476\":{\"h\":\"题目描述\",\"t\":[\"假如有一个1G大小的文件，文件里每一行是一个词，每个词的大小不超过16byte，要求返回出现频率最高的100个词。内存大小限制是10M\"]},\"477\":{\"h\":\"解法1（存在问题）\",\"t\":[\"由于内存限制，我们无法直接将大文件的所有词一次性读到内存中。\",\"可以使用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于10M，进而直接将单个小文件读取到内存中处理。\",\"第一步，首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 500，将结果为i的词存放到文件f(i)中，遍历结束后，可以得到500个小文件，每个小文件的大小为2M左右；\",\"第二步，接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key是词，value是该词出现的频率。\",\"对于遍历到的词x，如果在map中不存在，则执行 map.put(x, 1)。\",\"若存在，则执行 map.put(x, map.get(x)+1)，将该词出现的次数加1。\",\"第三步，在第二步中找出了每个文件出现频率最高的100个词之后，通过维护一个小顶堆来找出所有小文件中出现频率最高的100词。\",\"具体方法是，遍历第一个文件，把第一个文件中出现频率最高的100个词构造成小顶堆。\",\"如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构造好有100个结点的小顶堆为止。\",\"继续遍历其他小文件，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整此堆为小顶堆。\",\"当遍历完所有小文件后，这个小顶堆中的词就是出现频率最高的100词。\",\"总结一下，这种解法的主要思路如下：\",\"采用分治的思想，进行哈希取余\",\"使用HashMap统计每个小文件单词出现的频次\",\"使用小顶堆，遍历步骤2中的小文件，找出词频top100的词\",\"但是很容易可以发现问题，在第二步中，如果这个1G的大文件中有某个词词频过高，可能导致小文件大小超过10m。这种情况下该怎么处理呢？\",\"接下来看另外一种解法。\"]},\"478\":{\"h\":\"解法2\",\"t\":[\"第一步：使用多路归并排序对大文件进行排序，这样相同的单词肯定是紧挨着的\",\"多路归并排序对大文件进行排序的步骤如下：\",\"将文件按照顺序切分成大小不超过2m的小文件，总共500个小文件\",\"使用10MB内存分别对 500 个小文件中的单词进行排序\",\"使用一个大小为500大小的堆，对500个小文件进行多路排序，结果写到一个大文件中\",\"其中第三步，对500个小文件进行多路排序的思路如下：\",\"初始化一个小顶堆，大小就是有序小文件的个数500。堆中的每个节点存放每个有序小文件对应的输入流。\",\"按照每个有序文件中的下一行数据对所有文件输入流进行排序，单词小的输入文件流放在堆顶。\",\"拿出堆顶的输入流，并其下一行数据写入到最终排序的文件中，如果拿出来的输入流中还有数据的话，那么将这个输入流再一次添加到栈中。否则说明该文件输入流中没有数据了，那么可以关闭这个流。\",\"循环这个过程，直到所有文件输入流都没有数据为止。\",\"第二步：\",\"初始化一个100个节点的小顶堆，用于保存100个出现频率最多的单词\",\"遍历整个文件，一个单词一个单词的从文件中取出来，并计数\",\"等到遍历的单词和上一个单词不同的话，那么上一个单词及其频率如果大于堆顶的词的频率，那么放在堆中，否则不放\",\"最终，小顶堆中就是出现频率前100的单词了。\",\"解法2相对解法1，更加严谨，如果某个词词频过高或者整个文件都是同一个词的话，解法1不适用。\"]},\"479\":{\"h\":\"数据库开发规范\",\"t\":[\"本文摘录自阿里巴巴Java开发手册MySQL数据库篇，目的是为了加强记忆方便查询\"]},\"480\":{\"h\":\"建表规约\",\"t\":[\"【强制】\",\"表达是否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。\",\"说明：任何字段如果为非负数，必须是unsigned。\",\"正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。\",\"【强制】\",\"表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\",\"说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。\",\"正例：aliyun_admin, rdc_config, level3_name\",\"反例：AliyunAdmin, rdcConfig, level_3_name\",\"【强制】\",\"表名不使用复数名词。\",\"说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。\",\"【强制】\",\"禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。\",\"【强制】\",\"主键索引名为pk字段名；唯一索引名为uk字段名；普通索引名则为idx字段名。\",\"说明：pk即primary key；uk即unique key；idx即index\",\"【强制】\",\"小数类型为decimal，禁止使用float和double。\",\"说明：float和double在存储的时候，存在精度损失问题，很可能在值比较时，得到不正确的结果。如果存储的数据范围查过decimal的范围，建议将数据拆成整数和小数分开存储。\",\"【强制】\",\"如果存储的字符串长度几乎相等，使用char定长字符串类型。\",\"【强制】\",\"varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它索引效率。\",\"【强制】\",\"表必备三字段：id, gmt_create, gmt_modified。\",\"说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。（其实得根据主键类型进行动态判断）。gmt_create, gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。\",\"【推荐】\",\"表的命名最好是加上“业务名称_表的作用\\\"。\",\"正例：alipay_task / force_project / trade_config\",\"【推荐】\",\"库名与应用名称尽量一致。\",\"【推荐】\",\"如果修改字段含义或对应字段表示的状态追加时，需要及时更新字段注释。\",\"【推荐】\",\"字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\",\"1）不是频繁修改的字段。\",\"2） 不是varchar超长字段，更不能是text字段。\",\"正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。\",\"【推荐】\",\"单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。\",\"说明：如果预计三年后数据量根本达不到这个级别，请不要在创建表时就分库分表。\",\"【参考】\",\"合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\",\"正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\",\"对象\",\"年龄区间\",\"类型\",\"字节\",\"人\",\"150岁之内\",\"unsigned tinyint\",\"1\",\"龟\",\"数百岁\",\"unsigned smallint\",\"2\",\"恐龙化石\",\"数千万岁\",\"unsigned int\",\"4\",\"太阳\",\"约50亿年\",\"unsigned bigint\",\"8\"]},\"481\":{\"h\":\"索引规约\",\"t\":[\"【强制】\",\"业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。\",\"说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\",\"【强制】\",\"超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\",\"说明：即使双表join也要注意表索引、SQL性能。\",\"【强制】\",\"在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\",\"说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\",\"【强制】\",\"页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\",\"说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\",\"【推荐】\",\"如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。\",\"正例：where a=? and b=? order by c; 索引：a_b_c\",\"反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。\",\"【推荐】\",\"利用覆盖索引来进行查询操作，避免回表。\",\"说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\",\"正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。\",\"【推荐】\",\"利用延迟关联或者子查询优化超多分页场景。\",\"说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。\",\"正例：先快速定位需要获取的id段，然后再关联：\",\"SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id \",\"【推荐】\",\"SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。\",\"说明：\",\"1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。\",\"反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。\",\"【推荐】\",\"建组合索引的时候，区分度最高的在最左边。\",\"正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。\",\"说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。\",\"【推荐】\",\"防止因字段类型不同造成的隐式转换，导致索引失效。\",\"【参考】\",\"创建索引时避免有如下极端误解： 1）宁滥勿缺。认为一个查询就需要建一个索引。 2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\"]},\"482\":{\"h\":\"SQL语句\",\"t\":[\"【强制】\",\"不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。\",\"说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。\",\"【强制】\",\"count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。\",\"说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。\",\"【强制】\",\"当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。\",\"正例：可以使用如下方式来避免sum的NPE问题：\",\"SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; \",\"【强制】\",\"使用ISNULL()来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL。\",\"1） NULL<>NULL的返回结果是NULL，而不是false。 2） NULL=NULL的返回结果是NULL，而不是true。 3） NULL<>1的返回结果是NULL，而不是true。\",\"正例：可以使用如下方式来避免sum的NPE问题：\",\"SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; \",\"【强制】\",\"在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。\",\"【强制】\",\"不得使用外键与级联，一切外键概念必须在应用层解决。\",\"说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\",\"【强制】\",\"禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\",\"【强制】\",\"数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。\",\"【推荐】\",\"in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。\",\"【参考】\",\"如果有全球化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。\",\"说明：\",\"SELECT LENGTH(“轻松工作”)； 返回为12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为4 \",\"【参考】\",\"TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。\",\"说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\"]},\"483\":{\"h\":\"ORM映射\",\"t\":[\"【强制】\",\"在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\",\"说明：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。\",\"【强制】\",\"POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。\",\"说明：参见定义POJO类以及数据库字段定义规定第8条，在POJO类中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。\",\"【强制】\",\"不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\",\"说明：配置映射关系，使字段与DO类解耦，方便维护。\",\"【强制】\",\"sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。\",\"【强制】\",\"iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。\",\"说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。\",\"正例：\",\" Map<String, Object> map = new HashMap<String, Object>(); map.put(\\\"start\\\", start); map.put(\\\"size\\\", size); \",\"【强制】\",\"不允许直接拿HashMap与Hashtable作为查询结果集的输出。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【强制】\",\"更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【推荐】\",\"不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【参考】\",\"@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\",\"【参考】\",\"<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。\"]},\"484\":{\"h\":\"MySQL\"},\"485\":{\"h\":\"说说对MySQL索引的理解\",\"t\":[\"索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有的索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB的存储引擎只支持BTREE索引，MEMORY存储引擎支持HASH和BTREE索引。\",\"优点：\",\"通过创建唯一索引，可以保证数据库表中每一行数据的唯一性\",\"可以大大加快查询速度，这也是创建索引的主要原因\",\"在实现数据的参考完整性方面，可以加速表和表之间的连接\",\"在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间\",\"缺点：\",\"创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加\",\"索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸\",\"当对表中的数据进行增删改操作的时候，索引也要进行动态维护，这样降低了数据的维护速度\"]},\"486\":{\"h\":\"为了减少IO，索引树会一次性加载吗\",\"t\":[\"数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G\",\"当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的就是逐一加载每个磁盘页（数据页），因为数据页对应着索引树的节点\"]},\"487\":{\"h\":\"B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO（为什么索引使用B+树）\",\"t\":[\"InnoDB存储引擎中页的大小为16 KB，一般表的逐渐类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4-8个字节，也就是说一个页（B+tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，换算出一页大概能存储1000条数据，深度为3可以存储1000*1000*1000=10亿条数据。。。\"]},\"488\":{\"h\":\"为什么B+树比B树更适合做索引\",\"t\":[\"B+树的磁盘读写代价更低\",\"B+树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。\",\"B+树的查询效率更加稳定\",\"由于非叶节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一数据的查询效率相当。而B-树非叶子节点也存储数据，可能需要中序遍历。\",\"在范围查询上，B+树的效率也比B树高\",\"B+树的关键字都出现在叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成范围查询。\"]},\"489\":{\"h\":\"InnoDB为什么不建议用过长的字段作为主键\",\"t\":[\"所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大\"]},\"490\":{\"h\":\"InnoDB为什么使用自增主键是一个很好的选择\",\"t\":[\"InnoDB数据文件本身是一颗B+树，非单调的主键会造成在插入新纪录时，数据文件为了维持B+树的特性而频繁的分裂调整（页分裂）\"]},\"491\":{\"h\":\"Hash结构效率高，那为什么还要使用B+树索引呢\",\"t\":[\"Hash索引仅能满足 = , <> , IN 查询。如果进行范围查询，哈希索引的时间复杂度会退化为O(n)。而树型的依然能够保持O(log2N)\",\"Hash索引数据存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。\",\"对于联合索引的情况，Hash值是将联合索引键合并起来一起计算的，无法对单独的一个键或者几个索引键进行判断。\",\"对于等值查询来说，通常Hash索引的效率更高，不过当索引列的重复值过多，由于Hash冲突效率就会降低。\"]},\"492\":{\"h\":\"索引的分类\",\"t\":[\"从功能逻辑上说，索引主要有4种，分别是普通索引、唯一索引、主键索引和全文索引\",\"从物理实现方式：聚簇索引和非聚簇索引\",\"作用字段个数：单列索引和联合索引\"]},\"493\":{\"h\":\"哪些情况适合创建索引\",\"t\":[\"字段的数值有唯一性的限制\",\"业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。\",\"频繁作为 WHERE 查询条件的字段\",\"某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。 尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\",\"经常 GROUP BY 和 ORDER BY 的列\",\"索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。 如果待排序的列有多个，那么可以在这些列上建立 组合索引 。\",\"UPDATE、DELETE 的 WHERE 条件列\",\"对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。 如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\",\"DISTINCT 字段需要创建索引\",\"有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\",\"索引列按递增的顺序 进行排序。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\",\"多表 JOIN 连接操作时，创建索引注意事项\",\"首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\",\"其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\",\"最后， 对用于连接的字段创建索引，并且该字段在多张表中的 类型必须一致 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\",\"使用列数据类型小的字段创建索引\",\"使用字符串前缀创建索引\",\"【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。\",\"说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。\",\"区分度（散列性）高的适合作为索引\",\"数据相似性大的就不适合建立索引，如：男女性别\",\"使用最频繁的字段放到联合索引左侧\",\"这样也可以较少的建立一些索引。同时，由于\\\"最左前缀原则\\\"，可以增加联合索引的使用率。\",\"在多个字段需要创建索引的情况下，联合索引优于单值\"]},\"494\":{\"h\":\"哪些情况不适合创建索引\",\"t\":[\"在where中使用不到的字段\",\"数据量小的表\",\"有大量重复数据的列\",\"避免经常更新的表创建过多的索引\",\"不建议使用无序的值作为索引\",\"例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。\",\"删除不再使用或很少使用的索引\",\"不要定义冗余或重复的索引。\"]},\"495\":{\"h\":\"索引下推\",\"t\":[\"Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。\",\"示例：\",\"alert table tb_people add index `zip_last_first` (`zipcode`, `lastname`, `firstname`) select * from people where zipcode = '000001' and lastname like '%张%' and address like '%北京市%' \",\"上述添加了一个联合索引。select语句只有zipcode命中了联合索引，lastname因为%开头并不能命中，但是因为联合索引中有lastname，所以会先在联合索引中通过lastname进行过滤，然后再进行回表操作。这就是索引下推。\"]},\"496\":{\"h\":\"EXISTS和IN的区分\",\"t\":[\"如何选择需要看表的大小。小表驱动大表。\",\"比如\",\"select * from A where cc in (select cc from B) select * from A where exists (select cc from B where B.cc = A.cc) \",\"当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，\",\"for i in A for j in B if j.cc == i.cc then... \",\"IN的逻辑\",\"for i in B for j in A if j.cc == i.cc then... \"]},\"497\":{\"h\":\"COUNT(*), COUNT(1)和COUNT(具体字段)\",\"t\":[\"COUNT(*)和COUNT(1)都是对结果进行COUNT，COUNT(*)和COUNT(1)本质上并没有区别。\",\"如果采用的是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count的值，而一致性则由表级锁来保证。如果是InnoDB，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，O(n)的复杂度。\",\"在InnoDB中如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引。对于COUNT(*)和COUNT(1)来说，他们不需要查找具体的行，只是统计行数，系统会自动采用占用空间小的二级索引来进行统计。如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。\"]},\"498\":{\"h\":\"关于SELECT(*)\",\"t\":[\"在表查询中，建议明确字段，不要使用 *作为查询的字段列表，推荐受用具体字段查询。\",\"原因：\",\"mysql在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大消耗资源和时间。\",\"无法使用覆盖索引\"]},\"499\":{\"h\":\"多使用COMMIT\",\"t\":[\"只要有可能，在程序中尽量多使用COMMIT，这样程序的性能能够得到提高，需求也会因为COMMIT所释放的资源而减少。\",\"COMMIT所释放的资源：\",\"回滚段上用于恢复数据的信息\",\"被程序语句获得的锁\",\"redo / undo log buffer中的空间\",\"管理上述3种资源种的内部花费\"]},\"500\":{\"h\":\"主键如何设计\"},\"501\":{\"h\":\"自增ID的问题\",\"t\":[\"可靠性不高：存在自增ID回溯的问题，这个问题直到8.0才解决\",\"安全性不高：对外暴露的接口容易暴露信息。比如/User/1\",\"性能差：自增ID的性能较差，需要在数据库服务器端生成\",\"交互多：业务需要二外执行一次类似last_insert_id()的函数才能知道插入的子增值。\",\"局部唯一性：分布式问题\"]},\"502\":{\"h\":\"推荐的主键设计\",\"t\":[\"对于核心业务，主键的设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。推荐使用UUID。\",\"UUID的特点：\",\"全局唯一，占用36字节，数据无序，插入性能差。\",\"UUID如下图所示：\",\"改造UUID\",\"若将时间高低位互换，则时间就是单调递增的了。MySQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。\"]},\"503\":{\"h\":\"谈谈你对MVCC的了解\",\"t\":[\"MVCC只存在读已提交和可重复读的情况下，两种情况下生成ReadView的机制不一样。\",\"在读已提交中，每次读操作都会生成一个ReadView所以会出现不可重复读的情况。对于可重复读，在一次事务中，只有第一次读操作会生成ReadView，所以不会出现可重复读，也不会出现幻读。\",\"MySQL事务隔离级别和MVCC - 掘金 (juejin.cn)\",\"InnoDB的默认隔离级别是REPEATABLE READ，RR解决了脏读、不可重复读和幻读的问题。注意不是到了串行化才解决了幻读， RR通过MVCC快照读的思想就已经解决了幻读的问题。（这点有待商榷） MVCC的意思是多版本并发控制。它最大的优点就是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下奇数以及数据结构：\",\"隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id，指向undo log的指针等。\",\"基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。\",\"ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记作事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。\"]},\"504\":{\"h\":\"WHERE和HAVING的区别\",\"t\":[\"WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数\",\"HAVING是一个过滤声明，是在查询结果返回集以后对查询结果进行过滤的操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。\",\"从性能上来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。\"]},\"505\":{\"h\":\"数据库索引失效了怎么办\",\"t\":[\"可以采用一下几种方式，来避免索引失效\",\"使用联合索引时，要遵循“最左前缀”原则\",\"不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描\",\"尽量使用覆盖索引，减少select *使用能减少回表的次数\",\"MySQL在使用不等于的时候无法使用索引会导致全表扫描\",\"LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描\",\"字符串不加单引号会导致索引失效（发生了索引列的隐式转换）\",\"少用or，用or会导致索引失效\"]},\"506\":{\"h\":\"事务的四大特性以及如何实现\",\"t\":[\"原子性：原子性指整个数据库事务是不可分割的工作单位。只有事务中的数据库操作都执行成功，整个事务才算执行成功。事务中任何一个SQL语句执行失败，那么之前已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。\",\"一致性：一致性是指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\",\"隔离性：事务与事务之间的操作时互相隔离互不干扰的。\",\"持久性：事务一旦提交，其结果就是永久的，即使发生宕机等故障，数据库也能将数据恢复。\",\"原子性实现原理\",\"实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的SQL语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或者调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。\",\"undo log属于逻辑日志，它记录的是SQL执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。\",\"持久性实现原理\",\"InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，首先会从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中。\",\"Buffer Pool的使用大大提高了读写数据的效率，但是也带来了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。\",\"于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证数据不在因MySQL宕机而丢失，从而满足了持久性要求。\",\"既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘要快呢?\",\"将Buffer Pool中的数据写入磁盘属于随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO\",\"将Buffer Pool中的数据写入磁盘是以数据页为单位进行的，MySQL默认页为16KB，一个页上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。\",\"隔离性实现原理\",\"隔离性追求的是并发情形下事务之间互不干扰。\",\"第一方面，两个事务同时写：锁机制保证隔离性\",\"隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务执行期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。\",\"按照粒度，锁可以分为表锁、行锁以及其他位于二至之间的锁（页锁）。表锁在操作数据时会锁定整张表，并发性能较差。行锁则之锁定需要操作的数据，并发性能好。但是由于加锁本身也需要消耗资源，因此在锁定数据较多的情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且处于性能考虑，绝大多数情况下使用的是行锁。\",\"第二方面，一个事务读，一个事务写时，MVCC保证隔离性\",\"[0x10. 谈谈你对MVCC的了解](#0x10. 谈谈你对MVCC的了解)\",\"一致性实现原理\",\"一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性都是为了保证数据库状态的一致性。此外，除数据库层面的保障，一致性的实现也需要在应用层面进行保障。\"]},\"507\":{\"h\":\"MySQL的悲观锁和乐观锁\",\"t\":[\"悲观锁\",\"悲观锁是一种思想，对数据被其他事务修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排他性。\",\"乐观锁\",\"乐观锁也是一种思想，对数据被其他事务修改持乐观态度，属于小概率事件，不采用数据库本身的锁机制，而是通过程序来实现（CAS）。在程序上，我们可以使用版本号机制或时间戳机制来实现\",\"乐观锁的版本号机制\",\"在表中设计一个版本号字段version，第一次读的时候会获取version的取值。然后对数据进行更新或删除操作时会对当前字段的version进行加一操作。如果此时已经有事务对这条数据进行了更改，修改就不会成功。\",\"乐观锁的时间戳机制\",\"时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。\"]},\"508\":{\"h\":\"根据锁的类型分类\",\"t\":[\"需要注意的是对于InnoDB引擎来说，共享锁和排他锁既可以加在表上，也可以加在行上\",\"共享锁（S Lock）：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，互相不阻塞\",\"排他锁（X Lock）：当前写操作没有完成前，他会阻断其他共享锁和排他锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源\",\"X\",\"S\",\"X\",\"不兼容\",\"不兼容\",\"S\",\"不兼容\",\"兼容\"]},\"509\":{\"h\":\"根据锁的粒度进行分类\",\"t\":[\"可以分为表锁，页锁和行锁\"]},\"510\":{\"h\":\"表锁\",\"t\":[\"意向锁\",\"如果我们给某一行数据加上了排他锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人给它上过排他锁了。\",\"不这么做的话，想上锁的那个事务需要遍历有没有行锁。\",\"意向共享锁：事务有意向对表中的某些行加共享锁，就会在更大一级的空间加上意向共享锁。\",\"意向排他锁：事务有意向对表中的某些行加排他锁，就会在更大一级的空间加上意向排他锁。\",\"意向共享锁（IS）\",\"意向排他锁（IX）\",\"意向共享锁（IS）\",\"兼容\",\"兼容\",\"意向排他锁（IX）\",\"兼容\",\"兼容\",\"意向共享锁（IS）\",\"意向排他锁（IX）\",\"共享锁（S）\",\"兼容\",\"不兼容\",\"排他锁（X）\",\"不兼容\",\"不兼容\",\"自增锁\",\"AUTO-INC锁是当想使用含有AUTO-INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。\",\"元数据锁\",\"当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。\",\"读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显示使用，在访问一个表的时候会被自动加上。\"]},\"511\":{\"h\":\"行锁\",\"t\":[\"行锁又称为记录锁，顾名思义就是锁住某一行。需要注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。\",\"记录锁（Record Locks）\",\"可以理解为行级别的共享锁和排他锁\",\"间隙锁（Gap Locks）\",\"锁定一个范围，不包含记录本身（开区间），为了防止插入幻影记录而提出的\",\"临键锁（Next-Key Locks）\",\"Record Locks + Gap Locks\",\"锁定一个范围包含记录本身（闭区间）\"]},\"512\":{\"h\":\"InnoDB中行级锁是怎么实现的\",\"t\":[\"InnoDB行级锁是通过给索引上的索引项加锁来实现的。\"]},\"513\":{\"h\":\"数据库死锁问题以及解决办法\",\"t\":[\"死锁是指两个或两个以上的事务在执行过程中，因争夺所资源而造成的一种相互等待的现象。若无外力作用，事务都无法推进下去。\",\"解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续运行。\",\"除了超时机制，当前数据库还普遍采用wait-for graph（等待图）的方式来进行死锁检测。较之被动的超时方案，这时一种主动的死锁检测方法。InnoDB引擎也采用这种方法。wait-for graph要求数据库保存一下两种信息：\",\"锁的信息链表\",\"事务等待链表\",\"通过上述链表可以构造出一张图，若这个途中存在回路，就代表存在死锁。\"]},\"514\":{\"h\":\"Redis\"},\"515\":{\"h\":\"Redis常见数据结构以及使用场景\",\"t\":[\"string\",\"介绍：虽然Reids是C语言编写的，但是其string底层并没有采用C的字符串，而是自己构建了一种简单动态字符串\",\"常用命令：set，get，strlen，exists，decr，incr，setex等\",\"应用场景：一般用于需要计数的场景，比如用户的访问次数，热点文章的点赞数和转发数等等\",\"list\",\"介绍：底层为双向链表\",\"常用命令：rpush，lpush，rpop，lpop，lrange，llen等\",\"应用场景：消息队列\",\"hash\",\"介绍：类似于JDK1.8之前的HashMap，内部实现也差不多是数组+链表。\",\"常用命令：hset，hmset，hexists，hget，hgetall，hkeys，hvals等\",\"应用场景：系统中对象数据的存储\",\"set\",\"介绍：类似于Java中的HashSet\",\"常用命令：sadd，spop，smembers，sismember，scard，sinterstore，sunion等\",\"应用场景：集合运算，比如集合的交集和并集\",\"sorted set\",\"介绍：基于跳表实现，和set相比增加了一个权重参数score，使得集合中的元素可以根据score进行有序排列。\",\"常用命令：zadd，zcard，zscore，zrange，zrevrange，zrem等\",\"应用场景：需要对数据根据某个权重进行排序的场景。比如直播间礼物排行 。\"]},\"516\":{\"h\":\"Redis到底是单线程还是多线程\",\"t\":[\"Redis 6.0版本之前的单线程指的是其网络I/O和键值对读写是有一个线程完成的。也就是只有网络请求模块和数据操作模块是单线程的，而其他的持久化、集群数据同步等，其实是由额外的线程执行的\",\"Redis 6.0引入的多线程指的是网络I/O采用了多线程，而键值对读写命令仍然是单线程处理的，所以Redis仍然是并发安全的\"]},\"517\":{\"h\":\"Redis单线程为什么还快\",\"t\":[\"命令执行基于内存操作\",\"命令执行是单线程操作，没有线程切换开销\",\"基于IO多路复用机制（epoll）提升Redis的I/O利用率\",\"高效的数据存储结构：全局hash表以及多种高效数据结构，比如：跳表，压缩列表，链表等等\"]},\"518\":{\"h\":\"Redis底层数据是如何用跳表来存储的\",\"t\":[\"将有序链表改造为支持类似“折半查找”的算法，可以让链表可以快速的插入、删除和查找。常用于Sorted Set的底层实现。\"]},\"519\":{\"h\":\"Redis Key过期了为什么内存没释放\",\"t\":[\"设置了过期时间的key被没有设置过期时间的相同key覆盖了\",\"127.0.0.1:6379> set name vingkin ex 120 OK 127.0.0.1:6379> ttl name (integer) 119 127.0.0.1:6379> set name vingkin OK 127.0.0.1:6379> ttl name (integer) -1 # name被覆盖，永不过时 \",\"与过期数据删除策略有关\"]},\"520\":{\"h\":\"过期数据删除策略\",\"t\":[\"惰性删除： 在取出key的时候对数据进行过期检查。这样对CPU友好，但是会造成太多过期key没有被删除\",\"定期删除： 每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作的时常和频率来减少删除操作对CPU的影响\",\"定期删除对内存更加友好，惰性删除对CPU更加友好。所以Redis采用两者结合的方式进行过期数据删除\"]},\"521\":{\"h\":\"Redis Key没设置过期时间为什么被Redis主动删除了\",\"t\":[\"Redis的内存淘汰机制使用了allkeys-lru或者allkeys-random或者allkeys-lfu\"]},\"522\":{\"h\":\"Redis内存淘汰机制\",\"t\":[\"当Redis已用内存超过maxmemory限定时，触动主动清理策略。\",\"主动清理策略再Redis4.0 之前一共实现了6中内存淘汰机制，在4.0之后，又增加了2种策略，总共8种：\",\"针对设置了过期时间的key做处理：\",\"volatile-lru（least recently used）： 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰（最常用）\",\"volatile-ttl： 从已设置过期时间的数据集中挑选即将要过期的数据淘汰\",\"volatile-random： 从已设置过期时间的数据集中任意选择数据淘汰\",\"volatile-lfu（least frequently used）： 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰（访问次数最少）\",\"针对所有的key做处理：\",\"allkeys-lru：（least recently used）： 当内存不足以容纳新写入数据时，在键空间中，移出最近最少使用的key（最常用）\",\"allkeys-random： 从数据集中任意选择数据淘汰\",\"allkeys-lfu（least frequently used）： 当内存不足以容纳新写入的数据时，在键空间中移出最不经常使用的key\",\"不处理：\",\"no-eviction： 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。（基本不使用）\",\"绝大多数情况都是用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点，以访问次数的多少作为参考点。\"]},\"523\":{\"h\":\"删除Key的命令会阻塞Redis吗\",\"t\":[\"DEL key [key ...]\",\"时间复杂度：\",\"O(N)，其中N为被删除key的数量\",\"删除单个字符串类型的key，时间复杂度为O(1)\",\"删除单个列表、集合、有序集合或哈希表类型的key，时间复杂度为O(M)，其中M为以上数据类型种元素的数量。\",\"当删除的key是所占内存很大时，不管是string还是其他的数据类型，都有可能会阻塞Redis\"]},\"524\":{\"h\":\"Redis高可用方案\"},\"525\":{\"h\":\"主从模式\",\"t\":[\"不能保证高可用，当master节点挂掉后需要运维介入切换节点，一般不使用\"]},\"526\":{\"h\":\"哨兵模式\",\"t\":[\"在redis 3.0以前的版本要实现集群一般时借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做出主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别时主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发（单节点理论支持最高并发量为10万），且单个主节点内存也不宜设的过大（一般为10G），否则会导致持久化文件过大，影响数据恢复或主从同步的效率。\",\"sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：\",\"集群监控：负责监控redis master和slave进程是否正常工作\",\"消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员\",\"故障转移：如果master node挂掉了，会自动转移到slave node上。故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举。\",\"配置中心：如果故障转移发生了，通知client客户端新的master地址\",\"哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。\",\"即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的\",\"哨兵通常需要3个实例，来保证自己的健壮性\",\"哨兵 + redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性\"]},\"527\":{\"h\":\"集群模式\",\"t\":[\"Redis集群是由多个主从节点群组成的分布式服务器群，它具有复制，高可用和分片的特性。Redis集群不需要sentine哨兵也能完成节点移出和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点（官方推荐不超过1000个）。Redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。\",\"通过hash的方式，将数据分片，每个节点均衡存储一定哈希槽（哈希值）区间的数据\",\"每份数据分片会存储在多个互为主从的多节点上\",\"数据先写入主节点，再同步到从节点（支持配置为阻塞同步）\",\"同一分片多个节点间的数据不保持强一致性\",\"读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，转向正确的节点\",\"扩容时，需要把旧节点的数据迁移一部分到新节点\",\"在redis cluster架构下，每个redis节点都要开放两个端口号，一个用于连接，一个用于节点间通信\"]},\"528\":{\"h\":\"Reids集群模式下数据hash分片算法\",\"t\":[\"Redis Cluster将所有数据划分为16384个槽位，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。\",\"当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个key时，可以根据槽位定位算法定位到目标节点。\",\"槽位定位算法\",\"Cluster默认会对key使用crc16算法进行hash得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。\",\"HASH_SLOT = CRC16(key) % 16384\",\"再根据槽位值和Redis节点的对应关系就可以定位到key具体是落在哪个Redis节点上\"]},\"529\":{\"h\":\"Redis执行命令出现死循环Bug\",\"t\":[\"如果想随机查看Redis中的一个key，Redis里面有一个RANDOMKEY命令可以从Redis中随机取出一个key，这个命令可能导致Redis死循环阻塞。\",\"出现这个问题的原因主要还是在于Redis的过期数据删除策略\",\"RANDOMKEY随机拿出一个key后，首先会检查该key是否过期，如果过期，则会先删除这个key然后重新选取，直到找到一个未过期的key返回。如果Redis中有大量的key已经过期，但是没有被即使清理，那么这个循环会持续很久才结束。这个流程是发生在master节点中的。\",\"如果发生在slave节点中，那么问题会更严重。slave是不会主动清理过期key的，当一个key过期时，master会先清理删除它，然后向slave发送一个DEL命令，告知slave也删除这个key，以此达到主从库的数据一致性。\",\"假设Redis中存在大量已过期但是未被清理的key，在slave中执行RANDOMKEY时，因为不会删除过期key，则有可能无限制的命中过期key，陷入死循环，导致Redis实例卡死。\",\"这其实是Redis 5.0之前的一个Bug，修复方案就是给RANDOMKEY增加最多执行次数，无论是否找到key，都返回。\"]},\"530\":{\"h\":\"主从切换导致缓存雪崩具体场景\",\"t\":[\"为什么要保证主从节点机器时钟一致\",\"我们假设，slave的机器时钟比master走得快很多\",\"此时，Redis master里设置了过期时间的key，从slave角度来看，可能会有很多在master里没过期的数据其实已经过期了\",\"如果此时操作主从切换，把slave提升为新的master\",\"slave成为新的master后，就会开始大量清理过期key，此时就会导致以下结果：\",\"master大量清理过期key，主线程可能会发生阻塞，无法及时处理客户端请求\",\"Redis中数据大量过期，引发缓存雪崩甚至系统崩溃\",\"当master和slave机器始终严重不一致时，对业务的影响非常大。所以一定要保证主从节点的机器时钟一致性。\"]},\"531\":{\"h\":\"Java并发\"},\"532\":{\"h\":\"start()和run()\",\"t\":[\"start()和run()都是Thread类的方法（如果用的是Runnable则执行的是Runnable中的run方法，注意Callable中的是call方法）\",\"start是启动线程作用是将线程变为就绪状态，至于是否调用还是得看CPU的分配。run是一个线程的具体执行内容，线程启动后自动调用。\",\"如果在main线程中调用了t1线程的run方法，就相当于main线程运行了一个普通的run方法，并没能达到多线程的效果\",\"strat只能调用一次，多次调用会抛IllegalThreadStateException异常\"]},\"533\":{\"h\":\"sleep()与yield()\",\"t\":[\"sleep\",\"调用sleep会让当前线程从Running进入Timed Waiting（阻塞状态）状态\",\"其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException\",\"睡眠结束后的线程未必会立刻得到执行\",\"yield\",\"调用yield会让当前线程从Running进入Runnalbe（就绪状态）状态，然后调度执行其他同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果\",\"具体的实现依赖于操作系统的任务调度器\",\"区别\",\"就绪状态有机会被任务调度器调用，阻塞状态不会。\",\"sleep有休眠时间，yield没有时间参数\"]},\"534\":{\"h\":\"interrupt()\",\"t\":[\"Thread中的方法\",\"如果打断的是阻塞线程(sleep, wait, join)，则打断标记(isInterrupted())会在打断后清为False\",\"如果打断的是正常运行的线程，则不会清空打断状态\"]},\"535\":{\"h\":\"线程优先级\",\"t\":[\"Java中优先级最大10，最小1，默认为5，仅仅是一个提示，调度器甚至可以忽略。\",\"只有在cpu比较忙的时候，优先级较高的线程会获得更多的时间片，cpu空闲时，优先级几乎没什么用。\"]},\"536\":{\"h\":\"两阶段终止模式\",\"t\":[\"在线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个处理其他事情的机会（如释放锁）\",\"如果调用线程的stop()方法，如果此时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程永远无法获取锁。\",\"public class Test { public static void main(String[] args) throws InterruptedException { Monitor monitor = new Monitor(); monitor.start(); Thread.sleep(3500); monitor.stop(); } } class Monitor { Thread monitor; /** * 启动监控器线程 */ public void start() { //设置线控器线程，用于监控线程状态 monitor = new Thread() { @Override public void run() { //开始不停的监控 while (true) { //判断当前线程是否被打断了 if(Thread.currentThread().isInterrupted()) { System.out.println(\\\"处理后续任务\\\"); //终止线程执行 break; } System.out.println(\\\"监控器运行中...\\\"); try { //线程休眠 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); //如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记 Thread.currentThread().interrupt(); } } } }; monitor.start(); } /** * 用于停止监控器线程 */ public void stop() { //打断线程 monitor.interrupt(); } } \"]},\"537\":{\"h\":\"守护线程\",\"t\":[\"当Java进程中有多个线程执行时，只有当所有非守护线程执行完毕后，Java进程才会结束。但当非守护线程执行完毕后，守护线程无论是否执行完毕，都会一同结束。\",\"垃圾回收器就是一个守护线程\"]},\"538\":{\"h\":\"线程状态\",\"t\":[\"五种状态\",\"操作系统层面\",\"初始状态：仅在语言层面创建了线程对象，还未与操作系统线程关联\",\"可运行状态（就绪状态）：指该线程已经被创建（与操作系统线程相关），可以由CPU调度使用\",\"运行状态：指获取了CPU时间片运行中的状态\",\"阻塞状态： \",\"如果调用了阻塞API，如读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态\",\"等读写完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态\",\"与可运行状态的区别是，对阻塞状态的线程来说只要他们一直不唤醒，调度器就一直不会考虑调度他们。\",\"终止状态：表示线程执行已经完毕，生命周期已经结束，不会再转换为其他状态\",\"六种状态\",\"Java中Thread.State枚举描述的\",\"下图RUNNABLE中的阻塞状态应该去除\",\"线程的状态转换\",\"NEW：线程刚被创建，但是还没有调用start()方法\",\"RUNNABLE：当调用了start()方法之后的状态。涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（在Java中无法区分运行状态和可运行状态）\",\"BLOCKED、WAITING、TIMED_WAITING：都是Java API层面对【阻塞状态】的细分\",\"TERMINATED：当前线程运行结束\",\"Java 线程的状态 \"]},\"539\":{\"h\":\"变量的线程安全分析\",\"t\":[\"成员变量和静态变量的线程安全分析\",\"如果变量没有在线程间共享，那么变量是安全的\",\"如果变量在线程中共享 \",\"如果只有读操作，则线程安全\",\"如果有写操作，则该变量属于临界资源，需要考虑线程安全问题\",\"局部变量线程安全分析\",\"局部变量被初始化为基本数据类型则是安全的\",\"当局部变量是引用变量时则需要进行逃逸分析判断 \",\"如果该对象没有逃离方法的作用范围，则线程安全\",\"如果该对象逃离了方法的作用范围，则线程不安全\"]},\"540\":{\"h\":\"对象头\",\"t\":[\"Java对象头详细信息在JVM中有描述，简要来说包含Mark Word(32bit)和Klass Word(32bit)。如果是数组的话还会包含数组长度(32bit)。\",\"下图描述的是不同锁状态下Mark Word的形式，其中后几位为001表示无锁，101表示偏向锁，00表示轻量级锁，10表示重量级锁，11表示标记GC\"]},\"541\":{\"h\":\"Monitor原理\",\"t\":[\"Monitor被翻译成监视器或管程\",\"每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁之后，该对象头的Mark Word中就被设置成指向Monitor对象的指针\",\"Monitor的结构如下：\",\"刚开始Monitor中的Owner为null\",\"当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner\",\"在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED\",\"Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的\",\"途中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程\",\"注意：\",\"synchronized必须是进入同一个锁对象的monitor才有上述的效果（一个锁对象对应着一个monitor）\",\"不加synchronized的对象不会关联监视器，不遵从上述规则\",\"字节码层面分析synchronized\",\"monitorenter是进入synchronized语句\",\"monitorexit是退出synchronized语句\",\"6 - 14行是synchronized中执行的部分，如果其中出现了错误也会释放锁，因为异常表中当在6 - 16行出现异常时，会跳到19行执行异常处理部分。\",\"static final Object lock = new Object(); static int counter = 0; public static void main(String[] args) { synchronized (lock) { counter++; } } \"]},\"542\":{\"h\":\"自旋优化\",\"t\":[\"优化重量级锁竞争\",\"当发生重量级锁竞争的时候，还可以使用自旋来进行优化（不加入Monitor的阻塞队列EntryList中），如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换（持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程获取cpu执行权的过程）就获得了锁\",\"成功演示：\",\"失败演示：\",\"自旋会占用CPU时间，单核CPU自选就是浪费，多核CPU自旋才能发挥优势\"]},\"543\":{\"h\":\"轻量级锁\",\"t\":[\"用于优化重量级锁\",\"https://blog.csdn.net/m0_37989980/article/details/111408759#t5\"]},\"544\":{\"h\":\"偏向锁\",\"t\":[\"用于优化轻量级锁重入\",\"https://blog.csdn.net/m0_37989980/article/details/111408759#t8\"]},\"545\":{\"h\":\"wait()和notify()\",\"t\":[\"Object类中的方法\",\"https://blog.csdn.net/m0_37989980/article/details/111412907#t0\"]},\"546\":{\"h\":\"sleep()和wait()的区别\",\"t\":[\"sleep是Thread方法，wait是Object方法\",\"sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起使用\",\"sleep不会释放锁对象，wait会释放锁对象\",\"他们的线程状态都是TIMED_WAITING\"]},\"547\":{\"h\":\"保护性暂停模式\",\"t\":[\"用于一个线程等待另一个线程的执行结果\",\"join()内部采用的就是这个原理，不过join()中是一个线程等待另一个线程结束\",\"有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject\",\"如果有结果不断从一个线程到另一个线程，那么可以使用消息队列（生产者消费者模式）\",\"JDK中，join和future采用的就是该模式\",\"因为一个线程需要等待另一个线程的执行结果，所以归结于同步模式\"]},\"548\":{\"h\":\"生产者消费者模式\",\"t\":[\"与前面的保护性暂停中的GuardObjct不同，不需要产生结果和消费结果的线程一一对应\",\"消费队列可以用来平衡生产和消费的线程资源\",\"生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据\",\"消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据\",\"JDK中各种阻塞队列，采用的就是这种模式\"]},\"549\":{\"h\":\"park()和unpark()\",\"t\":[\"https://blog.csdn.net/m0_37989980/article/details/111412907#t8\",\"park和unpark是LockSupport类中的方法，运行时会调用Unsafe类中的native方法\",\"每个线程都会和一个park对象关联起来，由三部分组成_counter,_cond,_mutex_。核心部分是counter，可以理解为一个标记位。\",\"当调用park时会查看counter是否为0，为0则进入cond阻塞。为1则继续运行并将counter置为0。\",\"当调用unpark时，会将counter置为1，若之前的counter值为0，还会唤醒阻塞的线程。\",\"如果先调用unpark再调用park不会阻塞线程。调用unpark后将counter置为1，再调用park线程发现counter为1继续运行并将counter置为0。\",\"park()&unpark()与wait()&notify()对比\",\"wait，notify和notifyAll必须配合Object Monitor(synchronized)一起使用，而park和unpark不必\",\"park，unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，无法唤醒指定的线程。\",\"park，unpark可以先unpark，而wait，notify不能先notify\"]},\"550\":{\"h\":\"死锁，活锁，饥饿\"},\"551\":{\"h\":\"死锁\",\"t\":[\"代码演示：\",\"public static void main(String[] args) { final Object A = new Object(); final Object B = new Object(); new Thread(()->{ synchronized (A) { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (B) { } } }).start(); new Thread(()->{ synchronized (B) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (A) { } } }).start(); } \",\"发生死锁的必要条件：\",\"互斥条件：在一段时间内，一种资源只能被一个线程所使用\",\"请求和保持条件：线程已经拥有了至少一种资 源，同时又去申请其他资源。因为其他资源被别的线程所使用。该线程进入阻塞状态同时不释放自己已有的资源。\",\"不可抢占条件：进程对已获得的资源在未使用完成前不能被抢占，之后能在线程使用完后自己释放。\",\"循环等待条件：发生死锁时，必然存在一个线程---资源的循环链\",\"定位死锁的方法：\",\"jstack + 进程id命令查看线程状态有Java层面死锁线程信息\",\"jconsole有死锁检测功能\",\"避免死锁的方法：\",\"在线程使用锁对象时, 采用固定加锁的顺序, 可以使用Hash值的大小来确定加锁的先后\",\"尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁\",\"使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)\"]},\"552\":{\"h\":\"活锁\",\"t\":[\"活锁出现在两个线程 互相改变对方的结束条件，谁也无法结束。\",\"避免活锁的方法：\",\"在线程执行时，中途给予不同的间隔时间, 让某个线程先结束即可。\",\"死锁与活锁的区别：\",\"死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。\",\"活锁是因为线程间修改了对方的结束条件，而导致代码一直在运行，却一直运行不完的现象。\"]},\"553\":{\"h\":\"饥饿\",\"t\":[\"某些线程因为优先级太低，导致一直无法获得资源的现象。\",\"在使用顺序加锁时，可能会出现饥饿现象\"]},\"554\":{\"h\":\"固定线程运行顺序\",\"t\":[\"wait()&notify()\",\"public class Test { static final Object lock = new Object(); static boolean t2runned = false; public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (lock) { while (!t2runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"1\\\"); } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized(lock) { log.debug(\\\"2\\\"); t2runned = true; lock.notify(); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"park()&unpark()\",\"public class Test { public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { LockSupport.park(); log.debug(\\\"1\\\"); } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { log.debug(\\\"2\\\"); LockSupport.unpark(t1); } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"await()&signal()\",\"public class Test { private static ReentrantLock lock = new ReentrantLock(); private static boolean t2runned = false; static Condition condition1 = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { lock.lock(); try { while (!t2runned) { try { condition1.await(); log.debug(\\\"1\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { lock.unlock(); } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { lock.lock(); try { log.debug(\\\"2\\\"); t2runned = true; condition1.signal(); } finally { lock.unlock(); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \"]},\"555\":{\"h\":\"线程交替输出\",\"t\":[\"wait()&notify()\",\"public class Test { static boolean t1runned = false; static boolean t2runned = true; static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { synchronized (lock) { while (!t2runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"1\\\"); t1runned = true; t2runned = false; lock.notify(); } } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { synchronized (lock) { while (!t1runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"2\\\"); t1runned = false; t2runned = true; lock.notify(); } } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"park()&unpark()\",\"public class Test { volatile static boolean t1runned = false; volatile static boolean t2runned = true; static final Object lock = new Object(); static Thread t1; static Thread t2; public static void main(String[] args) { t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { if (!t2runned) { LockSupport.park(); } log.debug(\\\"1\\\"); t2runned = false; t1runned = true; LockSupport.unpark(t2); } } }, \\\"t1\\\"); t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { if (!t1runned) { LockSupport.park(); } log.debug(\\\"2\\\"); t2runned = true; t1runned = false; LockSupport.unpark(t1); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"await()&signal()\",\"public class Test { static boolean t1runned = false; static boolean t2runned = true; public static void main(String[] args) { ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { reentrantLock.lock(); try { while (!t2runned) { condition.await(); } log.debug(\\\"1\\\"); t1runned = true; t2runned = false; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { reentrantLock.unlock(); } } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { reentrantLock.lock(); try { while (!t1runned) { condition.await(); } log.debug(\\\"2\\\"); t1runned = false; t2runned = true; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { reentrantLock.unlock(); } } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \"]},\"556\":{\"h\":\"并发编程的三大特性\",\"t\":[\"原子性：保证指令不会受到线程上下文切换的影响。程序的原子性是指整个程序中的所有操作，要么全部完成，要么全部失败，不可能滞留在中间某个环节；在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所打断。\",\"可见性：保证指令不会受cpu缓存的影响。一个线程对共享变量值的修改，能够及时地被其他线程看到\",\"有序性：保证指令不会受到cpu指令并行优化的影响\"]},\"557\":{\"h\":\"volatile原理\",\"t\":[\"volatile的底层实现原理是内存屏障\",\"保证可见性 \",\"对volatile变量的写指令后会加入写屏障。写屏障保证该屏障之前的，对共享变量的改动都会同步到主存中。\",\"对volatile变量之间会加入读屏障。读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据。\",\"保证有序性（禁止指令重排） \",\"写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\",\"读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\"]},\"558\":{\"h\":\"volatile和synchronized\",\"t\":[\"一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。（比如volatile修饰的i，两个线程一个i++一个i--，只能保证看到最新值，不能解决指令交错的问题。）\",\"synchronized语句块既能保证代码块的原子性，也同时能保证代码块内变量的可见性。但缺点是synchronized属于重量级锁，性能相对较低。\",\"volatile关键字只能修饰变量，synchronized还可以修饰方法，类以及代码块。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。\"]},\"559\":{\"h\":\"volatile和synchronized在有序性上的不同\",\"t\":[\"synchronized的有序性是持有相同锁的两个同步块只能串行的进入，即被加锁的内容要按照顺序被多个线程执行，但是其内部的同步代码还是会发生重排序。\",\"volatile的有序性是通过插入内存屏障来保证指令按照顺序执行。不会存在后面的指令跑到前面的指令之前来执行。是保证编译器优化的时候不会让指令乱序。\",\"synchronized代码块内部是不能保证指令重排的。\"]},\"560\":{\"h\":\"i++是否线程安全\",\"t\":[\"提到这个问题得区分i是成员变量/静态变量还是局部变量，如果是前者需要考虑，对于局部变量不管是基本类型还是包装类型都不需要考虑，包装类型比如Integer是不可变类，是线程安全的。\",\"假设有1000个线程对i执行++操作，理论上ide结果应该是1000，实际并不是\",\"// i++ 的字节码指令，此时i是一个静态变量 getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 iadd // 自增 putstatic i // 将修改后的值存入静态变量i \",\"每个线程都有自己的工作内存，每个线程需要用共享变量时必须先把共享变量从主存load到自己的工作内存，等完成对共享变量的操作时再save到主内存。\",\"问题就出在一个线程读取主存的值后运算完还未刷回主存就被其他线程从主存中读取到了，这时候其他线程读取的数据就是脏数据了。\",\"这也是经典的内存不可见问题，把count加上volatile也不能解决这个问题。因为volatile只能保证可见性并不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程的可见性，也不能保证线程之间读取到同样的值然后互相覆盖对方值的情况。\",\"解决方案\",\"对i++操作的方法加同步锁，同时只能由一个线程执行i++\",\"使用支持原子类型操作的类，比如AtomicInteger，内部使用的是CAS\"]},\"561\":{\"h\":\"CAS的特点\",\"t\":[\"结合CAS和volatile可以实现无锁并发，适用于线程数少、多核CPU的场景下。\",\"CAS是基于乐观锁的思想~~（实际上并不是锁）~~：最乐观的估计，不怕别的线程来修复共享变量，就算改了也没关系，重试即可\",\"synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会\",\"CAS体现的是无锁并发，无阻塞并发\",\"因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一\",\"但是如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响\"]},\"562\":{\"h\":\"Atomic原子类\",\"t\":[\"并发编程面试必备：JUC 中的 Atomic 原子类总结 (qq.com)\",\"原子整数\",\"AtomicInteger\",\"AtomicLong\",\"AtomicBoolean\",\"public static void main(String[] args) { AtomicInteger i = new AtomicInteger(0); // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement()); // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet()); // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet()); // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i-- System.out.println(i.getAndDecrement()); // 获取并加值（i = 0, 结果 i = 5, 返回 0） System.out.println(i.getAndAdd(5)); // 加值并获取（i = 5, 结果 i = 0, 返回 0） System.out.println(i.addAndGet(-5)); // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.getAndUpdate(p -> p - 2)); // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.updateAndGet(p -> p + 2)); // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final System.out.println(i.getAndAccumulate(10, (p, x) -> p + x)); // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x)); } \",\"原子引用\",\"原子引用的作用: 保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)\",\"AtomicReference\",\"AtomicStampedReference\",\"AtomicMarkableReference\",\"原子数组\",\"保证数组内元素的线程安全\",\"AtomicIntegerArray\",\"AtomicLongArray\",\"AtomicReferenceArray\",\"字段更新器\",\"保证多线程访问同一个对象的成员变量时, 成员变量的线程安全性。\",\"AtomicIntegerFieldUpdater\",\"AtomicLongFieldUpdater\",\"AtomicReferenceFieldUpdater\",\"原子累加器\",\"LongAdder\",\"LongAccumulator\",\"DoubleAdder\",\"DoubleAccumulator\"]},\"563\":{\"h\":\"原子引用ABA问题\",\"t\":[\"采用CAS主线程仅能判断出共享变量的值与初值A是否相同，不能感知到这种从A改为B又改回A的情况，如果主线程希望：\",\"只要有其他线程【动过了】共享变量，那么自己的cas就算失败，这时仅比较值是不够的，还需要再加一个版本号\",\"通过AtomicStampedReference判断是否更改了版本号，传入的是整型变量\",\"通过AtomicMarkableReference判断是否被修改，传入的是布尔变量\"]},\"564\":{\"h\":\"LongAdder原理\",\"t\":[\"// 累加单元数组，懒惰初始化 transient volatile Cell[] cells; // 基础值，如果没有竞争，则用cas累加这个域 transient volatile long base; // 在cells创建或扩容时，置为1，表示加锁 transient volatile int cellsBusy; \",\"性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。\",\"之前AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS重试, 性能没有LongAdder高\"]},\"565\":{\"h\":\"Unsafe\",\"t\":[\"Unsafe并不是表示线程不安全，而是表示Unsafe类中的操作不安全，因为是对于底层的操作。\",\"Unsafe对象提供了非常底层的，操作系内存、线程的方法，Unsafe对象不能直接调用，只能通过反射获得\",\"Field theUnsafe = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); System.out.println(unsafe); \"]},\"566\":{\"h\":\"不可变类\",\"t\":[\"final的使用\",\"属性用final修饰保证该属性是只读的，不能修改\",\"类用final修饰保证了类不能被继承，该类中的方法不能被重写，防止子类无意间破坏不变性\",\"保护性拷贝\",\"使用字符串时，也有一些跟修改相关的方法啊，比如substring、replace 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：\",\"public String substring(int beginIndex, int endIndex) { if (beginIndex < 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex > value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen < 0) { throw new StringIndexOutOfBoundsException(subLen); } // 上面是一些校验，下面才是真正的创建新的String对象 return ((beginIndex == 0) && (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } \",\"发现其方法最后是调用String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制。 这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】\"]},\"567\":{\"h\":\"final原理\",\"t\":[\"public class TestFinal { final int a = 20; } \",\"0: aload_0 1: invokespecial #1 // Method java/lang/Object.\\\"<init>\\\":()V 4: aload_0 5: bipush 20 7: putfield #2 // Field a:I <-- 写屏障 10: retu \",\"发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。\",\"写屏障保证该屏障之前的，对共享变量的改动都会同步到主存中。\",\"写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\"]},\"568\":{\"h\":\"享元模式\",\"t\":[\"享元模式简单理解就是重用数量有限的同一对象，比如字符串常量池，包装类常量池，线程池以及字符串连接池都运用了享元模式的思想。\"]},\"569\":{\"h\":\"线程池\"},\"570\":{\"h\":\"线程池的好处\",\"t\":[\"降低资源消耗。通过重复利用已创建的线程来降低线程创建和销毁所带来的消耗。\",\"提高响应速度。当任务到达时，如果有空闲线程，任务可以不需要等到线程创建就直接运行。\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\"]},\"571\":{\"h\":\"线程池状态\",\"t\":[\"ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量。使用一个AtomicInteger来表示状态和数量，可以通过一次CAS同时更改两个属性的值。\",\"状态名称\",\"高3位的值\",\"描述\",\"RUNNING\",\"111\",\"接收新任务，同时处理任务队列中的任务\",\"SHUTDOWN\",\"000\",\"不接受新任务，但是处理任务队列中的任务\",\"STOP\",\"001\",\"中断正在执行的任务，同时抛弃阻塞队列中的任务\",\"TIDYING\",\"010\",\"任务执行完毕，活动线程为0时，即将进入TERMINATED状态\",\"TERMINATED\",\"011\",\"终结状态\"]},\"572\":{\"h\":\"ThreadPoolExecutor参数\",\"t\":[\"public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) \",\"corePoolSize：核心线程数\",\"maximumPoolSize：最大线程数 \",\"maximumPoolSize - corePoolSize = 救急线程数\",\"救急线程在没有空闲核心线程和任务队列满了的情况下才会创建使用\",\"keepAliveTime：救急线程空闲时的最大空闲时间\",\"unit：时间单位，针对救急线程\",\"workQueue：阻塞队列 \",\"有界阻塞队列：ArrayBlockingQueue\",\"无界阻塞队列：LinkedBlockingQueue\",\"最多只有一个任务的阻塞队列：SynchronizedQueue\",\"优先队列：PriorityBlockingQueue\",\"ThreadFactory：线程工厂（给线程取名字）\",\"handler：拒绝策略（当活动线程数==最大线程数且阻塞队列满的情况下采取的策略）\"]},\"573\":{\"h\":\"拒绝策略\",\"t\":[\"当活动线程数等于最大线程数且阻塞队列满的情况下采取的策略\",\"JDK提供了四种实现\",\"AbortPolicy终止策略：丢弃该任务并抛出RejectedExecutionException异常。这是默认策略\",\"DiscardPolicy丢弃策略：丢弃任务，但是不抛出异常。如果任务队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。\",\"DiscardOldestPolicy弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务\",\"CallerRunsPolicy调用者运行策略：由调用者线程自行处理该任务\"]},\"574\":{\"h\":\"Executors创建的线程池\",\"t\":[\"由Executors类提供的工厂方法来创建线程池！Executors 是Executor 框架的工具类\",\"一般不适用，而是直接使用ThreadPoolExecutor构造方法\",\"newFixedThreadPool\",\"public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory); } \",\"特点\",\"核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间\",\"阻塞队列是无界的，可以放任意数量的任务\",\"适用于任务量已知，相对耗时的任务\",\"newCachedThreadPool\",\"public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"特点\",\"没有核心线程，最大线程数为Integer.MAX_VALUE，所有创建的线程都是救急线程 (可以无限创建)，空闲时生存时间为60秒\",\"阻塞队列使用的是SynchronousQueue \",\"SynchronousQueue是一种特殊的队列 \",\"没有容量，没有线程来取是放不进去的\",\"只有当线程取任务时，才会将任务放入该阻塞队列中\",\"整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况\",\"newSingleThreadExecutor\",\"public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"使用场景：\",\"希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。 任务执行完毕，这唯一的线程也不会被释放。\",\"区别： \",\"和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而newSingleThreadExecutor线程池还会新建一个线程，保证池的正常工作\",\"Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 \",\"FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法\",\"和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改\"]},\"575\":{\"h\":\"执行 execute()方法和 submit()方法的区别是什么呢？\",\"t\":[\"就像runnable()和callable()的区别，submit()有返回值返回一个Future的对象。\"]},\"576\":{\"h\":\"线程池创建多少线程合适\",\"t\":[\"下面两点只是纯理论说法，具体个数要是需要测试得到\",\"CPU密集型\",\"通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费\",\"IO密集型\",\"CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。通过CPU的利用率计算得到。\"]},\"577\":{\"h\":\"ThreadLocal\",\"t\":[\"ThreadLocal是Java所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任何时刻，任意方法中获取缓存的数据\",\"ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值\",\"如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象就不会被回收，从而出现内存泄漏，解决办法是，当使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。\"]},\"578\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"CopyOnWriteArrayList是java.util.concurrent包提供的方法，它实现了读操作无锁，写操作则通过操作操作底层数组的新副本来实现（将之前的ArrayList拷贝一份，写操作在该副本上进行，在完成写之前，需要对写加锁，写操作完成后，将有来的引用指向新副本），是一种读写分离的并发策略。\",\"CopyOnWrite并发容器适用于对于绝大部分访问都是读，且只是偶尔写的并发场景。\",\"get弱一致性\"]},\"579\":{\"h\":\"ConcurrentHashMap\",\"t\":[\"一下都是基于JDK 8\",\"对于JDK 1.7而言，ConcurrentHashMap和HashMap都是基于数组和链表实现的。不同在于ConcurrentHashMap有大数组和小数组，大数组就是Segment数组，小数组是HashEntry数组。Segment继承了ReentranceLock，因此具有可重入锁的特性，这样的话就可以保证多线程同时访问的线程安全问题。ConcurrentHashMap的线程安全是基于Segment加锁的基础上。\",\"对于JDK 1.8而言，CoucurrentHashMap和HashMap的实现方式都是一样的，都是基于Node数组+链表+红黑树。当链表长度大于8并且Node数组长度大于64的时候，链表就会转换为红黑树。它的线程安全是由CAS+volatile和synchronized来实现的。比如在put操作中，如果链表头节点为空，则通过CAS创建链表头节点，如果链表头节点不为空则通过synchronized来加锁遍历链表。这样加锁的好处是对于链表头节点加锁，相比于对Segment加锁，锁的粒度更小，并发性能大大提升。\",\"重要属性和内部类\",\"// 默认为0 // 当初始化时，为-1 // 当扩容是，为-(1 + 扩容线程数) // 当初始化或扩容完成后，为下一次扩容的阈值大小 private transient volatile in sizeCtl; // 整个ConcurrentHashMap就是一个Node[] static class Node<K, V> implements Map.Entry<K, V> {} // hash表 transient volatile Node<K, V>[] table; // 扩容时 新的 hash表 private transient volatile Node<K, V>[] nextTable; // 扩容时如果某个bin迁移完毕，用FordwardingNode作为旧table bin的头节点 static final class ForwardingNode<K, V> extends Node<K, V> {} // 用在compute以及computeIfAbsent时，用来占位，计算完成后替换为普通Node static final class ReservationNode<K, V> extends Node<K, V> {} // 作为treebin（红黑树）的头节点，存储root和first static final class TreeBin<K, V> extends Node<K, V> {} // 作为treebin的节点，存储parent，left，right static final class TreeNode<K, V> extends Node<K, V> {} \",\"ForwardingNode的理解\",\"ForwardingNode出现在扩容时，下图是旧的hash表，从右向左迁移bin，该节点迁移完成后加入ForwardingNode作为当前节点的头节点。如果在扩容过程中其他线程来get，get到了ForwardingNode，那么这个线程就回到新的链表中get。如果扩容过程中，其他线程来put，put到了ForwardingNode，此时会帮忙扩容。\",\"构造器分析\",\"实现了懒惰初始化，在构造方法中仅仅计算了table的大小，以后在第一次使用时才会真正创建。\",\"public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0) throw new IllegalArgumentException(); if (initialCapacity < concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); // tableSizeFor是为了保证计算的大小是2^n int cap = (size >= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; } \",\"get流程\",\"全程没有加锁\",\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // spread方法能保证返回结果是正数 int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 如果头节点已经是要查找的key if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; } // hash为负数表示该bin在扩容中或是treebin，这时调用find方法来查找 else if (eh < 0) return (p = e.find(h, key)) != null ? p.val : null; // 正常遍历链表，用equals来比较 while ((e = e.next) != null) { if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; } \",\"put流程\",\"public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // spread方法会综合高位地位，具有更好的hash性 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { // f是链表头节点 // fh是链表头结点的hash // i是链表在table中的下标 Node<K,V> f; int n, i, fh; //要创建table if (tab == null || (n = tab.length) == 0) // 初始化table使用了cas，无需synchronized创建成功，进入下一轮循环 tab = initTable(); // 要创建链表头节点 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 添加链表头节点使用了cas，无需synchronized if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 帮忙扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 锁住链表头节点 synchronized (f) { // 再次确认链表头节点没有被移动 if (tabAt(tab, i) == f) { // 链表 if (fh >= 0) { binCount = 1; // 遍历链表 for (Node<K,V> e = f;; ++binCount) { K ek; // 找到相同的key if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; // 更新 if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; // 已经是最后的节点了，新增Node，追加至链表尾 if ((e = e.next) == null) { pred.next = new Node<K,V>(hash, key, value, null); break; } } } // 红黑树 else if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; // putTreeVal会看key是否已经在树中，是，则返回对应的TreeNode if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) // 如果链表长度大于等于阈值8，进行链表转为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 增加size计数，其中用到的原理和LongAdder差不多使用了Cell[]，设置了多个累加单元 addCount(1L, binCount); return null; } \",\"size计算流程\",\"size计算实际发生在put，remove改变集合元素的操作之中\",\"没有竞争发生，向baseCount累加计数\",\"有竞争发生，新建counterCells，象棋中的一个cell累加计数 \",\"counterCells初始有两个cell\",\"如果技术竞争比较激烈，会创建新的cell来累加计数\"]},\"580\":{\"h\":\"AQS\",\"t\":[\"以下是面向面试\",\"基于死磕 java同步系列之AQS终篇改编\"]},\"581\":{\"h\":\"AQS是什么\",\"t\":[\"AQS的全称是AbstractQueuedSynchronizer，是一个抽象类。它为Java中大部分锁和同步器提供一个基础框架，其中运用了设计模式中的模板方法。像ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch都继承了该抽象类。\"]},\"582\":{\"h\":\"状态变量state\",\"t\":[\"AQS中定义了一个状态变量state，它有以下两种使用方法：\",\"互斥锁\",\"当AQS只实现为互斥锁的时候，只要成功地通过CAS操作将state的值从0变为1就获取了锁，可重入是通过不断通过CAS操作将state的值+1实现的。当可重入时，释放锁的时候也需要将state减为0。\",\"互斥锁+共享锁\",\"当AQS需要同时实现为互斥锁+共享锁的时候，低16为存储互斥锁状态，高16位存储共享锁的状态，主要用于实现读写锁，比如ReentrantReadWriteLock。\",\"互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其他线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁（意思是互斥锁可以降级为共享锁，比如ReentrantReadWriteLock中的写锁可以降级为读锁）。\",\"共享锁允许同时多个线程占有，只要有一个线程占有了共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁\"]},\"583\":{\"h\":\"AQS队列\",\"t\":[\"AQS中维护了一个队列，获取锁失败的线程都将进入到这个队列中排队，等待所释放后唤醒下一个排队的线程。\",\"在互斥模式下唤醒的是下一个线程，如果是互斥锁+共享锁的情况下，比如ReentrantReadWriteLock，唤醒下一个线程后如果发现该线程占有的是共享锁，那么会在队列中再往后判断下一个节点的线程时候占有的是共享锁，如果是共享锁的话会将连着的占有共享锁的线程一同释放，达到一种并发读的效果。\",\"比如下图中t2和t3就占有共享锁，当t1释放锁t2被唤醒后，会连同t3一起唤醒。\"]},\"584\":{\"h\":\"Condition队列\",\"t\":[\"AQS中还有一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。\",\"ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，其他线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放后被唤醒。\",\"Condition典型的运用场景是在BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。\"]},\"585\":{\"h\":\"模板方法\",\"t\":[\"AQS这个抽象类把模板方法运用地炉火纯青，它里面定义了一系列的模板方法，比如下面这些：\",\"// 获取互斥锁 public final void acquire(int arg) { // tryAcquire(arg)需要子类实现 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 获取互斥锁可中断 public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // tryAcquire(arg)需要子类实现 if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } // 获取共享锁 public final void acquireShared(int arg) { // tryAcquireShared(arg)需要子类实现 if (tryAcquireShared(arg) < 0) doAcquireShared(arg); } // 获取共享锁可中断 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // tryAcquireShared(arg)需要子类实现 if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); } // 释放互斥锁 public final boolean release(int arg) { // tryRelease(arg)需要子类实现 if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // 释放共享锁 public final boolean releaseShared(int arg) { // tryReleaseShared(arg)需要子类实现 if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } \",\"需要子类实现的方法\",\"上面一起学习了AQS中几个重要的模板方法，下面我们再一起学习下几个需要子类实现的方法：\",\"// 互斥模式下使用：尝试获取锁 protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } // 互斥模式下使用：尝试释放锁 protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } // 共享模式下使用：尝试获取锁 protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); } // 共享模式下使用：尝试释放锁 protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); } // 如果当前线程独占着锁，返回true protected boolean isHeldExclusively() { throw new UnsupportedOperationException(); } \",\"这几个方法为什么不直接定义成抽象方法呢？\",\"因为子类只要实现这几个方法中的一部分就可以实现一个同步器了，所以不需要定义成抽象方法。\"]},\"586\":{\"h\":\"ReentrantLock\",\"t\":[\"ReentrantLock是基于Lock接口和AQS抽象类实现的可重入锁。\"]},\"587\":{\"h\":\"ReentrantLock与Synchronized的区别\"},\"588\":{\"h\":\"ReentrantLock的公平锁和非公平锁\",\"t\":[\"ReentrantLock的非公平体现在，当线程想要获取锁时，先通过两次CAS操作去争抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。对于队列中的线程是公平的，因为AQS中队列满足FIFO的特性。\",\"非公平锁在调用lock方法后，首先会调用CAS进行一次抢锁，如果这个时候锁恰好没有被占用，那么就直接获取到锁返回了\",\"非公平锁在CAS失败后，和公平锁一样都会进入到tryAcquire方法，在tryAcquire方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接CAS抢锁，但是公平锁会判断队列中是否有线程处于等待状态，如果有则不去抢锁，主动加入到队列等待唤醒。\",\"公平锁和非公平锁就这两点区别，如果两次CAS都不成功，那么后面公平锁和非公平锁是一样的，都要进入队列等待唤醒。\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获得锁的时间变得更加不确定，可能导致队列中的线程长期处于饥饿状态。\"]},\"589\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"ReentrantReadWriteLock是一种读写锁，用于实现并发读。\",\"写锁可以降级为读锁，读锁不能升级为写锁。\"]},\"590\":{\"h\":\"StampedLock\",\"t\":[\"该类自JDK 8加入，是为了进一步优化读性能，它的特点是在使用读锁和写锁时都必须配合**【戳】**来使用\",\"加解读锁\",\"long stamp = lock.readLock(); lock.unlockRead(stamp); \",\"加解写锁\",\"long stamp = lock.writeLock(); lock.unlockWrite(stamp); \",\"乐观读，StampedLock支持tryOptimisticRead()方法（乐观读），读取完毕后需要做一次戳校验，如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果检验没通过，需要重新获取读锁，保证数据安全。\",\"long stamp = lock.tryOptimisticRead(); // 验戳 if (!lock.validate(stamp)) { // 锁升级 } \",\"代码模拟StampedLock读和写的过程\",\"// 写过程和普通锁没什么区别，都需要全程加锁 public void write(int new Data) { long stamp = lock.writeLock(); try { // do something this.data = newData; } finally { lock.unlockWrite(stamp); } } \",\"public void read(int readTime) { long stamp = lock.tryOptimisticRead(); // do something if (lock.validate(stamp)) { return data; } // stamp别修改过了，需要进行加读锁 try { stamp = lock.readLock(); // do something return data; } finally { lock.unlockRead(stamp); } } \",\"StampedLock的缺点\",\"为什么StampedLock可以提升并发度的性能，但是不能取代ReentrantLock\",\"不支持条件变量\",\"不支持可重入\"]},\"591\":{\"h\":\"Semaphore\",\"t\":[\"信号量，用来限制能同时访问共享资源的线程上限\",\"Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多可以有n个线程同时访问。\",\"应用：使用Semaphore限流，在访问高峰期，限制请求线程数量，让请求线程阻塞，高峰期过去再释放许可。\",\"Semaphore的构造函数\",\"public Semaphore(int permits) { sync = new NonfairSync(permits); } NonfairSync(int permits) { super(permits); } Sync(int permits) { setState(permits); } \",\"由代码可以看出，Semaphore传入的参数permits最终设置为state的个数\",\"加锁解锁流程\",\"刚开始，permits(state)为3，并且同时5个线程来获取资源\",\"假设Thread-1，Thread-2，Thread-4 cas 竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞\",\"这时Thread-4释放了锁，状态如下：\",\"接下来Thread-0竞争成功，state再次设置为0，设置自己的head节点，断开原来的head节点，unpark接下来的Thread-3节点，但是由于state=0，因此Thread-3在尝试不成功后再次进入park状态\"]},\"592\":{\"h\":\"CountdownLatch\",\"t\":[\"用来进行线程同步协作，等待所有线程完成倒计时后再恢复运行。\",\"和Semaphore类似，构造函数传入的count值最终都会赋值给state。\",\"public CountDownLatch(int count) { if (count < 0) throw new IllegalArgumentException(\\\"count < 0\\\"); this.sync = new Sync(count); } \",\"比如可以用于王者荣耀玩家加载，只有所有玩家都加载到100%才能开始游戏。\",\"如果需要主线程汇总结果，CountdownLatch就不如future了，主线程通过get方法可以等待其他线程的运行结果，所有线程都运行完了进行汇总。\"]},\"593\":{\"h\":\"Cyclicbarrier\",\"t\":[\"循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置计数个数，每个线程执行到某个需要**“同步”的时刻调用await()方法进行等待，当等待的线程数满足计数个数**时，继续执行。\",\"和CountdownLatch和类似，区别就是在于Cyclibarrier计数变为0后下次再调用可以恢复到初始设定的值。CountdownLatch要想恢复设定值只能重新创建新的CountdownLatch对象。\",\"ExecutorService executorService = Executors.newFixedThreadPool(2); CyclicBarrier bar = new CyclicBarrier(2, () -> { log.debug(\\\"task1 task2 finished\\\"); }); for (int i = 0; i < 3; i++) { // 计数变为0后，下次循环计数重置 executorService.submit(() -> { log.debug(\\\"task1 begin...\\\"); try { bar.await(); // 2 - 1 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); executorService.submit(() -> { log.debug(\\\"task2 begin...\\\"); try { bar.await(); // 1 - 1 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); } \",\"注意线程池线程数和CyclicBarrier的计数要一样\",\"比如下面这种情况，task1会优先运行2次，这样就不会达到等待统计两个线程运行结束的预期了\",\"ExecutorService executorService = Executors.newFixedThreadPool(3); CyclicBarrier bar = new CyclicBarrier(2, () -> { log.debug(\\\"task1 task2 finished\\\"); }); for (int i = 0; i < 3; i++) { executorService.submit(() -> { log.debug(\\\"task1 begin...\\\"); try { bar.await(); // 2 - 1 Thread.sleep(1000); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); executorService.submit(() -> { log.debug(\\\"task2 begin...\\\"); try { bar.await(); // 1 - 1 Thread.sleep(3000); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); } \"]},\"594\":{\"h\":\"Java基础\"},\"595\":{\"h\":\"接口和抽象类有什么共同点和区别\",\"t\":[\"共同点：\",\"都不能被实例化\",\"都可以包含抽象方法\",\"都可以有默认的实现方法（Java 8可以用default关键字在接口中定义默认方法）\",\"区别：\",\"接口主要用于对类的行为进行约束，实现了某个接口就有了相应的行为。抽象类主要用于代码复用，强调的是所属关系\",\"一个类只能继承一个抽象类，但是能实现多个接口\",\"接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值。\"]},\"596\":{\"h\":\"equals和hashcode\",\"t\":[\"equals和hashCode都是Object类中的方法。hashCode是为了获取对象的哈希码，这个哈希码的作用是确定对象在哈希表中的索引位置\",\"举个HashSet插入对象的例子，HashSet首先会根据对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值进行比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。我们这样可以大大减少了equals的次数，相应就大大提高了执行速度。\"]},\"597\":{\"h\":\"==与equals的区别\",\"t\":[\"对于基本类型来说，==比较的是值是否相等\",\"对于引用类型来说，==比较的是两个引用是否指向同一个对象地址\",\"对于引用类型来说，equals方法如果没有被重写，equals与==作用一样，如果重写了，比如String则比较的具体内容是否相等。\"]},\"598\":{\"h\":\"包装类型的常量池技术\",\"t\":[\"Byte,Short,Integer,Long这四种包装类默认创建了数值[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True/False\"]},\"599\":{\"h\":\"自动装箱与自动拆箱\",\"t\":[\"装箱： 将基本类型用他们的引用类型包装起来，调用包装类的valueOf()方法\",\"拆箱： 将包装类型转换为基本数据类型，调用了xxxValue()方法\",\"Integer i = 10; // 自动装箱 int n = i; // 自动拆箱 \"]},\"600\":{\"h\":\"ArrayList和LinkedList的区别\",\"t\":[\"是否保证线程安全：ArrayList和LinkedList都是不同步的，也就是都不保证线程安全\",\"ArrayList底层采用的是Object数组，LinkedList采用的是双向链表（JDK 1.6之前采用的是双向循环链表，JDK 1.7取消了循环）\",\"数组和链表在插入删除方面的区别（注意两种结构都需要考虑是在中间操作还是在两端操作）\",\"数组支持随机访问，链表不支持随机访问\"]},\"601\":{\"h\":\"ArrayList的扩容机制\",\"t\":[\"new的时候可以给ArrayList设置数组的长度值，也可以不设置，不设置的情况下，在第一次add时会默认赋值长度为10\",\"每次add操作都会对比add后的长度值与数组原有的长度值，判断是否要扩容\",\"如果需要扩容，默认1.5倍长度进行扩容，先会去创造一个新的长度的数组，再将原来数组赋值过去，完成扩容操作\",\"扩容的时候还是会将扩容后的数据长度与Integer.MAX_VALUE进行对比，以防越界\",\"工作时，我们尽可能给ArrayList一个初始长度，避免扩容操作\"]},\"602\":{\"h\":\"List删除元素问题\",\"t\":[\"java中的fast-fail机制 - r1-12king - 博客园 (cnblogs.com)\",\"List移除元素_肆虐的毛豆的博客-CSDN博客_list删除元素\",\"fail-fast 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。或者一个线程对集合进行删除时也可能会产生。\"]},\"603\":{\"h\":\"Comparable和Comparator的区别\",\"t\":[\"两者都是用于自定义排序的接口\",\"Comparable接口出自java.lang，用compareTo(Object obj)方法来排序\",\"Comparator接口出自java.util，通过compare(Object obj1, Object obj2)来进行排序\"]},\"604\":{\"h\":\"HashSet、LinkedHashSet和TreeSet三者的异同\",\"t\":[\"HashSet、LinkedHashSet和TreeSet都是Set接口的实现类，都能保证数据的唯一性，并且都不是线程安全的\",\"三者的主要区别在于底层数据结构不同，HashSet底层采用的时哈希表（基于HashMap实现），LinkedHashSet底层采用的是链表和哈希表，TreeSet底层采用红黑树\",\"底层数据结构的不同导致应用场景也有所不同。HashSet用于不需要保证元素插入和取出顺序的场景，LinkedHashSet用于保证元素的插入和取出满足FIFO场景，TreeSet用于支持元素的自定义排序场景。\"]},\"605\":{\"h\":\"HashMap的底层实现\",\"t\":[\"JDK 1.8之前链表采用头插法，1.8采用了尾插法\",\"JDK 1.8之前HashMap底层采用的是数组和链表。HashMap通过key的hashcode经过扰动函数后得到hash值，然后通过(n-1)&hash判断当前元素的存放位置（这里n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的hash以及key是否相同，如果相同的话直接覆盖，不相同就通过拉链表解决冲突。\",\"所谓扰动函数指的就是HashMap中的hash方法。目的是为了防止一些实现比较差的hashcode方法，换句话说使用扰动函数之后可以减少碰撞\",\"JDK 1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树之前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"(n-1)&hash的规则决定在扩容后需要对已有元素进行重新hash\"]},\"606\":{\"h\":\"HashMap的扩容机制\",\"t\":[\"针对JDK 1.8\",\"容量（capacity）：hash表数组的大小，默认为16\",\"初始化容量（initial capacity）：创建hash表时指定的初始容量\",\"尺寸（size）：当前hash表中的元素数量\",\"负载（load）：load = size / capacity。负载为0时，表示空的hash表。轻负载的hash表具有冲突少、适宜插入和查询的特点\",\"负载因子（load factor）：决定hash表的最大填满程度（范围是0-1，默认为0.75）\",\"当hash表的负载达到了指定的“负载因子”值时，hash表就会加倍扩容，将原有的对象重新分配，放入新的hash表中，这成为rehashing。rehashing过程很复杂，而且非常消耗性能，所以指定一个合适的“负载因子”值很重要。\"]},\"607\":{\"h\":\"HashMap在JDK 1.7的死链问题\",\"t\":[\"jdk1.7中 hashmap为什么会发生死链?\",\"发生在多线程数组扩容的的情况下\"]},\"608\":{\"h\":\"BIO，NIO，AIO\",\"t\":[\"理解什么是BIO/NIO/AIO\"]},\"609\":{\"h\":\"BIO\",\"t\":[\"BIO基本介绍\",\"Java BIO就是传统的Java IO编程，其相关的类和接口在java.io包下\",\"BIO(Blocking I/O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就会需要启动一个线程来进行处理。如果这个连接不做任何事情就会造成不必要的开销。可以通过线程池进行改善。\",\"BIO模型\",\"BIO问题分析\",\"每个请求都需要创建独立的线程，与对应的客户端进行数据处理\",\"当并发数很大时，需要创建大量的线程来处理连接，系统资源占用较大\",\"连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在Read操作上。或者说连接后无事可做，这些都会造成线程资源的浪费\"]},\"610\":{\"h\":\"NIO\",\"t\":[\"NIO基本介绍\",\"Java NIO全称Java non-blocking IO，指的是JDK提供的新的API。从JDK1.4开始，JAVA提供了一系列改进的I/O的新特性，被统称为NIO，是同步非阻塞的。\",\"NIO相关类都放在了java.nio包下，并对原java.io包中很多类进行了改写\",\"NIO有三大核心部分：Channel（管道）、Buffer（缓冲区）、Selector（选择器）\",\"NIO是面向缓冲区编程的。数据读取到了一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络。\",\"Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到当前可用数据，如果目前没有可用数据时，不会保持线程阻塞，直到数据变为可以读取之前，该线程可以做其他事情。非阻塞写入同理。\",\"BIO模型\",\"NIO三大核心组件\",\"每个Channel对应一个Buffer\",\"一个线程对应一个Selector，一个Selector对应多个Channel\",\"上图反应了有三个Channel注册到了该Selector\",\"程序切换到哪个Channel是由**事件（event）**决定的\",\"Selector会根据不同的事件，在各个通道上切换\",\"Buffer就是一个内存块，底层是有一个数组\",\"数据的读取和写入是通过Buffer（双向的），但是需要flip()切换读写模式。而BIO是单向的，要么是输入流要么是输出流\",\"NIO三大核心组件\",\"Buffer\",\"缓冲区本质上是一个可以读写数据的内存块，可以理解为是一个容器对象（数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录了缓冲区的状态变化情况。\",\"Channel读取或者写入数据必须通过Buffer\",\"Buffer的子类中通过一个对应类型的数组用来存放数据\",\"Buffer常用子类：ByteBuffer,ShortBuffer,CharBuffer,IntBuffer,LongBuffer,DoubleBuffer,FloatBuffer\",\"属性\",\"描述\",\"capacity\",\"容量，即可以容纳的最大数据量；在缓冲区被创建的时候就被指定，无法修改\",\"limit\",\"表示缓冲区的当前终点，不能对缓冲区超过limit的位置进行读写操作，但是limit是可以修改的\",\"position\",\"当前位置，下一个要被读或者写的索引，每次读写缓冲区数据都会改变该值，为下次读写做准备\",\"mark\",\"标记当前position位置，让reset后回到标记位置\",\"Channel\",\"NIO的通道类似于流，但是有如下区别：\",\"通道是双向的可以进行读写，但是流是单向的只能读或者写\",\"通道可以实现异步读写数据\",\"通道可以从缓冲区读取数据，也可以写入数据到缓冲区\",\"常用的Channel有：FileChannel，DatagramChannel，SocketChannel，SocketServerChannel\",\"Selector\",\"Java的NIO使用了非阻塞的I/O方式。可以用一个线程处理若干个客户端连接，就会使用到Selector\",\"Selector能够检测到多个注册通道上是否有事件发生（多个Channel以事件的形式注册到同一个Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理\",\"只有在连接真正有读写事件发生时，才会进行读写，减少了系统开销，并且不必为每个连接都创建一个线程，不用维护多个线程。\",\"避免了多线程之间上下文切换导致的开销。\"]},\"611\":{\"h\":\"AIO\",\"t\":[\"JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程时，通常用到两种模式：Reactor和Proactor。Java的NIO就是Reactor，当有事件触发时，服务器得到通知，进行相应的处理。\",\"AIO叫做异步非阻塞IO，引入了异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才会启动线程，特点就是先由操作系统完成后才通知服务端程序启动线程去处理，一般用于连接数较多且连接时长较长的应用。\",\"Reactor和Proactor\",\"两种IO多路复用方案：Reactor和Proactor\",\"Reactor模式是基于同步IO，Proactor模式是和异步IO相关的\"]},\"612\":{\"h\":\"总结\",\"t\":[\"BIO、NIO、AIO使用场景分析\",\"BIO方式适用于连接数较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4之前唯一的选择，程序较为简单容易实现\",\"NIO方式适用于连接数目多且连接比较短的架构，比如聊天服务器等等，JDK1.4开始支持\",\"AIO方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作，JDK1.7开始支持\",\"NIO、BIO对比\",\"BIO是以流的形式处理数据，而NIO以块（Buffer）的方式处理数据，块IO的效率比流IO高很多\",\"BIO是阻塞的，而NIO是非阻塞的\",\"BIO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector用于监听多个通道事件，因此使用单个线程可以监听多个客户端通道\"]},\"613\":{\"h\":\"JDK8新特性\"},\"614\":{\"h\":\"Lambda\",\"t\":[\"lambda针对函数式接口进行简化编程，相对还算比较容易。\",\"在排序方面比较常用，示例如下：\",\"Collections.sort(employees, (e1, e2) -> { if (e1.getAge() == e2.getAge()) { return e2.getName().compareTo(e1.getName()); } return Integer.compare(e1.getAge(), e2.getAge()); }); \",\"我们还可以自己定义函数式接口完成相关操作，示例如下：\",\"/** * 1 声明函数式接口，接口中声明抽象方法，public String getValue(String str); * 2 声明类 Test，类中编写方法使用接口作为参数，将一个字符串转换成大写并作为方法的返回值。 * 3 再将一个字符串的第 2个和第 4 个索引位置进行截取子串。 **/ public class Test { public static String strHandler(String str, MyFunction t) { return t.getValue(str); } public static void main(String[] args) { String str = \\\"abcdEfG\\\"; String s1 = strHandler(str, s -> s.toUpperCase()); System.out.println(s1); String s2 = strHandler(str, s -> s.substring(2, 5)); System.out.println(s2); } } @FunctionalInterface interface MyFunction { String getValue(String str); } \",\"除此之外，Java拥有四大内置函数式接口，其区别在于参数和返回值有所区别：\",\"Consumer< T > : 消费型接口 void accept(T t); // 产生指定个数整数并放入集合中 Supplier< T > : 供给型接口 T get(); // 处理字符串 Function< T, R > : 函数型接口 R apply(T t); // 将满足条件的字符串添加到集合中去 Predicate< T > : 断言型接口 boolean test(T t); \"]},\"615\":{\"h\":\"Stream\",\"t\":[\"默认有如下数据：\",\"static List<Employee> employees = Arrays.asList( new Employee(\\\"张三\\\", 33, 6666.66, StatusEnum.BUSY), new Employee(\\\"李四\\\", 23, 5555.66, StatusEnum.BUSY), new Employee(\\\"王五\\\", 33, 4444.66, StatusEnum.BUSY), new Employee(\\\"赵六\\\", 43, 3333.66, StatusEnum.BUSY), new Employee(\\\"田七\\\", 53, 2222.66, StatusEnum.BUSY), new Employee(\\\"田七\\\", 53, 2222.66, StatusEnum.BUSY) ); \"]},\"616\":{\"h\":\"筛选与切片\",\"t\":[\"filter-- 接收 Lambda，从流中排除某些元素。\",\"limit-- 截断流，使其元素不超过给定数量。\",\"skip(n)-- 跳过元素，返同一个扔了前n个元素的流。若流中元素不足n个，则返回一个空流。与与limit(n)互补\",\"distinct-- 筛选，通过流所生成元素的hashCode()和equals()去除重复元素\",\"employees.stream() .filter(t -> t.getAge() > 30) .limit(2) .distinct() .forEach(System.out::println); \"]},\"617\":{\"h\":\"映射\",\"t\":[\"map-- 接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素\",\"flatMap-- 接收一个的函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\",\"public class Test2 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"aaa\\\", \\\"bbb\\\", \\\"ccc\\\", \\\"ddd\\\"); Stream<Stream<Character>> streamStream = list.stream() .map(Test2::filterCharacters); // {{a,a,a},{b,b,b}...} streamStream.forEach(str -> str.forEach(System.out::println)); System.out.println(\\\"---------------------\\\"); Stream<Character> characterStream = list.stream() .flatMap(Test2::filterCharacters); // {a,a,a,b,b,b...} characterStream.forEach(System.out::println); } private static Stream<Character> filterCharacters(String str) { List<Character> list = new ArrayList<>(); for (Character c : str.toCharArray()) { list.add(c); } return list.stream(); } } \"]},\"618\":{\"h\":\"排序\",\"t\":[\"sorted()-- 自然排序\",\"sorted(Comparator com)-- 定制排序\",\"employees.stream() .sorted(Comparator.comparingInt(Employee::getAge)) .forEach(System.out::println); \"]},\"619\":{\"h\":\"查找与匹配\",\"t\":[\"allMatch-- 检查是否匹配所有元素\",\"anyMatch-- 检查是否至少匹配一个元素\",\"noneMatch-- 检查是否没有匹配所有元素\",\"findFirst-- 返回第一个元素\",\"findAny-- 返回当前流中的任意元素\",\"count-- 返回流中元泰的总个数\",\"max-- 返回流中最大值\",\"min-- 返回流中最小值\",\"boolean b = employees.stream() .noneMatch(s -> s.getStatus().equals(StatusEnum.VOCATION)); System.out.println(b); Optional<Employee> first = employees.stream() .sorted(Comparator.comparingInt(Employee::getAge)) .findFirst(); System.out.println(first.get()); \"]},\"620\":{\"h\":\"规约\",\"t\":[\"reduce(T identity, BinaryOperator) / reduce(BinaryOperator)：可以将流中元素反复结合起来，得到一个值。\",\"List<Integer> list = Arrays.asList(1, 3, 4, 5, 6, 7, 8, 9); // 累加 Integer sum = list.stream() .reduce(0, Integer::sum); System.out.println(sum); // 工资总和 Double allSalary = employees.stream() .map(Employee::getSalary) .reduce(0D, Double::sum); System.out.println(allSalary); DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getSum()); \"]},\"621\":{\"h\":\"收集\",\"t\":[\"collect-- 将流转换为其他形式。接收一个Collector接口的实现，用于Stream中元素做汇总的方法。\",\"List<String> names = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); names.forEach(System.out::println); System.out.println(\\\"--------------------------------\\\"); HashSet<String> collect = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); System.out.println(\\\"--------------------------------\\\"); employees.stream() .collect(Collectors.toMap(Employee::getName, Function.identity())) .forEach((k, v) -> { System.out.println(k + \\\" \\\" + v); }); System.out.println(\\\"--------------------------------\\\"); Employee employee = employees.stream() .max(Comparator.comparingDouble(Employee::getSalary)) .get(); System.out.println(employee); Double aDouble = employees.stream() .map(Employee::getSalary) .min(Double::compare) .get(); System.out.println(aDouble); System.out.println(\\\"--------------------------------\\\"); Map<StatusEnum, List<Employee>> collect1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(collect1); \"]},\"622\":{\"h\":\"JVM\"},\"623\":{\"h\":\"双亲委派机制\",\"t\":[\"工作原理\",\"如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行\",\"如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器\",\"如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制\",\"优点\",\"避免类的重复加载\",\"保护程序安全，防止核心API被随意篡改（比如：java.lang.String)\"]},\"624\":{\"h\":\"沙箱安全机制\",\"t\":[\"比如自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器进行加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java/lang/String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\"]},\"625\":{\"h\":\"使用PC寄存器存储字节码指令地址有什么用呢？\",\"t\":[\"为什么用PC寄存器记录当前线程的执行地址呢\",\"因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪条指令开始继续执行（PC寄存器为什么要设定为线程私有）\",\"JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令\"]},\"626\":{\"h\":\"举例栈溢出的情况\",\"t\":[\"栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM\"]},\"627\":{\"h\":\"方法中定义的局部变量是否线程安全\",\"t\":[\"还得根据变量是基本类型和引用类型两种情况分类讨论\",\"如果只有一个线程操作此数据，则必是线程安全的\",\"如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 \",\"如果对象是在内部产生，并在内部消亡，没有返回到外部，那么他是线程安全的，反之则是线程不安全的。（逃逸分析）\"]},\"628\":{\"h\":\"Minor GC、Major GC、Full GC\",\"t\":[\"JVM在进行GC时，并非每次都对三个内存（新生代、老年代；方法区）区域一起回收，大部分时候回收的都是指新生代\",\"针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）\",\"部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： \",\"新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集\",\"老年代收集（Major GC / Old GC）：只是老年代的垃圾收集 \",\"目前，只有CMS GC会有单独收集老年代的行为\",\"注意，很多时候Major GC会和Full GC混淆使用，需要具体分析是老年代回收还是整堆回收\",\"混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 \",\"目前只有G1 GC会有这种行为\",\"整堆收集（Full GC)：收集整个Java堆和方法区的垃圾收集\"]},\"629\":{\"h\":\"创建对象的方式\",\"t\":[\"new\",\"Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public\",\"Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求\",\"使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()\",\"使用反序列化：从文件中、网络中获取一个对象的二进制流\"]},\"630\":{\"h\":\"创建对象的步骤\",\"t\":[\"判断对象对应的类是否加载、链接、初始化 \",\"虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。\",\"为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。\",\"如果内存规整：指针碰撞\",\"不规整：空闲列表\",\"处理并发安全问题 \",\"采用CAS失败重试、区域加锁保证更新的原子性\",\"每个线程先分配一块TLAB\",\"初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用\",\"设置对象的对象头\",\"执行init方法进行初始化 \",\"在Java程序员的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随由invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。\",\"判断对象所对应的类是否加载链接初始化，如果没有则需要在双亲委派模式下对相应的类进行加载。\",\"为对象分配内存。分配内存的方式有碰撞指针和空闲列表，具体使用哪种方式得看内存是否规整，规整的话使用碰撞指针否则使用空闲列表。\",\"内存分配的并发问题 \",\"采用CAS配上失败重试的方式保证操作的原子性。CAS是乐观锁的一种实现方式。\",\"为每个线程分配一块TLAB，TLAB是每个线程独享的，不存在线程安全问题\",\"初始化零值：内存分配完成后虚拟机需要将分配到内存的空间都初始化零值，这一操作保证了对象的实例字段在Java代码中不赋值就可以使用。\",\"设置对象的对象头\",\"执行init方法：在上面的工作都完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但是从Java程序的视角来看，对象创建才刚刚开始。\"]},\"631\":{\"h\":\"对象的内存布局\",\"t\":[\"对象头 \",\"运行时元数据（Mark Word） \",\"哈希值\",\"GC分代年龄\",\"锁状态标志\",\"线程持有的锁\",\"偏向线程ID\",\"偏向时间戳\",\"类型指针（Klass Word）：指向类元数据InstanceKlass，确定该对象所属类型\",\"说明：如果是数组，还需记录数组的长度\",\"实例数据 \",\"说明：对象真正存储的有效数据，包括程序代码中定义的各种类型的字段\",\"对齐填充\"]},\"632\":{\"h\":\"字符串拼接\",\"t\":[\"常量与常量引用的拼接结果在常量池，原理是编译期优化\",\"常量池中不会存在相同内容的变量\",\"拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder\",\"如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为： \",\"如果存在，则返回字符串在常量池中的地址\",\"如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址\"]},\"633\":{\"h\":\"GC大厂面试题\",\"t\":[\"蚂蚁金服\",\"你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？\",\"JVM GC算法有哪些，目前的JDK版本采用什么回收算法？\",\"G1回收器讲下回收过程GC是什么？为什么要有GC？\",\"GC的两种判定方法？CMS收集器与G1收集器的特点\",\"百度\",\"说一下GC算法，分代回收说下\",\"垃圾收集策略和算法\",\"天猫\",\"JVM GC原理，JVM怎么回收内存\",\"CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？\",\"滴滴\",\"Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的\",\"京东\",\"你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，\",\"包括原理，流程，优缺点。垃圾回收算法的实现原理\",\"阿里\",\"讲一讲垃圾回收算法。\",\"什么情况下触发垃圾回收？\",\"如何选择合适的垃圾收集算法？\",\"JVM有哪三种垃圾回收器？\",\"字节跳动\",\"常见的垃圾回收器算法有哪些，各有什么优劣？\",\"System.gc()和Runtime.gc()会做什么事情？\",\"Java GC机制？GC Roots有哪些？\",\"Java对象的回收方式，回收算法。\",\"CMS和G1了解么，CMS解决什么问题，说一下回收的过程。\",\"CMS回收停顿了几次，为什么要停顿两次?\"]},\"634\":{\"h\":\"增量收集算法\",\"t\":[\"基本思想\",\"如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，知道垃圾收集完成。\",\"缺点\",\"使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程和上下文切换的消耗，会使得垃圾回收的总成本上升，造成系统吞吐量的下降。\"]},\"635\":{\"h\":\"System.gc()的理解\",\"t\":[\"在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\"]},\"636\":{\"h\":\"内存溢出和内存泄漏的原因\",\"t\":[\"内存溢出\",\"Java虚拟机的堆内存设置不够\",\"代码中创建了大量大对象，并且长时间不能被垃圾收集器收集\",\"内存泄漏\",\"单例对象：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。\",\"一些提供close的资源未关闭导致内存泄漏\"]},\"637\":{\"h\":\"评估GC的性能指标\",\"t\":[\"吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间a + 内存回收的时间b）a/(a+b)\",\"垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。\",\"暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。\",\"收集频率：相对于应用程序的执行，收集操作发生的频率。\",\"内存占用：Java堆区所占的内存大小。\",\"快速：一个对象从诞生到被回收所经历的时间。\",\"吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。\",\"这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。\",\"简单来说，主要抓住两点：\",\"吞吐量\",\"暂停时间\"]},\"638\":{\"h\":\"7种经典的垃圾回收器\",\"t\":[\"以串并行分类：\",\"串行回收器：Serial、Serial old\",\"并行回收器：ParNew、Parallel Scavenge、Parallel old\",\"并发回收器：CMS、G1\",\"分代分类：\",\"新生代收集器：Serial、ParNew、Parallel Scavenge；\",\"老年代收集器：Serial old、Parallel old、CMS；\",\"整堆收集器：G1；\",\"垃圾收集器组合关系：\",\"两个收集器间有连线，表明它们可以搭配使用：\",\"Serial/Serial old\",\"Serial/CMS （JDK9废弃）\",\"ParNew/Serial Old （JDK9废弃）\",\"ParNew/CMS\",\"Parallel Scavenge/Serial Old （预计废弃）\",\"Parallel Scavenge/Parallel Old\",\"G1\",\"其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。\",\"（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。\",\"（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）\",\"（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）\",\"为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。\",\"虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。\"]},\"639\":{\"h\":\"垃圾回收器的选择\",\"t\":[\"HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？\",\"如果你想要最小化地使用内存和并行开销，请选Serial GC；\",\"如果你想要最大化应用程序的吞吐量，请选Parallel GC；\",\"如果你想要最小化GC的中断或停顿时间，请选CMS GC。\"]},\"640\":{\"h\":\"JDK 后续版本中 CMS 的变化\",\"t\":[\"JDK9新特性：CMS被标记为Deprecate了（JEP291） \",\"如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。\",\"JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器， \",\"如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM\"]},\"641\":{\"h\":\"代码模板\"},\"642\":{\"h\":\"排序\",\"t\":[\"img\"]},\"643\":{\"h\":\"选择排序\",\"t\":[\"找到最大（小）的元素\",\"将其与最后一个元素进行交换\",\"重复\"]},\"644\":{\"h\":\"插入排序\",\"t\":[\"标注需排序的元素，将其前方的序列视为已排序序列(从0开始)\",\"将需排序的元素与已排序序列进行比较，找到合适的插入位置，将此位置起的所有已排序序列后移一位\",\"将待排序元素插入到后移序列的前方\"]},\"645\":{\"h\":\"快排\",\"t\":[\"确定分界点x\",\"调整区间：小于等于x的放在区间左边，大于等于x的放在区间右边\",\"分治递归处理子问题\",\"public class Main { public static void quick_sort(int[] q, int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i < j) { do i++; while (q[i] < x); do j--; while (q[j] > x); if (i < j) { int tmp = q[i]; q[i] = q[j]; q[j] = tmp; } } quick_sort(q, l, j); quick_sort(q, j + 1, r); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] q = new int [100005]; for (int i = 0; i < n; i++) { q[i] = sc.nextInt(); } quick_sort(q, 0, n - 1); for (int i = 0; i < n; i++) { System.out.println(q[i] + \\\" \\\"); } } } \"]},\"646\":{\"h\":\"埃氏筛\",\"t\":[\"#include<bits/stdc++.h> using namespace std; const int MAXN = 5e6+5; int isPrime[MAXN]; void getPrime() { memset(isPrime, -1, sizeof isPrime); isPrime[1] = 0; for (int i = 2; i * i <= MAXN; i++) { if (isPrime[i]) { for (int j = i * i; j <= MAXN; j += i) { isPrime[j] = 0; } } } } int main () { getPrime(); for (int i = 2; i <= 100; i++) { if (isPrime[i]) { cout << i << endl; } } return 0; } \"]},\"647\":{\"h\":\"背包\"},\"648\":{\"h\":\"01背包\",\"t\":[\"【动态规划/背包问题】那就从 0-1 背包问题开始讲起吧 ... (qq.com)\",\"import java.util.Scanner; /** * @author Vingkin * @since 2022/5/8 20:33 */ public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); // 物品个数 int V = sc.nextInt(); // 背包体积 int[] v = new int[N]; // 体积 int[] w = new int[N]; // 价值 for (int i = 0; i < N; i++) { v[i] = sc.nextInt(); w[i] = sc.nextInt(); } int[][] f = new int[N][V + 1]; // 先处理「考虑第一件物品」的情况 for (int i = 0; i <= V; i++) { f[0][i] = i >= v[0] ? w[0] : 0; } // 再处理「考虑其余物品」的情况 for (int i = 1; i < N; i++) { for (int j = 0; j <= V; j++) { if (j >= v[i]) { // f[i - 1][j]表示不选第i个物品，f[i - 1][j - v[i]] + w[i]表示选择第i个物品 f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } else { f[i][j] = f[i - 1][j]; } } } System.out.println(f[N - 1][V]); } } \",\"空间优化\",\"求第 i 行第 c 个格子的值时，只依赖于第 i−1 行的第 c 个格子和 c−v[i] 个格子。\",\"问题来自于上一行 c 以及前面的区域，我们必须让 c 以递减的形式更新，以保证能够取到上一行的前面的值（因为 c 递减更新的话前面是旧值，我们恰恰需要上一行的旧值）\",\"import java.util.Scanner; /** * @author Vingkin * @since 2022/5/8 20:33 */ public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; // 体积 int[] w = new int[N]; // 价值 for (int i = 0; i < N; i++) { v[i] = sc.nextInt(); w[i] = sc.nextInt(); } int[] f = new int[V + 1]; for (int i = 0; i < N; i++) { for (int j = V; j >= v[i]; j--) { f[j] = Math.max(f[j], f[j - v[i]] + w[i]); } } System.out.println(f[V]); } } \"]},\"649\":{\"h\":\"完全背包\",\"t\":[\"完全背包和01背包相比就是每件物品数量无限\",\"【动态规划/背包问题】从数学角度推导「完全背包」与「01 背包」之间的遍历顺序关系 (qq.com)\",\"状态转移方程：dp[i][j]=max(dp[i−1][j],dp[i−1][j−k∗v[i]]+k∗w[i])\",\"class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[N][C + 1]; // 先预处理第一件物品 for (int j = 0; j <= C; j++) { // 显然当只有一件物品的时候，在容量允许的情况下，能选多少件就选多少件 int maxK = j / v[0]; dp[0][j] = maxK * w[0]; } // 处理剩余物品 for (int i = 1; i < N; i++) { for (int j = 0; j <= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[i - 1][j]; // 考虑第 i 件物品的情况 int y = 0; for (int k = 1 ;; k++) { if (j < v[i] * k) { break; } y = Math.max(y, dp[i - 1][j - k * v[i]] + k * w[i]); } dp[i][j] = Math.max(n, y); } } return dp[N - 1][C]; } } \",\"class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[] dp = new int[C + 1]; for (int i = 0; i < N; i++) { for (int j = 0; j <= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[j]; // 考虑第 i 件物品的情况 int y = j - v[i] >= 0 ? dp[j - v[i]] + w[i] : 0; dp[j] = Math.max(n, y); } } return dp[C]; } } \"]},\"650\":{\"h\":\"计算机网络\"},\"651\":{\"h\":\"Get和Post的区别\",\"t\":[\"【网络协议】彻底弄清POST和GET请求的区别，这次你GET了么 - SegmentFault 思否\",\"【前端 · 面试 】HTTP 总结（五）—— GET 和 POST - SegmentFault 思否\"]},\"652\":{\"h\":\"输入网址到网页显示期间发生了什么\",\"t\":[\"键入网址到网页显示，期间发生了什么？\",\"解析URL，生成HTTP请求信息\",\"DNS解析\",\"TCP连接（三次握手）\",\"建立连接\",\"四次挥手\"]},\"653\":{\"c\":[\"interview\"]},\"654\":{\"c\":[\"interview\"]},\"655\":{\"h\":\"数据结构\"},\"656\":{\"h\":\"红黑树\",\"t\":[\"节点是红色或黑色\",\"根节点是黑色\",\"每个叶子节点都是黑色的空节点（NIL节点）\",\"每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红节点）\",\"从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\",\"img\"]},\"657\":{\"h\":\"布隆过滤器\",\"t\":[\"布隆过滤器\"]},\"658\":{\"h\":\"什么是布隆过滤器\",\"t\":[\"首先，我们需要了解布隆过滤器的概念。\",\"布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。\",\"布隆过滤器示意图\",\"位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\",\"总结：一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。\"]},\"659\":{\"h\":\"布隆过滤器的原理介绍\",\"t\":[\"当一个元素加入布隆过滤器中的时候，会进行如下操作：\",\"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\",\"根据得到的哈希值，在位数组中把对应下标的值置为 1。\",\"当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：\",\"对给定元素再次进行相同的哈希计算；\",\"得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"举个简单的例子：\",\"布隆过滤器hash计算\",\"如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。\",\"如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。\",\"综上，我们可以得出：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\"]},\"660\":{\"h\":\"布隆过滤器使用场景\",\"t\":[\"判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。\",\"去重：比如爬给定网址的时候对已经爬取过的 URL 去重。\"]},\"661\":{\"h\":\"SDS\",\"t\":[\"Redis 数据结构 | 小林coding (xiaolincoding.com)\",\"字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。\",\"Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。\",\"既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。\",\"要了解这一点，得先来看看 char* 字符数组的结构。\"]},\"662\":{\"h\":\"C 语言字符串的缺陷\",\"t\":[\"C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。\",\"比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：\",\"img\",\"没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\\\\0”？\",\"在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\\\\0”表示，意思是指字符串的结束。\",\"因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\\\\0” 来决定要不要停止操作，如果当前字符不是 “\\\\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\\\\0” 是则说明字符串结束了，就要停止操作。\",\"举个例子，C 语言获取字符串长度的函数 strlen，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\\\\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：\",\"img\",\"很明显，C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方*）\",\"C 语言字符串用 “\\\\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\\\\0” 字符，这时在操作这个字符串时就会提早结束，比如 “xiao\\\\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：\",\"img\",\"因此，除了字符串的末尾之外，字符串里面不能含有 “\\\\0” 字符，否则最先被程序读入的 “\\\\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，不能保存像图片、音频、视频文化这样的二进制数据（*这也是一个可以改进的地方*）\",\"另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。\",\"举个例子，strcat 函数是可以将两个字符串拼接在一起。\",\"//将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src); \",\"C 语言的字符串是不会记录自身的缓冲区大小的，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方*）。\",\"而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，对字符串的操作效率不高。\",\"好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：\",\"获取字符串长度的时间复杂度为 O（N）；\",\"字符串的结尾是以 “\\\\0” 字符标识，字符串里面不能包含有 “\\\\0” 字符，因此不能保存二进制数据；\",\"字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；\",\"Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。\"]},\"663\":{\"h\":\"SDS 结构设计\",\"t\":[\"下图就是 Redis 5.0 的 SDS 的数据结构：\",\"img\",\"结构中的每个成员变量分别介绍下：\",\"len，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。\",\"alloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。\",\"flags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。\",\"buf[]，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。\",\"总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。\",\"O（1）复杂度获取字符串长度（这也可以说是Redis为什么快的一个原因）\",\"C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。\",\"而 Redis 的 SDS 结构因为加入了 len 成员变量，那么获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）。\",\"二进制安全\",\"因为 SDS 不需要用 “\\\\0” 字符来标识字符串结尾了，而是有个专门的 len 成员变量来记录长度，所以可存储包含 “\\\\0” 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\\\\0” 字符。\",\"因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。\",\"通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。\",\"不会发生缓冲区溢出\",\"C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。\",\"所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 alloc - len 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。\",\"而且，当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容），以满足修改所需的大小。\",\"在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。\",\"这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，有效的减少内存分配次数。\",\"所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。\",\"节省内存空间\",\"SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。\",\"Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。\",\"这 5 种类型的主要区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同。\",\"比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：\",\"struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; uint16_t alloc; unsigned char flags; char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; uint32_t alloc; unsigned char flags; char buf[]; }; \",\"可以看到：\",\"sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。\",\"sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。\",\"之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间。比如，在保存小字符串时，结构头占用空间也比较少。\",\"除了设计不同类型的结构体，Redis 在编程上还使用了专门的编译优化来节省内存空间，即在 struct 声明了 __attribute__ ((packed)) ，它的作用是：告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐。\",\"比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。\",\"举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：\",\"#include <stdio.h> struct test1 { char a; int b; } test1; int main() { printf(\\\"%lu\\\\n\\\", sizeof(test1)); return 0; } \",\"大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。\",\"img\",\"这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。\",\"如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 __attribute__ ((packed)) 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。\",\"比如，我用 __attribute__ ((packed)) 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：\",\"#include <stdio.h> struct __attribute__((packed)) test2 { char a; int b; } test2; int main() { printf(\\\"%lu\\\\n\\\", sizeof(test2)); return 0; } \",\"这时打印的结果是 5（1 个字节 char + 4 字节 int）。\",\"img\",\"可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。\"]},\"664\":{\"h\":\"压缩列表\",\"t\":[\"Redis 数据结构 | 小林coding (xiaolincoding.com)\",\"压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。\",\"但是，压缩列表的缺陷也是有的：\",\"不能保存过多的元素，否则查询效率就会降低；\",\"新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。\",\"因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。\"]},\"665\":{\"h\":\"压缩列表结构设计\",\"t\":[\"压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。\",\"img\",\"压缩列表在表头有三个字段：\",\"zlbytes，记录整个压缩列表占用对内存字节数；\",\"zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；\",\"zllen，记录压缩列表包含的节点数量；\",\"zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。\",\"在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。\",\"另外，压缩列表节点（entry）的构成如下：\",\"img\",\"压缩列表节点包含三部分内容：\",\"prevlen，记录了「前一个节点」的长度；\",\"encoding，记录了当前节点实际数据的类型以及长度；\",\"data，记录了当前节点的实际数据；\",\"当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的。\",\"分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。\",\"压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：\",\"如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；\",\"如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；\",\"encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：\",\"如果当前节点的数据是整数，则 encoding 会使用 1 字节的空间进行编码。\",\"如果当前节点的数据是字符串，根据字符串的长度大小，encoding 会使用 1 字节/2字节/5字节的空间进行编码。\"]},\"666\":{\"h\":\"连锁更新\",\"t\":[\"压缩列表除了查找复杂度高的问题，还有一个问题。\",\"压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。\",\"前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：\",\"如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；\",\"如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；\",\"现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：\",\"img\",\"因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。\",\"这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：\",\"img\",\"因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。\",\"多米诺牌的效应就此开始。\",\"img\",\"e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。\",\"正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展.... 一直持续到结尾。\",\"这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下....，\"]},\"667\":{\"h\":\"压缩列表的缺陷\",\"t\":[\"空间扩展操作也就是重新分配内存，因此连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能。\",\"所以说，虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题。\",\"因此，压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的。\",\"虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。\"]},\"668\":{\"h\":\"前缀树（字典树）\",\"t\":[\"public class Trie { public static class TrieNode { // count表示以当前单词结尾的单词数量 int count; // prefix表示以该处节点之前的字符串为前缀的单词数量（包括当前节点） int prefix; TrieNode[] nextNode = new TrieNode[26]; public TrieNode() { count = 0; prefix = 0; } } //插入一个新单词 public static void insert(TrieNode root, String str) { if (root == null || str.length() == 0) { return; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，创建一个新节点 if (root.nextNode[c[i] - 'a'] == null) { root.nextNode[c[i] - 'a'] = new TrieNode(); } root = root.nextNode[c[i] - 'a']; root.prefix++;//注意，应该加在后面 } //以该节点结尾的单词数+1 root.count++; } //查找该单词是否存在，如果存在返回数量，不存在返回-1 public static int search(TrieNode root, String str) { if (root == null || str.length() == 0) { return -1; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，表名该单词不存在 if (root.nextNode[c[i] - 'a'] == null) { return -1; } //如果存在，则继续向下遍历 root = root.nextNode[c[i] - 'a']; } //如果count==0,也说明该单词不存在 if (root.count == 0) { return -1; } return root.count; } //查询以str为前缀的单词数量 public static int searchPrefix(TrieNode root, String str) { if (root == null || str.length() == 0) { return -1; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，表名该单词不存在 if (root.nextNode[c[i] - 'a'] == null) { return -1; } //如果存在，则继续向下遍历 root = root.nextNode[c[i] - 'a']; } return root.prefix; } public static void main(String[] args) { TrieNode newNode = new TrieNode(); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"helloworld\\\"); System.out.println(search(newNode, \\\"hello\\\")); System.out.println(searchPrefix(newNode, \\\"h\\\")); } /** 输出：3 4 **/ } \"]},\"669\":{\"h\":\"二叉树构建\",\"t\":[\"数组转换为二叉树\",\"#include<bits/stdc++.h> using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) { val = x; left = NULL; right = NULL; } }; TreeNode* createTree(vector<int>& vec) { vector<TreeNode*> vecNode; TreeNode* root = NULL; for (int i = 0; i < vec.size(); i++) { TreeNode* node = new TreeNode(vec[i]); if (vec[i] != -1) vecNode.push_back(node); else vecNode.push_back(NULL); if (i == 0) root = node; } for (int i = 0; i * 2 + 2 < vecNode.size(); i++) { if (vecNode[i] != NULL) { vecNode[i] -> left = vecNode[2 * i + 1]; vecNode[i] -> right = vecNode[2 * i + 2]; } } return root; } void preOrder(TreeNode *root) { if (!root) return; cout << root -> val << ' '; preOrder(root -> left); preOrder(root -> right); } void l(TreeNode *root) { if (!root) return; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int len = q.size(); for (int i = 0; i < len; i++) { TreeNode* node = q.front(); q.pop(); cout << node -> val << ' '; if (node -> left) { q.push(node -> left); } if (node -> right) { q.push(node -> right); } } } } int main () { vector<int> vec; int n; cin >> n; for (int i = 0; i < n; i++) { int a; cin >> a; vec.push_back(a); } TreeNode* root = createTree(vec); preOrder(root); cout << endl; print(root); return 0; } \"]},\"670\":{\"h\":\"图的构建\"},\"671\":{\"h\":\"并查集\",\"t\":[\"class UnionFind { private Map<Integer,Integer> father; public UnionFind() { father = new HashMap<>(); } public void add(int x) { if (!father.containsKey(x)) { father.put(x, null); } } public void merge(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY){ father.put(rootX,rootY); } } public int find(int x) { int root = x; while(father.get(root) != null){ root = father.get(root); } while(x != root){ int original_father = father.get(x); father.put(x,root); x = original_father; } return root; } public boolean isConnected(int x, int y) { return find(x) == find(y); } } \"]},\"672\":{\"h\":\"树状数组\",\"t\":[\"聊聊树状数组 Binary Indexed Tree\"]},\"673\":{\"h\":\"单点更新，区间求和\",\"t\":[\"class TreeArray { private int[] tree; private int[] nums; // nums下标从0开始，tree下标从1开始 // 初始化 public TreeArray(int[] nums) { this.tree = new int[nums.length + 1]; this.nums = nums; for (int i = 0; i < nums.length; i++) { add(i + 1, nums[i]); } } // 单点修改 public void update(int index, int val) { add(index + 1, val - nums[index]); nums[index] = val; } // 区间查询 public int sumRange(int left, int right) { return prefixSum(right + 1) - prefixSum(left); } private int lowBit(int x) { return x & -x; } // index位置增加val private void add(int index, int val) { while (index < tree.length) { tree[index] += val; index += lowBit(index); } } // 查询前index位置的前缀和 private int prefixSum(int index) { int sum = 0; while (index > 0) { sum += tree[index]; index -= lowBit(index); } return sum; } } \"]},\"674\":{\"h\":\"操作系统\"},\"675\":{\"h\":\"操作系统IO介绍\",\"t\":[\"再过60分钟你就能了解同步异步、阻塞非阻塞、IO多路复用、select、poll、epoll等概念啦\"]},\"676\":{\"h\":\"用户空间和内核空间（用户态和内核态）\",\"t\":[\"现在的操作系统都是采用虚拟存储器，对于32位操作系统而言，他的寻址空间（虚拟存储空间）为4G(232)。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作系统内核（kernel），保证内核的安全，操作系统将虚拟空间划分成两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节供内核使用，成为内核空间，而将较低的3G字节供各个进程使用，称为用户空间。\",\"什么时候会从用户态切换到内核态？\",\"系统调用：用户进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如fork()就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux的 int 80H 中断，也可以称为软中断。\",\"异常：当CPU在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程，也就是切换到了内核态，如缺页异常。\",\"中断：当CPU在执行用户态的进程时，外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂时执行下一个即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。\",\"为什么用户态与内核态的转换开销大？\",\"保留用户态现场（上下文、寄存器、用户栈等）\",\"复制用户态参数，用户栈切换到内核栈，进入内核态\",\"额外的检查（内核代码对用户不信任）\",\"执行内核态代码\",\"复制内核态代码执行结果，回到用户态\",\"恢复用户态现场（上下文、寄存器、用户栈等）\"]},\"677\":{\"h\":\"文件描述符\",\"t\":[\"文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\",\"文件描述符在形式上是一个非负整数。实际上，他是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一个概念往往只适用于UNIX、Linux这样的操作系统。\"]},\"678\":{\"h\":\"缓存 I/O\",\"t\":[\"缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会被拷贝到操作系统内核的缓冲区中，然后才会从操作系统的内核缓冲区拷贝到应用程序的地址空间。\",\"缓存I/O的缺点：\",\"数据在传输过程中需要在应用程序地址空间和内核之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。\"]},\"679\":{\"h\":\"I/O 模式\",\"t\":[\"对于缓存I/O，对于一次I/O访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，他会经历两个阶段：\",\"等待数据准备\",\"将数据从内核拷贝到进程中\",\"正是因为这两个阶段，linux系统产生了下面五种网络模式的方案\",\"阻塞I/O（blocking IO）\",\"非阻塞I/O（nonblocking IO）\",\"I/O多路复用（IO multiplexing）\",\"信号驱动I/O（signal driven IO）\",\"异步I/O（asynchronous IO）\",\"阻塞I/O\",\"阻塞IO\",\"在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程如上图所示。\",\"当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，他就会将数据从kernel中拷贝到用户内存中，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\",\"blocking IO的特点就是IO执行的两个阶段都会被block\",\"非阻塞I/O\",\"非阻塞IO\",\"在linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程如上图所示。\",\"当用户发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，他就知道数据还没有准备好，于是他可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么他马上就将数据拷贝到了用户内存，然后返回。\",\"nonblocking IO的特点是用户进程需要不断地主动询问kernel数据好了没有\",\"I/O多路复用\",\"IO多路复用\",\"IO multiplexing就是我们说的select，poll和epoll，有些地方也称这种IO方式为事件驱动IO（event driven IO）。select/epoll的好处就在于单个process就可以同时处理多个网络的IO。他的基本原理就是select，poll和epoll。不断地轮询所负责的所有socket，当某个socket有数据到达了就通知用户进程。\",\"当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\",\"IO多路复用的特点是通过一种机制使得一个进程能够同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select函数就可以返回\",\"这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call（select和recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，用select的优势在于它可以同时处理多个connection\",\"所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。\",\"在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。\",\"异步I/O\",\"异步IO\",\"Linux下的asynchronous IO其实用的很少。流程如上图所示。\",\"用户进程发起read操作之后，立刻就可以开始去做其他事。而另一方面，从kernel的角度，当它收到一个asynchronous read之后，首先他会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉他read操作完成了。\",\"blocking和non-blocking的区别？\",\"调用blocking IO会一直block住对应的进程知道操作完成，而non-blocking IO在kernel准备数据的情况下会立刻返回。\",\"不同I/O对比\",\"IO对比\"]},\"680\":{\"h\":\"select、poll和epoll的区别\",\"t\":[\"select，poll和epoll都是IO多路复用的机制。IO多路复用就是通过一种机制使得一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步IO，因为他们需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核空间拷贝到用户空间。\",\"select\",\"select函数监视的文件描述符分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据可读、可写或者except）或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\",\"select目前几乎在所有的平台上支持，其良好跨平台支持也是他的一个优点。select的一个缺点在于单个进程能够监视文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。\",\"本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：\",\"select最大的缺陷就是单个进程所打开的fd数量是有一定限制的，它由FD_SETSIZE设置，默认值是1024.一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位机默认是1024个，64位机默认是2048个。\",\"对socket进行扫描时是线性扫描，采用轮询方式，效率较低。\",\"需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。\",\"poll\",\"poll本质上和select没有区别。他将用户传入的fd数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前线程，知道设备就绪或者主动超时，被唤醒后他又要再次遍历fd。他没有最大连接数的限制，原因是他是基于链表来存储的，但是同样有缺点：\",\"大量的fd数组被整体复制于用户空间和内核空间，而不管这样的复制是否有意义\",\"poll还有一个特点就是“水平触发”，如果报告了fd后没有被处理，那么下次poll时会再次报告该fd\",\"从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态，因此随着监视的文件描述符数量的增长，其效率也会线性下降。\",\"epoll\",\"epoll是select和poll的增强版本。相对于select和poll而言，epoll更加灵活，没有文件描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\",\"epoll支持水平触发和边缘触发，最大的特点就在于边缘触发，他只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。\",\"epoll的优点\",\"没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存大约能监听10万个端口）\",\"效率提升，不是轮询的方式，不会随着fd数目的增加使得效率降低。只有活跃可用的fd才会调用callback函数。即epoll最大的优点就在于他只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll\",\"内存拷贝，利用mmap()文件映射内存加速和内核空间的消息传递。即epoll使用mmap减少复制开销\",\"水平触发和边缘触发(Level trigger / edge trigger)\",\"epoll对文件描述符的操作有两种模式：LT(Level Trigger)和ET(Edge Trigger)。LT模式是默认模式，LT和ET的区别如下：\",\"LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件下次调用epoll_wait时，会再次相应应用程序并通知此事件。\",\"ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次相应应用程序并通知此事件。\",\"ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，防止由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\",\"总结\",\"在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描。\",\"epoll实现通过epoll_ctl()来注册一个文件扫描符，一旦基于某个文件扫描符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。\",\"如果没有大量的闲置连接和死亡连接，那么epoll的效率并不会比select/poll高很多，但是如果很多的话，就会发现epoll的效率大大高于select/poll。\",\"支持一个进程所能打开的最大连接数\",\"fd剧增后带来的IO效率问题\",\"消息传递方式\",\"select\",\"单个进程所能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上大小就是32*32，64位机器上就是32*64），当然我们可以对其进行修改，然后重新编译内核但是性能可能受到影响，这需要进一步测试\",\"因为每次调用时都会对连接进行线性遍历，所以随着fd的增加会造成遍历速度慢的“线性下降性能问题”\",\"内核需要将消息传递到用户空间，都需要内核的拷贝动作\",\"poll\",\"poll本质上和select没有区别，但是他没有最大连接数的限制，原因是他是基于链表来存储的\",\"同上\",\"同上\",\"epoll\",\"虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接\",\"因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃的socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能有性能问题\",\"epoll通过内核空间和用户空间共享一块内存来实现\",\"在选择select，poll和epoll时要根据具体的使用场合以及这三种方式的自身特点：\",\"表面上epoll的性能更好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调\",\"select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善\"]},\"681\":{\"h\":\"操作系统内存管理介绍\"},\"682\":{\"h\":\"内存管理主要是做什么\",\"t\":[\"操作系统的内存管理主要负责内存的分配与回收（malloc函数申请内存，free函数释放内存），另外地址转换也就是将逻辑地址转换为相应物理地址等功能也是操作系统内存管理做的事情。\"]},\"683\":{\"h\":\"常见的几种内存管理机制\",\"t\":[\"简单分为连续分配管理方式和非连续分配管理方式。连续分配管理方式是指为一个程序分配一个连续的内存空间，常见的如块式管理。同样地，非连续分配管理方式允许一个程序员使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理和段式管理。\",\"块式管理\",\"远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大校的块，每个块只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每块中未被利用的空间，我们称之为碎片。\",\"页式管理\",\"在该方式中，将用户程序的地址空间分为若干个固定大小的区域，称为“页”或“页面”。相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同。这样可将用户程序的任一页放入任一物理块中，实现离散分配。\",\"页（页面）和物理块（页框）\",\"页面对应着逻辑地址，物理块对应着物理地址\",\"页式管理中将进程的逻辑地址空间分成若干个页，并为每个页加以编号。相应地将内存的物理地址空间分成若干个块，同样加以编号。在为进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块，从而会形成碎片。\",\"页的地址结构：\",\"页表\",\"页表的作用是实现页号到物理块号的地址映射\",\"如何将逻辑地址转换为物理地址？\",\"通过页号去页表查找该页号对应的块号，然后将物理块号与页内偏移地址拼接成实际物理地址\",\"访问内存的有效时间\",\"从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所要花费的总时间，称为内存的有效访问时间(Effective Access Time, EAT)。\",\"假设访问一次内存的时间为t，在基本分页存储管理方式中，有效访问时间为第一次访间（即通过页号访问页表得到物理块号）与第二次访问内存时间（即将页表项中的物理块号与页内偏移地址拼接成实际物理地址后访问实际物理地址所耗费的时间）之和：EAT=t+t=2t\",\"快表和多级页表\",\"虚拟地址到物理地址的转换要快（快表解决）\",\"虚拟地址空间大，页表也会很大的问题（多级页表解决）\",\"快表\",\"快表的作用和缓存很类似\",\"在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器（快表），并将此页号与高速缓冲中的所有页号进行比较，若其中有与此相匹配地页号，便表示所要访问的页表项在快表中。如果在快表中未找到对应地页表项，则还需再次访问内存中的页表，在内存中找到后将该页表项存入快表的一个寄存器单元中。\",\"在引入快表的分页存储管理方式中，访问内存的有效时间为：EAT=a×λ+(t+λ)(1−a)+t，其中λ为访问快表所需时间，t为访问一次内存所需时间，a为快表的命中率。\",\"多级页表\",\"以二级页表而言，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散的存储在不同的物理块中（二级页表）。同样为离散分配的页表在建立一张页表，称为外层页表（一级页表）。\",\"多级页表的提出主要是解决下面两个问题：\",\"对于页表所需的内存空间，可采用离散分配的方式，以解决难以找到一块连续的大内存空间的问题。\",\"只将当前需要的部分页表项调入内存，其余的页表项仍然驻留在磁盘上，需要时再调入。\",\"总结\",\"为了提高内存的空间性能，提出了多级页表的概念；但是空间性能的提升是以时间为代价的，因此为了补充损失的时间性能，提出了快表的概念。不论使快表还是多级页表实际上都利用到了程序的局部性原理。\",\"段式管理\",\"这是为了满足用户要求而形成的一种存储管理方式。它把用户程序的地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。在存储器分配时，以段为单位，这些段在内存中可以不相邻接，所以也同样实现了离散分配。\",\"页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D和栈段S等。段式管理通过段表对应逻辑地址和物理地址。\",\"段页式管理\",\"这是分页和分段两种存储管理方式相结合的产物。它同时具有两者的优点，是目前应用较广泛的一种存储管理方式。\",\"段页式存储管理结合了页式管理和段式管理的优点。简单来说段页式管理机制就是先把用户程序分成若干个段，再把每个段分成若干个页。也就是说段页式管理机制中段与段之间以及段的内部都是离散的。（对于段式管理，一个段就是一个连续的物理地址空间）\",\"分段和分页的共同点与区别\",\"共同点 \",\"分页机制和分段机制都是为了提高内存利用率，减少内存碎片\",\"页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的\",\"区别 \",\"页的大小是固定的，由操作系统决定；而段的大小不固定，取决于具体程序\",\"分页仅仅是为了满足操作系统内存管理的需求，是物理单位。分段则是信息的逻辑单位，在程序中体现为主程序段，数据段等等，其目的是为了更好地满足用户的需求\"]},\"684\":{\"h\":\"逻辑地址和物理地址\",\"t\":[\"程序员一般只能和逻辑地址打交道，像C语言中指针存储的数值就可以理解为逻辑地址。而物理地址指的是真实物理内存中的地址，是内存单元真正的地址。\",\"CPU中的内存管理单元就是用于将逻辑地址翻译成物理地址。\"]},\"685\":{\"h\":\"为什么要有虚拟地址空间呢？\",\"t\":[\"如果直接把物理地址暴露出来的话会带来严重的问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难\",\"使用虚拟地址访问内存有以下优势：\",\"程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区\",\"程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动（虚拟内存）\",\"不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存\"]},\"686\":{\"h\":\"操作系统虚拟内存介绍\",\"t\":[\"在说操作系统虚拟内存之前有必要说一下局部性原理。局部性原理是虚拟内存技术的基础，正是因为程序具有局部性原理，才可以只装入部分程序到内存就开始运行。\"]},\"687\":{\"h\":\"局部性原理\",\"t\":[\"局部性原理有表现在下述两个方面：\",\"时间局部性：如果程序中的某条指令被执行，则不久后该指令可能再次执行；如果某数据被访问过，则不久后该数据可能再次被访问。产生时间局部性的典型原因是程序中存在着大量的循环操作。\",\"空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\",\"时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。\"]},\"688\":{\"h\":\"虚拟内存（虚拟存储器）\",\"t\":[\"基于局部性原理可知，应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。程序在运行时，如果他所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页（段），OS还须再利用页（段）的置换功能，将内存中暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去。这样，便可使一个大的用户程序在较小的内存空间中运行，也可在内存中同时装入更多的进程，使它们并发执行。\",\"虚拟内存类似于时间换空间，用CPU的计算，页的调入调出，换来了一个更大的空间来支持程序的运行。其重要意义在于定义了一个连续的虚拟地址空间，并且把内存扩展到磁盘空间。\"]},\"689\":{\"h\":\"虚拟存储器的实现方法\",\"t\":[\"虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配的方式，要求必须将作业装入一个连续的内存区域中，则必须事先为作业一次性地申请一个足以容纳整个作业的内存空间，以便能将作业分先后地多次装入内存。这不仅会使相当一部分内存空间都处于暂时或“永久”地空闲状态，造成内存资源的严重浪费，而且无法、也无意义再从逻辑上扩大内存容量。所以，虚拟存储器地实现，都毫无例外地建立在离散分配存储管理方式的基础上。\",\"虚拟内存的实现有以下三种方式：\",\"请求分页存储管理：分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数页面的程序（及数据）即可启动运行。以后，再通过调页功能及页面置换功能陆续地把即将运行的页面调入内存，同时把暂时不运行的页面换出到外存上。\",\"请求分段存储管理：请求分段系统是在分段系统的基础上，增加了请求调段及分段置换功能后形成的段式虚拟存储系统。它允许用户程序只要装入少数段的程序和数据即可启动运行。以后通过调段功能和段的置换功能将暂时不运行的段调出，再调入即将运行的段。\",\"请求段页式存储管理\",\"不管是上面那种实现方式，我们都需要：\",\"一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了\",\"缺页（段）中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序\",\"虚拟地址空间：实现虚拟地址向物理地址的转换\",\"这边说的请求分页存储管理和操作系统内存管理中的分页存储管理有何不同？\",\"请求分页存储管理建立在分页存储管理之上。它们的根本区别在于是否将程序所需的全部地址空间都装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚拟内存，而分页存储管理不能提供虚存。\"]},\"690\":{\"h\":\"页面置换算法\",\"t\":[\"在进程运行过程中，若其所要访问的页面不在内存，而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，操作系统必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，通常可以把页面置换算法看成是淘汰页面的规则\",\"最佳页面置换算法（OPT）：\",\"最佳页面置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法\",\"先进先出页面置换算法（FIFO）：\",\"总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰\",\"最近最久未使用页面置换算法（LRU）：\",\"LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需淘汰一个页面时，选择现有页面中其t值最大的淘汰，即选择最近最久未使用的页面进行淘汰。\",\"假设有一进程，有五个物理块，所访问的页面的页面序号为：4,7,0,7,1,0,1,2,1,2,6，其演示图如下：（其实并没有用到栈的特性）\",\"最少使用页面置换算法（LFU）：\",\"该置换算法选择在之前时期使用最少的也页面作为淘汰页\"]},\"691\":{\"h\":\"粘包与半包\"},\"692\":{\"h\":\"粘包现象\",\"t\":[\"服务端代码\",\"public class HelloWorldServer { static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class); void start() { NioEventLoopGroup boss = new NioEventLoopGroup(1); NioEventLoopGroup worker = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"connected {}\\\", ctx.channel()); super.channelActive(ctx); } @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"disconnect {}\\\", ctx.channel()); super.channelInactive(ctx); } }); } }); ChannelFuture channelFuture = serverBootstrap.bind(8080); log.debug(\\\"{} binding...\\\", channelFuture.channel()); channelFuture.sync(); log.debug(\\\"{} bound...\\\", channelFuture.channel()); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); log.debug(\\\"stoped\\\"); } } public static void main(String[] args) { new HelloWorldServer().start(); } } \",\"客户端代码希望发送 10 个消息，每个消息是 16 字节\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; for (int i = 0; i < 10; i++) { ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); ctx.writeAndFlush(buffer); } } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"127.0.0.1\\\", 8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\",\"08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding... 08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound... 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| +--------+-------------------------------------------------+----------------+ 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE \"]},\"693\":{\"h\":\"半包现象\",\"t\":[\"客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\",\"ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); } ctx.writeAndFlush(buffer); \",\"为现象明显，服务端修改一下接收缓冲区，其它代码不变\",\"serverBootstrap.option(ChannelOption.SO_RCVBUF, 10); \",\"服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\",\"08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding... 08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound... 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000010| 00 01 02 03 |.... | +--------+-------------------------------------------------+----------------+ 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |............ | +--------+-------------------------------------------------+----------------+ 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE \",\"注意\",\"serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\"]},\"694\":{\"h\":\"现象分析\",\"t\":[\"粘包\",\"现象，发送 abc def，接收 abcdef\",\"原因 \",\"应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\",\"滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\",\"Nagle 算法：会造成粘包\",\"半包\",\"现象，发送 abcdef，接收 abc def\",\"原因 \",\"应用层：接收方 ByteBuf 小于实际发送数据量\",\"滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\",\"MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\",\"本质是因为 TCP 是流式协议，消息无边界\",\"滑动窗口\",\"TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\",\"为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\",\"窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\",\"图中深色的部分即要发送的数据，高亮的部分即窗口\",\"窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\",\"如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\",\"接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\",\"MSS 限制\",\"链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\",\"以太网的 MTU 是 1500\",\"FDDI（光纤分布式数据接口）的 MTU 是 4352\",\"本地回环地址的 MTU 是 65535 - 本地测试不走网卡\",\"MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\",\"ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\",\"TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\",\"MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\",\"Nagle 算法\",\"即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由\",\"该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送 \",\"如果 SO_SNDBUF 的数据达到 MSS，则需要发送\",\"如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\",\"如果 TCP_NODELAY = true，则需要发送\",\"已发送的数据都收到 ack 时，则需要发送\",\"上述条件不满足，但发生超时（一般为 200ms）则需要发送\",\"除上述情况，延迟发送\"]},\"695\":{\"h\":\"解决方案\",\"t\":[\"短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\",\"每一条消息采用固定长度，缺点浪费空间\",\"每一条消息采用分隔符，例如 \\\\n，缺点需要转义\",\"每一条消息分为 head 和 body，head 中包含 body 的长度\"]},\"696\":{\"h\":\"方法1：短链接\",\"t\":[\"以解决粘包为例\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { // 分 10 次发送 for (int i = 0; i < 10; i++) { send(); } } private static void send() { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"conneted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); ctx.writeAndFlush(buffer); // 发完即关 ctx.close(); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"localhost\\\", 8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"输出，略\",\"半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\"]},\"697\":{\"h\":\"方法2：固定长度\",\"t\":[\"让所有数据包长度固定（假设长度为 8 字节），服务器端加入\",\"ch.pipeline().addLast(new FixedLengthFrameDecoder(8)); \",\"客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); // 发送内容随机的数据包 Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { byte[] bytes = new byte[8]; for (int j = 0; j < r.nextInt(8); j++) { bytes[j] = (byte) c; } c++; buffer.writeBytes(bytes); } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......| |00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......| |00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....| |00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......| |00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....| +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding... 12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound... 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 00 00 00 00 |aaaa.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 00 00 00 00 00 00 00 |b....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 00 00 00 00 00 00 |cc...... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 00 00 00 00 00 00 00 |d....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 00 00 00 00 00 |........ | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 66 66 00 00 00 00 |ffff.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 67 00 00 00 00 00 |ggg..... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 00 00 00 00 00 00 00 |h....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 00 00 00 |iiiii... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 00 00 00 00 |jjjj.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE \",\"缺点是，数据包的大小不好把握\",\"长度定的太大，浪费\",\"长度定的太小，对某些数据包又显得不够\"]},\"698\":{\"h\":\"方法3：固定分隔符\",\"t\":[\"服务端加入，默认以 \\\\n 或 \\\\r\\\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\",\"ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); \",\"客户端在每条消息之后，加入 \\\\n 分隔符\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { for (int j = 1; j <= r.nextInt(16)+1; j++) { buffer.writeByte((byte) c); } buffer.writeByte(10); c++; } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee| |00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg| |00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.| |00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a |jjjjjjjjjjj. | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 |a | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 62 62 |bbb | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 63 |ccc | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 64 |dd | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 65 65 65 65 65 65 65 65 65 65 |eeeeeeeeee | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 |ff | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 67 67 67 67 67 |ggggggg | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 68 68 68 |hhhh | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 69 69 |iiiiiii | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a |jjjjjjjjjjj | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE \",\"缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\"]},\"699\":{\"h\":\"方法4：预设长度\",\"t\":[\"在发送消息前，先约定用定长字节表示接下来数据的长度\",\"// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数 ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1)); \",\"客户端代码\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { byte length = (byte) (r.nextInt(16) + 1); // 先写入长度 buffer.writeByte(length); // 再 for (int j = 1; j <= length; j++) { buffer.writeByte((byte) c); } c++; } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb| |00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd| |00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee| |00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff| |00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii| |00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj| |00000060| 6a |j | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding... 14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound... 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 61 61 61 61 61 |aaaaaaaaa | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 62 62 62 62 62 62 62 62 |bbbbbbbbb | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 63 63 63 63 |cccccc | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 64 64 64 64 64 64 64 |dddddddd | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65 |eeeeeeeeeeeeeee | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66 |fffffffffffff | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 |gg | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 68 |hh | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69 |iiiiiiiiiiiiii | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a |jjjjjjjjj | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETEd \"]},\"700\":{\"h\":\"聊天室案例\"},\"701\":{\"h\":\"聊天室业务介绍\",\"t\":[\"/** * 用户管理接口 */ public interface UserService { /** * 登录 * @param username 用户名 * @param password 密码 * @return 登录成功返回 true, 否则返回 false */ boolean login(String username, String password); } \",\"/** * 会话管理接口 */ public interface Session { /** * 绑定会话 * @param channel 哪个 channel 要绑定会话 * @param username 会话绑定用户 */ void bind(Channel channel, String username); /** * 解绑会话 * @param channel 哪个 channel 要解绑会话 */ void unbind(Channel channel); /** * 获取属性 * @param channel 哪个 channel * @param name 属性名 * @return 属性值 */ Object getAttribute(Channel channel, String name); /** * 设置属性 * @param channel 哪个 channel * @param name 属性名 * @param value 属性值 */ void setAttribute(Channel channel, String name, Object value); /** * 根据用户名获取 channel * @param username 用户名 * @return channel */ Channel getChannel(String username); } \",\"/** * 聊天组会话管理接口 */ public interface GroupSession { /** * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null * @param name 组名 * @param members 成员 * @return 成功时返回组对象, 失败返回 null */ Group createGroup(String name, Set<String> members); /** * 加入聊天组 * @param name 组名 * @param member 成员名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group joinMember(String name, String member); /** * 移除组成员 * @param name 组名 * @param member 成员名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group removeMember(String name, String member); /** * 移除聊天组 * @param name 组名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group removeGroup(String name); /** * 获取组成员 * @param name 组名 * @return 成员集合, 没有成员会返回 empty set */ Set<String> getMembers(String name); /** * 获取组成员的 channel 集合, 只有在线的 channel 才会返回 * @param name 组名 * @return 成员 channel 集合 */ List<Channel> getMembersChannel(String name); } \"]},\"702\":{\"h\":\"聊天室业务-登录\",\"t\":[\"@Slf4j public class ChatServer { public static void main(String[] args) { NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() { @Override protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception { String username = msg.getUsername(); String password = msg.getPassword(); boolean login = UserServiceFactory.getUserService().login(username, password); LoginResponseMessage message; if(login) { message = new LoginResponseMessage(true, \\\"登录成功\\\"); } else { message = new LoginResponseMessage(false, \\\"用户名或密码不正确\\\"); } ctx.writeAndFlush(message); } }); } }); Channel channel = serverBootstrap.bind(8080).sync().channel(); channel.closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } } } \",\"@Slf4j public class ChatClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1); AtomicBoolean LOGIN = new AtomicBoolean(false); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); // ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(\\\"client handler\\\", new ChannelInboundHandlerAdapter() { // 接收响应消息 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"msg: {}\\\", msg); if ((msg instanceof LoginResponseMessage)) { LoginResponseMessage response = (LoginResponseMessage) msg; if (response.isSuccess()) { // 如果登录成功 LOGIN.set(true); } // 唤醒 system in 线程 WAIT_FOR_LOGIN.countDown(); } } // 在连接建立后触发 active 事件 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { // 负责接收用户在控制台的输入，负责向服务器发送各种消息 new Thread(() -> { Scanner scanner = new Scanner(System.in); System.out.println(\\\"请输入用户名:\\\"); String username = scanner.nextLine(); System.out.println(\\\"请输入密码:\\\"); String password = scanner.nextLine(); // 构造消息对象 LoginRequestMessage message = new LoginRequestMessage(username, password); // 发送消息 ctx.writeAndFlush(message); System.out.println(\\\"等待后续操作...\\\"); try { WAIT_FOR_LOGIN.await(); } catch (InterruptedException e) { e.printStackTrace(); } // 如果登录失败 if (!LOGIN.get()) { ctx.channel().close(); return; } while (true) { System.out.println(\\\"==================================\\\"); System.out.println(\\\"send [username] [content]\\\"); System.out.println(\\\"gsend [group name] [content]\\\"); System.out.println(\\\"gcreate [group name] [m1,m2,m3...]\\\"); System.out.println(\\\"gmembers [group name]\\\"); System.out.println(\\\"gjoin [group name]\\\"); System.out.println(\\\"gquit [group name]\\\"); System.out.println(\\\"quit\\\"); System.out.println(\\\"==================================\\\"); String command = scanner.nextLine(); String[] s = command.split(\\\" \\\"); switch (s[0]){ case \\\"send\\\": ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2])); break; case \\\"gsend\\\": ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2])); break; case \\\"gcreate\\\": Set<String> set = new HashSet<>(Arrays.asList(s[2].split(\\\",\\\"))); set.add(username); // 加入自己 ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set)); break; case \\\"gmembers\\\": ctx.writeAndFlush(new GroupMembersRequestMessage(s[1])); break; case \\\"gjoin\\\": ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1])); break; case \\\"gquit\\\": ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1])); break; case \\\"quit\\\": ctx.channel().close(); return; } } }, \\\"system in\\\").start(); } }); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \"]},\"703\":{\"h\":\"聊天室业务-单聊\",\"t\":[\"服务器端将 handler 独立出来\",\"登录 handler\",\"@ChannelHandler.Sharable public class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception { String username = msg.getUsername(); String password = msg.getPassword(); boolean login = UserServiceFactory.getUserService().login(username, password); LoginResponseMessage message; if(login) { SessionFactory.getSession().bind(ctx.channel(), username); message = new LoginResponseMessage(true, \\\"登录成功\\\"); } else { message = new LoginResponseMessage(false, \\\"用户名或密码不正确\\\"); } ctx.writeAndFlush(message); } } \",\"单聊 handler\",\"@ChannelHandler.Sharable public class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception { String to = msg.getTo(); Channel channel = SessionFactory.getSession().getChannel(to); // 在线 if(channel != null) { channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent())); } // 不在线 else { ctx.writeAndFlush(new ChatResponseMessage(false, \\\"对方用户不存在或者不在线\\\")); } } } \"]},\"704\":{\"h\":\"聊天室业务-群聊\",\"t\":[\"创建群聊\",\"@ChannelHandler.Sharable public class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception { String groupName = msg.getGroupName(); Set<String> members = msg.getMembers(); // 群管理器 GroupSession groupSession = GroupSessionFactory.getGroupSession(); Group group = groupSession.createGroup(groupName, members); if (group == null) { // 发生成功消息 ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + \\\"创建成功\\\")); // 发送拉群消息 List<Channel> channels = groupSession.getMembersChannel(groupName); for (Channel channel : channels) { channel.writeAndFlush(new GroupCreateResponseMessage(true, \\\"您已被拉入\\\" + groupName)); } } else { ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + \\\"已经存在\\\")); } } } \",\"群聊\",\"@ChannelHandler.Sharable public class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception { List<Channel> channels = GroupSessionFactory.getGroupSession() .getMembersChannel(msg.getGroupName()); for (Channel channel : channels) { channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent())); } } } \",\"加入群聊\",\"@ChannelHandler.Sharable public class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception { Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername()); if (group != null) { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群加入成功\\\")); } else { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群不存在\\\")); } } } \",\"退出群聊\",\"@ChannelHandler.Sharable public class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception { Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername()); if (group != null) { ctx.writeAndFlush(new GroupJoinResponseMessage(true, \\\"已退出群\\\" + msg.getGroupName())); } else { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群不存在\\\")); } } } \",\"查看成员\",\"@ChannelHandler.Sharable public class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception { Set<String> members = GroupSessionFactory.getGroupSession() .getMembers(msg.getGroupName()); ctx.writeAndFlush(new GroupMembersResponseMessage(members)); } } \"]},\"705\":{\"h\":\"聊天室业务-退出\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class QuitHandler extends ChannelInboundHandlerAdapter { // 当连接断开时触发 inactive 事件 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { SessionFactory.getSession().unbind(ctx.channel()); log.debug(\\\"{} 已经断开\\\", ctx.channel()); } // 当出现异常时触发 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { SessionFactory.getSession().unbind(ctx.channel()); log.debug(\\\"{} 已经异常断开 异常是{}\\\", ctx.channel(), cause.getMessage()); } } \"]},\"706\":{\"h\":\"聊天室业务-空闲检测\"},\"707\":{\"h\":\"连接假死\",\"t\":[\"原因\",\"网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\",\"公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\",\"应用程序线程阻塞，无法进行数据读写\",\"问题\",\"假死的连接占用的资源不能自动释放\",\"向假死的连接发送数据，得到的反馈是发送超时\",\"服务器端解决\",\"怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\",\"// 用来判断是不是 读空闲时间过长，或 写空闲时间过长 // 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件 ch.pipeline().addLast(new IdleStateHandler(5, 0, 0)); // ChannelDuplexHandler 可以同时作为入站和出站处理器 ch.pipeline().addLast(new ChannelDuplexHandler() { // 用来触发特殊事件 @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{ IdleStateEvent event = (IdleStateEvent) evt; // 触发了读空闲事件 if (event.state() == IdleState.READER_IDLE) { log.debug(\\\"已经 5s 没有读到数据了\\\"); ctx.channel().close(); } } }); \",\"客户端定时心跳\",\"客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\",\"// 用来判断是不是 读空闲时间过长，或 写空闲时间过长 // 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件 ch.pipeline().addLast(new IdleStateHandler(0, 3, 0)); // ChannelDuplexHandler 可以同时作为入站和出站处理器 ch.pipeline().addLast(new ChannelDuplexHandler() { // 用来触发特殊事件 @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{ IdleStateEvent event = (IdleStateEvent) evt; // 触发了写空闲事件 if (event.state() == IdleState.WRITER_IDLE) { // log.debug(\\\"3s 没有写数据了，发送一个心跳包\\\"); ctx.writeAndFlush(new PingMessage()); } } }); \"]},\"708\":{\"h\":\"协议设计与解析\"},\"709\":{\"h\":\"为什么需要协议？\",\"t\":[\"TCP/IP 中消息传输基于流的方式，没有边界。\",\"协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\",\"例如：在网络上传输\",\"下雨天留客天留我不留 \",\"是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\",\"一种解读\",\"下雨天留客，天留，我不留 \",\"另一种解读\",\"下雨天，留客天，留我不？留 \",\"如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\",\"定长字节表示内容长度 + 实际内容 \",\"例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\",\"0f下雨天留客06天留09我不留 \",\"小故事\",\"很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\",\"年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\",\"私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\",\"双方唇枪舌战，你来我往，真个是不亦乐乎！\",\"这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\"]},\"710\":{\"h\":\"redis 协议举例\",\"t\":[\"NioEventLoopGroup worker = new NioEventLoopGroup(); byte[] LINE = {13, 10}; try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { ch.pipeline().addLast(new LoggingHandler()); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { // 会在连接 channel 建立成功后，会触发 active 事件 @Override public void channelActive(ChannelHandlerContext ctx) { set(ctx); get(ctx); } private void get(ChannelHandlerContext ctx) { ByteBuf buf = ctx.alloc().buffer(); buf.writeBytes(\\\"*2\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"get\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"aaa\\\".getBytes()); buf.writeBytes(LINE); ctx.writeAndFlush(buf); } private void set(ChannelHandlerContext ctx) { ByteBuf buf = ctx.alloc().buffer(); buf.writeBytes(\\\"*3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"set\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"aaa\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"bbb\\\".getBytes()); buf.writeBytes(LINE); ctx.writeAndFlush(buf); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; System.out.println(buf.toString(Charset.defaultCharset())); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"localhost\\\", 6379).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } \"]},\"711\":{\"h\":\"http 协议举例\",\"t\":[\"NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new HttpServerCodec()); ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() { @Override protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception { // 获取请求 log.debug(msg.uri()); // 返回响应 DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK); byte[] bytes = \\\"<h1>Hello, world!</h1>\\\".getBytes(); response.headers().setInt(CONTENT_LENGTH, bytes.length); response.content().writeBytes(bytes); // 写回响应 ctx.writeAndFlush(response); } }); /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"{}\\\", msg.getClass()); if (msg instanceof HttpRequest) { // 请求行，请求头 } else if (msg instanceof HttpContent) { //请求体 } } });*/ } }); ChannelFuture channelFuture = serverBootstrap.bind(8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } \"]},\"712\":{\"h\":\"自定义协议要素\",\"t\":[\"魔数，用来在第一时间判定是否是无效数据包\",\"版本号，可以支持协议的升级\",\"序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk\",\"指令类型，是登录、注册、单聊、群聊... 跟业务相关\",\"请求序号，为了双工通信，提供异步能力\",\"正文长度\",\"消息正文\"]},\"713\":{\"h\":\"编解码器\",\"t\":[\"根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\",\"@Slf4j public class MessageCodec extends ByteToMessageCodec<Message> { @Override protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception { // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(0); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(msg); byte[] bytes = bos.toByteArray(); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerType = in.readByte(); byte messageType = in.readByte(); int sequenceId = in.readInt(); in.readByte(); // 跳过对齐填充的一个字节 int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); Message message = (Message) ois.readObject(); log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); log.debug(\\\"{}\\\", message); out.add(message); } } \",\"测试\",\"EmbeddedChannel channel = new EmbeddedChannel( new LoggingHandler(), new LengthFieldBasedFrameDecoder( 1024, 12, 4, 0, 0), new MessageCodec() ); // encode LoginRequestMessage message = new LoginRequestMessage(\\\"zhangsan\\\", \\\"123\\\", \\\"张三\\\"); // channel.writeOutbound(message); // decode ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); new MessageCodec().encode(null, message, buf); ByteBuf s1 = buf.slice(0, 100); ByteBuf s2 = buf.slice(100, buf.readableBytes() - 100); s1.retain(); // 引用计数 2 channel.writeInbound(s1); // release 1 channel.writeInbound(s2); \",\"解读\"]},\"714\":{\"h\":\"什么时候可以加 @Sharable💡\",\"t\":[\"当 handler 不保存状态时，就可以安全地在多线程下被共享\",\"但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\",\"如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类\",\"@Slf4j @ChannelHandler.Sharable /** * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的 */ public class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> { @Override protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception { ByteBuf out = ctx.alloc().buffer(); // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(0); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(msg); byte[] bytes = bos.toByteArray(); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); outList.add(out); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerType = in.readByte(); byte messageType = in.readByte(); int sequenceId = in.readInt(); in.readByte(); int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); Message message = (Message) ois.readObject(); log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); log.debug(\\\"{}\\\", message); out.add(message); } } \"]},\"715\":{\"h\":\"响应式流\"},\"716\":{\"h\":\"概念\",\"t\":[\"Reactive Streams为我们提供了Java中的Reactive Programming的通用API。传统异步编程的写法，不同任务分别在不同的线程中执行，协调这些线程执行的先后顺序、线程间的依赖顺序是一件非常麻烦的事情，而Reactive Streams就是为了解决该问题。Reactive Streams API中仅仅包含了如下四个接口：\",\"//发布者 public interface Publisher < T > { public void subscribe（Subscriber <？super T > s）; } //订阅者 public interface Subscriber < T > { public void onSubscribe（Subscription s）; public void onNext（T t）; public void onError（Throwable t）; public void onComplete（）; } //表示Subscriber消费Publisher发布的一个消息的生命周期 public interface Subscription { public void request(long n); public void cancel(); } //处理器，表示一个处理阶段，它既是订阅者也是发布者，并且遵守两者的契约 public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { } \"]},\"717\":{\"h\":\"示例1\",\"t\":[\"通过Publisher，Subscriber和Subscription完成一个发布-订阅模式\",\"public class ReactiveStreamDemo { public static void main(String[] args) throws InterruptedException { // 1、定义发布者，发布的数据类型是Integer SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(); // 2、定义订阅者 Subscriber<Integer> subscriber = new Subscriber<>() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { // 保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); } @Override public void onNext(Integer item) { // 接收到一个数据，处理 System.out.println(\\\"接收到数据：\\\" + item); // 处理完调用request再请求一个数据 this.subscription.request(1); // 或者已经达到目标，调用cancel告诉发布者不在调用数据 // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"处理完了\\\"); } }; // 3、发布者订阅者之间建立订阅关系 publisher.subscribe(subscriber); // 4、生产数据并发布 Stream.of(1, 2, 3, 4, 5, 6, 7, 8) .forEach(i -> { publisher.submit(i); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } }); // 5、结束后 关闭发布者 // 正式环境应放在finally或者try-resource中确保关闭 publisher.close(); Thread.currentThread().join(1000); } } \"]},\"718\":{\"h\":\"示例2\",\"t\":[\"在示例1的基础上，添加了processor进行中间处理\",\"public class MyProcessor extends SubmissionPublisher<String> implements Processor<Integer, String> { private static final String[] NUMBER_TO_CHINESE = {\\\"零\\\", \\\"壹\\\", \\\"贰\\\", \\\"叁\\\", \\\"肆\\\", \\\"伍\\\", \\\"陆\\\", \\\"柒\\\", \\\"捌\\\", \\\"玖\\\"}; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { // 保存订阅关系，需要用它来发布响应 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); } @Override public void onNext(Integer item) { // 接收到一个数据，进行处理 System.out.println(\\\"处理器接收到的数据：\\\" + item); // 过滤掉小于0的，发布出去 if (item >= 0) { this.submit(NUMBER_TO_CHINESE[item]); } // 处理完调用request再请求一个数据 this.subscription.request(1); // 或者已经达到目标，调用cancel告诉发布者不在调用数据 // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"处理器处理完了\\\"); } } \",\"public class ReactiveStreamDemo2 { public static void main(String[] args) throws InterruptedException { // 1、定义发布者，发布的数据类型是Integer SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(); // 2、定义处理器，对数据进行过滤，并转换成String类型 MyProcessor processor = new MyProcessor(); // 3、发布者和处理器之间建立订阅关系 publisher.subscribe(processor); // 4、定义最终订阅者，消费String类型数据 Subscriber<String> subscriber = new Subscriber<>() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { this.subscription = subscription; this.subscription.request(1); } @Override public void onNext(String item) { System.out.println(\\\"接收到处理后的数据：\\\" + item); this.subscription.request(1); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"订阅者处理完了\\\"); } }; // 5、处理器和最终订阅者建立订阅关系 processor.subscribe(subscriber); // 6、生产数据并发布 // submit是一个阻塞式方法 Stream.of(-3, -2, -1, 0, 1, 2, 3, 4, 5) .forEach(i -> { publisher.submit(i); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } }); // 7、结束后 关闭发布者 // 正式环境应放在finally或者try-resource中确保关闭 publisher.close(); Thread.currentThread().join(1000); } } \"]},\"719\":{\"h\":\"背压\",\"t\":[\"背压可以理解为订阅者能和发布者交互（通过代码里面的调用request和cancel方法交互），可以调节发布者发布数据的速率，解决把订阅者压垮的问题。关键在于上面例子里面的订阅关系Subscription这个接口，他有request和cancel 2个方法，用于通知发布者需要数据和通知发布者不再接受数据。\",\"在JDK9zhong发布者Publisher的实现类SubmissionPublisher的submit方法是block方法。订阅者会有一个缓冲池，默认为Flow.defaultBufferSize() = 256。当订阅者的缓冲池满了之后，发布者调用submit方法发布数据就会被阻塞，发布者就会停（慢）下来；订阅者消费了数据之后（调用Subscription.request方法），缓冲池有位置了，submit方法就会继续执行下去，就是通过这样的机制，实现了调节发布者发布数据的速率，消费得快，生成就快，消费得慢，发布者就会被阻塞，当然就会慢下来了。\"]},\"720\":{\"h\":\"webflux\"},\"721\":{\"h\":\"TODO\"},\"722\":{\"h\":\"Netty优化\"},\"723\":{\"h\":\"扩展序列化算法\",\"t\":[\"序列化，反序列化主要用在消息正文的转换上\",\"序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\",\"反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\",\"目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\",\"// 反序列化 byte[] body = new byte[bodyLength]; byteByf.readBytes(body); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body)); Message message = (Message) in.readObject(); message.setSequenceId(sequenceId); // 序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(message); byte[] bytes = out.toByteArray(); \",\"为了支持更多序列化算法，抽象一个 Serializer 接口\",\"public interface Serializer { // 反序列化方法 <T> T deserialize(Class<T> clazz, byte[] bytes); // 序列化方法 <T> byte[] serialize(T object); } \",\"提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\",\"enum SerializerAlgorithm implements Serializer { // Java 实现 Java { @Override public <T> T deserialize(Class<T> clazz, byte[] bytes) { try { ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes)); Object object = in.readObject(); return (T) object; } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(\\\"SerializerAlgorithm.Java 反序列化错误\\\", e); } } @Override public <T> byte[] serialize(T object) { try { ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(object); return out.toByteArray(); } catch (IOException e) { throw new RuntimeException(\\\"SerializerAlgorithm.Java 序列化错误\\\", e); } } }, // Json 实现(引入了 Gson 依赖) Json { @Override public <T> T deserialize(Class<T> clazz, byte[] bytes) { return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz); } @Override public <T> byte[] serialize(T object) { return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8); } }; // 需要从协议的字节中得到是哪种序列化算法 public static SerializerAlgorithm getByInt(int type) { SerializerAlgorithm[] array = SerializerAlgorithm.values(); if (type < 0 || type > array.length - 1) { throw new IllegalArgumentException(\\\"超过 SerializerAlgorithm 范围\\\"); } return array[type]; } } \",\"增加配置类和配置文件\",\"public abstract class Config { static Properties properties; static { try (InputStream in = Config.class.getResourceAsStream(\\\"/application.properties\\\")) { properties = new Properties(); properties.load(in); } catch (IOException e) { throw new ExceptionInInitializerError(e); } } public static int getServerPort() { String value = properties.getProperty(\\\"server.port\\\"); if(value == null) { return 8080; } else { return Integer.parseInt(value); } } public static Serializer.Algorithm getSerializerAlgorithm() { String value = properties.getProperty(\\\"serializer.algorithm\\\"); if(value == null) { return Serializer.Algorithm.Java; } else { return Serializer.Algorithm.valueOf(value); } } } \",\"配置文件\",\"serializer.algorithm=Json \",\"修改编解码器\",\"/** * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的 */ public class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> { @Override public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception { ByteBuf out = ctx.alloc().buffer(); // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(Config.getSerializerAlgorithm().ordinal()); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 byte[] bytes = Config.getSerializerAlgorithm().serialize(msg); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); outList.add(out); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerAlgorithm = in.readByte(); // 0 或 1 byte messageType = in.readByte(); // 0,1,2... int sequenceId = in.readInt(); in.readByte(); int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); // 找到反序列化算法 Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm]; // 确定具体消息类型 Class<? extends Message> messageClass = Message.getMessageClass(messageType); Message message = algorithm.deserialize(messageClass, bytes); // log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); // log.debug(\\\"{}\\\", message); out.add(message); } } \",\"其中确定具体消息类型，可以根据 消息类型字节 获取到对应的 消息 class\",\"@Data public abstract class Message implements Serializable { /** * 根据消息类型字节，获得对应的消息 class * @param messageType 消息类型字节 * @return 消息 class */ public static Class<? extends Message> getMessageClass(int messageType) { return messageClasses.get(messageType); } private int sequenceId; private int messageType; public abstract int getMessageType(); public static final int LoginRequestMessage = 0; public static final int LoginResponseMessage = 1; public static final int ChatRequestMessage = 2; public static final int ChatResponseMessage = 3; public static final int GroupCreateRequestMessage = 4; public static final int GroupCreateResponseMessage = 5; public static final int GroupJoinRequestMessage = 6; public static final int GroupJoinResponseMessage = 7; public static final int GroupQuitRequestMessage = 8; public static final int GroupQuitResponseMessage = 9; public static final int GroupChatRequestMessage = 10; public static final int GroupChatResponseMessage = 11; public static final int GroupMembersRequestMessage = 12; public static final int GroupMembersResponseMessage = 13; public static final int PingMessage = 14; public static final int PongMessage = 15; private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>(); static { messageClasses.put(LoginRequestMessage, LoginRequestMessage.class); messageClasses.put(LoginResponseMessage, LoginResponseMessage.class); messageClasses.put(ChatRequestMessage, ChatRequestMessage.class); messageClasses.put(ChatResponseMessage, ChatResponseMessage.class); messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class); messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class); messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class); messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class); messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class); messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class); messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class); messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class); messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class); messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class); } } \"]},\"724\":{\"h\":\"参数调优\"},\"725\":{\"h\":\"1）CONNECT_TIMEOUT_MILLIS\",\"t\":[\"属于 SocketChannal 参数\",\"用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\",\"SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\",\"@Slf4j public class TestConnectionTimeout { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap() .group(group) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300) .channel(NioSocketChannel.class) .handler(new LoggingHandler()); ChannelFuture future = bootstrap.connect(\\\"127.0.0.1\\\", 8080); future.sync().channel().closeFuture().sync(); // 断点1 } catch (Exception e) { e.printStackTrace(); log.debug(\\\"timeout\\\"); } finally { group.shutdownGracefully(); } } } \",\"另外源码部分 io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect\",\"@Override public final void connect( final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) { // ... // Schedule connect timeout. int connectTimeoutMillis = config().getConnectTimeoutMillis(); if (connectTimeoutMillis > 0) { connectTimeoutFuture = eventLoop().schedule(new Runnable() { @Override public void run() { ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise; ConnectTimeoutException cause = new ConnectTimeoutException(\\\"connection timed out: \\\" + remoteAddress); // 断点2 if (connectPromise != null && connectPromise.tryFailure(cause)) { close(voidPromise()); } } }, connectTimeoutMillis, TimeUnit.MILLISECONDS); } // ... } \"]},\"726\":{\"h\":\"2）SO_BACKLOG\",\"t\":[\"属于 ServerSocketChannal 参数\",\"第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\",\"第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\",\"第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\",\"其中\",\"在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\",\"sync queue - 半连接队列\",\"大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 syncookies 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\",\"accept queue - 全连接队列\",\"其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\",\"如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\",\"netty 中\",\"可以通过 option(ChannelOption.SO_BACKLOG, 值) 来设置大小\",\"可以通过下面源码查看默认大小\",\"public class DefaultServerSocketChannelConfig extends DefaultChannelConfig implements ServerSocketChannelConfig { private volatile int backlog = NetUtil.SOMAXCONN; // ... } \",\"课堂调试关键断点为：io.netty.channel.nio.NioEventLoop#processSelectedKey\",\"oio 中更容易说明，不用 debug 模式\",\"public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8888, 2); Socket accept = ss.accept(); System.out.println(accept); System.in.read(); } } \",\"客户端启动 4 个\",\"public class Client { public static void main(String[] args) throws IOException { try { Socket s = new Socket(); System.out.println(new Date()+\\\" connecting...\\\"); s.connect(new InetSocketAddress(\\\"localhost\\\", 8888),1000); System.out.println(new Date()+\\\" connected...\\\"); s.getOutputStream().write(1); System.in.read(); } catch (IOException e) { System.out.println(new Date()+\\\" connecting timeout...\\\"); e.printStackTrace(); } } } \",\"第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\",\"Tue Apr 21 20:30:28 CST 2020 connecting... Tue Apr 21 20:30:28 CST 2020 connected... \",\"第 4 个客户端连接时\",\"Tue Apr 21 20:53:58 CST 2020 connecting... Tue Apr 21 20:53:59 CST 2020 connecting timeout... java.net.SocketTimeoutException: connect timed out \"]},\"727\":{\"h\":\"3）ulimit -n\",\"t\":[\"属于操作系统参数\"]},\"728\":{\"h\":\"4）TCP_NODELAY\",\"t\":[\"属于 SocketChannal 参数\",\"false：开启了nagle算法\",\"true：关闭了nagle算法（推荐）\"]},\"729\":{\"h\":\"5）SO_SNDBUF & SO_RCVBUF\",\"t\":[\"发送缓冲区和接受缓冲区，最好别修改\",\"SO_SNDBUF 属于 SocketChannal 参数\",\"SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\"]},\"730\":{\"h\":\"6）ALLOCATOR\",\"t\":[\"属于 SocketChannal 参数\",\"用来分配 ByteBuf， ctx.alloc()\"]},\"731\":{\"h\":\"7）RCVBUF_ALLOCATOR\",\"t\":[\"属于 SocketChannal 参数\",\"控制 netty 接收缓冲区大小\",\"负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\"]},\"732\":{\"h\":\"RPC 框架\"},\"733\":{\"h\":\"1）准备工作\",\"t\":[\"这些代码可以认为是现成的，无需从头编写练习\",\"为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\",\"@Data public abstract class Message implements Serializable { // 省略旧的代码 public static final int RPC_MESSAGE_TYPE_REQUEST = 101; public static final int RPC_MESSAGE_TYPE_RESPONSE = 102; static { // ... messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class); messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class); } } \",\"请求消息\",\"@Getter @ToString(callSuper = true) public class RpcRequestMessage extends Message { /** * 调用的接口全限定名，服务端根据它找到实现 */ private String interfaceName; /** * 调用接口中的方法名 */ private String methodName; /** * 方法返回类型 */ private Class<?> returnType; /** * 方法参数类型数组 */ private Class[] parameterTypes; /** * 方法参数值数组 */ private Object[] parameterValue; public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) { super.setSequenceId(sequenceId); this.interfaceName = interfaceName; this.methodName = methodName; this.returnType = returnType; this.parameterTypes = parameterTypes; this.parameterValue = parameterValue; } @Override public int getMessageType() { return RPC_MESSAGE_TYPE_REQUEST; } } \",\"响应消息\",\"@Data @ToString(callSuper = true) public class RpcResponseMessage extends Message { /** * 返回值 */ private Object returnValue; /** * 异常值 */ private Exception exceptionValue; @Override public int getMessageType() { return RPC_MESSAGE_TYPE_RESPONSE; } } \",\"服务器架子\",\"@Slf4j public class RpcServer { public static void main(String[] args) { NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); // rpc 请求消息处理器，待实现 RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = serverBootstrap.bind(8080).sync().channel(); channel.closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } } } \",\"客户端架子\",\"public class RpcClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); // rpc 响应消息处理器，待实现 RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \",\"服务器端的 service 获取\",\"public class ServicesFactory { static Properties properties; static Map<Class<?>, Object> map = new ConcurrentHashMap<>(); static { try (InputStream in = Config.class.getResourceAsStream(\\\"/application.properties\\\")) { properties = new Properties(); properties.load(in); Set<String> names = properties.stringPropertyNames(); for (String name : names) { if (name.endsWith(\\\"Service\\\")) { Class<?> interfaceClass = Class.forName(name); Class<?> instanceClass = Class.forName(properties.getProperty(name)); map.put(interfaceClass, instanceClass.newInstance()); } } } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) { throw new ExceptionInInitializerError(e); } } public static <T> T getService(Class<T> interfaceClass) { return (T) map.get(interfaceClass); } } \",\"相关配置 application.properties\",\"serializer.algorithm=Json cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl \"]},\"734\":{\"h\":\"2）服务器 handler\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) { RpcResponseMessage response = new RpcResponseMessage(); response.setSequenceId(message.getSequenceId()); try { // 获取真正的实现对象 HelloService service = (HelloService) ServicesFactory.getService(Class.forName(message.getInterfaceName())); // 获取要调用的方法 Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes()); // 调用方法 Object invoke = method.invoke(service, message.getParameterValue()); // 调用成功 response.setReturnValue(invoke); } catch (Exception e) { e.printStackTrace(); // 调用异常 response.setExceptionValue(e); } // 返回结果 ctx.writeAndFlush(response); } } \"]},\"735\":{\"h\":\"3）客户端代码第一版\",\"t\":[\"只发消息\",\"@Slf4j public class RpcClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage( 1, \\\"cn.itcast.server.service.HelloService\\\", \\\"sayHello\\\", String.class, new Class[]{String.class}, new Object[]{\\\"张三\\\"} )).addListener(promise -> { if (!promise.isSuccess()) { Throwable cause = promise.cause(); log.error(\\\"error\\\", cause); } }); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \"]},\"736\":{\"h\":\"4）客户端 handler 第一版\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception { log.debug(\\\"{}\\\", msg); } } \"]},\"737\":{\"h\":\"5）客户端代码 第二版\",\"t\":[\"包括 channel 管理，代理，接收结果\",\"@Slf4j public class RpcClientManager { public static void main(String[] args) { HelloService service = getProxyService(HelloService.class); System.out.println(service.sayHello(\\\"zhangsan\\\")); // System.out.println(service.sayHello(\\\"lisi\\\")); // System.out.println(service.sayHello(\\\"wangwu\\\")); } // 创建代理类 public static <T> T getProxyService(Class<T> serviceClass) { ClassLoader loader = serviceClass.getClassLoader(); Class<?>[] interfaces = new Class[]{serviceClass}; // sayHello \\\"张三\\\" Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> { // 1. 将方法调用转换为 消息对象 int sequenceId = SequenceIdGenerator.nextId(); RpcRequestMessage msg = new RpcRequestMessage( sequenceId, serviceClass.getName(), method.getName(), method.getReturnType(), method.getParameterTypes(), args ); // 2. 将消息对象发送出去 getChannel().writeAndFlush(msg); // 3. 准备一个空 Promise 对象，来接收结果 指定 promise 对象异步接收结果线程 DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop()); RpcResponseMessageHandler.PROMISES.put(sequenceId, promise); // promise.addListener(future -> { // // 线程 // }); // 4. 等待 promise 结果 promise.await(); if(promise.isSuccess()) { // 调用正常 return promise.getNow(); } else { // 调用失败 throw new RuntimeException(promise.cause()); } }); return (T) o; } private static Channel channel = null; private static final Object LOCK = new Object(); // 获取唯一的 channel 对象 public static Channel getChannel() { if (channel != null) { return channel; } synchronized (LOCK) { // t2 if (channel != null) { // t1 return channel; } initChannel(); return channel; } } // 初始化 channel 方法 private static void initChannel() { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); try { channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().addListener(future -> { group.shutdownGracefully(); }); } catch (Exception e) { log.error(\\\"client error\\\", e); } } } \"]},\"738\":{\"h\":\"6）客户端 handler 第二版\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> { // 序号 用来接收结果的 promise 对象 public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>(); @Override protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception { log.debug(\\\"{}\\\", msg); // 拿到空的 promise Promise<Object> promise = PROMISES.remove(msg.getSequenceId()); if (promise != null) { Object returnValue = msg.getReturnValue(); Exception exceptionValue = msg.getExceptionValue(); if(exceptionValue != null) { promise.setFailure(exceptionValue); } else { promise.setSuccess(returnValue); } } } } \"]},\"739\":{\"h\":\"Netty源码分析\"},\"740\":{\"h\":\"启动剖析\",\"t\":[\"我们就来看看 netty 中对下面的代码是怎样进行处理的\",\"//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector Selector selector = Selector.open(); //2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config NioServerSocketChannel attachment = new NioServerSocketChannel(); //3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); //4 启动 nio boss 线程执行接下来的操作 //5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件 SelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment); //6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor //7 绑定端口 serverSocketChannel.bind(new InetSocketAddress(8080)); //8 触发 channel active 事件，在 head 中关注 op_accept 事件 selectionKey.interestOps(SelectionKey.OP_ACCEPT); \",\"入口 io.netty.bootstrap.ServerBootstrap#bind\",\"关键代码 io.netty.bootstrap.AbstractBootstrap#doBind\",\"private ChannelFuture doBind(final SocketAddress localAddress) { // 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码 final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) { return regFuture; } // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分 // 2.1 如果已经完成 if (regFuture.isDone()) { ChannelPromise promise = channel.newPromise(); // 3.1 立刻调用 doBind0 doBind0(regFuture, channel, localAddress, promise); return promise; } // 2.2 还没有完成 else { final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); // 3.2 回调 doBind0 regFuture.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { Throwable cause = future.cause(); if (cause != null) { // 处理异常... promise.setFailure(cause); } else { promise.registered(); // 3. 由注册线程去执行 doBind0 doBind0(regFuture, channel, localAddress, promise); } } }); return promise; } } \",\"关键代码 io.netty.bootstrap.AbstractBootstrap#initAndRegister\",\"final ChannelFuture initAndRegister() { Channel channel = null; try { channel = channelFactory.newChannel(); // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer init(channel); } catch (Throwable t) { // 处理异常... return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t); } // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上 ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) { // 处理异常... } return regFuture; } \",\"关键代码 io.netty.bootstrap.ServerBootstrap#init\",\"// 这里 channel 实际上是 NioServerSocketChannel void init(Channel channel) throws Exception { final Map<ChannelOption<?>, Object> options = options0(); synchronized (options) { setChannelOptions(channel, options, logger); } final Map<AttributeKey<?>, Object> attrs = attrs0(); synchronized (attrs) { for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) { @SuppressWarnings(\\\"unchecked\\\") AttributeKey<Object> key = (AttributeKey<Object>) e.getKey(); channel.attr(key).set(e.getValue()); } } ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry<ChannelOption<?>, Object>[] currentChildOptions; final Entry<AttributeKey<?>, Object>[] currentChildAttrs; synchronized (childOptions) { currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0)); } synchronized (childAttrs) { currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0)); } // 为 NioServerSocketChannel 添加初始化器 p.addLast(new ChannelInitializer<Channel>() { @Override public void initChannel(final Channel ch) throws Exception { final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) { pipeline.addLast(handler); } // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel ch.eventLoop().execute(new Runnable() { @Override public void run() { pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); } }); } }); } \",\"关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#register\",\"public final void register(EventLoop eventLoop, final ChannelPromise promise) { // 一些检查，略... AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) { register0(promise); } else { try { // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行 // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程 // 这行代码完成的事实是 main -> nio boss 线程的切换 eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { // 日志记录... closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } } \",\"io.netty.channel.AbstractChannel.AbstractUnsafe#register0\",\"private void register0(ChannelPromise promise) { try { if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } boolean firstRegistration = neverRegistered; // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel doRegister(); neverRegistered = false; registered = true; // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel pipeline.invokeHandlerAddedIfNeeded(); // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0 safeSetSuccess(promise); pipeline.fireChannelRegistered(); // 对应 server socket channel 还未绑定，isActive 为 false if (isActive()) { if (firstRegistration) { pipeline.fireChannelActive(); } else if (config().isAutoRead()) { beginRead(); } } } catch (Throwable t) { // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } \",\"关键代码 io.netty.channel.ChannelInitializer#initChannel\",\"private boolean initChannel(ChannelHandlerContext ctx) throws Exception { if (initMap.add(ctx)) { // Guard against re-entrance. try { // 1.2.2.1 执行初始化 initChannel((C) ctx.channel()); } catch (Throwable cause) { exceptionCaught(ctx, cause); } finally { // 1.2.2.2 移除初始化器 ChannelPipeline pipeline = ctx.pipeline(); if (pipeline.context(this) != null) { pipeline.remove(this); } } return true; } return false; } \",\"关键代码 io.netty.bootstrap.AbstractBootstrap#doBind0\",\"// 3.1 或 3.2 执行 doBind0 private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) { channel.eventLoop().execute(new Runnable() { @Override public void run() { if (regFuture.isSuccess()) { channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); } else { promise.setFailure(regFuture.cause()); } } }); } \",\"关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#bind\",\"public final void bind(final SocketAddress localAddress, final ChannelPromise promise) { assertEventLoop(); if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) && localAddress instanceof InetSocketAddress && !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() && !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) { // 记录日志... } boolean wasActive = isActive(); try { // 3.3 执行端口绑定 doBind(localAddress); } catch (Throwable t) { safeSetFailure(promise, t); closeIfClosed(); return; } if (!wasActive && isActive()) { invokeLater(new Runnable() { @Override public void run() { // 3.4 触发 active 事件 pipeline.fireChannelActive(); } }); } safeSetSuccess(promise); } \",\"3.3 关键代码 io.netty.channel.socket.nio.NioServerSocketChannel#doBind\",\"protected void doBind(SocketAddress localAddress) throws Exception { if (PlatformDependent.javaVersion() >= 7) { javaChannel().bind(localAddress, config.getBacklog()); } else { javaChannel().socket().bind(localAddress, config.getBacklog()); } } \",\"3.4 关键代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\",\"public void channelActive(ChannelHandlerContext ctx) { ctx.fireChannelActive(); // 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册) readIfIsAutoRead(); } \",\"关键代码 io.netty.channel.nio.AbstractNioChannel#doBeginRead\",\"protected void doBeginRead() throws Exception { // Channel.read() or ChannelHandlerContext.read() was called final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) { return; } readPending = true; final int interestOps = selectionKey.interestOps(); // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件 if ((interestOps & readInterestOp) == 0) { selectionKey.interestOps(interestOps | readInterestOp); } } \"]},\"741\":{\"h\":\"NioEventLoop 剖析\",\"t\":[\"NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\",\"提交任务代码 io.netty.util.concurrent.SingleThreadEventExecutor#execute\",\"public void execute(Runnable task) { if (task == null) { throw new NullPointerException(\\\"task\\\"); } boolean inEventLoop = inEventLoop(); // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列 addTask(task); if (!inEventLoop) { // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread startThread(); if (isShutdown()) { // 如果已经 shutdown，做拒绝逻辑，代码略... } } if (!addTaskWakesUp && wakesUpForTask(task)) { // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程 wakeup(inEventLoop); } } \",\"唤醒 select 阻塞线程io.netty.channel.nio.NioEventLoop#wakeup\",\"@Override protected void wakeup(boolean inEventLoop) { if (!inEventLoop && wakenUp.compareAndSet(false, true)) { selector.wakeup(); } } \",\"启动 EventLoop 主循环 io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread\",\"private void doStartThread() { assert thread == null; executor.execute(new Runnable() { @Override public void run() { // 将线程池的当前线程保存在成员变量中，以便后续使用 thread = Thread.currentThread(); if (interrupted) { thread.interrupt(); } boolean success = false; updateLastExecutionTime(); try { // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下 SingleThreadEventExecutor.this.run(); success = true; } catch (Throwable t) { logger.warn(\\\"Unexpected exception from an event executor: \\\", t); } finally { // 清理工作，代码略... } } }); } \",\"io.netty.channel.nio.NioEventLoop#run 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\",\"protected void run() { for (;;) { try { try { // calculateStrategy 的逻辑如下： // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞 switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) { case SelectStrategy.CONTINUE: continue; case SelectStrategy.BUSY_WAIT: case SelectStrategy.SELECT: // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒 // 进行 select 阻塞，并设置唤醒状态为 false boolean oldWakenUp = wakenUp.getAndSet(false); // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup // 下面的 select 方法不会阻塞 // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢? // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时 // 才能执行，让 select 方法无谓阻塞 select(oldWakenUp); if (wakenUp.get()) { selector.wakeup(); } default: } } catch (IOException e) { rebuildSelector0(); handleLoopException(e); continue; } cancelledKeys = 0; needsToSelectAgain = false; // ioRatio 默认是 50 final int ioRatio = this.ioRatio; if (ioRatio == 100) { try { processSelectedKeys(); } finally { // ioRatio 为 100 时，总是运行完所有非 IO 任务 runAllTasks(); } } else { final long ioStartTime = System.nanoTime(); try { processSelectedKeys(); } finally { // 记录 io 事件处理耗时 final long ioTime = System.nanoTime() - ioStartTime; // 运行非 IO 任务，一旦超时会退出 runAllTasks runAllTasks(ioTime * (100 - ioRatio) / ioRatio); } } } catch (Throwable t) { handleLoopException(t); } try { if (isShuttingDown()) { closeAll(); if (confirmShutdown()) { return; } } } catch (Throwable t) { handleLoopException(t); } } } \"]},\"742\":{\"h\":\"注意⚠️\",\"t\":[\"这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\",\"由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\",\"由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\",\"参考下图\",\"io.netty.channel.nio.NioEventLoop#select\",\"private void select(boolean oldWakenUp) throws IOException { Selector selector = this.selector; try { int selectCnt = 0; long currentTimeNanos = System.nanoTime(); // 计算等待时间 // * 没有 scheduledTask，超时时间为 1s // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间` long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); for (;;) { long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L; // 如果超时，退出循环 if (timeoutMillis <= 0) { if (selectCnt == 0) { selector.selectNow(); selectCnt = 1; } break; } // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行 // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup if (hasTasks() && wakenUp.compareAndSet(false, true)) { selector.selectNow(); selectCnt = 1; break; } // select 有限时阻塞 // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100% int selectedKeys = selector.select(timeoutMillis); // 计数加 1 selectCnt ++; // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环 if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) { break; } if (Thread.interrupted()) { // 线程被打断，退出循环 // 记录日志 selectCnt = 1; break; } long time = System.nanoTime(); if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) { // 如果超时，计数重置为 1，下次循环就会 break selectCnt = 1; } // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512 // 这是为了解决 nio 空轮询 bug else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 && selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) { // 重建 selector selector = selectRebuildSelector(selectCnt); selectCnt = 1; break; } currentTimeNanos = time; } if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) { // 记录日志 } } catch (CancelledKeyException e) { // 记录日志 } } \",\"处理 keys io.netty.channel.nio.NioEventLoop#processSelectedKeys\",\"private void processSelectedKeys() { if (selectedKeys != null) { // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet） processSelectedKeysOptimized(); } else { processSelectedKeysPlain(selector.selectedKeys()); } } \",\"io.netty.channel.nio.NioEventLoop#processSelectedKey\",\"private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) { final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); // 当 key 取消或关闭时会导致这个 key 无效 if (!k.isValid()) { // 无效时处理... return; } try { int readyOps = k.readyOps(); // 连接事件 if ((readyOps & SelectionKey.OP_CONNECT) != 0) { int ops = k.interestOps(); ops &= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); } // 可写事件 if ((readyOps & SelectionKey.OP_WRITE) != 0) { ch.unsafe().forceFlush(); } // 可读或可接入事件 if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read unsafe.read(); } } catch (CancelledKeyException ignored) { unsafe.close(unsafe.voidPromise()); } } \"]},\"743\":{\"h\":\"accept 剖析\",\"t\":[\"nio 中如下代码，在 netty 中的流程\",\"//1 阻塞直到事件发生 selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { //2 拿到一个事件 SelectionKey key = iter.next(); //3 如果是 accept 事件 if (key.isAcceptable()) { //4 执行 accept SocketChannel channel = serverSocketChannel.accept(); channel.configureBlocking(false); //5 关注 read 事件 channel.register(selector, SelectionKey.OP_READ); } // ... } \",\"先来看可接入事件处理（accept）\",\"io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\",\"public void read() { assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try { try { do { // doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf // readBuf 是一个 ArrayList 用来缓存消息 int localRead = doReadMessages(readBuf); if (localRead == 0) { break; } if (localRead < 0) { closed = true; break; } // localRead 为 1，就一条消息，即接收一个客户端连接 allocHandle.incMessagesRead(localRead); } while (allocHandle.continueReading()); } catch (Throwable t) { exception = t; } int size = readBuf.size(); for (int i = 0; i < size; i ++) { readPending = false; // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead pipeline.fireChannelRead(readBuf.get(i)); } readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception != null) { closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); } if (closed) { inputShutdown = true; if (isOpen()) { close(voidPromise()); } } } finally { if (!readPending && !config.isAutoRead()) { removeReadOp(); } } } \",\"关键代码 io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\",\"public void channelRead(ChannelHandlerContext ctx, Object msg) { // 这时的 msg 是 NioSocketChannel final Channel child = (Channel) msg; // NioSocketChannel 添加 childHandler 即初始化器 child.pipeline().addLast(childHandler); // 设置选项 setChannelOptions(child, childOptions, logger); for (Entry<AttributeKey<?>, Object> e: childAttrs) { child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue()); } try { // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程 childGroup.register(child).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { forceClose(child, future.cause()); } } }); } catch (Throwable t) { forceClose(child, t); } } \",\"又回到了熟悉的 io.netty.channel.AbstractChannel.AbstractUnsafe#register 方法\",\"public final void register(EventLoop eventLoop, final ChannelPromise promise) { // 一些检查，略... AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) { register0(promise); } else { try { // 这行代码完成的事实是 nio boss -> nio worker 线程的切换 eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { // 日志记录... closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } } \",\"io.netty.channel.AbstractChannel.AbstractUnsafe#register0\",\"private void register0(ChannelPromise promise) { try { if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } boolean firstRegistration = neverRegistered; doRegister(); neverRegistered = false; registered = true; // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail pipeline.invokeHandlerAddedIfNeeded(); // 执行后就是 head -> logging handler -> my handler -> tail safeSetSuccess(promise); pipeline.fireChannelRegistered(); if (isActive()) { if (firstRegistration) { // 触发 pipeline 上 active 事件 pipeline.fireChannelActive(); } else if (config().isAutoRead()) { beginRead(); } } } catch (Throwable t) { closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } \",\"回到了熟悉的代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\",\"public void channelActive(ChannelHandlerContext ctx) { ctx.fireChannelActive(); // 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取) readIfIsAutoRead(); } \",\"io.netty.channel.nio.AbstractNioChannel#doBeginRead\",\"protected void doBeginRead() throws Exception { // Channel.read() or ChannelHandlerContext.read() was called final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) { return; } readPending = true; // 这时候 interestOps 是 0 final int interestOps = selectionKey.interestOps(); if ((interestOps & readInterestOp) == 0) { // 关注 read 事件 selectionKey.interestOps(interestOps | readInterestOp); } } \"]},\"744\":{\"h\":\"read 剖析\",\"t\":[\"再来看可读事件 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\",\"public final void read() { final ChannelConfig config = config(); if (shouldBreakReadReady(config)) { clearReadPending(); return; } final ChannelPipeline pipeline = pipeline(); // io.netty.allocator.type 决定 allocator 的实现 final ByteBufAllocator allocator = config.getAllocator(); // 用来分配 byteBuf，确定单次读取大小 final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle(); allocHandle.reset(config); ByteBuf byteBuf = null; boolean close = false; try { do { byteBuf = allocHandle.allocate(allocator); // 读取 allocHandle.lastBytesRead(doReadBytes(byteBuf)); if (allocHandle.lastBytesRead() <= 0) { byteBuf.release(); byteBuf = null; close = allocHandle.lastBytesRead() < 0; if (close) { readPending = false; } break; } allocHandle.incMessagesRead(1); readPending = false; // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler pipeline.fireChannelRead(byteBuf); byteBuf = null; } // 是否要继续循环 while (allocHandle.continueReading()); allocHandle.readComplete(); // 触发 read complete 事件 pipeline.fireChannelReadComplete(); if (close) { closeOnRead(pipeline); } } catch (Throwable t) { handleReadException(pipeline, byteBuf, t, close, allocHandle); } finally { if (!readPending && !config.isAutoRead()) { removeReadOp(); } } } \",\"io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)\",\"public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) { return // 一般为 true config.isAutoRead() && // respectMaybeMoreData 默认为 true // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true (!respectMaybeMoreData || maybeMoreDataSupplier.get()) && // 小于最大次数，maxMessagePerRead 默认 16 totalMessages < maxMessagePerRead && // 实际读到了数据 totalBytesRead > 0; } \"]},\"745\":{\"h\":\"组件\"},\"746\":{\"h\":\"EventLoop\",\"t\":[\"事件循环对象\",\"EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\",\"它的继承关系比较复杂\",\"一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\",\"另一条线是继承自 netty 自己的 OrderedEventExecutor， \",\"提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\",\"提供了 parent 方法来看看自己属于哪个 EventLoopGroup\",\"事件循环组\",\"EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\",\"继承自 netty 自己的 EventExecutorGroup \",\"实现了 Iterable 接口提供遍历 EventLoop 的能力\",\"另有 next 方法获取集合中下一个 EventLoop\",\"以一个简单的实现为例：\",\"// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程 DefaultEventLoopGroup group = new DefaultEventLoopGroup(2); System.out.println(group.next()); System.out.println(group.next()); System.out.println(group.next()); \",\"输出\",\"io.netty.channel.DefaultEventLoop@60f82f98 io.netty.channel.DefaultEventLoop@35f983a6 io.netty.channel.DefaultEventLoop@60f82f98 \",\"也可以使用 for 循环\",\"DefaultEventLoopGroup group = new DefaultEventLoopGroup(2); for (EventExecutor eventLoop : group) { System.out.println(eventLoop); } \",\"输出\",\"io.netty.channel.DefaultEventLoop@60f82f98 io.netty.channel.DefaultEventLoop@35f983a6 \"]},\"747\":{\"h\":\"优雅关闭💡\",\"t\":[\"优雅关闭 shutdownGracefully 方法。该方法会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\"]},\"748\":{\"h\":\"演示 NioEventLoop 处理 io 事件\",\"t\":[\"服务器端两个 nio worker 工人\",\"new ServerBootstrap() // boss 和 worker // 细分1：boss 只负责 ServerSocketChannel 上 accept 事件 // worker 只负责 socketChannel 上的读写 .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2)) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null; if (byteBuf != null) { byte[] buf = new byte[16]; ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes()); log.debug(new String(buf)); } } }); } }).bind(8080).sync(); \",\"客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\",\"public static void main(String[] args) throws InterruptedException { Channel channel = new Bootstrap() .group(new NioEventLoopGroup(1)) .handler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { System.out.println(\\\"init...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); } }) .channel(NioSocketChannel.class).connect(\\\"localhost\\\", 8080) .sync() .channel(); channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\\\"wangwu\\\".getBytes())); Thread.sleep(2000); channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\\\"wangwu\\\".getBytes())); \",\"最后输出\",\"22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan 22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan 22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi 22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi 22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu 22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu \",\"可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定\",\"再增加两个非 nio 工人\",\"// 细分2：创建一个独立的 EventLoopGroup EventLoopGroup group = new DefaultEventLoopGroup(2); new ServerBootstrap() // boss 和 worker // 细分1：boss 只负责 ServerSocketChannel 上 accept 事件 worker 只负责 socketChannel 上的读写 .group(new NioEventLoopGroup(), new NioEventLoopGroup(2)) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(\\\"handler1\\\", new ChannelInboundHandlerAdapter() { @Override // ByteBuf public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; log.debug(buf.toString(Charset.defaultCharset())); ctx.fireChannelRead(msg); // 让消息传递给下一个handler } }).addLast(group, \\\"handler2\\\", new ChannelInboundHandlerAdapter() { @Override // ByteBuf public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; log.debug(buf.toString(Charset.defaultCharset())); } }); } }) .bind(8080); \",\"客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\",\"输出\",\"22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 7a 68 61 6e 67 73 61 6e |zhangsan | +--------+-------------------------------------------------+----------------+ 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE 22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan 22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 7a 68 61 6e 67 73 61 6e |zhangsan | +--------+-------------------------------------------------+----------------+ 22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE 22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan 22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED 22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE 22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6c 69 73 69 |lisi | +--------+-------------------------------------------------+----------------+ 22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE 22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi 22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6c 69 73 69 |lisi | +--------+-------------------------------------------------+----------------+ 22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE 22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 61 6e 67 77 75 |wangwu | +--------+-------------------------------------------------+----------------+ 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE 22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu 22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 61 6e 67 77 75 |wangwu | +--------+-------------------------------------------------+----------------+ 22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE 22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu \",\"可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\"]},\"749\":{\"h\":\"handler 执行中如何换人？💡\",\"t\":[\"关键代码 io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()\",\"static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \\\"msg\\\"), next); // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程 EventExecutor executor = next.executor(); // 是，直接调用 if (executor.inEventLoop()) { next.invokeChannelRead(m); } // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人） else { executor.execute(new Runnable() { @Override public void run() { next.invokeChannelRead(m); } }); } } \",\"如果两个 handler 绑定的是同一个线程，那么就直接调用\",\"否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\"]},\"750\":{\"h\":\"演示 NioEventLoop 处理普通任务\",\"t\":[\"NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\",\"NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2); log.debug(\\\"server start...\\\"); Thread.sleep(2000); nioWorkers.execute(()->{ log.debug(\\\"normal task...\\\"); }); \",\"输出\",\"22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start... 22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task... \",\"可以用来执行耗时较长的任务\"]},\"751\":{\"h\":\"演示 NioEventLoop 处理定时任务\",\"t\":[\"NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2); log.debug(\\\"server start...\\\"); Thread.sleep(2000); nioWorkers.scheduleAtFixedRate(() -> { log.debug(\\\"running...\\\"); }, 0, 1, TimeUnit.SECONDS); \",\"输出\",\"22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start... 22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... ... \",\"可以用来执行定时任务\"]},\"752\":{\"h\":\"Channel\",\"t\":[\"channel 的主要作用\",\"close() 可以用来关闭 channel\",\"closeFuture() 用来处理 channel 的关闭 \",\"sync 方法作用是同步等待 channel 关闭\",\"而 addListener 方法是异步等待 channel 关闭\",\"pipeline() 方法添加处理器\",\"write() 方法将数据写入\",\"writeAndFlush() 方法将数据写入并刷出\"]},\"753\":{\"h\":\"ChannelFuture\",\"t\":[\"这时刚才的客户端代码\",\"new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080) .sync() .channel() .writeAndFlush(new Date() + \\\": hello world!\\\"); \",\"现在把它拆开来看\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) // 异步非阻塞, main 发起了调用，真正执行connect是NioEventLoopGroup中的线程 .connect(\\\"127.0.0.1\\\", 8080); // 1 channelFuture.sync().channel().writeAndFlush(new Date() + \\\": hello world!\\\"); \",\"1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\",\"注意 connect 方法是异步非阻塞的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象 （虽然有channel对象，但是channel对象并没有正确连接）\",\"实验如下：\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080); log.debug(\\\"{}\\\", channelFuture.channel()); // 1 channelFuture.sync(); // 2 log.debug(\\\"{}\\\", channelFuture.channel()); // 3 \",\"执行到 1 时，连接未建立，打印 [id: 0x2e1884dd]\",\"执行到 2 时，sync 方法是同步等待连接建立完成\",\"执行到 3 时，连接肯定建立了，打印 [id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]\",\"除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080); log.debug(\\\"{}\\\", channelFuture.channel()); // 1 // 2.2 使用 addListener(回调对象) 方法异步处理结果 channelFuture.addListener(new ChannelFutureListener() { @Override // 在 nio 线程连接建立好之后，会回调 operationComplete，该方法的执行还是nio线程 public void operationComplete(ChannelFuture future) throws Exception { Channel channel = future.channel(); log.debug(\\\"{}\\\", channel); // 2 channel.writeAndFlush(\\\"hello, world\\\"); } }); \",\"执行到 1 时，连接未建立，打印 [id: 0x749124ba]\",\"ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 [id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]\"]},\"754\":{\"h\":\"CloseFuture\",\"t\":[\"@Slf4j public class CloseFutureClient { public static void main(String[] args) throws InterruptedException { NioEventLoopGroup group new NioEventLoopGroup(); ChannelFuture channelFuture = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<NioSocketChannel>() { @Override // 在连接建立后被调用 protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new StringEncoder()); } }) .connect(new InetSocketAddress(\\\"localhost\\\", 8080)); Channel channel = channelFuture.sync().channel(); log.debug(\\\"{}\\\", channel); new Thread(()->{ Scanner scanner = new Scanner(System.in); while (true) { String line = scanner.nextLine(); if (\\\"q\\\".equals(line)) { channel.close(); // 该步是异步操作，所以不能在这里善后 // log.debug(\\\"处理关闭之后的操作\\\"); // 不能在这里善后 break; } channel.writeAndFlush(line); } }, \\\"input\\\").start(); // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭 ChannelFuture closeFuture = channel.closeFuture(); // 同步方式处理关闭 /*log.debug(\\\"waiting close...\\\"); closeFuture.sync(); log.debug(\\\"处理关闭之后的操作\\\");*/ // 异步方式处理关闭 closeFuture.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { log.debug(\\\"处理关闭之后的操作\\\"); group.shutdownGracefully(); } }); } } \"]},\"755\":{\"h\":\"异步提升的是什么💡\",\"t\":[\"有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\",\"还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\",\"思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：4 * 8 * 3 = 96\",\"经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\",\"因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 4 * 8 * 12 效率几乎是原来的四倍\",\"要点\",\"单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\",\"异步并没有缩短响应时间，反而有所增加，提高的是吞吐量（单位时间内能够处理请求的数量）\",\"合理进行任务拆分，也是利用异步的关键\"]},\"756\":{\"h\":\"Future & Promise\",\"t\":[\"在异步处理时，经常用到这两个接口\",\"首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 juc 的 Future，而 Promise 又对 netty Future 进行了扩展\",\"public interface Future<V> extends java.util.concurrent.Future<V> public interface Promise<V> extends Future<V> \",\"jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\",\"netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\",\"netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\",\"功能/名称\",\"jdk Future\",\"netty Future\",\"Promise\",\"cancel\",\"取消任务\",\"-\",\"-\",\"isCanceled\",\"任务是否取消\",\"-\",\"-\",\"isDone\",\"任务是否完成，不能区分成功失败\",\"-\",\"-\",\"get\",\"获取任务结果，阻塞等待\",\"-\",\"-\",\"getNow\",\"-\",\"获取任务结果，非阻塞，还未产生结果时返回 null\",\"-\",\"await\",\"-\",\"等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断\",\"-\",\"sync\",\"-\",\"等待任务结束，如果任务失败，抛出异常\",\"-\",\"isSuccess\",\"-\",\"判断任务是否成功\",\"-\",\"cause\",\"-\",\"获取失败信息，非阻塞，如果没有失败，返回null\",\"-\",\"addLinstener\",\"-\",\"添加回调，异步接收结果\",\"-\",\"setSuccess\",\"-\",\"-\",\"设置成功结果\",\"setFailure\",\"-\",\"-\",\"设置失败结果\"]},\"757\":{\"h\":\"JDK Future\",\"t\":[\"// 1. 线程池 ExecutorService service = Executors.newFixedThreadPool(2); // 2. 提交任务 Future<Integer> future = service.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { log.debug(\\\"执行计算\\\"); Thread.sleep(1000); return 50; } }); // 3. 主线程通过 future 来获取结果 log.debug(\\\"等待结果\\\"); log.debug(\\\"结果是 {}\\\", future.get()); \"]},\"758\":{\"h\":\"Netty Future\",\"t\":[\"NioEventLoopGroup group = new NioEventLoopGroup(); EventLoop eventLoop = group.next(); Future<Integer> future = eventLoop.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { log.debug(\\\"执行计算\\\"); Thread.sleep(1000); return 70; } }); // log.debug(\\\"等待结果\\\"); // log.debug(\\\"结果是 {}\\\", future.get()); future.addListener(new GenericFutureListener<Future<? super Integer>>(){ @Override public void operationComplete(Future<? super Integer> future) throws Exception { log.debug(\\\"接收结果:{}\\\", future.getNow()); } }); \"]},\"759\":{\"h\":\"Promise\",\"t\":[\"// 1. 准备 EventLoop 对象 EventLoop eventLoop = new NioEventLoopGroup().next(); // 2. 可以主动创建 promise, 结果容器 DefaultPromise<Integer> promise = new DefaultPromise<>(eventLoop); new Thread(() -> { // 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果 log.debug(\\\"开始计算...\\\"); try { int i = 1 / 0; Thread.sleep(1000); promise.setSuccess(80); } catch (Exception e) { // e.printStackTrace(); promise.setFailure(e); } }).start(); // 4. 接收结果的线程 log.debug(\\\"等待结果...\\\"); log.debug(\\\"结果是: {}\\\", promise.get()); \"]},\"760\":{\"h\":\"例1\",\"t\":[\"同步处理任务成功\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(()->{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\\\"set success, {}\\\",10); promise.setSuccess(10); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\",promise.getNow()); // 还没有结果 log.debug(\\\"{}\\\",promise.get()); \",\"输出\",\"11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10 11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10 \"]},\"761\":{\"h\":\"例2\",\"t\":[\"异步处理任务成功\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); // 设置回调，异步接收结果 promise.addListener(future -> { // 这里的 future 就是上面的 promise log.debug(\\\"{}\\\",future.getNow()); }); // 等待 1000 后设置成功结果 eventExecutors.execute(()->{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\\\"set success, {}\\\",10); promise.setSuccess(10); }); log.debug(\\\"start...\\\"); \",\"输出\",\"11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10 11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10 \"]},\"762\":{\"h\":\"例3\",\"t\":[\"同步处理任务失败 - sync & get\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\", promise.getNow()); promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常 \",\"输出\",\"12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... Exception in thread \\\"main\\\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error... at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41) at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34) Caused by: java.lang.RuntimeException: error... at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) \"]},\"763\":{\"h\":\"例4\",\"t\":[\"同步处理任务失败 - await\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\", promise.getNow()); promise.await(); // 与 sync 和 get 区别在于，不会抛异常 log.debug(\\\"result {}\\\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString()); \",\"输出\",\"12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... 12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error... \"]},\"764\":{\"h\":\"例5\",\"t\":[\"异步处理任务失败\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); promise.addListener(future -> { log.debug(\\\"result {}\\\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString()); }); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); \",\"输出\",\"12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... 12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error... \"]},\"765\":{\"h\":\"例6\",\"t\":[\"await 死锁检查\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.submit(()->{ System.out.println(\\\"1\\\"); try { promise.await(); // 注意不能仅捕获 InterruptedException 异常 // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播 // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出 } catch (Exception e) { e.printStackTrace(); } System.out.println(\\\"2\\\"); }); eventExecutors.submit(()->{ System.out.println(\\\"3\\\"); try { promise.await(); } catch (Exception e) { e.printStackTrace(); } System.out.println(\\\"4\\\"); }); \",\"输出\",\"1 2 3 4 io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete) at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384) at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212) at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27) at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete) at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384) at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212) at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36) at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) \"]},\"766\":{\"h\":\"Handler & Pipeline\",\"t\":[\"ChannelHandler 用来处理 Channel 上的各种事件，分为入站（数据读取）、出站（数据写出）两种。所有 ChannelHandler 被连成一串，就是 Pipeline\",\"入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\",\"出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\",\"打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\",\"先搞清楚顺序，服务端\",\"@Slf4j public class TestPipeline { public static void main(String[] args) { new ServerBootstrap() .group(new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { // 1. 通过 channel 拿到 pipeline ChannelPipeline pipeline = ch.pipeline(); // 2. 添加处理器 head -> h1 -> h2 -> h4 -> h3 -> h5 -> h6 -> tail pipeline.addLast(\\\"h1\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"1\\\"); ByteBuf buf = (ByteBuf) msg; String name = buf.toString(Charset.defaultCharset()); super.channelRead(ctx, name); // name就是在handler处理链中传递的数据 } }); pipeline.addLast(\\\"h2\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object name) throws Exception { log.debug(\\\"2\\\"); Student student = new Student(name.toString()); super.channelRead(ctx, student); // 将数据传递给下个 handler，如果不调用，调用链会断开 或者调用 ctx.fireChannelRead(student); } }); pipeline.addLast(\\\"h3\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object student) throws Exception { log.debug(\\\"3, 结果是：{}\\\", student.toString()); // super.channelRead(ctx, student); // 从当前位置向上找出站处理器 // ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes())); // 从tail向上找出站处理器 ch.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes())); } }); pipeline.addLast(\\\"h4\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { Student student = new Student(msg.toString()); log.debug(\\\"4\\\"); super.write(ctx, student, promise); } }); pipeline.addLast(\\\"h5\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object student, ChannelPromise promise) throws Exception { log.debug(\\\"5，结果是：{}\\\", student); super.write(ctx, student, promise); } }); pipeline.addLast(\\\"h6\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { log.debug(\\\"6\\\"); super.write(ctx, msg, promise); } }); } }) .bind(8080); } @Data @AllArgsConstructor static class Student { private String name; @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + '}'; } } } \",\"客户端\",\"new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080) .addListener((ChannelFutureListener) future -> { future.channel().writeAndFlush(\\\"hello,world\\\"); }); \",\"服务器端打印：\",\"1 2 3 6 5 4 \",\"可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\",\"入站处理器中，super.channelRead(ctx, name)是 调用下一个入站处理器\",\"如果注释掉 h1 处代码，则仅会打印 1\",\"如果注释掉 h2 处代码，则仅会打印 1 2\",\"h3 处的 ch.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes()))会 从尾部开始触发 后续出站处理器的执行 \",\"如果注释掉 3 处代码，则仅会打印 1 2 3\",\"类似的，出站处理器中，super.write(ctx, msg, promise); 的调用也会 触发上一个出站处理器\",\"如果注释掉 h6 处代码，则仅会打印 1 2 3 6\",\"ctx.channel().write(msg) vs ctx.write(msg) \",\"都是触发出站处理器的执行\",\"ctx.channel().write(msg) 从尾部开始查找出站处理器\",\"ctx.write(msg) 是从当前节点找上一个出站处理器\",\"3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\",\"6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\",\"图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\"]},\"767\":{\"h\":\"ByteBuf\",\"t\":[\"是对字节数据的封装\"]},\"768\":{\"h\":\"1）创建\",\"t\":[\"ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10); log(buffer); \",\"上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\",\"输出\",\"read index:0 write index:0 capacity:10 \",\"其中 log 方法参考如下\",\"private static void log(ByteBuf buffer) { int length = buffer.readableBytes(); int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4; StringBuilder buf = new StringBuilder(rows * 80 * 2) .append(\\\"read index:\\\").append(buffer.readerIndex()) .append(\\\" write index:\\\").append(buffer.writerIndex()) .append(\\\" capacity:\\\").append(buffer.capacity()) .append(NEWLINE); appendPrettyHexDump(buf, buffer); System.out.println(buf.toString()); } \"]},\"769\":{\"h\":\"2）直接内存 vs 堆内存\",\"t\":[\"可以使用下面的代码来创建池化基于堆的 ByteBuf\",\"ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10); \",\"也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\",\"ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10); \",\"直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\",\"直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\"]},\"770\":{\"h\":\"3）池化 vs 非池化\",\"t\":[\"池化的最大意义在于可以重用 ByteBuf，优点有\",\"没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\",\"有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\",\"高并发时，池化功能更节约内存，减少内存溢出的可能\",\"池化功能是否开启，可以通过下面的系统环境变量来设置\",\"-Dio.netty.allocator.type={unpooled|pooled} \",\"4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\",\"4.1 之前，池化功能还不成熟，默认是非池化实现\"]},\"771\":{\"h\":\"4）组成\",\"t\":[\"ByteBuf 由四部分组成\",\"废弃字节：已经读取过的部分\",\"最开始读写指针都在 0 位置\"]},\"772\":{\"h\":\"5）写入\",\"t\":[\"方法列表，省略一些不重要的方法\",\"方法签名\",\"含义\",\"备注\",\"writeBoolean(boolean value)\",\"写入 boolean 值\",\"用一字节 01 | 00代表true | false\",\"writeByte(int value)\",\"写入 byte 值\",\"writeShort(int value)\",\"写入 short 值\",\"writeInt(int value)\",\"写入 int 值\",\"Big Endian（大端写入），即 0x250，写入后 00 00 02 50\",\"writeIntLE(int value)\",\"写入 int 值\",\"Little Endian（小端写入），即 0x250，写入后 50 02 00 00\",\"writeLong(long value)\",\"写入 long 值\",\"writeChar(int value)\",\"写入 char 值\",\"writeFloat(float value)\",\"写入 float 值\",\"writeDouble(double value)\",\"写入 double 值\",\"writeBytes(ByteBuf src)\",\"写入 netty 的 ByteBuf\",\"writeBytes(byte[] src)\",\"写入 byte[]\",\"writeBytes(ByteBuffer src)\",\"写入 nio 的 ByteBuffer\",\"int writeCharSequence(CharSequence sequence, Charset charset)\",\"写入字符串\",\"注意\",\"这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\",\"网络传输，默认习惯是 Big Endian\",\"先写入 4 个字节\",\"buffer.writeBytes(new byte[]{1, 2, 3, 4}); log(buffer); \",\"结果是\",\"read index:0 write index:4 capacity:10 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 |.... | +--------+-------------------------------------------------+----------------+ \",\"再写入一个 int 整数，也是 4 个字节\",\"buffer.writeInt(5); log(buffer); \",\"结果是\",\"read index:0 write index:8 capacity:10 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 00 00 00 05 |........ | +--------+-------------------------------------------------+----------------+ \",\"还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\"]},\"773\":{\"h\":\"6）扩容\",\"t\":[\"再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\",\"buffer.writeInt(6); log(buffer); \",\"扩容规则是\",\"如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\",\"如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 210=1024（29=512 已经不够了）\",\"扩容超过 max capacity（Integer.MAX_VALUE）会报错\",\"结果是\",\"read index:0 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 00 00 00 05 00 00 00 06 |............ | +--------+-------------------------------------------------+----------------+ \"]},\"774\":{\"h\":\"7）读取\",\"t\":[\"例如读了 4 次，每次一个字节\",\"System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); log(buffer); \",\"读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\",\"1 2 3 4 read index:4 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 05 00 00 00 06 |........ | +--------+-------------------------------------------------+----------------+ \",\"如果需要重复读取 int 整数 5，怎么办？\",\"可以在 read 前先做个标记 mark\",\"buffer.markReaderIndex(); System.out.println(buffer.readInt()); log(buffer); \",\"结果\",\"5 read index:8 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 06 |.... | +--------+-------------------------------------------------+----------------+ \",\"这时要重复读取的话，重置到标记位置 reset\",\"buffer.resetReaderIndex(); log(buffer); \",\"这时\",\"read index:4 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 05 00 00 00 06 |........ | +--------+-------------------------------------------------+----------------+ \",\"还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\"]},\"775\":{\"h\":\"8）retain & release\",\"t\":[\"由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\",\"UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\",\"UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\",\"PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\",\"回收内存的源码实现，请关注下面方法的不同实现\",\"protected abstract void deallocate()\",\"Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\",\"每个 ByteBuf 对象的初始计数为 1\",\"调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\",\"调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\",\"当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\",\"谁来负责 release 呢？\",\"不是我们想象的（一般情况下）\",\"ByteBuf buf = ... try { ... } finally { buf.release(); } \",\"请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\",\"基本规则是，谁是最后使用者，谁负责 release，详细分析如下\",\"起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\",\"入站 ByteBuf 处理原则 \",\"对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\",\"将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\",\"如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\",\"注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\",\"假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\",\"出站 ByteBuf 处理原则 \",\"出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\",\"异常处理原则 \",\"有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\",\"TailContext 释放未处理消息逻辑\",\"// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object) protected void onUnhandledInboundMessage(Object msg) { try { logger.debug( \\\"Discarded inbound message {} that reached at the tail of the pipeline. \\\" + \\\"Please check your pipeline configuration.\\\", msg); } finally { ReferenceCountUtil.release(msg); } } \",\"具体代码\",\"// io.netty.util.ReferenceCountUtil#release(java.lang.Object) public static boolean release(Object msg) { if (msg instanceof ReferenceCounted) { return ((ReferenceCounted) msg).release(); } return false; } \"]},\"776\":{\"h\":\"9）slice\",\"t\":[\"【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\",\"public class TestSlice { public static void main(String[] args) { ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(10); buf.writeBytes(new byte[]{'a','b','c','d','e','f','g','h','i','j'}); log(buf); // 在切片过程中，没有发生数据复制 ByteBuf f1 = buf.slice(0, 5); f1.retain(); // 引用计数加一 // 'a','b','c','d','e', 'x' ByteBuf f2 = buf.slice(5, 5); f2.retain(); log(f1); log(f2); System.out.println(\\\"释放原有 byteBuf 内存\\\"); buf.release(); log(buf); // 此时buf没有被释放 log(f1); f1.release(); f2.release(); /*System.out.println(\\\"========================\\\"); f1.setByte(0, 'b'); log(f1); log(buf);*/ } } \",\"例，原始 ByteBuf 进行一些初始操作\",\"ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10); origin.writeBytes(new byte[]{1, 2, 3, 4}); origin.readByte(); System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write\",\"ByteBuf slice = origin.slice(); System.out.println(ByteBufUtil.prettyHexDump(slice)); // slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常 \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"如果原始 ByteBuf 再次读操作（又读了一个字节）\",\"origin.readByte(); System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 03 04 |.. | +--------+-------------------------------------------------+----------------+ \",\"这时的 slice 不受影响，因为它有独立的读写指针\",\"System.out.println(ByteBufUtil.prettyHexDump(slice)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"如果 slice 的内容发生了更改\",\"slice.setByte(2, 5); System.out.println(ByteBufUtil.prettyHexDump(slice)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 05 |... | +--------+-------------------------------------------------+----------------+ \",\"这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\",\"System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 03 05 |.. | +--------+-------------------------------------------------+----------------+ \"]},\"777\":{\"h\":\"10）duplicate\",\"t\":[\"【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\"]},\"778\":{\"h\":\"11）copy\",\"t\":[\"会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\"]},\"779\":{\"h\":\"12）CompositeByteBuf\",\"t\":[\"【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\",\"有两个 ByteBuf 如下\",\"ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5); buf1.writeBytes(new byte[]{1, 2, 3, 4, 5}); ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5); buf2.writeBytes(new byte[]{6, 7, 8, 9, 10}); System.out.println(ByteBufUtil.prettyHexDump(buf1)); System.out.println(ByteBufUtil.prettyHexDump(buf2)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 |..... | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 06 07 08 09 0a |..... | +--------+-------------------------------------------------+----------------+ \",\"现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\",\"方法1：\",\"ByteBuf buf3 = ByteBufAllocator.DEFAULT .buffer(buf1.readableBytes()+buf2.readableBytes()); buf3.writeBytes(buf1); buf3.writeBytes(buf2); System.out.println(ByteBufUtil.prettyHexDump(buf3)); \",\"结果\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\",\"方法2：\",\"CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer(); // true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0 buf3.addComponents(true, buf1, buf2); \",\"结果是一样的\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\",\"优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\",\"缺点，复杂了很多，多次操作会带来性能的损耗\"]},\"780\":{\"h\":\"13）Unpooled\",\"t\":[\"Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\",\"这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\",\"ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5); buf1.writeBytes(new byte[]{1, 2, 3, 4, 5}); ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5); buf2.writeBytes(new byte[]{6, 7, 8, 9, 10}); // 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2); System.out.println(ByteBufUtil.prettyHexDump(buf3)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"也可以用来包装普通字节数组，底层也不会有拷贝操作\",\"ByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6}); System.out.println(buf4.getClass()); System.out.println(ByteBufUtil.prettyHexDump(buf4)); \",\"输出\",\"class io.netty.buffer.CompositeByteBuf +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 |...... | +--------+-------------------------------------------------+----------------+ \"]},\"781\":{\"h\":\"ByteBuf 优势💡\",\"t\":[\"池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\",\"读写指针分离，不需要像 ByteBuffer 一样切换读写模式\",\"可以自动扩容\",\"支持链式调用，使用更流畅\",\"很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\"]},\"782\":{\"h\":\"Hello World\"},\"783\":{\"h\":\"目标\",\"t\":[\"开发一个简单的服务器端和客户端\",\"客户端向服务器端发送 hello, world\",\"服务器仅接收，不返回\",\"加入依赖\",\"<dependency> <groupId>io.netty</groupId> <artifactId>netty-all</artifactId> <version>4.1.39.Final</version> </dependency> \"]},\"784\":{\"h\":\"服务器端\",\"t\":[\"new ServerBootstrap() .group(new NioEventLoopGroup()) // 1 .channel(NioServerSocketChannel.class) // 2 .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3 protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new StringDecoder()); // 5 ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6 @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) { System.out.println(msg); } }); } }) .bind(8080); // 4 \",\"代码解读\",\"1 处，创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector 后面会详细展开\",\"2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\",\"3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\",\"4 处，ServerSocketChannel 绑定的监听端口\",\"5 处，SocketChannel 的处理器，解码 ByteBuf => String\",\"6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\"]},\"785\":{\"h\":\"客户端\",\"t\":[\"new Bootstrap() .group(new NioEventLoopGroup()) // 1 .channel(NioSocketChannel.class) // 2 .handler(new ChannelInitializer<Channel>() { // 3 @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); // 8 } }) .connect(\\\"127.0.0.1\\\", 8080) // 4 .sync() // 5 .channel() // 6 .writeAndFlush(new Date() + \\\": hello world!\\\"); // 7 \",\"代码解读\",\"1 处，创建 NioEventLoopGroup，同 Server\",\"2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\",\"3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\",\"4 处，指定要连接的服务器和端口\",\"5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\",\"6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\",\"7 处，写入消息并清空缓冲区\",\"8 处，消息会经过通道 handler 处理，这里是将 String => ByteBuf 发出\",\"数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\"]},\"786\":{\"h\":\"流程梳理\"},\"787\":{\"h\":\"提示💡\",\"t\":[\"一开始需要树立正确的观念\",\"把 channel 理解为数据的通道\",\"把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\",\"把 handler 理解为数据的处理工序 \",\"工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\",\"handler 分 Inbound 和 Outbound 两类\",\"把 eventLoop 理解为处理数据的工人 \",\"工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\",\"工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\",\"工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\"]},\"788\":{\"h\":\"Netty概述\"},\"789\":{\"h\":\"Netty 是什么？\",\"t\":[\"Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. \",\"Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\"]},\"790\":{\"h\":\"Netty 的作者\",\"t\":[\"他还是另一个著名网络应用框架 Mina 的重要贡献者\"]},\"791\":{\"h\":\"Netty 的地位\",\"t\":[\"Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\",\"以下的框架都使用了 Netty，因为它们有网络通信需求！\",\"Cassandra - nosql 数据库\",\"Spark - 大数据分布式计算框架\",\"Hadoop - 大数据分布式存储框架\",\"RocketMQ - ali 开源的消息队列\",\"ElasticSearch - 搜索引擎\",\"gRPC - rpc 框架\",\"Dubbo - rpc 框架\",\"Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\",\"Zookeeper - 分布式协调框架\"]},\"792\":{\"h\":\"Netty 的优势\",\"t\":[\"Netty vs NIO，工作量大，bug 多 \",\"需要自己构建协议\",\"解决 TCP 传输问题，如粘包、半包\",\"epoll 空轮询导致 CPU 100%\",\"对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal，ByteBuf => ByteBuffer\",\"Netty vs 其它网络应用框架 \",\"Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\",\"久经考验，16年，Netty 版本 \",\"2.x 2004\",\"3.x 2008\",\"4.x 2013\",\"5.x 已废弃（没有明显的性能提升，维护成本高）\"]},\"793\":{\"h\":\"双向通信\"},\"794\":{\"h\":\"练习\",\"t\":[\"实现一个 echo server\",\"编写 server\",\"new ServerBootstrap() .group(new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buffer = (ByteBuf) msg; System.out.println(buffer.toString(Charset.defaultCharset())); // 建议使用 ctx.alloc() 创建 ByteBuf ByteBuf response = ctx.alloc().buffer(); response.writeBytes(buffer); ctx.writeAndFlush(response); // 思考：需要释放 buffer 吗 // 思考：需要释放 response 吗 } }); } }).bind(8080); \",\"编写 client\",\"NioEventLoopGroup group = new NioEventLoopGroup(); Channel channel = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(new StringEncoder()); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buffer = (ByteBuf) msg; System.out.println(buffer.toString(Charset.defaultCharset())); // 思考：需要释放 buffer 吗 } }); } }).connect(\\\"127.0.0.1\\\", 8080).sync().channel(); channel.closeFuture().addListener(future -> { group.shutdownGracefully(); }); new Thread(() -> { Scanner scanner = new Scanner(System.in); while (true) { String line = scanner.nextLine(); if (\\\"q\\\".equals(line)) { channel.close(); break; } channel.writeAndFlush(line); } }).start(); \"]},\"795\":{\"h\":\"读和写的误解💡\",\"t\":[\"我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在A 到 B 和 B 到 A 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\",\"例如\",\"public class TestServer { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8888); Socket s = ss.accept(); new Thread(() -> { try { BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream())); while (true) { System.out.println(reader.readLine()); } } catch (IOException e) { e.printStackTrace(); } }).start(); new Thread(() -> { try { BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据 for (int i = 0; i < 100; i++) { writer.write(String.valueOf(i)); writer.newLine(); writer.flush(); } } catch (IOException e) { e.printStackTrace(); } }).start(); } } \",\"客户端\",\"public class TestClient { public static void main(String[] args) throws IOException { Socket s = new Socket(\\\"localhost\\\", 8888); new Thread(() -> { try { BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream())); while (true) { System.out.println(reader.readLine()); } } catch (IOException e) { e.printStackTrace(); } }).start(); new Thread(() -> { try { BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); for (int i = 0; i < 100; i++) { writer.write(String.valueOf(i)); writer.newLine(); writer.flush(); } } catch (IOException e) { e.printStackTrace(); } }).start(); } } \"]},\"796\":{\"h\":\"ByteBuffer\",\"t\":[\"有一普通文本文件 data.txt，内容为\",\"1234567890abcd \",\"使用 FileChannel 来读取文件内容\",\"@Slf4j public class ChannelDemo1 { public static void main(String[] args) { try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/data.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(10); do { // 向 buffer 写入 int len = channel.read(buffer); log.debug(\\\"读到字节数：{}\\\", len); if (len == -1) { break; } // 切换 buffer 读模式 buffer.flip(); while(buffer.hasRemaining()) { log.debug(\\\"{}\\\", (char)buffer.get()); } // 切换 buffer 写模式 buffer.clear(); } while (true); } catch (IOException e) { e.printStackTrace(); } } } \",\"输出\",\"10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1 \"]},\"797\":{\"h\":\"ByteBuffer 正确使用姿势\",\"t\":[\"向 buffer 写入数据，例如调用 channel.read(buffer)\",\"调用 flip() 切换至读模式\",\"从 buffer 读取数据，例如调用 buffer.get()\",\"调用 clear() 或 compact() 切换至写模式\",\"重复 1~4 步骤\"]},\"798\":{\"h\":\"ByteBuffer 结构\",\"t\":[\"ByteBuffer 有以下重要属性\",\"capacity\",\"position\",\"limit\",\"一开始\",\"写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\",\"flip 动作发生后，position 切换为读取位置，limit 切换为读取限制\",\"读取 4 个字节后，状态\",\"clear 动作发生后，状态\",\"compact 方法，是把未读完的部分向前压缩，然后切换至写模式\"]},\"799\":{\"h\":\"调试工具类💡\",\"t\":[\"public class ByteBufferUtil { private static final char[] BYTE2CHAR = new char[256]; private static final char[] HEXDUMP_TABLE = new char[256 * 4]; private static final String[] HEXPADDING = new String[16]; private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4]; private static final String[] BYTE2HEX = new String[256]; private static final String[] BYTEPADDING = new String[16]; static { final char[] DIGITS = \\\"0123456789abcdef\\\".toCharArray(); for (int i = 0; i < 256; i++) { HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F]; HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F]; } int i; // Generate the lookup table for hex dump paddings for (i = 0; i < HEXPADDING.length; i++) { int padding = HEXPADDING.length - i; StringBuilder buf = new StringBuilder(padding * 3); for (int j = 0; j < padding; j++) { buf.append(\\\" \\\"); } HEXPADDING[i] = buf.toString(); } // Generate the lookup table for the start-offset header in each row (up to 64KiB). for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) { StringBuilder buf = new StringBuilder(12); buf.append(NEWLINE); buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L)); buf.setCharAt(buf.length() - 9, '|'); buf.append('|'); HEXDUMP_ROWPREFIXES[i] = buf.toString(); } // Generate the lookup table for byte-to-hex-dump conversion for (i = 0; i < BYTE2HEX.length; i++) { BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i); } // Generate the lookup table for byte dump paddings for (i = 0; i < BYTEPADDING.length; i++) { int padding = BYTEPADDING.length - i; StringBuilder buf = new StringBuilder(padding); for (int j = 0; j < padding; j++) { buf.append(' '); } BYTEPADDING[i] = buf.toString(); } // Generate the lookup table for byte-to-char conversion for (i = 0; i < BYTE2CHAR.length; i++) { if (i <= 0x1f || i >= 0x7f) { BYTE2CHAR[i] = '.'; } else { BYTE2CHAR[i] = (char) i; } } } /** * 打印所有内容 * @param buffer */ public static void debugAll(ByteBuffer buffer) { int oldlimit = buffer.limit(); buffer.limit(buffer.capacity()); StringBuilder origin = new StringBuilder(256); appendPrettyHexDump(origin, buffer, 0, buffer.capacity()); System.out.println(\\\"+--------+-------------------- all ------------------------+----------------+\\\"); System.out.printf(\\\"position: [%d], limit: [%d]\\\\n\\\", buffer.position(), oldlimit); System.out.println(origin); buffer.limit(oldlimit); } /** * 打印可读取内容 * @param buffer */ public static void debugRead(ByteBuffer buffer) { StringBuilder builder = new StringBuilder(256); appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position()); System.out.println(\\\"+--------+-------------------- read -----------------------+----------------+\\\"); System.out.printf(\\\"position: [%d], limit: [%d]\\\\n\\\", buffer.position(), buffer.limit()); System.out.println(builder); } private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) { if (isOutOfBounds(offset, length, buf.capacity())) { throw new IndexOutOfBoundsException( \\\"expected: \\\" + \\\"0 <= offset(\\\" + offset + \\\") <= offset + length(\\\" + length + \\\") <= \\\" + \\\"buf.capacity(\\\" + buf.capacity() + ')'); } if (length == 0) { return; } dump.append( \\\" +-------------------------------------------------+\\\" + NEWLINE + \\\" | 0 1 2 3 4 5 6 7 8 9 a b c d e f |\\\" + NEWLINE + \\\"+--------+-------------------------------------------------+----------------+\\\"); final int startIndex = offset; final int fullRows = length >>> 4; final int remainder = length & 0xF; // Dump the rows which have 16 bytes. for (int row = 0; row < fullRows; row++) { int rowStartIndex = (row << 4) + startIndex; // Per-row prefix. appendHexDumpRowPrefix(dump, row, rowStartIndex); // Hex dump int rowEndIndex = rowStartIndex + 16; for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2HEX[getUnsignedByte(buf, j)]); } dump.append(\\\" |\\\"); // ASCII dump for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]); } dump.append('|'); } // Dump the last row which has less than 16 bytes. if (remainder != 0) { int rowStartIndex = (fullRows << 4) + startIndex; appendHexDumpRowPrefix(dump, fullRows, rowStartIndex); // Hex dump int rowEndIndex = rowStartIndex + remainder; for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2HEX[getUnsignedByte(buf, j)]); } dump.append(HEXPADDING[remainder]); dump.append(\\\" |\\\"); // Ascii dump for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]); } dump.append(BYTEPADDING[remainder]); dump.append('|'); } dump.append(NEWLINE + \\\"+--------+-------------------------------------------------+----------------+\\\"); } private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) { if (row < HEXDUMP_ROWPREFIXES.length) { dump.append(HEXDUMP_ROWPREFIXES[row]); } else { dump.append(NEWLINE); dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L)); dump.setCharAt(dump.length() - 9, '|'); dump.append('|'); } } public static short getUnsignedByte(ByteBuffer buffer, int index) { return (short) (buffer.get(index) & 0xFF); } } \"]},\"800\":{\"h\":\"ByteBuffer 常见方法\"},\"801\":{\"h\":\"分配空间\",\"t\":[\"可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\",\"ByteBuffer buf = ByteBuffer.allocate(16); // -- java堆内存，读写效率较低，受GC影响 ByteBuffer buf2 = ByteBuffer.allocateDirect(16); // -- 直接内存，读写效率高（少一次拷贝），不受GC影响，分配的效率低，可能造成内存泄漏 \"]},\"802\":{\"h\":\"向 buffer 写入数据\",\"t\":[\"有两种办法\",\"调用 channel 的 read 方法\",\"调用 buffer 自己的 put 方法\",\"int readBytes = channel.read(buf); \",\"和\",\"buf.put((byte)127); \"]},\"803\":{\"h\":\"从 buffer 读取数据\",\"t\":[\"同样有两种办法\",\"调用 channel 的 write 方法\",\"调用 buffer 自己的 get 方法\",\"int writeBytes = channel.write(buf); \",\"和\",\"byte b = buf.get(); \",\"get 方法会让 position 读指针向后走，如果想重复读取数据\",\"可以调用 rewind 方法将 position 重新置为 0\",\"或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\"]},\"804\":{\"h\":\"mark 和 reset\",\"t\":[\"mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\",\"注意\",\"rewind 和 flip 都会清除 mark 位置\"]},\"805\":{\"h\":\"字符串与 ByteBuffer 互转\",\"t\":[\"ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\\\"你好\\\"); ByteBuffer buffer2 = Charset.forName(\\\"utf-8\\\").encode(\\\"你好\\\"); debug(buffer1); debug(buffer2); CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1); System.out.println(buffer3.getClass()); System.out.println(buffer3.toString()); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| e4 bd a0 e5 a5 bd |...... | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| e4 bd a0 e5 a5 bd |...... | +--------+-------------------------------------------------+----------------+ class java.nio.HeapCharBuffer 你好 \"]},\"806\":{\"h\":\"Buffer 的线程安全⚠️\",\"t\":[\"Buffer 是非线程安全的\"]},\"807\":{\"h\":\"Scattering Reads分散读\",\"t\":[\"分散读取，有一个文本文件 3parts.txt\",\"onetwothree \",\"使用如下方式读取，可以将数据填充至多个 buffer\",\"try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/3parts.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer a = ByteBuffer.allocate(3); ByteBuffer b = ByteBuffer.allocate(3); ByteBuffer c = ByteBuffer.allocate(5); channel.read(new ByteBuffer[]{a, b, c}); a.flip(); b.flip(); c.flip(); debug(a); debug(b); debug(c); } catch (IOException e) { e.printStackTrace(); } \",\"结果\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6f 6e 65 |one | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 74 77 6f |two | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 74 68 72 65 65 |three | +--------+-------------------------------------------------+----------------+ \"]},\"808\":{\"h\":\"Gathering Writes集中写\",\"t\":[\"使用如下方式写入，可以将多个 buffer 的数据填充至 channel\",\"try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/3parts.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer d = ByteBuffer.allocate(4); ByteBuffer e = ByteBuffer.allocate(4); channel.position(11); d.put(new byte[]{'f', 'o', 'u', 'r'}); e.put(new byte[]{'f', 'i', 'v', 'e'}); d.flip(); e.flip(); debug(d); debug(e); channel.write(new ByteBuffer[]{d, e}); } catch (IOException e) { e.printStackTrace(); } \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 6f 75 72 |four | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 69 76 65 |five | +--------+-------------------------------------------------+----------------+ \",\"文件内容\",\"onetwothreefourfive \"]},\"809\":{\"h\":\"练习\",\"t\":[\"网络上有多条数据发送给服务端，数据之间使用 \\\\n 进行分隔 但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\",\"Hello,world\\\\n\",\"I'm zhangsan\\\\n\",\"How are you?\\\\n\",\"变成了下面的两个 byteBuffer (黏包，半包)\",\"Hello,world\\\\nI'm zhangsan\\\\nHo\",\"w are you?\\\\n\",\"现在要求你编写程序，将错乱的数据恢复成原始的按 \\\\n 分隔的数据\",\"public static void main(String[] args) { ByteBuffer source = ByteBuffer.allocate(32); // 11 24 source.put(\\\"Hello,world\\\\nI'm zhangsan\\\\nHo\\\".getBytes()); split(source); source.put(\\\"w are you?\\\\nhaha!\\\\n\\\".getBytes()); split(source); } private static void split(ByteBuffer source) { source.flip(); int oldLimit = source.limit(); for (int i = 0; i < oldLimit; i++) { if (source.get(i) == '\\\\n') { System.out.println(i); ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position()); // 0 ~ limit source.limit(i + 1); target.put(source); // 从source 读，向 target 写 debugAll(target); source.limit(oldLimit); } } source.compact(); } \"]},\"810\":{\"h\":\"文件编程\"},\"811\":{\"h\":\"FileChannel\"},\"812\":{\"h\":\"FileChannel 工作模式⚠️\",\"t\":[\"FileChannel 只能工作在阻塞模式下\"]},\"813\":{\"h\":\"获取\",\"t\":[\"不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\",\"通过 FileInputStream 获取的 channel 只能读\",\"通过 FileOutputStream 获取的 channel 只能写\",\"通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\"]},\"814\":{\"h\":\"读取\",\"t\":[\"会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\",\"int readBytes = channel.read(buffer); \"]},\"815\":{\"h\":\"写入\",\"t\":[\"写入的正确姿势如下， SocketChannel\",\"ByteBuffer buffer = ...; buffer.put(...); // 存入数据 buffer.flip(); // 切换读模式 while(buffer.hasRemaining()) { channel.write(buffer); } \",\"在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\"]},\"816\":{\"h\":\"关闭\",\"t\":[\"channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\"]},\"817\":{\"h\":\"位置\",\"t\":[\"获取当前位置\",\"long pos = channel.position(); \",\"设置当前位置\",\"long newPos = ...; channel.position(newPos); \",\"设置当前位置时，如果设置为文件的末尾\",\"这时读取会返回 -1\",\"这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\"]},\"818\":{\"h\":\"大小\",\"t\":[\"使用 size 方法获取文件的大小\"]},\"819\":{\"h\":\"强制写入\",\"t\":[\"操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\"]},\"820\":{\"h\":\"两个 Channel 传输数据\",\"t\":[\"String FROM = \\\"helloword/data.txt\\\"; String TO = \\\"helloword/to.txt\\\"; long start = System.nanoTime(); try (FileChannel from = new FileInputStream(FROM).getChannel(); FileChannel to = new FileOutputStream(TO).getChannel(); ) { // 效率高，底层会用操作系统的零拷贝进行优化，一次只能穿2G from.transferTo(0, from.size(), to); } catch (IOException e) { e.printStackTrace(); } long end = System.nanoTime(); System.out.println(\\\"transferTo 用时：\\\" + (end - start) / 1000_000.0); \",\"输出\",\"transferTo 用时：8.2011 \",\"超过 2g 大小的文件传输\",\"public class TestFileChannelTransferTo { public static void main(String[] args) { try ( FileChannel from = new FileInputStream(\\\"data.txt\\\").getChannel(); FileChannel to = new FileOutputStream(\\\"to.txt\\\").getChannel(); ) { // 效率高，底层会利用操作系统的零拷贝进行优化 long size = from.size(); // left 变量代表还剩余多少字节 for (long left = size; left > 0; ) { System.out.println(\\\"position:\\\" + (size - left) + \\\" left:\\\" + left); left -= from.transferTo((size - left), left, to); } } catch (IOException e) { e.printStackTrace(); } } } \",\"实际传输一个超大文件\",\"position:0 left:7769948160 position:2147483647 left:5622464513 position:4294967294 left:3474980866 position:6442450941 left:1327497219 \"]},\"821\":{\"h\":\"Path\",\"t\":[\"jdk7 引入了 Path 和 Paths 类\",\"Path 用来表示文件路径\",\"Paths 是工具类，用来获取 Path 实例\",\"Path source = Paths.get(\\\"1.txt\\\"); // 相对路径 使用 user.dir 环境变量来定位 1.txt Path source = Paths.get(\\\"d:\\\\\\\\1.txt\\\"); // 绝对路径 代表了 d:\\\\1.txt Path source = Paths.get(\\\"d:/1.txt\\\"); // 绝对路径 同样代表了 d:\\\\1.txt Path projects = Paths.get(\\\"d:\\\\\\\\data\\\", \\\"projects\\\"); // 代表了 d:\\\\data\\\\projects \",\". 代表了当前路径\",\".. 代表了上一级路径\",\"例如目录结构如下\",\"d: |- data |- projects |- a |- b \",\"代码\",\"Path path = Paths.get(\\\"d:\\\\\\\\data\\\\\\\\projects\\\\\\\\a\\\\\\\\..\\\\\\\\b\\\"); System.out.println(path); System.out.println(path.normalize()); // 正常化路径 \",\"会输出\",\"d:\\\\data\\\\projects\\\\a\\\\..\\\\b d:\\\\data\\\\projects\\\\b \"]},\"822\":{\"h\":\"Files\",\"t\":[\"检查文件是否存在\",\"Path path = Paths.get(\\\"helloword/data.txt\\\"); System.out.println(Files.exists(path)); \",\"创建一级目录\",\"Path path = Paths.get(\\\"helloword/d1\\\"); Files.createDirectory(path); \",\"如果目录已存在，会抛异常 FileAlreadyExistsException\",\"不能一次创建多级目录，否则会抛异常 NoSuchFileException\",\"创建多级目录用\",\"Path path = Paths.get(\\\"helloword/d1/d2\\\"); Files.createDirectories(path); \",\"拷贝文件\",\"Path source = Paths.get(\\\"helloword/data.txt\\\"); Path target = Paths.get(\\\"helloword/target.txt\\\"); Files.copy(source, target); \",\"如果文件已存在，会抛异常 FileAlreadyExistsException\",\"如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\",\"Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING); \",\"移动文件\",\"Path source = Paths.get(\\\"helloword/data.txt\\\"); Path target = Paths.get(\\\"helloword/data.txt\\\"); Files.move(source, target, StandardCopyOption.ATOMIC_MOVE); \",\"StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\",\"删除文件\",\"Path target = Paths.get(\\\"helloword/target.txt\\\"); Files.delete(target); \",\"如果文件不存在，会抛异常 NoSuchFileException\",\"删除目录\",\"Path target = Paths.get(\\\"helloword/d1\\\"); Files.delete(target); \",\"如果目录还有内容，会抛异常 DirectoryNotEmptyException\",\"遍历目录文件\",\"// 统计文件夹和文件个数 public static void main(String[] args) throws IOException { Path path = Paths.get(\\\"C:\\\\\\\\Program Files\\\\\\\\Java\\\\\\\\jdk1.8.0_91\\\"); AtomicInteger dirCount = new AtomicInteger(); AtomicInteger fileCount = new AtomicInteger(); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { System.out.println(dir); dirCount.incrementAndGet(); return super.preVisitDirectory(dir, attrs); } @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { System.out.println(file); fileCount.incrementAndGet(); return super.visitFile(file, attrs); } }); System.out.println(dirCount); // 133 System.out.println(fileCount); // 1479 } \",\"统计 jar 的数目\",\"Path path = Paths.get(\\\"C:\\\\\\\\Program Files\\\\\\\\Java\\\\\\\\jdk1.8.0_91\\\"); AtomicInteger fileCount = new AtomicInteger(); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { if (file.toFile().getName().endsWith(\\\".jar\\\")) { fileCount.incrementAndGet(); } return super.visitFile(file, attrs); } }); System.out.println(fileCount); // 724 \",\"删除多级目录\",\"Path path = Paths.get(\\\"d:\\\\\\\\a\\\"); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return super.visitFile(file, attrs); } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { Files.delete(dir); return super.postVisitDirectory(dir, exc); } }); \"]},\"823\":{\"h\":\"删除很危险⚠️\",\"t\":[\"删除是危险操作，确保要递归删除的文件夹没有重要内容\",\"拷贝多级目录\",\"long start = System.currentTimeMillis(); String source = \\\"D:\\\\\\\\Snipaste-1.16.2-x64\\\"; String target = \\\"D:\\\\\\\\Snipaste-1.16.2-x64aaa\\\"; Files.walk(Paths.get(source)).forEach(path -> { try { String targetName = path.toString().replace(source, target); // 是目录 if (Files.isDirectory(path)) { Files.createDirectory(Paths.get(targetName)); } // 是普通文件 else if (Files.isRegularFile(path)) { Files.copy(path, Paths.get(targetName)); } } catch (IOException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(end - start); \"]},\"824\":{\"h\":\"网络编程\"},\"825\":{\"h\":\"非阻塞 vs 阻塞\"},\"826\":{\"h\":\"阻塞\",\"t\":[\"阻塞模式下，相关方法都会导致线程暂停 \",\"ServerSocketChannel.accept 会在没有连接建立时让线程暂停\",\"SocketChannel.read 会在没有数据可读时让线程暂停\",\"阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\",\"单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\",\"但多线程下，有新的问题，体现在以下方面 \",\"32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\",\"可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\",\"服务器端\",\"// 使用 nio 来理解阻塞模式, 单线程 // 0. ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(16); // 1. 创建了服务器 ServerSocketChannel ssc = ServerSocketChannel.open(); // 2. 绑定监听端口 ssc.bind(new InetSocketAddress(8080)); // 3. 连接集合 List<SocketChannel> channels = new ArrayList<>(); while (true) { // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信 log.debug(\\\"connecting...\\\"); SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行 log.debug(\\\"connected... {}\\\", sc); channels.add(sc); for (SocketChannel channel : channels) { // 5. 接收客户端发送的数据 log.debug(\\\"before read... {}\\\", channel); channel.read(buffer); // 阻塞方法，线程停止运行 buffer.flip(); debugRead(buffer); buffer.clear(); log.debug(\\\"after read...{}\\\", channel); } } \",\"客户端\",\"SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); System.out.println(\\\"waiting...\\\"); \"]},\"827\":{\"h\":\"非阻塞\",\"t\":[\"非阻塞模式下，相关方法都会不会让线程暂停 \",\"在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\",\"SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept\",\"写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\",\"但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\",\"数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\",\"服务器端，客户端代码不变\",\"// 使用 nio 来理解非阻塞模式, 单线程 // 0. ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(16); // 1. 创建了服务器 ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 非阻塞模式 // 2. 绑定监听端口 ssc.bind(new InetSocketAddress(8080)); // 3. 连接集合 List<SocketChannel> channels = new ArrayList<>(); while (true) { // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信 SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null if (sc != null) { log.debug(\\\"connected... {}\\\", sc); sc.configureBlocking(false); // 非阻塞模式 channels.add(sc); } for (SocketChannel channel : channels) { // 5. 接收客户端发送的数据 int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0 if (read > 0) { buffer.flip(); debugRead(buffer); buffer.clear(); log.debug(\\\"after read...{}\\\", channel); } } } \"]},\"828\":{\"h\":\"多路复用\",\"t\":[\"单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\",\"多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\",\"如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证 \",\"有可连接事件时才去连接\",\"有可读事件才去读取\",\"有可写事件才去写入 \",\"限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\"]},\"829\":{\"h\":\"Selector\",\"t\":[\"好处\",\"一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\",\"让这个线程能够被充分利用\",\"节约了线程的数量\",\"减少了线程上下文切换\"]},\"830\":{\"h\":\"创建\",\"t\":[\"Selector selector = Selector.open(); \"]},\"831\":{\"h\":\"绑定 Channel 事件\",\"t\":[\"也称之为注册事件，绑定的事件 selector 才会关心\",\"channel.configureBlocking(false); SelectionKey key = channel.register(selector, 绑定事件); \",\"channel 必须工作在非阻塞模式\",\"FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\",\"绑定的事件类型可以有 \",\"connect - 客户端连接成功时触发\",\"accept - 服务器端成功接受连接时触发\",\"read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\",\"write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\"]},\"832\":{\"h\":\"监听 Channel 事件\",\"t\":[\"可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\",\"方法1，阻塞直到绑定事件发生\",\"int count = selector.select(); \",\"方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\",\"int count = selector.select(long timeout); \",\"方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\",\"int count = selector.selectNow(); \"]},\"833\":{\"h\":\"select 何时不阻塞💡\",\"t\":[\"事件发生时 \",\"客户端发起连接请求，会触发 accept 事件\",\"客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\",\"channel 可写，会触发 write 事件\",\"在 linux 下 nio bug 发生时\",\"调用 selector.wakeup()\",\"调用 selector.close()\",\"selector 所在线程 interrupt\"]},\"834\":{\"h\":\"处理 accept 事件\",\"t\":[\"客户端代码为\",\"public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)) { System.out.println(socket); socket.getOutputStream().write(\\\"world\\\".getBytes()); System.in.read(); } catch (IOException e) { e.printStackTrace(); } } } \",\"服务器端代码为\",\"@Slf4j public class ChannelDemo6 { public static void main(String[] args) { try (ServerSocketChannel channel = ServerSocketChannel.open()) { channel.bind(new InetSocketAddress(8080)); System.out.println(channel); Selector selector = Selector.open(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_ACCEPT); while (true) { int count = selector.select(); // int count = selector.selectNow(); log.debug(\\\"select count: {}\\\", count); // if(count <= 0) { // continue; // } // 获取所有事件 Set<SelectionKey> keys = selector.selectedKeys(); // 遍历所有事件，逐一处理 Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); // 判断事件类型 if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); // 必须处理 SocketChannel sc = c.accept(); log.debug(\\\"{}\\\", sc); } // 处理完毕，必须将事件移除 iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } \"]},\"835\":{\"h\":\"事件发生后能否不处理💡\",\"t\":[\"事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\"]},\"836\":{\"h\":\"处理 read 事件\",\"t\":[\"@Slf4j public class ChannelDemo6 { public static void main(String[] args) { try (ServerSocketChannel channel = ServerSocketChannel.open()) { channel.bind(new InetSocketAddress(8080)); System.out.println(channel); Selector selector = Selector.open(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_ACCEPT); while (true) { int count = selector.select(); // int count = selector.selectNow(); log.debug(\\\"select count: {}\\\", count); // if(count <= 0) { // continue; // } // 获取所有事件 Set<SelectionKey> keys = selector.selectedKeys(); // 遍历所有事件，逐一处理 Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); // 判断事件类型 if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); // 必须处理 SocketChannel sc = c.accept(); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); log.debug(\\\"连接已建立: {}\\\", sc); } else if (key.isReadable()) { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(128); int read = sc.read(buffer); if(read == -1) { key.cancel(); sc.close(); } else { buffer.flip(); debug(buffer); } } // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题 iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } \",\"开启两个客户端，修改一下发送文字，输出\",\"sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080] 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367] 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 65 6c 6c 6f |hello | +--------+-------------------------------------------------+----------------+ 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378] 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 6f 72 6c 64 |world | +--------+-------------------------------------------------+----------------+ \"]},\"837\":{\"h\":\"为何要 iter.remove()💡\",\"t\":[\"因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\",\"第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey\",\"第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\"]},\"838\":{\"h\":\"cancel 的作用💡\",\"t\":[\"cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\"]},\"839\":{\"h\":\"不处理边界的问题⚠️\",\"t\":[\"以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\",\"public class Server { public static void main(String[] args) throws IOException { ServerSocket ss=new ServerSocket(9000); while (true) { Socket s = ss.accept(); InputStream in = s.getInputStream(); // 这里这么写，有没有问题 byte[] arr = new byte[4]; while(true) { int read = in.read(arr); // 这里这么写，有没有问题 if(read == -1) { break; } System.out.println(new String(arr, 0, read)); } } } } \",\"客户端\",\"public class Client { public static void main(String[] args) throws IOException { Socket max = new Socket(\\\"localhost\\\", 9000); OutputStream out = max.getOutputStream(); out.write(\\\"hello\\\".getBytes()); out.write(\\\"world\\\".getBytes()); out.write(\\\"你好\\\".getBytes()); max.close(); } } \",\"输出\",\"hell owor ld� �好 \",\"为什么？\"]},\"840\":{\"h\":\"处理消息的边界\",\"t\":[\"一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\",\"另一种思路是按分隔符拆分，缺点是效率低\",\"TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量 \",\"Http 1.1 是 TLV 格式\",\"Http 2.0 是 LTV 格式\",\"服务器端\",\"private static void split(ByteBuffer source) { source.flip(); for (int i = 0; i < source.limit(); i++) { // 找到一条完整消息 if (source.get(i) == '\\\\n') { int length = i + 1 - source.position(); // 把这条完整消息存入新的 ByteBuffer ByteBuffer target = ByteBuffer.allocate(length); // 从 source 读，向 target 写 for (int j = 0; j < length; j++) { target.put(source.get()); } debugAll(target); } } source.compact(); // 0123456789abcdef position 16 limit 16 } public static void main(String[] args) throws IOException { // 1. 创建 selector, 管理多个 channel Selector selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 2. 建立 selector 和 channel 的联系（注册） // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件 SelectionKey sscKey = ssc.register(selector, 0, null); // key 只关注 accept 事件 sscKey.interestOps(SelectionKey.OP_ACCEPT); log.debug(\\\"sscKey:{}\\\", sscKey); ssc.bind(new InetSocketAddress(8080)); while (true) { // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行 // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理 selector.select(); // 4. 处理事件, selectedKeys 内部包含了所有发生的事件 Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read while (iter.hasNext()) { SelectionKey key = iter.next(); // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题 iter.remove(); log.debug(\\\"key: {}\\\", key); // 5. 区分事件类型 if (key.isAcceptable()) { // 如果是 accept ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel sc = channel.accept(); sc.configureBlocking(false); ByteBuffer buffer = ByteBuffer.allocate(16); // attachment // 将一个 byteBuffer 作为附件关联到 selectionKey 上 SelectionKey scKey = sc.register(selector, 0, buffer); scKey.interestOps(SelectionKey.OP_READ); log.debug(\\\"{}\\\", sc); log.debug(\\\"scKey:{}\\\", scKey); } else if (key.isReadable()) { // 如果是 read try { SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel // 获取 selectionKey 上关联的附件 ByteBuffer buffer = (ByteBuffer) key.attachment(); int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1 if(read == -1) { key.cancel(); } else { split(buffer); // 需要扩容 if (buffer.position() == buffer.limit()) { ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2); buffer.flip(); newBuffer.put(buffer); // 0123456789abcdef3333\\\\n key.attach(newBuffer); } } } catch (IOException e) { e.printStackTrace(); key.cancel(); // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key） } } } } } \",\"客户端\",\"SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); SocketAddress address = sc.getLocalAddress(); // sc.write(Charset.defaultCharset().encode(\\\"hello\\\\nworld\\\\n\\\")); sc.write(Charset.defaultCharset().encode(\\\"0123\\\\n456789abcdef\\\")); sc.write(Charset.defaultCharset().encode(\\\"0123456789abcdef3333\\\\n\\\")); System.in.read(); \"]},\"841\":{\"h\":\"ByteBuffer 大小分配\",\"t\":[\"每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\",\"ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer \",\"一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 http://tutorials.jenkov.com/java-performance/resizable-array.html\",\"另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\"]},\"842\":{\"h\":\"处理 write 事件\"},\"843\":{\"h\":\"一次无法写完例子\",\"t\":[\"非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\",\"用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略 \",\"当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\",\"selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\",\"如果不取消，会每次可写均会触发 write 事件\",\"public class WriteServer { public static void main(String[] args) throws IOException { ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); ssc.bind(new InetSocketAddress(8080)); Selector selector = Selector.open(); ssc.register(selector, SelectionKey.OP_ACCEPT); while(true) { selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { SocketChannel sc = ssc.accept(); sc.configureBlocking(false); SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ); // 1. 向客户端发送内容 StringBuilder sb = new StringBuilder(); for (int i = 0; i < 3000000; i++) { sb.append(\\\"a\\\"); } ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString()); int write = sc.write(buffer); // 3. write 表示实际写了多少字节 System.out.println(\\\"实际写入字节:\\\" + write); // 4. 如果有剩余未读字节，才需要关注写事件 if (buffer.hasRemaining()) { // read 1 write 4 // 在原有关注事件的基础上，多关注 写事件 sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE); // 把 buffer 作为附件加入 sckey sckey.attach(buffer); } } else if (key.isWritable()) { ByteBuffer buffer = (ByteBuffer) key.attachment(); SocketChannel sc = (SocketChannel) key.channel(); int write = sc.write(buffer); System.out.println(\\\"实际写入字节:\\\" + write); if (!buffer.hasRemaining()) { // 写完了 key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); key.attach(null); } } } } } } \",\"客户端\",\"public class WriteClient { public static void main(String[] args) throws IOException { Selector selector = Selector.open(); SocketChannel sc = SocketChannel.open(); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); int count = 0; while (true) { selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isConnectable()) { System.out.println(sc.finishConnect()); } else if (key.isReadable()) { ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); count += sc.read(buffer); buffer.clear(); System.out.println(count); } } } } } \"]},\"844\":{\"h\":\"write 为何要取消💡\",\"t\":[\"只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\"]},\"845\":{\"h\":\"更进一步\"},\"846\":{\"h\":\"利用多线程优化💡\",\"t\":[\"现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\",\"前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\",\"分两组选择器\",\"单线程配一个选择器（boss），专门处理 accept 事件\",\"创建 cpu 核心数的线程，每个线程配一个选择器（worker），轮流处理 read 事件\",\"public class ChannelDemo7 { public static void main(String[] args) throws IOException { new BossEventLoop().register(); } @Slf4j static class BossEventLoop implements Runnable { private Selector boss; private WorkerEventLoop[] workers; private volatile boolean start = false; AtomicInteger index = new AtomicInteger(); public void register() throws IOException { if (!start) { start = true; ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(8080)); ssc.configureBlocking(false); boss = Selector.open(); SelectionKey ssckey = ssc.register(boss, 0, null); ssckey.interestOps(SelectionKey.OP_ACCEPT); workers = initEventLoops(); new Thread(this, \\\"boss\\\").start(); log.debug(\\\"boss start...\\\"); } } public WorkerEventLoop[] initEventLoops() { // EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()]; WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2]; for (int i = 0; i < workerEventLoops.length; i++) { workerEventLoops[i] = new WorkerEventLoop(i); } return workerEventLoops; } @Override public void run() { while (true) { try { boss.select(); Iterator<SelectionKey> iter = boss.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); SocketChannel sc = c.accept(); sc.configureBlocking(false); log.debug(\\\"{} connected\\\", sc.getRemoteAddress()); workers[index.getAndIncrement() % workers.length].register(sc); } } } catch (IOException e) { e.printStackTrace(); } } } } @Slf4j static class WorkerEventLoop implements Runnable { private Selector worker; private volatile boolean start = false; private int index; private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>(); public WorkerEventLoop(int index) { this.index = index; } public void register(SocketChannel sc) throws IOException { if (!start) { worker = Selector.open(); new Thread(this, \\\"worker-\\\" + index).start(); start = true; } tasks.add(() -> { try { SelectionKey sckey = sc.register(worker, 0, null); sckey.interestOps(SelectionKey.OP_READ); worker.selectNow(); } catch (IOException e) { e.printStackTrace(); } }); worker.wakeup(); } @Override public void run() { while (true) { try { worker.select(); Runnable task = tasks.poll(); if (task != null) { task.run(); } Set<SelectionKey> keys = worker.selectedKeys(); Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); if (key.isReadable()) { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(128); try { int read = sc.read(buffer); if (read == -1) { key.cancel(); sc.close(); } else { buffer.flip(); log.debug(\\\"{} message:\\\", sc.getRemoteAddress()); debugAll(buffer); } } catch (IOException e) { e.printStackTrace(); key.cancel(); sc.close(); } } iter.remove(); } } catch (IOException e) { e.printStackTrace(); } } } } } \"]},\"847\":{\"h\":\"如何拿到 cpu 个数💡\",\"t\":[\"Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\",\"这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\"]},\"848\":{\"h\":\"UDP\",\"t\":[\"UDP 是无连接的，client 发送数据不会管 server 是否开启\",\"server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\",\"首先启动服务器端\",\"public class UdpServer { public static void main(String[] args) { try (DatagramChannel channel = DatagramChannel.open()) { channel.socket().bind(new InetSocketAddress(9999)); System.out.println(\\\"waiting...\\\"); ByteBuffer buffer = ByteBuffer.allocate(32); channel.receive(buffer); buffer.flip(); debug(buffer); } catch (IOException e) { e.printStackTrace(); } } } \",\"输出\",\"waiting... \",\"运行客户端\",\"public class UdpClient { public static void main(String[] args) { try (DatagramChannel channel = DatagramChannel.open()) { ByteBuffer buffer = StandardCharsets.UTF_8.encode(\\\"hello\\\"); InetSocketAddress address = new InetSocketAddress(\\\"localhost\\\", 9999); channel.send(buffer, address); } catch (Exception e) { e.printStackTrace(); } } } \",\"接下来服务器端输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 65 6c 6c 6f |hello | +--------+-------------------------------------------------+----------------+ \"]},\"849\":{\"h\":\"NIO vs. BIO\"},\"850\":{\"h\":\"stream vs channel\",\"t\":[\"stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\",\"stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\",\"二者均为全双工，即读写可以同时进行\"]},\"851\":{\"h\":\"IO 模型\",\"t\":[\"同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\",\"同步：线程自己去获取结果（一个线程）\",\"异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\",\"当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\",\"等待数据阶段\",\"复制数据阶段\",\"阻塞 IO\",\"非阻塞 IO\",\"多路复用\",\"信号驱动\",\"异步 IO\",\"阻塞 IO vs 多路复用\"]},\"852\":{\"h\":\"参考🔖\",\"t\":[\"UNIX 网络编程 - 卷 I\"]},\"853\":{\"h\":\"零拷贝\"},\"854\":{\"h\":\"传统 IO 问题\",\"t\":[\"传统的 IO 将一个文件通过 socket 写出\",\"File f = new File(\\\"helloword/data.txt\\\"); RandomAccessFile file = new RandomAccessFile(file, \\\"r\\\"); byte[] buf = new byte[(int)f.length()]; file.read(buf); Socket socket = ...; socket.getOutputStream().write(buf); \",\"内部工作流程是这样的：\",\"java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\",\"DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\",\"从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\",\"调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，cpu 会参与拷贝\",\"接下来要向网卡写数据，这项能力 java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\",\"可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\",\"用户态与内核态的切换发生了 3 次，这个操作比较重量级\",\"数据拷贝了共 4 次\"]},\"855\":{\"h\":\"NIO 优化\",\"t\":[\"通过 DirectByteBuf\",\"ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存\",\"ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存\",\"大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\",\"这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\",\"java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步 \",\"DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\",\"通过专门线程访问引用队列，根据虚引用释放堆外内存\",\"减少了一次数据拷贝，用户态与内核态的切换次数没有减少\",\"进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\",\"java 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\",\"数据从内核缓冲区传输到 socket 缓冲区，cpu 会参与拷贝\",\"最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\",\"可以看到\",\"只发生了一次用户态与内核态的切换\",\"数据拷贝了 3 次\",\"进一步优化（linux 2.4）\",\"java 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\",\"只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗\",\"使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 cpu\",\"整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\",\"更少的用户态与内核态的切换\",\"不利用 cpu 计算，减少 cpu 缓存伪共享\",\"零拷贝适合小文件传输\"]},\"856\":{\"h\":\"AIO\",\"t\":[\"AIO 用来解决数据复制阶段的阻塞问题\",\"同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\",\"异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\",\"异步模型需要底层操作系统（Kernel）提供支持\",\"Windows 系统通过 IOCP 实现了真正的异步 IO\",\"Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\"]},\"857\":{\"h\":\"文件 AIO\",\"t\":[\"先来看看 AsynchronousFileChannel\",\"@Slf4j public class AioDemo1 { public static void main(String[] args) throws IOException { try{ AsynchronousFileChannel s = AsynchronousFileChannel.open( Paths.get(\\\"1.txt\\\"), StandardOpenOption.READ); ByteBuffer buffer = ByteBuffer.allocate(2); log.debug(\\\"begin...\\\"); s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer attachment) { log.debug(\\\"read completed...{}\\\", result); buffer.flip(); debug(buffer); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.debug(\\\"read failed...\\\"); } }); } catch (IOException e) { e.printStackTrace(); } log.debug(\\\"do other things...\\\"); System.in.read(); } } \",\"输出\",\"13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin... 13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things... 13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 0d |a. | +--------+-------------------------------------------------+----------------+ \",\"可以看到\",\"响应文件读取成功的是另一个线程 Thread-5\",\"主线程并没有 IO 操作阻塞\"]},\"858\":{\"h\":\"守护线程💡\",\"t\":[\"默认文件 AIO 使用的线程都是守护线程，所以最后要执行 System.in.read() 以避免守护线程意外结束\"]},\"859\":{\"h\":\"网络 AIO\",\"t\":[\"public class AioServer { public static void main(String[] args) throws IOException { AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open(); ssc.bind(new InetSocketAddress(8080)); ssc.accept(null, new AcceptHandler(ssc)); System.in.read(); } private static void closeChannel(AsynchronousSocketChannel sc) { try { System.out.printf(\\\"[%s] %s close\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); sc.close(); } catch (IOException e) { e.printStackTrace(); } } private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> { private final AsynchronousSocketChannel sc; public ReadHandler(AsynchronousSocketChannel sc) { this.sc = sc; } @Override public void completed(Integer result, ByteBuffer attachment) { try { if (result == -1) { closeChannel(sc); return; } System.out.printf(\\\"[%s] %s read\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); attachment.flip(); System.out.println(Charset.defaultCharset().decode(attachment)); attachment.clear(); // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件 sc.read(attachment, attachment, this); } catch (IOException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { closeChannel(sc); exc.printStackTrace(); } } private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> { private final AsynchronousSocketChannel sc; private WriteHandler(AsynchronousSocketChannel sc) { this.sc = sc; } @Override public void completed(Integer result, ByteBuffer attachment) { // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容 if (attachment.hasRemaining()) { sc.write(attachment); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { exc.printStackTrace(); closeChannel(sc); } } private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> { private final AsynchronousServerSocketChannel ssc; public AcceptHandler(AsynchronousServerSocketChannel ssc) { this.ssc = ssc; } @Override public void completed(AsynchronousSocketChannel sc, Object attachment) { try { System.out.printf(\\\"[%s] %s connected\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); } catch (IOException e) { e.printStackTrace(); } ByteBuffer buffer = ByteBuffer.allocate(16); // 读事件由 ReadHandler 处理 sc.read(buffer, buffer, new ReadHandler(sc)); // 写事件由 WriteHandler 处理 sc.write(Charset.defaultCharset().encode(\\\"server hello!\\\"), ByteBuffer.allocate(16), new WriteHandler(sc)); // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件 ssc.accept(null, this); } @Override public void failed(Throwable exc, Object attachment) { exc.printStackTrace(); } } } \"]},\"860\":{\"h\":\"三大组件\"},\"861\":{\"h\":\"Channel & Buffer\",\"t\":[\"channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\",\"常见的 Channel 有\",\"FileChannel\",\"DatagramChannel\",\"SocketChannel\",\"ServerSocketChannel\",\"buffer 则用来缓冲读写数据，常见的 buffer 有\",\"ByteBuffer \",\"MappedByteBuffer\",\"DirectByteBuffer\",\"HeapByteBuffer\",\"ShortBuffer\",\"IntBuffer\",\"LongBuffer\",\"FloatBuffer\",\"DoubleBuffer\",\"CharBuffer\"]},\"862\":{\"h\":\"Selector\",\"t\":[\"selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\"]},\"863\":{\"h\":\"多线程版设计\"},\"864\":{\"h\":\"多线程版缺点⚠️\",\"t\":[\"内存占用高\",\"线程上下文切换成本高\",\"只适合连接数少的场景\"]},\"865\":{\"h\":\"线程池版设计\"},\"866\":{\"h\":\"线程池版缺点⚠️\",\"t\":[\"阻塞模式下，线程仅能处理一个 socket 连接\",\"仅适合短连接场景\"]},\"867\":{\"h\":\"selector 版设计\",\"t\":[\"selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\",\"调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\"]},\"868\":{\"h\":\"HDFS 集群管理与运维\"},\"869\":{\"h\":\"1. DistCp\",\"t\":[\"HDFS分布式拷贝工具\",\"用于数据迁移，定期在集群间或集群内部进行数据备份\",\"底层使用MapReduce在集群之间或并行地在同一集群内复制文件。执行复制的MapReduce只有mapper阶段。\",\"$ hadoop distcp usage: distcp OPTIONS [source_path...] <target_path> -append //拷贝文件时支持对现有文件进行追加写操作 -async //异步执行distcp拷贝任务 -bandwidth <arg> //对每个Map任务的带宽限速 -delete //删除相对于源端,目标端多出来的文件 -diff <arg> //通过快照diff信息进行数据的同步 -overwrite //以覆盖的方式进行拷贝,如果目标端文件已经存在,则直接覆盖 -p <arg> //拷贝数据时,扩展属性信息的保留,包括权限信息,块大小信息等等 -skipcrccheck //拷贝数据时是否跳过cheacksum的校验 -update //拷贝数据时,只拷贝相对于源端 ,目标端不存在的文件数据 \"]},\"870\":{\"h\":\"2. 安全模式\",\"t\":[\"安全模式下系统可读不可写\",\"Hadoop中的安全模式safe mode是NameNode的维护状态，在此状态下NameNode不允许对文件系统进行任何更改，可以接受读数据请求。\",\"在NameNode启动过程中，首先会从fsimage和edits日志文件加载文件系统状态。然后，等待DataNodes汇报可用的block信息。在此期间，NameNode保持在安全模式。随着DataNode的block汇报持续进行，当整个系统达到安全标准时，HDFS自动离开安全模式。在NameNode Web主页上会显示安全模式是打开还是关闭。\",\"如果HDFS处于安全模式下，不允许HDFS客户端进行任何修改文件的操作,包括上传文件，删除文件，重命名，创建文件夹,修改副本数等操作。\",\"自动操作：\",\"# hdfs-site.xml、hdfs-default.xml dfs.replication #hdfs block的副本数据，默认3 dfs.replication.max #最大块副本数，默认512 dfs.namenode.replication.min #最小块副本数，默认1 dfs.namenode.safemode.threshold-pct #已汇报可用数据块数量占整体块数量的百分比阈值。默认0.999f。 #小于或等于0，则表示退出安全模式之前，不要等待特定百分比的块。 # 大于1的值将使安全模式永久生效 dfs.namenode.safemode.min.datanodes #指在退出安全模式之前必须存活的DataNode数量，默认0 dfs.namenode.safemode.extension #达到阈值条件后持续扩展的时间。倒计时结束如果依然满足阈值条件 # 自动离开安全模式。默认30000毫秒 \",\"手动操作：\",\"hdfs dfsadmin -safemode get # 手动获取安全模式状态信息 hdfs dfsadmin -safemode enter # 手动进入安全模式 hdfs dfsadmin -safemode leave # 手动离开安全模式 \"]},\"871\":{\"h\":\"3. HDFS高阶优化方案\"},\"872\":{\"h\":\"3.1. 短路本地读取\",\"t\":[\"当DFSClient与数据在同一个机器上时，让DFSClient绕开Datanode自己去读取数据\",\"实现思想：\",\"在Linux中，有个技术叫做Unix Domain Socket。Unix Domain Socket是一种进程间的通讯方式，它使得同一个机器上的两个进程能以Socket的方式通讯。\",\"它带来的另一大好处是，利用它两个进程除了可以传递普通数据外，还可以在进程间传递文件描述符。\",\"借助Unix Domain Socket，可以让A打开文件得到一个文件描述符，然后把文件描述符传递给B，B就能读取文件里面的内容了即使它没有相应的权限。\",\"在HDFS的场景里面，A就是Datanode，B就是DFSClient，需要读取的文件就是Datanode数据目录中的某个文件\",\"短路本地读取\",\"实现步骤：\",\"因为Java不能直接操作Unix Domain Socket，所以需要安装Hadoop的native包libhadoop.so。在编译Hadoop源码的时候可以通过编译native模块获取。可以用hadoop checknative来检查native包是否安装好。\",\"dfs.client.read.shortcircuit 是打开短路本地读取功能的开关\",\"dfs.domain.socket.path 是Datanode和DFSClient之间沟通的Socket的本地路径。\",\"# hdfs-site.xml <property> <name>dfs.client.read.shortcircuit</name> <value>true</value> </property> <property> <name>dfs.domain.socket.path</name> <value>/var/lib/hadoop-hdfs/dn_socket</value> </property> \",\"创建本地路径：mkdir -p /var/lib/hadoop-hdfs（注意不包含dn_socket）\",\"通过datanode的日志查看是否配置完成/logs/...，搜索关键词UNIX domain socket\"]},\"873\":{\"h\":\"3.2. HDFS Block负载平衡器：Balancer\",\"t\":[\"所谓的平衡指的是每个DataNode的利用率（本机已用空间与本机总容量之比）与集群的利用率（HDFS整体已用空间与HDFS集群总容量的比）之间相差不超过给定阈值百分比\",\"注意：负载平衡器无法在单个DataNode上的各个卷（磁盘）之间进行平衡，将通过磁盘均衡器来实现\",\"实现步骤：\",\"设置平衡数据传输带宽\",\"hdfs dfsadmin -setBalancerBandwidth newbandwidth\",\"其中newbandwidth是每个DataNode在平衡操作期间可以使用的最大网络带宽量，以每秒字节数为单位。\",\"例如：hdfs dfsadmin -setBalancerBandwidth 104857600（100M）\",\"运行balancer\",\"默认参数运行：hdfs balancer\",\"指定参数运行：hdfs balancer -thresholod 5 将以阈值5%运行，默认为10%\",\"这意味着程序将确保每个DataNode上的磁盘使用量与群集中的总体使用量相差不超过5％\"]},\"874\":{\"h\":\"3.3. 磁盘均衡器：HDFS Disk Balancer（3.0）\",\"t\":[\"HDFS disk balancer是Hadoop 3中引入的命令行工具，用于平衡DataNode中的数据在磁盘之间分布不均匀问题\",\"实现思想：\",\"卷（磁盘）数据密度：比较同台机器上不同卷之间的数据分布情况。\",\"计算方法：\",\"Total Used / Total Capacity - Disk Used / Disk Capacity\",\"节点数据密度：比较的是不同机器之间的。\",\"该节点上所有volume data density卷（磁盘）数据密度绝对值的总和\",\"较低的node Data Density值表示该机器节点具有较好的扩展性，而较高的值表示节点具有更倾斜的数据分布。一旦有了volume Data Density和node Data Density，就可以找到集群中数据分布倾斜的节点和机器上数据分步倾斜的磁盘。（先通过node Data Density确定哪个节点不平衡，再通过volume Data Density对具体的卷实施操作）\",\"实现步骤（百度）：\",\"默认情况下，Hadoop群集上已经启用了Disk Balancer功能。通过在hdfs-site.xml中调整dfs.disk.balancer.enabled参数值，选择在Hadoop中是否启用磁盘平衡器。\"]},\"875\":{\"h\":\"3.4. 纠删码技术（Erasure Coding)（3.0）\",\"t\":[\"纠删码技术（Erasure coding）简称EC，是一种编码容错技术。最早用于通信行业，数据传输中的数据恢复。它通过对数据进行分块，然后计算出校验数据，使得各个部分的数据产生关联性。当一部分数据块丢失时，可以通过剩余的数据块和校验块计算出丢失的数据块。\",\"出现背景：3副本存储的弊端\",\"里德所罗门（Reed-Solomon）码数学原理：\",\"k个数据块组成一个向量被乘上一个生成矩阵（Generator Matrix）GT从而得到一个码字（codeword）向量，该向量由k个数据块（d0,d1..d3）和m个校验块（c0,c1）构成。\",\"如果数据块丢失，可以用GT逆矩阵乘以码字向量来恢复出丢失的数据块。\",\"比如有 7、8、9 三个原始数据，通过矩阵乘法，计算出来两个校验数据 50、122\",\"一共五个数据：7、8、9、50、122，可以任意丢两个，然后通过算法进行恢复\",\"Hadoop EC架构（为了支持纠删码，HDFS体系结构进行的调整）\",\"Namenode扩展\",\"条带化的HDFS文件在逻辑上由block group（块组）组成，每个块组包含一定数量的内部块。这允许在块组级别而不是块级别进行文件管理。\",\"客户端扩展\",\"客户端的读写路径得到了增强，可以并行处理块组中的多个内部块\",\"Datanode扩展\",\"DataNode运行一个附加的ErasureCodingWorker（ECWorker）任务，以对失败的纠删编码块进行后台恢复。 NameNode检测到失败的EC块，然后NameNode选择一个DataNode进行恢复工作。\",\"纠删编码策略\",\"为了适应异构的工作负载，允许HDFS群集中的文件和目录具有不同的复制和纠删码策略。纠删码策略封装了如何对文件进行编码/解码。默认情况下启用RS-6-3-1024k策略， RS表示编码器算法Reed-Solomon，6 、3中表示数据块和奇偶校验块的数量，1024k表示条带化单元的大小。\",\"目录上还支持默认的REPLICATION方案。它只能在目录上设置，以强制目录采用3倍复制方案，而不继承其祖先的纠删码策略。此策略可以使3x复制方案目录与纠删码目录交错。REPLICATION始终处于启用状态。\",\"此外也支持用户通过XML文件定义自己的EC策略，Hadoop conf目录中有一个名为user_ec_policies.xml.template的示例EC策略XML文件，用户可以参考该文件。\",\"Intel ISA-L\",\"英特尔ISA-L代表英特尔智能存储加速库。 加速纠删码的编码和解码。\",\"EC编码部署方式\",\"集群和硬件配置\",\"编码和解码工作会消耗HDFS客户端和DataNode上的额外CPU。\",\"纠删码文件也分布在整个机架上，以实现机架容错。这意味着在读写条带化文件时，大多数操作都是在机架上进行的。因此，网络带宽也非常重要。\",\"对于机架容错，拥有足够数量的机架也很重要，每个机架所容纳的块数不超过EC奇偶校验块的数。机架数量=（数据块+奇偶校验块）/奇偶校验块后取整。\",\"比如对于EC策略RS（6,3），这意味着最少3个机架（由（6 + 3）/ 3 = 3计算），理想情况下为9个或更多，以处理计划内和计划外的停机。对于机架数少于奇偶校验单元数的群集，HDFS无法维持机架容错能力，但仍将尝试在多个节点之间分布条带化文件以保留节点级容错能力。因此，建议设置具有类似数量的DataNode的机架。\",\"纠删码策略设置\",\"纠删码策略由参数dfs.namenode.ec.system.default.policy指定，默认是RS-6-3-1024k，其他策略默认是禁用的。\",\"可以通过hdfs ec [-enablePolicy -policy <policyName>]命令启用策略集。\",\"启用ISA-L（见下方）\",\"EC命令\",\"hdfs ec\",\"[-setPolicy -path <path> [-policy <policy>] [-replicate]] #在指定路径的目录上设置擦除编码策略。 #path：HDFS中的目录。这是必填参数。设置策略仅影响新创建的文件，而不影响现有文件。 #policy：用于此目录下文件的擦除编码策略。默认RS-6-3-1024k策略。 #-replicate在目录上应用默认的REPLICATION方案，强制目录采用3x复制方案。replicate和-policy <policy>是可 选参数。不能同时指定它们。 [-getPolicy -path < path >] #获取指定路径下文件或目录的擦除编码策略的详细信息。 [-unsetPolicy -path < path >] #取消设置先前对目录上的setPolicy的调用所设置的擦除编码策略。如果该目录从祖先目录继承了擦除编码策略，则unsetPolicy是no-op。在没有显式策略集的目录上取消策略将不会返回错误。 [-listPolicies] #列出在HDFS中注册的所有（启用，禁用和删除）擦除编码策略。只有启用的策略才适合与setPolicy命令一起使用。 [-addPolicies -policyFile <文件>] #添加用户定义的擦除编码策略列表。[-listCodecs] #获取系统中支持的擦除编码编解码器和编码器的列表。 [-removePolicy -policy <policyName>] #删除用户定义的擦除编码策略。 [-enablePolicy -policy <policyName>] #启用擦除编码策略。[-disablePolicy -policy <policyName>] #禁用擦除编码策略。 \"]},\"876\":{\"h\":\"Hadoop纠删码算法启用ISA-L加速库\",\"t\":[\"版本\",\"软件\",\"版本\",\"Hadoop\",\"3.1.4\",\"isa-l\",\"2.28.0\",\"nasm\",\"2.14.02\",\"yasm\",\"1.2.0\",\"1、安装yasm和nasm\",\"#在Hadoop集群所有节点上安装yasm和nasm。 yum install -y yasm yum install -y nasm #注意：isa-l-2.28.0对nasm和yasm有版本要求，低版本在安装时会报错。 \",\"2、编译安装isa-l-2.28.0\",\"#在Hadoop集群所有节点上编译安装isa-l-2.28.0。 tar -zxvf isa-l-2.28.0.tar.gz cd isa-l-2.28.0 ./autogen.sh ./configure --prefix=/usr --libdir=/usr/lib64 make make install make -f Makefile.unx #检查libisal.so*是否成功 ll /lib64/libisal.so* ############如果有，则跳过############## ############如果没有有，则复制############## cp bin/libisal.so bin/libisal.so.2 /lib64 \",\"3、Hadoop上检查是否启用isa-l\",\"Native library checking: hadoop: true /usr/hdp/3.0.0.0-1634/hadoop/lib/native/libhadoop.so.1.0.0 zlib: true /lib64/libz.so.1 zstd : false snappy: true /usr/hdp/3.0.0.0-1634/hadoop/lib/native/libsnappy.so.1 lz4: true revision:10301 bzip2: true /lib64/libbz2.so.1 openssl: true /lib64/libcrypto.so ISA-L: true /lib64/libisal.so.2 -------------> Shows that ISA-L is loaded. \"]},\"877\":{\"h\":\"4. HDFS动态节点管理\"},\"878\":{\"h\":\"4.1. 节点扩容\",\"t\":[\"已有HDFS集群容量已不能满足存储数据的需求，需要在原有集群基础上动态添加新的DataNode节点。\",\"新机器基础环境准备\",\"主机名、IP\",\"vim /etc/sysconfig/network-scripts/ifcfg-ens33\",\"设置IPADDR\",\"vim /etc/hostname\",\"设置node4\",\"Hosts映射\",\"vim /etc/hosts\",\"设置IPADDR与Hostname之间的映射\",\"防火墙、时间同步\",\"systemctl stop firewalld.service：关闭当下\",\"systemctl disable firewalld.service：永久关闭\",\"ntpdate ntp4.aliyun.com：时间同步\",\"SSH免密登录\",\"[root@node1 ~]# ssh -copy-id node4：复制公钥到新机器\",\"JDK环境\",\"Hadoop配置\",\"修改workers配置文件，方便一键启停\",\"vim /export/server/hadoop-3.1.4/etc/hadoop/workers\",\"从namenode节点复制hadoop安装包到新节点，注意不包括hadoop.tmp.dir指定的数据存储目录\",\"[root@node1 server]# scp -r hadoop-3.1.4 node4:$PWD\",\"新机器上配置hadoop环境变量\",\"vim /etc/profile，可以将Namenode 的profile文件拷贝到node4\",\"注意需要创建短路本地读取的文件夹，否则会报错，具体报错可以去logs里面查看\",\"手动启动DataNode进程\",\"hdfs --daemon start datanode\",\"具体是否启动可以去Web页面查看，或者jps命令获取相关进程\",\"DataNode负载均衡服务\",\"hdfs dfsadmin -setBalancerBandwidth 104857600：设置负载均衡的带宽\",\"hdfs balancer -threshold 5：设置偏差为5%\"]},\"879\":{\"h\":\"4.2. 动态缩容\",\"t\":[\"服务器需要进行退役更换，需要在当下的集群中停止某些机器上datanode的服务\",\"添加退役节点（该操作node2，node3不需要参与，即不需要拷贝该文件）\",\"在namenode机器的hdfs-site.xml中配置dfs.hosts.exclude属性（黑名单）\",\"<property> <name>dfs.hosts.exclude</name> <value>/export/server/hadoop-3.1.4/etc/hadoop/excludes</value> </property> \",\"excludes文件中的节点就是被禁止的节点\",\"该属性（dfs.hosts.exclude）需要在namenode启动前配置，否则只能重启机器\",\"当副本为3，服役的节点也是3，则不能退役成功\",\"// excludes node4 \",\"刷新集群\",\"[root@node1 ~]# hdfs dfsadmin -refreshNodes等待节点迁移数据后退役\",\"手动关闭DataNode进程\",\"[root@node4 ~]# hdfs --daemon stop datanode\",\"DataNode负载均衡服务\",\"hdfs balancer -threshold 5\"]},\"880\":{\"h\":\"4.3. 黑白名单机制\",\"t\":[\"白名单\",\"允许哪些机器加入到当前的HDFS集群中，是一种准入机制\",\"由dfs.hosts参数指定，该参数位于hdfs-site.xml。默认值为空\",\"dfs.hosts指向文件，该文件包含允许连接到namenode的主机列表。必须指定文件的完整路径名。如果该值为空，则允许所有主机准入。\",\"黑名单\",\"禁止哪些机器加入到当前的HDFS集群中，是一种禁入机制。\",\"由dfs.hosts.exclude参数指定，该参数位于hdfs-site.xml。默认值为空。\",\"dfs.hosts.exclude指向文件，该文件包含不允许连接到名称节点的主机列表。必须指定文件的完整路径名。如果该值为空，则不禁止任何主机加入。\"]},\"881\":{\"h\":\"5. HDFS HA高可用\"},\"882\":{\"h\":\"5.1 背景知识\",\"t\":[\"单点故障（single point of failure SPOF），系统中某个点故障，导致整个系统不可用\",\"解决单点故障\",\"目的是为了让故障对业务的影响最小，而不是让故障用不发生\",\"给单点故障设置备份，形成主备架构\",\"集群可用性评判标准（x个9）\",\"X个9表示在系统1年时间的使用过程中，系统可以正常使用时间与总时间（1年）之比\",\"比如4个9：(1-99.99%)36524=0.876小时=52.6分钟，表示该系统在连续运行1年时间里最多可能的业务中断时间是52.6分钟\",\"9越多，系统的可靠性越强，能够容忍的业务中断时间越少，但是要付出的成本更高\",\"HA系统设计核心问题\",\"对于HA的解决方案，都要考虑到这两点\",\"脑裂问题\",\"集群无主：都认为对方状态是好的，自己是备份角色，后果是无服务\",\"集群多主：都是为对方是故障的， 自己是主角色，导致系统混乱，数据损坏。\",\"为此，保持任意时刻系统有且只有一个主角色提供服务\",\"数据状态同步问题\",\"主备节点之间，数据状态不同步\",\"为此，可以采用日志重演操作记录，让从角色通过主角色的修改日志记录重演修改操作\"]},\"883\":{\"h\":\"5.2 NameNode单点故障问题\",\"t\":[\"HDFS的单点故障问题指的是NameNode单点故障。对于DataNode出现了故障，因为有冗余副本存储或者EC编码技术，当某个DataNode出现问题时，并不影响整体系统的运行。若NameNode出现了故障，则整个集群不可用，就像删除了索引，虽然有文件，但是找不到问题的具体存放位置。\",\"解决方法：在同一群集中运行两个（从3.0.0起，支持超过两个）冗余NameNode。形成主备架构。\"]},\"884\":{\"h\":\"5.3 HDFS HA解决方案--QJM\",\"t\":[\"QJM全称Quorum Journal Manager（仲裁日志管理器），是Hadoop官方推荐的HDFS HA解决方案之一\",\"使用zookeeper中ZKFC来实现主备切换；（解决脑裂问题）\",\"使用Journal Node（JN）集群实现edits log的共享以达到数据同步的目的。（解决数据同步问题）\",\"image-20210721173527315\"]},\"885\":{\"h\":\"ZK Failover Controller（ZKFC）\",\"t\":[\"监视和管理NameNode健康状态\",\"维持和ZK群联系：\",\"如果本地NameNode运行状况良好，并且ZKFC看到当前没有其他节点持有锁znode，它将自己尝试获取该锁。如果成功，则表明它“赢得了选举”，并负责运行故障转移以使其本地NameNode处于Active状态。如果已经有其他节点持有锁，zkfc选举失败，则会对该节点注册监听，等待下次继续选举。\",\"image-20210721173918912\",\"脑裂问题的解决\",\"通过Fencing机制来避免，将先前的Active节点隔离，然后将Standby转换为Active状态\",\"Hadoop对于Fencing提供了两种实现\",\"sshfench\",\"通过ssh登录目标节点，使用命令fuser将进程杀死（通过tcp端口号定位进程pid，该方法比jps更准确）\",\"shellfench\"]},\"886\":{\"h\":\"Journal Node（JN）\",\"t\":[\"Journal Node（JN）集群是轻量级分布式系统，主要用于高速读写数据、存储数据\",\"使用2N+1台JournalNode存储共享Edits Log（编辑日志）\",\"任何修改操作在Active Node上进行，JN进程也会同时记录edits log到至少半数的JN中\",\"Standby Node检测到JN 里面的同步log发生变化了会读取JN里面的edits log，然后重演操作记录同步到自己的目录镜像树里面。\"]},\"887\":{\"h\":\"6. HDFS Federation联邦机制\"},\"888\":{\"h\":\"6.1 当前HDFS体系架构\",\"t\":[\"命名空间：由文件，块和目录组成的统一抽象的目录树结构。\",\"块存储层 \",\"**块管理：**NameNode执行块管理。块管理通过处理注册和定期心跳来提供DataNode群集成员身份。它处理块报告并支持与块相关的操作，如创建，删除，修改或获取块位置。它还维护块的位置，副本位置。为未复制的块管理块复制，并在已复制的块中删除。\",\"**块存储：**DataNode通过在本地文件系统上存储块并提供读/写访问权限来管理存储空间。\",\"当前体系结构的弊端：\",\"扩展困难\",\"单个NameNode的吞吐量决定了集群的性能\",\"集群占有组织之间没有隔离\"]},\"889\":{\"h\":\"6.2 联邦Federation架构\",\"t\":[\"Federation中文意思为联邦,联盟，是NameNode之间的Federation,也就是集群中会有多个NameNode。多个NameNode的情况意味着有多个namespace。注意，这区别于HA模式下的多NameNode，HA中它们是拥有着同一个namespace。\",\"Federation体系中多个namenode之间相互独立且不需要互相协调，各自分工，管理自己的区域。每个DataNode要向集群中所有的namenode注册，且周期性地向所有namenode发送心跳和块报告，并执行来自所有namenode的命令。\",\"image-20210722132212837\",\"优点\",\"命名空间可伸缩性\",\"提高集群性能\",\"不同占有者组织之间对于NameNode是隔离的\"]},\"890\":{\"h\":\"7. HDFS集群滚动升级\",\"t\":[\"升级的时候依然向外提供服务。注意必须是HA集群，否则无法实现\"]},\"891\":{\"h\":\"8. HDFS集群滚动降级\"},\"892\":{\"h\":\"8.1. 降级和回滚的区别\",\"t\":[\"共同点\",\"退回之前版本\",\"在升级的finalize执行后，不允许再执行降级和回滚\",\"不同点\",\"降级可以滚动降级，不需要停机，回滚需要停机\",\"降级会保留现有的数据状态，回滚不会\"]},\"893\":{\"h\":\"HDFS 架构原理\"},\"894\":{\"h\":\"1. HDFS架构剖析\",\"t\":[\"略\"]},\"895\":{\"h\":\"2. HDFS Web Interfaces\",\"t\":[\"略\"]},\"896\":{\"h\":\"3. HDFS读写流程\"},\"897\":{\"h\":\"3.1 HDFS写数据流程\"},\"898\":{\"h\":\"Pipeline管道\",\"t\":[\"客户端将数据块写入第一个数据节点，第一个数据节点保存数据之后再将块复制到第二个数据节点，后者保存后将其复制到第三个数据节点\",\"为什么datanode之间采用pipeline线性传输，而不是一次给三个datanode拓扑式传输呢？\",\"因为数据以管道的方式，顺序的沿着一个方向传输，这样能够充分利用每个机器的带宽，避免网络瓶颈和高延迟时的连接，最小化推送所有数据的延时。在线性推送模式下，每台机器所有的出口宽带都用于以最快的速度传输数据，而不是在多个接受者之间分配宽带。\"]},\"899\":{\"h\":\"ACK应答响应\",\"t\":[\"ACK (Acknowledge character）即是确认字符，在数据通信中，接收方发给发送方的一种传输类控制字符。表示发来的数据已确认接收无误。\"]},\"900\":{\"h\":\"默认三副本存储策略\",\"t\":[\"默认副本存储策略是由BlockPlacementPolicyDefault指定\",\"第一块副本：客户端就是一个datanode的话优先客户端本地，否则随机\",\"第二块副本：不同于第一块副本的不同机架。\",\"第三块副本：第二块副本相同机架不同机器。\"]},\"901\":{\"h\":\"写流程\",\"t\":[\"HDFS客户端创建FileSystem对象实例DistributedFileSystem， FileSystem封装了与文件系统操作的相关方法。\",\"调用DistributedFileSystem对象的create()方法，通过RPC请求NameNode创建文件。NameNode执行各种检查判断：目标文件是否存在、父目录是否存在、客户端是否具有创建该文件的权限。检查通过NameNode就会为本次请求记下一条记录，返回FSDataOutputStream输出流对象给客户端用于写数据。\",\"客户端通过FSDataOutputStream开始写入数据。FSDataOutputStream是DFSOutputStream包装类。\",\"客户端写入数据时，DFSOutputStream将数据分成一个个数据包（packet默认64k）,并写入一个内部数据队列（data queue）。（DFSOutputStream有一个内部类做DataStreamer，用于请求NameNode挑选出适合存储数据副本的一组DataNode，默认是3副本存储。DataStreamer将数据包流式传输到pipeline的第一个DataNode,该DataNode存储数据包并将它发送到pipeline的第二个DataNode。同样，第二个DataNode存储数据包并且发送给第三个（也是最后一个）DataNode。）\",\"DFSOutputStream也维护着一个内部数据包队列来等待DataNode的收到确认回执，称之为确认队列（ackqueue）,收到pipeline中所有DataNode确认信息后，该数据包才会从确认队列删除。\",\"客户端完成数据写入后，在FSDataOutputStream输出流上调用close()方法关闭。\",\"DistributedFileSystem联系NameNode告知其文件写入完成，等待NameNode确认。因为namenode已经知道文件由哪些块组成（DataStream请求分配数据块），因此仅需等待最小复制块即可成功返回。（最小复制是由参数dfs.namenode.replication.min指定，默认是1）\"]},\"902\":{\"h\":\"3.2 HDFS读数据流程\",\"t\":[\"HDFS客户端创建FileSystem对象实例DistributedFileSystem， FileSystem封装了与文件系统操作的相关方法。调用DistributedFileSystem对象的open()方法来打开希望读取的文件。\",\"DistributedFileSystem使用RPC调用namenode来确定文件中前几个块的块位置（分批次读取）信息。\",\"对于每个块，namenode返回具有该块所有副本的datanode位置地址列表，并且该地址列表是排序好的，与客户端的网络拓扑距离近的排序靠前。\",\"DistributedFileSystem将FSDataInputStream输入流返回到客户端以供其读取数据。FSDataInputStream类是DFSInputStream类的包装。\",\"客户端在FSDataInputStream输入流上调用read()方法。然后，已存储DataNode地址的DFSInputStream连接到文件中第一个块的最近的DataNode。数据从DataNode流回客户端，结果客户端可以在流上重复调用read（）。\",\"当该块结束时，DFSInputStream将关闭与DataNode的连接，然后寻找下一个块的最佳datanode。这些操作对用户来说是透明的。所以用户感觉起来它一直在读取一个连续的流。客户端从流中读取数据时，也会根据需要询问NameNode来检索下一批数据块的DataNode位置信息。\",\"一旦客户端完成读取，就对FSDataInputStream调用close()方法。\"]},\"903\":{\"h\":\"3.3 HDFS集群角色职责\",\"t\":[\"NameNode职责\",\"NameNode是HDFS的核心，集群的主角色，被称为Master。\",\"NameNode仅存储管理HDFS的元数据：文件系统namespace操作维护目录树，文件和块的位置信息。\",\"NameNode不存储实际数据或数据集。数据本身实际存储在DataNodes中。\",\"NameNode知道HDFS中任何给定文件的块列表及其位置。使用此信息NameNode知道如何从块中构建文件。\",\"NameNode并不持久化存储每个文件中各个块所在的DataNode的位置信息，这些信息会在系统启动时从DataNode汇报中重建。\",\"NameNode对于HDFS至关重要，当NameNode关闭时，HDFS / Hadoop集群无法访问。\",\"NameNode是Hadoop集群中的单点故障。\",\"NameNode所在机器通常会配置有大量内存（RAM）。\",\"DataNode职责\",\"DataNode负责将实际数据存储在HDFS中。是集群的从角色，被称为Slave。\",\"DataNode启动时，它将自己发布到NameNode并汇报自己负责持有的块列表。\",\"根据NameNode的指令，执行块的创建、复制、删除操作。\",\"DataNode会定期（dfs.heartbeat.interval配置项配置，默认是3秒）向NameNode发送心跳，如果NameNode长时间没有接受到DataNode发送的心跳， NameNode就会认为该DataNode失效。\",\"DataNode会定期向NameNode进行自己持有的数据块信息汇报，汇报时间间隔取参数dfs.blockreport.intervalMsec,参数未配置的话默认为6小时.\",\"DataNode所在机器通常配置有大量的硬盘空间。因为实际数据存储在DataNode中。\"]},\"904\":{\"h\":\"4. NameNode元数据管理\"},\"905\":{\"h\":\"4.1 元数据管理综述\",\"t\":[\"元数据类型\",\"文件自身属性信息：文件名称、权限，修改时间，文件大小，复制因子，数据块大小。\",\"文件块位置映射信息：记录文件块和DataNode之间的映射信息，即哪个块位于哪个节点上。\",\"元数据按存储形式分类\",\"内存元数据\",\"元数据文件 \",\"fsimage内存镜像文件\",\"Edits log编辑日志\"]},\"906\":{\"h\":\"5. HDFS小文件解决方案\",\"t\":[\"通过下述实现：\",\"Hadoop Archive文件归档\",\"Sequence File序列化文件\"]},\"907\":{\"h\":\"HDFS 数据安全与隐私保护\"},\"908\":{\"h\":\"1. HDFS Trash垃圾桶\",\"t\":[\"该概念就和Windows的垃圾桶一样，默认不开启\"]},\"909\":{\"h\":\"1.1 功能描述\",\"t\":[\"启用Trash功能后，从HDFS中删除某些内容时，文件或目录不会立即被清除，它们将被移动到回收站Current目录中**(/user/${username}/.Trash/current)**。\",\"最近删除的文件被移动到回收站Current目录，并且在可配置的时间间隔内，HDFS会为在Current回收站目录下的文件创建检查点/user/${username}/.Trash/<日期>，并在过期时删除旧的检查点。\"]},\"910\":{\"h\":\"1.2 功能开启\",\"t\":[\"关闭hdfs集群：stop-dfs.sh\",\"修改core-site.xml\",\"<property> <!-- 回收站中的文件多少分钟后会被系统永久删除。如果为零，Trash功能将被禁用。--> <name>fs.trash.interval</name> <value>1440</value> </property> <property> <!-- 前后两次检查点的创建时间间隔（单位也是分钟） 新的检查点被创建后，随之旧的检查点就会被系统永久删除。 如果为零，则将该值设置为fs.trash.interval的值。 --> <name>fs.trash.checkpoint.interval</name> <value>0</value> </property> \",\"同步集群（此时在/export/server/hadoop-3.1.4/etc/hadoop目录下）\",\"[root@node1 hadoop]# scp -r core-site.xml node2:$PWD [root@node1 hadoop]# scp -r core-site.xml node2:$PWD \",\"重启集群：start-dfs.sh\",\"操作时和正常删除操作一样，通过-skipTrash来跳过垃圾桶直接永久删除\",\"hadoop fs -rm [-skipTrash] /tmp/1.txt\",\"HDFS提供了一个命令行工具来完成这个工作：hadoop fs -expunge。该命令立即从文件系统中删除过期的检查点。\"]},\"911\":{\"h\":\"2. HDFS Snapshot快照\",\"t\":[\"快照（Snapshot）是数据存储的某一时刻的状态记录。HDFS Snapshot快照是整个文件系统或某个目录在某个时刻的镜像。\"]},\"912\":{\"h\":\"2.1 快照的作用\",\"t\":[\"数据恢复：对重要目录进行创建snapshot的操作，当用户误操作时，可以通过snapshot来进行相关的恢复操作。\",\"数据备份：使用snapshot来进行整个集群，或者某些目录、文件的备份。管理员以某个时刻的snapshot作为备份的起始结点，然后通过比较不同备份之间差异性，来进行增量备份。\",\"数据测试：在某些重要数据上进行测试或者实验，可能会直接将原始的数据破坏掉。可以临时的为用户针对要操作的数据来创建一个snapshot，然后让用户在对应的snapshot上进行相关的实验和测试，从而避免对原始数据的破坏。\"]},\"913\":{\"h\":\"2.2 快照功能的理论实现\",\"t\":[\"HDFS快照不是数据的简单拷贝，只做差异的记录。\",\"对于大多不变的数据，你所看到的数据其实是当前物理路径所指的内容，而发生变更的inode数据才会被快照额外拷贝，也就是所说的差异拷贝。\",\"linode指索引节点，用来存放文件及目录的基本信息，包含时间、名称、拥有者、所在组等。\",\"并且快照只是记录一些元数据信息。\"]},\"914\":{\"h\":\"2.3 快照功能的命令实现\",\"t\":[\"目录开启快照功能（hdfs dfsadmin -allowSnapshot /vingkin）\",\"没有启动快照功能的目录创建快照会报错\",\"目录禁用快照功能（hdfs dfsadmin -disallowSnapshot /vingkin）\",\"禁用的前提是该目录的所有快照已经被删除\",\"创建快照（hdfs dfs -createSnapshot /vingkin [mysnap1]）\",\"可以指定具体的快照名，如果不指定则默认以时间等相关数据命名\",\"查看创建的快照（hdfs lsSnapshottableDir）\",\"还可以通过Web UI页面直接查看快照信息，并可以在Web UI的目录页面手动输入/vingkin/.snapshot来查看隐藏文件\",\"比较不同快照的差异（hdfs snapshotDiff /vingkin mysnap1 mysnap2）\",\"+表示增加了文件，M表示文件做了修改...\",\"删除快照（hdfs dfs -deleteSnapshot /vingkin mysnap1）\",\"快照重命名（hdfs dfs -renameSnapshot /vingkin mysnap1 mysnap2）\",\"将mysnap1重命名为mysnap2\",\"注意：拥有快照的目录不允许被删除\"]},\"915\":{\"h\":\"3. HDFS权限管理\"},\"916\":{\"h\":\"3.1 AAA\",\"t\":[\"认证（Authentication）、**授权（Authorization）和审计（Accounting）**指计算机安全领域的一个架构模式。通常缩写为 AAA。\",\"在该模式中，使用服务的用户先要证明自己的身份；然后根据规则被授予权限，同时其操作被记录下来留待审计。\",\"作为分布式文件系统，HDFS也集成了一套权限管理系统。客户端在进行每次文件操时，系统会从用户身份认证和数据访问授权两个环节进行验证。\"]},\"917\":{\"h\":\"3.2 UGO权限管理\",\"t\":[\"HDFS文件权限与Linux/Unix系统的UGO模型类似，简单描述为：每个文件和目录都与一个拥有者和一个组相关联。\",\"USER（文件的所有者）：一般是创建该文件的用户，对该文件具有完全的权限。\",\"GROUP（拥有者所在的组）：和文件所有者属于同一组的用户。\",\"OTHER（其他用户组）：其他用户组的用户。\"]},\"918\":{\"h\":\"3.2.1 读、写、执行权限\",\"t\":[\"HDFS文件权限也细分为：读权限（r）、写权限（w）、执行权限（x）。\",\"在HDFS中，对于文件，需要r权限才能读取文件，而w权限才能写入或追加到文件。没有x可执行文件的概念。\",\"在HDFS中，对于目录，需要r权限才能列出目录的内容，需要w权限才能创建或删除文件或目录，并且需要x权限才能访问目录的子级。\"]},\"919\":{\"h\":\"3.2.2 umask权限掩码\",\"t\":[\"HDFS也提供了umask掩码，用于设置在HDFS中新建的文件和目录的默认权限。\",\"默认umask值有属性fs.permissions.umask-mode指定，默认值022。\",\"创建文件和目录时使用的umask，默认的权限就是\",\"目录：777-022=755，也就是drwxr-xr-x\",\"文件：777-022=755，因为HDFS中文件没有x执行权限的概念，所以是：-rw-r--r--\",\"<property> <name>fs.permissions.umask-mode</name> <value>022</value> <final>false</final> <source>core-default.xml</source> </property> \"]},\"920\":{\"h\":\"3.2.3 UGO相关命令\",\"t\":[\"#变更目录或文件的权限 可以使用数字 也可以使用字母 u g o a + - r w x hadoop fs -chmod [-R] 777 /user/itcast/foo hadoop fs -chmod [-R] u+x,o-x /user/itcast/foo #变更目录或文件的属主或用户组 hadoop fs -chown [-R] itcast /user/itcast/foo hadoop fs -chown [-R] itcast:ogroup /user/itcast/foo #变更用户组 hadoop fs -chgrp [-R] group1 /user/itcast/foo \",\"**粘滞[nián zhì]位（Sticky bit）**用在目录上设置，如此以来，只有目录内文件的所有者或者root才可以删除或移动该文件。\",\"如果不为目录设置粘滞位，任何具有该目录写和执行权限的用户都可以删除和移动其中的文件\"]},\"921\":{\"h\":\"3.3 HDFS用户身份认证\",\"t\":[\"HDFS项目本身并没有用户身份认证，通过相关接口从主机获取相关用户身份，然后用于后续的权限管理。\",\"Simple（默认）\",\"Kerberos\"]},\"922\":{\"h\":\"3.3.1 Simple认证\",\"t\":[\"客户端与NN进行交互时，会用基于HDFS客户端所在的Linux/Unix系统的登录用户名来进行认证。只要用户能正常登录就认证成功。\",\"存在的问题：\",\"多用户使用一个客户端会导致权限混淆\",\"恶意用户可以进行身份伪造从而非法获取相应的权限\",\"防止好人误做坏事，不防止坏人做坏事\"]},\"923\":{\"h\":\"3.3.2 Kerberos认证\",\"t\":[\"Kerberos是麻省理工学院（MIT）开发的一种网络身份认证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。也就是AAA的第一个A。\",\"Kerberos所具有的角色：\",\"访问服务的Client\",\"提供服务的Server\",\"KDC（Key Distribution Center）密钥分发中心\",\"域的概念：\",\"域的产生是为了解决企业内部的资源管理问题，比如一个公司就可以在网络中建立一个域环境，更方便内部的资源管理。在一个域中有域控、域管理员、普通用户、主机等等各种资源。\",\"YUNYING.LAB为其他两个域的根域，NEWS.YUNYING.LAB和DEV.YUNYING.LAB均为YUNYING.LAB的子域，这三个域组成了一个域树。\",\"子域的概念可以理解为一个集团在不同业务上分公司，他们有业务重合的点并且都属于YUNYING.LAB这个根域，但又独立运作。同样TEST.COM也是一个单独的域树，两个域树YUNYING.LAB和TEST.COM组合起来被称为一个域林。\",\"KDC服务默认会安装在一个域的域控中\",\"具体认证过程：\",\"Authentication Server： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。\",\"Ticket Granting Server： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（上车的票ST）。ST（Service Ticket）也有资料称为TGS Ticket，为了和TGS区分，在这里就用ST来说明。\"]},\"924\":{\"h\":\"3.4 HDFS Group Mapping组映射\",\"t\":[\"HDFS在获取用户名后还需要获取该用户所在的组。一般来说，HDFS中用户所属组的确认工作需要通过外部的用户组映射（Group Mapping）服务来获取。\",\"Linux/Unix系统上的用户和用户组信息存储在/etc/passwd和/etc/group文件中。\",\"默认情况下，HDFS会通过调用外部的 Shell 命令来获取用户的所有用户组列表。\",\"/etc/passwd：（用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell）\",\"/etc/group：（组名：密码：GID：该用户组中的用户列表）\",\"此方案的优点在于组映射服务十分稳定，不易受外部服务的影响。\",\"但是用户和用户组管理涉及到root权限等，同时会在服务器上生成大量的用户组，后续管理，特别是自动化运维方面会有较大影响。\"]},\"925\":{\"h\":\"3.5 ACL权限管理\",\"t\":[\"对于一个文件或文件夹而言，通过UGO来给予不同的角色不同的权限。比如属主root具有权限rwx，属组具有权限rwx，其他用户无任何权限。对于一个新来的用户，如果想要授予r-x权限将无法满足。可以通过ACL（Access Control List）访问控制列表，为特定的用户或组设置不同的权限。\"]},\"926\":{\"h\":\"3.5.1 相关命令\",\"t\":[\"使用命令前需要设置相关参数并重启hdfs服务\",\"<property> <name>dfs.namenode.acls.enabled</name> <value>true</value> <final>false</final> <source>hdfs-site.xml</source> </property> \",\"# 为node1用户对于vingkin添加rwx权限 hadoop fs -setfacl -m user:node1:rwx /vingkin # 查看ACL权限 hadoop fs -getfacl /vingkin # 删除指定的ACL条目 hadoop fs -setfacl -x user:node1 /vingkin # 删除基本ACL条目以外的所有条目。保留用户，组和其他条目以与权限位兼容。（相当于回到没有设置ACL之前的样子） hadoop fs -setfacl -b /vingkin # 设置默认的ACl权限，以后在该目录中新建文件或者子目录时，新建的文件/目录的ACL权限都是之前设置的default ACLs hadoop fs -setfacl -m default:user:node1:rwx /vingkin # 删除默认ACL权限 hadoop fs -setfacl -k /vingkin \"]},\"927\":{\"h\":\"4. HDFS Proxy user代理用户\",\"t\":[\"一个用户（比如超级用户）代表另一个用户提交作业或访问HDFS，比如：用户名为“root”的超级用户代表用户vingkin提交作业并访问HDFS。\",\"例如：名为root的超级用户只能从host1和host2连接来模拟属于group1和group2的用户。\",\"<!-- core-site.xml --> <property> <name>hadoop.proxyuser.root.hosts</name> <value>host1,host2</value> </property> <property> <name>hadoop.proxyuser.root.groups</name> <value>group1,group2</value> </property> \",\"通配符*可用于允许来自任何主机或任何用户的模拟\",\"从任何主机访问的名为root的用户都可以假冒属于任何组的任何用户。\",\"<property> <name>hadoop.proxyuser.root.hosts</name> <value>*</value> </property> <property> <name>hadoop.proxyuser.root.groups</name> <value>*</value> </property> \"]},\"928\":{\"h\":\"5. HDFS透明加密\",\"t\":[\"对HDFS的指定目录进行透明加密，通过Web UI界面访问或者hadoop fs -cat访问仿佛就是未加密的文件，以为上面两种方法访问时实现了自动解密。通过直接产看块信息时是加密的。\"]},\"929\":{\"h\":\"5.1 相关概念\"},\"930\":{\"h\":\"加密区域\",\"t\":[\"所谓加密区域其实就是一个目录\"]},\"931\":{\"h\":\"密钥\",\"t\":[\"当加密区域被创建时，都会有一个加密区域秘钥（EZ密钥，encryption zone key）与之对应，EZ密钥存储在HDFS外部的密钥库中。\",\"加密区域里的每个文件都有其自己加密密钥，叫做数据加密秘钥（DEK，data encryption key）。\",\"DEK会使用其各自的加密区域的EZ密钥进行加密，以形成加密数据加密密钥（EDEK）。\"]},\"932\":{\"h\":\"密钥库\",\"t\":[\"存储密钥（key）的叫做密钥库（keystore）,将HDFS与外部企业级密钥库（keystore）集成是部署透明加密的第一步。\",\"与HDFS本身是分离的\"]},\"933\":{\"h\":\"密钥管理服务（KMS）\",\"t\":[\"Hadoop密钥管理服务（Key Management Server，简写KMS），用作HDFS客户端与密钥库之间的代理。\",\"主要职责：\",\"访问加密区域秘钥（EZ key）\",\"生成EDEK，EDEK存储在NameNode上\",\"为HDFS客户端解密EDEK\"]},\"934\":{\"h\":\"写入加密文件的过程\",\"t\":[\"提前动作：创建加密区，设置加密区密钥(EZ key)\",\"Client向NN请求在HDFS某个加密区新建文件\",\"NN从缓存中取出一个新的EDEK（后台不断从KMS拉取新的EDEK到缓存中）\",\"获取到EDEK会被NN保存到文件的元数据中\",\"然后NN将EDEK发送给Client\",\"Client发送EDEK给KMS，KMS用对应的EZ key将EDEK解密出DEK发送给Client(EDEK+EZ key -> DEK)\",\"Client用DEK加密文件内容发送给datanode进行存储(DEK + File -> Encrypted File)\",\"DEK是加解密一个文件的密匙，而KMS里存储的EZ key是用来加解密所有文件的密匙（DEK）的密匙。\",\"所以，EZ Key是更为重要的数据，只在KMS内部使用（DEK的加解密只在KMS内存进行），不会被传递到外面使用；\",\"而HDFS服务端只能接触到EDEK。\"]},\"935\":{\"h\":\"读取解密文件的过程\",\"t\":[\"读流程与写流程类型，区别就是NN直接读取加密文件元数据里的EDEK返回给客户端，客户端一样把EDEK发送给KMS获取DEK。再对加密内容解密读取。\",\"EDEK的加密和解密完全在KMS上进行。更重要的是，请求创建或解密EDEK的客户端永远不会处理EZ密钥。仅KMS可以根据要求使用EZ密钥创建和解密EDEK。\"]},\"936\":{\"h\":\"5.2 KMS配置\",\"t\":[\"关闭HDFS集群\",\"创建keystore：keytool -genkey -alias 'vinkgin_keystore'\",\"配置kms.site.xml\",\"<configuration> <property> <name>hadoop.kms.key.provider.uri</name> <value>jceks://file@/${user.home}/kms.jks</value> </property> <property> <name>hadoop.security.keystore.java-keystore-provider.password-file</name> <value>kms.keystore.password</value> <!-- kms.keystore.password需在当前目录自己创建，内容就是keystore设置的密码 --> </property> <property> <name>dfs.encryption.key.provider.uri</name> <value>kms://http@node1:16000/kms</value> </property> <property> <name>hadoop.kms.authentication.type</name> <value>simple</value> </property> </configuration> \",\"kms-env.sh\",\"export KMS_HOME=/export/server/hadoop-3.1.4 export KMS_LOG=${KMS_HOME}/logs/kms export KMS_HTTP_PORT=16000 export KMS_ADMIN_PORT=16001 \",\"core-site.xml\",\"<property> <name>hadoop.security.key.provider.path</name> <value>kms://http@node1:16000/kms</value> </property> \",\"hdfs-site.xml\",\"<property> <name>dfs.encryption.key.provider.uri</name> <value>kms://http@node1:16000/kms</value> </property> \",\"同步配置文件\",\"cd /export/server/hadoop-3.1.4/etc/hadoop、 scp core-site.xml hdfs-site.xml kms-site.xml kms-env.sh node2:/export/server/hadoop-3.1.4/etc/hadoop/ scp core-site.xml hdfs-site.xml kms-site.xml kms-env.sh node3:/export/server/hadoop-3.1.4/etc/hadoop/ \",\"启动KMS：hadoop --daemon start kms\",\"创建EZ key：hadoop key create ezk\",\"创建一个目录，并设置为加密区\",\"hadoop fs -mkdir /zone hdfs crypto -createZone -keyName ezk -path /zone \"]},\"937\":{\"h\":\"HDFS 源码分析\"},\"938\":{\"h\":\"TODO\"},\"939\":{\"h\":\"YARN 框架概述\"},\"940\":{\"h\":\"1. YARN架构体系\"},\"941\":{\"h\":\"1.1 官方架构图\",\"t\":[\"官方架构图\"]},\"942\":{\"h\":\"1.2 核心交互流程\",\"t\":[\"MR作业状态汇报 Container（Map|Reduce Task）-->Container（MrAppMaster）\",\"MR作业提交 Client-->RM\",\"节点的状态汇报 NM-->RM\",\"资源的申请 MrAppMaster-->RM\"]},\"943\":{\"h\":\"2. YARN组件及功能\"},\"944\":{\"h\":\"2.1 三大组件\",\"t\":[\"组件名\",\"功能\",\"ResourceManager(RM)\",\"YARN集群中的主角色，决定系统中所有应用程序之间资源分配的最终权限，即最终仲裁者。接收用户的作业提交，并通过NM分配、管理各个机器上的计算资源。\",\"NodeManager(NM)\",\"YARN中的从角色，一台机器上一个，负责管理本机器上的计算资源。根据RM命令，启动Container容器、监视容器的资源使用情况。并且向RM主角色汇报资源使用情况。\",\"ApplicationMaster(AM)\",\"用户提交的每个应用程序均包含一个AM。应用程序内的“老大”，负责程序内部各阶段的资源申请，监督程序的执行情况。\"]},\"945\":{\"h\":\"ResourceManager\",\"t\":[\"ResourceManager主要由两个组件构成：调度器（Scheduler）和应用程序管理器（Applications Manager， ASM）\",\"调度器（Scheduler） 根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。\",\"应用程序管理器（Applications Manager） 负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动 ApplicationMaster、监控 ApplicationMaster 运行状态并在失败时重新启动它等。\"]},\"946\":{\"h\":\"NodeManager\",\"t\":[\"NodeManager是每个节点上的资源和任务管理器。\",\"一方面，它会定时地向 RM 汇报本节点上的资源使用情况和各个 Container 的运行状态\",\"另一方面，它接收并处理来自 AM 的 Container启动 / 停止等各种请求\"]},\"947\":{\"h\":\"ApplicationMaster\",\"t\":[\"职责 \",\"与 RM 调度器协商以获取资源（用 Container 表示）；\",\"将得到的任务进一步分配给内部的任务；\",\"与 NM 通信以启动 / 停止任务；\",\"监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。\"]},\"948\":{\"h\":\"2.2 Container容器\",\"t\":[\"Container 是YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当 AM 向 RM 申请资源时， RM 为 AM 返回的资源便是用 Container表示的。YARN 会为每个任务分配一个 Container，且该任务只能使用该 Container 中描述的资源。需要注意的是， Container 不同于 MRv1 中的 slot（槽位），它是一个动态资源划分单位，是根据应用程序的需求动态生成的。\",\"当下YARN仅支持CPU和内存两种资源，底层使用了轻量级资源隔离机制Cgroups进行资源隔离\"]},\"949\":{\"h\":\"3. YARN通信协议\",\"t\":[\"分布式环境下，需要涉及跨机器跨网络通信，YARN底层使用RPC协议实现通信。\",\"RPC是远程过程调用（Remote Procedure Call）的缩写形式。基于RPC进行远程调用就像本地调用一样\",\"在RPC协议中，通信双方有一端是Client，另一端为Server，且Client总是主动连接 Server 的。因此，YARN实际上采用的是拉式（pull-based）通信模型\",\"JobClient（作业提交客户端 ）与 RM 之间的协议--ApplicationClientProtocol。客户端通过该 RPC 协议提交应用程序、查询应用程序状态等。\",\"Admin（管理员）与 RM 之间的通信协议--ResourceManagerAdministrationProtocol。Admin通过该 RPC 协议更新YARN集群系统配置文件，比如节点黑白名单、用户队列权限等。\",\"AM 与 RM 之间的协议--ApplicationMasterProtocol。AM 通过该 RPC 协议向RM注册和撤销自己，并为各个任务申请资源。\",\"AM 与 NM 之间的协议--ContainerManagementProtocol。AM 通过该 RPC 要求NM启动或者停止 Container，获取各个 Container 的使用状态等信息。\",\"NM 与 RM 之间的协议--ResourceTracker。NM 通过该 RPC 协议向 RM 注册，并定时发送心跳信息汇报当前节点的资源使用情况和 Container 运行情况。\"]},\"950\":{\"h\":\"4. YARN交互流程\"},\"951\":{\"h\":\"4.1 YARN上的应用类型\",\"t\":[\"短应用程序：指一定时间内（可能是秒级、分钟级或小时级，尽管天级别或者更长时间的也存在，但非常少）可运行完成并正常退出的应用程序，比如 MapReduce 作业、 Spark 作业等；\",\"长应用程序：指不出意外，永不终止运行的应用程序，通常是一些服务，比如 Storm Service（主要包括 Nimbus 和 Supervisor 两类服务）， Flink（包括 JobManager和 TaskManager两类服务） 等，而它们本身作为一个框架提供了编程接口供用户使用。\",\"尽管这两类应用程序作用不同，一类直接运行数据处理程序，一类用于部署服务（服务之上再运行数据处理程序），但运行在 YARN 上的流程是相同的。\"]},\"952\":{\"h\":\"4.2 整体概述\",\"t\":[\"当用户向 YARN 中提交一个应用程序后， YARN 将分两个阶段运行该应用程序 。\",\"第一个阶段是启动 ApplicationMaster；\",\"第二个阶段是由 ApplicationMaster 创建应用程序，为它申请资源，并监控它的整个运行过程，直到运行完成。\"]},\"953\":{\"h\":\"4.3 MR提交YARN交互流程\",\"t\":[\"第1步：用户向YARN中提交应用程序，其中包括ApplicationMaster程序、启动ApplicationMaster 的命令、用户程序等\",\"第2步：ResourceManager 为该应用程序分配第一个Container，并与对应的 NodeManager通信，要求它在这个 Container中启动应用程序的 ApplicationMaster\",\"第3步：ApplicationMaster 首先向 ResourceManager 注册，这样用户可以直接通过ResourceManage 查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即重复步骤 4~7。\",\"第4步：ApplicationMaster 通过 RPC 协议向 ResourceManager 申请和领取资源\",\"第5步：一旦 ApplicationMaster 申请到资源后，便与对应的 NodeManager 通信，要求它启动任务\",\"第6步：NodeManager 为任务设置好运行环境（包括环境变量、 JAR 包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务\",\"第7步：各个任务通过某个 RPC 协议向 ApplicationMaster 汇报自己的状态和进度，以让 ApplicationMaster 随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。在应用程序运行过程中，用户可随时通过 RPC 向 ApplicationMaster 查询应用程序的当前运行状态\",\"第8步：应用程序运行完成后，ApplicationMaster 向 ResourceManager 注销并关闭自己\"]},\"954\":{\"h\":\"MapReduce 基础入门\"},\"955\":{\"h\":\"1. MapReduce相关介绍\",\"t\":[\"MapReduce是一个离线计算框架，针对静态数据集，不支持动态的离线数据\"]},\"956\":{\"h\":\"1.1 Hadoop Writable序列化机制\",\"t\":[\"序列化 (Serialization)是将结构化对象转换成字节流以便于进行网络传输或写入持久存储的过程。\",\"反序列化（Deserialization）是将字节流转换为一系列结构化对象的过程，重新创建该对象。\",\"Hadoop通过Writable接口实现的序列化机制，接口提供两个方法write和readFields。\",\"write叫做序列化方法，用于把对象指定的字段写出去；\",\"readFields叫做反序列化方法，用于从字节流中读取字段重构对象；\",\"Hadoop没有提供对象比较功能，所以和java中的Comparable接口合并，提供一个接口WritableComparable。\",\"WritableComparable接口可用于用户自定义对象的比较规则。\",\"@InterfaceAudience.Public @InterfaceStability.Stable public interface WritableComparable<T> extends Writable, Comparable<T> { } \",\"Hadoop数据类型\",\"Java数据类型\",\"BooleanWritable\",\"boolean\",\"ByteWritable\",\"byte\",\"IntWritable\",\"int\",\"FloatWritable\",\"float\",\"LongWritable\",\"long\",\"DoubleWritable\",\"double\",\"Text\",\"String\",\"MapWritable\",\"map\",\"ArrayWritable\",\"array\",\"NullWritable\",\"null\",\"如果想自定义Hadoop数据类型\",\"自定义对象必须实现Hadoop的序列化机制Writable\",\"如果需要将自定义的对象作为key传递，则还需要实现Comparable接口，因为MapReduce框中的Shuffle过程要求对key必须能排序。你得指定对象的排序规则是什么。\"]},\"957\":{\"h\":\"2. WordCount\",\"t\":[\"所需要的依赖以及maven打包插件\",\"<dependencies> <dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-common</artifactId> <version>3.1.4</version> </dependency> <dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-hdfs</artifactId> <version>3.1.4</version> </dependency> <dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-client</artifactId> <version>3.1.4</version> </dependency> <dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-mapreduce-client-core</artifactId> <version>3.1.4</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.32</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-jar-plugin</artifactId> <version>2.4</version> <configuration> <archive> <manifest> <addClasspath>true</addClasspath> <classpathPrefix>lib/</classpathPrefix> <mainClass>com.vingkin.mapreduce.wordcount.WordCountDriver_v2</mainClass> </manifest> </archive> </configuration> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.1</version> <configuration> <source>1.8</source> <target>1.8</target> <encoding>UTF-8</encoding> </configuration> </plugin> </plugins> </build> \"]},\"958\":{\"h\":\"Map阶段\",\"t\":[\"WordCountMapper.java\",\"Map阶段的处理类，对应着MapTask\",\"public class WordCountMapper extends Mapper<LongWritable, Text, Text, LongWritable> { private Text outkey = new Text(); private final static LongWritable outvalue = new LongWritable(1); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, LongWritable>.Context context) throws IOException, InterruptedException { // 拿取一行数据转换为String String line = value.toString(); // 根据分隔符进行切割 String[] words = line.split(\\\"\\\\\\\\s+\\\"); // 遍历数组 for (String word : words) { outkey.set(word); // 输出数据 吧每个单词都标记1 输出的结果<单词,1> context.write(outkey, outvalue); } } } \"]},\"959\":{\"h\":\"相关解析\",\"t\":[\"Mapper的四个泛型分别为：\",\"KEYIN：LongWritable\",\"VALUEIN：Text\",\"KEYOUT：Text\",\"VALUEOUT：LongWritable\",\"在map阶段之前，MapReduce程序已采用其默认的读取数据组件TextInputFormat对文本数据进行了读取，每一行返回一个kv键值对（map方法基于行来调用，每一行调用一次map方法进行业务处理），分别表示每一行起始位置的偏移量和这一行的文本内容。因此，Mapper的KEYIN和VALUEIN分别对应着TextInputFormat返回的键值对，其Hadoop数据类型分别为LongWritable和Text。\",\"在执行map的时候，先将LongWritable类型的value转换成String类型，再通过正则对一行文本进行分隔。最后通过context上下文对象将每个单词都组成<单词, 1>形式的键值对进行输出。因此KEYOUT和VALUEOUT的数据类型分别为Text和LongWritable。\"]},\"960\":{\"h\":\"Reduce阶段\",\"t\":[\"WordCountReducer.java\",\"Reduce阶段的处理类，对应着ReduceTask\",\"public class WordCountReducer extends Reducer<Text, LongWritable, Text, LongWritable> { private LongWritable outValue = new LongWritable(); @Override protected void reduce(Text key, Iterable<LongWritable> values, Reducer<Text, LongWritable, Text, LongWritable>.Context context) throws IOException, InterruptedException { // 统计变量 long count = 0; for (LongWritable value : values) { // <hadoop,Iterable[1,1,1]> count += value.get(); } outValue.set(count); // 最终使用上下文对此项输出结果 context.write(key, outValue); } } \"]},\"961\":{\"h\":\"相关解析\",\"t\":[\"Reducer的四个泛型分别为：\",\"KEYIN\",\"VALUEIN\",\"KEYOUT\",\"VALUEOUT\",\"Reducer的四个泛型很好确定，Reducer的KEYIN和VALUEIN对应着Mapper的KEYOUT和VALUEOUT，因此为Text和LongWritable。对于KEYOUT和VALUEOUT要根据具体的业务进行判断，此业务是统计单词个数，因而KEYOUT为单词Text，VALUEOUT为单词个数LongWritable。\",\"在Map阶段和Reduce阶段之间MapReduce程序默认对数据进行了相关的处理。对于Map阶段的输出结果我们可以假设为<hadoop,1><hadoop,1><hello,1><hello,1><hadoop,1>，MapReduce程序会对数据先按key的字典序对键值对进行排序，然后再以key相同的为一组，分组之后，同一组数据组成一个新的kv键值对，调用一次reduce（reduce方法基于分组调用，一个分组调用一次）。\",\"具体的数据操作如下：\",\"排序：<hadoop,1><hadoop,1><hadoop,1><hello,1><hello,1>\",\"分组： \",\"<hadoop,1><hadoop,1><hadoop,1>\",\"<hello,1><hello,1>\",\"分组后新的kv键值对： \",\"<hadoop,Iterable[1,1,1]>\",\"<hello,Iterable[1,1]>\",\"map的执行流程为：对于每一个分组，对values进行迭代遍历加出该key的总个数，再将key作为输出的key，个数作为输出的value通过context上下文对象进行输出。\"]},\"962\":{\"h\":\"Driver阶段\",\"t\":[\"WordCountDriver_v1.java\",\"/** * @Author: Vingkin * @Date: Create in 14:44 2021/8/1 * @Description: MapReduce客户端程序驱动类 构造Job对象实例 * 指定各种组件属性 包括：mapper reducer类、输入输出的数据类型、输入输出的数据路径 * 提交job作业 job.submit() */ public class WordCountDriver_v1 { public static void main(String[] args) throws Exception { // 创建配置对象 Configuration conf = new Configuration(); // 构建Job作业的实例 参数（配置对象，Job名字） Job job = Job.getInstance(conf, WordCountDriver_v1.class.getSimpleName()); // 设置MR程序运行的主类 job.setJarByClass(WordCountDriver_v1.class); // 设置MR程序的mapper类 reducer类 job.setMapperClass(WordCountMapper.class); job.setReducerClass(WordCountReducer.class); // 指定mapper阶段输出的key value类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(LongWritable.class); // 指定reducer阶段输出的key value类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(LongWritable.class); // 配置本次作业的输入数据路径 输出数据路径 // todo 默认组件 TextInputFormat TextOutputFormat FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); // 提交作业 // 采用waitForCompletion参数表示是否开启实时监视追踪作业的执行情况 boolean resultFlag = job.waitForCompletion(true); // 退出程序 和job结果进行绑定 System.exit(resultFlag ? 0 : 1); } } \",\"WordCountDriver_v2.java（效率更高，优先使用）\",\"/** * @Author: Vingkin * @Date: Create in 14:44 2021/8/1 * @Description: 使用工具类ToolRunner提交MapReduce作业 */ public class WordCountDriver_v2 extends Configured implements Tool { public static void main(String[] args) throws Exception { // 创建配置对象 Configuration conf = new Configuration(); // todo 使用工具类ToolRunner提交程序 int status = ToolRunner.run(conf, new WordCountDriver_v2(), args); // 退出客户端 System.exit(status); } @Override public int run(String[] args) throws Exception { Job job = Job.getInstance(getConf(), WordCountDriver_v2.class.getSimpleName()); // 设置MR程序运行的主类 job.setJarByClass(WordCountDriver_v2.class); // 设置MR程序的mapper类 reducer类 job.setMapperClass(WordCountMapper.class); job.setReducerClass(WordCountReducer.class); // 指定mapper阶段输出的key value类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(LongWritable.class); // 指定reducer阶段输出的key value类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(LongWritable.class); // 配置本次作业的输入数据路径 输出数据路径 // todo 默认组件 TextInputFormat TextOutputFormat FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); return job.waitForCompletion(true) ? 0 : 1; } } \",\"打包方式：先clean再package\",\"hadoop jar WordCount-1.0-SNAPSHOT.jar /vingkin/input /vingkin/output\",\"默认输入组件为TextInputFormat，通过指定input文件夹，就处理该目录所有的文件，把所有文件当成整体来处理。默认输出组件为*TextOutputFormat，output文件夹应该不存在，否则报错。\"]},\"963\":{\"h\":\"3. MapReduce程序运行模式\",\"t\":[\"所谓运行模式是指MapReduce程序是单机运行还是分布式运行，程序所需要的运算资源是YARN分配还是本机系统自己分配\",\"yarn：YARN集群模式\",\"local：本地模式（默认）\",\"在mapred-default.xml中可以进行相应的配置，需要配置的参数如下：\",\"mapreduce.framework.name=yarn\",\"yarn.resourcemanager.hostname=node1\",\"但是如果在代码中（conf.set()）或者运行的环境中有配置（mapred-site.xml），则会覆盖default的配置。\",\"conf.set(\\\"mapreduce.framework.name\\\", \\\"yarn\\\") \"]},\"964\":{\"h\":\"4. MapReduce流程梳理\"},\"965\":{\"h\":\"4.1 Map阶段执行过程\",\"t\":[\"第一阶段：把输入目录下文件按照一定的标准逐个进行逻辑切片，形成切片规划。\",\"默认Split size = Block size，每一个切片由一个MapTask处理。（getSplits）\",\"第二阶段：对切片中的数据按照一定的规则读取解析返回<key,value>对。\",\"默认是按行读取数据。key是每一行的起始位置偏移量，value是本行的文本内容。（TextInputFormat）\",\"第三阶段：调用Mapper类中的map方法处理数据。\",\"每读取解析出来的一个<key,value> ，调用一次map方法。\",\"第四阶段：按照一定的规则对Map输出的键值对进行分区partition。默认不分区，因为只有一个reducetask。\",\"分区的数量就是reducetask运行的数量。\",\"第五阶段：Map输出数据写入内存缓冲区，达到比例溢出到磁盘上。溢出spill的时候根据key进行排序sort。\",\"默认根据key字典序排序。\",\"第六阶段：对所有溢出文件进行最终的merge合并，成为一个文件。\"]},\"966\":{\"h\":\"4.2 Reduce阶段执行过程\",\"t\":[\"第一阶段：ReduceTask会主动从MapTask复制拉取其输出的键值对。\",\"第二阶段：把复制到Reducer本地数据，全部进行合并merge，即把分散的数据合并成一个大的数据。再对合并后的数据排序。\",\"第三阶段是对排序后的键值对调用reduce方法。\",\"键相等的键值对调用一次reduce方法。最后把这些输出的键值对写入到HDFS文件中。\"]},\"967\":{\"h\":\"MapReduce 基础编程\"},\"968\":{\"h\":\"1. MapReduce Partition分区\",\"t\":[\"注意分区与分组的区别，分区的目的是通过设置ReduceTask的数量将数据输出到不同的文件中。而每一个分组调用一次reduce程序。\",\"输出文件的个数与ReduceTask个数是一种对等关系，有几个ReduceTask，最终程序就输出几个文件。\",\"对于MapTask究竟给哪个ReduceTask处理，这就是数据分区问题。\",\"可以自己制定ReduceTask的个数：\",\"job.setNumReduceTasks(3);\",\"MapReduce的默认分区规则是HashPartitioner，也就是用key的哈希值对ReduceTask个数进行取模，与int最大值是为了避免哈希值为负的情况。\",\"@InterfaceAudience.Public @InterfaceStability.Stable public class HashPartitioner<K2, V2> implements Partitioner<K2, V2> { public void configure(JobConf job) {} /** Use {@link Object#hashCode()} to partition. */ public int getPartition(K2 key, V2 value, int numReduceTasks) { return (key.hashCode() & Integer.MAX_VALUE) % numReduceTasks; } } \",\"注意事项：\",\"ReduceTask个数的改变导致了数据分区的产生，而不是有数据分区导致了reducetask个数改变。\",\"数据分区的核心是分区规则。即如何分配数据给各个ReduceTask。\",\"默认的规则可以保证只要map阶段输出的key一样，数据就一定可以分区到同一个ReduceTask，但是不能保证数据平均分区。\",\"ReduceTask个数的改变还会导致输出结果文件不再是一个整体，而是输出到多个文件中。\"]},\"969\":{\"h\":\"2. MapReduce Combiner规约\",\"t\":[\"数据归约是指在尽可能保持数据原貌的前提下，最大限度地精简数据量。\",\"产生的原因：跨网络传递的资源消耗\",\"Combiner的作用就是对map端的输出先做一次局部合并，以减少在map和reduce节点之间的数据传输量。\"]},\"970\":{\"h\":\"2.1 Combiner组件的使用\",\"t\":[\"Combiner默认不开启，其本质就是Reducer\",\"具体实现步骤：\",\"自定义一个CustomCombiner类，继承Reducer，重写reduce方法\",\"job.setCombinerClass(CustomCombiner.class)\",\"注意事项：\",\"Combiner能够应用的前提是不能影响最终的业务逻辑，而且，Combiner的输出kv应该跟reducer的输入kv类型要对应起来。\",\"下述场景禁止使用Combiner，因为这样不仅优化了网络传输数据量，还改变了最终的执行结果\",\"业务和数据个数相关的。\",\"业务和整体排序相关的。\",\"Combiner组件不是禁用，而是慎用。用的好提高程序性能，用不好，改变程序结果且不易发现。\"]},\"971\":{\"h\":\"3. COVID-19病例统计\"},\"972\":{\"h\":\"3.1 各州累计病例数量统计\",\"t\":[\"统计美国2021-01-28，每个州state累计确诊案例数、累计死亡案例数。\",\"自定义JavaBean实现Writable接口来实现Hadoop的序列化机制\",\"需求分析：\",\"自定义对象CovidCountBean，用于封装每个县的确诊病例数和死亡病例数。\",\"注意自定义对象需要实现Hadoop的序列化机制。\",\"以州作为map阶段输出的key,以CovidCountBean作为value，这样属于同一个州的数据就会变成一组进行reduce处理，进行累加即可得出每个州累计确诊病例。\",\"CovidCountBean.java\",\"/** * @Author: Vingkin * @Date: Create in 16:58 2021/8/3 * @Description: 自定义对象作为数据类型在MapReduce中传递，注意实现Hadoop的序列化机制 */ public class CovidCountBean implements Writable { private long cases; // 确诊病例数 private long deaths; // 死亡病例数 // 构造函数 set get 。。。 /** * 自己封装的set方法，用于对象的属性赋值 * @param cases * @param deaths */ public void set(long cases, long deaths) { this.cases = cases; this.deaths = deaths; } @Override public String toString() { return cases + \\\"\\\\t\\\" + deaths; } /** * 序列化方法，控制那些字段序列化出去 * @param out * @throws IOException */ @Override public void write(DataOutput out) throws IOException { out.writeLong(cases); out.writeLong(deaths); } /** * 反序列化方法，todo 反序列化的顺序与序列化一致 也就是必须先写cases后写deaths * @param in * @throws IOException */ @Override public void readFields(DataInput in) throws IOException { this.cases = in.readLong(); this.deaths = in.readLong(); } } \",\"CovidSumMapper.java\",\"public class CovidSumMapper extends Mapper<LongWritable, Text, Text, CovidCountBean> { Text outKey = new Text(); CovidCountBean outValue = new CovidCountBean(); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, CovidCountBean>.Context context) throws IOException, InterruptedException { // 1. 读取一行数据进行切割 String[] fields = value.toString().split(\\\",\\\"); // 2. 提取数据 州 确诊数 死亡数 outKey.set(fields[2]); outValue.set(Long.parseLong(fields[fields.length-2]), Long.parseLong(fields[fields.length-1])); context.write(outKey, outValue); } } \",\"CovidSumReducer.java\",\"public class CovidSumReducer extends Reducer<Text, CovidCountBean, Text, CovidCountBean> { private CovidCountBean outValue = new CovidCountBean(); @Override protected void reduce(Text key, Iterable<CovidCountBean> values, Reducer<Text, CovidCountBean, Text, CovidCountBean>.Context context) throws IOException, InterruptedException { long countCases = 0; long countDeaths = 0; for (CovidCountBean value : values) { countCases += value.getCases(); countDeaths += value.getDeath(); } outValue.set(countCases, countDeaths); context.write(key, outValue); } } \",\"CovidSumDriver.java\",\"public class CovidSumDriver { public static void main(String[] args) throws Exception { //配置文件对象 Configuration conf = new Configuration(); // 创建作业实例 Job job = Job.getInstance(conf, CovidSumDriver.class.getSimpleName()); // 设置作业驱动类 job.setJarByClass(CovidSumDriver.class); // 设置作业mapper reducer类 job.setMapperClass(CovidSumMapper.class); job.setReducerClass(CovidSumReducer.class); // 设置作业mapper阶段输出key value数据类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(CovidCountBean.class); //设置作业reducer阶段输出key value数据类型 也就是程序最终输出数据类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(CovidCountBean.class); // 配置作业的输入数据路径 FileInputFormat.addInputPath(job, new Path(args[0])); // 配置作业的输出数据路径 FileOutputFormat.setOutputPath(job, new Path(args[1])); //判断输出路径是否存在 如果存在删除 FileSystem fs = FileSystem.get(conf); if (fs.exists(new Path(args[1]))) { fs.delete(new Path(args[1]), true); } // 提交作业并等待执行完成 boolean resultFlag = job.waitForCompletion(true); //程序退出 System.exit(resultFlag ? 0 : 1); } } \"]},\"973\":{\"h\":\"3.2 各州累计病例分区统计\",\"t\":[\"将美国疫情数据不同州的输出到不同文件中，属于同一个州的各个县输出到同一个结果文件中\",\"这个主要考察的就是自定义分区的实现，而且分区数=ReduceTask数\",\"需求分析：\",\"输出到不同文件中-->reducetask有多个（>2）-->默认只有1个，如何有多个？--->可以设置，job.setNumReduceTasks(N)--->当有多个reducetask 意味着数据分区---->默认分区规则是什么？ hashPartitioner--->默认分区规则符合你的业务需求么？---->符合，直接使用--->不符合，自定义分区。\",\"StatePartitioner.java\",\"/** * @Author: Vingkin * @Date: Create in 19:58 2021/8/3 * @Description: 自定义分区规则 */ public class StatePartitioner extends Partitioner<Text, Text> { // 模拟美国各州的数据字典 实际中可以通过redis来实现 如果数据量不大 也可以创建数据集合保存 public static HashMap<String, Integer> stateMap = new HashMap<String, Integer>(); static { stateMap.put(\\\"Alabama\\\", 0); stateMap.put(\\\"Alaska\\\", 1); stateMap.put(\\\"Arkansas\\\", 2); stateMap.put(\\\"California\\\", 3); stateMap.put(\\\"Colorado\\\", 4); } /** * 自定义分区器中分区规则的实现方法 只要getPartition返回的int一样 数据就会被分到同一个分区 * 所谓的同一个分区指的是数据由同一个ReduceTask来处理 * @param key state * @param value 文本数据 * @param numPartitions * @return */ @Override public int getPartition(Text key, Text value, int numPartitions) { Integer code = stateMap.get(key.toString()); if (code != null) { return code; } return 5; } } \",\"CovidPartitionMapper.java\",\"public class CovidPartitionMapper extends Mapper<LongWritable, Text, Text, Text> { private Text outKey = new Text(); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, Text>.Context context) throws IOException, InterruptedException { String[] split = value.toString().split(\\\",\\\"); outKey.set(split[2]); context.write(outKey, value); } } \",\"CovidPartitionReducer.java\",\"public class CovidPartitionReducer extends Reducer<Text, Text, Text, NullWritable> { @Override protected void reduce(Text key, Iterable<Text> values, Reducer<Text, Text, Text, NullWritable>.Context context) throws IOException, InterruptedException { for (Text value : values) { context.write(value, NullWritable.get()); } } } \",\"CovidPartitionDriver.java\",\"public class CovidPartitionDriver { public static void main(String[] args) throws Exception { //配置文件对象 Configuration conf = new Configuration(); // 创建作业实例 Job job = Job.getInstance(conf, CovidPartitionDriver.class.getSimpleName()); // 设置作业驱动类 job.setJarByClass(CovidPartitionDriver.class); // 设置作业mapper reducer类 job.setMapperClass(CovidPartitionMapper.class); job.setReducerClass(CovidPartitionReducer.class); // 设置作业mapper阶段输出key value数据类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); //设置作业reducer阶段输出key value数据类型 也就是程序最终输出数据类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(NullWritable.class); job.setNumReduceTasks(6); // 配置作业的输入数据路径 FileInputFormat.addInputPath(job, new Path(args[0])); // 配置作业的输出数据路径 FileOutputFormat.setOutputPath(job, new Path(args[1])); //判断输出路径是否存在 如果存在删除 FileSystem fs = FileSystem.get(conf); if (fs.exists(new Path(args[1]))) { fs.delete(new Path(args[1]), true); } // 提交作业并等待执行完成 boolean resultFlag = job.waitForCompletion(true); //程序退出 System.exit(resultFlag ? 0 : 1); } } \"]},\"974\":{\"h\":\"3.3 各州累计病例数最多top1县\",\"t\":[\"统计美国2021-01-28，每个州state的确诊案例数最多的县是哪一个\",\"主要考察的就是自定义分组的实现，每个州按cases倒序分成一组，当reduce进行处理的时候，迭代器的第一个数据就是cases最多的县，迭代器中的值与key是一一对应的。\",\"需求分析：\",\"在map阶段将“州state、县county、县确诊病例cases”通过自定义对象封装，作为key输出；\",\"重写对象的排序规则，首先根据州的正序排序，如果州相等，按照确诊病例数cases倒序排序，发送到reduce。\",\"在reduce端利用自定义分组规则，将州state相同的分为一组，然后取第一个即是最大值。\",\"CovidTop1GroupingComparator.java\",\"/** * @Author: Vingkin * @Date: Create in 11:07 2021/8/4 * @Description: 自定义分组规则，州相同的为一组 */ public class CovidTop1GroupingComparator extends WritableComparator { protected CovidTop1GroupingComparator() { super(CovidTop1Bean.class, true); // 允许创建对象实例 } @Override public int compare(WritableComparable a, WritableComparable b) { CovidTop1Bean aBean = (CovidTop1Bean) a; CovidTop1Bean bBean = (CovidTop1Bean) b; return aBean.getState().compareTo(bBean.getState()); } } \",\"CovidTop1Bean.java\",\"public class CovidTop1Bean implements WritableComparable<CovidTop1Bean> { private String state; // 州 private String county; // 县 private long cases; // 确诊病例 public void set(String state, String county, long cases) { this.state = state; this.county = county; this.cases = cases; } @Override public int compareTo(CovidTop1Bean o) { int result; int i = this.state.compareTo(o.getState()); if (i > 0) { return 1; } else if (i < 0) { return -1; } else { // 州相等的情况，根据cases进行倒序排序 result = Long.compare(o.getCases(), this.cases); } return result; } @Override public void write(DataOutput out) throws IOException { out.writeUTF(state); out.writeUTF(county); out.writeLong(cases); } @Override public void readFields(DataInput in) throws IOException { this.state = in.readUTF(); this.county = in.readUTF(); this.cases = in.readLong(); } @Override public String toString() { return state + \\\"\\\\t\\\" + county + \\\"\\\\t\\\" + cases; } } \",\"CovidTop1Mapper.java\",\"public class CovidTop1Mapper extends Mapper<LongWritable, Text, CovidTop1Bean, NullWritable> { CovidTop1Bean outKey = new CovidTop1Bean(); NullWritable outValue = NullWritable.get(); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, CovidTop1Bean, NullWritable>.Context context) throws IOException, InterruptedException { String[] fields = value.toString().split(\\\",\\\"); outKey.set(fields[2], fields[1], Long.parseLong(fields[fields.length-2])); context.write(outKey, outValue); } } \",\"CovidTop1Reducer.java\",\"package com.vingkin.mapreduce.covid.top1; public class CovidTop1Reducer extends Reducer<CovidTop1Bean, NullWritable, CovidTop1Bean, NullWritable> { @Override protected void reduce(CovidTop1Bean key, Iterable<NullWritable> values, Reducer<CovidTop1Bean, NullWritable, CovidTop1Bean, NullWritable>.Context context) throws IOException, InterruptedException { for (NullWritable value : values) { System.out.println(key); } context.write(key, NullWritable.get()); } } \",\"CovidTop1Driver.java\",\"public class CovidTop1Driver { public static void main(String[] args) throws Exception { //配置文件对象 Configuration conf = new Configuration(); // 创建作业实例 Job job = Job.getInstance(conf, CovidTop1Driver.class.getSimpleName()); // 设置作业驱动类 job.setJarByClass(CovidTop1Driver.class); // 设置作业mapper reducer类 job.setMapperClass(CovidTop1Mapper.class); job.setReducerClass(CovidTop1Reducer.class); // 设置作业mapper阶段输出key value数据类型 job.setMapOutputKeyClass(CovidTop1Bean.class); job.setMapOutputValueClass(NullWritable.class); //设置作业reducer阶段输出key value数据类型 也就是程序最终输出数据类型 job.setOutputKeyClass(CovidTop1Bean.class); job.setOutputValueClass(NullWritable.class); // 设置分组规则 job.setGroupingComparatorClass(CovidTop1GroupingComparator.class); // 配置作业的输入数据路径 FileInputFormat.addInputPath(job, new Path(args[0])); // 配置作业的输出数据路径 FileOutputFormat.setOutputPath(job, new Path(args[1])); //判断输出路径是否存在 如果存在删除 FileSystem fs = FileSystem.get(conf); if (fs.exists(new Path(args[1]))) { fs.delete(new Path(args[1]), true); } // 提交作业并等待执行完成 boolean resultFlag = job.waitForCompletion(true); //程序退出 System.exit(resultFlag ? 0 : 1); } } \"]},\"975\":{\"h\":\"4. MapReduce并行度机制\"},\"976\":{\"h\":\"4.1 MapTask并行度机制\",\"t\":[\"MapTask的个数是与逻辑切片的个数相等的，而逻辑切片的大小默认与block size相等，也就是默认为128M\",\"逻辑规划：\",\"MapTask并行度的决定机制叫做逻辑规划。\",\"客户端提交job之前会对待处理数据进行逻辑切片，形成逻辑规划文件。\",\"逻辑规划机制由FileInputFormat类的getSplits方法完成。\",\"逻辑规划结果写入规划文件（job.split），在客户端提交Job之前，把规划文件提交到任务准备区，供后续使用。\",\"每个逻辑切片最终对应启动一个maptask。\",\"在默认情况下，split size = block size一个数据块对应一个切片文件 对应一个maptask处理。如果split size = 100M，那么可能会出现需要读多个块的情况，这时候会增加网络传输消耗。所以永远让split size == block size\",\"注意：bytesRemaining/splitSize > 1.1不满足的话，那么最后所有剩余的会作为一个切片。（所以理论上最后一个块的split size = 128 + 128x0.1）。意思是前面都按128M来逻辑划分，当划到最后一部分的时候进行计算。\"]},\"977\":{\"h\":\"4.2 ReduceTask并行度机制\",\"t\":[\"根据业务需求进行手动设置。job.setNumReduceTask(N);\"]},\"978\":{\"h\":\"5. MapReduce工作流程详解\"},\"979\":{\"h\":\"5.1 MapTask工作机制详解\",\"t\":[\"详细步骤\",\"Step1：读取数据组件InputFormat（默认TextInputFormat）会通过getSplits方法对输入目录中文件进行逻辑规划得到splits，有多少个split就对应启动多少个MapTask。split与block的对应关系默认是一对一。\",\"Step1：逻辑规划后，由RecordReader对象（默认LineRecordReader）进行读取，以回车换行作为分隔符，读取一行数据，返回<key，value>。（Key表示每行首字符偏移值，value表示这一行文本内容。）\",\"Step1：读取split返回<key,value>，进入用户自己继承的Mapper类中，执行用户重写的map函数。 RecordReader读取一行数据，这里调用一次map方法进程处理。\",\"Step2： map处理完之后，将map的每条结果通过context.write进行collect数据收集。在collect中，会先对其进行分区处理，默认使用HashPartitioner。(MapReduce提供Partitioner接口，它的作用就是决定当前的这对输出数据最终应该交由哪个reduce task处理。默认对key hash后再以reduce task数量取模。如果用户自己对Partitioner有需求，可以订制并设置到job上。 )\",\"Step2： 分区计算之后，会将数据写入内存，内存中这片区域叫做环形缓冲区（意思就是内存可复用），缓冲区的作用是批量收集map结果，减少磁盘IO的影响。\",\"Step3：当溢写线程启动后，需要对这80MB空间内的key做排序(Sort)。排序是MapReduce模型默认的行为，这里的排序也是对序列化的字节做的排序。(如果job设置过Combiner，那么现在就是使用Combiner的时候了。将有相同key的key/value对的value加起来，减少溢写到磁盘的数据量。Combiner会优化MapReduce的中间结果，所以它在整个模型中会多次使用。)\",\"Step4：每次溢写会在磁盘上生成一个临时文件，如果map的输出结果真的很大，有多次这样的溢写发生，磁盘上相应的就会有多个临时文件存在。(当整个数据处理结束之后开始对磁盘中的临时文件进行merge合并，因为最终的文件只有一个，写入磁盘，并且为这个文件提供了一个索引文件，以记录每个reduce对应数据的偏移量。 )\",\"环形缓冲区\",\"环形缓冲区就是内存中的一块区域，底层是字节数组。缓冲区是有大小限制，默认是100MB。\",\"当map task的输出结果很多时，就可能会撑爆内存，所以需要在一定条件下将缓冲区中的数据临时写入磁盘，然后重新利用这块缓冲区。这个从内存往磁盘写数据的过程被称为Spill，中文可译为溢写。\",\"这个溢写是由单独线程来完成，不影响往缓冲区写map结果的线程。溢写线程启动时不应该阻止map的结果输出，所以整个缓冲区有个溢写的比例spill.percent。这个比例默认是0.8（设置这个的原因就是在溢写的时候依然能往内存中输出数据），也就是当缓冲区的数据已经达到阈值（buffer size * spill percent = 100MB * 0.8 = 80MB），溢写线程启动，锁定这80MB的内存，执行溢写过程。Map task的输出结果还可以往剩下的20MB内存中写，互不影响。\"]},\"980\":{\"h\":\"5.2 ReduceTask工作机制详解\",\"t\":[\"详细步骤：\",\"Step1：Copy阶段，简单地拉取数据。Reduce进程启动一些数据copy线程(Fetcher)，通过HTTP方式请求maptask获取属于自己的文件。\",\"Step2： Merge阶段。Copy过来的数据会先放入内存缓冲区中，这里的缓冲区大小要比map端的更为灵活。merge有三种形式：内存到内存；内存到磁盘；磁盘到磁盘。默认情况下第一种形式不启用。当内存中的数据量到达一定阈值，就启动内存到磁盘的merge。第二种merge方式一直在运行，直到没有map端的数据时才结束，然后启动第三种磁盘到磁盘的merge方式生成最终的文件。（把分散的数据合并成一个大的数据后，还会再对合并后的数据排序。默认key的字典序排序。）\",\"Step3:对排序后的键值对调用reduce方法，键相等的键值对组成一组，调用一次reduce方法。 所谓分组就是纯粹的前后两个key比较，如果相等就继续判断下一个是否和当前相等。\",\"reduce处理的结果会调用默认输出组件TextOutputFormat写入到指定的目录文件中。\\nTextOutputFormat默认是一次输出写一行，key value之间以制表符\\\\t分割。\"]},\"981\":{\"h\":\"MapReduce 高阶编程\"},\"982\":{\"h\":\"1. MapReduce Counter计数器\"},\"983\":{\"h\":\"1.1 自定义Counter计数器\",\"t\":[\"需求：在WordCount程序中对apple单词的数量利用计数器进行统计\",\"在map阶段自定义一个counter，并且在遍历的时候进行统计\",\"protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, LongWritable>.Context context) throws IOException, InterruptedException { // todo 从程序的上下文环境中获取全局计数器 指定计数器所属组的名字 计数器的名字 Counter counter = context.getCounter(\\\"vingkin counters\\\", \\\"apple counter\\\"); // 拿取一行数据转换为String String line = value.toString(); // 根据分隔符进行切割 String[] words = line.split(\\\"\\\\\\\\s+\\\"); // 遍历数组 for (String word : words) { // 计数器使用 if (\\\"apple\\\".equals(word)) { counter.increment(1); } outkey.set(word); // 输出数据 吧每个单词都标记1 输出的结果<单词,1> context.write(outkey, outvalue); } } \",\"结果：\",\"vingkin counters apple counter=3 \"]},\"984\":{\"h\":\"2. MapReduce读取数据库操作\",\"t\":[\"对于MapReduce框架来说，使用inputformat进行数据读取操作，读取的数据首先由mapper处理，然后交给reducer处理，最终使用outputformat进行数据的输出操作。默认情况下，输入输出的组件实现都是针对文本数据处理的，分别是TextInputFormat、TextOutputFormat。\",\"为了方便 MapReduce 直接访问关系型数据库（Mysql，Oracle），Hadoop提供了DBInputFormat和DBOutputFormat两个类。其中DBInputFormat负责从数据库中读取数据，而DBOutputFormat负责把数据最终写入数据库中。\"]},\"985\":{\"h\":\"2.1 MapReduce读取Mysql操作\",\"t\":[\"DBInputFormat类用于从SQL表读取数据。底层一行一行读取表中的数据，返回<k,v>键值对。\",\"其中k是LongWritalbe类型的，表示数据的记录行号，从0开始\",\"其中v是DBWritable类型的，表示改行数据对应的对象类型\",\"相关依赖：\",\"<dependency> <groupId>org.apache.hadoop</groupId> <artifactId>hadoop-mapreduce-client-core</artifactId> <version>3.1.4</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.32</version> </dependency> \",\"GoodsBean.java，用于封装查询结果，需要实现序列化接口Writable和数据库操作接口DBWritable\",\"public class GoodsBean implements Writable, DBWritable { private long goodsId; // 商品ID private String goodsSn; // 商品编号 private String goodsName; // 商品名称 private double marketPrice; // 市场价 private double shopPrice; // 门店价 private long saleNum; // 总销售量 // set get 构造函数省略 public void set(long goodsId, String goodsSn, String goodsName, double marketPrice, double shopPrice, long saleNum) { this.goodsId = goodsId; this.goodsSn = goodsSn; this.goodsName = goodsName; this.marketPrice = marketPrice; this.shopPrice = shopPrice; this.saleNum = saleNum; } @Override public String toString() { return goodsId + \\\"\\\\t\\\" + goodsSn + \\\"\\\\t\\\" + goodsName + \\\"\\\\t\\\" + marketPrice + \\\"\\\\t\\\" + shopPrice + \\\"\\\\t\\\" + saleNum; } // 序列化方法 @Override public void write(DataOutput out) throws IOException { out.writeLong(goodsId); out.writeUTF(goodsSn); out.writeUTF(goodsName); out.writeDouble(marketPrice); out.writeDouble(shopPrice); out.writeLong(saleNum); } @Override public void readFields(DataInput in) throws IOException { this.goodsId = in.readLong(); this.goodsSn = in.readUTF(); this.goodsName = in.readUTF(); this.marketPrice = in.readDouble(); this.shopPrice = in.readDouble(); this.saleNum = in.readLong(); } // 在PreparedStatement中设置对象的字段 写数据操作 @Override public void write(PreparedStatement ps) throws SQLException { ps.setLong(1, goodsId); ps.setString(2, goodsSn); ps.setString(3, goodsName); ps.setDouble(4, marketPrice); ps.setDouble(5, shopPrice); ps.setLong(6, saleNum); } // 从ResultSet读取查询结果 赋值给对象属性 @Override public void readFields(ResultSet rs) throws SQLException { this.goodsId = rs.getLong(1); this.goodsSn = rs.getString(2); this.goodsName = rs.getString(3); this.marketPrice = rs.getDouble(4); this.shopPrice = rs.getDouble(5); this.saleNum = rs.getLong(6); } } \",\"ReadDBMapper.java\",\"public class ReadDBMapper extends Mapper<LongWritable, GoodsBean, LongWritable, Text> { private Text outValue = new Text(); @Override protected void map(LongWritable key, GoodsBean value, Mapper<LongWritable, GoodsBean, LongWritable, Text>.Context context) throws IOException, InterruptedException { outValue.set(value.toString()); context.write(key, outValue); } } \",\"ReadDBDriver.java\",\"public class ReadDBDriver { public static void main(String[] args) throws Exception { // 配置文件对象 Configuration conf = new Configuration(); // todo 配置当前作业的jdbc信息 DBConfiguration.configureDB( conf, \\\"com.mysql.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/study\\\", \\\"root\\\", \\\"123456\\\"); // 配置创建作业的job类 Job job = Job.getInstance(conf, ReadDBDriver.class.getSimpleName()); // 设置本次MR程序的驱动类 job.setJarByClass(ReadDBDriver.class); // 设置mapper class job.setMapperClass(ReadDBMapper.class); // 设置程序最终输出的key value类型 job.setOutputKeyClass(LongWritable.class); job.setOutputValueClass(Text.class); FileOutputFormat.setOutputPath(job, new Path(args[0])); // todo 把reducetask的个数设置为0 job.setNumReduceTasks(0); // 设置输入组件 job.setInputFormatClass(DBInputFormat.class); // 添加读取数据库相关参数 DBInputFormat.setInput( job, GoodsBean.class, \\\"select goodsId, goodsSn, goodsName, marketPrice, shopPrice, saleNum from itheima_goods\\\", \\\"select count(goodsId) from vingkin_goods\\\" ); boolean b = job.waitForCompletion(true); System.exit(b ? 0 : 1); } } \"]},\"986\":{\"h\":\"2.2 MapReducer写入Mysql操作\",\"t\":[\"DBOutputFormat ，它将reduce输出发送到SQL表。\",\"DBOutputFormat接受<key，value>键值对，其中key必须具有扩展DBWritable的类型，在该案例中key必须为GoodsBean，因为只会将key对应的内容写入数据库。\",\"WriteDBMapper.java\",\"public class WriteDBMapper extends Mapper<LongWritable, Text, NullWritable, GoodsBean> { private GoodsBean outValue = new GoodsBean(); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, NullWritable, GoodsBean>.Context context) throws IOException, InterruptedException { // 获取两个计数器 用于统计合法数据 非法数据 Counter sc = context.getCounter(\\\"mr_to_mysql\\\", \\\"SUCCESS\\\"); Counter fc = context.getCounter(\\\"mr_to_mysql\\\", \\\"FAILED\\\"); String[] fields = value.toString().split(\\\"\\\\t\\\"); // 判断输入的字段是否有缺失 如果不满足需求 就是非法数据 if (fields.length > 6) { // 合法数据 outValue.set( Long.parseLong(fields[1]), fields[2], fields[3], Double.parseDouble(fields[4]), Double.parseDouble(fields[5]), Long.parseLong(fields[6]) ); sc.increment(1); context.write(NullWritable.get(), outValue); } else { // 非法数据 fc.increment(1); } } } \",\"WriteDBReducer.java\",\"// 在使用DBOutputFormat时，要求我们输出的key必须是DBWritable的实现，因为只会把key写入数据库 public class WriteDBReducer extends Reducer<NullWritable, GoodsBean, GoodsBean, NullWritable> { @Override protected void reduce(NullWritable key, Iterable<GoodsBean> values, Reducer<NullWritable, GoodsBean, GoodsBean, NullWritable>.Context context) throws IOException, InterruptedException { for (GoodsBean value : values) { context.write(value, NullWritable.get()); } } } \",\"WriteDBDriver.java\",\"public class WriteDBDriver { public static void main(String[] args) throws Exception { // 配置文件对象 Configuration conf = new Configuration(); // todo 配置当前作业的jdbc信息 DBConfiguration.configureDB( conf, \\\"com.mysql.jdbc.Driver\\\", \\\"jdbc:mysql://localhost:3306/study?useUnicode=true&characterEncoding=utf8\\\", \\\"root\\\", \\\"123456\\\"); // 配置创建作业的job类 Job job = Job.getInstance(conf, WriteDBDriver.class.getSimpleName()); // 设置本次MR程序的驱动类 job.setJarByClass(WriteDBDriver.class); // 设置mapper class job.setMapperClass(WriteDBMapper.class); // 设置map输出的key value类型 job.setMapOutputKeyClass(NullWritable.class); job.setMapOutputValueClass(GoodsBean.class); // 设置reducer class job.setReducerClass(WriteDBReducer.class); // 设置程序最终输出的key value类型 job.setOutputKeyClass(GoodsBean.class); job.setOutputValueClass(NullWritable.class); // 设置当前作业的输入文件路径 FileInputFormat.setInputPaths(job, new Path(args[0])); // todo 把reducetask的个数设置为0 // job.setNumReduceTasks(0); // todo 输出组件 job.setOutputFormatClass(DBOutputFormat.class); // todo 配置当前作业写入数据库的表，字段 DBOutputFormat.setOutput( job, \\\"vingkin_goods_mr_write\\\", \\\"goodsId\\\", \\\"goodsSn\\\", \\\"goodsName\\\", \\\"marketPrice\\\", \\\"shopPrice\\\", \\\"saleNum\\\" ); boolean b = job.waitForCompletion(true); System.exit(b ? 0 : 1); } } \"]},\"987\":{\"h\":\"3. MapReduce Join操作\"},\"988\":{\"h\":\"3.1 Reduce Side Join\",\"t\":[\"在reduce阶段执行join关联操作\",\"实现步骤：\",\"mapper分别读取不同的数据集；\",\"mapper的输出中，通常以join的字段作为输出的key；\",\"不同数据集的数据经过shuffle，key一样的会被分到同一分组处理；\",\"在reduce中根据业务需求把数据进行关联整合汇总，最终输出。\",\"弊端：\",\"reduce端join最大的问题是整个join的工作是在reduce阶段完成的，但是通常情况下MapReduce中reduce的并行度是极小的（默认是1个），这就使得所有的数据都挤压到reduce阶段处理，压力颇大。虽然可以设置reduce的并行度，但是又会导致最终结果被分散到多个不同文件中。\",\"并且在数据从mapper到reducer的过程中，shuffle阶段十分繁琐，数据集大时成本极高。\",\"案例：对商品信息文件和订单信息文件进行Join处理\",\"思路分析：\",\"使用mapper处理订单数据和商品数据，输出的时候以goodsId号作为key。相同goodsId的商品和订单会到同一个reduce的同一个分组，在分组中进行订单和商品信息的关联合并。\",\"在MapReduce程序中可以通过context获取到当前处理的切片所属的文件名称。根据文件名来判断当前处理的是订单数据还是商品数据，以此来进行不同逻辑的输出。\",\"join处理完之后，最后可以再通过MapReduce程序排序功能，将属于同一笔订单的所有商品信息汇聚在一起。\",\"ReduceJoinMapper.java\",\"public class ReduceJoinMapper extends Mapper<LongWritable, Text, Text, Text> { private Text outKey = new Text(); private Text outValue = new Text(); StringBuilder sb = new StringBuilder(); String fileName = null; // maptask的初始化方法，获取当前处理的切面所属的文件名称 @Override protected void setup(Mapper<LongWritable, Text, Text, Text>.Context context) throws IOException, InterruptedException { FileSplit split = (FileSplit) context.getInputSplit(); // 获取切面所属文件名称，也就是当前Task处理的数据是哪一个文件的 fileName = split.getPath().getName(); System.out.println(\\\"当前处理的文件是：\\\" + fileName); } @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, Text>.Context context) throws IOException, InterruptedException { // 清空sb sb.setLength(0); // 切割读取的一行数据 String[] fields = value.toString().split(\\\"\\\\\\\\|\\\"); // 根据文件名进行判断 if (fileName.contains(\\\"itheima_goods.txt\\\")) { // 处理商品数据（商品id 商品编号 商品名称） outKey.set(fields[0]); sb.append(fields[1]).append(\\\"\\\\t\\\").append(fields[2]); outValue.set(sb.insert(0, \\\"goods#\\\").toString()); } else { // 处理订单数据（订单编号 商品id 实际支付价格） outKey.set(fields[1]); sb.append(fields[0]).append(\\\"\\\\t\\\").append(fields[2]); outValue.set(sb.insert(0, \\\"orders#\\\").toString()); } context.write(outKey, outValue); } } \",\"ReduceJoinReducer.java\",\"public class ReduceJoinReducer extends Reducer<Text, Text, Text, Text> { // 创建集合 用于保存订单数据和商品数据 便于后续join关联拼接数据 // goods 商品编号 商品名称 private List<String> goodsList = new ArrayList<String>(); // orders 订单编号 实际支付价格 private List<String> ordersList = new ArrayList<String>(); private Text outValue = new Text(); @Override protected void reduce(Text key, Iterable<Text> values, Reducer<Text, Text, Text, Text>.Context context) throws IOException, InterruptedException { // 遍历values for (Text value : values) { if (value.toString().startsWith(\\\"goods#\\\")) { String s = value.toString().split(\\\"#\\\")[1]; // 添加到商品集合中 goodsList.add(s); } if (value.toString().startsWith(\\\"orders#\\\")) { String s = value.toString().split(\\\"#\\\")[1]; // 添加到商品集合中 ordersList.add(s); } } // 获取两个集合的长度 int goodsSize = goodsList.size(); int ordersSize = ordersList.size(); for (int i = 0; i < ordersSize; i++) { for (int j = 0; j < goodsSize; j++) { outValue.set(ordersList.get(i) + \\\"\\\\t\\\" + goodsList.get(j)); // 最终输出 商品id，订单编号，实际支付价格，商品编号，商品名称 context.write(key, outValue); } } // 清空集合 ordersList.clear(); goodsList.clear(); } } \",\"ReduceJoinDriver.java\",\"略\",\"ReduceJoinSort.java\",\"public class ReduceJoinSort extends Configured implements Tool { /** * 调整一行数据中的字段顺序，让订单号放在首位 * 把属于同一笔订单的不同商品聚集在一起 * 以订单编号作为key */ public static class ReduceJoinSortMapper extends Mapper<LongWritable, Text, Text, Text> { Text outKey = new Text(); Text outValue = new Text(); @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, Text>.Context context) throws IOException, InterruptedException { String[] fields = value.toString().split(\\\"\\\\t\\\"); // 订单编号作为key outKey.set(fields[1]); // 输出结果：订单编号 商品id 商品编码 商品名称 实际成交金额 outValue.set(fields[1] + '\\\\t' + fields[0] + '\\\\t' + fields[3] + '\\\\t' + fields[4] + '\\\\t' + fields[2]); context.write(outKey, outValue); } } public static class ReduceJoinSortReducer extends Reducer<Text, Text, Text, NullWritable>{ @Override protected void reduce(Text key, Iterable<Text> values, Reducer<Text, Text, Text, NullWritable>.Context context) throws IOException, InterruptedException { for (Text value : values) { context.write(value, NullWritable.get()); } } } public static void main(String[] args) throws Exception { // 创建配置对象 Configuration conf = new Configuration(); //判断输出路径是否存在 如果存在删除 FileSystem fs = FileSystem.get(conf); if (fs.exists(new Path(args[1]))) { fs.delete(new Path(args[1]), true); } // todo 使用工具类ToolRunner提交程序 int status = ToolRunner.run(conf, new ReduceJoinSort(), args); // 退出客户端 System.exit(status); } @Override public int run(String[] args) throws Exception { Job job = Job.getInstance(getConf(), ReduceJoinSort.class.getSimpleName()); // 设置MR程序运行的主类 job.setJarByClass(ReduceJoinSort.class); // 设置MR程序的mapper类 reducer类 job.setMapperClass(ReduceJoinSortMapper.class); job.setReducerClass(ReduceJoinSortReducer.class); // 指定mapper阶段输出的key value类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); // 指定reducer阶段输出的key value类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(NullWritable.class); // 修改reducetask个数 // job.setNumReduceTasks(3); // 配置本次作业的输入数据路径 输出数据路径 // todo 默认组件 TextInputFormat TextOutputFormat FileInputFormat.setInputPaths(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); return job.waitForCompletion(true) ? 0 : 1; } } \"]},\"989\":{\"h\":\"3.2 MapReduce分布式缓存\",\"t\":[\"相关介绍：\",\"DistributedCache是MapReduce框架提供的一种机制,可以将job指定的文件,在job执行前,先行分发到各个task执行的机器上,并有相关机制对cache文件进行管理（比如读取缓存）。\",\"DistributedCache能够缓存应用程序所需的各种文件，包括text文本，Archive档案文件，jar包等。\",\"MapReduce框架在作业所有task执行之前会把指定的分布式缓存文件拷贝到各个Task运行的节点上。\",\"使用方法：\",\"添加缓存文件\",\"//添加归档文件到分布式缓存中 job.addCacheArchive(URI uri); //添加普通文件到分布式缓存中 job.addCacheFile(URI uri); // todo 添加分布式缓存文件，对应目录是hdfs上的目录，因为分布式缓存只支持在yarn模式下运行 job.addCacheFile(new URI(\\\"/vingkin/input/itheima_goods.txt\\\")); \",\"MapReduce程序中读取缓存文件 在Mapper类或者Reducer类的setup方法中，用BufferedReader获取分布式缓存中的文件内容。BufferedReader是带缓冲区的字符流，能够减少访问磁盘的次数，提高文件读取性能；并且可以一次性读取一行字符。\"]},\"990\":{\"h\":\"3.3 Map Side Join\",\"t\":[\"利用分布式缓存，实现在map阶段的join操作，因此程序没有了shuffle阶段和reduce阶段，避免了shuffle阶段的繁琐\",\"实现思路：\",\"首先分析处理的数据集，使用分布式缓存技术将小的数据集进行分布式缓存。\",\"MapReduce框架在执行的时候会自动将缓存的数据分发到各个maptask运行的机器上。\",\"在mapper初始化的时候从分布式缓存中读取小数据集数据，然后和自己读取的大数据集进行join关联，输出最终的结果。\",\"案例：和Reduce Side Join一样\",\"思路分析：\",\"Map-side Join是指在Mapper任务中加载特定数据集，此案例中把商品数据进行分布式缓存，使用Mapper读取订单数据和缓存的商品数据进行连接。\",\"通常为了方便使用，会在mapper的初始化方法setup中读取分布式缓存文件加载的程序的内存中，便于后续mapper处理数据。\",\"因为在mapper阶段已经完成了数据的关联操作，因此程序不需要进行reduce。需要在job中将reducetask的个数设置为0,也就是mapper的输出就是程序最终的输出。\",\"MapJoinMapper.java\",\"public class MapJoinMapper extends Mapper<LongWritable, Text, Text, NullWritable> { // 创建一个集合用于缓存我们的商品数据 Map<String, String> goodsMap = new HashMap<>(); private final Text outKey = new Text(); /** * 在程序初始化的方法中，从分布式缓存文件中加载我们的内容：itheima_goods.txt到本程序自己创建的集合中 * 便于map方法中的join操作 */ @Override protected void setup(Mapper<LongWritable, Text, Text, NullWritable>.Context context) throws IOException, InterruptedException { // 读取分布式缓存文件 注意：关于缓存文件的路径直接指定文件名称即可 不需要添加路径 BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\\\"itheima_goods.txt\\\"))); String line = null; while ((line = br.readLine()) != null) { // 商品id 商品编号 商品名称 String[] fields = line.split(\\\"\\\\\\\\|\\\"); // 把读取的分布式缓存内容添加到集合中 // key：商品id value：商品编码 商品名称 goodsMap.put(fields[0], fields[1] + '\\\\t' + fields[2]); } } @Override protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Text, NullWritable>.Context context) throws IOException, InterruptedException { // 订单编号 商品id 成交价格 String[] fields = value.toString().split(\\\"\\\\\\\\|\\\"); // todo 根据订单数据中的商品id在我们的缓存集合中找出对应的商品名称及相关信息，完成拼接，也就是所谓的join关联 String goodsInfo = goodsMap.get(fields[1]); outKey.set(value.toString() + '\\\\t' +goodsInfo); context.write(outKey, NullWritable.get()); } } \",\"MapJoinDriver.java\",\"具体步骤就是模板代码，只是下面两点需要注意\",\"// todo 修改reducetask个数 job.setNumReduceTasks(0); // todo 添加分布式缓存文件 job.addCacheFile(new URI(\\\"/vingkin/input/itheima_goods.txt\\\")); \",\"注意：最后通过maven将程序打包放到yarn集群上运行即可，不支持本地运行\"]},\"991\":{\"h\":\"4. MapReduce 工作流\",\"t\":[\"map -> reduce -> map -> reduce ....\",\"也就是前一个reduce的输出结果，是后一个阶段map的输入，类似于拓扑或者DAG\",\"JobControl类：工作流job控制器，一次可以提交、管理多个job。 JobControl类实现了线程Runnable接口。需要实例化一个线程来让它启动。\",\"ControlledJob类：可以将普通作业包装成受控作业。并且支持设置依赖关系。 Hadoop会根据依赖的关系，先后执行job任务，每个任务的运行都是独立的。\",\"需求：\",\"针对Reduce Side Join的两个程序（1.将数据集join，2.将join好的数据集排序），进行工作流处理，一起执行提交。\",\"MRJobFlow.java\",\"public class MRJobFlow { public static void main(String[] args) throws IOException { Configuration conf = new Configuration(); // 第一个做的job Job job1 = Job.getInstance(conf, ReduceJoinDriver.class.getSimpleName()); // 设置MR程序运行的主类 job1.setJarByClass(ReduceJoinDriver.class); // 设置MR程序的mapper类 reducer类 job1.setMapperClass(ReduceJoinMapper.class); job1.setReducerClass(ReduceJoinReducer.class); // 指定mapper阶段输出的key value类型 job1.setMapOutputKeyClass(Text.class); job1.setMapOutputValueClass(Text.class); // 指定reducer阶段输出的key value类型 job1.setOutputKeyClass(Text.class); job1.setOutputValueClass(Text.class); // 修改reducetask个数 // job.setNumReduceTasks(3); // 配置本次作业的输入数据路径 输出数据路径 // 默认组件 TextInputFormat TextOutputFormat FileInputFormat.setInputPaths(job1, new Path(\\\"D:\\\\\\\\OneDrive\\\\\\\\code\\\\\\\\bigdata\\\\\\\\code\\\\\\\\MapReduce\\\\\\\\WordCount\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\com\\\\\\\\vingkin\\\\\\\\mapreduce\\\\\\\\file\\\\\\\\join\\\\\\\\input\\\")); FileOutputFormat.setOutputPath(job1, new Path(\\\"D:\\\\\\\\OneDrive\\\\\\\\code\\\\\\\\bigdata\\\\\\\\code\\\\\\\\MapReduce\\\\\\\\WordCount\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\com\\\\\\\\vingkin\\\\\\\\mapreduce\\\\\\\\file\\\\\\\\join\\\\\\\\rjout\\\")); // todo 将我们普通的作业包装成受控作业 ControlledJob cj1 = new ControlledJob(conf); cj1.setJob(job1); // 第二个作业job Job job2 = Job.getInstance(conf, ReduceJoinSort.class.getSimpleName()); // 设置MR程序运行的主类 job2.setJarByClass(ReduceJoinSort.class); // 设置MR程序的mapper类 reducer类 job2.setMapperClass(ReduceJoinSort.ReduceJoinSortMapper.class); job2.setReducerClass(ReduceJoinSort.ReduceJoinSortReducer.class); // 指定mapper阶段输出的key value类型 job2.setMapOutputKeyClass(Text.class); job2.setMapOutputValueClass(Text.class); // 指定reducer阶段输出的key value类型 job2.setOutputKeyClass(Text.class); job2.setOutputValueClass(NullWritable.class); // 配置本次作业的输入数据路径 输出数据路径 // 默认组件 TextInputFormat TextOutputFormat FileInputFormat.setInputPaths(job2, new Path(\\\"D:\\\\\\\\OneDrive\\\\\\\\code\\\\\\\\bigdata\\\\\\\\code\\\\\\\\MapReduce\\\\\\\\WordCount\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\com\\\\\\\\vingkin\\\\\\\\mapreduce\\\\\\\\file\\\\\\\\join\\\\\\\\rjout\\\")); FileOutputFormat.setOutputPath(job2, new Path(\\\"D:\\\\\\\\OneDrive\\\\\\\\code\\\\\\\\bigdata\\\\\\\\code\\\\\\\\MapReduce\\\\\\\\WordCount\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\com\\\\\\\\vingkin\\\\\\\\mapreduce\\\\\\\\file\\\\\\\\join\\\\\\\\finalout\\\")); // todo 将我们普通的作业包装成受控作业 ControlledJob cj2 = new ControlledJob(conf); cj2.setJob(job2); // todo 设置作业之间的依赖关系 cj2.addDependingJob(cj1); // todo 创建主控制器控制上面两个作业一起提交 JobControl jc = new JobControl(\\\"myctrl\\\"); jc.addJob(cj1); jc.addJob(cj2); // 使用线程启动jc Thread t = new Thread(jc); t.start(); while (true) { if (jc.allFinished()) { System.out.println(jc.getSuccessfulJobList()); jc.stop(); break; } } } } \"]},\"992\":{\"h\":\"MapReduce 整体流程核心代码解读\",\"t\":[\"记得引用老师画的图\",\"waitForCompletion（）=》submit=》和集群建立链接（connect（））=》创建Cluster对象（new Cluter()）\"]},\"993\":{\"h\":\"MapReduce 性能优化\"},\"994\":{\"h\":\"1. IO性能优化：文件类型\"},\"995\":{\"h\":\"1.1 行式存储、列式存储\",\"t\":[\"优缺点：\",\"行存储的写入是一次性完成，消耗的时间比列存储少，并且能够保证数据的完整性，缺点是数据读取过程中会产生冗余数据，如果只有少量数据，此影响可以忽略;数量大可能会影响到数据的处理效率。行适合插入、不适合查询。\",\"列存储在写入效率、保证数据完整性上都不如行存储，它的优势是在读取过程，不会产生冗余数据，这对数据完整性要求不高的大数据处理领域，比如互联网，犹为重要。列适合查询，不适合插入。\"]},\"996\":{\"h\":\"雪花算法\",\"t\":[\"SnowFlake 雪花算法详解与实现\"]},\"997\":{\"h\":\"背景\",\"t\":[\"现在的服务基本是分布式，微服务形式的，而且大数据量也导致分库分表的产生，对于水平分表就需要保证表中 id 的全局唯一性。\",\"对于 MySQL 而言，一个表中的主键 id 一般使用自增的方式，但是如果进行水平分表之后，多个表中会生成重复的 id 值。那么如何保证水平分表后的多张表中的 id 是全局唯一性的呢？\",\"如果还是借助数据库主键自增的形式，那么可以让不同表初始化一个不同的初始值，然后按指定的步长进行自增。例如有3张拆分表，初始主键值为1，2，3，自增步长为3。\",\"当然也有人使用 UUID 来作为主键，但是 UUID 生成的是一个无序的字符串，对于 MySQL 推荐使用增长的数值类型值作为主键来说不适合。\",\"也可以使用 Redis 的自增原子性来生成唯一 id，但是这种方式业内比较少用。\",\"当然还有其他解决方案，不同互联网公司也有自己内部的实现方案。雪花算法是其中一个用于解决分布式 id 的高效方案，也是许多互联网公司在推荐使用的。\"]},\"998\":{\"h\":\"SnowFlake 雪花算法\",\"t\":[\"SnowFlake 中文意思为雪花，故称为雪花算法。最早是 Twitter 公司在其内部用于分布式环境下生成唯一 ID。在2014年开源 scala 语言版本。\",\"雪花算法\",\"雪花算法原理就是生成一个的64位比特位的 long 类型的唯一 id。\",\"最高1位固定值0，因为生成的 id 是正整数，如果是1就是负数了。\",\"接下来41位存储毫秒级时间戳，241/(1000∗60∗60∗24∗365)=69，大概可以使用69年。\",\"再接下10位存储机器码，包括5位 datacenterId 和5位 workerId。最多可以部署210=1024台机器。\",\"最后12位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成212=4096个不重复 id。\",\"可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。\",\"对于每一个雪花算法服务，需要先指定10位的机器码（机器id+服务id），这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的10位比特位的整数值都行。\"]},\"999\":{\"h\":\"算法实现\",\"t\":[\"import java.util.Set; import java.util.TreeSet; public class SnowflakeIdGenerator { // 初始时间戳(纪年)，可用雪花算法服务上线时间戳的值 // 1649059688068：2022-04-04 16:08:08 private static final long INIT_EPOCH = 1649059688068L; // 记录最后使用的毫秒时间戳，主要用于判断是否同一毫秒，以及用于服务器时钟回拨判断 private long lastTimeMillis = -1L; // dataCenterId占用的位数 private static final long DATA_CENTER_ID_BITS = 5L; // dataCenterId占用5个比特位，最大值31 // 0000000000000000000000000000000000000000000000000000000000011111 private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS); // datacenterId private long datacenterId; // workId占用的位数 private static final long WORKER_ID_BITS = 5L; // workId占用5个比特位，最大值31 // 0000000000000000000000000000000000000000000000000000000000011111 private static final long MAX_WORKER_ID = ~(-1L << WORKER_ID_BITS); // workId private long workerId; // 最后12位，代表每毫秒内可产生最大序列号，即 2^12 - 1 = 4095 private static final long SEQUENCE_BITS = 12L; // 掩码（最低12位为1，高位都为0），主要用于与自增后的序列号进行位与，如果值为0，则代表自增后的序列号超过了4095 // 0000000000000000000000000000000000000000000000000000111111111111 private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS); // 同一毫秒内的最新序号，最大值可为 2^12 - 1 = 4095 private long sequence; // workId位需要左移的位数 12 private static final long WORK_ID_SHIFT = SEQUENCE_BITS; // dataCenterId位需要左移的位数 12+5 private static final long DATA_CENTER_ID_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS; // 时间戳需要左移的位数 12+5+5 private static final long TIMESTAMP_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS + DATA_CENTER_ID_BITS; public SnowflakeIdGenerator(long datacenterId, long workerId) { // 检查datacenterId的合法值 if (datacenterId < 0 || datacenterId > MAX_DATA_CENTER_ID) { throw new IllegalArgumentException( String.format(\\\"datacenterId值必须大于0并且小于%d\\\", MAX_DATA_CENTER_ID)); } // 检查workId的合法值 if (workerId < 0 || workerId > MAX_WORKER_ID) { throw new IllegalArgumentException(String.format(\\\"workId值必须大于0并且小于%d\\\", MAX_WORKER_ID)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 通过雪花算法生成下一个id，注意这里使用synchronized同步 * * @return 唯一id */ public synchronized long nextId() { long currentTimeMillis = System.currentTimeMillis(); // 当前时间小于上一次生成id使用的时间，可能出现服务器时钟回拨问题 if (currentTimeMillis < lastTimeMillis) { throw new RuntimeException( String.format(\\\"可能出现服务器时钟回拨问题，请检查服务器时间。当前服务器时间戳：%d，上一次使用时间戳：%d\\\", currentTimeMillis, lastTimeMillis)); } if (currentTimeMillis == lastTimeMillis) { // 还是在同一毫秒内，则将序列号递增1，序列号最大值为4095 // 序列号的最大值是4095，使用掩码（最低12位为1，高位都为0）进行位与运行后如果值为0，则自增后的序列号超过了4095 // 那么就使用新的时间戳 sequence = (sequence + 1) & SEQUENCE_MASK; if (sequence == 0) { currentTimeMillis = tilNextMillis(lastTimeMillis); } } else { // 不在同一毫秒内，则序列号重新从0开始，序列号最大值为4095 sequence = 0; } // 记录最后一次使用的毫秒时间戳 lastTimeMillis = currentTimeMillis; // 核心算法，将不同部分的数值移动到指定的位置，然后进行或运行 return ((currentTimeMillis - INIT_EPOCH) << TIMESTAMP_SHIFT) | (datacenterId << DATA_CENTER_ID_SHIFT) | (workerId << WORK_ID_SHIFT) | sequence; } /** * 获取指定时间戳的接下来的时间戳，也可以说是下一毫秒 * * @param lastTimeMillis 指定毫秒时间戳 * @return 时间戳 */ private long tilNextMillis(long lastTimeMillis) { long currentTimeMillis = System.currentTimeMillis(); while (currentTimeMillis <= lastTimeMillis) { currentTimeMillis = System.currentTimeMillis(); } return currentTimeMillis; } public static void main(String[] args) { SnowflakeIdGenerator snowflakeIdGenerator = new SnowflakeIdGenerator(1, 2); // 生成50个id Set<Long> set = new TreeSet<>(); for (int i = 0; i < 50; i++) { set.add(snowflakeIdGenerator.nextId()); } System.out.println(set.size()); System.out.println(set); // 验证生成100万个id需要多久 long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { snowflakeIdGenerator.nextId(); } System.out.println(System.currentTimeMillis() - startTime); } } \"]},\"1000\":{\"h\":\"算法优缺点\",\"t\":[\"雪花算法有以下几个优点：\",\"高并发分布式环境下生成不重复 id，每秒可生成百万个不重复 id。\",\"基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。\",\"不依赖第三方库或者中间件。\",\"算法简单，在内存中进行，效率高。\",\"雪花算法有如下缺点：\",\"依赖服务器时间，服务器时钟回拨时可能会生成重复 id。算法中可通过记录最后一个生成 id 时的时间戳来解决，每次生成 id 之前比较当前服务器时钟是否被回拨，避免生成重复 id。\"]},\"1001\":{\"h\":\"注意事项\",\"t\":[\"其实雪花算法每一部分占用的比特位数量并不是固定死的。例如你的业务可能达不到69年之久，那么可用减少时间戳占用的位数，雪花算法服务需要部署的节点超过1024台，那么可将减少的位数补充给机器码用。\",\"注意，雪花算法中41位比特位不是直接用来存储当前服务器毫秒时间戳的，而是需要当前服务器时间戳减去某一个初始时间戳值，一般可以使用服务上线时间作为初始时间戳值。\",\"对于机器码，可根据自身情况做调整，例如机房号，服务器号，业务号，机器 IP 等都是可使用的。对于部署的不同雪花算法服务中，最后计算出来的机器码能区分开来即可。\"]},\"1002\":{\"h\":\"幂等性\",\"t\":[\"幂等性如何实现？带你了解一波！！！\",\"所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是f(x)=f(f(x))。\"]},\"1003\":{\"h\":\"为什么需要幂等性\",\"t\":[\"在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：\",\"创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？\",\"订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？\",\"订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？\",\"作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式：\",\"服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。\",\"另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。\"]},\"1004\":{\"h\":\"HTTP的幂等性\",\"t\":[\"GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。\",\"HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。\",\"OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。\",\"DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。\",\"PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。\",\"POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。\"]},\"1005\":{\"h\":\"幂等性的实现方式\",\"t\":[\"对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。\",\"后端的幂等性如何实现？将会从以下几个方面介绍。\",\"数据库去重表\",\"在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。\",\"状态机\",\"很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。\",\"TOKEN机制\",\"针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。\",\"TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：\",\"TOKEN机制实现接口幂等性\",\"主要的流程步骤如下：\",\"客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。\",\"客户端调用业务请求的时候必须携带这个token，一般放在请求头上。\",\"服务端会校验这个Token，如果校验成功，则执行业务。\",\"如果校验失败，则表示重复操作，直接返回指定的结果给客户端。\",\"通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，可以选择雪花算法生成全局唯一ID。\"]},\"1006\":{\"h\":\"Kafka\",\"t\":[\"目录\"]},\"1007\":{\"h\":\"1、Kafka简介\"},\"1008\":{\"h\":\"1.1、消息队列\",\"t\":[\"消息队列——用于存放消息的组件\",\"程序员可以将消息放入到队列中，也可以从消息队列中获取消息\",\"很多时候消息队列不是一个永久性的存储，是作为临时存储存在的（设定一个期限：设置消息在MQ中保存10天）\",\"消息队列中间件：消息队列的组件，例如：Kafka、Active MQ、RabbitMQ、RocketMQ、ZeroMQ\"]},\"1009\":{\"h\":\"1.2、Kafka的应用场景\",\"t\":[\"异步处理 \",\"可以将一些比较耗时的操作放在其他系统中，通过消息队列将需要进行处理的消息进行存储，其他系统可以消费消息队列中的数据\",\"比较常见的：发送短信验证码、发送邮件（可以用此对之前Redis用户注册部分进行改进）\",\"系统解耦 \",\"原先一个微服务是通过接口（HTTP）调用另一个微服务，这时候耦合很严重，只要接口发生变化就会导致系统不可用\",\"使用消息队列可以将系统进行解耦合，现在第一个微服务可以将消息放入到消息队列中，另一个微服务可以从消息队列中把消息取出来进行处理。进行系统解耦\",\"流量削峰 \",\"因为消息队列是低延迟、高可靠、高吞吐的，可以应对大量并发\",\"日志处理 \",\"可以使用消息队列作为临时存储，或者一种通信管道\"]},\"1010\":{\"h\":\"1.3、消息队列的两种模型\",\"t\":[\"生产者、消费者模型\",\"生产者负责将消息生产到MQ中\",\"消费者负责从MQ中获取消息\",\"生产者和消费者是解耦的，可能是生产者一个程序、消费者是另外一个程序\",\"消息队列的模式\",\"点对点：一个消费者消费一个消息\",\"发布订阅：多个消费者可以消费一个消息\"]},\"1011\":{\"h\":\"2、Kafka 环境搭建\"},\"1012\":{\"h\":\"2.1、搭建 Kafka 环境\",\"t\":[\"将 Kafka 的安装包上传到虚拟机，并解压\",\"cd /export/software/ tar -xvzf kafka_2.12-2.4.1.tgz -C ../server/ cd /export/server/kafka_2.12-2.4.1/ \",\"修改 server.properties\",\"cd /export/server/kafka_2.12-2.4.1/config vim server.properties # 指定broker的id broker.id=0 # 指定Kafka数据的位置 log.dirs=/export/server/kafka_2.12-2.4.1/data \",\"配置 KAFKA_HOME 环境变量\",\"vim /etc/profile export KAFKA_HOME=/export/server/kafka_2.12-2.4.1 export PATH=:$PATH:${KAFKA_HOME} 每个节点加载环境变量 source /etc/profile \",\"启动服务器\",\"# 启动ZooKeeper nohup bin/zookeeper-server-start.sh config/zookeeper.properties & # 启动Kafka cd /export/server/kafka_2.12-2.4.1 nohup bin/kafka-server-start.sh config/server.properties & # 测试Kafka集群是否启动成功 bin/kafka-topics.sh --bootstrap-server localhost:9092 --list \",\"注意：\",\"每一个Kafka的节点都需要修改broker.id（每个节点的标识，不能重复）\",\"log.dir数据存储目录需要配置\",\"Kafka集群是必须要有ZooKeeper的\"]},\"1013\":{\"h\":\"2.2、目录结构分析\",\"t\":[\"目录名称\",\"说明\",\"bin\",\"Kafka 的所有执行脚本都在这里。例如：启动 Kafka 服务器、创建 Topic、生产者、消费者程序等等\",\"config\",\"Kafka 的所有配置文件\",\"libs\",\"运行 Kafka 所需要的所有 JAR 包\",\"logs\",\"Kafka 的所有日志文件，如果 Kafka 出现一些问题，需要到该目录中去查看异常信息\",\"site-docs\",\"Kafka 的网站帮助文件\"]},\"1014\":{\"h\":\"3、基础操作\"},\"1015\":{\"h\":\"3.1、创建 topic\",\"t\":[\"创建一个topic（主题）。Kafka中所有的消息都是保存在主题中，要生产消息到Kafka，首先必须要有一个确定的主题。\",\"# 创建名为test的主题 bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --topic test # 查看目前Kafka中的主题 bin/kafka-topics.sh --list --bootstrap-server localhost:9092 \"]},\"1016\":{\"h\":\"3.2、生产消息到 Kafka\",\"t\":[\"使用Kafka内置的测试程序，生产一些消息到Kafka的test主题中。\",\"bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test \"]},\"1017\":{\"h\":\"3.3、从 Kafka 消费消息\",\"t\":[\"使用下面的命令来消费 test 主题中的消息。\",\"bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning \"]},\"1018\":{\"h\":\"3.4、Kafka Tool\",\"t\":[\"远程连接需要配置server.properties\",\"listeners = PLAINTEXT://:9092 advertised.listeners=PLAINTEXT://ip:9092 \",\"浏览Kafka集群节点、多少个topic、多少个分区\",\"创建topic/删除topic\",\"浏览ZooKeeper中的数据\"]},\"1019\":{\"h\":\"4、Kafka 基准测试\",\"t\":[\"基准测试（benchmark testing）是一种测量和评估软件性能指标的活动。我们可以通过基准测试，了解到软件、硬件的性能水平。主要测试负载的执行时间、传输速度、吞吐量、资源占用率等。\",\"测试步骤：\",\"启动 Kafka 集群\",\"创建一个 1 个分区 1 个副本的 topic: benchmark\",\"同时运行生产者、消费者基准测试程序\",\"观察结果\"]},\"1020\":{\"h\":\"4.1、创建 topic\",\"t\":[\"bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic benchmark --partitions 1 --replication-factor 1 \"]},\"1021\":{\"h\":\"4.2、生产消息基准测试\",\"t\":[\"在生产环境中，推荐使用生产5000W消息，这样会性能数据会更准确些。\",\"bin/kafka-producer-perf-test.sh --topic benchmark --num-records 50000000 --throughput -1 --record-size 1000 --producer-props bootstrap.servers=localhost:9092 acks=1 \",\"参数信息\",\"bin/kafka-producer-perf-test.sh\",\"--topic topic的名字\",\"--num-records 总共指定生产数据量（默认5000W）\",\"--throughput 指定吞吐量——限流（-1不指定）\",\"--record-size record数据大小（字节）\",\"--producer-props bootstrap.servers=ip1:9092,ip2:9092,ip3:9092 acks=1 指定Kafka集群地址，ACK模式\",\"Kafka中提供了内置的性能测试工具\",\"生产者：测试生产每秒传输的数据量（多少条数据、多少M的数据）\",\"5000000 records sent, 11825.446943 records/sec (11.28 MB/sec), 2757.61 ms avg latency \",\"消费者：测试消费每条拉取的数据量\",\"对比生产者和消费者：消费者的速度更快\"]},\"1022\":{\"h\":\"5、Kafka Java API开发\",\"t\":[\"相关依赖：\",\"<dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- kafka客户端工具 --> <dependency> <groupId>org.apache.kafka</groupId> <artifactId>kafka-clients</artifactId> <version>2.4.1</version> </dependency> <!-- 工具类 --> <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-io</artifactId> <version>1.3.2</version> </dependency> <!-- SLF桥接LOG4J日志 --> <dependency> <groupId>org.slf4j</groupId> <artifactId>slf4j-log4j12</artifactId> <version>1.7.6</version> </dependency> <!-- SLOG4J日志 --> <dependency> <groupId>log4j</groupId> <artifactId>log4j</artifactId> <version>1.2.16</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <!--hutool--> <dependency> <groupId>cn.hutool</groupId> <artifactId>hutool-all</artifactId> <version>5.7.17</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <version>3.7.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> </plugins> </build> \",\"log4j.properties\",\"log4j.rootLogger=INFO,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p - %m%n \"]},\"1023\":{\"h\":\"5.1、生产者程序开发\",\"t\":[\"具体流程：\",\"创建连接 \",\"bootstrap.servers：Kafka 的服务器地址\",\"acks：表示当生产者生产数据到 Kafka 中，Kafka 中会以什么样的策略返回\",\"key.serializer：Kafka 中的消息是以key、value键值对存储的，而且生产者生产的消息是需要在网络上传到的，这里指定的是StringSerializer方式，就是以字符串方式发送（将来还可以使用其他的一些序列化框架：Google ProtoBuf、Avro）\",\"value.serializer：同上\",\"采用 try-resource 创建一个生产者对象KafkaProducer\",\"调用 send 方法发送消息（ProducerRecord，封装是 key-value 键值对）\",\"调用 Future.get() 表示等带服务端的响应\",\"配置KafkaProducer：\",\"@Configuration public class KafkaConfig { @Bean public Properties kafkaProducerConfigProperties() { Properties properties = new Properties(); properties.put(\\\"bootstrap.servers\\\", \\\"ip:9092\\\"); properties.put(\\\"acks\\\", \\\"all\\\"); properties.put(\\\"key.serializer\\\", \\\"org.apache.kafka.common.serialization.StringSerializer\\\"); properties.put(\\\"value.serializer\\\", \\\"org.apache.kafka.common.serialization.StringSerializer\\\"); return properties; } } \",\"编写代码：\",\"@Autowired @Qualifier(\\\"kafkaProducerConfigProperties\\\") private Properties kafkaProducerConfigProperties; @Test public void testProducer() { try (KafkaProducer<String, String> producer = new KafkaProducer<>(kafkaProducerConfigProperties)) { for (int i = 0; i < 100; i++) { Future<RecordMetadata> future = producer .send(new ProducerRecord<>(\\\"test\\\", null, String.valueOf(i))); future.get(); log.info(\\\"第{}条消息写入成功！\\\", i + 1); Thread.sleep(1000); } } catch (Exception e) { log.error(e.getMessage()); } } \"]},\"1024\":{\"h\":\"5.2、消费者程序开发\",\"t\":[\"配置KafkaConsumer：\",\"@Bean public Properties kafkaConsumerConfigProperties() { Properties properties = new Properties(); properties.put(\\\"bootstrap.servers\\\", \\\"ip:9092\\\"); properties.put(\\\"group.id\\\", \\\"test\\\"); properties.put(\\\"enable.auto.commit\\\", \\\"true\\\"); properties.put(\\\"auto.commit.interval.ms\\\", \\\"1000\\\"); properties.put(\\\"key.deserializer\\\", \\\"org.apache.kafka.common.serialization.StringDeserializer\\\"); properties.put(\\\"value.deserializer\\\", \\\"org.apache.kafka.common.serialization.StringDeserializer\\\"); return properties; } \",\"编写代码：\",\"@Autowired @Qualifier(\\\"kafkaConsumerConfigProperties\\\") private Properties kafkaConsumerConfigProperties; @Test public void testConsumer() { try (KafkaConsumer<String, String> consumer = new KafkaConsumer<>(kafkaConsumerConfigProperties)) { consumer.subscribe(Collections.singletonList(\\\"test\\\")); while (true) { // kafka消费者一次拉取一批数据过来 ConsumerRecords<String, String> records = consumer.poll(Duration.ofSeconds(5)); records.forEach(record -> { String topic = record.topic(); long offset = record.offset(); String key = record.key(); String value = record.value(); log.info(\\\"========================\\\"); log.info(\\\"topic: {}\\\", topic); log.info(\\\"offset: {}\\\", offset); log.info(\\\"key: {}\\\", key); log.info(\\\"value: {}\\\", value); }); } } catch (Exception e) { log.error(e.getMessage()); } } \",\"group.id：消费者组的概念，可以在一个消费组中包含多个消费者。如果若干个消费者的group.id是一样的，表示它们就在一个组中，一个组中的消费者是共同消费Kafka中topic的数据。\",\"Kafka：是一种拉消息模式的消息队列，在消费者中会有一个offset，表示从哪条消息开始拉取数据\",\"kafkaConsumer.poll：Kafka的消费者API是一批一批数据的拉取\"]},\"1025\":{\"h\":\"5.3、生产者使用异步方式生产消息\",\"t\":[\"如果我们想获取生产者消息是否成功，或者成功生产消息到 Kafka 中后，执行一些其他动作。此时，可以很方便地使用带有回调函数来发送消息。\",\"需求：\",\"在发送消息出现异常时，能够及时打印出异常信息\",\"在发送消息成功时，打印 Kafka 的 topic 名字、分区 id、offset\",\"@Test public void testProducer() { try (KafkaProducer<String, String> producer = new KafkaProducer<>(kafkaProducerConfigProperties)) { for (int i = 0; i < 100; i++) { ProducerRecord<String, String> record = new ProducerRecord<>(\\\"test\\\", null, String.valueOf(i)); producer.send(record, (metadata, exception) -> { if (exception == null) { // 生产成功 String topic = metadata.topic(); int partition = metadata.partition(); long offset = metadata.offset(); log.info(\\\"topic: {}, partition: {}, offset: {}\\\", topic, partition, offset); } else { log.error(exception.getMessage()); } }); } } catch (Exception e) { log.error(e.getMessage()); } } \",\"使用匿名内部类实现Callback接口，该接口中表示Kafka服务器响应给客户端，会自动调用onCompletion方法 \",\"metadata：消息的元数据（属于哪个topic、属于哪个partition、对应的offset是什么）\",\"exception：这个对象Kafka生产消息封装了出现的异常，如果为null，表示发送成功，如果不为null，表示出现异常。\"]},\"1026\":{\"h\":\"6、Kafka中的重要概念\",\"t\":[\"Broker：一台Kafka 服务器就是一个broker。一个集群由多个broker 组成。一个 broker 可以容纳多个topic。\",\"Producer：生产者\",\"Consumer：消费者\",\"Topic：主题，一个 Kafka 集群中，可以包含多个 topic。一个 topic 可以包含多个分区\",\"是一个逻辑结构，生产、消费消息都需要指定 topic，一个 topic 在物理上被划分为一个或多个 partition。\",\"Partition：Kafka 集群的分布式就是由分区来实现的。一个 topic 中的消息可以分布在 topic 中的不同partition 中，每个 partition 是一个有序的队列。\",\"Replica：副本，实现 Kafka 集群的容错，实现 partition 的容错。一个 topic 至少应该包含大于 1 个的副本，\",\"一个 Leader 和若干个 Follower。\",\"Leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是 Leader。\",\"Follower：每个分区多个副本中的“从”，实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 会成为新的 Leader。\",\"Consumer Group：消费者组，由多个 consumer 组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费； 消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。\",\"Offset：偏移量。相对消费者、partition 来说，可以通过 offset 来拉取数据\"]},\"1027\":{\"h\":\"7、幂等性\",\"t\":[\"在生产者生产消息时，如果出现retry时，有可能会一条消息被发送了多次，如果Kafka不具备幂等性的，就有可能会在partition中保存多条一模一样的消息。\"]},\"1028\":{\"h\":\"7.1、配置幂等性\",\"t\":[\"开启参数 enable.idempotence 默认为true，false 关闭。\",\"properties.put(\\\"enable.idempotence\\\",true); \"]},\"1029\":{\"h\":\"7.2、幂等性原理\",\"t\":[\"为了实现生产者的幂等性，Kafka引入了 Producer ID（PID）和 Sequence Number的概念。\",\"PID：每个Producer在初始化时，都会分配一个唯一的PID，这个PID对用户来说，是透明的。\",\"Sequence Number：针对每个生产者（对应PID）发送到指定主题分区的消息都对应一个从0开始递增的Sequence Number。\",\"其中 PID Kafka 每次重启都会重新分配，所以幂等性只能保证的是在单分区单会话内不重复。\"]},\"1030\":{\"h\":\"8、Kafka中的分区副本机制\"},\"1031\":{\"h\":\"8.1、生产者的分区写入策略\"},\"1032\":{\"h\":\"轮询策略\",\"t\":[\"默认的策略，也是使用最多的策略，可以最大限度保证所有消息平均分配到一个分区\",\"如果在生产消息时，key为null，则使用轮询算法均衡地分配分区\"]},\"1033\":{\"h\":\"随即策略\",\"t\":[\"随机策略，每次都随机地将消息分配到每个分区。在较早的版本，默认的分区策略就是随机策略，也是为了将消息均衡地写入到每个分区。但后续轮询策略表现更佳，所以基本上很少会使用随机策略。\"]},\"1034\":{\"h\":\"按 key 分配策略\",\"t\":[\"按key分配策略（key.hash() % 分区的数量），有可能会出现「数据倾斜」，例如：某个key包含了大量的数据，因为key值一样，所有所有的数据将都分配到一个分区中，造成该分区的消息数量远大于其他的分区。\"]},\"1035\":{\"h\":\"自定义分区策略\",\"t\":[\"创建自定义分区器：\",\"public class KeyWithRandomPartitioner implements Partitioner { private Random r; @Override public void configure(Map<String, ?> configs) { r = new Random(); } @Override public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) { // cluster.partitionCountForTopic 表示获取指定topic的分区数量 return r.nextInt(1000) % cluster.partitionCountForTopic(topic); } @Override public void close() { } } \",\"配置使用：\",\"properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, KeyWithRandomPartitioner.class.getName()); \",\"乱序问题\",\"在Kafka中生产者是有写入策略，如果topic有多个分区，就会将数据分散在不同的partition中存储\",\"当partition数量大于1的时候，数据（消息）会打散分布在不同的partition中，因此在每个partition中数据是相对有序的，但是对于topic，数据就会变得无须，这也是为什么说数据是相对有序的。\",\"如果只有一个分区，消息是有序的\"]},\"1036\":{\"h\":\"8.2、消费组 Rebalance 机制\"},\"1037\":{\"h\":\"Rebalance 再均衡\",\"t\":[\"Kafka 中的 Rebalance 称之为再均衡，是 Kafka 中确保 Consumer group 下所有的 consumer 如何达成一致，分配订阅的 topic 的每个分区的机制。\",\"Rebalance触发的时机有：\",\"消费者组中 consumer 的个数发生变化。例如：有新的 consumer 加入到消费者组，或者是某个 consumer 停止了。\",\"订阅的 topic 个数发生变化。消费者可以订阅多个主题，假设当前的消费者组订阅了三个主题，但有一个主题突然被删除了，此时也需要发生再均衡。（本质上其实是 partition 发生了变化）\",\"订阅的 topic 中的 partition 发生变化。\"]},\"1038\":{\"h\":\"Rebalance 的不良影响\",\"t\":[\"发生 Rebalance 时，consumer group 下的所有 consumer 都会协调在一起共同参与，Kafka 使用分配策略尽可能达到最公平的分配\",\"Rebalance 过程会对 consumer group 产生非常严重的影响，Rebalance 的过程中所有的消费者都将停止工作，直到 Rebalance 完成。\"]},\"1039\":{\"h\":\"8.3、消费者的分区分配策略\"},\"1040\":{\"h\":\"Range 范围分配策略\",\"t\":[\"Range 范围分配策略是 Kafka 默认的分配策略，它可以确保每个消费者消费的分区数量是均衡的。\",\"注意：Range 范围分配策略是针对每个 Topic 的\",\"配置：\",\"配置消费者的partition.assignment.strategy 为org.apache.kafka.clients.consumer.RangeAssignor。\",\"算法公式：\",\"n = 分区数量 / 消费者数量\",\"m = 分区数量 % 消费者数量\",\"前 m 个消费者消费 n+1 个\",\"剩余消费者消费 n 个\"]},\"1041\":{\"h\":\"RoundRobin轮询策略\",\"t\":[\"RoundRobinAssignor 轮询策略是将消费组内所有消费者以及消费者所订阅的所有 topic 的 partition 按照字典序排序（topic 和分区的 hashcode 进行排序），然后通过轮询方式逐个将分区以此分配给每个消费者。\",\"配置：\",\"配置消费者的partition.assignment.strategy 为org.apache.kafka.clients.consumer.RoundRobinAssignor。\"]},\"1042\":{\"h\":\"Stricky 粘性分配策略\",\"t\":[\"从 Kafka 0.11.x 开始，引入此类分配策略。主要目的：\",\"分区分配尽可能均匀\",\"在发生 rebalance 的时候，分区的分配尽可能与上一次分配保持相同\",\"没有发生 rebalance 时，Striky 粘性分配策略和 RoundRobin 分配策略类似。\",\"上面如果 consumer2 崩溃了，此时需要进行 rebalance。如果是 Range 分配和轮询分配都会重新进行分配，例如：\",\"通过上图，我们发现，consumer0 和 consumer1 原来消费的分区大多发生了改变。接下来我们再来看下粘性分配策略。\",\"我们发现，Striky 粘性分配策略，保留 rebalance 之前的分配结果。这样，只是将原先 consumer2 负责的两个分区再均匀分配给 consumer0、consumer1。这样可以明显减少系统资源的浪费，例如：之前 consumer0、consumer1 之前正在消费某几个分区，但由于 rebalance 发生，导致 consumer0、consumer1 需要重新消费之前正在处理的分区，导致不必要的系统开销。（例如：某个事务正在进行就必须要取消了）\"]},\"1043\":{\"h\":\"8.4、副本的ACK机制\",\"t\":[\"producer是不断地往Kafka中写入数据，写入数据会有一个返回结果，表示是否写入成功。这里对应有一个ACKs的配置。对应的代码如下：\",\"properties.put(\\\"acks\\\", \\\"all\\\"); \",\"acks = 0：生产者只管写入，不管是否写入成功，可能会数据丢失。性能是最好的\",\"acks = 1：生产者会等到leader分区写入成功后，返回成功，接着发送下一条\",\"acks = -1/all：确保消息写入到leader分区、还确保消息写入到对应副本都成功后，接着发送下一条，性能是最差的\",\"根据业务情况来选择ack机制，是要求性能最高，一部分数据丢失影响不大，可以选择0/1。如果要求数据一定不能丢失，就得配置为-1/all。\",\"分区中是有leader和follower的概念，为了确保消费者消费的数据是一致的，只能从分区leader去读写消息，follower做的事情就是同步数据，Backup。\"]},\"1044\":{\"h\":\"9、Kafka-Eagle\"},\"1045\":{\"h\":\"9.1、开启 JMX 端口\",\"t\":[\"JMX(Java Management Extensions) 是一个为应用程序植入管理功能的框架。JMX 是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。很多的一些软件都提供了JMX接口，来实现一些管理、监控功能。\",\"在启动Kafka的脚本前，添加：\",\"cd ${KAFKA_HOME} export JMX_PORT=9988 nohup bin/kafka-server-start.sh config/server.properties & \"]},\"1046\":{\"h\":\"9.2、安装Kafka-Eagle\",\"t\":[\"安装 JDK，并配置好 JAVA_HOME。\",\"将 Kafka-Eagle 上传，并解压到 /export/server 目录中。\",\"cd /export/software/ wget https://github.com/smartloli/kafka-eagle-bin/archive/v1.4.6.tar.gz tar -xvzf kafka-eagle-bin-1.4.6.tar.gz -C ../server/ cd /export/server/kafka-eagle-bin-1.4.6/ tar -xvzf kafka-eagle-web-1.4.6-bin.tar.gz cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6 \",\"配置 Kafka-Eagle 环境变量\",\"vim /etc/profile export KE_HOME=/export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6 export PATH=$PATH:$KE_HOME/bin source /etc/profile \",\"配置 conf 目录下的 system-config.properties\",\"vim conf/system-config.properties # :set nu 开启行号 # 修改第4行，配置kafka集群别名 kafka.eagle.zk.cluster.alias=cluster1 # 修改第5行，配置ZK集群地址 cluster1.zk.list=localhost:2181 # 注释第6行 #cluster2.zk.list=xdn10:2181,xdn11:2181,xdn12:2181 # 修改第32行，打开图标统计 kafka.eagle.metrics.charts=true # 注释第69行，取消sqlite数据库连接配置 #kafka.eagle.driver=org.sqlite.JDBC #kafka.eagle.url=jdbc:sqlite:/hadoop/kafka-eagle/db/ke.db #kafka.eagle.username=root #kafka.eagle.password=www.kafka-eagle.org # 修改第77行，开启mysql kafka.eagle.driver=com.mysql.jdbc.Driver kafka.eagle.url=jdbc:mysql://localhost:3306/ke?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull kafka.eagle.username=root kafka.eagle.password=123456 \",\"配置 JAVA_HOME\",\"cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6/bin vim ke.sh # 在第24行添加JAVA_HOME环境配置 export JAVA_HOME=/export/server/jdk1.8.0_241 \",\"修改 Kafka-Eagle 可执行权限\",\"cd /export/server/kafka-eagle-bin-1.4.6/kafka-eagle-web-1.4.6/bin chmod +x ke.sh \",\"启动 Kafka-Eagle\",\"./ke.sh start \"]},\"1047\":{\"h\":\"Kafka原理（TODO）\"},\"1048\":{\"h\":\"leader和follower\",\"t\":[\"Kafka中的leader和follower是相对分区有意义，不是相对broker\",\"Kafka在创建topic的时候，会尽量分配分区的leader在不同的broker中，其实就是负载均衡\",\"leader职责：读写数据\",\"follower职责：同步数据、参与选举（leader crash之后，会选举一个follower重新成为分区的leader\",\"注意和ZooKeeper区分 \",\"ZK的leader负责读、写，follower可以读取\",\"Kafka的leader负责读写、follower不能读写数据（确保每个消费者消费的数据是一致的），Kafka一个topic有多个分区leader，一样可以实现数据操作的负载均衡\"]},\"1049\":{\"h\":\"AR\\\\ISR\\\\OSR\",\"t\":[\"AR表示一个topic下的所有副本\",\"ISR：In Sync Replicas，正在同步的副本（可以理解为当前有几个follower是存活的）\",\"OSR：Out of Sync Replicas，不再同步的副本\",\"AR = ISR + OSR\"]},\"1050\":{\"h\":\"leader选举\",\"t\":[\"Controller：controller是kafka集群的老大，是针对Broker的一个角色\",\"Controller是高可用的，是用过ZK来进行选举\",\"Leader：是针对partition的一个角色\",\"Leader是通过ISR来进行快速选举\",\"如果Kafka是基于ZK来进行选举，ZK的压力可能会比较大。例如：某个节点崩溃，这个节点上不仅仅只有一个leader，是有不少的leader需要选举。通过ISR快速进行选举。\",\"leader的负载均衡\",\"如果某个broker crash之后，就可能会导致partition的leader分布不均匀，就是一个broker上存在一个topic下不同partition的leader\",\"通过以下指令，可以将leader分配到优先的leader对应的broker，确保leader是均匀分配的\",\"bin/kafka-leader-election.sh --bootstrap-server node1.itcast.cn:9092 --topic test --partition=2 --election-type preferred \"]},\"1051\":{\"h\":\"Kafka读写流程\",\"t\":[\"写流程 \",\"通过ZooKeeper找partition对应的leader，leader是负责写的\",\"producer开始写入数据\",\"ISR里面的follower开始同步数据，并返回给leader ACK\",\"返回给producer ACK\",\"读流程 \",\"通过ZooKeeper找partition对应的leader，leader是负责读的\",\"通过ZooKeeper找到消费者对应的offset\",\"然后开始从offset往后顺序拉取数据\",\"提交offset（自动提交——每隔多少秒提交一次offset、手动提交——放入到事务中提交）\"]},\"1052\":{\"h\":\"Kafka的物理存储\",\"t\":[\"Kafka的数据组织结构 \",\"topic\",\"partition\",\"segment \",\".log数据文件\",\".index（稀疏索引）\",\".timeindex（根据时间做的索引）\",\"深入了解读数据的流程 \",\"消费者的offset是一个针对partition全局offset\",\"可以根据这个offset找到segment段\",\"接着需要将全局的offset转换成segment的局部offset\",\"根据局部的offset，就可以从（.index稀疏索引）找到对应的数据位置\",\"开始顺序读取\"]},\"1053\":{\"h\":\"消息传递的语义性\",\"t\":[\"Flink里面有对应的每种不同机制的保证，提供Exactly-Once保障（二阶段事务提交方式）\",\"At-most once：最多一次（只管把数据消费到，不管有没有成功，可能会有数据丢失）\",\"At-least once：最少一次（有可能会出现重复消费）\",\"Exactly-Once：仅有一次（事务性性的保障，保证消息有且仅被处理一次）\"]},\"1054\":{\"h\":\"Kafka的消息不丢失\",\"t\":[\"broker消息不丢失：因为有副本relicas的存在，会不断地从leader中同步副本，所以，一个broker crash，不会导致数据丢失，除非是只有一个副本。\",\"生产者消息不丢失：ACK机制（配置成ALL/-1）、配置0或者1有可能会存在丢失\",\"消费者消费不丢失：重点控制offset \",\"At-least once：一种数据可能会重复消费\",\"Exactly-Once：仅被一次消费\"]},\"1055\":{\"h\":\"数据积压\",\"t\":[\"数据积压指的是消费者因为有一些外部的IO、一些比较耗时的操作（Full GC——Stop the world），就会造成消息在partition中一直存在得不到消费，就会产生数据积压\",\"在企业中，我们要有监控系统，如果出现这种情况，需要尽快处理。虽然后续的Spark Streaming/Flink可以实现背压机制，但是数据累积太多一定对实时系统它的实时性是有说影响的\"]},\"1056\":{\"h\":\"数据清理&配额限速\",\"t\":[\"数据清理 \",\"Log Deletion（日志删除）：如果消息达到一定的条件（时间、日志大小、offset大小），Kafka就会自动将日志设置为待删除（segment端的后缀名会以 .delete结尾），日志管理程序会定期清理这些日志 \",\"默认是7天过期\",\"Log Compaction（日志合并） \",\"如果在一些key-value数据中，一个key可以对应多个不同版本的value\",\"经过日志合并，就会只保留最新的一个版本\",\"配额限速 \",\"可以限制Producer、Consumer的速率\",\"防止Kafka的速度过快，占用整个服务器（broker）的所有IO资源\"]},\"1057\":{\"h\":\"ElasticSearch 实战\"},\"1058\":{\"h\":\"TODO\"},\"1059\":{\"h\":\"ElasticSearch 基础\"},\"1060\":{\"h\":\"1. 基本概念\"},\"1061\":{\"h\":\"1.1 索引（Index）\",\"t\":[\"一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。\",\"能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。\"]},\"1062\":{\"h\":\"1.2 类型（Type）\",\"t\":[\"在一个索引中，你可以定义一种或多种类型。\",\"一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。\",\"版本\",\"Type\",\"5.x\",\"支持多种Type\",\"6.x\",\"只能有一种Type\",\"7.x\",\"默认不再支持自定义索引类型（默认类型为：_doc）\"]},\"1063\":{\"h\":\"1.3 文档（Document）\",\"t\":[\"一个文档是一个可被索引的基础信息单元，也就是一条数据。\",\"比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。\",\"在一个index/type里面，你可以存储任意多的文档。\"]},\"1064\":{\"h\":\"1.4 字段（Field）\",\"t\":[\"相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。\"]},\"1065\":{\"h\":\"1.5 映射（Mapping）\",\"t\":[\"mapping是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\"]},\"1066\":{\"h\":\"1.6 分片（Shards）\",\"t\":[\"一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档数据的索引占据1TB的磁盘空间，而任一节点都可能没有这样大的磁盘空间。或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。\",\"分片很重要，主要有两方面的原因：\",\"允许你水平分割 / 扩展你的内容容量。\",\"允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。\",\"至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。\"]},\"1067\":{\"h\":\"1.7 副本（Replicas）\",\"t\":[\"在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。\",\"复制分片之所以重要，有两个主要原因：\",\"在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。\",\"扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。\",\"总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。默认情况下，Elasticsearch中的每个索引被分片1个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有1个主分片和另外1个复制分片（1个完全拷贝），这样的话每个索引总共就有2个分片，我们需要根据索引需要确定分片个数。\"]},\"1068\":{\"h\":\"1.8 分配（Allocation）\",\"t\":[\"将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由master节点完成的。\"]},\"1069\":{\"h\":\"2. 入门操作\"},\"1070\":{\"h\":\"2.1 引入依赖\",\"t\":[\"<dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.elasticsearch</groupId> <artifactId>elasticsearch</artifactId> <version>7.8.0</version> </dependency> <dependency> <groupId>org.elasticsearch.client</groupId> <artifactId>elasticsearch-rest-high-level-client</artifactId> <version>7.8.0</version> </dependency> <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-api</artifactId> <version>2.8.2</version> </dependency> <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-core</artifactId> <version>2.8.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.9</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> \"]},\"1071\":{\"h\":\"2.2 客户端对象\",\"t\":[\"因为早期版本的客户端对象已经不再推荐使用，且在未来版本中会被删除，所以这里我们采用高级 REST 客户端对象。\",\"public class ESTestClient { private ESTestClient() { } private static class SingletonHolder { private static final RestHighLevelClient INSTANCE = new RestHighLevelClient( RestClient.builder(new HttpHost(\\\"localhost\\\", 9200, \\\"http\\\")) ); private static void close() { try { INSTANCE.close(); } catch (IOException e) { throw new RuntimeException(e); } } } public static RestHighLevelClient getInstance() { // 创建es客户端 return SingletonHolder.INSTANCE; } public static void close() { SingletonHolder.close(); } } \"]},\"1072\":{\"h\":\"2.3 索引操作\",\"t\":[\"2.3.1 创建索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 创建索引 CreateIndexRequest request = new CreateIndexRequest(\\\"user\\\"); CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT); // 响应状态 boolean acknowledged = response.isAcknowledged(); log.info(\\\"索引操作：{}\\\", acknowledged); ESTestClient.close(); \",\"2.3.2 删除索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 删除索引 DeleteIndexRequest request = new DeleteIndexRequest(\\\"user\\\"); AcknowledgedResponse response = client.indices().delete(request, RequestOptions.DEFAULT); // 响应状态 log.info(\\\"索引删除：{}\\\", response.isAcknowledged()); ESTestClient.close(); \",\"2.3.3 查询索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 查询索引 GetIndexRequest request = new GetIndexRequest(\\\"user\\\"); GetIndexResponse response = client.indices().get(request, RequestOptions.DEFAULT); // 响应状态 log.info(\\\"索引查询getAliases：{}\\\", response.getAliases()); log.info(\\\"索引查询getMappings：{}\\\", response.getMappings()); log.info(\\\"索引查询getSettings：{}\\\", response.getSettings()); ESTestClient.close(); \"]},\"1073\":{\"h\":\"2.4 文档操作\",\"t\":[\"2.4.1 创建数据模型\",\"public class User { private String name; private String sex; private Integer age; } \",\"2.4.2 新增文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 插入数据 IndexRequest request = new IndexRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); // 构建数据 User user = new User(\\\"zhangsan\\\", \\\"男\\\", 30); ObjectMapper mapper = new ObjectMapper(); String userJson = mapper.writeValueAsString(user); request.source(userJson, XContentType.JSON); IndexResponse response = client.index(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.3 修改文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 修改数据 UpdateRequest request = new UpdateRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); request.doc(XContentType.JSON, \\\"sex\\\", \\\"女\\\", \\\"age\\\" , 18); UpdateResponse response = client.update(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.4 查询文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 查询数据 GetRequest request = new GetRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); GetResponse response = client.get(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.5 批量新增\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 批量插入数据 BulkRequest request = new BulkRequest(); User user1 = new User(\\\"zhangsan\\\", \\\"男\\\", 30); User user2 = new User(\\\"lisi\\\", \\\"男\\\", 18); User user3 = new User(\\\"wangwu\\\", \\\"女\\\", 20); ObjectMapper mapper = new ObjectMapper(); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1001\\\").source(mapper.writeValueAsString(user1), XContentType.JSON)); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1002\\\").source(mapper.writeValueAsString(user2), XContentType.JSON)); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1003\\\").source(mapper.writeValueAsString(user3), XContentType.JSON)); request.add(new BulkResponse response = client.bulk(request, RequestOptions.DEFAULT); ESTestClient.close(); \"]},\"1074\":{\"h\":\"3. 高级查询\"},\"1075\":{\"h\":\"3.1 查询索引中所有的数据\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 1、查询索引中所有的数据 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); request.source(new SearchSourceBuilder().query(QueryBuilders.matchAllQuery())); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1076\":{\"h\":\"3.2 条件查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 2、条件查询 SearchRequest request = new SearchRequest(); request.source(new SearchSourceBuilder().query(QueryBuilders.termQuery(\\\"age\\\", 30))); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1077\":{\"h\":\"3.3 分页查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 3、分页查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); builder.from(0); builder.size(2); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1078\":{\"h\":\"3.4 查询排序\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 4、查询排序 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); builder.sort(\\\"age\\\", SortOrder.ASC); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1079\":{\"h\":\"3.5 查询字段过滤\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 5、查询字段过滤 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); String[] include = {\\\"name\\\"}; String[] exclude = {}; builder.fetchSource(include, exclude); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1080\":{\"h\":\"3.6 组合查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 6、组合查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); BoolQueryBuilder query = QueryBuilders.boolQuery(); // query.must(QueryBuilders.matchQuery(\\\"sex\\\", \\\"女\\\")); query.should(QueryBuilders.matchQuery(\\\"age\\\", \\\"45\\\")); SearchSourceBuilder builder = new SearchSourceBuilder().query(query); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1081\":{\"h\":\"3.7 范围查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 7、范围查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(\\\"age\\\"); rangeQuery.gte(30); rangeQuery.lte(50); builder.query(rangeQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1082\":{\"h\":\"3.8 模糊查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 8、模糊查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); FuzzyQueryBuilder fuzzyQuery = QueryBuilders.fuzzyQuery(\\\"name\\\", \\\"wangwu\\\"); // 一个字符不同也能匹配成功 fuzzyQuery.fuzziness(Fuzziness.ONE); builder.query(fuzzyQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1083\":{\"h\":\"3.9 高亮查询\",\"t\":[\" RestHighLevelClient client = ESTestClient.getInstance(); // 9、高亮查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); TermsQueryBuilder termsQuery = QueryBuilders.termsQuery(\\\"name\\\", \\\"wangwu\\\"); HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.preTags(\\\"<font color='red'>\\\"); highlightBuilder.postTags(\\\"</font>\\\"); highlightBuilder.field(\\\"name\\\"); builder.highlighter(highlightBuilder); builder.query(termsQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1084\":{\"h\":\"3.10 聚合查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 10、聚合查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); AggregationBuilder aggregationBuilder = AggregationBuilders.max(\\\"maxAge\\\").field(\\\"age\\\"); builder.aggregation(aggregationBuilder); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1085\":{\"h\":\"3.11 分组查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 11、分组查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); AggregationBuilder aggregationBuilder = AggregationBuilders.terms(\\\"ageGroup\\\").field(\\\"age\\\"); builder.aggregation(aggregationBuilder); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"1086\":{\"h\":\"4. 框架集成\"},\"1087\":{\"h\":\"4.1 引入依赖\",\"t\":[\"<dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-elasticsearch</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-test</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> </dependency> </dependencies> \"]},\"1088\":{\"h\":\"4.2 配置类编写\",\"t\":[\"elasticsearch: host: localhost port: 9200 logging: level: com.vingkin.esspringboot: debug \",\"@ConfigurationProperties(prefix = \\\"elasticsearch\\\") @Configuration @Data public class ElasticsearchConfig extends AbstractElasticsearchConfiguration { private String host; private Integer port; @Override public RestHighLevelClient elasticsearchClient() { RestClientBuilder builder = RestClient.builder(new HttpHost(host, port)); return new RestHighLevelClient(builder); } } \"]},\"1089\":{\"h\":\"4.3 实现\",\"t\":[\"@Data @NoArgsConstructor @AllArgsConstructor @ToString @Document(indexName = \\\"product\\\") public class Product { @Id private Long id; @Field(type = FieldType.Text) private String title; // keyword表示关键字不分开（不分词） @Field(type = FieldType.Keyword) private String category; @Field(type = FieldType.Double) private Double price; // index=false表示不做索引关联（不能用images来查询） @Field(type = FieldType.Keyword, index=false) private String images; } \",\"@Repository public interface ProductDao extends ElasticsearchRepository<Product, Long> { } \",\"@SpringBootTest @Slf4j class EsSpringbootApplicationTests { @Autowired private ElasticsearchRestTemplate elasticsearchRestTemplate; @Autowired private ProductDao productDao; // 创建索引 @Test public void createIndex() { // 系统会扫描@Document(indexName = \\\"product\\\")后自动创建索引 log.info(\\\"创建索引\\\"); } // 删除索引 @Test public void deleteIndex() { boolean b = elasticsearchRestTemplate.deleteIndex(Product.class); } // 新增文档 @Test public void docSave() { Product product = new Product(3L, \\\"华为手机\\\", \\\"手机\\\", 3999.0, \\\"http://www.images.com/valsdkf/1.jpg\\\"); productDao.save(product); } // 修改文档（和新增一致） @Test public void updateSave() { Product product = new Product(5L, \\\"ipad2018\\\", \\\"平板\\\", 4999.0, \\\"http://www.images.com/valsdkf/1.jpg\\\"); productDao.save(product); } // 文档根据id查询 @Test public void findById() { Product product = productDao.findById(2L).get(); log.info(\\\"查询结果：{}\\\", product); } // 文档查询所有 @Test public void findAll() { Iterable<Product> all = productDao.findAll(); all.forEach(System.out::println); } // 文档文档删除 @Test public void docDelete() { productDao.deleteById(2L); } // 文档批量新增 @Test public void saveAll() { List<Product> productList = new ArrayList<>(); // 省略创建productList过程 productDao.saveAll(productList); } // 文档分页查询 @Test public void findByPageable() { Sort sort = Sort.by(Sort.Direction.DESC, \\\"id\\\"); int currentPage = 0; int pageSize = 3; // 设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize, sort); // 分页查询 Page<Product> productPage = productDao.findAll(pageRequest); productPage.forEach(System.out::println); } // 条件查询+分页 @Test public void termQueryByPage() { int currentPage = 0; int pageSize = 3; // 设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize); // 设置查询条件 TermQueryBuilder termQuery = QueryBuilders.termQuery(\\\"category\\\", \\\"手机\\\"); Page<Product> products = productDao.search(termQuery, pageRequest); products.forEach(System.out::println); } } \"]},\"1090\":{\"h\":\"Redis 实战\",\"t\":[\"目录\"]},\"1091\":{\"h\":\"1、短信登录\"},\"1092\":{\"h\":\"1.1、导入黑马点评项目\"},\"1093\":{\"h\":\"1.1.1 、导入SQL\"},\"1094\":{\"h\":\"1.1.2、有关当前模型\",\"t\":[\"手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。\",\"在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。\"]},\"1095\":{\"h\":\"1.1.3、导入后端项目\",\"t\":[\"在资料中提供了一个项目源码：\"]},\"1096\":{\"h\":\"1.1.4、导入前端工程\"},\"1097\":{\"h\":\"1.1.5 运行前端项目\"},\"1098\":{\"h\":\"1.2 、基于Session实现登录流程\",\"t\":[\"发送验证码：\",\"用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号\",\"如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户\",\"短信验证码登录、注册：\",\"用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息\",\"校验登录状态:\",\"用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行\"]},\"1099\":{\"h\":\"1.3、实现发送短信验证码功能\",\"t\":[\"页面流程\",\"具体代码如下\",\"贴心小提示：\",\"具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。\",\"发送验证码\",\"@Override public Result sendCode(String phone, HttpSession session) { // 1.校验手机号 if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.符合，生成验证码 String code = RandomUtil.randomNumbers(6); // 4.保存验证码到 session session.setAttribute(\\\"code\\\",code); // 5.发送验证码 log.debug(\\\"发送短信验证码成功，验证码：{}\\\", code); // 返回ok return Result.ok(); } \",\"登录\",\"@Override public Result login(LoginFormDTO loginForm, HttpSession session) { // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.校验验证码 Object cacheCode = session.getAttribute(\\\"code\\\"); String code = loginForm.getCode(); if(cacheCode == null || !cacheCode.toString().equals(code)){ //3.不一致，报错 return Result.fail(\\\"验证码错误\\\"); } //一致，根据手机号查询用户 User user = query().eq(\\\"phone\\\", phone).one(); //5.判断用户是否存在 if(user == null){ //不存在，则创建 user = createUserWithPhone(phone); } //7.保存用户信息到session中 session.setAttribute(\\\"user\\\",user); return Result.ok(); } \"]},\"1100\":{\"h\":\"1.4、实现登录拦截功能\",\"t\":[\"温馨小贴士：tomcat的运行原理\",\"当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应\",\"通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据\",\"温馨小贴士：关于threadlocal\",\"如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离\",\"拦截器代码\",\"public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的用户 Object user = session.getAttribute(\\\"user\\\"); //3.判断用户是否存在 if(user == null){ //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到Threadlocal UserHolder.saveUser((User)user); //6.放行 return true; } } \",\"让拦截器生效\",\"@Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { // 登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \\\"/shop/**\\\", \\\"/voucher/**\\\", \\\"/shop-type/**\\\", \\\"/upload/**\\\", \\\"/blog/hot\\\", \\\"/user/code\\\", \\\"/user/login\\\" ).order(1); // token刷新的拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\\\"/**\\\").order(0); } } \"]},\"1101\":{\"h\":\"1.5、隐藏用户敏感信息\",\"t\":[\"我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了\",\"在登录方法处修改\",\"//7.保存用户信息到session中 session.setAttribute(\\\"user\\\", BeanUtils.copyProperties(user,UserDTO.class)); \",\"在拦截器处：\",\"//5.存在，保存用户信息到Threadlocal UserHolder.saveUser((UserDTO) user); \",\"在UserHolder处：将user对象换成UserDTO\",\"public class UserHolder { private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>(); public static void saveUser(UserDTO user){ tl.set(user); } public static UserDTO getUser(){ return tl.get(); } public static void removeUser(){ tl.remove(); } } \"]},\"1102\":{\"h\":\"1.6、session共享问题\",\"t\":[\"核心思路分析：\",\"每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了\",\"但是这种方案具有两个大问题\",\"1、每台服务器中都有完整的一份session数据，服务器压力过大。\",\"2、session拷贝数据时，可能会出现延迟\",\"所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了\"]},\"1103\":{\"h\":\"1.7、Redis代替session的业务流程\"},\"1104\":{\"h\":\"1.7.1、设计key的结构\",\"t\":[\"首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。\"]},\"1105\":{\"h\":\"1.7.2、设计key的具体细节\",\"t\":[\"所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了\",\"在设计这个key的时候，我们之前讲过需要满足两点\",\"1、key要具有唯一性\",\"2、key要方便携带\",\"如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了\"]},\"1106\":{\"h\":\"1.7.3、整体访问流程\",\"t\":[\"当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。\"]},\"1107\":{\"h\":\"1.8、基于Redis实现短信登录\",\"t\":[\"这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。\",\"UserServiceImpl代码\",\"@Override public Result login(LoginFormDTO loginForm, HttpSession session) { // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.从redis获取验证码并校验 String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone); String code = loginForm.getCode(); if (cacheCode == null || !cacheCode.equals(code)) { // 不一致，报错 return Result.fail(\\\"验证码错误\\\"); } // 4.一致，根据手机号查询用户 select * from tb_user where phone = ? User user = query().eq(\\\"phone\\\", phone).one(); // 5.判断用户是否存在 if (user == null) { // 6.不存在，创建新用户并保存 user = createUserWithPhone(phone); } // 7.保存用户信息到 redis中 // 7.1.随机生成token，作为登录令牌 String token = UUID.randomUUID().toString(true); // 7.2.将User对象转为HashMap存储 UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(), CopyOptions.create() .setIgnoreNullValue(true) .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString())); // 7.3.存储 String tokenKey = LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(tokenKey, userMap); // 7.4.设置token有效期 stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES); // 8.返回token return Result.ok(token); } \"]},\"1108\":{\"h\":\"1.9、解决状态登录刷新问题\"},\"1109\":{\"h\":\"1.9.1、初始方案思路总结：\",\"t\":[\"在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的\"]},\"1110\":{\"h\":\"1.9.2、优化方案\",\"t\":[\"既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。\"]},\"1111\":{\"h\":\"1.9.3、代码\",\"t\":[\"RefreshTokenInterceptor\",\"public class RefreshTokenInterceptor implements HandlerInterceptor { private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1.获取请求头中的token String token = request.getHeader(\\\"authorization\\\"); if (StrUtil.isBlank(token)) { return true; } // 2.基于TOKEN获取redis中的用户 String key = LOGIN_USER_KEY + token; Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key); // 3.判断用户是否存在 if (userMap.isEmpty()) { return true; } // 5.将查询到的hash数据转为UserDTO UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false); // 6.存在，保存用户信息到 ThreadLocal UserHolder.saveUser(userDTO); // 7.刷新token有效期 stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES); // 8.放行 return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 移除用户 UserHolder.removeUser(); } } \",\"LoginInterceptor\",\"public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1.判断是否需要拦截（ThreadLocal中是否有用户） if (UserHolder.getUser() == null) { // 没有，需要拦截，设置状态码 response.setStatus(401); // 拦截 return false; } // 有用户，则放行 return true; } } \"]},\"1112\":{\"h\":\"2、商户查询缓存\"},\"1113\":{\"h\":\"2.1、什么是缓存?\",\"t\":[\"前言:什么是缓存?\",\"就像自行车,越野车的避震器\",\"举个例子:越野车,山地自行车,都拥有\\\"避震器\\\",防止车体加速后因惯性,在酷似\\\"U\\\"字母的地形上飞跃,硬着陆导致的损害,像个弹簧一样;\",\"同样,实际开发中,系统也需要\\\"避震器\\\",防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;\",\"这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;\",\"缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码(例如:\",\"例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发 例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存 例3:Static final Map<K,V> map = new HashMap(); 本地缓存 \",\"由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;\"]},\"1114\":{\"h\":\"2.1.1、为什么要使用缓存\",\"t\":[\"一句话:因为速度快,好用\",\"缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低用户访问并发量带来的服务器读写压力\",\"实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为\\\"避震器\\\",系统是几乎撑不住的,所以企业会大量运用到缓存技术;\",\"但是缓存也会增加代码复杂度和运营的成本:\"]},\"1115\":{\"h\":\"2.1.2、如何使用缓存\",\"t\":[\"实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用\",\"浏览器缓存：主要是存在于浏览器端的缓存\",\"**应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存\",\"**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中\",\"**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\"]},\"1116\":{\"h\":\"2.2、添加商户缓存\",\"t\":[\"在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存\",\"@GetMapping(\\\"/{id}\\\") public Result queryShopById(@PathVariable(\\\"id\\\") Long id) { //这里是直接查询数据库 return shopService.queryById(id); } \"]},\"1117\":{\"h\":\"2.2.1、缓存模型和思路\",\"t\":[\"标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。\"]},\"1118\":{\"h\":\"2.1.2、代码如下\",\"t\":[\"代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。\"]},\"1119\":{\"h\":\"2.3、缓存更新策略\",\"t\":[\"缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。\",\"**内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\",\"**超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存\",\"**主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\"]},\"1120\":{\"h\":\"2.3.1、数据库缓存不一致解决方案：\",\"t\":[\"由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:\",\"用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案\",\"Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\",\"Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理\",\"Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致\"]},\"1121\":{\"h\":\"2.3.2、数据库和缓存不一致采用什么方案\",\"t\":[\"综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题\",\"操作缓存和数据库时有三个问题需要考虑：\",\"如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来\",\"删除缓存还是更新缓存？\",\"更新缓存：每次更新数据库都更新缓存，无效写操作较多\",\"删除缓存：更新数据库时让缓存失效，查询时再更新缓存\",\"如何保证缓存与数据库的操作的同时成功或失败？\",\"单体系统，将缓存与数据库操作放在一个事务\",\"分布式系统，利用TCC等分布式事务方案\",\"应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\",\"先操作缓存还是先操作数据库？ \",\"先删除缓存，再操作数据库\",\"先操作数据库，再删除缓存\"]},\"1122\":{\"h\":\"2.4、实现商铺和缓存与数据库双写一致\",\"t\":[\"核心思路如下：\",\"修改ShopController中的业务逻辑，满足下面的需求：\",\"根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间\",\"根据id修改店铺时，先修改数据库，再删除缓存\",\"修改重点代码1：修改ShopServiceImpl的queryById方法\",\"设置redis缓存时添加过期时间\",\"@Override public Result getByIdWithRedis(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); // 2、判断是否存在 if (StrUtil.isNotBlank(shopMap)) { // 3、不为null且存在，直接返回 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); } // 4、不存在，根据id查询数据库 Shop shop = this.getById(id); if (ObjectUtil.isEmpty(shop)) { // 4.1、数据库不存在返回错误 return Result.fail(\\\"店铺不存在！\\\"); } // 4.2、数据库存在，写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, BeanUtil.beanToMap(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); // 5、返回 return Result.ok(shop); } \",\"修改重点代码2\",\"代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题\",\"@Override @Transactional public Result update(Shop shop) { Long id = shop.getId(); if (id == null) { return Result.fail(\\\"店铺id不能为空！\\\"); } // 1、更新数据库 this.updateById(shop); // 2、删除缓存 redisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id); return Result.ok(); } \"]},\"1123\":{\"h\":\"2.5、缓存穿透问题的解决思路\",\"t\":[\"缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\",\"常见的解决方案有两种：\",\"缓存空对象 \",\"优点：实现简单，维护方便\",\"缺点： \",\"额外的内存消耗\",\"可能造成短期的不一致\",\"布隆过滤 \",\"优点：内存占用较少，没有多余key\",\"缺点： \",\"实现复杂\",\"存在误判可能\",\"缓存空对象思路分析： 当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了\",\"布隆过滤： 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，\",\"假设布隆过滤器判断这个数据不存在，则直接返回\",\"这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突\"]},\"1124\":{\"h\":\"2.6、编码解决商品查询的缓存穿透问题：\",\"t\":[\"核心思路如下：\",\"在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的\",\"现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。\",\"private Shop queryWithPassThrough(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3、不为null且存在，直接返回 shop = JSONUtil.toBean(shopJson, Shop.class); return shop; } // 判断是否是key为\\\"\\\"的缓存（缓存穿透） if (shopJson != null) { return null; } // 4、不存在，根据id查询数据库 shop = this.getById(id); if (ObjectUtil.isEmpty(shop)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 4.1、数据库不存在返回错误 return null; } // 4.2、数据库存在，写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return shop; } \",\"小总结：\",\"缓存穿透产生的原因是什么？\",\"用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\",\"缓存穿透的解决方案有哪些？\",\"缓存null值\",\"布隆过滤\",\"增强id的复杂度，避免被猜测id规律\",\"做好数据的基础格式校验\",\"加强用户权限校验\",\"做好热点参数的限流\"]},\"1125\":{\"h\":\"2.7、缓存雪崩问题及解决思路\",\"t\":[\"缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\",\"解决方案：\",\"给不同的Key的TTL添加随机值\",\"利用Redis集群提高服务的可用性\",\"给缓存业务添加降级限流策略\",\"给业务添加多级缓存\"]},\"1126\":{\"h\":\"2.8、缓存击穿问题及解决思路\",\"t\":[\"缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\",\"常见的解决方案有两种：\",\"互斥锁\",\"逻辑过期\",\"逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大\",\"解决方案一、使用锁来解决：\",\"因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。\",\"假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\",\"解决方案二、逻辑过期方案\",\"方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。\",\"我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\",\"这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\",\"进行对比\",\"互斥锁方案： 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响\",\"逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦\"]},\"1127\":{\"h\":\"2.9、利用互斥锁解决缓存击穿问题\",\"t\":[\"核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询\",\"如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿\",\"操作锁的代码：\",\"核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。\",\"private boolean tryLock(String key) { Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, \\\"1\\\", 10, TimeUnit.SECONDS); // 防止装包以及拆包引发bug return BooleanUtil.isTrue(flag); } private void unlock(String key) { redisTemplate.delete(key); } \",\"操作代码：\",\"private Shop queryWithMutex(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3、不为null且存在，直接返回 shop = JSONUtil.toBean(shopJson, Shop.class); return shop; } // 判断是否是\\\"\\\"的缓存（缓存穿透） if (shopJson != null) { return null; } try { // 4、互斥锁实现缓存重建 // 4.1、获取互斥锁 boolean hasLock = tryLock(RedisConstants.LOCK_SHOP_KEY + id, RedisConstants.LOCK_SHOP_TTL); // 4.2、判断是否获取成功 if (!hasLock) { // 4.3、如果失败，则失眠并重试 Thread.sleep(50); return queryWithMutex(id); } // 4.4、成功，根据id查询数据库 shop = this.getById(id); // 模拟缓存重建延迟 Thread.sleep(200); if (ObjectUtil.isEmpty(shop)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 数据库不存在返回错误 return null; } redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); // 数据库存在，写入redis } catch (InterruptedException e) { throw new RuntimeException(e); } finally { // 释放互斥锁 unlock(RedisConstants.LOCK_SHOP_KEY + id); } return shop; } \"]},\"1128\":{\"h\":\"2.10、利用逻辑过期解决缓存击穿问题\",\"t\":[\"需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题\",\"思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\",\"如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你\",\"步骤一、\",\"新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。\",\"@Data public class RedisData<T> { /** * 逻辑过期时间 */ private LocalDateTime expireTime; private T data; } \",\"步骤二、\",\"在ShopServiceImpl 新增此方法，利用单元测试进行缓存预热\",\"public void saveShop2Redis(Long id, Long expireSeconds) { // 1、查询店铺数据 Shop shop = this.getById(id); // 2、封装逻辑过期时间 RedisData<Shop> redisData = new RedisData<>(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); // 3、写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData)); } \",\"在测试类中\",\"@Test public void testSaveShop() { shopService.saveShop2Redis(1L, 10L); } \",\"步骤三：正式代码\",\"ShopServiceImpl\",\"private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); private Shop queryWithLogicalExpire(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isBlank(shopJson)) { // 3、不存在，直接返回null return null; } // 4、命中，判断缓存是否过期（需要将json反序列化成对象） RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); LocalDateTime expireTime = redisData.getExpireTime(); // 5、判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 5.1、未过期，返回shop信息 return shop; } // 5.2、已过期，需要缓存重建 // 6、缓存重建 // 6.1、获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey, RedisConstants.LOCK_SHOP_TTL); // 6.2、判断锁是否获取成功 if (isLock) { // 6.3、成功，开启独立线程，开启缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -> { try { // 重建缓存 this.saveShop2Redis(id, 20L); } catch (Exception e) { throw new RuntimeException(e); } finally { // 释放锁 unlock(lockKey); } }); } // 6.4、返回过期的商铺信息 return shop; } \"]},\"1129\":{\"h\":\"2.11、封装Redis工具类\",\"t\":[\"基于StringRedisTemplate封装一个缓存工具类，满足下列需求：\",\"方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间\",\"方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓\",\"存击穿问题\",\"方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\",\"方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\",\"将逻辑进行封装\",\"@Slf4j @Component public class CacheClient { private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); private final StringRedisTemplate redisTemplate; public CacheClient(StringRedisTemplate redisTemplate) { this.redisTemplate = redisTemplate; } /** * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间 * * @param key 存储的key * @param value 存储的value * @param expireTime 过期时间 * @param timeUnit 过期时间单位 */ public <T> void set(String key, T value, Long expireTime, TimeUnit timeUnit) { redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), expireTime, timeUnit); } /** * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题 * * @param key 存储的key * @param value 存储的data * @param expireTime 逻辑过期时间 * @param timeUnit 逻辑过期时间单位 */ public <T> void setWithLogicExpire(String key, T value, Long expireTime, TimeUnit timeUnit) { RedisData<T> redisData = new RedisData<>(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(expireTime))); redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } /** * 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 * * @param keyPrefix key前缀 * @param id id * @param expireTime 过期时间 * @param timeUnit 过期时间单位 * @param type 返回值class类型 * @param dbFallback 用于数据库操作的回调函数 * @param <R> 返回值数据类型 * @param <ID> id数据类型 * @return R */ public <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Long expireTime, TimeUnit timeUnit, Class<R> type, Function<ID, R> dbFallback) { // 1、从redis查询商铺缓存 String key = keyPrefix + id; String json = redisTemplate.opsForValue().get(key); // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(json)) { // 3、不为null且存在，直接返回 return JSONUtil.toBean(json, type); } // 判断是否是key为\\\"\\\"的缓存（缓存穿透） if (json != null) { return null; } // 4、不存在，根据id查询数据库（通过定义回调函数，交给调用者自己处理） R r = dbFallback.apply(id); if (ObjectUtil.isEmpty(r)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(key, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 4.1、数据库不存在返回错误 return null; } // 4.2、数据库存在，写入redis this.set(key, r, expireTime, timeUnit); return r; } /** * 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题将逻辑进行封装 * * @param keyPrefix key前缀 * @param id id * @param time 逻辑过期时间 * @param timeUnit 逻辑过期时间单位 * @param type 返回值数据class类型 * @param dbRollback 操作数据库的回调函数 * @param <R> 返回值数据类型 * @param <ID> id数据类型 * @return r */ public <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Long time, TimeUnit timeUnit, Class<R> type, Function<ID, R> dbRollback) { // 1、从redis查询商铺缓存 String key = keyPrefix + id; String json = redisTemplate.opsForValue().get(key); // 2、判断缓存中是否存在 if (StrUtil.isBlank(json)) { // 3、不存在，直接返回null return null; } // 4、命中，判断缓存是否过期（需要将json反序列化成对象） RedisData redisData = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean(JSONUtil.toJsonStr(redisData.getData()), type); LocalDateTime expireTime = redisData.getExpireTime(); // 5、判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 5.1、未过期，返回shop信息 return r; } // 5.2、已过期，需要缓存重建 // 6、缓存重建 // 6.1、获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 6.2、判断锁是否获取成功 if (isLock) { // 6.3、成功，开启独立线程，开启缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -> { try { // 重建缓存 // 查数据库 R newR = dbRollback.apply(id); // 写入redis this.setWithLogicExpire(key, newR, time, timeUnit); } catch (Exception e) { throw new RuntimeException(e); } finally { // 释放锁 unlock(lockKey); } }); } // 6.4、返回过期的商铺信息 return r; } public <R, ID> R queryWithMutex( String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) { String key = keyPrefix + id; // 1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3.存在，直接返回 return JSONUtil.toBean(shopJson, type); } // 判断命中的是否是空值 if (shopJson != null) { // 返回一个错误信息 return null; } // 4.实现缓存重建 // 4.1.获取互斥锁 String lockKey = LOCK_SHOP_KEY + id; R r = null; try { boolean isLock = tryLock(lockKey); // 4.2.判断是否获取成功 if (!isLock) { // 4.3.获取锁失败，休眠并重试 Thread.sleep(50); return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit); } // 4.4.获取锁成功，根据id查询数据库 r = dbFallback.apply(id); // 5.不存在，返回错误 if (r == null) { // 将空值写入redis stringRedisTemplate.opsForValue().set(key, \\\"\\\", CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; } // 6.存在，写入redis this.set(key, r, time, unit); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { // 7.释放锁 unlock(lockKey); } // 8.返回 return r; } private boolean tryLock(String key) { Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, \\\"1\\\", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } private void unlock(String key) { redisTemplate.delete(key); } } \",\"在ShopServiceImpl 中\",\"@Override public Result getByIdWithRedis(Long id) { // 缓存穿透 // Shop shop = queryWithPassThrough(id); // Shop shop = cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, // RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES, // Shop.class, this::getById); // 缓存击穿 // Shop shop = queryWithMutex(id); // cacheClient. // 逻辑过期 Shop shop = cacheClient.queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY, id, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES, Shop.class, this::getById); // Shop shop = queryWithLogicalExpire(id); if (shop == null) { return Result.fail(\\\"店铺不存在！\\\"); } return Result.ok(shop); } \"]},\"1130\":{\"h\":\"3、优惠卷秒杀\"},\"1131\":{\"h\":\"3.1、全局唯一ID\",\"t\":[\"每个店铺都可以发布优惠券：\",\"当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：\",\"id的规律性太明显\",\"受单表数据量的限制\",\"场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。\",\"场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。\",\"全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：\",\"为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：\",\"ID的组成部分：符号位：1bit，永远为0\",\"时间戳：31bit，以秒为单位，可以使用69年\",\"序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID\"]},\"1132\":{\"h\":\"3.2、Redis实现全局唯一Id\",\"t\":[\"@Component public class RedisIdWorker { /** * 开始时间戳 2022-1-1 00:00:00 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } // 通过不同的前缀来区分不同业务的id public long nextId(String keyPrefix) { // 1.生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; // 2.生成序列号 // 2.1.获取当前日期，精确到天（每天使用一个key） String date = now.format(DateTimeFormatter.ofPattern(\\\"yyyy:MM:dd\\\")); // 2.2.自增长 long count = stringRedisTemplate.opsForValue().increment(\\\"icr:\\\" + keyPrefix + \\\":\\\" + date); // 3.拼接并返回 return timestamp << COUNT_BITS | count; } } \",\"测试类\",\"知识小贴士：关于countdownlatch\",\"countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题\",\"我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch\",\"CountDownLatch 中有两个最重要的方法\",\"1、countDown\",\"2、await\",\"await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch 维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。\",\"@Test void testIdWorker() throws InterruptedException { CountDownLatch latch = new CountDownLatch(300); Runnable task = () -> { for (int i = 0; i < 100; i++) { long id = redisIdWorker.nextId(\\\"order\\\"); System.out.println(\\\"id = \\\" + id); } latch.countDown(); }; long begin = System.currentTimeMillis(); for (int i = 0; i < 300; i++) { es.submit(task); } latch.await(); long end = System.currentTimeMillis(); System.out.println(\\\"time = \\\" + (end - begin)); } \"]},\"1133\":{\"h\":\"3.3、添加优惠卷\",\"t\":[\"每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：\",\"tb_voucher：优惠券的基本信息，优惠金额、使用规则等 tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息\",\"平价卷由于优惠力度并不是很大，所以是可以任意领取\",\"而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段\",\"**新增普通卷代码： **VoucherController\",\"@PostMapping public Result addVoucher(@RequestBody Voucher voucher) { voucherService.save(voucher); return Result.ok(voucher.getId()); } \",\"新增秒杀卷代码：\",\"VoucherController\",\"@PostMapping(\\\"seckill\\\") public Result addSeckillVoucher(@RequestBody Voucher voucher) { voucherService.addSeckillVoucher(voucher); return Result.ok(voucher.getId()); } \",\"VoucherServiceImpl\",\"@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); // 保存秒杀库存到Redis中 stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); } \"]},\"1134\":{\"h\":\"3.4、实现秒杀下单\",\"t\":[\"下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可\",\"秒杀下单应该思考的内容：\",\"下单时需要判断两点：\",\"秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\",\"库存是否充足，不足则无法下单\",\"下单核心逻辑分析：\",\"当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件\",\"比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。\",\"VoucherOrderServiceImpl\",\"@Override public Result seckillVoucher(Long voucherId) { // 1、查询优惠券 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); // 2、判断秒杀是否开始 if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) { return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3、判断秒杀是否已经结束 if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) { return Result.fail(\\\"秒杀已经结束！\\\"); } // 4、判断库存是否充足 if (seckillVoucher.getStock() <= 0) { return Result.fail(\\\"库存不足！\\\"); } // 5、扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") .eq(\\\"voucher_id\\\", voucherId) .update(); if (!success) { return Result.fail(\\\"库存不足！\\\"); } // 6、创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 6.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 6.2.用户id Long userId = UserHolder.getUser().getId(); voucherOrder.setUserId(userId); // 6.3.代金券id voucherOrder.setVoucherId(voucherId); this.save(voucherOrder); return Result.ok(orderId); } \"]},\"1135\":{\"h\":\"3.5、库存超卖问题分析\",\"t\":[\"有关超卖问题分析：在我们原有代码中是这么写的\",\" if (voucher.getStock() < 1) { // 库存不足 return Result.fail(\\\"库存不足！\\\"); } //5，扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update(); if (!success) { //扣减库存 return Result.fail(\\\"库存不足！\\\"); } \",\"假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。\",\"超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：\",\"悲观锁：\",\"悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等\",\"乐观锁：\",\"乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas\",\"乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值\",\"其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\",\"int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; \",\"课程中的使用方式：\",\"课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功\"]},\"1136\":{\"h\":\"3.6、乐观锁解决超卖问题\",\"t\":[\"修改代码方案一、\",\"VoucherOrderServiceImpl 在扣减库存时，改为：\",\"boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") //set stock = stock -1 .eq(\\\"voucher_id\\\", voucherId).eq(\\\"stock\\\",voucher.getStock()).update(); //where id = ？ and stock = ? \",\"以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败\",\"修改代码方案二、\",\"之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可\",\"boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update().gt(\\\"stock\\\",0); //where id = ? and stock > 0 \",\"知识小扩展：\",\"针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决\",\"Java8 提供的一个对AtomicLong改进后的一个类，LongAdder\",\"大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好\",\"所以利用这么一个类，LongAdder来进行优化\",\"如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值\"]},\"1137\":{\"h\":\"3.7、优惠券秒杀-一人一单\",\"t\":[\"需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单\",\"现在的问题在于：\",\"优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单\",\"具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单\",\"VoucherOrderServiceImpl\",\"初步代码：增加一人一单逻辑\",\"@Override public Result seckillVoucher(Long voucherId) { // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) { // 尚未开始 return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) { // 尚未开始 return Result.fail(\\\"秒杀已经结束！\\\"); } // 4.判断库存是否充足 if (voucher.getStock() < 1) { // 库存不足 return Result.fail(\\\"库存不足！\\\"); } // 5.一人一单逻辑 // 5.1.用户id Long userId = UserHolder.getUser().getId(); int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } //6，扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update(); if (!success) { //扣减库存 return Result.fail(\\\"库存不足！\\\"); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); } \",\"**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作\",\"**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁\",\"@Transactional public synchronized Result createVoucherOrder(Long voucherId) { Long userId = UserHolder.getUser().getId(); // 5.1.查询订单 int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") // set stock = stock - 1 .eq(\\\"voucher_id\\\", voucherId).gt(\\\"stock\\\", 0) // where id = ? and stock > 0 .update(); if (!success) { // 扣减失败 return Result.fail(\\\"库存不足！\\\"); } // 7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 7.2.用户id voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); // 7.返回订单id return Result.ok(orderId); } \",\"，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为： intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法\",\"@Transactional public Result createVoucherOrder(Long voucherId) { Long userId = UserHolder.getUser().getId(); synchronized(userId.toString().intern()){ // 5.1.查询订单 int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") // set stock = stock - 1 .eq(\\\"voucher_id\\\", voucherId).gt(\\\"stock\\\", 0) // where id = ? and stock > 0 .update(); if (!success) { // 扣减失败 return Result.fail(\\\"库存不足！\\\"); } // 7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 7.2.用户id voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); // 7.返回订单id return Result.ok(orderId); } } \",\"但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：\",\"在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度\",\"Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { return this.createVoucherOrder(voucherId, userId); } \",\"但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务\",\"synchronized (userId.toString().intern()) { // 获取代理对象（事务） IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId, userId); } \",\"除此之外还需要引入aspectj依赖，以及在启动类添加配置\",\"<dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> </dependency> \",\"@EnableAspectJAutoProxy(exposeProxy = true) \"]},\"1138\":{\"h\":\"3.8、集群环境下的并发问题\",\"t\":[\"通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。\",\"1、我们将服务启动两份，端口分别为8081和8082：\",\"2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：\",\"具体操作(略)\",\"有关锁失效原因分析\",\"由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。\"]},\"1139\":{\"h\":\"4、分布式锁\"},\"1140\":{\"h\":\"4.1、基本原理和实现方式对比\",\"t\":[\"分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。\",\"分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路\",\"那么分布式锁他应该满足一些什么样的条件呢？\",\"可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思\",\"互斥：互斥是分布式锁的最基本的条件，使得程序串行执行\",\"高可用：程序不易崩溃，时时刻刻都保证较高的可用性\",\"高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能\",\"安全性：安全也是程序中必不可少的一环\",\"常见的分布式锁有三种\",\"Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见\",\"Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁\",\"Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述\",\"MySQL\",\"Redis\",\"Zookeeper\",\"互斥\",\"利用mysql本身的互斥锁机制\",\"利用setnx这样的互斥命令\",\"利用节点的唯一性和有序性实现互斥\",\"高可用\",\"好\",\"好\",\"好\",\"高性能\",\"一般\",\"好\",\"一般\",\"安全性\",\"断开连接，自动释放锁\",\"利用锁超时时间，到期释放\",\"临时节点，断开连接自动释放\"]},\"1141\":{\"h\":\"4.2、Redis分布式锁的实现核心思路\",\"t\":[\"实现分布式锁时需要实现的两个基本方法：\",\"获取锁：\",\"互斥：确保只能有一个线程获取锁\",\"非阻塞：尝试一次，成功返回true，失败返回false\",\"# 添加锁，NX是互斥，EX是设置超时时间 SET lock thread1 NX EX 10 # 下面方法如果在俩个操作之间服务宕机了，依然会有bug SETNX lock thread1 # 两个操作不具备原子性，这边有可能出bug EXPIRE lock 10 \",\"释放锁：\",\"手动释放\",\"超时释放：获取锁时添加一个超时时间\",\"# 释放锁，删除即可 DEL key \",\"核心思路：\",\"我们利用redis 的setnx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可\"]},\"1142\":{\"h\":\"4.3、实现分布式锁版本一\",\"t\":[\"加锁逻辑\",\"锁的基本接口\",\"public interface ILock { /** * 尝试获取锁 * * @param timeoutSec 锁持有的超时事件，过期后自动释放 * @return true代表获取锁成功，false代表获取锁失败 */ boolean tryLock(long timeoutSec); /** * 释放锁 */ void unlock(); } \",\"SimpleRedisLock\",\"利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性\",\"private static final String KEY_PREFIX=\\\"lock:\\\" @Override public boolean tryLock(long timeoutSec) { // 获取当前线程的ID。 long id = Thread.currentThread().getId(); // 如果Redis中不存在指定的键，则尝试设置一个值。 Boolean success = redisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, String.valueOf(id), timeoutSec, TimeUnit.SECONDS); // 如果成功设置值，则返回true；否则返回false。 return Boolean.TRUE.equals(success); } \",\"释放锁逻辑\",\"SimpleRedisLock\",\"释放锁，防止删除别人的锁\",\"@Override public void unlock() { redisTemplate.delete(KEY_PREFIX + name); } \",\"修改业务代码\",\"@Override public Result seckillVoucher(Long voucherId) { // 1、查询优惠券 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); // 2、判断秒杀是否开始 if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) { return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3、判断秒杀是否已经结束 if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) { return Result.fail(\\\"秒杀已经结束！\\\"); } // 4、判断库存是否充足 if (seckillVoucher.getStock() <= 0) { return Result.fail(\\\"库存不足！\\\"); } // 5.1.用户id Long userId = UserHolder.getUser().getId(); // 创建 SimpleRedisLock 实例 SimpleRedisLock lock = new SimpleRedisLock(\\\"order:\\\" + userId, redisTemplate); // 尝试获取锁 boolean isLock = lock.tryLock(1200); // 如果获取锁失败，返回错误信息 if (!isLock) { return Result.fail(\\\"不允许重复下单\\\"); } try { // 获取代理对象（事务） IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); // 调用代理对象的创建代金券订单方法 return proxy.createVoucherOrder(voucherId, userId); } finally { // 释放锁 lock.unlock(); } } \"]},\"1143\":{\"h\":\"4.4、Redis分布式锁误删情况说明\",\"t\":[\"逻辑说明：\",\"持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明\",\"解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。\"]},\"1144\":{\"h\":\"4.5、解决Redis分布式锁误删问题\",\"t\":[\"需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致\",\"如果一致则释放锁\",\"如果不一致则不释放锁\",\"核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。\",\"具体代码如下：加锁\",\"private static final String ID_PREFIX = UUID.randomUUID().toString(true) + \\\"-\\\"; @Override public boolean tryLock(long timeoutSec) { // 获取当前线程的ID。 String threadId = ID_PREFIX + Thread.currentThread().getId(); // 如果Redis中不存在指定的键，则尝试设置一个值。 Boolean success = redisTemplate.opsForValue() .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS); // 如果成功设置值，则返回true；否则返回false。 return Boolean.TRUE.equals(success); } \",\"释放锁\",\"@Override public void unlock() { // 获取当前线程的ID String threadId = ID_PREFIX + Thread.currentThread().getId(); // 获取缓存的ID String cacheId = redisTemplate.opsForValue().get(KEY_PREFIX + name); // 如果缓存的ID和当前线程的ID相同，则删除缓存 if (threadId.equals(cacheId)) { redisTemplate.delete(KEY_PREFIX + name); } } \",\"有关代码实操说明：\",\"在我们修改完此处代码后，我们重启工程，然后启动两个线程，第一个线程持有锁后，手动释放锁，第二个线程 此时进入到锁内部，再放行第一个线程，此时第一个线程由于锁的value值并非是自己，所以不能释放锁，也就无法删除别人的锁，此时第二个线程能够正确释放锁，通过这个案例初步说明我们解决了锁误删的问题。\"]},\"1145\":{\"h\":\"4.6、分布式锁的原子性问题\",\"t\":[\"更为极端的误删逻辑说明：\",\"线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，\"]},\"1146\":{\"h\":\"4.7、Lua脚本解决多条命令原子性问题\",\"t\":[\"Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：https://www.runoob.com/lua/lua-tutorial.html, 这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁、比锁、删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求，并不需要大家过于精通， 只需要知道他有什么作用即可。\",\"这里重点介绍Redis提供的调用函数，语法如下：\",\"redis.call('命令名称', 'key', '其它参数', ...) \",\"例如，我们要执行set name jack，则脚本是这样：\",\"# 执行 set name jack redis.call('set', 'name', 'jack') \",\"例如，我们要先执行set name Rose，再执行get name，则脚本如下：\",\"# 先执行 set name jack redis.call('set', 'name', 'Rose') # 再执行 get name local name = redis.call('get', 'name') # 返回 return name \",\"写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：\",\"例如，我们要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下：\",\"如果脚本中的key、value不想写死，可以作为参数传递。key类型参数会放入KEYS数组，其它参数会放入ARGV数组，在脚本中可以从KEYS和ARGV数组获取这些参数：\",\"接下来我们来回一下我们释放锁的逻辑：\",\"释放锁的业务流程是这样的\",\"1、获取锁中的线程标示 2、判断是否与指定的标示（当前线程标示）一致 3、如果一致则释放锁（删除） 4、如果不一致则什么都不做 \",\"如果用Lua脚本来表示则是这样的：\",\"最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样\",\"-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示 -- 获取锁中的标示，判断是否与当前线程标示一致 if (redis.call('GET', KEYS[1]) == ARGV[1]) then -- 一致，则删除锁 return redis.call('DEL', KEYS[1]) end -- 不一致，则直接返回 return 0 \"]},\"1147\":{\"h\":\"4.8、利用Java代码调用Lua脚本改造分布式锁\",\"t\":[\"lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。\",\"我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股\",\"Java代码\",\"private static final DefaultRedisScript<Long> UNLOCK_SCRIPT; static { UNLOCK_SCRIPT = new DefaultRedisScript<>(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\\\"unlock.lua\\\")); UNLOCK_SCRIPT.setResultType(Long.class); } public void unlock() { // 调用lua脚本 redisTemplate.execute( UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + name), ID_PREFIX + Thread.currentThread().getId()); } \",\"经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~\",\"小总结：\",\"基于Redis的分布式锁实现思路：\",\"利用set nx ex获取锁，并设置过期时间，保存线程标示\",\"释放锁时先判断线程标示是否与自己一致，一致则删除锁 \",\"特性： \",\"利用set nx满足互斥性\",\"利用set ex保证故障时锁依然能释放，避免死锁，提高安全性\",\"利用Redis集群保证高可用和高并发特性\",\"笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题\",\"但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个 30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦\",\"测试逻辑：\",\"第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行 lua 来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。\"]},\"1148\":{\"h\":\"5、分布式锁-Redisson\"},\"1149\":{\"h\":\"5.1、分布式锁-Redisson 功能介绍\",\"t\":[\"基于 setnx 实现的分布式锁存在下面的问题：\",\"重入问题：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如 HashTable 这样的代码中，他的方法都是使用 synchronized 修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的 synchronized 和 Lock 锁都是可重入的。\",\"不可重试：是指目前的分布式获取锁只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。\",\"超时释放： 我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了 lua 表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患\",\"主从一致性： 如果 Redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。\",\"那么什么是 Redisson 呢\",\"Redisson 是一个在 Redis 的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。\",\"Redisson 提供了分布式锁的多种多样的功能\"]},\"1150\":{\"h\":\"5.2、分布式锁-Redisson 快速入门\",\"t\":[\"引入依赖：\",\"<dependency> <groupId>org.redisson</groupId> <artifactId>redisson</artifactId> <version>3.13.6</version> </dependency> \",\"配置 Redisson 客户端：\",\"@Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient(){ // 配置 Config config = new Config(); config.useSingleServer().setAddress(\\\"redis://192.168.150.101:6379\\\") .setPassword(\\\"123321\\\"); // 创建RedissonClient对象 return Redisson.create(config); } } \",\"如何使用 Redisson 的分布式锁\",\"@Resource private RedissionClient redissonClient; @Test void testRedisson() throws Exception{ //获取锁(可重入)，指定锁的名称 RLock lock = redissonClient.getLock(\\\"anyLock\\\"); //尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位 boolean isLock = lock.tryLock(1,10,TimeUnit.SECONDS); //判断获取锁成功 if(isLock){ try{ System.out.println(\\\"执行业务\\\"); }finally{ //释放锁 lock.unlock(); } } } \",\"在 VoucherOrderServiceImpl\",\"注入RedissonClient\",\"@Resource private RedissonClient redissonClient; @Override public Result seckillVoucher(Long voucherId) { // 1、查询优惠券 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); // 2、判断秒杀是否开始 if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) { return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3、判断秒杀是否已经结束 if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) { return Result.fail(\\\"秒杀已经结束！\\\"); } // 4、判断库存是否充足 if (seckillVoucher.getStock() <= 0) { return Result.fail(\\\"库存不足！\\\"); } // 5.1.用户id Long userId = UserHolder.getUser().getId(); // 创建 SimpleRedisLock 实例 // SimpleRedisLock lock = new SimpleRedisLock(\\\"order:\\\" + userId, redisTemplate); RLock lock = redissonClient.getLock(\\\"lock:order:\\\" + userId); // 尝试获取锁 boolean isLock = lock.tryLock(); // 如果获取锁失败，返回错误信息 if (!isLock) { return Result.fail(\\\"不允许重复下单\\\"); } try { // 获取代理对象（事务） IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); // 调用代理对象的创建代金券订单方法 return proxy.createVoucherOrder(voucherId, userId); } finally { // 释放锁 lock.unlock(); } } \"]},\"1151\":{\"h\":\"5.3、分布式锁-Redisson 可重入锁原理\",\"t\":[\"在 Lock 锁中，他是借助于底层的一个 volatile 的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么 state=0，假如有人持有这把锁，那么 state=1，如果持有这把锁的人再次持有这把锁，那么 state 就会 +1 ，如果是对于 synchronized 而言，他在 c 语言代码中会有一个 count，原理和 state 类似，也是重入一次就加一，释放一次就 -1 ，直到减少成 0 时，表示当前这把锁没有被人持有。\",\"在 Redisson 中，我们的也支持支持可重入锁。\",\"在分布式锁中，他采用 hash 结构用来存储锁，其中大 key 表示表示这把锁是否存在，用小 key 表示当前这把锁被哪个线程持有。接下来我们一起分析一下当前的这个 lua 表达式\",\"下面的 lua 脚本一共有3个参数：\",\"KEYS[1]：锁名称 ARGV[1]：线程唯一标识 ARGV[2]：锁失效时间 \",\"-- 判断是否存在 if (redis.call('exists', KEYS[1]) == 0) then -- 不存在，则创建并获取锁 redis.call('hset', KEYS[1], ARGV[1], 1); -- 设置有效期 redis.call('pexpire', KEYS[1], ARGV[2]); -- 返回结果 return 1; end; -- 锁已经存在，判断threadId是否是自己 if (redis.call('hexists', KEYS[1], ARGV[1]) == 1) then -- threadId是自己，获取锁，重入次数 +1 redis.call('hincrby', KEYS[1], ARGV[1], 1); -- 设置有效期 redis.call('pexpire', KEYS[1], ARGV[2]); -- 返回结果 return 1; end; -- 代码走到这里，说明锁的不是自己，获取锁失败 return 0； \",\"-- 判断当前锁是否还是被自己所持有 if (redis.call('HEXISTS', KEYS[1], ARGV[1]) == 0) then return nil; end; -- 是自己的锁，则重入次数-1 local count = redis.call('HINCRBY', KEYS[1], ARGV[1], -1); -- 判断重入次数是否已经为0 if (count > 0) then -- 大于0说明不能释放锁，重置有效期然后返回 redis.call('EXPIRE', KEYS[1], ARGV[2]); return nil; else -- 等于0说明可以释放锁，直接删除 redis.call('DEL', key); return nil; end; \"]},\"1152\":{\"h\":\"5.4、分布式锁-Redisson 锁重试和 WatchDog 机制\",\"t\":[\"说明：由于课程中已经说明了有关 tryLock 的源码解析以及其看门狗原理，所以笔者在这里给大家分析 lock() 方法的源码解析，希望大家在学习过程中，能够掌握更多的知识\",\"抢锁过程中，获得当前线程，通过 tryAcquire 进行抢锁，该抢锁逻辑和之前逻辑相同\",\"1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回 null\",\"2、判断当前这把锁是否是属于当前线程，如果是，则返回 null\",\"所以如果返回是 null，则代表着当前这哥们已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，同学们可以自行往下翻一点点，你能发现有个 while(true) 再次进行 tryAcquire 进行抢锁\",\"long threadId = Thread.currentThread().getId(); Long ttl = tryAcquire(-1, leaseTime, unit, threadId); // lock acquired if (ttl == null) { return; } \",\"接下来会有一个条件分支，因为 lock 方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则 leaseTime 是他本身，所以如果传入了参数，此时 leaseTime != -1 则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑\",\"if (leaseTime != -1) { return tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG); } \",\"如果是没有传入时间，则此时也会进行抢锁， 而且抢锁时间是默认看门狗时间 commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()\",\"ttlRemainingFuture.onComplete((ttlRemaining, e) 这句话相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程\",\"RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(waitTime, commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); ttlRemainingFuture.onComplete((ttlRemaining, e) -> { if (e != null) { return; } // lock acquired if (ttlRemaining == null) { scheduleExpirationRenewal(threadId); } }); return ttlRemainingFuture; \",\"此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（） 此方法\",\"Method( new TimerTask() {},参数2 ，参数3 )\",\"指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情\",\"因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约\",\"那么大家可以想一想，假设我们的线程出现了宕机他还会续约吗？当然不会，因为没有人再去调用renewExpiration这个方法，所以等到时间之后自然就释放了。\",\"private void renewExpiration() { ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ee == null) { return; } Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName()); if (ent == null) { return; } Long threadId = ent.getFirstThreadId(); if (threadId == null) { return; } RFuture<Boolean> future = renewExpirationAsync(threadId); future.onComplete((res, e) -> { if (e != null) { log.error(\\\"Can't update lock \\\" + getName() + \\\" expiration\\\", e); return; } if (res) { // reschedule itself renewExpiration(); } }); } }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); ee.setTimeout(task); } \"]},\"1153\":{\"h\":\"5.5、分布式锁-redission锁的MutiLock原理\",\"t\":[\"为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例\",\"此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。\",\"为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。\",\"那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明\",\"当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.\"]},\"1154\":{\"h\":\"6、秒杀优化\"},\"1155\":{\"h\":\"6.1、秒杀优化-异步秒杀思路\",\"t\":[\"我们来回顾一下下单流程\",\"当用户发起请求，此时会请求 nginx，nginx 会访问到 tomcat，而 tomcat 中的程序，会进行串行操作，分成如下几个步骤\",\"1、查询优惠券 2、判断秒杀库存是否足够 3、查询订单 4、校验是否是一人一单 5、扣减库存 6、创建订单 \",\"在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行得很慢，所以我们需要异步程序执行，那么如何加速呢？\",\"在这里笔者想给大家分享一下课程内没有的思路，看看有没有小伙伴这么想，比如，我们可以不可以使用异步编排来做，或者说我开启N多线程，N多个线程，一个线程执行查询优惠卷，一个执行判断扣减库存，一个去创建订单等等，然后再统一做返回，这种做法和课程中有哪种好呢？答案是课程中的好，因为如果你采用我刚说的方式，如果访问的人很多，那么线程池中的线程可能一下子就被消耗完了，而且你使用上述方案，最大的特点在于，你觉得时效性会非常重要，但是你想想是吗？并不是，比如我只要确定他能做这件事，然后我后边慢慢做就可以了，我并不需要他一口气做完这件事，所以我们应当采用的是课程中，类似消息队列的方式来完成我们的需求，而不是使用线程池或者是异步编排的方式来完成这个需求。\",\"优化方案：我们将耗时比较短的逻辑判断放入到 redis 中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行queue里边的消息，这样程序不就超级快了吗？而且也不用担心线程池消耗殆尽的问题，因为这里我们的程序中并没有手动使用任何线程池，当然这里边有两个难点：\",\"第一个难点是我们怎么在 redis 中去快速校验一人一单，还有库存判断。\",\"第二个难点是由于我们校验和 tomcat 下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在 redis 操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步 queue 中去，后续操作中，可以通过这个 id 来查询我们 tomcat 中的下单逻辑是否完成了。\",\"我们现在来看看整体思路：当用户下单之后，判断库存是否充足只需要导 redis 中去根据 key 找对应的 value 是否大于 0 即可，如果不充足，则直接结束，如果充足，继续在 redis 中判断用户是否可以下单，如果 set 集合中没有这条数据，说明他可以下单，如果 set 集合中没有这条记录，则将 userId 和优惠卷存入到 redis 中，并且返回 0，整个过程需要保证是原子性的，我们可以使用 lua 来操作。\",\"当以上判断逻辑走完之后，我们可以判断当前 redis 中返回的结果是否是 0 ，如果是 0，则表示可以下单，则将之前说的信息存入到到 queue 中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单 id 来判断是否下单成功。\"]},\"1156\":{\"h\":\"6.2、秒杀优化-Redis 完成秒杀资格判断\",\"t\":[\"需求：\",\"新增秒杀优惠券的同时，将优惠券信息保存到Redis中\",\"基于 Lua 脚本，判断秒杀库存、一人一单，决定用户是否抢购成功（抢购成功需要将用户 id 存入 redis 中的与秒杀优惠券相关的订单 key 中）\",\"如果抢购成功，将优惠券id和用户id封装后存入阻塞队列\",\"开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能\",\"VoucherServiceImpl\",\"@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存代金券 save(voucher); // 创建秒杀代金券对象 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); // 保存秒杀代金券 seckillVoucherService.save(seckillVoucher); // 设置Redis中的秒杀库存 redisTemplate.opsForValue() .set(RedisConstants.SECKILL_STOCK_KEY + voucher.getId(), String.valueOf(voucher.getStock())); } \",\"完整 lua 表达式\",\"-- 1.参数列表 -- 1.1.优惠券id local voucherId = ARGV[1] -- 1.2.用户id local userId = ARGV[2] -- 1.3.订单id local orderId = ARGV[3] -- 2.数据key -- 2.1.库存key local stockKey = 'seckill:stock:' .. voucherId -- 2.2.订单key local orderKey = 'seckill:order:' .. voucherId -- 3.脚本业务 -- 3.1.判断库存是否充足 get stockKey if(tonumber(redis.call('get', stockKey)) <= 0) then -- 3.2.库存不足，返回1 return 1 end -- 3.2.判断用户是否下单 SISMEMBER orderKey userId if(redis.call('sismember', orderKey, userId) == 1) then -- 3.3.存在，说明是重复下单，返回2 return 2 end -- 3.4.扣库存 incrby stockKey -1 redis.call('incrby', stockKey, -1) -- 3.5.下单（保存用户）sadd orderKey userId redis.call('sadd', orderKey, userId) return 0 \",\"当以上 lua 表达式执行完毕后，剩下的就是根据步骤3,4来执行我们接下来的任务了\",\"VoucherOrderServiceImpl\",\"private static final DefaultRedisScript<Long> SECKILL_SCRIPT; static { SECKILL_SCRIPT = new DefaultRedisScript<>(); SECKILL_SCRIPT.setLocation(new ClassPathResource(\\\"script/seckill.lua\\\")); SECKILL_SCRIPT.setResultType(Long.class); } @Override public Result seckillVoucher(Long voucherId) { Long userId = UserHolder.getUser().getId(); Long result = redisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), String.valueOf(voucherId), String.valueOf(userId)); assert result != null; if (result.intValue() != 0) { return Result.fail(result == 1 ? \\\"优惠券库存不足！\\\" : \\\"不能重复下单！\\\"); } // todo 保存到阻塞队列 long orderId = redisIdWorker.nextId(\\\"order\\\"); return Result.ok(orderId); } \"]},\"1157\":{\"h\":\"6.3、秒杀优化-基于阻塞队列实现秒杀优化\",\"t\":[\"VoucherOrderServiceImpl\",\"修改下单动作，现在我们去下单时，是通过 lua 表达式去原子执行判断逻辑，如果判断我出来不为 0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是 0，则把下单的逻辑保存到队列中去，然后异步执行\",\"TODO\",\"采用消息队列对阻塞队列进行改写\",\"//异步处理线程池 private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor(); //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的 @PostConstruct private void init() { SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); } // 用于线程池处理的任务 // 当初始化完毕后，就会去从对列中去拿信息 private class VoucherOrderHandler implements Runnable{ @Override public void run() { while (true){ try { // 1.获取队列中的订单信息 VoucherOrder voucherOrder = orderTasks.take(); // 2.创建订单 handleVoucherOrder(voucherOrder); } catch (Exception e) { log.error(\\\"处理订单异常\\\", e); } } } } private void handleVoucherOrder(VoucherOrder voucherOrder) { //1.获取用户 Long userId = voucherOrder.getUserId(); // 2.创建锁对象 RLock redisLock = redissonClient.getLock(\\\"lock:order:\\\" + userId); // 3.尝试获取锁 boolean isLock = redisLock.lock(); // 4.判断是否获得锁成功 if (!isLock) { // 获取锁失败，直接返回失败或者重试 log.error(\\\"不允许重复下单！\\\"); return; } try { //注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效 proxy.createVoucherOrder(voucherOrder); } finally { // 释放锁 redisLock.unlock(); } } private BlockingQueue<VoucherOrder> orderTasks =new ArrayBlockingQueue<>(1024 * 1024); @Override public Result seckillVoucher(Long voucherId) { Long userId = UserHolder.getUser().getId(); long orderId = redisIdWorker.nextId(\\\"order\\\"); // 1.执行lua脚本 Long result = redisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(orderId) ); int r = result.intValue(); // 2.判断结果是否为0 if (r != 0) { // 2.1.不为0 ，代表没有购买资格 return Result.fail(r == 1 ? \\\"库存不足\\\" : \\\"不能重复下单\\\"); } VoucherOrder voucherOrder = new VoucherOrder(); // 2.3.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 2.4.用户id voucherOrder.setUserId(userId); // 2.5.代金券id voucherOrder.setVoucherId(voucherId); // 2.6.放入阻塞队列 orderTasks.add(voucherOrder); //3.获取代理对象 proxy = (IVoucherOrderService)AopContext.currentProxy(); //4.返回订单id return Result.ok(orderId); } @Transactional public void createVoucherOrder(VoucherOrder voucherOrder) { Long userId = voucherOrder.getUserId(); // 5.1.查询订单 int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherOrder.getVoucherId()).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 log.error(\\\"用户已经购买过了\\\"); return ; } // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") // set stock = stock - 1 .eq(\\\"voucher_id\\\", voucherOrder.getVoucherId()).gt(\\\"stock\\\", 0) // where id = ? and stock > 0 .update(); if (!success) { // 扣减失败 log.error(\\\"库存不足\\\"); return ; } save(voucherOrder); } \",\"小总结：\",\"秒杀业务的优化思路是什么？\",\"先利用 redis 完成库存余量、一人一单判断，完成抢单业务\",\"再将下单业务放入阻塞队列，利用独立线程异步下单\",\"基于阻塞队列的异步秒杀存在哪些问题？ \",\"内存限制问题\",\"数据安全问题\"]},\"1158\":{\"h\":\"7、达人探店\"},\"1159\":{\"h\":\"7.1、达人探店-发布探店笔记\",\"t\":[\"发布探店笔记\",\"探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个： tb_blog：探店笔记表，包含笔记中的标题、文字、图片等 tb_blog_comments：其他用户对探店笔记的评价\",\"具体发布流程\",\"图片上传接口\",\"@Slf4j @RestController @RequestMapping(\\\"upload\\\") public class UploadController { @PostMapping(\\\"blog\\\") public Result uploadImage(@RequestParam(\\\"file\\\") MultipartFile image) { try { // 获取原始文件名称 String originalFilename = image.getOriginalFilename(); // 生成新文件名 String fileName = createNewFileName(originalFilename); // 保存文件 image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName)); // 返回结果 log.debug(\\\"文件上传成功，{}\\\", fileName); return Result.ok(fileName); } catch (IOException e) { throw new RuntimeException(\\\"文件上传失败\\\", e); } } } \",\"注意：同学们在操作时，需要修改 SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在 nginx 上或者是云存储上。\",\"BlogController\",\"@RestController @RequestMapping(\\\"/blog\\\") public class BlogController { @Resource private IBlogService blogService; @PostMapping public Result saveBlog(@RequestBody Blog blog) { // 获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 保存探店博文 blogService.save(blog); // 返回id return Result.ok(blog.getId()); } } \"]},\"1160\":{\"h\":\"7.2、达人探店-查看探店笔记\",\"t\":[\"实现查看发布探店笔记的接口\",\"实现代码：\",\"BlogServiceImpl\",\"@Override public Result queryBlogById(Long id) { // 1.查询blog Blog blog = getById(id); if (blog == null) { return Result.fail(\\\"Blog不存在！\\\"); } // 2.查询blog有关的用户 queryBlogUser(blog); return Result.ok(blog); } private void queryBlogUser(Blog blog) { User user = userService.getById(blog.getUserId()); blog.setName(user.getNickName()); blog.setIcon(user.getIcon()); } \"]},\"1161\":{\"h\":\"7.3、达人探店-点赞功能\",\"t\":[\"初始代码\",\"@GetMapping(\\\"/likes/{id}\\\") public Result queryBlogLikes(@PathVariable(\\\"id\\\") Long id) { //修改点赞数量 blogService.update().setSql(\\\"liked = liked +1 \\\").eq(\\\"id\\\",id).update(); return Result.ok(); } \",\"问题分析：这种方式会导致一个用户无限点赞，明显是不合理的\",\"造成这个问题的原因是，我们现在的逻辑，发起请求只是给数据库 +1，所以才会出现这个问题\",\"完善点赞功能\",\"需求：\",\"同一个用户只能点赞一次，再次点击则取消点赞\",\"如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）\",\"实现步骤：\",\"给Blog类中添加一个isLike字段，标示是否被当前用户点赞\",\"修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1\",\"修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段\",\"修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段\",\"为什么采用set集合：\",\"因为我们的数据是不能重复的，当用户操作过之后，无论他怎么操作，都是\",\"具体步骤：\",\"1、在Blog 添加一个字段\",\"@TableField(exist = false) private Boolean isLike; \",\"2、修改代码\",\"@Override public Result likeBlog(Long id) { // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 String key = BLOG_LIKED_KEY + id; Boolean isMember = redisTemplate.opsForSet().isMember(key, userId.toString()); if(BooleanUtil.isFalse(isMember)) { //3.如果未点赞，可以点赞 //3.1 数据库点赞数+1 boolean isSuccess = update().setSql(\\\"liked = liked + 1\\\").eq(\\\"id\\\", id).update(); //3.2 保存用户到Redis的set集合 if(isSuccess){ redisTemplate.opsForSet().add(key,userId.toString()); } } else { //4.如果已点赞，取消点赞 //4.1 数据库点赞数-1 boolean isSuccess = update().setSql(\\\"liked = liked - 1\\\").eq(\\\"id\\\", id).update(); //4.2 把用户从Redis的set集合移除 if(isSuccess){ redisTemplate.opsForSet().remove(key,userId.toString()); } } } \",\"private void isBlogLiked(Blog blog) { // 获取当前用户id UserDTO user = UserHolder.getUser(); if (user == null) { return; } Long userId = user.getId(); // 拼接点赞key String key = RedisConstants.BLOG_LIKED_KEY + blog.getId(); // 判断当前用户是否已经点赞 Boolean isMember = redisTemplate.opsForSet().isMember(key, String.valueOf(userId)); blog.setIsLike(Boolean.TRUE.equals(isMember)); } \",\"修改根据id查询Blog的业务\",\"@Override public Result queryBlogById(Long id) { // 根据id查询blog Blog blog = this.getById(id); // 如果查询结果为空，则返回Blog不存在 if (ObjectUtil.isEmpty(blog)) { return Result.fail(\\\"Blog不存在！\\\"); } // 查询blog用户 queryBlogUser(blog); // 判断blog是否被点赞 isBlogLiked(blog); // 返回查询结果 return Result.ok(blog); } \",\"修改分页查询Blog业务\",\"@Override public Result queryHotBlog(Integer current) { // 根据用户查询 Page<Blog> page = this.query() .orderByDesc(\\\"liked\\\") .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List<Blog> records = page.getRecords(); // 查询用户 records.forEach(blog -> { this.isBlogLiked(blog); this.queryBlogUser(blog); }); return Result.ok(records); } \"]},\"1162\":{\"h\":\"7.4、达人探店-点赞排行榜\",\"t\":[\"在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜：\",\"之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet\",\"我们接下来来对比一下这些集合的区别是什么\",\"所有点赞的人，需要是唯一的，所以我们应当使用set或者是sortedSet\",\"其次我们需要排序，就可以直接锁定使用sortedSet啦\",\"修改代码\",\"BlogServiceImpl\",\"点赞逻辑代码\",\"@Override public Result likeBlog(Long id) { // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 String key = BLOG_LIKED_KEY + id; Double score = redisTemplate.opsForZSet().score(key, userId.toString()); if (score == null) { // 3.如果未点赞，可以点赞 // 3.1.数据库点赞数 + 1 boolean isSuccess = update().setSql(\\\"liked = liked + 1\\\").eq(\\\"id\\\", id).update(); // 3.2.保存用户到Redis的set集合 zadd key value score if (isSuccess) { stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis()); } } else { // 4.如果已点赞，取消点赞 // 4.1.数据库点赞数 -1 boolean isSuccess = update().setSql(\\\"liked = liked - 1\\\").eq(\\\"id\\\", id).update(); // 4.2.把用户从Redis的set集合移除 if (isSuccess) { redisTemplate.opsForZSet().remove(key, userId.toString()); } } return Result.ok(); } private void isBlogLiked(Blog blog) { // 1.获取登录用户 UserDTO user = UserHolder.getUser(); if (user == null) { // 用户未登录，无需查询是否点赞 return; } Long userId = user.getId(); // 2.判断当前登录用户是否已经点赞 String key = BLOG_LIKED_KEY + blog.getId(); Double score = redisTemplate.opsForZSet().score(key, userId.toString()); blog.setIsLike(score != null); } \",\"点赞列表查询列表\",\"BlogController\",\"@GetMapping(\\\"/likes/{id}\\\") public Result queryBlogLikes(@PathVariable(\\\"id\\\") Long id) { return blogService.queryBlogLikes(id); } \",\"BlogService\",\"@Override public Result queryBlogLikes(Long id) { String key = BLOG_LIKED_KEY + id; // 1.查询top5的点赞用户 zrange key 0 4 Set<String> top5 = redisTemplate.opsForZSet().range(key, 0, 4); if (top5 == null || top5.isEmpty()) { return Result.ok(Collections.emptyList()); } // 2.解析出其中的用户id List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList()); String idStr = StrUtil.join(\\\",\\\", ids); // 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1) List<UserDTO> userDTOS = userService.query() .in(\\\"id\\\", ids).last(\\\"ORDER BY FIELD(id,\\\" + idStr + \\\")\\\").list() .stream() .map(user -> BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); // 4.返回 return Result.ok(userDTOS); } \"]},\"1163\":{\"h\":\"8、好友关注\"},\"1164\":{\"h\":\"8.1、好友关注-关注和取消关注\",\"t\":[\"针对用户的操作：可以对用户进行关注和取消关注功能。\",\"实现思路：\",\"需求：基于该表数据结构，实现两个接口：\",\"关注和取关接口\",\"判断是否关注的接口\",\"关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示：\",\"CREATE TABLE `tb_follow` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `user_id` bigint(20) unsigned NOT NULL COMMENT '用户id', `follow_user_id` bigint(20) unsigned NOT NULL COMMENT '关联的用户id', `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT; \",\"注意: 这里需要把主键修改为自增长，简化开发。\",\"FollowController\",\"//关注 @PutMapping(\\\"/{id}/{isFollow}\\\") public Result follow(@PathVariable(\\\"id\\\") Long followUserId, @PathVariable(\\\"isFollow\\\") Boolean isFollow) { return followService.follow(followUserId, isFollow); } //取消关注 @GetMapping(\\\"/or/not/{id}\\\") public Result isFollow(@PathVariable(\\\"id\\\") Long followUserId) { return followService.isFollow(followUserId); } \",\"FollowService\",\"@Override public Result follow(Long followerId, Boolean isFollow) { // 获取当前用户id Long userId = UserHolder.getUser().getId(); if (isFollow) { // 关注 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followerId); this.save(follow); } else { // 取消关注 LambdaQueryWrapper<Follow> wrapper = new LambdaQueryWrapper<>(); wrapper.eq(Follow::getUserId, userId) .eq(Follow::getFollowUserId, followerId); this.remove(wrapper); } return Result.ok(); } @Override public Result isFollow(Long followerId) { // 查询当前用户是否关注了指定用户 Integer count = this.lambdaQuery().eq(Follow::getUserId, UserHolder.getUser().getId()) .eq(Follow::getFollowUserId, followerId).count(); // 返回查询结果 return Result.ok(count > 0); } \"]},\"1165\":{\"h\":\"8.2、好友关注-共同关注\",\"t\":[\"想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求\",\"1、去查询用户的详情\",\"2、去查询用户的笔记\",\"以上两个功能和共同关注没有什么关系，大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了，我们的重点在于共同关注功能。\",\"// UserController 根据id查询用户 @GetMapping(\\\"/{id}\\\") public Result queryUserById(@PathVariable(\\\"id\\\") Long userId){ // 查询详情 User user = userService.getById(userId); if (user == null) { return Result.ok(); } UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); // 返回 return Result.ok(userDTO); } // BlogController 根据id查询博主的探店笔记 @GetMapping(\\\"/of/user\\\") public Result queryBlogByUserId( @RequestParam(value = \\\"current\\\", defaultValue = \\\"1\\\") Integer current, @RequestParam(\\\"id\\\") Long id) { // 根据用户查询 Page<Blog> page = blogService.query() .eq(\\\"user_id\\\", id).page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE)); // 获取当前页数据 List<Blog> records = page.getRecords(); return Result.ok(records); } \",\"接下来我们来看看共同关注如何实现：\",\"需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。\",\"当然是使用我们之前学习过的set集合咯，在set集合中，有交集并集补集的api，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。\",\"我们先来改造当前的关注列表\",\"改造原因是因为我们需要在用户关注了某位用户后，需要将数据放入到set集合中，方便后续进行共同关注，同时当取消关注时，也需要从set集合中进行删除\",\"FollowServiceImpl\",\"@Override public Result follow(Long followerId, Boolean isFollow) { // 获取当前用户id Long userId = UserHolder.getUser().getId(); String key = \\\"follows:\\\" + userId; if (isFollow) { // 关注 Follow follow = new Follow(); follow.setUserId(userId); follow.setFollowUserId(followerId); boolean isSuccess = this.save(follow); if (isSuccess) { redisTemplate.opsForSet() .add(key, String.valueOf(followerId)); } } else { // 取消关注 LambdaQueryWrapper<Follow> wrapper = new LambdaQueryWrapper<>(); wrapper.eq(Follow::getUserId, userId) .eq(Follow::getFollowUserId, followerId); boolean isSuccess = this.remove(wrapper); if (isSuccess) { redisTemplate.opsForSet() .remove(key, String.valueOf(followerId)); } } return Result.ok(); } \",\"具体的关注代码：\",\"FollowServiceImpl\",\"@Override public Result commonFollow(Long followerId) { // 获取当前用户id Long userId = UserHolder.getUser().getId(); // 拼接key String key1 = \\\"follows:\\\" + userId; String key2 = \\\"follows:\\\" + followerId; // 获取两个key的交集 Set<String> follows = redisTemplate.opsForSet() .intersect(key1, key2); // 如果交集为空，返回空 if (CollectionUtil.isEmpty(follows)) { return Result.ok(); } // 将交集转换为list List<Long> ids = follows.stream().map(Long::valueOf) .collect(Collectors.toList()); // 根据id查询用户信息 List<UserDTO> userDTOs = userService.lambdaQuery() .in(User::getId, ids).list() .stream() // 将user对象转换为userDTO对象 .map(user -> BeanUtil.copyProperties(user, UserDTO.class)) .collect(Collectors.toList()); // 返回查询结果 return Result.ok(userDTOs); } \"]},\"1166\":{\"h\":\"8.3、好友关注-Feed流实现方案\",\"t\":[\"当我们关注了用户后，这个用户发了动态，那么我们应该把这些数据推送给用户，这个需求，其实我们又把他叫做Feed流，关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。\",\"对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容\",\"对于新型的Feed流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。\",\"Feed流的实现有两种模式：\",\"Feed流产品有两种常见模式： Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈\",\"优点：信息全面，不会有缺失。并且实现也相对简单\",\"缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低\",\"智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户\",\"优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷\",\"缺点：如果算法不精准，可能起到反作用 本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：\",\"我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可\",\"，因此采用Timeline的模式。该模式的实现方案有三种：\",\"拉模式\",\"推模式\",\"推拉结合\",\"拉模式：也叫做读扩散\",\"该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序\",\"优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清楚。\",\"缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大。\",\"推模式：也叫做写扩散。\",\"推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了\",\"优点：时效快，不用临时拉取\",\"缺点：内存压力大，假设一个大V写信息，很多人关注他， 就会写很多分数据到粉丝那边去\",\"推拉结合模式：也叫做读写混合，兼具推和拉两种模式的优点。\",\"推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大V和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息。\"]},\"1167\":{\"h\":\"8.4、好友关注-推送到粉丝收件箱\",\"t\":[\"模式选择\",\"本节 Feed 流采用推模式\",\"需求：\",\"修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱\",\"收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现\",\"查询收件箱数据时，可以实现分页查询\",\"Feed 流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。\",\"传统了分页在 Feed 流是不适用的，因为我们的数据会随时发生变化\",\"假设在t1 时刻，我们去读取第一页，此时 page = 1 ，size = 5 ，那么我们拿到的就是 10~6 这几条记录，假设现在t2时候又发布了一条记录，此时t3 时刻，我们来读取第二页，读取第二页传入的参数是page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，所以feed流的分页，不能采用原始方案来做。\",\"Feed 流的滚动分页\",\"我们需要记录每次操作的最后一条，然后从这个位置开始去读取数据\",\"举个例子：我们从t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用sortedSet来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了\",\"核心的意思：就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。\",\"@Override public Result saveBlog(Blog blog) { // 1.获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 2.保存探店笔记 boolean isSuccess = save(blog); if(!isSuccess){ return Result.fail(\\\"新增笔记失败!\\\"); } // 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ? List<Follow> follows = followService.query().eq(\\\"follow_user_id\\\", user.getId()).list(); // 4.推送笔记id给所有粉丝 for (Follow follow : follows) { // 4.1.获取粉丝id Long userId = follow.getUserId(); // 4.2.推送 String key = FEED_KEY + userId; stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis()); } // 5.返回id return Result.ok(blog.getId()); } \"]},\"1168\":{\"h\":\"8.5、好友关注-实现分页查询收邮箱\",\"t\":[\"需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：\",\"具体操作如下：\",\"1、每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件\",\"2、我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据\",\"综上：我们的请求参数中就需要携带 lastId：上一次查询的最小时间戳 和偏移量这两个参数。\",\"这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。\",\"一、定义出来具体的返回值实体类\",\"@Data public class ScrollResult { private List<?> list; private Long minTime; private Integer offset; } \",\"BlogController\",\"注意：RequestParam 表示接受url地址栏传参的注解，当方法上参数的名称和url地址栏不相同时，可以通过RequestParam 来进行指定\",\"@GetMapping(\\\"/of/follow\\\") public Result queryBlogOfFollow( @RequestParam(\\\"lastId\\\") Long max, @RequestParam(value = \\\"offset\\\", defaultValue = \\\"0\\\") Integer offset){ return blogService.queryBlogOfFollow(max, offset); } \",\"BlogServiceImpl\",\"@Override public Result queryBlogOfFollow(Long max, Integer offset) { // 1.获取当前用户 Long userId = UserHolder.getUser().getId(); // 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count String key = FEED_KEY + userId; Set<ZSetOperations.TypedTuple<String>> typedTuples = redisTemplate.opsForZSet() .reverseRangeByScoreWithScores(key, 0, max, offset, 2); // 3.非空判断 if (typedTuples == null || typedTuples.isEmpty()) { return Result.ok(); } // 4.解析数据：blogId、minTime（时间戳）、offset List<Long> ids = new ArrayList<>(typedTuples.size()); long minTime = 0; // 2 int os = 1; // 2 for (ZSetOperations.TypedTuple<String> tuple : typedTuples) { // 5 4 4 2 2 // 4.1.获取id ids.add(Long.valueOf(tuple.getValue())); // 4.2.获取分数(时间戳） long time = tuple.getScore().longValue(); if(time == minTime){ os++; }else{ minTime = time; os = 1; } } os = minTime == max ? os : os + offset; // 5.根据id查询blog String idStr = StrUtil.join(\\\",\\\", ids); List<Blog> blogs = query().in(\\\"id\\\", ids).last(\\\"ORDER BY FIELD(id,\\\" + idStr + \\\")\\\").list(); for (Blog blog : blogs) { // 5.1.查询blog有关的用户 queryBlogUser(blog); // 5.2.查询blog是否被点赞 isBlogLiked(blog); } // 6.封装并返回 ScrollResult r = new ScrollResult(); r.setList(blogs); r.setOffset(os); r.setMinTime(minTime); return Result.ok(r); } \"]},\"1169\":{\"h\":\"9、附近商户\"},\"1170\":{\"h\":\"9.1、附近商户-GEO 数据结构的基本用法\",\"t\":[\"GEO 就是 Geolocation 的简写形式，代表地理坐标。Redis 在 3.2 版本中加入了对 GEO 的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：\",\"GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）\",\"GEODIST：计算指定的两个点之间的距离并返回\",\"GEOHASH：将指定member的坐标转为hash字符串形式并返回\",\"GEOPOS：返回指定member的坐标\",\"GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃\",\"GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能\",\"GEOSEARCHSTORE：与 GEOSEARCH 功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能\"]},\"1171\":{\"h\":\"9.2、附近商户-导入店铺数据到 GEO\",\"t\":[\"具体场景说明：\",\"当我们点击美食之后，会出现一系列的商家，商家中可以按照多种排序方式，我们此时关注的是距离，这个地方就需要使用到我们的 GEO，向后台传入当前 app 收集的地址(我们此处是写死的) ，以当前坐标作为圆心，同时绑定相同的店家类型 type，以及分页信息，把这几个条件传入后台，后台查询出对应的数据再返回。\",\"我们要做的事情是：将数据库表中的数据导入到 redis 中去，redis 中的 GEO，GEO 在 redis 中就一个 member 和一个经纬度，我们把 x 和 y 轴传入到 redis 做的经纬度位置去，但我们不能把所有的数据都放入到 menber 中去，毕竟作为 redis 是一个内存级数据库，如果存海量数据， redis 还是力不从心，所以我们在这个地方存储他的 id 即可。\",\"但是这个时候还有一个问题，就是在 redis 中并没有存储 type，所以我们无法根据 type 来对数据进行筛选，所以我们可以按照商户类型做分组，类型相同的商户作为同一组，以 typeId 为 key 存入同一个 GEO 集合中即可\",\"代码\",\"HmDianPingApplicationTests\",\"@Test void loadShopData() { // 1.查询店铺信息 List<Shop> list = shopService.list(); // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合 Map<Long, List<Shop>> map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId)); // 3.分批完成写入Redis for (Map.Entry<Long, List<Shop>> entry : map.entrySet()) { // 3.1.获取类型id Long typeId = entry.getKey(); String key = SHOP_GEO_KEY + typeId; // 3.2.获取同类型的店铺的集合 List<Shop> value = entry.getValue(); List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(value.size()); // 3.3.写入redis GEOADD key 经度 纬度 member for (Shop shop : value) { locations.add(new RedisGeoCommands.GeoLocation<>( shop.getId().toString(), new Point(shop.getX(), shop.getY()) )); } redisTemplate.opsForGeo().add(key, locations); } } \"]},\"1172\":{\"h\":\"9.3、附近商户-实现附近商户功能\",\"t\":[\"SpringDataRedis 的 2.3.9 版本并不支持 Redis 6.2 提供的 GEOSEARCH 命令，因此我们需要提示其版本，修改自己的 POM\",\"第一步：导入 pom\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> <exclusions> <exclusion> <artifactId>spring-data-redis</artifactId> <groupId>org.springframework.data</groupId> </exclusion> <exclusion> <artifactId>lettuce-core</artifactId> <groupId>io.lettuce</groupId> </exclusion> </exclusions> </dependency> <dependency> <groupId>org.springframework.data</groupId> <artifactId>spring-data-redis</artifactId> <version>2.6.2</version> </dependency> <dependency> <groupId>io.lettuce</groupId> <artifactId>lettuce-core</artifactId> <version>6.1.6.RELEASE</version> </dependency> \",\"第二步：\",\"ShopController\",\"@GetMapping(\\\"/of/type\\\") public Result queryShopByType( @RequestParam(\\\"typeId\\\") Integer typeId, @RequestParam(value = \\\"current\\\", defaultValue = \\\"1\\\") Integer current, @RequestParam(value = \\\"x\\\", required = false) Double x, @RequestParam(value = \\\"y\\\", required = false) Double y ) { return shopService.queryShopByType(typeId, current, x, y); } \",\"ShopServiceImpl\",\"@Override public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) { // 1.判断是否需要根据坐标查询 if (x == null || y == null) { // 不需要坐标查询，按数据库查询 Page<Shop> page = query() .eq(\\\"type_id\\\", typeId) .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE)); // 返回数据 return Result.ok(page.getRecords()); } // 2.计算分页参数 int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE; int end = current * SystemConstants.DEFAULT_PAGE_SIZE; // 3.查询redis、按照距离排序、分页。结果：shopId、distance String key = RedisConstants.SHOP_GEO_KEY + typeId; GeoResults<RedisGeoCommands.GeoLocation<String>> results = redisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE .search( key, GeoReference.fromCoordinate(x, y), new Distance(SystemConstants.DEFAULT_SHOP_DISTANCE), RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end) ); // 4.解析出id if (results == null) { return Result.ok(Collections.emptyList()); } List<GeoResult<RedisGeoCommands.GeoLocation<String>>> list = results.getContent(); if (list.size() <= from) { // 没有下一页了，结束 return Result.ok(Collections.emptyList()); } // 4.1.截取 from ~ end的部分 List<Long> ids = new ArrayList<>(list.size()); Map<String, Distance> distanceMap = new HashMap<>(list.size()); list.stream().skip(from).forEach(result -> { // 4.2.获取店铺id String shopIdStr = result.getContent().getName(); ids.add(Long.valueOf(shopIdStr)); // 4.3.获取距离 Distance distance = result.getDistance(); distanceMap.put(shopIdStr, distance); }); // 5.根据id查询Shop String idStr = StrUtil.join(\\\",\\\", ids); List<Shop> shops = query().in(\\\"id\\\", ids).last(\\\"ORDER BY FIELD(id,\\\" + idStr + \\\")\\\").list(); for (Shop shop : shops) { shop.setDistance(distanceMap.get(shop.getId().toString()).getValue()); } // 6.返回 return Result.ok(shops); } \"]},\"1173\":{\"h\":\"10、用户签到\"},\"1174\":{\"h\":\"10.1、用户签到-BitMap 功能演示\",\"t\":[\"我们针对签到功能完全可以通过 mysql 来完成，比如说以下这张表\",\"CREATE TABLE `tb_sign` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键', `user_id` bigint(20) unsigned NOT NULL COMMENT '用户id', `year` year(4) NOT NULL COMMENT '签到的年', `month` tinyint(2) NOT NULL COMMENT '签到的月', `date` date NOT NULL COMMENT '签到的日期', `is_backup` tinyint(1) unsigned DEFAULT NULL COMMENT '是否补签', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT; \",\"用户一次签到，就是一条记录，假如有 1000 万用户，平均每人每年签到次数为 10 次，则这张表一年的数据量为 1 亿条\",\"每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共 22 字节的内存，一个月则最多需要 600 多字节\",\"我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了\",\"我们可以采用类似这样的方案来实现我们的签到需求。\",\"我们按月来统计用户签到信息，签到记录为 1，未签到则记录为 0.\",\"把每一个 bit 位对应当月的每一天，形成了映射关系。用 0 和 1 标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示\",\"Redis 中是利用 string 类型数据结构实现 BitMap，因此最大上限是 512M，转换为 bit 则是 2^32 个 bit 位。\",\"BitMap 的操作命令有：\",\"SETBIT：向指定位置（offset）存入一个0或1\",\"GETBIT ：获取指定位置（offset）的bit值\",\"BITCOUNT ：统计 BitMap 中值为 1 的bit位的数量\",\"BITFIELD ：操作（查询、修改、自增）BitMap 中 bit 数组中的指定位置（offset）的值\",\"BITFIELD_RO ：获取 BitMap 中 bit 数组，并以十进制形式返回\",\"BITOP ：将多个 BitMap 的结果做位运算（与 、或、异或）\",\"BITPOS ：查找 bit 数组中指定范围内第一个 0 或 1 出现的位置\"]},\"1175\":{\"h\":\"10.2、用户签到-实现签到功能\",\"t\":[\"需求：实现签到接口，将当前用户当天签到信息保存到 Redis 中\",\"思路：我们可以把年和月作为 bitMap 的 key，然后保存到一个 bitMap 中，每次签到就到对应的位上把数字从 0 变成 1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。\",\"我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改 bitMap。\",\"代码\",\"UserController\",\" @PostMapping(\\\"/sign\\\") public Result sign(){ return userService.sign(); } \",\"UserServiceImpl\",\"@Override public Result sign() { // 1.获取当前登录用户 Long userId = UserHolder.getUser().getId(); // 2.获取日期 LocalDateTime now = LocalDateTime.now(); // 3.拼接key String keySuffix = now.format(DateTimeFormatter.ofPattern(\\\":yyyy/MM\\\")); String key = USER_SIGN_KEY + userId + keySuffix; // 4.获取今天是本月的第几天 int dayOfMonth = now.getDayOfMonth(); // 5.写入Redis SETBIT key offset 1 redisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true); return Result.ok(); } \"]},\"1176\":{\"h\":\"10.3、用户签到-签到统计\",\"t\":[\"问题1： 什么叫做连续签到天数？ 从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。\",\"Java 逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非 0 的数字即可，每得到一个非 0 的数字计数器 +1，直到遍历完所有的数据，就可以获得当前月的签到总天数了\",\"问题2： 如何得到本月到今天为止的所有签到数据？\",\"BITFIELD key GET u[dayOfMonth] 0\",\"假设今天是 10 号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是 10 号，那么就是 10 位，去拿这段时间的数据，就能拿到所有的数据了，那么这 10 天里边签到了多少次呢？统计有多少个 1 即可。\",\"问题3：如何从后向前遍历每个 bit 位？\",\"注意：bitMap 返回的数据是 10 进制，哪假如说返回一个数字 8，那么我哪儿知道到底哪些是 0，哪些是 1 呢？我们只需要让得到的 10 进制数字和 1 做与运算就可以了，因为 1 只有遇见 1 才是 1，其他数字都是 0，我们把签到结果和 1 进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。\",\"需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数\",\"有用户有时间我们就可以组织出对应的 key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了\",\"代码\",\"UserController\",\"@GetMapping(\\\"/sign/count\\\") public Result signCount(){ return userService.signCount(); } \",\"UserServiceImpl\",\"@Override public Result signCount() { // 1.获取当前登录用户 Long userId = UserHolder.getUser().getId(); // 2.获取日期 LocalDateTime now = LocalDateTime.now(); // 3.拼接key String keySuffix = now.format(DateTimeFormatter.ofPattern(\\\":yyyyMM\\\")); String key = USER_SIGN_KEY + userId + keySuffix; // 4.获取今天是本月的第几天 int dayOfMonth = now.getDayOfMonth(); // 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0 List<Long> result = redisTemplate.opsForValue().bitField( key, BitFieldSubCommands.create() .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0) ); if (CollectionUtil.isEmpty(result)) { // 没有任何签到结果 return Result.ok(0); } Long num = result.get(0); if (num == null || num == 0) { return Result.ok(0); } // 6.循环遍历 int count = 0; while ((num & 1) == 1) { count++; num >>>= 1; } return Result.ok(count); } \"]},\"1177\":{\"h\":\"10.4、额外加餐-关于使用 bitmap 来解决缓存穿透的方案\",\"t\":[\"回顾缓存穿透：\",\"发起了一个数据库不存在的，redis 里边也不存在的数据，通常你可以把他看成一个攻击\",\"解决方案：\",\"判断 id<0\",\"如果数据库是空，那么就可以直接往 redis 里边把这个空数据缓存起来\",\"第一种解决方案：遇到的问题是如果用户访问的是 id 不存在的数据，则此时就无法生效\",\"第二种解决方案：遇到的问题是：如果是不同的 id 那就可以防止下次过来直击数据\",\"所以我们如何解决呢？\",\"我们可以将数据库的数据，所对应的 id 写入到一个 list 集合中，当用户过来访问的时候，我们直接去判断 list 中是否包含当前的要查询的数据，如果说用户要查询的 id 数据并不在 list 集合中，则直接返回，如果 list 中包含对应查询的 id 数据，则说明不是一次缓存穿透数据，则直接放行。\",\"现在的问题是这个主键其实并没有那么短，而是很长的一个主键\",\"哪怕你单独去提取这个主键，但是在 11 年左右，淘宝的商品总量就已经超过 10 亿个\",\"所以如果采用以上方案，这个 list 也会很大，所以我们可以使用 bitmap 来减少 list 的存储空间\",\"我们可以把 list 数据抽象成一个非常大的 bitmap，我们不再使用 list，而是将 db 中的 id 数据利用哈希思想，比如：\",\"id % bitmap.size = 算出当前这个 id 对应应该落在 bitmap的哪个索引上，然后将这个值从 0 变成 1，然后当用户来查询数据时，此时已经没有了 list，让用户用他查询的 id 去用相同的哈希算法， 算出来当前这个 id 应当落在 bitmap 的哪一位，然后判断这一位是 0，还是 1，如果是 0 则表明这一位上的数据一定不存在，采用这种方式来处理，需要重点考虑一个事情，就是误差率，所谓的误差率就是指当发生哈希冲突的时候，产生的误差。\"]},\"1178\":{\"h\":\"11、UV 统计\"},\"1179\":{\"h\":\"11.1 、UV 统计-HyperLogLog\",\"t\":[\"首先我们搞懂两个概念：\",\"UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。\",\"PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。\",\"通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值\",\"UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？\",\"Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。相关算法原理大家可以参考：https://juejin.cn/post/6844903785744056333#heading-0 Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低的令人发指！作为代价，其测量结果是概率性的，有小于0.81％的误差。不过对于UV统计来说，这完全可以忽略。\"]},\"1180\":{\"h\":\"11.2、UV统计-测试百万数据的统计\",\"t\":[\"测试思路：我们直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何\",\"@Test void testHyperLogLog() { String[] values = new String[1000]; int j = 0; for (int i = 0; i < 1000000; i++) { j = i % 1000; values[j] = \\\"user_\\\" + i; if (j == 999) { redisTemplate.opsForHyperLogLog().add(\\\"hl2\\\", values); } } Long count = redisTemplate.opsForHyperLogLog().size(\\\"hl2\\\"); log.info(\\\"UV统计数量：{}\\\", count); } \",\"经过测试：我们会发生他的误差是在允许范围内，并且内存占用极小\"]},\"1181\":{\"h\":\"Redis 基础\",\"t\":[\"提示\",\"Redis系列整理学习自黑马程序员Redis相关课程\",\"目录\"]},\"1182\":{\"h\":\"1、Redis简单介绍\",\"t\":[\"Redis是一种键值型的NoSql数据库，这里有两个关键字：\",\"键值型\",\"NoSql\",\"其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：\",\"1652882668159\",\"而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。\",\"对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。\"]},\"1183\":{\"h\":\"2、初始Redis\"},\"1184\":{\"h\":\"2.1、认识NoSQL\",\"t\":[\"NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。\"]},\"1185\":{\"h\":\"2.1.1、结构化与非结构化\",\"t\":[\"传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：\",\"而NoSql则对数据库格式没有严格约束，往往形式松散，自由。\",\"可以是键值型：\",\"也可以是文档型：\",\"甚至可以是图格式：\"]},\"1186\":{\"h\":\"2.1.2、关联和非关联\",\"t\":[\"传统数据库的表与表之间往往存在关联，例如外键：\",\"而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：\",\"{ \\\"id\\\": 1, \\\"name\\\": \\\"张三\\\", \\\"orders\\\": [ { \\\"id\\\": 1, \\\"item\\\": { \\\"id\\\": 10, \\\"title\\\": \\\"荣耀6\\\", \\\"price\\\": 4999 } }, { \\\"id\\\": 2, \\\"item\\\": { \\\"id\\\": 20, \\\"title\\\": \\\"小米11\\\", \\\"price\\\": 3999 } } ] } \",\"此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。\"]},\"1187\":{\"h\":\"2.1.3、查询方式\",\"t\":[\"传统关系型数据库会基于Sql语句做查询，语法有统一标准；\",\"而不同的非关系数据库查询语法差异极大，五花八门各种各样。\"]},\"1188\":{\"h\":\"2.1.4、事务\",\"t\":[\"传统关系型数据库能满足事务ACID的原则。\",\"而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。\"]},\"1189\":{\"h\":\"2.1.5、总结\",\"t\":[\"除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：\",\"存储方式 \",\"关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响\",\"非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些\",\"扩展性 \",\"关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。\",\"非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。\",\"关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦\"]},\"1190\":{\"h\":\"2.2、认识Redis\",\"t\":[\"Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。\",\"特征：\",\"键值（key-value）型，value支持多种不同数据结构，功能丰富\",\"单线程，每个命令具备原子性\",\"低延迟，速度快（基于内存.IO多路复用.良好的编码）。\",\"支持数据持久化\",\"支持主从集群.分片集群\",\"支持多语言客户端\",\"作者：Antirez\",\"Redis的官方网站地址：https://redis.io/\"]},\"1191\":{\"h\":\"2.3、安装Redis\",\"t\":[\"大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.\",\"此处选择的Linux版本为CentOS 7.\"]},\"1192\":{\"h\":\"2.3.1、依赖库\",\"t\":[\"Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：\",\"yum install -y gcc tcl \"]},\"1193\":{\"h\":\"2.3.2、上传安装包并解压\",\"t\":[\"然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：\",\"例如，我放到了/usr/local/src 目录：\",\"解压缩：\",\"tar -xzf redis-6.2.6.tar.gz \",\"解压后：\",\"image-20211211080339076\",\"进入redis目录：\",\"cd redis-6.2.6 \",\"运行编译命令：\",\"make && make install \",\"如果没有出错，应该就安装成功了。\",\"默认的安装路径是在 /usr/local/bin目录下：\",\"该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：\",\"redis-cli：是redis提供的命令行客户端\",\"redis-server：是redis的服务端启动脚本\",\"redis-sentinel：是redis的哨兵启动脚本\"]},\"1194\":{\"h\":\"2.3.3、启动\",\"t\":[\"redis的启动方式有很多种，例如：\",\"默认启动\",\"指定配置启动\",\"开机自启\"]},\"1195\":{\"h\":\"2.3.4、默认启动\",\"t\":[\"安装完成后，在任意目录输入redis-server命令即可启动Redis：\",\"redis-server \",\"如图：\",\"这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。\"]},\"1196\":{\"h\":\"2.3.5、指定配置启动\",\"t\":[\"如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf：\",\"image-20211211082225509\",\"我们先将这个配置文件备份一份：\",\"cp redis.conf redis.conf.bck \",\"然后修改redis.conf文件中的一些配置：\",\"# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0 bind 0.0.0.0 # 守护进程，修改为yes后即可后台运行 daemonize yes # 密码，设置后访问Redis必须输入密码 requirepass 123321 \",\"Redis的其它常见配置：\",\"# 监听的端口 port 6379 # 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录 dir . # 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15 databases 1 # 设置redis能够使用的最大内存 maxmemory 512mb # 日志文件，默认为空，不记录日志，可以指定日志文件名 logfile \\\"redis.log\\\" \",\"启动Redis：\",\"# 进入redis安装目录 cd /usr/local/src/redis-6.2.6 # 启动 redis-server redis.conf \",\"停止服务：\",\"# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务， # 因为之前配置了密码，因此需要通过 -u 来指定密码 redis-cli -u 123321 shutdown \"]},\"1197\":{\"h\":\"2.3.6、开机自启\",\"t\":[\"我们也可以通过配置来实现开机自启。\",\"首先，新建一个系统服务文件：\",\"vi /etc/systemd/system/redis.service \",\"内容如下：\",\"[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target \",\"然后重载系统服务：\",\"systemctl daemon-reload \",\"现在，我们可以用下面这组命令来操作redis了：\",\"# 启动 systemctl start redis # 停止 systemctl stop redis # 重启 systemctl restart redis # 查看状态 systemctl status redis \",\"执行下面的命令，可以让redis开机自启：\",\"systemctl enable redis \"]},\"1198\":{\"h\":\"2.4、Redis桌面客户端\",\"t\":[\"安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：\",\"命令行客户端\",\"图形化桌面客户端\",\"编程客户端\"]},\"1199\":{\"h\":\"2.4.1、Redis命令行客户端\",\"t\":[\"Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：\",\"redis-cli [options] [commonds] \",\"其中常见的options有：\",\"-h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1\",\"-p 6379：指定要连接的redis节点的端口，默认是6379\",\"-a 123321：指定redis的访问密码\",\"其中的commonds就是Redis的操作命令，例如：\",\"ping：与redis服务端做心跳测试，服务端正常会返回pong\",\"不指定commond时，会进入redis-cli的交互控制台：\"]},\"1200\":{\"h\":\"2.4.2、图形化桌面客户端\",\"t\":[\"GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager\",\"不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。\",\"在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\"]},\"1201\":{\"h\":\"2.4.3、安装\",\"t\":[\"在课前资料中可以找到Redis的图形化桌面客户端：\",\"解压缩后，运行安装程序即可安装：\",\"安装完成后，在安装目录下找到rdm.exe文件：\",\"双击即可运行：\"]},\"1202\":{\"h\":\"2.4.4、建立连接\",\"t\":[\"点击左上角的连接到Redis服务器按钮：\",\"在弹出的窗口中填写Redis服务信息：\",\"点击确定后，在左侧菜单会出现这个链接：\",\"点击即可建立连接了。\",\"Redis默认有16个仓库，编号从0至15. 通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。\",\"如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：\",\"# 选择 0号库 select 0 \"]},\"1203\":{\"h\":\"3、Redis常见命令\"},\"1204\":{\"h\":\"3.1、Redis数据结构介绍\",\"t\":[\"Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：\",\"1652887393157\",\"贴心小建议：命令不要死记，学会查询就好啦\",\"Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令：\",\"1652887648826\",\"当然我们也可以通过Help命令来帮助我们去查看命令\",\"1652887748279\"]},\"1205\":{\"h\":\"3.2、Redis 通用命令\",\"t\":[\"通用指令是部分数据类型的，都可以使用的指令，常见的有：\",\"KEYS：查看符合模板的所有key\",\"DEL：删除一个指定的key\",\"EXISTS：判断key是否存在\",\"EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除\",\"TTL：查看一个KEY的剩余有效期\",\"通过help [command] 可以查看一个命令的具体用法，例如：\",\"1652887865189\",\"课堂代码如下\",\"KEYS\",\"127.0.0.1:6379> keys * 1) \\\"name\\\" 2) \\\"age\\\" 127.0.0.1:6379> # 查询以a开头的key 127.0.0.1:6379> keys a* 1) \\\"age\\\" 127.0.0.1:6379> \",\"贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高\",\"DEL\",\"127.0.0.1:6379> help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic 127.0.0.1:6379> del name #删除单个 (integer) 1 #成功删除1个 127.0.0.1:6379> keys * 1) \\\"age\\\" 127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 #批量添加数据 OK 127.0.0.1:6379> keys * 1) \\\"k3\\\" 2) \\\"k2\\\" 3) \\\"k1\\\" 4) \\\"age\\\" 127.0.0.1:6379> del k1 k2 k3 k4 (integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回 127.0.0.1:6379> 127.0.0.1:6379> keys * #再查询全部的key 1) \\\"age\\\" #只剩下一个了 127.0.0.1:6379> \",\"贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~\",\"EXISTS\",\"127.0.0.1:6379> help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic 127.0.0.1:6379> exists age (integer) 1 127.0.0.1:6379> exists name (integer) 0 \",\"EXPIRE\",\"贴心小提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~\",\"127.0.0.1:6379> expire age 10 (integer) 1 127.0.0.1:6379> ttl age (integer) 8 127.0.0.1:6379> ttl age (integer) 6 127.0.0.1:6379> ttl age (integer) -2 127.0.0.1:6379> ttl age (integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379> keys * (empty list or set) 127.0.0.1:6379> set age 10 #如果没有设置过期时间 OK 127.0.0.1:6379> ttl age (integer) -1 # ttl的返回值就是-1 \"]},\"1206\":{\"h\":\"3.3、Redis命令-String命令\",\"t\":[\"String类型，也就是字符串类型，是Redis中最简单的存储类型。\",\"其value是字符串，不过根据字符串的格式不同，又可以分为3类：\",\"string：普通字符串\",\"int：整数类型，可以做自增.自减操作\",\"float：浮点类型，可以做自增.自减操作\",\"1652890121291\",\"String的常见命令有：\",\"SET：添加或者修改已经存在的一个String类型的键值对\",\"GET：根据key获取String类型的value\",\"MSET：批量添加多个String类型的键值对\",\"MGET：根据多个key获取多个String类型的value\",\"INCR：让一个整型的key自增1\",\"INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\",\"INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\",\"SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\",\"SETEX：添加一个String类型的键值对，并且指定有效期\",\"贴心小提示：以上命令除了INCRBYFLOAT 都是常用命令\",\"SET 和GET: 如果key不存在则是新增，如果存在则是修改\",\"127.0.0.1:6379> set name Rose //原来不存在 OK 127.0.0.1:6379> get name \\\"Rose\\\" 127.0.0.1:6379> set name Jack //原来存在，就是修改 OK 127.0.0.1:6379> get name \\\"Jack\\\" \",\"MSET和MGET\",\"127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379> MGET name age k1 k2 k3 1) \\\"Jack\\\" //之前存在的name 2) \\\"10\\\" //之前存在的age 3) \\\"v1\\\" 4) \\\"v2\\\" 5) \\\"v3\\\" \",\"INCR和INCRBY和DECY\",\"127.0.0.1:6379> get age \\\"10\\\" 127.0.0.1:6379> incr age //增加1 (integer) 11 127.0.0.1:6379> get age //获得age \\\"11\\\" 127.0.0.1:6379> incrby age 2 //一次增加2 (integer) 13 //返回目前的age的值 127.0.0.1:6379> incrby age 2 (integer) 15 127.0.0.1:6379> incrby age -1 //也可以增加负数，相当于减 (integer) 14 127.0.0.1:6379> incrby age -2 //一次减少2个 (integer) 12 127.0.0.1:6379> DECR age //相当于 incr 负数，减少正常用法 (integer) 11 127.0.0.1:6379> get age \\\"11\\\" \",\"SETNX\",\"127.0.0.1:6379> help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string 127.0.0.1:6379> set name Jack //设置名称 OK 127.0.0.1:6379> setnx name lisi //如果key不存在，则添加成功 (integer) 0 127.0.0.1:6379> get name //由于name已经存在，所以lisi的操作失败 \\\"Jack\\\" 127.0.0.1:6379> setnx name2 lisi //name2 不存在，所以操作成功 (integer) 1 127.0.0.1:6379> get name2 \\\"lisi\\\" \",\"SETEX\",\"127.0.0.1:6379> setex name 10 jack OK 127.0.0.1:6379> ttl name (integer) 8 127.0.0.1:6379> ttl name (integer) 7 127.0.0.1:6379> ttl name (integer) 5 \"]},\"1207\":{\"h\":\"3.4、Redis命令-Key的层级结构\",\"t\":[\"Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？\",\"例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？\",\"我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：\",\"Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下：\",\"1652941631682\",\"这个格式并非固定，也可以根据自己的需求来删除或添加词条。\",\"例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：\",\"user相关的key：heima:user:1\",\"product相关的key：heima:product:1\",\"如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：\",\"KEY\",\"VALUE\",\"heima:user:1\",\"{\\\"id\\\":1, \\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}\",\"heima:product:1\",\"{\\\"id\\\":1, \\\"name\\\": \\\"小米11\\\", \\\"price\\\": 4999}\",\"一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据\",\"1652941883537\"]},\"1208\":{\"h\":\"3.5、Redis命令-Hash命令\",\"t\":[\"Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\",\"String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：\",\"1652941995945\",\"Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：\",\"1652942027719\",\"Hash类型的常见命令\",\"HSET key field value：添加或者修改hash类型key的field的值\",\"HGET key field：获取一个hash类型key的field的值\",\"HMSET：批量添加多个hash类型key的field的值\",\"HMGET：批量获取多个hash类型key的field的值\",\"HGETALL：获取一个hash类型的key中的所有的field和value\",\"HKEYS：获取一个hash类型的key中的所有的field\",\"HINCRBY:让一个hash类型key的字段值自增并指定步长\",\"HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\",\"贴心小提示：哈希结构也是我们以后实际开发中常用的命令哟\",\"HSET和HGET\",\"127.0.0.1:6379> HSET heima:user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy (integer) 1 127.0.0.1:6379> HSET heima:user:3 age 21// 如果操作不存在的数据，则是新增 (integer) 1 127.0.0.1:6379> HSET heima:user:3 age 17 //如果操作存在的数据，则是修改 (integer) 0 127.0.0.1:6379> HGET heima:user:3 name \\\"Lucy\\\" 127.0.0.1:6379> HGET heima:user:3 age \\\"17\\\" \",\"HMSET和HMGET\",\"127.0.0.1:6379> HMSET heima:user:4 name HanMeiMei OK 127.0.0.1:6379> HMSET heima:user:4 name LiLei age 20 sex man OK 127.0.0.1:6379> HMGET heima:user:4 name age sex 1) \\\"LiLei\\\" 2) \\\"20\\\" 3) \\\"man\\\" \",\"HGETALL\",\"127.0.0.1:6379> HGETALL heima:user:4 1) \\\"name\\\" 2) \\\"LiLei\\\" 3) \\\"age\\\" 4) \\\"20\\\" 5) \\\"sex\\\" 6) \\\"man\\\" \",\"HKEYS和HVALS\",\"127.0.0.1:6379> HKEYS heima:user:4 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"sex\\\" 127.0.0.1:6379> HVALS heima:user:4 1) \\\"LiLei\\\" 2) \\\"20\\\" 3) \\\"man\\\" \",\"HINCRBY\",\"127.0.0.1:6379> HINCRBY heima:user:4 age 2 (integer) 22 127.0.0.1:6379> HVALS heima:user:4 1) \\\"LiLei\\\" 2) \\\"22\\\" 3) \\\"man\\\" 127.0.0.1:6379> HINCRBY heima:user:4 age -2 (integer) 20 \",\"HSETNX\",\"127.0.0.1:6379> HSETNX heima:user4 sex woman (integer) 1 127.0.0.1:6379> HGETALL heima:user:3 1) \\\"name\\\" 2) \\\"Lucy\\\" 3) \\\"age\\\" 4) \\\"17\\\" 127.0.0.1:6379> HSETNX heima:user:3 sex woman (integer) 1 127.0.0.1:6379> HGETALL heima:user:3 1) \\\"name\\\" 2) \\\"Lucy\\\" 3) \\\"age\\\" 4) \\\"17\\\" 5) \\\"sex\\\" 6) \\\"woman\\\" \"]},\"1209\":{\"h\":\"3.6、Redis命令-List命令\",\"t\":[\"Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\",\"特征也与LinkedList类似：\",\"有序\",\"元素可以重复\",\"插入和删除快\",\"查询速度一般\",\"常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\",\"List的常见命令有：\",\"LPUSH key element ... ：向列表左侧插入一个或多个元素\",\"LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\",\"RPUSH key element ... ：向列表右侧插入一个或多个元素\",\"RPOP key：移除并返回列表右侧的第一个元素\",\"LRANGE key star end：返回一段角标范围内的所有元素\",\"BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\",\"1652943604992\",\"LPUSH和RPUSH\",\"127.0.0.1:6379> LPUSH users 1 2 3 (integer) 3 127.0.0.1:6379> RPUSH users 4 5 6 (integer) 6 \",\"LPOP和RPOP\",\"127.0.0.1:6379> LPOP users \\\"3\\\" 127.0.0.1:6379> RPOP users \\\"6\\\" \",\"LRANGE\",\"127.0.0.1:6379> LRANGE users 1 2 1) \\\"1\\\" 2) \\\"4\\\" \"]},\"1210\":{\"h\":\"3.7、Redis命令-Set命令\",\"t\":[\"Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\",\"无序\",\"元素不可重复\",\"查找快\",\"支持交集.并集.差集等功能\",\"Set类型的常见命令\",\"SADD key member ... ：向set中添加一个或多个元素\",\"SREM key member ... : 移除set中的指定元素\",\"SCARD key： 返回set中元素的个数\",\"SISMEMBER key member：判断一个元素是否存在于set中\",\"SMEMBERS：获取set中的所有元素\",\"SINTER key1 key2 ... ：求key1与key2的交集\",\"SDIFF key1 key2 ... ：求key1与key2的差集\",\"SUNION key1 key2 ..：求key1和key2的并集\",\"例如两个集合：s1和s2:\",\"求交集：SINTER s1 s2\",\"求s1与s2的不同：SDIFF s1 s2\",\"具体命令\",\"127.0.0.1:6379> sadd s1 a b c (integer) 3 127.0.0.1:6379> smembers s1 1) \\\"c\\\" 2) \\\"b\\\" 3) \\\"a\\\" 127.0.0.1:6379> srem s1 a (integer) 1 127.0.0.1:6379> SISMEMBER s1 a (integer) 0 127.0.0.1:6379> SISMEMBER s1 b (integer) 1 127.0.0.1:6379> SCARD s1 (integer) 2 \",\"案例\",\"将下列数据用Redis的Set集合来存储：\",\"张三的好友有：李四.王五.赵六\",\"李四的好友有：王五.麻子.二狗\",\"利用Set的命令实现下列功能：\",\"计算张三的好友有几人\",\"计算张三和李四有哪些共同好友\",\"查询哪些人是张三的好友却不是李四的好友\",\"查询张三和李四的好友总共有哪些人\",\"判断李四是否是张三的好友\",\"判断张三是否是李四的好友\",\"将李四从张三的好友列表中移除\",\"127.0.0.1:6379> SADD zs lisi wangwu zhaoliu (integer) 3 127.0.0.1:6379> SADD ls wangwu mazi ergou (integer) 3 127.0.0.1:6379> SCARD zs (integer) 3 127.0.0.1:6379> SINTER zs ls 1) \\\"wangwu\\\" 127.0.0.1:6379> SDIFF zs ls 1) \\\"zhaoliu\\\" 2) \\\"lisi\\\" 127.0.0.1:6379> SUNION zs ls 1) \\\"wangwu\\\" 2) \\\"zhaoliu\\\" 3) \\\"lisi\\\" 4) \\\"mazi\\\" 5) \\\"ergou\\\" 127.0.0.1:6379> SISMEMBER zs lisi (integer) 1 127.0.0.1:6379> SISMEMBER ls zhangsan (integer) 0 127.0.0.1:6379> SREM zs lisi (integer) 1 127.0.0.1:6379> SMEMBERS zs 1) \\\"zhaoliu\\\" 2) \\\"wangwu\\\" \"]},\"1211\":{\"h\":\"3.8、Redis命令-SortedSet类型\",\"t\":[\"Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\",\"SortedSet具备下列特性：\",\"可排序\",\"元素不重复\",\"查询速度快\",\"因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\",\"SortedSet的常见命令有：\",\"ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\",\"ZREM key member：删除sorted set中的一个指定元素\",\"ZSCORE key member : 获取sorted set中的指定元素的score值\",\"ZRANK key member：获取sorted set 中的指定元素的排名\",\"ZCARD key：获取sorted set中的元素个数\",\"ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\",\"ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\",\"ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\",\"ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\",\"ZDIFF.ZINTER.ZUNION：求差集.交集.并集\",\"注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：\",\"升序获取sorted set 中的指定元素的排名：ZRANK key member\",\"降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber\"]},\"1212\":{\"h\":\"4、Redis的Java客户端-Jedis\",\"t\":[\"在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/\",\"其中Java客户端也包含很多：\",\"image-20220609102817435\",\"标记为❤的就是推荐使用的java客户端，包括：\",\"Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。\",\"Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。\"]},\"1213\":{\"h\":\"4.1、Jedis快速入门\",\"t\":[\"入门案例详细步骤\",\"案例分析：\",\"0）创建工程\",\"1）引入依赖：\",\"<!--jedis--> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>3.7.0</version> </dependency> <!--单元测试--> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.7.0</version> <scope>test</scope> </dependency> \",\"2）建立连接\",\"新建一个单元测试类，内容如下：\",\"private Jedis jedis; @BeforeEach void setUp() { // 1.建立连接 // jedis = new Jedis(\\\"192.168.150.101\\\", 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(\\\"123321\\\"); // 3.选择库 jedis.select(0); } \",\"3）测试：\",\"@Test void testString() { // 存入数据 String result = jedis.set(\\\"name\\\", \\\"虎哥\\\"); System.out.println(\\\"result = \\\" + result); // 获取数据 String name = jedis.get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } @Test void testHash() { // 插入hash数据 jedis.hset(\\\"user:1\\\", \\\"name\\\", \\\"Jack\\\"); jedis.hset(\\\"user:1\\\", \\\"age\\\", \\\"21\\\"); // 获取 Map<String, String> map = jedis.hgetAll(\\\"user:1\\\"); System.out.println(map); } \",\"4）释放资源\",\"@AfterEach void tearDown() { if (jedis != null) { jedis.close(); } } \"]},\"1214\":{\"h\":\"4.2、Jedis连接池\",\"t\":[\"Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式\",\"有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。\"]},\"1215\":{\"h\":\"4.2.1、创建Jedis的连接池\",\"t\":[\"public class JedisConnectionFacotry { private static final JedisPool jedisPool; static { //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, \\\"192.168.150.101\\\",6379,1000,\\\"123321\\\"); } public static Jedis getJedis(){ return jedisPool.getResource(); } } \",\"代码说明：\",\"1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式\",\"2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化\",\"3）最后提供返回连接池中连接的方法.\"]},\"1216\":{\"h\":\"4.2.2、改造原始代码\",\"t\":[\"代码说明:\",\"1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。\",\"，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。\",\"2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。\",\" @BeforeEach void setUp(){ //建立连接 /*jedis = new Jedis(\\\"127.0.0.1\\\",6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); } @AfterEach void tearDown() { if (jedis != null) { jedis.close(); } } \"]},\"1217\":{\"h\":\"5、Redis的Java客户端-SpringDataRedis\",\"t\":[\"SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis\",\"提供了对不同Redis客户端的整合（Lettuce和Jedis）\",\"提供了RedisTemplate统一API来操作Redis\",\"支持Redis的发布订阅模型\",\"支持Redis哨兵和Redis集群\",\"支持基于Lettuce的响应式编程\",\"支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化\",\"支持基于Redis的JDKCollection实现\",\"SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\",\"1652976773295\"]},\"1218\":{\"h\":\"5.1、快速入门\",\"t\":[\"SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：\"]},\"1219\":{\"h\":\"5.1.1、导入pom坐标\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.5.7</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.heima</groupId> <artifactId>redis-demo</artifactId> <version>0.0.1-SNAPSHOT</version> <name>redis-demo</name> <description>Demo project for Spring Boot</description> <properties> <java.version>1.8</java.version> </properties> <dependencies> <!--redis依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <!--common-pool--> <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-pool2</artifactId> </dependency> <!--Jackson依赖--> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project> \"]},\"1220\":{\"h\":\"5.1.2、配置文件\",\"t\":[\"spring: redis: host: 192.168.150.101 port: 6379 password: 123321 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 \"]},\"1221\":{\"h\":\"5.1.3、测试代码\",\"t\":[\"@SpringBootTest class RedisDemoApplicationTests { @Autowired private RedisTemplate<String, Object> redisTemplate; @Test void testString() { // 写入一条String数据 redisTemplate.opsForValue().set(\\\"name\\\", \\\"虎哥\\\"); // 获取string数据 Object name = redisTemplate.opsForValue().get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } } \",\"贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可\",\"SpringDataRedis的使用步骤：\",\"引入spring-boot-starter-data-redis依赖\",\"在application.yml配置Redis信息\",\"注入RedisTemplate\"]},\"1222\":{\"h\":\"5.2、数据序列化器\",\"t\":[\"RedisTemplate可以接收任意Object作为值写入Redis：\",\"只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：\",\"缺点：\",\"可读性差\",\"内存占用较大\",\"我们可以自定义RedisTemplate的序列化方式，代码如下：\",\"@Configuration public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){ // 创建RedisTemplate对象 RedisTemplate<String, Object> template = new RedisTemplate<>(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; } } \",\"这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：\",\"整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。\"]},\"1223\":{\"h\":\"5.3、StringRedisTemplate\",\"t\":[\"尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：\",\"1653054602930\",\"为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。\",\"为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间\",\"1653054744832\",\"这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。\",\"省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：\",\"@SpringBootTest class RedisStringTests { @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() { // 写入一条String数据 stringRedisTemplate.opsForValue().set(\\\"verify:phone:13600527634\\\", \\\"124143\\\"); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException { // 创建对象 User user = new User(\\\"虎哥\\\", 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(\\\"user:200\\\", json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(\\\"user:200\\\"); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(\\\"user1 = \\\" + user1); } } \",\"此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~\",\"1653054945211\",\"最后小总结：\",\"RedisTemplate的两种序列化实践方案：\",\"方案一：\",\"自定义RedisTemplate\",\"修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer\",\"方案二：\",\"使用StringRedisTemplate\",\"写入Redis时，手动把对象序列化为JSON\",\"读取Redis时，手动把读取到的JSON反序列化为对象\"]},\"1224\":{\"h\":\"5.4、Hash结构操作\",\"t\":[\"在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦\",\"马上就开始新的篇章~~~进入到我们的Redis实战篇\",\"@SpringBootTest class RedisStringTests { @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testHash() { stringRedisTemplate.opsForHash().put(\\\"user:400\\\", \\\"name\\\", \\\"虎哥\\\"); stringRedisTemplate.opsForHash().put(\\\"user:400\\\", \\\"age\\\", \\\"21\\\"); Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(\\\"user:400\\\"); System.out.println(\\\"entries = \\\" + entries); } } \"]},\"1225\":{\"c\":[\"redis\"]},\"1226\":{\"c\":[\"redis\"]},\"1227\":{\"h\":\"MyBatis / MyBatis-Plus\"},\"1228\":{\"h\":\"Mybatis\"},\"1229\":{\"h\":\"@Param / @RequestBody\",\"t\":[\"发现在dao层方法接口的参数中不用@Param指定参数名称，在xml中也是可以直接用#{}来对参数进行引用，查了很多资料解释是idea进行了预处理，所以即使不报错，也需要在dao层参数名称位置指定具体名称，以免其他开发环境下出现bug。\",\"@RequestBody是对json格式的入参进行处理，将json格式数据封装成具体的vo或者po实体类，目前现在都是前后端分离的项目，前端传过来的参数都是json格式的，所以在controller层实体类型的参数前需要加上@RequestBody注解。\"]},\"1230\":{\"h\":\"$和#\",\"t\":[\"#{}相当于占位符，编译时会进行预处理用?替换原来的位置。而${}相当于字符串拼接，不到万不得已不要使用，因为有sql注入的风险。\",\"两种必须要使用${}的情况：\",\"采用in来进行批量删除时只能采用${}进行字符串拼接\",\"String ids = \\\"1,2,3\\\"; \",\"delete from user where id in (${ids}) # 正确写法 # delete from user where id in (#{ids})会被解析成 # delete from user where id in ('1,2,3')，虽然spring执行不报错，但是并不能正确删除 \",\"动态设置表名的问题\",\"select * from #{tableName} # 错误的，表名不能有单引号 # 只能使用${} select * from ${tableName} # 正确写法 \",\"模糊查询时如果使用了#进行sql编写，例如select * from user where name = '%#{name}%'，这种情况占位符?会被当成字符串来处理，sql会变成select * from user where name = '%?%'，因此出现错误。\",\"解决方案：\",\"采用${}来拼接sql\",\"采用mysql自带的concat函数进行拼接\",\"select * from user where name like concat('%', #{name}, '%') \",\"采用双引号进行拼接（最常使用）\",\"select * from user where name like \\\"%\\\"#{name}\\\"%\\\" \",\"如果dao层查询出来的数据没有一个实体类对象与之一一对应，则ResultType可以设置成map，最终将结果相应给前端。\",\"通过association解决多对一映射关系\",\"一般都可以使用分布查询来解决，先通过user_id查询出User完整信息以及role_id，之后通过role_id查询出Role的完整信息，只需要在service中将查询出来的Role封装到User实体类中即可。\",\"假设有如下两张表：\",\" user表 | Role表 ------------------------ user_id | role_id user_name | role_name role_id | \",\"但是User实体类中具有Role实体类：\",\"public class User { private Long userId; private String userName; private Role role; } \",\"通过级联查询将结果直接映射在User实体类中，则需要ResultMap来手动指定映射关系\",\"<ResultMap id=\\\"test\\\" type=\\\"User\\\"> <id properties=\\\"userId\\\" column=\\\"user_id\\\"></id> <id properties=\\\"userName\\\" column=\\\"user_name\\\"></id> <association property=\\\"role\\\" javaType=\\\"Role\\\"> <id properties=\\\"roleId\\\" column=\\\"role_id\\\"></id> <id properties=\\\"roleName\\\" column=\\\"role_name\\\"></id> </association> </ResultMap> <select id=\\\"getUserAndRole\\\" resultMap=\\\"test\\\"> select * from user left join role on user.role_id = role.role_id where user.user_id = #{id} </select> \",\"通过分步查询解决多对一映射关系\",\"优点是可以开启延迟加载\",\"通过在配置文件中指定mybatis.configuration.lazy-loading-enabled=true来手动开启，如果mybatis版本低于3.4.1还需要手动设置mybatis.configuration.aggressiveLazyLoading=false。\",\"当延迟加载开启后，当我们只查询user信息时，调用<select id=\\\"getUserAndRole\\\">则只会执行select * from user where user_id = #{id}的部分，否则级联部分sql语句也会执行。\",\"延迟加载配置是全局开启的，如果想要细粒度控制则需要设置association的fetchType=\\\"eager\\\"，表明该association不开启延迟加载\",\"其中association中的select对应RoleMapper.java的全类名加上对应的方法名，column是分步查询的条件\",\"<!-- RoleMapper.xml --> <select id=\\\"getRole\\\" resultType=\\\"Role\\\"> select * from role where role_id = #{id} </select> <!-- UserMapper.xml --> <ResultMap id=\\\"test\\\" type=\\\"User\\\"> <id properties=\\\"userId\\\" column=\\\"user_id\\\"></id> <id properties=\\\"userName\\\" column=\\\"user_name\\\"></id> <association property=\\\"role\\\" select=\\\"com.vingkin.role.dao.RoleMapper.getRole\\\" column=\\\"role_id\\\"> </association> </ResultMap> <select id=\\\"getUserAndRole\\\" resultMap=\\\"test\\\"> select * from user where user_id = #{id} </select> \",\"通过collection解决一对多映射关系和通过分步查询解决一对多映射关系如上述代码相差不大，故不细加阐述。\"]},\"1231\":{\"h\":\"Mybatis分页操作\",\"t\":[\"Mybatis+PageHelper插件即可实现分页操作\"]},\"1232\":{\"h\":\"Mybatis动态表模式实现\",\"t\":[\"关键点在于如下拦截器的编写，需要先在业务层中向线程变量存入province属性，然后在拦截其中进行拦截处理。对拦截器代码进行了相关优化，可以自定义属性。比如下面代码，线程变量中如果有province字段，则会与原表名t_user进行拼接，以t_user_province格式回调，以达到动态表名的效果，province字段需要从前端传过来。如果未来业务有其他拼接字段，也都可以进行简单修改即可使用。\",\"@Configuration @MapperScan(\\\"com.vingkin.dynamictable.mapper\\\") public class MybatisPlusConfig { /** * 添加动态表名插件 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor(); dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -> { // 获取参数方法 Map<String, Object> paramMap = RequestDataHelper.getRequestData(); if (CollectionUtils.isNotEmpty(paramMap)) { // 获取传递的参数 StringBuilder tableNameSuffix = new StringBuilder(); if (ObjectUtils.isNotEmpty(paramMap.get(\\\"province\\\"))) { tableNameSuffix.append(\\\"_\\\").append((String) paramMap.get(\\\"province\\\")); } // 组装动态表名 return tableName + tableNameSuffix; } return tableName; }); interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor); return interceptor; } } \"]},\"1233\":{\"h\":\"Mybatis Plus\"},\"1234\":{\"h\":\"前端传来不定条件Mybatis-Plus的解决方案\",\"t\":[\"其wrapper方法中第一个参数为condition，返回true即拼接否则不拼接。\",\"/** * String name; * Integer age; */ public void radomCondition(User user) { QueryWrapper<User> wrapper = new QueryWrapper<>(); // Mybatis-Plus包中的StringUtils wrapper.like(StringUtils.isNotBlank(name), \\\"name\\\", user.getName()) .eq(age != null, \\\"age\\\", user.getAge()); List<User> users = userMapper.selectList(wrapper); } \"]},\"1235\":{\"h\":\"函数式SQL\",\"t\":[\"使用LambdaQueryWrapper和LambdaUpdateWrapper替代QueryWrapper和UpdateWrapper。\",\"前两者采用函数式方法获取列名，避免列名出错的情况\",\"// 使用QueryWrapper的情况 QueryWrapper<User> wrapper = new QueryWrapper<>(); queryWrapper.like(StringUtils.isNotBlank(name), \\\"name\\\", user.getName()) .ge(age != null, \\\"age\\\", user.getAge()); // 使用LambdaQueryWrapper的情况 LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>(); queryWrapper.like(StringUtils.isNotBlank(name), User::getName, user.getName()) .ge(age != null, User::getAge, user.getAge()); \"]},\"1236\":{\"h\":\"Mybatis-Plus多数据源\",\"t\":[\"引入依赖\",\"<mybatisplus.version>3.5.1</mybatisplus.version> <!-- mybatis-plus --> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>${mybatisplus.version}</version> </dependency> <!-- mybatis-plus多数据源 --> <dependency> <groupId>com.baomidou</groupId> <artifactId>dynamic-datasource-spring-boot-starter</artifactId> <version>${mybatisplus.version}</version> </dependency> \",\"在配置文件中进行配置\",\"spring: # 配置数据源信息 datasource: dynamic: # 设置默认的数据源或者数据源组,datasource1 primary: datasource-mysql # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: datasource-mysql: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/t_user?serverTimeZone=GMT%2B8&characterEncoding=utf-8&useSSL=false username: root password: 123456 datasource-pgsql: driver-class-name: org.postgresql.Driver url: jdbc:postgresql://localhost:58063/test username: postgres password: 123456 \",\"在业务层实现类方法的类名或方法名上通过@DS(\\\"datasource\\\")指定访问数据源。\",\"@Service @DS(\\\"datasource-mysql\\\") // 在类名上指定使用数据源 public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService{ } \"]},\"1237\":{\"h\":\"通过MybatisX插件自动生成代码\",\"t\":[\"MybatisX\"]},\"1238\":{\"h\":\"Spring 高级\"},\"1239\":{\"h\":\"容器与 bean\"},\"1240\":{\"h\":\"1) 容器接口\",\"t\":[\"BeanFactory 接口，典型功能有：\",\"getBean\",\"ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：\",\"国际化\",\"通配符方式获取一组 Resource 资源\",\"整合 Environment 环境（能通过它获取各种来源的配置信息）\",\"事件发布与监听，实现组件之间的解耦\",\"可以看到，我们课上讲的，都是 BeanFactory 提供的基本功能，ApplicationContext 中的扩展功能都没有用到。\"]},\"1241\":{\"h\":\"演示1 - BeanFactory 与 ApplicationContext 的区别\"},\"1242\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a01 包\"]},\"1243\":{\"h\":\"收获💡\",\"t\":[\"通过这个示例结合 debug 查看 ApplicationContext 对象的内部结构，学到：\",\"到底什么是 BeanFactory\",\"它是 ApplicationContext 的父接口\",\"它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能，【组合】是指 ApplicationContext 的一个重要成员变量就是 BeanFactory\",\"BeanFactory 能干点啥\",\"表面上只有 getBean\",\"实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能，都由它的实现类提供\",\"例子中通过反射查看了它的成员变量 singletonObjects，内部包含了所有的单例 bean\",\"ApplicationContext 比 BeanFactory 多点啥\",\"ApplicationContext 组合并扩展了 BeanFactory 的功能\",\"国际化、通配符方式获取一组 Resource 资源、整合 Environment 环境、事件发布与监听\",\"新学一种代码之间解耦途径，事件解耦\",\"建议练习：完成用户注册与发送短信之间的解耦，用事件方式、和 AOP 方式分别实现\",\"注意\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED，这是因为这些版本的 jdk 默认不允许跨 module 反射\",\"事件发布还可以异步，这个视频中没有展示，请自行查阅 @EnableAsync，@Async 的用法\"]},\"1244\":{\"h\":\"演示2 - 国际化\",\"t\":[\"public class TestMessageSource { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(\\\"messageSource\\\", MessageSource.class, () -> { ResourceBundleMessageSource ms = new ResourceBundleMessageSource(); ms.setDefaultEncoding(\\\"utf-8\\\"); ms.setBasename(\\\"messages\\\"); return ms; }); context.refresh(); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.ENGLISH)); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.CHINESE)); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.JAPANESE)); } } \",\"国际化文件均在 src/resources 目录下\",\"messages.properties（空）\",\"messages_en.properties\",\"hi=Hello \",\"messages_ja.properties\",\"hi=こんにちは \",\"messages_zh.properties\",\"hi=你好 \",\"注意\",\"ApplicationContext 中 MessageSource bean 的名字固定为 messageSource\",\"使用 SpringBoot 时，国际化文件名固定为 messages\",\"空的 messages.properties 也必须存在\"]},\"1245\":{\"h\":\"2) 容器实现\",\"t\":[\"Spring 的发展历史较为悠久，因此很多资料还在讲解它较旧的实现，这里出于怀旧的原因，把它们都列出来，供大家参考\",\"DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像控制反转和依赖注入功能，都是它来实现\",\"ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）\",\"FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）\",\"XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）\",\"AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）\",\"AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）\",\"AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）\",\"AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）\",\"另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是组合了 DefaultListableBeanFactory 的功能，并非继承而来\"]},\"1246\":{\"h\":\"演示1 - DefaultListableBeanFactory\"},\"1247\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a02.TestBeanFactory\"]},\"1248\":{\"h\":\"收获💡\",\"t\":[\"beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象 \",\"我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中\",\"bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等\",\"beanFactory 需要手动调用 beanFactory 后处理器对它做增强 \",\"例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition\",\"beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强 \",\"例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的\",\"bean 后处理的添加顺序会对解析结果有影响，见视频中同时加 @Autowired，@Resource 的例子\",\"beanFactory 需要手动调用方法来初始化单例\",\"beanFactory 需要额外设置才能解析 ${} 与 #{}\"]},\"1249\":{\"h\":\"演示2 - 常见 ApplicationContext 实现\"},\"1250\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a02.A02\"]},\"1251\":{\"h\":\"收获💡\",\"t\":[\"常见的 ApplicationContext 容器实现\",\"内嵌容器、DispatcherServlet 的创建方法、作用\"]},\"1252\":{\"h\":\"3) Bean 的生命周期\",\"t\":[\"一个受 Spring 管理的 bean，生命周期主要阶段有\",\"创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象\",\"依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系\",\"初始化：回调各种 Aware 接口，调用对象的各种初始化方法\",\"销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法） \",\"prototype 对象也能够销毁，不过需要容器这边主动调用\",\"一些资料会提到，生命周期中还有一类 bean 后处理器：BeanPostProcessor，会在 bean 的初始化的前后，提供一些扩展逻辑。但这种说法是不完整的，见下面的演示1\"]},\"1253\":{\"h\":\"演示1 - bean 生命周期\"},\"1254\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a03 包\",\"创建前后的增强\",\"postProcessBeforeInstantiation \",\"这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程\",\"postProcessAfterInstantiation \",\"这里如果返回 false 会跳过依赖注入阶段\",\"依赖注入前的增强\",\"postProcessProperties \",\"如 @Autowired、@Value、@Resource\",\"初始化前后的增强\",\"postProcessBeforeInitialization \",\"这里返回的对象会替换掉原本的 bean\",\"如 @PostConstruct、@ConfigurationProperties\",\"postProcessAfterInitialization \",\"这里返回的对象会替换掉原本的 bean\",\"如代理增强\",\"销毁之前的增强\",\"postProcessBeforeDestruction \",\"如 @PreDestroy\"]},\"1255\":{\"h\":\"收获💡\",\"t\":[\"Spring bean 生命周期各个阶段\",\"模板设计模式, 指大流程已经固定好了, 通过接口回调（bean 后处理器）在一些关键点前后提供扩展\"]},\"1256\":{\"h\":\"演示2 - 模板方法设计模式\"},\"1257\":{\"h\":\"关键代码\",\"t\":[\"public class TestMethodTemplate { public static void main(String[] args) { MyBeanFactory beanFactory = new MyBeanFactory(); beanFactory.addBeanPostProcessor(bean -> System.out.println(\\\"解析 @Autowired\\\")); beanFactory.addBeanPostProcessor(bean -> System.out.println(\\\"解析 @Resource\\\")); beanFactory.getBean(); } // 模板方法 Template Method Pattern static class MyBeanFactory { public Object getBean() { Object bean = new Object(); System.out.println(\\\"构造 \\\" + bean); System.out.println(\\\"依赖注入 \\\" + bean); // @Autowired, @Resource for (BeanPostProcessor processor : processors) { processor.inject(bean); } System.out.println(\\\"初始化 \\\" + bean); return bean; } private List<BeanPostProcessor> processors = new ArrayList<>(); public void addBeanPostProcessor(BeanPostProcessor processor) { processors.add(processor); } } static interface BeanPostProcessor { public void inject(Object bean); // 对依赖注入阶段的扩展 } } \"]},\"1258\":{\"h\":\"演示3 - bean 后处理器排序\"},\"1259\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a03.TestProcessOrder\"]},\"1260\":{\"h\":\"收获💡\",\"t\":[\"实现了 PriorityOrdered 接口的优先级最高\",\"实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序\",\"其它的排在最后\"]},\"1261\":{\"h\":\"4) Bean 后处理器\"},\"1262\":{\"h\":\"演示1 - 后处理器作用\"},\"1263\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a04 包\"]},\"1264\":{\"h\":\"收获💡\",\"t\":[\"@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成\",\"每个后处理器各自增强什么功能 \",\"AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value\",\"CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy\",\"ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties\",\"另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等\"]},\"1265\":{\"h\":\"演示2 - @Autowired bean 后处理器运行分析\"},\"1266\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a04.DigInAutowired\"]},\"1267\":{\"h\":\"收获💡\",\"t\":[\"AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata\",\"InjectionMetadata 可以完成依赖注入\",\"InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型\",\"有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找\"]},\"1268\":{\"h\":\"5) BeanFactory 后处理器\"},\"1269\":{\"h\":\"演示1 - BeanFactory 后处理器的作用\"},\"1270\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05 包\",\"ConfigurationClassPostProcessor 可以解析 \",\"@ComponentScan\",\"@Bean\",\"@Import\",\"@ImportResource\",\"MapperScannerConfigurer 可以解析 \",\"Mapper 接口\"]},\"1271\":{\"h\":\"收获💡\",\"t\":[\"@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能\",\"这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义\"]},\"1272\":{\"h\":\"演示2 - 模拟解析 @ComponentScan\"},\"1273\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.ComponentScanPostProcessor\"]},\"1274\":{\"h\":\"收获💡\",\"t\":[\"Spring 操作元数据的工具类 CachingMetadataReaderFactory\",\"通过注解元数据（AnnotationMetadata）获取直接或间接标注的注解信息\",\"通过类元数据（ClassMetadata）获取类名，AnnotationBeanNameGenerator 生成 bean 名\",\"解析元数据是基于 ASM 技术\"]},\"1275\":{\"h\":\"演示3 - 模拟解析 @Bean\"},\"1276\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.AtBeanPostProcessor\"]},\"1277\":{\"h\":\"收获💡\",\"t\":[\"进一步熟悉注解元数据（AnnotationMetadata）获取方法上注解信息\"]},\"1278\":{\"h\":\"演示4 - 模拟解析 Mapper 接口\"},\"1279\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.MapperPostProcessor\"]},\"1280\":{\"h\":\"收获💡\",\"t\":[\"Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中\",\"Spring 的诡异做法，根据接口生成的 BeanDefinition 仅为根据接口名生成 bean 名\"]},\"1281\":{\"h\":\"6) Aware 接口\"},\"1282\":{\"h\":\"演示 - Aware 接口及 InitializingBean 接口\"},\"1283\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a06 包\"]},\"1284\":{\"h\":\"收获💡\",\"t\":[\"Aware 接口提供了一种【内置】 的注入手段，例如 \",\"BeanNameAware 注入 bean 的名字\",\"BeanFactoryAware 注入 BeanFactory 容器\",\"ApplicationContextAware 注入 ApplicationContext 容器\",\"EmbeddedValueResolverAware 注入 ${} 解析器\",\"InitializingBean 接口提供了一种【内置】的初始化手段\",\"对比 \",\"内置的注入和初始化不受扩展功能的影响，总会被执行\",\"而扩展功能受某些情况影响可能会失效\",\"因此 Spring 框架内部的类常用内置注入和初始化\"]},\"1285\":{\"h\":\"配置类 @Autowired 失效分析\",\"t\":[\"Java 配置类不包含 BeanFactoryPostProcessor 的情况\",\"Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效\",\"对应代码\",\"@Configuration public class MyConfig1 { private static final Logger log = LoggerFactory.getLogger(MyConfig1.class); @Autowired public void setApplicationContext(ApplicationContext applicationContext) { log.debug(\\\"注入 ApplicationContext\\\"); } @PostConstruct public void init() { log.debug(\\\"初始化\\\"); } @Bean // ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况 public BeanFactoryPostProcessor processor1() { return beanFactory -> { log.debug(\\\"执行 processor1\\\"); }; } } \",\"注意\",\"解决方法：\",\"用内置依赖注入和初始化取代扩展依赖注入和初始化\",\"用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建\"]},\"1286\":{\"h\":\"7) 初始化与销毁\"},\"1287\":{\"h\":\"演示 - 初始化销毁顺序\"},\"1288\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a07 包\"]},\"1289\":{\"h\":\"收获💡\",\"t\":[\"Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是\",\"@PostConstruct 标注的初始化方法\",\"InitializingBean 接口的初始化方法\",\"@Bean(initMethod) 指定的初始化方法\",\"与初始化类似，Spring 也提供了多种销毁手段，执行顺序为\",\"@PreDestroy 标注的销毁方法\",\"DisposableBean 接口的销毁方法\",\"@Bean(destroyMethod) 指定的销毁方法\"]},\"1290\":{\"h\":\"8) Scope\",\"t\":[\"在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope\",\"singleton，容器启动时创建（未设置延迟），容器关闭时销毁\",\"prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁\",\"request，每次请求用到此 bean 时创建，请求结束时销毁\",\"session，每个会话用到此 bean 时创建，会话结束时销毁\",\"application，web 容器用到此 bean 时创建，容器停止时销毁\",\"有些文章提到有 globalSession 这一 Scope，也是陈旧的说法，目前 Spring 中已废弃\",\"但要注意，如果在 singleton 注入其它 scope 都会有问题，解决方法有\",\"@Lazy\",\"@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)\",\"ObjectFactory\",\"ApplicationContext.getBean\"]},\"1291\":{\"h\":\"演示1 - request, session, application 作用域\"},\"1292\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a08 包\",\"打开不同的浏览器, 刷新 http://localhost:8080/test 即可查看效果\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"1293\":{\"h\":\"收获💡\",\"t\":[\"有几种 scope\",\"在 singleton 中使用其它几种 scope 的方法\",\"其它 scope 的销毁时机 \",\"可以将通过 server.servlet.session.timeout=30s 观察 session bean 的销毁\",\"ServletContextScope 销毁机制疑似实现有误\"]},\"1294\":{\"h\":\"分析 - singleton 注入其它 scope 失效\",\"t\":[\"以单例注入多例为例\",\"有一个单例对象 E\",\"@Component public class E { private static final Logger log = LoggerFactory.getLogger(E.class); private F f; public E() { log.info(\\\"E()\\\"); } @Autowired public void setF(F f) { this.f = f; log.info(\\\"setF(F f) {}\\\", f.getClass()); } public F getF() { return f; } } \",\"要注入的对象 F 期望是多例\",\"@Component @Scope(\\\"prototype\\\") public class F { private static final Logger log = LoggerFactory.getLogger(F.class); public F() { log.info(\\\"F()\\\"); } } \",\"测试\",\"E e = context.getBean(E.class); F f1 = e.getF(); F f2 = e.getF(); System.out.println(f1); System.out.println(f2); \",\"输出\",\"com.itheima.demo.cycle.F@6622fc65 com.itheima.demo.cycle.F@6622fc65 \",\"发现它们是同一个对象，而不是期望的多例对象\",\"对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F\",\"解决\",\"仍然使用 @Lazy 生成代理\",\"代理对象虽然还是同一个，但当每次使用代理对象的任意方法时，由代理创建新的 f 对象\",\"@Component public class E { @Autowired @Lazy public void setF(F f) { this.f = f; log.info(\\\"setF(F f) {}\\\", f.getClass()); } // ... } \",\"注意\",\"@Lazy 加在也可以加在成员变量上，但加在 set 方法上的目的是可以观察输出，加在成员变量上就不行了\",\"@Autowired 加在 set 方法的目的类似\",\"输出\",\"E: setF(F f) class com.itheima.demo.cycle.F$$EnhancerBySpringCGLIB$$8b54f2bc F: F() com.itheima.demo.cycle.F@3a6f2de3 F: F() com.itheima.demo.cycle.F@56303b57 \",\"从输出日志可以看到调用 setF 方法时，f 对象的类型是代理类型\"]},\"1295\":{\"h\":\"演示2 - 4种解决方法\"},\"1296\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a08.sub 包\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"1297\":{\"h\":\"收获💡\",\"t\":[\"单例注入其它 scope 的四种解决方法 \",\"@Lazy\",\"@Scope(value = \\\"prototype\\\", proxyMode = ScopedProxyMode.TARGET_CLASS)\",\"ObjectFactory\",\"ApplicationContext\",\"解决方法虽然不同，但理念上殊途同归: 都是推迟其它 scope bean 的获取\"]},\"1298\":{\"h\":\"AOP\",\"t\":[\"AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能\",\"除此以外，aspectj 提供了两种另外的 AOP 底层实现：\",\"第一种是通过 ajc 编译器在编译 class 类文件时，就把通知的增强功能，织入到目标类的字节码中\",\"第二种是通过 agent 在加载目标类时，修改目标类的字节码，织入增强功能\",\"作为对比，之前学习的代理是运行时生成新的字节码\",\"简单比较的话：\",\"aspectj 在编译和加载时，修改目标字节码，性能较高\",\"aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强\",\"但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行\"]},\"1299\":{\"h\":\"9) AOP 实现之 ajc 编译器\",\"t\":[\"代码参考项目 demo6_advanced_aspectj_01\"]},\"1300\":{\"h\":\"收获💡\",\"t\":[\"编译器也能修改 class 实现增强\",\"编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强\",\"注意\",\"版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16\",\"一定要用 maven 的 compile 来编译, idea 不会调用 ajc 编译器\"]},\"1301\":{\"h\":\"10) AOP 实现之 agent 类加载\",\"t\":[\"代码参考项目 demo6_advanced_aspectj_02\"]},\"1302\":{\"h\":\"收获💡\",\"t\":[\"类加载时可以通过 agent 修改 class 实现增强\"]},\"1303\":{\"h\":\"11) AOP 实现之 proxy\"},\"1304\":{\"h\":\"演示1 - jdk 动态代理\",\"t\":[\"public class JdkProxyDemo { interface Foo { void foo(); } static class Target implements Foo { public void foo() { System.out.println(\\\"target foo\\\"); } } public static void main(String[] param) { // 目标对象 Target target = new Target(); // 代理对象 Foo proxy = (Foo) Proxy.newProxyInstance( Target.class.getClassLoader(), new Class[]{Foo.class}, (p, method, args) -> { System.out.println(\\\"proxy before...\\\"); Object result = method.invoke(target, args); System.out.println(\\\"proxy after...\\\"); return result; }); // 调用代理 proxy.foo(); } } \",\"运行结果\",\"proxy before... target foo proxy after... \"]},\"1305\":{\"h\":\"收获💡\",\"t\":[\"jdk 动态代理要求目标必须实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系\"]},\"1306\":{\"h\":\"演示2 - cglib 代理\",\"t\":[\"public class CglibProxyDemo { static class Target { public void foo() { System.out.println(\\\"target foo\\\"); } } public static void main(String[] param) { // 目标对象 Target target = new Target(); // 代理对象 Target proxy = (Target) Enhancer.create(Target.class, (MethodInterceptor) (p, method, args, methodProxy) -> { System.out.println(\\\"proxy before...\\\"); Object result = methodProxy.invoke(target, args); // 另一种调用方法，不需要目标对象实例 // Object result = methodProxy.invokeSuper(p, args); System.out.println(\\\"proxy after...\\\"); return result; }); // 调用代理 proxy.foo(); } } \",\"运行结果与 jdk 动态代理相同\"]},\"1307\":{\"h\":\"收获💡\",\"t\":[\"cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系\",\"限制⛔：根据上述分析 final 类无法被 cglib 增强\"]},\"1308\":{\"h\":\"12) jdk 动态代理进阶\"},\"1309\":{\"h\":\"演示1 - 模拟 jdk 动态代理\",\"t\":[\"目标接口Foo.java\",\"public interface Foo { void foo(); int bar(); } \",\"目标类Target.java\",\"public class Target implements Foo { @Override public void foo() { System.out.println(\\\"foo\\\"); } @Override public int bar() { System.out.println(\\\"bar\\\"); return 100; } }; } \",\"InvocationHandler接口\",\"public interface InvocationHandler { Object invoke(Object proxy, Method method, Object[] args) throws Exception; } \",\"代理类$Proxy0\",\"// ⬇️这就是 jdk 代理类的源码, 秘密都在里面 public class $Proxy0 implements Foo { private final InvocationHandler h; public $Proxy0(InvocationHandler h) { this.h = h; } // ⬇️3. 进入代理方法 public void foo() { try { // ⬇️4. 回调 InvocationHandler h.invoke(this, foo, new Object[0]); } catch (RuntimeException | Error e) { throw e; } catch (Throwable e) { throw new UndeclaredThrowableException(e); } } @Override public int bar() { try { Object result = h.invoke(this, bar, new Object[0]); return (int) result; } catch (RuntimeException | Error e) { throw e; } catch (Throwable e) { throw new UndeclaredThrowableException(e); } } static Method foo; static Method bar; static { try { foo = A12.Foo.class.getMethod(\\\"foo\\\"); bar = A12.Foo.class.getMethod(\\\"bar\\\"); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } } \",\"测试方法\",\"public class Client { public static void main(String[] args) { $Proxy0 proxy = new $Proxy0(new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\\\"before...\\\"); // 发射调用目标方法 Object result = method.invoke(new Target(), args); System.out.println(\\\"after...\\\"); return result; } }); proxy.foo(); proxy.bar(); } } \"]},\"1310\":{\"h\":\"收获💡\",\"t\":[\"代理一点都不难，无非就是利用了多态、反射的知识\",\"方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部\",\"通过接口回调将【增强逻辑】置于代理类之外\",\"配合接口方法反射（是多态调用），就可以再联动调用目标方法\",\"会用 arthas 的 jad 工具反编译代理类\",\"限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现\"]},\"1311\":{\"h\":\"演示2 - 方法反射优化\"},\"1312\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a12.TestMethodInvoke\"]},\"1313\":{\"h\":\"收获💡\",\"t\":[\"前 16 次反射性能较低\",\"第 17 次调用会生成代理类，优化为非反射调用\",\"会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类\",\"注意\",\"运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\"]},\"1314\":{\"h\":\"13) cglib 代理进阶\"},\"1315\":{\"h\":\"演示 - 模拟 cglib 代理\"},\"1316\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a13 包\"]},\"1317\":{\"h\":\"收获💡\",\"t\":[\"和 jdk 动态代理原理查不多\",\"回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor\",\"调用目标时有所改进，见下面代码片段 \",\"method.invoke 是反射调用，必须调用到足够次数才会进行优化\",\"methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）\",\"methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象\",\"public class A14Application { public static void main(String[] args) throws InvocationTargetException { Target target = new Target(); Proxy proxy = new Proxy(); proxy.setCallbacks(new Callback[]{(MethodInterceptor) (p, m, a, mp) -> { System.out.println(\\\"proxy before...\\\" + mp.getSignature()); // ⬇️调用目标方法(三种) // Object result = m.invoke(target, a); // ⬅️反射调用 // Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用 Object result = mp.invokeSuper(p, a); // ⬅️非反射调用, 结合代理用 System.out.println(\\\"proxy after...\\\" + mp.getSignature()); return result; }}); // ⬇️调用代理方法 proxy.save(); } } \",\"注意\",\"调用 Object 的方法, 后两种在 jdk >= 9 时都有问题, 需要 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"1318\":{\"h\":\"14) cglib 避免反射调用\"},\"1319\":{\"h\":\"演示 - cglib 如何避免反射\"},\"1320\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a13.ProxyFastClass，com.itheima.a13.TargetFastClass\"]},\"1321\":{\"h\":\"收获💡\",\"t\":[\"当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类 \",\"ProxyFastClass 配合代理对象一起使用, 避免反射\",\"TargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)\",\"TargetFastClass 记录了 Target 中方法与编号的对应关系 \",\"save(long) 编号 2\",\"save(int) 编号 1\",\"save() 编号 0\",\"首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号\",\"然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射\",\"ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法 \",\"saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)\",\"saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)\",\"saveSuper() 编号 0，不增强, 仅是调用 super.save()\",\"查找方式与 TargetFastClass 类似\",\"为什么有这么麻烦的一套东西呢？ \",\"避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法\",\"用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死\"]},\"1322\":{\"h\":\"15) jdk 和 cglib 在 Spring 中的统一\",\"t\":[\"Spring 中对切点、通知、切面的抽象如下\",\"切点：接口 Pointcut，典型实现 AspectJExpressionPointcut\",\"通知：典型接口为 MethodInterceptor 代表环绕通知\",\"切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut\",\"代理相关类图\",\"AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现\",\"AopProxy 通过 getProxy 创建代理对象\",\"图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）\",\"调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor\"]},\"1323\":{\"h\":\"演示 - 底层切点、通知、切面\"},\"1324\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a15.A15\"]},\"1325\":{\"h\":\"收获💡\",\"t\":[\"底层的切点实现\",\"底层的通知实现\",\"底层的切面实现\",\"ProxyFactory 用来创建代理 \",\"如果指定了接口，且 proxyTargetClass = false，使用 JdkDynamicAopProxy\",\"如果没有指定接口，或者 proxyTargetClass = true，使用 ObjenesisCglibAopProxy \",\"例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy\",\"注意\",\"要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口\"]},\"1326\":{\"h\":\"16) 切点匹配\"},\"1327\":{\"h\":\"演示 - 切点匹配\"},\"1328\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a16.A16\"]},\"1329\":{\"h\":\"收获💡\",\"t\":[\"常见 aspectj 切点用法\",\"aspectj 切点的局限性，实际的 @Transactional 切点实现\"]},\"1330\":{\"h\":\"17) 从 @Aspect 到 Advisor\"},\"1331\":{\"h\":\"演示1 - 代理创建器\"},\"1332\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy 包\"]},\"1333\":{\"h\":\"收获💡\",\"t\":[\"AnnotationAwareAspectJAutoProxyCreator 的作用 \",\"将高级 @Aspect 切面统一为低级 Advisor 切面\",\"在合适的时机创建代理\",\"findEligibleAdvisors 找到有【资格】的 Advisors \",\"有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3\",\"有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得\",\"wrapIfNecessary \",\"它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理\",\"它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行\"]},\"1334\":{\"h\":\"演示2 - 代理创建时机\"},\"1335\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A17_1\"]},\"1336\":{\"h\":\"收获💡\",\"t\":[\"代理的创建时机 \",\"初始化之后 (无循环依赖时)\",\"实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\",\"依赖注入与初始化不应该被增强, 仍应被施加于原始对象\"]},\"1337\":{\"h\":\"演示3 - @Before 对应的低级通知\"},\"1338\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A17_2\"]},\"1339\":{\"h\":\"收获💡\",\"t\":[\"@Before 前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息 \",\"通知代码从哪儿来\",\"切点是什么(这里为啥要切点, 后面解释)\",\"通知对象如何创建, 本例共用同一个 Aspect 对象\",\"类似的还有 \",\"AspectJAroundAdvice (环绕通知)\",\"AspectJAfterReturningAdvice\",\"AspectJAfterThrowingAdvice (环绕通知)\",\"AspectJAfterAdvice (环绕通知)\"]},\"1340\":{\"h\":\"18) 静态通知调用\",\"t\":[\"代理对象调用流程如下（以 JDK 动态代理实现为例）\",\"从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi\",\"首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)\",\"进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)\",\"进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法\",\"目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强\",\"环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强\",\"环绕通知1返回最终的结果\",\"图中不同颜色对应一次环绕通知或目标的调用起始至终结\"]},\"1341\":{\"h\":\"演示1 - 通知调用过程\"},\"1342\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.A18\"]},\"1343\":{\"h\":\"收获💡\",\"t\":[\"代理方法执行时会做如下工作\",\"通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知 \",\"MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor\",\"AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor\",\"这体现的是适配器设计模式\",\"所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可\",\"结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用\"]},\"1344\":{\"h\":\"演示2 - 模拟 MethodInvocation\"},\"1345\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.A18_1\"]},\"1346\":{\"h\":\"收获💡\",\"t\":[\"proceed() 方法调用链中下一个环绕通知\",\"每个环绕通知内部继续调用 proceed()\",\"调用到没有更多通知了, 就调用目标方法\",\"MethodInvocation 的编程技巧在实现拦截器、过滤器时能用上\"]},\"1347\":{\"h\":\"19) 动态通知调用\"},\"1348\":{\"h\":\"演示 - 带参数绑定的通知方法调用\"},\"1349\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A19\"]},\"1350\":{\"h\":\"收获💡\",\"t\":[\"通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知\",\"所谓动态通知，体现在上面方法的 DynamicInterceptionAdvice 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式\",\"动态通知调用复杂程度高，性能较低\"]},\"1351\":{\"h\":\"WEB\"},\"1352\":{\"h\":\"20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter\",\"t\":[\"RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter 俩是一对，分别用来\",\"处理 @RequestMapping 映射\",\"调用控制器方法、并处理方法参数与方法返回值\"]},\"1353\":{\"h\":\"演示1 - DispatcherServlet 初始化\"},\"1354\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a20 包\"]},\"1355\":{\"h\":\"收获💡\",\"t\":[\"DispatcherServlet 是在第一次被访问时执行初始化, 也可以通过配置修改为 Tomcat 启动后就初始化\",\"在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 HandlerMapping、HandlerAdapter 等，并逐一调用它们的初始化\",\"RequestMappingHandlerMapping 初始化时，会收集所有 @RequestMapping 映射信息，封装为 Map，其中 \",\"key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息\",\"value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象\",\"有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet\",\"RequestMappingHandlerAdapter 初始化时，会准备 HandlerMethod 调用时需要的各个组件，如： \",\"HandlerMethodArgumentResolver 解析控制器方法参数\",\"HandlerMethodReturnValueHandler 处理控制器方法返回值\"]},\"1356\":{\"h\":\"演示2 - 自定义参数与返回值处理器\"},\"1357\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a20.TokenArgumentResolver ，com.itheima.a20.YmlReturnValueHandler\"]},\"1358\":{\"h\":\"收获💡\",\"t\":[\"体会参数解析器的作用\",\"体会返回值处理器的作用\"]},\"1359\":{\"h\":\"21) 参数解析器\"},\"1360\":{\"h\":\"演示 - 常见参数解析器\"},\"1361\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a21 包\"]},\"1362\":{\"h\":\"收获💡\",\"t\":[\"初步了解 RequestMappingHandlerAdapter 的调用过程 \",\"控制器方法被封装为 HandlerMethod\",\"准备对象绑定与类型转换\",\"准备 ModelAndViewContainer 用来存储中间 Model 结果\",\"解析每个参数值\",\"解析参数依赖的就是各种参数解析器，它们都有两个重要方法 \",\"supportsParameter 判断是否支持方法参数\",\"resolveArgument 解析方法参数\",\"常见参数的解析 \",\"@RequestParam\",\"省略 @RequestParam\",\"@RequestParam(defaultValue)\",\"MultipartFile\",\"@PathVariable\",\"@RequestHeader\",\"@CookieValue\",\"@Value\",\"HttpServletRequest 等\",\"@ModelAttribute\",\"省略 @ModelAttribute\",\"@RequestBody\",\"组合模式在 Spring 中的体现\",\"@RequestParam, @CookieValue 等注解中的参数名、默认值, 都可以写成活的, 即从 ${ } #{ }中获取\"]},\"1363\":{\"h\":\"22) 参数名解析\"},\"1364\":{\"h\":\"演示 - 两种方法获取参数名\"},\"1365\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a22.A22\"]},\"1366\":{\"h\":\"收获💡\",\"t\":[\"如果编译时添加了 -parameters 可以生成参数表, 反射时就可以拿到参数名\",\"如果编译时添加了 -g 可以生成调试信息, 但分为两种情况 \",\"普通类, 会包含局部变量表, 用 asm 可以拿到参数名\",\"接口, 不会包含局部变量表, 无法获得参数名 \",\"这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名\"]},\"1367\":{\"h\":\"23) 对象绑定与类型转换\"},\"1368\":{\"h\":\"底层第一套转换接口与实现\",\"t\":[\"Printer 把其它类型转为 String\",\"Parser 把 String 转为其它类型\",\"Formatter 综合 Printer 与 Parser 功能\",\"Converter 把类型 S 转为类型 T\",\"Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合\",\"FormattingConversionService 利用其它们实现转换\"]},\"1369\":{\"h\":\"底层第二套转换接口\",\"t\":[\"PropertyEditor 把 String 与其它类型相互转换\",\"PropertyEditorRegistry 可以注册多个 PropertyEditor 对象\",\"与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配\"]},\"1370\":{\"h\":\"高层接口与实现\",\"t\":[\"它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式） \",\"首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)\",\"再看有没有 ConversionService 转换\",\"再利用默认的 PropertyEditor 转换\",\"最后有一些特殊处理\",\"SimpleTypeConverter 仅做类型转换\",\"BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property\",\"DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field\",\"ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能\"]},\"1371\":{\"h\":\"演示1 - 类型转换与数据绑定\"},\"1372\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23 包\"]},\"1373\":{\"h\":\"收获💡\",\"t\":[\"基本的类型转换与数据绑定用法\",\"SimpleTypeConverter\",\"BeanWrapperImpl\",\"DirectFieldAccessor\",\"ServletRequestDataBinder\"]},\"1374\":{\"h\":\"演示2 - 数据绑定工厂\"},\"1375\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23.TestServletDataBinderFactory\"]},\"1376\":{\"h\":\"收获💡\",\"t\":[\"ServletRequestDataBinderFactory 的用法和扩展点\",\"可以解析控制器的 @InitBinder 标注方法作为扩展点，添加自定义转换器 \",\"控制器私有范围\",\"可以通过 ConfigurableWebBindingInitializer 配置 ConversionService 作为扩展点，添加自定义转换器 \",\"公共范围\",\"同时加了 @InitBinder 和 ConversionService 的转换优先级 \",\"优先采用 @InitBinder 的转换器\",\"其次使用 ConversionService 的转换器\",\"使用默认转换器\",\"特殊处理（例如有参构造）\"]},\"1377\":{\"h\":\"演示3 - 获取泛型参数\"},\"1378\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23.sub 包\"]},\"1379\":{\"h\":\"收获💡\",\"t\":[\"java api 获取泛型参数\",\"spring api 获取泛型参数\"]},\"1380\":{\"h\":\"24) @ControllerAdvice 之 @InitBinder\"},\"1381\":{\"h\":\"演示 - 准备 @InitBinder\",\"t\":[\"准备 @InitBinder 在整个 HandlerAdapter 调用过程中所处的位置\",\"RequestMappingHandlerAdapter 在图中缩写为 HandlerAdapter\",\"HandlerMethodArgumentResolverComposite 在图中缩写为 ArgumentResolvers\",\"HandlerMethodReturnValueHandlerComposite 在图中缩写为 ReturnValueHandlers\"]},\"1382\":{\"h\":\"收获💡\",\"t\":[\"RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法\",\"RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法\",\"以上两种 @InitBinder 的解析结果都会缓存来避免重复解析\",\"控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂\"]},\"1383\":{\"h\":\"25) 控制器方法执行流程\"},\"1384\":{\"h\":\"图1\",\"t\":[\"HandlerMethod 需要\",\"bean 即是哪个 Controller\",\"method 即是 Controller 中的哪个方法\",\"ServletInvocableHandlerMethod 需要\",\"WebDataBinderFactory 负责对象绑定、类型转换\",\"ParameterNameDiscoverer 负责参数名解析\",\"HandlerMethodArgumentResolverComposite 负责解析参数\",\"HandlerMethodReturnValueHandlerComposite 负责处理返回值\"]},\"1385\":{\"h\":\"图2\"},\"1386\":{\"h\":\"图3\"},\"1387\":{\"h\":\"26) @ControllerAdvice 之 @ModelAttribute\"},\"1388\":{\"h\":\"演示 - 准备 @ModelAttribute\"},\"1389\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a26 包\",\"准备 @ModelAttribute 在整个 HandlerAdapter 调用过程中所处的位置\"]},\"1390\":{\"h\":\"收获💡\",\"t\":[\"RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @ModelAttribute 方法\",\"RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @ModelAttribute 方法\",\"以上两种 @ModelAttribute 的解析结果都会缓存来避免重复解析\",\"控制器方法调用时，会综合利用本类的 @ModelAttribute 方法和 @ControllerAdvice 中的 @ModelAttribute 方法创建模型工厂\"]},\"1391\":{\"h\":\"27) 返回值处理器\"},\"1392\":{\"h\":\"演示 - 常见返回值处理器\"},\"1393\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a27 包\"]},\"1394\":{\"h\":\"收获💡\",\"t\":[\"常见的返回值处理器 \",\"ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer\",\"返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer\",\"返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer \",\"此时需找到默认视图名\",\"返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer \",\"此时需找到默认视图名\",\"返回值类型为 ResponseEntity 时 \",\"此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true\",\"返回值类型为 HttpHeaders 时 \",\"会设置 ModelAndViewContainer.requestHandled 为 true\",\"返回值添加了 @ResponseBody 注解时 \",\"此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true\",\"组合模式在 Spring 中的体现 + 1\"]},\"1395\":{\"h\":\"28) MessageConverter\"},\"1396\":{\"h\":\"演示 - MessageConverter 的作用\"},\"1397\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a28.A28\"]},\"1398\":{\"h\":\"收获💡\",\"t\":[\"MessageConverter 的作用 \",\"@ResponseBody 是返回值处理器解析的\",\"但具体转换工作是 MessageConverter 做的\",\"如何选择 MediaType \",\"首先看 @RequestMapping 上有没有指定\",\"其次看 request 的 Accept 头有没有指定\",\"最后按 MessageConverter 的顺序, 谁能谁先转换\"]},\"1399\":{\"h\":\"29) @ControllerAdvice 之 ResponseBodyAdvice\"},\"1400\":{\"h\":\"演示 - ResponseBodyAdvice 增强\"},\"1401\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a29 包\",\"ResponseBodyAdvice 增强 在整个 HandlerAdapter 调用过程中所处的位置\"]},\"1402\":{\"h\":\"收获💡\",\"t\":[\"ResponseBodyAdvice 返回响应体前包装\"]},\"1403\":{\"h\":\"30) 异常解析器\"},\"1404\":{\"h\":\"演示 - ExceptionHandlerExceptionResolver\"},\"1405\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a30.A30\"]},\"1406\":{\"h\":\"收获💡\",\"t\":[\"它能够重用参数解析器、返回值处理器，实现组件重用\",\"它能够支持嵌套异常\"]},\"1407\":{\"h\":\"31) @ControllerAdvice 之 @ExceptionHandler\"},\"1408\":{\"h\":\"演示 - 准备 @ExceptionHandler\"},\"1409\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a31 包\"]},\"1410\":{\"h\":\"收获💡\",\"t\":[\"ExceptionHandlerExceptionResolver 初始化时会解析 @ControllerAdvice 中的 @ExceptionHandler 方法\",\"ExceptionHandlerExceptionResolver 会以类为单位，在该类首次处理异常时，解析此类的 @ExceptionHandler 方法\",\"以上两种 @ExceptionHandler 的解析结果都会缓存来避免重复解析\"]},\"1411\":{\"h\":\"32) Tomcat 异常处理\",\"t\":[\"我们知道 @ExceptionHandler 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内，那么如果是 Filter 出现了异常，如何进行处理呢？\",\"在 Spring Boot 中，是这么实现的：\",\"因为内嵌了 Tomcat 容器，因此可以配置 Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚\",\"先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 /error 也可以通过 ${server.error.path} 进行配置\",\"当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 /error 这个地址 \",\"当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理\",\"Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 /error，所以处理异常的职责就又回到了 Spring\",\"异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到\",\"具体异常信息会由 DefaultErrorAttributes 封装好\",\"BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应 \",\"如果要的不是 text/html，走 MessageConverter 流程\",\"如果需要 text/html，走 mvc 流程，此时又分两种情况 \",\"配置了 ErrorViewResolver，根据状态码去找 View\",\"没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView\",\"评价\",\"一个错误处理搞得这么复杂，就问恶心不？\"]},\"1412\":{\"h\":\"演示1 - 错误页处理\"},\"1413\":{\"h\":\"关键代码\",\"t\":[\"@Bean // ⬅️修改了 Tomcat 服务器默认错误地址, 出错时使用请求转发方式跳转 public ErrorPageRegistrar errorPageRegistrar() { return webServerFactory -> webServerFactory.addErrorPages(new ErrorPage(\\\"/error\\\")); } @Bean // ⬅️TomcatServletWebServerFactory 初始化前用它增强, 注册所有 ErrorPageRegistrar public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor() { return new ErrorPageRegistrarBeanPostProcessor(); } \"]},\"1414\":{\"h\":\"收获💡\",\"t\":[\"Tomcat 的错误页处理手段\"]},\"1415\":{\"h\":\"演示2 - BasicErrorController\"},\"1416\":{\"h\":\"关键代码\",\"t\":[\"@Bean // ⬅️ErrorProperties 封装环境键值, ErrorAttributes 控制有哪些错误信息 public BasicErrorController basicErrorController() { ErrorProperties errorProperties = new ErrorProperties(); errorProperties.setIncludeException(true); return new BasicErrorController(new DefaultErrorAttributes(), errorProperties); } @Bean // ⬅️名称为 error 的视图, 作为 BasicErrorController 的 text/html 响应结果 public View error() { return new View() { @Override public void render( Map<String, ?> model, HttpServletRequest request, HttpServletResponse response ) throws Exception { System.out.println(model); response.setContentType(\\\"text/html;charset=utf-8\\\"); response.getWriter().print(\\\"\\\"\\\" <h3>服务器内部错误</h3> \\\"\\\"\\\"); } }; } @Bean // ⬅️收集容器中所有 View 对象, bean 的名字作为视图名 public ViewResolver viewResolver() { return new BeanNameViewResolver(); } \"]},\"1417\":{\"h\":\"收获💡\",\"t\":[\"Spring Boot 中 BasicErrorController 如何工作\"]},\"1418\":{\"h\":\"33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter\"},\"1419\":{\"h\":\"演示 - 本组映射器和适配器\"},\"1420\":{\"h\":\"关键代码\",\"t\":[\"@Bean public BeanNameUrlHandlerMapping beanNameUrlHandlerMapping() { return new BeanNameUrlHandlerMapping(); } @Bean public SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() { return new SimpleControllerHandlerAdapter(); } @Bean(\\\"/c3\\\") public Controller controller3() { return (request, response) -> { response.getWriter().print(\\\"this is c3\\\"); return null; }; } \"]},\"1421\":{\"h\":\"收获💡\",\"t\":[\"BeanNameUrlHandlerMapping，以 / 开头的 bean 的名字会被当作映射路径\",\"这些 bean 本身当作 handler，要求实现 Controller 接口\",\"SimpleControllerHandlerAdapter，调用 handler\",\"模拟实现这组映射器和适配器\"]},\"1422\":{\"h\":\"34) RouterFunctionMapping 与 HandlerFunctionAdapter\"},\"1423\":{\"h\":\"演示 - 本组映射器和适配器\"},\"1424\":{\"h\":\"关键代码\",\"t\":[\"@Bean public RouterFunctionMapping routerFunctionMapping() { return new RouterFunctionMapping(); } @Bean public HandlerFunctionAdapter handlerFunctionAdapter() { return new HandlerFunctionAdapter(); } @Bean public RouterFunction<ServerResponse> r1() { // ⬇️映射条件 ⬇️handler return route(GET(\\\"/r1\\\"), request -> ok().body(\\\"this is r1\\\")); } \"]},\"1425\":{\"h\":\"收获💡\",\"t\":[\"RouterFunctionMapping, 通过 RequestPredicate 条件映射\",\"handler 要实现 HandlerFunction 接口\",\"HandlerFunctionAdapter, 调用 handler\"]},\"1426\":{\"h\":\"35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter\"},\"1427\":{\"h\":\"演示1 - 本组映射器和适配器\"},\"1428\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.boot.autoconfigure.web.servlet.A35\"]},\"1429\":{\"h\":\"关键代码\",\"t\":[\"@Bean public SimpleUrlHandlerMapping simpleUrlHandlerMapping(ApplicationContext context) { SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping(); Map<String, ResourceHttpRequestHandler> map = context.getBeansOfType(ResourceHttpRequestHandler.class); handlerMapping.setUrlMap(map); return handlerMapping; } @Bean public HttpRequestHandlerAdapter httpRequestHandlerAdapter() { return new HttpRequestHandlerAdapter(); } @Bean(\\\"/**\\\") public ResourceHttpRequestHandler handler1() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"static/\\\"))); return handler; } @Bean(\\\"/img/**\\\") public ResourceHttpRequestHandler handler2() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"images/\\\"))); return handler; } \"]},\"1430\":{\"h\":\"收获💡\",\"t\":[\"SimpleUrlHandlerMapping 不会在初始化时收集映射信息，需要手动收集\",\"SimpleUrlHandlerMapping 映射路径\",\"ResourceHttpRequestHandler 作为静态资源 handler\",\"HttpRequestHandlerAdapter, 调用此 handler\"]},\"1431\":{\"h\":\"演示2 - 静态资源解析优化\"},\"1432\":{\"h\":\"关键代码\",\"t\":[\"@Bean(\\\"/**\\\") public ResourceHttpRequestHandler handler1() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"static/\\\"))); handler.setResourceResolvers(List.of( // ⬇️缓存优化 new CachingResourceResolver(new ConcurrentMapCache(\\\"cache1\\\")), // ⬇️压缩优化 new EncodedResourceResolver(), // ⬇️原始资源解析 new PathResourceResolver() )); return handler; } \"]},\"1433\":{\"h\":\"收获💡\",\"t\":[\"责任链模式体现\",\"压缩文件需要手动生成\"]},\"1434\":{\"h\":\"演示3 - 欢迎页\"},\"1435\":{\"h\":\"关键代码\",\"t\":[\"@Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext context) { Resource resource = context.getResource(\\\"classpath:static/index.html\\\"); return new WelcomePageHandlerMapping(null, context, resource, \\\"/**\\\"); } @Bean public SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() { return new SimpleControllerHandlerAdapter(); } \"]},\"1436\":{\"h\":\"收获💡\",\"t\":[\"欢迎页支持静态欢迎页与动态欢迎页\",\"WelcomePageHandlerMapping 映射欢迎页（即只映射 '/'） \",\"它内置的 handler ParameterizableViewController 作用是不执行逻辑，仅根据视图名找视图\",\"视图名固定为 forward:index.html\",\"SimpleControllerHandlerAdapter, 调用 handler \",\"转发至 /index.html\",\"处理 /index.html 又会走上面的静态资源处理流程\"]},\"1437\":{\"h\":\"映射器与适配器小结\",\"t\":[\"HandlerMapping 负责建立请求与控制器之间的映射关系 \",\"RequestMappingHandlerMapping (与 @RequestMapping 匹配)\",\"WelcomePageHandlerMapping (/)\",\"BeanNameUrlHandlerMapping (与 bean 的名字匹配 以 / 开头)\",\"RouterFunctionMapping (函数式 RequestPredicate, HandlerFunction)\",\"SimpleUrlHandlerMapping (静态资源 通配符 /** /img/**)\",\"之间也会有顺序问题, boot 中默认顺序如上\",\"HandlerAdapter 负责实现对各种各样的 handler 的适配调用 \",\"RequestMappingHandlerAdapter 处理：@RequestMapping 方法 \",\"参数解析器、返回值处理器体现了组合模式\",\"SimpleControllerHandlerAdapter 处理：Controller 接口\",\"HandlerFunctionAdapter 处理：HandlerFunction 函数式接口\",\"HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)\",\"这也是典型适配器模式体现\"]},\"1438\":{\"h\":\"36) mvc 处理流程\",\"t\":[\"当浏览器发送一个请求 http://localhost:8080/hello 后，请求到达服务器，其处理流程是：\",\"服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术\",\"路径：默认映射路径为 /，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为前控制器\",\"jsp 不会匹配到 DispatcherServlet\",\"其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet\",\"创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean\",\"初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量 \",\"HandlerMapping，初始化时记录映射关系\",\"HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器\",\"HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器\",\"ViewResolver\",\"DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法\",\"例如根据 /hello 路径找到 @RequestMapping(\\\"/hello\\\") 对应的控制器方法\",\"控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet\",\"HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象\",\"DispatcherServlet 接下来会：\",\"调用拦截器的 preHandle 方法\",\"RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod \",\"@ControllerAdvice 全局增强点1️⃣：补充模型数据\",\"@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器\",\"使用 HandlerMethodArgumentResolver 准备参数 \",\"@ControllerAdvice 全局增强点3️⃣：RequestBody 增强\",\"调用 ServletInvocableHandlerMethod\",\"使用 HandlerMethodReturnValueHandler 处理返回值 \",\"@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强\",\"根据 ModelAndViewContainer 获取 ModelAndView \",\"如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程 \",\"例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null\",\"如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程\",\"调用拦截器的 postHandle 方法\",\"处理异常或视图渲染 \",\"如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程 \",\"@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理\",\"正常，走视图解析及渲染流程\",\"调用拦截器的 afterCompletion 方法\"]},\"1439\":{\"h\":\"Boot\"},\"1440\":{\"h\":\"37) Boot 骨架项目\",\"t\":[\"如果是 linux 环境，用以下命令即可获取 spring boot 的骨架 pom.xml\",\"curl -G https://start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml \",\"也可以使用 Postman 等工具实现\",\"若想获取更多用法，请参考\",\"curl https://start.spring.io \"]},\"1441\":{\"h\":\"38) Boot War项目\",\"t\":[\"步骤1：创建模块，区别在于打包方式选择 war\",\"接下来勾选 Spring Web 支持\",\"步骤2：编写控制器\",\"@Controller public class MyController { @RequestMapping(\\\"/hello\\\") public String abc() { System.out.println(\\\"进入了控制器\\\"); return \\\"hello\\\"; } } \",\"步骤3：编写 jsp 视图，新建 webapp 目录和一个 hello.jsp 文件，注意文件名与控制器方法返回的视图逻辑名一致\",\"src |- main |- java |- resources |- webapp |- hello.jsp \",\"步骤4：配置视图路径，打开 application.properties 文件\",\"spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp \",\"将来 prefix + 控制器方法返回值 + suffix 即为视图完整路径\"]},\"1442\":{\"h\":\"测试\",\"t\":[\"如果用 mvn 插件 mvn spring-boot:run 或 main 方法测试\",\"必须添加如下依赖，因为此时用的还是内嵌 tomcat，而内嵌 tomcat 默认不带 jasper（用来解析 jsp）\",\"<dependency> <groupId>org.apache.tomcat.embed</groupId> <artifactId>tomcat-embed-jasper</artifactId> <scope>provided</scope> </dependency> \",\"也可以使用 Idea 配置 tomcat 来测试，此时用的是外置 tomcat\",\"骨架生成的代码中，多了一个 ServletInitializer，它的作用就是配置外置 Tomcat 使用的，在外置 Tomcat 启动后，去调用它创建和运行 SpringApplication\"]},\"1443\":{\"h\":\"启示\",\"t\":[\"对于 jar 项目，若要支持 jsp，也可以在加入 jasper 依赖的前提下，把 jsp 文件置入 META-INF/resources\"]},\"1444\":{\"h\":\"39) Boot 启动过程\",\"t\":[\"阶段一：SpringApplication 构造\",\"记录 BeanDefinition 源\",\"推断应用类型\",\"记录 ApplicationContext 初始化器\",\"记录监听器\",\"推断主启动类\",\"阶段二：执行 run 方法\",\"得到 SpringApplicationRunListeners，名字取得不好，实际是事件发布器\",\"发布 application starting 事件1️⃣\",\"封装启动 args\",\"准备 Environment 添加命令行参数（*）\",\"ConfigurationPropertySources 处理（*）\",\"发布 application environment 已准备事件2️⃣\",\"通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）\",\"application.properties，由 StandardConfigDataLocationResolver 解析\",\"spring.application.json\",\"绑定 spring.main 到 SpringApplication 对象（*）\",\"打印 banner（*）\",\"创建容器\",\"准备容器\",\"发布 application context 已初始化事件3️⃣\",\"加载 bean 定义\",\"发布 application prepared 事件4️⃣\",\"refresh 容器\",\"发布 application started 事件5️⃣\",\"执行 runner\",\"发布 application ready 事件6️⃣\",\"这其中有异常，发布 application failed 事件7️⃣\",\"带 * 的有独立的示例\"]},\"1445\":{\"h\":\"演示 - 启动过程\",\"t\":[\"com.itheima.a39.A39_1 对应 SpringApplication 构造\",\"com.itheima.a39.A39_2 对应第1步，并演示 7 个事件\",\"com.itheima.a39.A39_3 对应第2、8到12步\",\"org.springframework.boot.Step3\",\"org.springframework.boot.Step4\",\"org.springframework.boot.Step5\",\"org.springframework.boot.Step6\",\"org.springframework.boot.Step7\"]},\"1446\":{\"h\":\"收获💡\",\"t\":[\"SpringApplication 构造方法中所做的操作 \",\"可以有多种源用来加载 bean 定义\",\"应用类型推断\",\"添加容器初始化器\",\"添加监听器\",\"演示主类推断\",\"如何读取 spring.factories 中的配置\",\"从配置中获取重要的事件发布器：SpringApplicationRunListeners\",\"容器的创建、初始化器增强、加载 bean 定义等\",\"CommandLineRunner、ApplicationRunner 的作用\",\"环境对象 \",\"命令行 PropertySource\",\"ConfigurationPropertySources 规范环境键名称\",\"EnvironmentPostProcessor 后处理增强 \",\"由 EventPublishingRunListener 通过监听事件2️⃣来调用\",\"绑定 spring.main 前缀的 key value 至 SpringApplication\",\"Banner\"]},\"1447\":{\"h\":\"40) Tomcat 内嵌容器\",\"t\":[\"Tomcat 基本结构\",\"Server └───Service ├───Connector (协议, 端口) └───Engine └───Host(虚拟主机 localhost) ├───Context1 (应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase ) │ │ index.html │ └───WEB-INF │ │ web.xml (servlet, filter, listener) 3.0 │ ├───classes (servlet, controller, service ...) │ ├───jsp │ └───lib (第三方 jar 包) └───Context2 (应用2) │ index.html └───WEB-INF web.xml \"]},\"1448\":{\"h\":\"演示1 - Tomcat 内嵌容器\"},\"1449\":{\"h\":\"关键代码\",\"t\":[\"public static void main(String[] args) throws LifecycleException, IOException { // 1.创建 Tomcat 对象 Tomcat tomcat = new Tomcat(); tomcat.setBaseDir(\\\"tomcat\\\"); // 2.创建项目文件夹, 即 docBase 文件夹 File docBase = Files.createTempDirectory(\\\"boot.\\\").toFile(); docBase.deleteOnExit(); // 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context Context context = tomcat.addContext(\\\"\\\", docBase.getAbsolutePath()); // 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() { @Override public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException { HelloServlet helloServlet = new HelloServlet(); ctx.addServlet(\\\"aaa\\\", helloServlet).addMapping(\\\"/hello\\\"); } }, Collections.emptySet()); // 5.启动 Tomcat tomcat.start(); // 6.创建连接器, 设置监听端口 Connector connector = new Connector(new Http11Nio2Protocol()); connector.setPort(8080); tomcat.setConnector(connector); } \"]},\"1450\":{\"h\":\"演示2 - 集成 Spring 容器\"},\"1451\":{\"h\":\"关键代码\",\"t\":[\"WebApplicationContext springContext = getApplicationContext(); // 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() { @Override public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException { // ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等 for (ServletRegistrationBean registrationBean : springContext.getBeansOfType(ServletRegistrationBean.class).values()) { registrationBean.onStartup(ctx); } } }, Collections.emptySet()); \"]},\"1452\":{\"h\":\"41) Boot 自动配置\"},\"1453\":{\"h\":\"AopAutoConfiguration\",\"t\":[\"Spring Boot 是利用了自动配置类来简化了 aop 相关配置\",\"AOP 自动配置类为 org.springframework.boot.autoconfigure.aop.AopAutoConfiguration\",\"可以通过 spring.aop.auto=false 禁用 aop 自动配置\",\"AOP 自动配置的本质是通过 @EnableAspectJAutoProxy 来开启了自动代理，如果在引导类上自己添加了 @EnableAspectJAutoProxy 那么以自己添加的为准\",\"@EnableAspectJAutoProxy 的本质是向容器中添加了 AnnotationAwareAspectJAutoProxyCreator 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的\"]},\"1454\":{\"h\":\"DataSourceAutoConfiguration\",\"t\":[\"对应的自动配置类为：org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\",\"它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效\",\"简单说明一下，Spring Boot 支持两大类数据源：\",\"EmbeddedDatabase - 内嵌数据库连接池\",\"PooledDataSource - 非内嵌数据库连接池\",\"PooledDataSource 又支持如下数据源\",\"hikari 提供的 HikariDataSource\",\"tomcat-jdbc 提供的 DataSource\",\"dbcp2 提供的 BasicDataSource\",\"oracle 提供的 PoolDataSourceImpl\",\"如果知道数据源的实现类类型，即指定了 spring.datasource.type，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）\"]},\"1455\":{\"h\":\"MybatisAutoConfiguration\",\"t\":[\"MyBatis 自动配置类为 org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\",\"它主要配置了两个 bean \",\"SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession\",\"SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定\",\"用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口\",\"用 AutoConfigurationPackages 来确定扫描的包\",\"还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 mybatis. 前缀的配置项进行定制配置\",\"@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别\",\"@MapperScan 扫描具体包（当然也可以配置关注哪个注解）\",\"@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口\",\"MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口\",\"这里有同学有疑问，之前介绍的都是将具体类交给 Spring 管理，怎么到了 MyBatis 这儿，接口就可以被管理呢？\",\"其实并非将接口交给 Spring 管理，而是每个接口会对应一个 MapperFactoryBean，是后者被 Spring 所管理，接口只是作为 MapperFactoryBean 的一个属性来配置\"]},\"1456\":{\"h\":\"TransactionAutoConfiguration\",\"t\":[\"事务自动配置类有两个：\",\"org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration\",\"org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration\",\"前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作\",\"后者功能上对标 @EnableTransactionManagement，包含以下三个 bean\",\"BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点\",\"TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作\",\"AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能\",\"如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准\"]},\"1457\":{\"h\":\"ServletWebServerFactoryAutoConfiguration\",\"t\":[\"提供 ServletWebServerFactory\"]},\"1458\":{\"h\":\"DispatcherServletAutoConfiguration\",\"t\":[\"提供 DispatcherServlet\",\"提供 DispatcherServletRegistrationBean\"]},\"1459\":{\"h\":\"WebMvcAutoConfiguration\",\"t\":[\"配置 DispatcherServlet 的各项组件，提供的 bean 见过的有 \",\"多项 HandlerMapping\",\"多项 HandlerAdapter\",\"HandlerExceptionResolver\"]},\"1460\":{\"h\":\"ErrorMvcAutoConfiguration\",\"t\":[\"提供的 bean 有 BasicErrorController\"]},\"1461\":{\"h\":\"MultipartAutoConfiguration\",\"t\":[\"它提供了 org.springframework.web.multipart.support.StandardServletMultipartResolver\",\"该 bean 用来解析 multipart/form-data 格式的数据\"]},\"1462\":{\"h\":\"HttpEncodingAutoConfiguration\",\"t\":[\"POST 请求参数如果有中文，无需特殊设置，这是因为 Spring Boot 已经配置了 org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter\",\"对应配置 server.servlet.encoding.charset=UTF-8，默认就是 UTF-8\",\"当然，它只影响非 json 格式的数据\"]},\"1463\":{\"h\":\"演示 - 自动配置类原理\"},\"1464\":{\"h\":\"关键代码\",\"t\":[\"假设已有第三方的两个自动配置类\",\"@Configuration // ⬅️第三方的配置类 static class AutoConfiguration1 { @Bean public Bean1 bean1() { return new Bean1(); } } @Configuration // ⬅️第三方的配置类 static class AutoConfiguration2 { @Bean public Bean2 bean2() { return new Bean2(); } } \",\"提供一个配置文件 META-INF/spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔\",\"MyImportSelector=\\\\ AutoConfiguration1,\\\\ AutoConfiguration2 \",\"注意\",\"上述配置文件中 MyImportSelector 与 AutoConfiguration1，AutoConfiguration2 为简洁均省略了包名，自己测试时请将包名根据情况补全\",\"引入自动配置\",\"@Configuration // ⬅️本项目的配置类 @Import(MyImportSelector.class) static class Config { } static class MyImportSelector implements DeferredImportSelector { // ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类 public String[] selectImports(AnnotationMetadata importingClassMetadata) { return SpringFactoriesLoader .loadFactoryNames(MyImportSelector.class, null).toArray(new String[0]); } } \"]},\"1465\":{\"h\":\"收获💡\",\"t\":[\"自动配置类本质上就是一个配置类而已，只是用 META-INF/spring.factories 管理，与应用配置类解耦\",\"@Enable 打头的注解本质是利用了 @Import\",\"@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名\",\"DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析\"]},\"1466\":{\"h\":\"42) 条件装配底层\",\"t\":[\"条件装配的底层是本质上是 @Conditional 与 Condition，这两个注解。引入自动配置类时，期望满足一定条件才能被 Spring 管理，不满足则不管理，怎么做呢？\",\"比如条件是【类路径下必须有 dataSource】这个 bean ，怎么做呢？\",\"首先编写条件判断类，它实现 Condition 接口，编写条件判断逻辑\",\"static class MyCondition1 implements Condition { // ⬇️如果存在 Druid 依赖，条件成立 public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return ClassUtils.isPresent(\\\"com.alibaba.druid.pool.DruidDataSource\\\", null); } } \",\"其次，在要导入的自动配置类上添加 @Conditional(MyCondition1.class)，将来此类被导入时就会做条件检查\",\"@Configuration // 第三方的配置类 @Conditional(MyCondition1.class) // ⬅️加入条件 static class AutoConfiguration1 { @Bean public Bean1 bean1() { return new Bean1(); } } \",\"分别测试加入和去除 druid 依赖，观察 bean1 是否存在于容器\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.17</version> </dependency> \"]},\"1467\":{\"h\":\"收获💡\",\"t\":[\"学习一种特殊的 if - else\"]},\"1468\":{\"h\":\"其它\"},\"1469\":{\"h\":\"43) FactoryBean\"},\"1470\":{\"h\":\"演示 - FactoryBean\"},\"1471\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a43 包\"]},\"1472\":{\"h\":\"收获💡\",\"t\":[\"它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能\",\"使用上较为古怪, 一不留神就会用错 \",\"被 FactoryBean 创建的产品 \",\"会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走\",\"唯有后初始化的流程会走, 也就是产品可以被代理增强\",\"单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中\",\"按名字去获取时, 拿到的是产品对象, 名字前面加 & 获取的是工厂对象\"]},\"1473\":{\"h\":\"44) @Indexed 原理\",\"t\":[\"真实项目中，只需要加入以下依赖即可\",\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-context-indexer</artifactId> <optional>true</optional> </dependency> \"]},\"1474\":{\"h\":\"演示 - @Indexed\"},\"1475\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a44 包\"]},\"1476\":{\"h\":\"收获💡\",\"t\":[\"在编译时就根据 @Indexed 生成 META-INF/spring.components 文件\",\"扫描时 \",\"如果发现 META-INF/spring.components 存在, 以它为准加载 bean definition\",\"否则, 会遍历包下所有 class 资源 (包括 jar 内的)\",\"解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间\"]},\"1477\":{\"h\":\"45) 代理进一步理解\"},\"1478\":{\"h\":\"演示 - 代理\"},\"1479\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a45 包\"]},\"1480\":{\"h\":\"收获💡\",\"t\":[\"spring 代理的设计特点\",\"依赖注入和初始化影响的是原始对象\",\"因此 cglib 不能用 MethodProxy.invokeSuper()\",\"代理与目标是两个对象，二者成员变量并不共用数据\",\"static 方法、final 方法、private 方法均无法增强\",\"进一步理解代理增强基于方法重写\"]},\"1481\":{\"h\":\"46) @Value 装配底层\"},\"1482\":{\"h\":\"按类型装配的步骤\",\"t\":[\"查看需要的类型是否为 Optional，是，则进行封装（非延迟），否则向下走\",\"查看需要的类型是否为 ObjectFactory 或 ObjectProvider，是，则进行封装（延迟），否则向下走\",\"查看需要的类型（成员或参数）上是否用 @Lazy 修饰，是，则返回代理，否则向下走\",\"解析 @Value 的值 \",\"如果需要的值是字符串，先解析 ${ }，再解析 #\",\"不是字符串，需要用 TypeConverter 转换\",\"看需要的类型是否为 Stream、Array、Collection、Map，是，则按集合处理，否则向下走\",\"在 BeanFactory 的 resolvableDependencies 中找有没有类型合适的对象注入，没有向下走\",\"在 BeanFactory 及父工厂中找类型匹配的 bean 进行筛选，筛选时会考虑 @Qualifier 及泛型\",\"结果个数为 0 抛出 NoSuchBeanDefinitionException 异常\",\"如果结果 > 1，再根据 @Primary 进行筛选\",\"如果结果仍 > 1，再根据成员名或变量名进行筛选\",\"结果仍 > 1，抛出 NoUniqueBeanDefinitionException 异常\"]},\"1483\":{\"h\":\"演示 - @Value 装配过程\"},\"1484\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a46 包\"]},\"1485\":{\"h\":\"收获💡\",\"t\":[\"ContextAnnotationAutowireCandidateResolver 作用之一，获取 @Value 的值\",\"了解 ${ } 对应的解析器\",\"了解 #{ } 对应的解析器\",\"TypeConvert 的一项体现\"]},\"1486\":{\"h\":\"47) @Autowired 装配底层\"},\"1487\":{\"h\":\"演示 - @Autowired 装配过程\"},\"1488\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a47 包\"]},\"1489\":{\"h\":\"收获💡\",\"t\":[\"@Autowired 本质上是根据成员变量或方法参数的类型进行装配\",\"如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配\",\"如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配 \",\"此方法可以延迟 bean 的获取\",\"如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配 \",\"此方法可以延迟真实 bean 的获取\",\"被装配的代理不作为 bean\",\"如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配\",\"如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean\",\"如果待装配类型是 ApplicationContext 等特殊类型 \",\"会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配\",\"resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象\",\"不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型\",\"如果待装配类型有泛型参数 \",\"需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选\",\"如果待装配类型有 @Qualifier \",\"需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选\",\"有 @Primary 标注的 @Component 或 @Bean 的处理\",\"与成员变量名或方法参数名同名 bean 的处理\"]},\"1490\":{\"h\":\"48) 事件监听器\"},\"1491\":{\"h\":\"演示 - 事件监听器\"},\"1492\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a48 包\"]},\"1493\":{\"h\":\"收获💡\",\"t\":[\"事件监听器的两种方式\",\"实现 ApplicationListener 接口 \",\"根据接口泛型确定事件类型\",\"@EventListener 标注监听方法 \",\"根据监听器方法参数确定事件类型\",\"解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean\"]},\"1494\":{\"h\":\"49) 事件发布器\"},\"1495\":{\"h\":\"演示 - 事件发布器\"},\"1496\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a49 包\"]},\"1497\":{\"h\":\"收获💡\",\"t\":[\"事件发布器模拟实现\",\"addApplicationListenerBean 负责收集容器中的监听器 \",\"监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型\",\"multicastEvent 遍历监听器集合，发布事件 \",\"发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件\",\"可以利用线程池进行异步发事件优化\",\"如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型 \",\"视频中未讲解\"]},\"1498\":{\"h\":\"Spring\"},\"1499\":{\"h\":\"列举一些重要的Spring模块\",\"t\":[\"下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。\",\"Spring Core：核心模块，Spring其他功能基本都需要依赖于该类库，主要提供IOC依赖注入功能的支持\",\"Spring Aspects：该模块为与AspectJ的集成提供支持\",\"Spring AOP：提供了面向切面编程的实现\",\"Spring Data Access / Integration \",\"spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。\",\"spring-tx : 提供对事务的支持。\",\"spring-orm : 提供对 Hibernate 等 ORM 框架的支持。\",\"spring-oxm ： 提供对 Castor 等 OXM 框架的支持。\",\"spring-jms : Java 消息服务。\",\"Spring Web \",\"spring-web ：对 Web 功能的实现提供一些最基础的支持。\",\"spring-webmvc ： 提供对 Spring MVC 的实现。\",\"spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。\",\"spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.\",\"Spring test：Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。\"]},\"1500\":{\"h\":\"请你说说Spring的核心是什么？\",\"t\":[\"Spring的核心是IoC和AOP\",\"IoC叫反转控制，就是将对象的控制权交由Spring框架来管理。IOC可以帮助我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。\",\"说到IoC就不得不说DI，IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来替代它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。\",\"DI主要有两种注入方式：\",\"构造方法注入\",\"setter方法注入\",\"AOP是面向切面编程的意思。将那些与业务无关却为业务模块共同调用的逻辑或责任（如事务处理、日志管理和权限管理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，也有利于未来的可拓展性和可维护性。比如@Transactional注解就是通过AOP实现的。\",\"Spring AOP是基于动态代理的。如果代理对象实现了某个接口，那么Spring AOP会使用JDK Proxy通过接口去创建代理对象，对于没有实现接口的对象，Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。\",\"当然也可以使用AspectJ！\"]},\"1501\":{\"h\":\"说一说对Spring容器的了解\",\"t\":[\"Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext\",\"BeanFactory：是基础类型的IoC容器，是IoC的顶层接口，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个对象时，该对象才会进行初始化以及依赖注入的操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。\",\"ApplicationContext：他是在BeanFactory的基础上构建的，是BeanFactory的子接口，拥有BeanFactory的所有支持。除此之外，还支持比如事件发布、国际化信息支持（继承了MessageSource）等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并进行依赖注入。所以，对于BeanFactory而言，ApplicationContext要求更多的系统资源。同时，因为在启动时就完成所有初始化，容器启动的时间较BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。\"]},\"1502\":{\"h\":\"说一说对BeanFactory的了解\",\"t\":[\"其实就是说上面的，包括ApplicationContext\",\"BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，可以创建并管理各种类的对象。这些被创建和管理的对象叫做Bean。\",\"BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了很多实现，比较常用的比如AnnotationConfigApplicationContext，常用的方法比如getBean()获取指定名称的Bean。\",\"BeanFactory本身并不会自动解析像@Bean,@Autowired,@Resources这些注解的功能，如果想要通过BeanFactory实现这些功能，则需要向BeanFactory添加一些后置处理器来解析这些注解，从而将相关Bean加入到IoC容器中。\"]},\"1503\":{\"h\":\"Spring是如何管理Bean的\",\"t\":[\"Spring通过IoC来管理Bean，我们可以通过XML配置或者注解来进行配置。\",\"以下是管理Bean时常用的一些注解：\",\"@ComponentScan：用于声明扫描策略。通过它的声明，Spring就知道要哪些包下带声明的类需要被扫描。\",\"@Component，@Repository，@Service，@Controller用于类上声明Bean，他们的作用一样，只是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类当被扫描到时就会创建对应的Bean\",\"@Autowired，@Qualifier，@Resource，@Value用于注入Bean。@Autowired用于按类型注入，@Qualifier指定Bean名称注入需要与@Autowired一起使用，@Resource既可以按类型注入也可以指定Bean名称注入，@Value适用于注入基本类型。\",\"@Scope用于声明Bean的作用域。\",\"@PostConstruct，@PreDestory用于声明Bean的生命周期。其中被@PostConstruct修饰的发给发将在Bean实例化后被调用，@PreDestory修饰的方法将在容器销毁前调用。\"]},\"1504\":{\"h\":\"Bean的作用域\",\"t\":[\"默认情况下，Bean在Spring容器中是单例的，可以通过@Scope注解修改Bean的作用域。\",\"类型\",\"说明\",\"singleton\",\"单例Bean，默认作用域，IoC容器启动时创建，IoC容器销毁时销毁\",\"prototype\",\"每次请求都会创建一个新的bean实例，每次使用时创建，销毁不归容器管，自行调用销毁方法\",\"request\",\"每一次HTTP请求（浏览器刷新页面）都会产生一个新的Bean\",\"session\",\"同一个HTTP Session共享一个Bean，不同的HTTP Session（不同的浏览器）使用不同的Bean\",\"application\",\"应用程序启动时bean创建，应用程序销毁时bean销毁，应用程序值得是ServletContext\"]},\"1505\":{\"h\":\"Bean的生命周期\",\"t\":[\"解析类得到BeanDefinition\",\"通过构造方法实例化得到一个对象（如果有多个构造方法，则要推断使用）\",\"对加了@Autowired或者相关注解对对象进行依赖注入\",\"回调Aware接口的方法，比如BeanNameAware中setBeanName()方法，BeanFactoryAware中setBeanFactory()方法。\",\"调用BeanPostProcessor的初始化前的方法\",\"调用初始化方法\",\"调用BeanPostProcessor的初始化后的方法，这会进行AOP\",\"如果当前创建的Bean是单例的则会放入单例池\",\"使用Bean\",\"Spring容器关闭时调用DisposableBean中的destory()方法\",\"@Slf4j @Component public class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor { @Override // 实例化前（即调用构造方法前）执行的方法 public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 实例化前执行，如@PreDestroy\\\"); // 返回null保持原有对象不变，返回不为null，会替换掉原有对象 return null; } @Override // 实例化后执行的方法 public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) { log.debug(\\\"<<<<<<<<<<< 实例化后执行，这里如果返回 false 会跳过依赖注入阶段\\\"); // return false; } return true; } @Override // 依赖注入阶段执行的方法 public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 依赖注入阶段执行，如@Autowired、@Value、@Resource\\\"); return pvs; } @Override // 销毁前执行的方法 public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<<销毁之前执行\\\"); } @Override // 初始化之前执行的方法 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 初始化之前执行，这里返回的对象会替换掉原本的bean，如 @PostConstruct、@ConfigurationProperties\\\"); return bean; } @Override // 初始化之后执行的方法 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 初始化之后执行，这里返回的对象会替换掉原本的bean，如 代理增强\\\"); return bean; } } \"]},\"1506\":{\"h\":\"单例Bean的线程安全问题了解吗\",\"t\":[\"要是问Bean的线程安全问题需要考虑单例Bean还是多例Bean，多例Bean不存在线程安全问题\",\"单例Bean存在线程安全问题，主要是因为当多个线程操作同一个对象的时候存在共享资源竞争的问题。\",\"两种解决方法：\",\"在Bean中尽量避免定义可变的成员变量。\",\"在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中\",\"不过，大部分Bean实际都是无状态（没有实例变量）的（比如Dao、Service），这种情况下，Bean是线程安全的。\"]},\"1507\":{\"h\":\"@Component和@Bean的区别是什么？\",\"t\":[\"@Component注解作用于类，通常是通过类路径扫描（@ComponentScan）自动侦测以及自动装配到Spring容器中。而@Bean注解作用于方法，将当前方法的返回值存入IOC容器。\",\"@Bean注解比@Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册Bean。比如当我们引用第三方库中的类需要装配到Spring容器中时，只能通过@Bean来实现。\"]},\"1508\":{\"h\":\"AspectJ\",\"t\":[\"AspectJ与Spring AOP和Cglib实现AOP是有所不同的，AspectJ是在字节码的层面上实现的，另外两个是通过代理实现的。\",\"AspectJ相当于在被增强方法的class文件的对应位置调用增强方法实现AOP\",\"对于AspectJ的实现也有两种，一种在编译阶段实现，一种在类加载阶段实现\",\"编译阶段：通过在pom文件中配置AspectJ编译插件实现\",\"类加载阶段：通过配置虚拟机参数-javaagent实现，具体类的样式可以通过阿里巴巴的arthas插件看到\"]},\"1509\":{\"h\":\"Spring AOP和AspectJ AOP的区别？\",\"t\":[\"Spring AOP输入运行时增强，而AspectJ是编译时或者类加载时增强。\",\"Spring AOP基于代理，而AspectJ基于字节码操作。\"]},\"1510\":{\"h\":\"说说AOP的应用场景\",\"t\":[\"Spring AOP为IoC的使用提供了更多的便利。一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨应用的多个模块功能抽象出来，通过AOP编织到模块中，比如可以通过AOP实现应用程序中的日志功能。\",\"另一方面，在Spring内部，事务处理也是通过AOP实现的。\"]},\"1511\":{\"h\":\"Spring AOP不能对哪些类进行增强\",\"t\":[\"Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。\",\"由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。\"]},\"1512\":{\"h\":\"既然没有接口都可以用CGLib，为什么Spring还要使用JDK动态代理\",\"t\":[\"在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象无需频繁创建代理对象，采用CGLib比较合适。反之，对于多例的对象因为要频繁创建代理对象，则JDK动态代理更合适。\"]},\"1513\":{\"h\":\"Spring是如何管理事务的\",\"t\":[\"编程式事务：Spring提供了TransactionTemplate和TransactionManager手动管理事务。这种方式相对麻烦，实际应用中很少使用。\",\"声明式事务：在XML配置文件中配置或者直接基于注解（推荐使用），实际是通过AOP实现的（基于@Transactional的全注解方式使用最多）\"]},\"1514\":{\"h\":\"Spring中的事务传播行为\",\"t\":[\"当我们调用一个业务方法时，它的内部可能会调用其他的业务方法，以完成一个完整的业务操作。这种业务方法嵌套调用的时候，如果这两个方法都是要保证事务的，那么就要通过Spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中。\",\"Spring在TransactionDefinition接口中规定了其中类型的事务传播行为。\",\"事务传播类型\",\"说明\",\"PROPAGATION_REQUIRED\",\"如果当前没有事务，则新建一个事务；如果已存在一个事务，在加入到这个事务中。这时最常见的选择，也是@Transactional的默认选项。\",\"PROPAGATION_REQUIRED_NEW\",\"创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，REQUIRES_NEW修饰的内部方法都会开启自己的新事务，且开启的事务互相独立，互不干扰。\",\"PROPAGATION_NESTED\",\"如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则等价于PROPAGATION_REQUIRED（nested：嵌套的）\",\"PROPAGATION_MANDATORY\",\"如果当前存在事务，则加入该事务；如果不存在则抛出异常。（mandatory：强制性）\",\"PROPAGATION_SUPPORTS\",\"如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式继续运行\",\"PROPAGATION_NOT_SUPPORTED\",\"以非事务方式运行，如果当前存在事务，则把当前事务挂起\",\"PROPAGATION_NEVER\",\"以非事务方式运行，如果当前存在事务，则抛出异常\",\"若是错误的配置了以下三种事务传播行为，事务将不会发生回滚。\"]},\"1515\":{\"h\":\"Spring的事务如何配置，常用注解有那些？\",\"t\":[\"事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器。在Spring Boot中，当你添加了数据库访问框架的起步依赖时，他就会进行自动配置，即自动实例化正确的事务管理器。\",\"对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。\",\"当他标注在类上时，代表着各类所有公共（public）非静态方法（static）都将启用事务功能\",\"当它标注在方法上时，代表这个方法将启用事务功能。\",\"另外，在@Transactional注解上，我们可以使用isolation属性声明事物的隔离级别，使用propagation属性声明事物的传播行为。\"]},\"1516\":{\"h\":\"@Transactional(rollbackFor = Exception.class)注解了解吗\",\"t\":[\"Exception分为运行时异常和非运行时异常。\",\"在@Transactional注解中如果不配置rollbackFor属性，那么事务只会在遇到RuntimeException的时候才会回滚，加上rollbackFor=Exception.class，可以让事务在遇到非运行时异常时也会回滚。\"]},\"1517\":{\"h\":\"@Transactional失效场景\",\"t\":[\"@Transaction应用再非public修饰的方法上\",\"@Transaction注解属性propagation设置错误，上面写的传播行为后三个会使之失效\",\"@Transactional注解属性rollbackFor设置错误\",\"数据库引擎不支持事务，只有InnoDB支持事务\"]},\"1518\":{\"h\":\"Spring是怎么解决循环依赖的\",\"t\":[\"TODO\"]},\"1519\":{\"h\":\"SpringBoot\"},\"1520\":{\"h\":\"说说你对Spring Boot的理解\",\"t\":[\"从本质上来说，Spring Boot就是Spring。Spring Boot使用“约定大于配置”的理念让你的项目快速的运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。\",\"简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目。Spring Boot有如下优点：\",\"可以快速构建项目\",\"可以对主流开发框架的无配置集成\",\"项目可独立运行，无需外部依赖Servlet容器\",\"提供运行时的应用监控\",\"可以极大地提高开发、部署效率\",\"可以与云计算天然集成\"]},\"1521\":{\"h\":\"Spring Boot Starter有什么用\",\"t\":[\"Spring Boot提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。\",\"举例来说，你打算做个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来的简单。你只要添加Spring Boot的Web起步依赖就好了。\"]},\"1522\":{\"h\":\"介绍Spring Boot的启动流程\",\"t\":[\"首先，Spring Boot项目创建完成会默认生成一个名为*Application的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过run方法进行*Application类的初始化和启动。\",\"*Application调用run方法的大致流程如下图：\",\"其中，*Application在run方法中重点做了以下操作：\",\"获取监听器的参数配置\",\"打印Banner信息\",\"创建并初始化容器\",\"监听器发送通知\",\"当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。\"]},\"1523\":{\"h\":\"Spring Boot项目是如何导入包的\",\"t\":[\"通过Spring Boot Starter导入包。其他详见[0x01](#0x01. Spring Boot Starter有什么用).\"]},\"1524\":{\"h\":\"Spring Boot自动装配过程\",\"t\":[\"使用Spring Boot时，我们只需引入对应的Starter，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。\",\"整个自动配置的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean，并注入Spring容器，就可以完成依赖框架的自动配置。\"]},\"1525\":{\"h\":\"说说你对Spring Boot的注解的了解\",\"t\":[\"@SpringBootApplication\",\"这个注解时Spring Boot项目的基石，创建Spring Boot项目之后会默认在主类加上。\",\"我们可以把@SpringBootApplication看作是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan注解的集合。\",\"@EnableAutoConfiguration：启用Spring Boot的自动装配机制\",\"@ComponentScan：包路径扫描，扫描被@Component注解修饰的Bean\",\"@SpringBootConfiguration：就是@Configuration的不同语义的版本，允许在该类中使用@Bean实修方法注册额外的Bean或导入其他配置类\",\"@Import\",\"@EnableAutoConfiguration的关键功能就是通过@Import注解导入的ImportSelector来完成的。从源码得知@Import({AutoConfigurationImportSelector.class})是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。\",\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \\\"spring.boot.enableautoconfiguration\\\"; Class<?>[] exclude() default {}; String[] excludeName() default {}; } \",\"@Conditional\",\"@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制实例化的行为。\",\"@Conditional衍生注解\",\"@ConditionalOnBean：在容器中有指定Bean的时候才会加载\",\"@ConditiaonOnMissingBean：在容器中没有指定Bean的时候才会加载\",\"等等\",\"@RestController\",\"@RestController是@Controller和@ResponseBody的合集，表示这是个控制器Bean，并且是将函数的返回值直接填入HTTP响应体中，返回JSON或XML形式数据，是REST风格的控制器。\",\"@Configuration\",\"一般用来声明配置类，可以用@Component注解替代，不过使用@Configuration注解声明配置类更加语义化。\",\"@PathVariable和@RequestParam\",\"@PathVariable：用于获取路径参数\",\"@RequestParam：用于获取查询参数\",\"@GetMapping(\\\"/klasses/{klassId}/teachers\\\") public List<Teacher> getKlassRelatedTeachers( @PathVariable(\\\"klassId\\\") Long klassId, @RequestParam(value = \\\"type\\\", required = false) String type ) { ... } \",\"如果我们请求的url是：/klasses/123456/teachers?type=web\",\"那么我们服务获取到的数据就是：klassId=123456,type=web\",\"@RequestBody\",\"用于读取Request请求的body部分，并且Content-Type为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的body中的json字符串转换成java对象。\",\"我们有个注册的接口：\",\"@PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) { userService.save(userRegisterRequest); return ResponseEntity.ok().build(); } \",\"UserRegisterRequest对象\",\"@Data @AllArgsConstructor @NoArgsConstructor public class UserRegisterRequest { @NotBlank private String userName; @NotBlank private String password; @NotBlank private String fullName; } \",\"我们发送post请求到这个接口，并且body携带JSON数据。这样我们的后端就可以直接把JSON格式的数据映射到我们的UserRegisterRequest类上。\",\"{\\\"userName\\\":\\\"coder\\\",\\\"fullName\\\":\\\"shuangkou\\\",\\\"password\\\":\\\"123456\\\"} \",\"需要注意的是：一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable。 如果你的方法必须要用两个 @RequestBody来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！\",\"@Value和@ConfigurationProperties\",\"wuhan2020: 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！ my-profile: name: Guide哥 email: koushuangbwcx@163.com library: location: 湖北武汉加油中国加油 books: - name: 天才基本法 description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。 - name: 时间的秩序 description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。 - name: 了不起的我 description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？ \",\"使用@Value(\\\"${property}\\\")读取比较简单的配置信息\",\"@Value(\\\"${wuhan2020}\\\") String wuhan2020; \",\"通过@ConfigurationProperties读取配置信息并于Bean绑定，就可以像使用普通的Bean一样，将其注入到类中使用\",\"@Component @ConfigurationProperties(prefix = \\\"library\\\") @Data @ToString public class LibraryProperties { private String location; private List<Book> books; @Setter @Getter @ToString static class Book { String name; String description; } } \",\"@Autowired private LibraryProperties libraryProperties; \"]},\"1526\":{\"h\":\"Spring Boot全局异常处理器\",\"t\":[\"@ControllerAdvice开启全局异常处理，使用该注解表示开启了全局异常的捕获，我们只需再自定义一个方法使用@ExceptionHandler注解，然后自定义捕获异常类型即可对这些捕获的异常进行统一处理。\",\"// 全局异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) @ResponseBody public String globalExceptionHandler(Exception e) { System.out.println(\\\"全局异常捕获>>>:\\\" + e); return \\\"全局异常捕获,错误原因>>>\\\" + e.getMessage(); } } \",\"// controller中进行测试 @PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody UserRegisterRequest userRegisterRequest) { testService.save(userRegisterRequest); int i = 1 / 0; return ResponseEntity.ok(userRegisterRequest); } \",\"结果：\",\"全局异常捕获,错误原因>>>/ by zero \"]},\"1527\":{\"h\":\"SpringMVC\"},\"1528\":{\"h\":\"什么是MVC\",\"t\":[\"MVC是一种设计模式，在这种模式下软件被分为三层，及Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。\"]},\"1529\":{\"h\":\"DAO层是做什么的\",\"t\":[\"DAO层是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。\"]},\"1530\":{\"h\":\"介绍一下Spring MVC的执行流程\",\"t\":[\"整个过程开始于客户端发出一个HTTP请求，Web应用服务器接受到这个请求。如果匹配DispatcherServlet的请求路径，则Web容器将该请求转交给DispatcherServlet处理。\",\"DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看作路由控制器，将Handler看作目标主机。\",\"当DispatcherServlet根据HandlerMapping得到对应请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架的接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。\",\"处理器完成业务逻辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。\",\"ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。\",\"当得到真实的视图对象View后，DispatcherServlet就用这个View对象对ModelAndView中的模型数据进行视图渲染。\",\"最终客户端得到的响应消息可能是有一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。\",\"简略版本：\",\"用户发送请求至前端控制器DispatcherServlet\",\"DispatcherServlet收到请求调用HandllerMapping处理器映射器\",\"处理器映射器找到具体的处理器（Handler）（可以根据xml配置，注解进行查找），生成处理器对象以及处理器拦截器（如果有拦截器则生成）一并返回给DispatcherServlet\",\"DispatcherServlet调用HandlerAdapter处理器适配器\",\"HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）\",\"Controller执行完成后返回ModelAndView\",\"HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet\",\"DispatcherServlet将ModelAndView传给ViewReslover视图解析器\",\"ViewReslover解析后返回具体View\",\"DispatcherServlet根据View进行渲染视图。（最终客户端得到的响应消息可能是有一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。）\"]},\"1531\":{\"h\":\"说一说你知道的Spring MVC注解\",\"t\":[\"@RequestMapping\",\"该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上\",\"属性：\",\"mothod：请求类型，比如get和post\",\"value：请求地址\",\"@RequestParam\",\"是将请求参数绑定到控制器的方法参数上，是Spring MVC中的接收普通参数的注解\",\"@RequestBody\",\"用于读取Request请求的body部分，并且Content-Type为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的body中的json字符串转换成java对象。\",\"@PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody UserRegisterRequest userRegisterRequest) { testService.save(userRegisterRequest); return ResponseEntity.ok(userRegisterRequest); } \",\"@PathVariable\",\"该注解适用于绑定url中的占位符。是Spring MVC支持rest风格的一个重要标志。\",\"@GetMapping(\\\"/klasses/{klassId}/teachers\\\") public List<Teacher> getKlassRelatedTeachers( @PathVariable(\\\"klassId\\\") Long klassId, @RequestParam(value = \\\"type\\\", required = false) String type ) { } \"]},\"1532\":{\"h\":\"介绍一下Sprig MVC的拦截器\",\"t\":[\"可以拓展一下SSO单点登录来讲项目\",\"Session的工作原理和使用经验 - Ken的杂谈\",\"SSO 单点登录 | JavaGuide\",\"SpringBoot实现登录拦截器（实战版） - 掘金 (juejin.cn)\",\"拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口中包含如下三个方法：preHandle(),postHandle(),afterCompletion()。\",\"这些方法的执行流程如下图：\",\"通过上图可以看出，Spring MVC拦截器的执行流程如下：\",\"执行preHandle方法，它会返回一个布尔值。如果为false，则结束所有流程，如果为true，则执行下一步。\",\"执行处理器逻辑，它包含控制器的功能\",\"执行postHandler方法\",\"执行视图解析和视图渲染\",\"执行afterCompletion方法\",\"Spring MVC拦截器的开发步骤如下：\",\"开发拦截器：实现HandlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时需要执行的具体业务逻辑，一般使用preHandle方法。\",\"注册拦截器：定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配那些请求路径。\"]},\"1533\":{\"h\":\"Designmode\"},\"1534\":{\"h\":\"Ml\"},\"1535\":{\"h\":\"O S\"},\"1536\":{\"h\":\"Tools\"},\"1537\":{\"h\":\"Hive\"},\"1538\":{\"h\":\"Bigdata\"},\"1539\":{\"h\":\"Bigdata\"},\"1540\":{\"h\":\"Interview\"},\"1541\":{\"h\":\"Database\"},\"1542\":{\"h\":\"Java\"},\"1543\":{\"h\":\"Computer\"},\"1544\":{\"h\":\"Advance\"},\"1545\":{\"h\":\"Netty\"},\"1546\":{\"h\":\"Reactive\"},\"1547\":{\"h\":\"Microservice\"},\"1548\":{\"h\":\"Optimization\"},\"1549\":{\"h\":\"Basics\"},\"1550\":{\"h\":\"Nio\"},\"1551\":{\"h\":\"Hdfs\"},\"1552\":{\"h\":\"Hadoop\"},\"1553\":{\"h\":\"Yarn\"},\"1554\":{\"h\":\"Mapreduce\"},\"1555\":{\"h\":\"Idgenerator\"},\"1556\":{\"h\":\"Distributed\"},\"1557\":{\"h\":\"Base\"},\"1558\":{\"h\":\"Systemdesign\"},\"1559\":{\"h\":\"Middleware\"},\"1560\":{\"h\":\"Elasticsearch\"},\"1561\":{\"h\":\"Redis\"},\"1562\":{\"h\":\"Framework\"}},\"dirtCount\":0,\"index\":[[\"顾名思义\",{\"1\":{\"1530\":1}}],[\"顾名思义就是锁住某一行\",{\"1\":{\"511\":1}}],[\"邀请我们思考这一亘古难题\",{\"1\":{\"1525\":1}}],[\"罗韦利用诗意的文字\",{\"1\":{\"1525\":1}}],[\"恰是父亲当年为她放弃的那所\",{\"1\":{\"1525\":1}}],[\"湖北武汉加油中国加油\",{\"1\":{\"1525\":1}}],[\"武汉加油\",{\"1\":{\"1525\":1}}],[\"疫情严重\",{\"1\":{\"1525\":1}}],[\"约定大于配置\",{\"1\":{\"1520\":1}}],[\"约50亿年\",{\"1\":{\"480\":1}}],[\"嵌套的\",{\"1\":{\"1514\":1}}],[\"团队提倡测试驱动开发\",{\"1\":{\"1499\":1}}],[\"抛出\",{\"1\":{\"1482\":2}}],[\"抛出异常\",{\"1\":{\"756\":1}}],[\"及handlermapping的配置找到处理请求的处理器\",{\"1\":{\"1530\":1}}],[\"及model\",{\"1\":{\"1528\":1}}],[\"及泛型\",{\"1\":{\"1482\":1}}],[\"及父工厂中找类型匹配的\",{\"1\":{\"1482\":1}}],[\"及事务属性\",{\"1\":{\"1456\":1}}],[\"及数据\",{\"1\":{\"689\":1}}],[\"├───jsp\",{\"1\":{\"1447\":1}}],[\"├───classes\",{\"1\":{\"1447\":1}}],[\"├───context1\",{\"1\":{\"1447\":1}}],[\"├───connector\",{\"1\":{\"1447\":1}}],[\"│\",{\"1\":{\"1447\":9}}],[\"└───context2\",{\"1\":{\"1447\":1}}],[\"└───lib\",{\"1\":{\"1447\":1}}],[\"└───web\",{\"1\":{\"1447\":2}}],[\"└───host\",{\"1\":{\"1447\":1}}],[\"└───engine\",{\"1\":{\"1447\":1}}],[\"└───service\",{\"1\":{\"1447\":1}}],[\"阶段二\",{\"1\":{\"1444\":1}}],[\"阶段一\",{\"1\":{\"1444\":1}}],[\"骨架生成的代码中\",{\"1\":{\"1442\":1}}],[\"骨架项目\",{\"0\":{\"1440\":1}}],[\"插件\",{\"1\":{\"1442\":1}}],[\"插入hash数据\",{\"1\":{\"1213\":1}}],[\"插入和删除快\",{\"1\":{\"1209\":1}}],[\"插入的数据必须遵守这些约束\",{\"1\":{\"1185\":1}}],[\"插入一把锁\",{\"1\":{\"1152\":1}}],[\"插入一个新单词\",{\"1\":{\"668\":1}}],[\"插入数据\",{\"1\":{\"1073\":1}}],[\"插入排序\",{\"0\":{\"644\":1}}],[\"插入性能差\",{\"1\":{\"502\":1}}],[\"插入两个表\",{\"1\":{\"288\":1}}],[\"路径找到\",{\"1\":{\"1438\":1}}],[\"路径\",{\"1\":{\"1438\":1}}],[\"路径相同\",{\"1\":{\"105\":1}}],[\"匹配优先级也高于\",{\"1\":{\"1438\":1}}],[\"匹配\",{\"1\":{\"1437\":1}}],[\"匹萨\",{\"1\":{\"147\":1}}],[\"欢迎页支持静态欢迎页与动态欢迎页\",{\"1\":{\"1436\":1}}],[\"欢迎页\",{\"0\":{\"1434\":1}}],[\"责任链模式体现\",{\"1\":{\"1433\":1}}],[\"门面模式\",{\"1\":{\"1370\":1}}],[\"门店价\",{\"1\":{\"985\":1}}],[\"委派conversionservice\",{\"1\":{\"1370\":1}}],[\"俩是一对\",{\"1\":{\"1352\":1}}],[\"形式\",{\"1\":{\"1339\":1}}],[\"形成类似于这样的结构\",{\"1\":{\"1207\":1}}],[\"形成了映射关系\",{\"1\":{\"1174\":1}}],[\"形成点赞排行榜\",{\"1\":{\"1162\":1}}],[\"形成逻辑规划文件\",{\"1\":{\"976\":1}}],[\"形成切片规划\",{\"1\":{\"965\":1}}],[\"形成主备架构\",{\"1\":{\"882\":1,\"883\":1}}],[\"形成一套规范\",{\"1\":{\"75\":1}}],[\"资格\",{\"1\":{\"1333\":3}}],[\"资源占用率等\",{\"1\":{\"1019\":1}}],[\"资源的申请\",{\"1\":{\"942\":1}}],[\"资源的循环链\",{\"1\":{\"551\":1}}],[\"资源\",{\"1\":{\"576\":1,\"1240\":1,\"1243\":1,\"1476\":1}}],[\"资源查找\",{\"1\":{\"238\":1}}],[\"资源剥夺法\",{\"1\":{\"178\":1}}],[\"资源利用率低\",{\"1\":{\"176\":1,\"192\":1}}],[\"资源共享分为\",{\"1\":{\"155\":1}}],[\"资源共享\",{\"1\":{\"155\":1}}],[\"资源文件等转化为能够运行或部署的应用程序或库的过程\",{\"1\":{\"91\":1}}],[\"典型接口为\",{\"1\":{\"1322\":1}}],[\"典型实现\",{\"1\":{\"1322\":1}}],[\"典型功能有\",{\"1\":{\"1240\":1}}],[\"置于代理类之外\",{\"1\":{\"1310\":1}}],[\"置为\",{\"1\":{\"741\":1}}],[\"置为1\",{\"1\":{\"564\":1}}],[\"⬇️如果存在\",{\"1\":{\"1466\":1}}],[\"⬇️该方法从\",{\"1\":{\"1464\":1}}],[\"⬇️通过\",{\"1\":{\"1451\":1}}],[\"⬇️原始资源解析\",{\"1\":{\"1432\":1}}],[\"⬇️压缩优化\",{\"1\":{\"1432\":1}}],[\"⬇️缓存优化\",{\"1\":{\"1432\":1}}],[\"⬇️handler\",{\"1\":{\"1424\":1}}],[\"⬇️映射条件\",{\"1\":{\"1424\":1}}],[\"⬇️调用代理方法\",{\"1\":{\"1317\":1}}],[\"⬇️调用目标方法\",{\"1\":{\"1317\":1}}],[\"⬇️4\",{\"1\":{\"1309\":1}}],[\"⬇️3\",{\"1\":{\"1309\":1}}],[\"⬇️这就是\",{\"1\":{\"1309\":1}}],[\"秘密都在里面\",{\"1\":{\"1309\":1}}],[\"侵入性较强\",{\"1\":{\"1298\":1}}],[\"织入增强功能\",{\"1\":{\"1298\":1}}],[\"织入到目标类的字节码中\",{\"1\":{\"1298\":1}}],[\"期望满足一定条件才能被\",{\"1\":{\"1466\":1}}],[\"期望是多例\",{\"1\":{\"1294\":1}}],[\"期间会重试\",{\"1\":{\"1150\":1}}],[\"期间发生了什么\",{\"1\":{\"652\":1}}],[\"⬅️加入条件\",{\"1\":{\"1466\":1}}],[\"⬅️本项目的配置类\",{\"1\":{\"1464\":1}}],[\"⬅️第三方的配置类\",{\"1\":{\"1464\":2}}],[\"⬅️收集容器中所有\",{\"1\":{\"1416\":1}}],[\"⬅️名称为\",{\"1\":{\"1416\":1}}],[\"⬅️errorproperties\",{\"1\":{\"1416\":1}}],[\"⬅️tomcatservletwebserverfactory\",{\"1\":{\"1413\":1}}],[\"⬅️修改了\",{\"1\":{\"1413\":1}}],[\"⬅️非反射调用\",{\"1\":{\"1317\":2}}],[\"⬅️反射调用\",{\"1\":{\"1317\":1}}],[\"⬅️\",{\"1\":{\"1285\":1}}],[\"失效\",{\"0\":{\"1294\":1}}],[\"失效分析\",{\"0\":{\"1285\":1}}],[\"失败的原因在于\",{\"1\":{\"1136\":1}}],[\"失败的后备预案\",{\"1\":{\"638\":1}}],[\"失败随时都可能发生\",{\"1\":{\"1067\":1}}],[\"失败了就走失败的流程\",{\"1\":{\"1003\":1}}],[\"失败返回false\",{\"1\":{\"1141\":1}}],[\"失败返回\",{\"1\":{\"701\":1}}],[\"失败演示\",{\"1\":{\"542\":1}}],[\"技术\",{\"1\":{\"1274\":1,\"1438\":1}}],[\"泛型创建\",{\"1\":{\"1489\":1}}],[\"泛型找到\",{\"1\":{\"1489\":1}}],[\"泛型\",{\"1\":{\"1264\":1,\"1489\":1}}],[\"销毁前执行的方法\",{\"1\":{\"1505\":1}}],[\"销毁不归容器管\",{\"1\":{\"1504\":1}}],[\"销毁机制疑似实现有误\",{\"1\":{\"1293\":1}}],[\"销毁之前的增强\",{\"1\":{\"1254\":1}}],[\"销毁\",{\"1\":{\"1252\":1,\"1290\":1}}],[\"旧\",{\"1\":{\"1245\":4}}],[\"国际化信息支持\",{\"1\":{\"1501\":1}}],[\"国际化文件名固定为\",{\"1\":{\"1244\":1}}],[\"国际化文件均在\",{\"1\":{\"1244\":1}}],[\"国际化\",{\"0\":{\"1244\":1},\"1\":{\"1240\":1,\"1243\":1}}],[\"国家\",{\"1\":{\"374\":1}}],[\"严格匹配数据源\",{\"1\":{\"1236\":1}}],[\"严重影响查询的效率\",{\"1\":{\"493\":1}}],[\"严重拖慢更新和新增速度\",{\"1\":{\"481\":1}}],[\"官网地址\",{\"1\":{\"1217\":1}}],[\"官方架构图\",{\"0\":{\"941\":1},\"1\":{\"941\":1}}],[\"官方推荐不超过1000个\",{\"1\":{\"527\":1}}],[\"官方明确表示\",{\"1\":{\"420\":1}}],[\"官方\",{\"0\":{\"144\":1}}],[\"官方论文复现\",{\"1\":{\"128\":1}}],[\"官方github\",{\"1\":{\"121\":1}}],[\"虎哥\",{\"1\":{\"1213\":1,\"1221\":1,\"1223\":1,\"1224\":1}}],[\"麻子\",{\"1\":{\"1210\":1}}],[\"差集等功能\",{\"1\":{\"1210\":1}}],[\"差错处理\",{\"1\":{\"210\":1}}],[\"评价\",{\"1\":{\"1411\":1}}],[\"评论列表等\",{\"1\":{\"1209\":1}}],[\"评估gc的性能指标\",{\"0\":{\"637\":1}}],[\"隔开\",{\"1\":{\"1207\":1}}],[\"隔离性要求同一时刻只能有一个事务对数据进行写操作\",{\"1\":{\"506\":1}}],[\"隔离性追求的是并发情形下事务之间互不干扰\",{\"1\":{\"506\":1}}],[\"隔离性实现原理\",{\"1\":{\"506\":1}}],[\"隔离性\",{\"1\":{\"506\":1}}],[\"浮点类型\",{\"1\":{\"1206\":1}}],[\"学习一种特殊的\",{\"1\":{\"1467\":1}}],[\"学到\",{\"1\":{\"1243\":1}}],[\"学会查询就好啦\",{\"1\":{\"1204\":1}}],[\"学生表中的student\",{\"1\":{\"482\":1}}],[\"学生类\",{\"1\":{\"54\":1}}],[\"贴心小建议\",{\"1\":{\"1204\":1}}],[\"贴心小提示\",{\"1\":{\"1099\":1,\"1205\":3,\"1206\":1,\"1208\":1,\"1221\":1}}],[\"守护进程\",{\"1\":{\"1196\":1}}],[\"守护线程💡\",{\"0\":{\"858\":1}}],[\"守护线程无论是否执行完毕\",{\"1\":{\"537\":1}}],[\"守护线程\",{\"0\":{\"537\":1}}],[\"良好的编码\",{\"1\":{\"1190\":1}}],[\"型\",{\"1\":{\"1190\":1}}],[\"荣耀\",{\"1\":{\"1186\":1}}],[\"荣耀6\",{\"1\":{\"1186\":1}}],[\"淘宝的商品总量就已经超过\",{\"1\":{\"1177\":1}}],[\"淘汰掉一些不重要的数据\",{\"1\":{\"1119\":1}}],[\"遇到的问题是\",{\"1\":{\"1177\":1}}],[\"遇到的问题是如果用户访问的是\",{\"1\":{\"1177\":1}}],[\"额外提供了下面几个方法\",{\"1\":{\"1321\":1}}],[\"额外加餐\",{\"0\":{\"1177\":1}}],[\"额外的内存消耗\",{\"1\":{\"1123\":1}}],[\"额外的检查\",{\"1\":{\"676\":1}}],[\"额外的这个线程就能顶上去\",{\"1\":{\"576\":1}}],[\"号\",{\"1\":{\"1176\":2}}],[\"签到统计\",{\"0\":{\"1176\":1}}],[\"签到记录为\",{\"1\":{\"1174\":1}}],[\"签到的日期\",{\"1\":{\"1174\":1}}],[\"签到的月\",{\"1\":{\"1174\":1}}],[\"签到的年\",{\"1\":{\"1174\":1}}],[\"万用户\",{\"1\":{\"1174\":1}}],[\"万物皆对象\",{\"1\":{\"25\":1}}],[\"毕竟作为\",{\"1\":{\"1171\":1}}],[\"毕竟epoll的通知机制需要很多函数回调\",{\"1\":{\"680\":1}}],[\"轴传入到\",{\"1\":{\"1171\":1}}],[\"纬度\",{\"1\":{\"1170\":1,\"1171\":1}}],[\"帮助我们根据经纬度来检索数据\",{\"1\":{\"1170\":1}}],[\"帮忙扩容\",{\"1\":{\"579\":1}}],[\"卡洛\",{\"1\":{\"1525\":1}}],[\"卡片中\",{\"1\":{\"1168\":1}}],[\"卡车\",{\"1\":{\"147\":1}}],[\"站在发件人这一段\",{\"1\":{\"1166\":1}}],[\"兼具推和拉两种模式的优点\",{\"1\":{\"1166\":1}}],[\"兼容\",{\"1\":{\"508\":1,\"510\":5}}],[\"拉模式\",{\"1\":{\"1166\":2}}],[\"拉链表的设计是将更新的数据进行状态记录\",{\"1\":{\"405\":1}}],[\"拉链表的设计与实现\",{\"0\":{\"405\":1}}],[\"拉链表专门用于解决在数据仓库中数据发生变化如何实现数据存储的问题\",{\"1\":{\"405\":1}}],[\"投喂用户感兴趣信息\",{\"1\":{\"1166\":1}}],[\"智能排序\",{\"1\":{\"1166\":1}}],[\"沉浸式\",{\"1\":{\"1166\":1}}],[\"咱们对hash结构操作一下\",{\"1\":{\"1224\":1}}],[\"咱们准备一张小小的卡片\",{\"1\":{\"1174\":1}}],[\"咱们可以采用一个可以排序的set集合\",{\"1\":{\"1162\":1}}],[\"咱们就不能使用code了\",{\"1\":{\"1105\":1}}],[\"赋值给islike字段\",{\"1\":{\"1161\":2}}],[\"赋值给对象属性\",{\"1\":{\"985\":1}}],[\"点击即可建立连接了\",{\"1\":{\"1202\":1}}],[\"点击确定后\",{\"1\":{\"1202\":1}}],[\"点击左上角的连接到redis服务器按钮\",{\"1\":{\"1202\":1}}],[\"点赞列表查询列表\",{\"1\":{\"1162\":1}}],[\"点赞逻辑代码\",{\"1\":{\"1162\":1}}],[\"点赞排行榜\",{\"0\":{\"1162\":1}}],[\"点赞功能\",{\"0\":{\"1161\":1}}],[\"点对点\",{\"1\":{\"1010\":1}}],[\"探店笔记表\",{\"1\":{\"1159\":1}}],[\"探店笔记类似点评网站的评价\",{\"1\":{\"1159\":1}}],[\"达人探店\",{\"0\":{\"1158\":1,\"1159\":1,\"1160\":1,\"1161\":1,\"1162\":1}}],[\"达到比例溢出到磁盘上\",{\"1\":{\"965\":1}}],[\"达到阈值条件后持续扩展的时间\",{\"1\":{\"870\":1}}],[\"达到一种并发读的效果\",{\"1\":{\"583\":1}}],[\"达到了与对象解耦的目的\",{\"1\":{\"25\":1}}],[\"剩下的就是根据步骤3\",{\"1\":{\"1156\":1}}],[\"剩余消费者消费\",{\"1\":{\"1040\":1}}],[\"剩余区\",{\"1\":{\"168\":1}}],[\"扣库存\",{\"1\":{\"1156\":1}}],[\"扣减失败\",{\"1\":{\"1137\":2,\"1157\":1}}],[\"扣减库存\",{\"1\":{\"1134\":1,\"1135\":2,\"1137\":4,\"1155\":1,\"1157\":1}}],[\"笔者画了一幅图来说明\",{\"1\":{\"1153\":1}}],[\"笔者总结\",{\"1\":{\"1147\":1}}],[\"笔记本电脑\",{\"1\":{\"147\":1}}],[\"删锁这个逻辑来解决的\",{\"1\":{\"1147\":1}}],[\"删锁是一个原子性动作了\",{\"1\":{\"1146\":1}}],[\"删锁\",{\"1\":{\"1145\":1}}],[\"删除sorted\",{\"1\":{\"1211\":1}}],[\"删除src目录\",{\"1\":{\"112\":1}}],[\"删除一个指定的key\",{\"1\":{\"1205\":1}}],[\"删除即可\",{\"1\":{\"1141\":1}}],[\"删除缓存\",{\"1\":{\"1121\":1,\"1122\":1}}],[\"删除缓存还是更新缓存\",{\"1\":{\"1121\":1}}],[\"删除topic\",{\"1\":{\"1018\":1}}],[\"删除默认acl权限\",{\"1\":{\"926\":1}}],[\"删除基本acl条目以外的所有条目\",{\"1\":{\"926\":1}}],[\"删除指定的acl条目\",{\"1\":{\"926\":1}}],[\"删除快照\",{\"1\":{\"914\":1}}],[\"删除操作\",{\"1\":{\"903\":1}}],[\"删除\",{\"1\":{\"888\":1,\"1146\":1}}],[\"删除用户定义的擦除编码策略\",{\"1\":{\"875\":1}}],[\"删除相对于源端\",{\"1\":{\"869\":1}}],[\"删除是危险操作\",{\"1\":{\"823\":1}}],[\"删除很危险⚠️\",{\"0\":{\"823\":1}}],[\"删除多级目录\",{\"1\":{\"822\":1}}],[\"删除目录\",{\"1\":{\"822\":1}}],[\"删除cms垃圾回收器\",{\"1\":{\"638\":1,\"640\":1}}],[\"删除单个\",{\"1\":{\"1205\":1}}],[\"删除单个列表\",{\"1\":{\"523\":1}}],[\"删除单个字符串类型的key\",{\"1\":{\"523\":1}}],[\"删除key的命令会阻塞redis吗\",{\"0\":{\"523\":1}}],[\"删除和查找\",{\"1\":{\"518\":1}}],[\"删除不再使用或很少使用的索引\",{\"1\":{\"494\":1}}],[\"删除索引\",{\"1\":{\"423\":1,\"1072\":2,\"1089\":1}}],[\"删除旧文件\",{\"1\":{\"294\":1}}],[\"删除时前缀是delete\",{\"1\":{\"293\":1}}],[\"删除分区操作差不多\",{\"1\":{\"281\":1}}],[\"删除分区\",{\"1\":{\"280\":1}}],[\"删除数据库\",{\"1\":{\"278\":1}}],[\"删除物化视图\",{\"1\":{\"276\":1}}],[\"删除视图\",{\"1\":{\"271\":1}}],[\"删除hdfs上的表数据\",{\"1\":{\"258\":1}}],[\"删除元数据\",{\"1\":{\"258\":1}}],[\"删除表结果\",{\"1\":{\"258\":1}}],[\"删除文件\",{\"1\":{\"196\":1,\"199\":1,\"822\":1,\"870\":1}}],[\"课堂代码如下\",{\"1\":{\"1205\":1}}],[\"课堂调试关键断点为\",{\"1\":{\"726\":1}}],[\"课程中的使用方式是没有像cas一样带自旋的操作\",{\"1\":{\"1135\":1}}],[\"课程中的使用方式\",{\"1\":{\"1135\":1}}],[\"秒杀业务的优化思路是什么\",{\"1\":{\"1157\":1}}],[\"秒杀优化\",{\"0\":{\"1154\":1,\"1155\":1,\"1156\":1,\"1157\":1}}],[\"秒杀已经结束\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"秒杀尚未开始\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"秒杀是否开始或结束\",{\"1\":{\"1134\":1}}],[\"秒杀下单应该思考的内容\",{\"1\":{\"1134\":1}}],[\"秒内的计数器\",{\"1\":{\"1131\":1}}],[\"符号位\",{\"1\":{\"1131\":1}}],[\"符合\",{\"1\":{\"1099\":1}}],[\"符合表达习惯\",{\"1\":{\"480\":1}}],[\"符合开闭原则\",{\"1\":{\"15\":1}}],[\"卖出了多少单\",{\"1\":{\"1131\":1}}],[\"卖票接口\",{\"1\":{\"58\":1,\"59\":1}}],[\"休眠并重试\",{\"1\":{\"1129\":1}}],[\"证明是缓存穿透数据\",{\"1\":{\"1124\":1}}],[\"欧当再次发起查询时\",{\"1\":{\"1124\":1}}],[\"误删别人的锁\",{\"1\":{\"1149\":1}}],[\"误判原因在于\",{\"1\":{\"1123\":1}}],[\"误报的可能性就越大\",{\"1\":{\"658\":2}}],[\"走视图解析及渲染流程\",{\"1\":{\"1438\":1}}],[\"走\",{\"1\":{\"1370\":2,\"1411\":2,\"1438\":1}}],[\"走到了删除锁逻辑\",{\"1\":{\"1143\":1}}],[\"走哈希思想去判断当前这个要查询的这个数据是否存在\",{\"1\":{\"1123\":1}}],[\"走完一个流程\",{\"1\":{\"785\":1}}],[\"店铺id不能为空\",{\"1\":{\"1122\":1}}],[\"店铺不存在\",{\"1\":{\"1122\":1,\"1129\":1}}],[\"企业的数据量\",{\"1\":{\"1114\":1}}],[\"俗称的缓存就是缓冲区内的数据\",{\"1\":{\"1113\":1}}],[\"避震器\",{\"1\":{\"1113\":2,\"1114\":1}}],[\"避免反射\",{\"1\":{\"1321\":3}}],[\"避免反射调用\",{\"0\":{\"1318\":1}}],[\"避免工厂对象提前被创建\",{\"1\":{\"1285\":1}}],[\"避免列名出错的情况\",{\"1\":{\"1235\":1}}],[\"避免被猜测id规律\",{\"1\":{\"1124\":1}}],[\"避免生成重复\",{\"1\":{\"1000\":1}}],[\"避免了shuffle阶段的繁琐\",{\"1\":{\"990\":1}}],[\"避免了多线程之间上下文切换导致的开销\",{\"1\":{\"610\":1}}],[\"避免网络瓶颈和高延迟时的连接\",{\"1\":{\"898\":1}}],[\"避免非阻塞模式下所做无用功\",{\"1\":{\"829\":1}}],[\"避免拷贝\",{\"1\":{\"779\":1}}],[\"避免类的重复加载\",{\"1\":{\"623\":1}}],[\"避免扩容操作\",{\"1\":{\"601\":1}}],[\"避免活锁的方法\",{\"1\":{\"552\":1}}],[\"避免经常更新的表创建过多的索引\",{\"1\":{\"494\":1}}],[\"避免执行后面的分页语句\",{\"1\":{\"482\":1}}],[\"避免回表\",{\"1\":{\"481\":1}}],[\"避免关联查询\",{\"1\":{\"480\":1}}],[\"避免影响其它索引效率\",{\"1\":{\"480\":1}}],[\"避免节外生枝\",{\"1\":{\"480\":1}}],[\"避免数据倾斜\",{\"1\":{\"465\":1,\"469\":1}}],[\"避免每个task数据差异过大导致数据倾斜\",{\"1\":{\"464\":1}}],[\"避免不必要的数据扫描\",{\"1\":{\"437\":1}}],[\"避免不必要的比较\",{\"1\":{\"418\":1}}],[\"避免小文件生成\",{\"0\":{\"435\":1}}],[\"避免全表扫描\",{\"1\":{\"260\":1}}],[\"避免全表数据扫描\",{\"1\":{\"259\":1}}],[\"避免i\",{\"1\":{\"191\":1}}],[\"避免死锁的方法\",{\"1\":{\"551\":1}}],[\"避免死锁\",{\"0\":{\"177\":1},\"1\":{\"175\":1,\"1147\":1}}],[\"避免重复定义\",{\"1\":{\"108\":1}}],[\"避免出现误删除\",{\"1\":{\"482\":1}}],[\"避免出现file\",{\"1\":{\"481\":1}}],[\"避免出现构建依赖混乱导致构建失败的情况\",{\"1\":{\"108\":1}}],[\"避免出现版本冲突和依赖缺失等问题\",{\"1\":{\"97\":1}}],[\"避免版本冲突和转换错误等\",{\"1\":{\"91\":1}}],[\"山地自行车\",{\"1\":{\"1113\":1}}],[\"越野车\",{\"1\":{\"1113\":1}}],[\"越野车的避震器\",{\"1\":{\"1113\":1}}],[\"越来越多的应用场景需要根据任务的紧急程度来决定处理的顺序\",{\"1\":{\"167\":1}}],[\"商家中可以按照多种排序方式\",{\"1\":{\"1171\":1}}],[\"商户查询缓存\",{\"0\":{\"1112\":1}}],[\"商品信息到redis\",{\"1\":{\"1207\":1}}],[\"商品编码\",{\"1\":{\"988\":1,\"990\":1}}],[\"商品编号\",{\"1\":{\"985\":1,\"988\":3,\"990\":1}}],[\"商品名称\",{\"1\":{\"985\":1,\"988\":4,\"990\":2}}],[\"商品id\",{\"1\":{\"985\":1,\"988\":4,\"990\":3}}],[\"商品类目名称使用频率高\",{\"1\":{\"480\":1}}],[\"早期的方案是session拷贝\",{\"1\":{\"1102\":1}}],[\"早期的多用户操作系统\",{\"1\":{\"196\":1}}],[\"拦截器会对处理器进行拦截\",{\"1\":{\"1532\":1}}],[\"拦截器内\",{\"1\":{\"1411\":1}}],[\"拦截器代码\",{\"1\":{\"1100\":1}}],[\"拦截\",{\"1\":{\"1100\":1,\"1111\":1}}],[\"温馨小贴士\",{\"1\":{\"1100\":2}}],[\"校验是否是一人一单\",{\"1\":{\"1155\":1}}],[\"校验验证码\",{\"1\":{\"1099\":1}}],[\"校验手机号\",{\"1\":{\"1099\":2,\"1107\":1}}],[\"校验登录状态\",{\"1\":{\"1098\":1}}],[\"瞬间就会让mysql服务器的cpu\",{\"1\":{\"1094\":1}}],[\"华为手机\",{\"1\":{\"1089\":1}}],[\"华硕\",{\"1\":{\"17\":2}}],[\"批量获取多个hash类型key的field的值\",{\"1\":{\"1208\":1}}],[\"批量添加多个hash类型key的field的值\",{\"1\":{\"1208\":1}}],[\"批量添加多个string类型的键值对\",{\"1\":{\"1206\":1}}],[\"批量添加数据\",{\"1\":{\"1205\":1}}],[\"批量插入数据\",{\"1\":{\"1073\":1}}],[\"批量新增\",{\"1\":{\"1073\":1}}],[\"批处理阶段引入了脱机输入\",{\"1\":{\"212\":1}}],[\"批处理命令接口\",{\"1\":{\"154\":1}}],[\"云的环境里\",{\"1\":{\"1067\":1}}],[\"稀疏索引\",{\"1\":{\"1052\":1}}],[\"端口分别为8081和8082\",{\"1\":{\"1138\":1}}],[\"端口\",{\"0\":{\"1045\":1},\"1\":{\"1447\":1}}],[\"崩溃了\",{\"1\":{\"1042\":1}}],[\"乱序问题\",{\"1\":{\"1035\":1}}],[\"副本的ack机制\",{\"0\":{\"1043\":1}}],[\"副本\",{\"0\":{\"1067\":1},\"1\":{\"1026\":1,\"1067\":1}}],[\"副本位置\",{\"1\":{\"888\":1}}],[\"封装起来\",{\"1\":{\"1500\":1}}],[\"封装启动\",{\"1\":{\"1444\":1}}],[\"封装环境键值\",{\"1\":{\"1416\":1}}],[\"封装好\",{\"1\":{\"1411\":1}}],[\"封装为\",{\"1\":{\"1355\":1}}],[\"封装并返回\",{\"1\":{\"1168\":1}}],[\"封装redis工具类\",{\"0\":{\"1129\":1}}],[\"封装逻辑过期时间\",{\"1\":{\"1128\":1}}],[\"封装是\",{\"1\":{\"1023\":1}}],[\"封装了创建对象的过程\",{\"1\":{\"29\":1}}],[\"浏览器刷新页面\",{\"1\":{\"1504\":1}}],[\"浏览器缓存\",{\"1\":{\"1115\":1}}],[\"浏览这个网页的自然人\",{\"1\":{\"1179\":1}}],[\"浏览zookeeper中的数据\",{\"1\":{\"1018\":1}}],[\"浏览kafka集群节点\",{\"1\":{\"1018\":1}}],[\"浏览量\",{\"1\":{\"359\":1}}],[\"懂点技术的都可以模拟请求调用接口\",{\"1\":{\"1005\":1}}],[\"哈哈哈\",{\"1\":{\"1003\":1}}],[\"哈希结构也是我们以后实际开发中常用的命令哟\",{\"1\":{\"1208\":1}}],[\"哈希函数\",{\"1\":{\"658\":1}}],[\"哈希值\",{\"1\":{\"527\":1,\"631\":1}}],[\"哈希索引的时间复杂度会退化为o\",{\"1\":{\"491\":1}}],[\"幂等性原理\",{\"0\":{\"1029\":1}}],[\"幂等性的实现方式\",{\"0\":{\"1005\":1}}],[\"幂等性如何实现\",{\"1\":{\"1002\":1}}],[\"幂等性\",{\"0\":{\"1002\":1,\"1027\":1}}],[\"掩码\",{\"1\":{\"999\":1}}],[\"纪年\",{\"1\":{\"999\":1}}],[\"雪花算法中41位比特位不是直接用来存储当前服务器毫秒时间戳的\",{\"1\":{\"1001\":1}}],[\"雪花算法服务需要部署的节点超过1024台\",{\"1\":{\"1001\":1}}],[\"雪花算法有如下缺点\",{\"1\":{\"1000\":1}}],[\"雪花算法有以下几个优点\",{\"1\":{\"1000\":1}}],[\"雪花算法原理就是生成一个的64位比特位的\",{\"1\":{\"998\":1}}],[\"雪花算法是其中一个用于解决分布式\",{\"1\":{\"997\":1}}],[\"雪花算法详解与实现\",{\"1\":{\"996\":1}}],[\"雪花算法\",{\"0\":{\"996\":1,\"998\":1},\"1\":{\"998\":1}}],[\"雪橇\",{\"1\":{\"147\":1}}],[\"犹为重要\",{\"1\":{\"995\":1}}],[\"弊端\",{\"1\":{\"988\":1}}],[\"市场价\",{\"1\":{\"985\":1}}],[\"市政\",{\"1\":{\"147\":1}}],[\"溢写线程启动\",{\"1\":{\"979\":1}}],[\"溢写线程启动时不应该阻止map的结果输出\",{\"1\":{\"979\":1}}],[\"溢出spill的时候根据key进行排序sort\",{\"1\":{\"965\":1}}],[\"环绕通知1返回最终的结果\",{\"1\":{\"1340\":1}}],[\"环绕通知2继续将结果返回给环绕通知1\",{\"1\":{\"1340\":1}}],[\"环绕通知\",{\"1\":{\"1339\":3,\"1343\":1,\"1350\":1}}],[\"环境对象\",{\"1\":{\"1446\":1}}],[\"环境容器\",{\"1\":{\"1245\":3}}],[\"环境变量\",{\"1\":{\"1012\":1,\"1046\":1}}],[\"环境变量来定位\",{\"1\":{\"821\":1}}],[\"环境\",{\"0\":{\"1012\":1},\"1\":{\"1240\":1,\"1243\":1,\"1440\":1}}],[\"环境搭建\",{\"0\":{\"1011\":1}}],[\"环形缓冲区就是内存中的一块区域\",{\"1\":{\"979\":1}}],[\"环形缓冲区\",{\"1\":{\"979\":1}}],[\"迭代器中的值与key是一一对应的\",{\"1\":{\"974\":1}}],[\"迭代器的第一个数据就是cases最多的县\",{\"1\":{\"974\":1}}],[\"跨网络传递的资源消耗\",{\"1\":{\"969\":1}}],[\"吧每个单词都标记1\",{\"1\":{\"958\":1,\"983\":1}}],[\"申请到资源后\",{\"1\":{\"953\":1}}],[\"申请和领取资源\",{\"1\":{\"953\":1}}],[\"申请资源时\",{\"1\":{\"948\":1}}],[\"职责\",{\"1\":{\"947\":1}}],[\"汇报自己的状态和进度\",{\"1\":{\"953\":1}}],[\"汇报本节点上的资源使用情况和各个\",{\"1\":{\"946\":1}}],[\"汇报时间间隔取参数dfs\",{\"1\":{\"903\":1}}],[\"叫做数据加密秘钥\",{\"1\":{\"931\":1}}],[\"口令\",{\"1\":{\"924\":1}}],[\"口令保护\",{\"1\":{\"201\":1}}],[\"票给client\",{\"1\":{\"923\":1}}],[\"验证码错误\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"验证码\",{\"1\":{\"1099\":1}}],[\"验证生成100万个id需要多久\",{\"1\":{\"999\":1}}],[\"验证通过就会给一张tgt\",{\"1\":{\"923\":1}}],[\"验戳\",{\"1\":{\"590\":1}}],[\"域管理员\",{\"1\":{\"923\":1}}],[\"域的产生是为了解决企业内部的资源管理问题\",{\"1\":{\"923\":1}}],[\"域的概念\",{\"1\":{\"923\":1}}],[\"密钥管理服务\",{\"0\":{\"933\":1}}],[\"密钥库\",{\"0\":{\"932\":1}}],[\"密钥\",{\"0\":{\"931\":1}}],[\"密钥分发中心\",{\"1\":{\"923\":1}}],[\"密码\",{\"1\":{\"201\":1,\"701\":1,\"924\":1,\"1196\":1}}],[\"恶意用户可以进行身份伪造从而非法获取相应的权限\",{\"1\":{\"922\":1}}],[\"恶汉式\",{\"1\":{\"66\":1}}],[\"粘性分配策略和\",{\"1\":{\"1042\":1}}],[\"粘性分配策略\",{\"0\":{\"1042\":1},\"1\":{\"1042\":1}}],[\"粘滞\",{\"1\":{\"920\":1}}],[\"粘包\",{\"1\":{\"694\":1}}],[\"粘包现象\",{\"0\":{\"692\":1}}],[\"粘包与半包\",{\"0\":{\"691\":1}}],[\"授权\",{\"1\":{\"916\":1}}],[\"认识redis\",{\"0\":{\"1190\":1}}],[\"认识nosql\",{\"0\":{\"1184\":1}}],[\"认证\",{\"1\":{\"916\":1}}],[\"认为只有在\",{\"1\":{\"795\":1}}],[\"认为业务的惟一性一律需要在应用层通过\",{\"1\":{\"481\":1}}],[\"认为索引会消耗空间\",{\"1\":{\"481\":1}}],[\"认为一个查询就需要建一个索引\",{\"1\":{\"481\":1}}],[\"称之为nosql数据库\",{\"1\":{\"1182\":1}}],[\"称之为再均衡\",{\"1\":{\"1037\":1}}],[\"称之为确认队列\",{\"1\":{\"901\":1}}],[\"称为水平扩展\",{\"1\":{\"1189\":1}}],[\"称为垂直扩展\",{\"1\":{\"1189\":1}}],[\"称为缺页或缺段\",{\"1\":{\"688\":1,\"689\":1}}],[\"称为外层页表\",{\"1\":{\"683\":1}}],[\"称为内存的有效访问时间\",{\"1\":{\"683\":1}}],[\"称为内存映像i\",{\"1\":{\"208\":1}}],[\"称为\",{\"1\":{\"683\":1}}],[\"称为用户空间\",{\"1\":{\"676\":1}}],[\"称为hive查询语言\",{\"1\":{\"229\":1}}],[\"称为页目录表\",{\"1\":{\"186\":1}}],[\"称为页\",{\"1\":{\"184\":1}}],[\"称为进程控制块\",{\"1\":{\"159\":1}}],[\"升级的时候依然向外提供服务\",{\"1\":{\"890\":1}}],[\"升序获取sorted\",{\"1\":{\"1211\":1}}],[\"升序\",{\"1\":{\"312\":1}}],[\"赢得了选举\",{\"1\":{\"885\":1}}],[\"维持和zk群联系\",{\"1\":{\"885\":1}}],[\"维护的变量就是0\",{\"1\":{\"1132\":1}}],[\"维护的变量变为0\",{\"1\":{\"1132\":1}}],[\"维护方便\",{\"1\":{\"1123\":1}}],[\"维护成本高\",{\"1\":{\"792\":1}}],[\"维护\",{\"1\":{\"792\":1}}],[\"维护独立的\",{\"1\":{\"776\":1}}],[\"维护一个独立的\",{\"1\":{\"841\":1}}],[\"维护一个线程\",{\"1\":{\"746\":1}}],[\"维护一个row\",{\"1\":{\"497\":1}}],[\"维护相对繁琐\",{\"1\":{\"424\":1}}],[\"仲裁日志管理器\",{\"1\":{\"884\":1}}],[\"冗余namenode\",{\"1\":{\"883\":1}}],[\"冗余字段应遵循\",{\"1\":{\"480\":1}}],[\"脑裂问题的解决\",{\"1\":{\"885\":1}}],[\"脑裂问题\",{\"1\":{\"882\":1}}],[\"服役的节点也是3\",{\"1\":{\"879\":1}}],[\"服务\",{\"1\":{\"1196\":1}}],[\"服务方提供一个查询操作是否成功的api\",{\"1\":{\"1003\":1}}],[\"服务之上再运行数据处理程序\",{\"1\":{\"951\":1}}],[\"服务来获取\",{\"1\":{\"924\":1}}],[\"服务端正常会返回pong\",{\"1\":{\"1199\":1}}],[\"服务端会校验这个token\",{\"1\":{\"1005\":1}}],[\"服务端会生成一个全局唯一的id保存在redis中\",{\"1\":{\"1005\":1}}],[\"服务端扣钱成功\",{\"1\":{\"1003\":1}}],[\"服务端\",{\"1\":{\"766\":2}}],[\"服务端根据它找到实现\",{\"1\":{\"733\":1}}],[\"服务端也一直收不到数据\",{\"1\":{\"707\":1}}],[\"服务端加入\",{\"1\":{\"698\":1}}],[\"服务端输出\",{\"1\":{\"697\":1,\"698\":1,\"699\":1}}],[\"服务端修改一下接收缓冲区\",{\"1\":{\"693\":1}}],[\"服务端代码\",{\"1\":{\"692\":1}}],[\"服务器提供了\",{\"1\":{\"1438\":1}}],[\"服务器默认错误地址\",{\"1\":{\"1413\":1}}],[\"服务器压力过大\",{\"1\":{\"1102\":1}}],[\"服务器就是一个broker\",{\"1\":{\"1026\":1}}],[\"服务器就会需要启动一个线程来进行处理\",{\"1\":{\"609\":1}}],[\"服务器号\",{\"1\":{\"1001\":1}}],[\"服务器时钟回拨时可能会生成重复\",{\"1\":{\"1000\":1}}],[\"服务器应用程序提供强身份验证\",{\"1\":{\"923\":1}}],[\"服务器需要进行退役更换\",{\"1\":{\"879\":1}}],[\"服务器按预定长度读取\",{\"1\":{\"840\":1}}],[\"服务器仅接收\",{\"1\":{\"783\":1}}],[\"服务器\",{\"0\":{\"734\":1},\"1\":{\"1013\":1}}],[\"服务器架子\",{\"1\":{\"733\":1}}],[\"服务器端代码为\",{\"1\":{\"834\":1}}],[\"服务器端成功接受连接时触发\",{\"1\":{\"831\":1}}],[\"服务器端\",{\"0\":{\"784\":1},\"1\":{\"785\":1,\"826\":1,\"827\":1,\"840\":1}}],[\"服务器端打印\",{\"1\":{\"766\":1}}],[\"服务器端两个\",{\"1\":{\"748\":1}}],[\"服务器端的\",{\"1\":{\"733\":1}}],[\"服务器端的某次输出\",{\"1\":{\"692\":1,\"693\":1}}],[\"服务器端解决\",{\"1\":{\"707\":1}}],[\"服务器端将\",{\"1\":{\"703\":1}}],[\"服务器端加入\",{\"1\":{\"697\":1}}],[\"服务器等\",{\"1\":{\"638\":1}}],[\"服务器得到通知\",{\"1\":{\"611\":1}}],[\"服务器实现模式为一个连接一个线程\",{\"1\":{\"609\":1}}],[\"服务即可\",{\"1\":{\"240\":1}}],[\"擦除编码策略\",{\"1\":{\"875\":1}}],[\"奇偶校验块后取整\",{\"1\":{\"875\":1}}],[\"奇数分为一组\",{\"1\":{\"313\":1}}],[\"拥有beanfactory的所有支持\",{\"1\":{\"1501\":1}}],[\"拥有快照的目录不允许被删除\",{\"1\":{\"914\":1}}],[\"拥有者所在的组\",{\"1\":{\"917\":1}}],[\"拥有者\",{\"1\":{\"913\":1}}],[\"拥有足够数量的机架也很重要\",{\"1\":{\"875\":1}}],[\"拥有启动分区的磁盘为启动磁盘或系统磁盘\",{\"1\":{\"206\":1}}],[\"纠删码策略由参数dfs\",{\"1\":{\"875\":1}}],[\"纠删码策略设置\",{\"1\":{\"875\":1}}],[\"纠删码策略封装了如何对文件进行编码\",{\"1\":{\"875\":1}}],[\"纠删码文件也分布在整个机架上\",{\"1\":{\"875\":1}}],[\"纠删码技术\",{\"0\":{\"875\":1},\"1\":{\"875\":1}}],[\"纠删编码策略\",{\"1\":{\"875\":1}}],[\"码数学原理\",{\"1\":{\"875\":1}}],[\"较低的node\",{\"1\":{\"874\":1}}],[\"较之被动的超时方案\",{\"1\":{\"513\":1}}],[\"借助unix\",{\"1\":{\"872\":1}}],[\"版设计\",{\"0\":{\"867\":1}}],[\"版本中\",{\"1\":{\"1499\":1}}],[\"版本中加入了对\",{\"1\":{\"1170\":1}}],[\"版本选择了\",{\"1\":{\"1300\":1}}],[\"版本并不支持\",{\"1\":{\"1172\":1}}],[\"版本引入\",{\"1\":{\"856\":1}}],[\"版本\",{\"1\":{\"792\":1,\"876\":2,\"1062\":1,\"1499\":1}}],[\"版本可能会有较大重构\",{\"1\":{\"792\":1}}],[\"版本号只比原来大1\",{\"1\":{\"1135\":1}}],[\"版本号\",{\"1\":{\"98\":1,\"712\":1}}],[\"信息噪音较多\",{\"1\":{\"1166\":1}}],[\"信息全面\",{\"1\":{\"1166\":1}}],[\"信息\",{\"1\":{\"902\":1}}],[\"信息拷入\",{\"1\":{\"855\":1}}],[\"信号驱动\",{\"1\":{\"851\":1}}],[\"信号驱动i\",{\"1\":{\"679\":1}}],[\"信号量\",{\"1\":{\"591\":1}}],[\"信号量的使用不当\",{\"1\":{\"175\":1}}],[\"信号量s就是传入的参数\",{\"1\":{\"171\":1}}],[\"信号量就是一个变量\",{\"1\":{\"171\":1}}],[\"信号量机制存在的问题\",{\"1\":{\"173\":1}}],[\"信号量机制实现前驱关系\",{\"1\":{\"172\":1}}],[\"信号量机制实现进程同步\",{\"1\":{\"172\":1}}],[\"信号量机制实现进程互斥\",{\"1\":{\"172\":1}}],[\"信号量机制\",{\"0\":{\"171\":1}}],[\"唯有后初始化的流程会走\",{\"1\":{\"1472\":1}}],[\"唯有一点\",{\"1\":{\"855\":1}}],[\"唯一的重点就是这个全局唯一id如何生成\",{\"1\":{\"1005\":1}}],[\"唯一id\",{\"1\":{\"999\":1}}],[\"唯一索引\",{\"1\":{\"481\":1,\"492\":1}}],[\"唯一索引名为uk字段名\",{\"1\":{\"480\":1}}],[\"唯一需要注意的是\",{\"1\":{\"61\":1}}],[\"卷\",{\"1\":{\"852\":1,\"874\":1}}],[\"容器启动的时间较beanfactory也会长一些\",{\"1\":{\"1501\":1}}],[\"容器启动初期速度较快\",{\"1\":{\"1501\":1}}],[\"容器启动时创建\",{\"1\":{\"1290\":1}}],[\"容器的创建\",{\"1\":{\"1446\":1}}],[\"容器中找一些\",{\"1\":{\"1355\":1}}],[\"容器停止时销毁\",{\"1\":{\"1290\":1}}],[\"容器用到此\",{\"1\":{\"1290\":1}}],[\"容器关闭时销毁\",{\"1\":{\"1290\":1}}],[\"容器\",{\"0\":{\"1450\":1},\"1\":{\"1284\":2,\"1411\":1,\"1444\":1}}],[\"容器实现\",{\"0\":{\"1245\":1},\"1\":{\"1251\":1}}],[\"容器接口\",{\"0\":{\"1240\":1}}],[\"容器与\",{\"0\":{\"1239\":1}}],[\"容器下\",{\"1\":{\"847\":1}}],[\"容易沉迷\",{\"1\":{\"1166\":1}}],[\"容易崩溃\",{\"1\":{\"1094\":1}}],[\"容量不够了\",{\"1\":{\"773\":1}}],[\"容量\",{\"1\":{\"606\":1,\"610\":1}}],[\"格式的数据\",{\"1\":{\"1461\":1,\"1462\":1}}],[\"格式如下\",{\"1\":{\"1207\":1}}],[\"格式来表示\",{\"1\":{\"1063\":1}}],[\"格式\",{\"1\":{\"840\":3}}],[\"�好\",{\"1\":{\"839\":1}}],[\"道理是一样的\",{\"1\":{\"839\":1}}],[\"逐一尝试右边类型是否可以被赋值给左边的\",{\"1\":{\"1489\":1}}],[\"逐一处理\",{\"1\":{\"834\":1,\"836\":1}}],[\"逐梦之影\",{\"1\":{\"256\":1}}],[\"限流\",{\"1\":{\"1021\":1}}],[\"限于网络传输能力\",{\"1\":{\"828\":1}}],[\"限制⛔\",{\"1\":{\"1307\":1,\"1310\":1}}],[\"限制后\",{\"1\":{\"694\":1}}],[\"限制\",{\"1\":{\"694\":2}}],[\"限制请求线程数量\",{\"1\":{\"591\":1}}],[\"限制是不能执行full\",{\"1\":{\"326\":1}}],[\"限制多\",{\"1\":{\"162\":1}}],[\"体会返回值处理器的作用\",{\"1\":{\"1358\":1}}],[\"体会参数解析器的作用\",{\"1\":{\"1358\":1}}],[\"体现在上面方法的\",{\"1\":{\"1343\":1,\"1350\":1}}],[\"体现在以下方面\",{\"1\":{\"826\":1}}],[\"体积\",{\"1\":{\"648\":2}}],[\"拷贝数据时是否跳过cheacksum的校验\",{\"1\":{\"869\":1}}],[\"拷贝数据时\",{\"1\":{\"869\":2}}],[\"拷贝多级目录\",{\"1\":{\"823\":1}}],[\"拷贝文件时支持对现有文件进行追加写操作\",{\"1\":{\"869\":1}}],[\"拷贝文件\",{\"1\":{\"822\":1}}],[\"黏包\",{\"1\":{\"809\":1}}],[\"受单表数据量的限制\",{\"1\":{\"1131\":1}}],[\"受gc影响\",{\"1\":{\"801\":1}}],[\"受到了特征金字塔的启发\",{\"1\":{\"138\":1}}],[\"吗\",{\"1\":{\"794\":3}}],[\"练习\",{\"0\":{\"794\":1,\"809\":1}}],[\"久经考验\",{\"1\":{\"792\":1}}],[\"文字\",{\"1\":{\"1159\":1}}],[\"文档分页查询\",{\"1\":{\"1089\":1}}],[\"文档批量新增\",{\"1\":{\"1089\":1}}],[\"文档文档删除\",{\"1\":{\"1089\":1}}],[\"文档查询所有\",{\"1\":{\"1089\":1}}],[\"文档根据id查询\",{\"1\":{\"1089\":1}}],[\"文档操作\",{\"0\":{\"1073\":1}}],[\"文档以json\",{\"1\":{\"1063\":1}}],[\"文档\",{\"0\":{\"1063\":1}}],[\"文档更优秀\",{\"1\":{\"792\":1}}],[\"文本数据\",{\"1\":{\"973\":1}}],[\"文件夹\",{\"1\":{\"1449\":1}}],[\"文件置入\",{\"1\":{\"1443\":1}}],[\"文件上传失败\",{\"1\":{\"1159\":1}}],[\"文件上传成功\",{\"1\":{\"1159\":1}}],[\"文件类型\",{\"0\":{\"994\":1}}],[\"文件或目录不会立即被清除\",{\"1\":{\"909\":1}}],[\"文件块位置映射信息\",{\"1\":{\"905\":1}}],[\"文件大小\",{\"1\":{\"905\":1}}],[\"文件名称\",{\"1\":{\"905\":1}}],[\"文件自身属性信息\",{\"1\":{\"905\":1}}],[\"文件和块的位置信息\",{\"1\":{\"903\":1}}],[\"文件系统namespace操作维护目录树\",{\"1\":{\"903\":1}}],[\"文件系统的层次结构\",{\"0\":{\"202\":1}}],[\"文件编程\",{\"0\":{\"810\":1}}],[\"文件内容\",{\"1\":{\"808\":1}}],[\"文件内部的数据就是一系列二进制流或字符流组成\",{\"1\":{\"195\":1}}],[\"文件内部的数据应该是如何组织起来的\",{\"1\":{\"195\":1}}],[\"文件内部的数据组织形式\",{\"1\":{\"194\":1}}],[\"文件映射内存加速和内核空间的消息传递\",{\"1\":{\"680\":1}}],[\"文件描述符在形式上是一个非负整数\",{\"1\":{\"677\":1}}],[\"文件描述符\",{\"0\":{\"677\":1},\"1\":{\"677\":1}}],[\"文件里每一行是一个词\",{\"1\":{\"476\":1}}],[\"文件格式也是一种hadoop生态圈中的列式存储格式\",{\"1\":{\"430\":1}}],[\"文件格式\",{\"0\":{\"426\":1}}],[\"文件都以orc格式存储\",{\"1\":{\"293\":1}}],[\"文件个数多时\",{\"1\":{\"259\":1}}],[\"文件记录等功能\",{\"1\":{\"238\":1}}],[\"文件主的伙伴\",{\"1\":{\"201\":1}}],[\"文件主\",{\"1\":{\"201\":1}}],[\"文件数据\",{\"1\":{\"200\":1}}],[\"文件存储空间管理\",{\"0\":{\"198\":1}}],[\"文件分配表需要占用一定的内存\",{\"1\":{\"197\":1}}],[\"文件分配方式\",{\"1\":{\"197\":2}}],[\"文件控制块\",{\"1\":{\"196\":1}}],[\"文件目录包括文件第一块的指针和最后一块指针\",{\"1\":{\"197\":1}}],[\"文件目录\",{\"0\":{\"196\":1}}],[\"文件检索效率\",{\"1\":{\"195\":1}}],[\"文件的所有者\",{\"1\":{\"917\":1}}],[\"文件的备份\",{\"1\":{\"912\":1}}],[\"文件的权限等信息\",{\"1\":{\"819\":1}}],[\"文件的基本操作\",{\"0\":{\"199\":1}}],[\"文件的数据是如何存放在外存中的\",{\"1\":{\"195\":1}}],[\"文件的物理结构\",{\"0\":{\"197\":1},\"1\":{\"195\":1}}],[\"文件的逻辑结构\",{\"0\":{\"195\":1}}],[\"文件逻辑结构\",{\"1\":{\"195\":1}}],[\"文件保护\",{\"0\":{\"201\":1},\"1\":{\"194\":1}}],[\"文件共享是操作系统为用户提供文件共享功能\",{\"1\":{\"200\":1}}],[\"文件共享\",{\"0\":{\"200\":1},\"1\":{\"194\":1}}],[\"文件如何存放在外存\",{\"1\":{\"194\":1}}],[\"文件组织形式\",{\"1\":{\"194\":1}}],[\"文件区主要存放文件\",{\"1\":{\"181\":1}}],[\"文件管理等\",{\"1\":{\"158\":1}}],[\"文件管理\",{\"1\":{\"154\":1}}],[\"文件中的operation是2\",{\"1\":{\"293\":1}}],[\"文件中的记录一个接一个的顺序排列\",{\"1\":{\"195\":1}}],[\"文件中的依赖项是否正确\",{\"1\":{\"101\":1}}],[\"文件中\",{\"1\":{\"100\":1}}],[\"文件\",{\"0\":{\"857\":1},\"1\":{\"97\":1,\"101\":2,\"919\":1,\"1441\":2,\"1476\":1}}],[\"切面统一为低级\",{\"1\":{\"1333\":1}}],[\"切面\",{\"0\":{\"1323\":1},\"1\":{\"1322\":1,\"1333\":1}}],[\"切面的抽象如下\",{\"1\":{\"1322\":1}}],[\"切点是什么\",{\"1\":{\"1339\":1}}],[\"切点实现\",{\"1\":{\"1329\":1}}],[\"切点的局限性\",{\"1\":{\"1329\":1}}],[\"切点用法\",{\"1\":{\"1329\":1}}],[\"切点匹配\",{\"0\":{\"1326\":1,\"1327\":1}}],[\"切点\",{\"1\":{\"1322\":1}}],[\"切割读取的一行数据\",{\"1\":{\"988\":1}}],[\"切片后的\",{\"1\":{\"776\":3}}],[\"切换读模式\",{\"1\":{\"815\":1}}],[\"切换读写模式\",{\"1\":{\"610\":1}}],[\"切换为读取限制\",{\"1\":{\"798\":1}}],[\"切换为读取位置\",{\"1\":{\"798\":1}}],[\"切换至写模式\",{\"1\":{\"797\":1}}],[\"切换至读模式\",{\"1\":{\"797\":1}}],[\"切换数据库\",{\"1\":{\"278\":1}}],[\"切换\",{\"1\":{\"165\":1,\"796\":2}}],[\"切换与过程的调度方式\",{\"0\":{\"165\":1}}],[\"切换的工作都是由内核负责\",{\"1\":{\"163\":1}}],[\"切换进程\",{\"1\":{\"163\":1}}],[\"切换同进程内的线程\",{\"1\":{\"163\":1}}],[\"起步依赖本质上是一个maven项目对象模型\",{\"1\":{\"1521\":1}}],[\"起到数据备份的作用\",{\"1\":{\"1189\":1}}],[\"起点\",{\"1\":{\"775\":1}}],[\"起始路径\",{\"1\":{\"1447\":1}}],[\"起始地址\",{\"1\":{\"182\":1,\"184\":1}}],[\"起始位置\",{\"1\":{\"179\":1}}],[\"详细步骤\",{\"1\":{\"979\":1,\"980\":1}}],[\"详细分析如下\",{\"1\":{\"775\":1}}],[\"详见附件资料\",{\"1\":{\"293\":1}}],[\"呢\",{\"1\":{\"775\":1,\"1132\":1,\"1149\":1,\"1176\":1}}],[\"谁能谁先转换\",{\"1\":{\"1398\":1}}],[\"谁负责\",{\"1\":{\"775\":1}}],[\"谁是最后使用者\",{\"1\":{\"775\":1}}],[\"谁来负责\",{\"1\":{\"775\":1}}],[\"谁也无法结束\",{\"1\":{\"552\":1}}],[\"怎么做呢\",{\"1\":{\"1466\":2}}],[\"怎么到了\",{\"1\":{\"1455\":1}}],[\"怎么解决呢\",{\"1\":{\"1120\":1}}],[\"怎么办\",{\"1\":{\"774\":1}}],[\"怎么判断客户端连接是否假死呢\",{\"1\":{\"707\":1}}],[\"备注\",{\"1\":{\"772\":1}}],[\"含义\",{\"1\":{\"772\":1}}],[\"含聚合\",{\"1\":{\"310\":1}}],[\"废弃字节\",{\"1\":{\"771\":1}}],[\"池化功能还不成熟\",{\"1\":{\"770\":1}}],[\"池化功能是否开启\",{\"1\":{\"770\":1}}],[\"池化功能更节约内存\",{\"1\":{\"770\":1}}],[\"池化的最大意义在于可以重用\",{\"1\":{\"770\":1}}],[\"池化\",{\"0\":{\"770\":1},\"1\":{\"781\":1}}],[\"池化基于直接内存的\",{\"1\":{\"768\":1}}],[\"压缩文件需要手动生成\",{\"1\":{\"1433\":1}}],[\"压缩列表只会用于保存的节点数量不多的场景\",{\"1\":{\"667\":1}}],[\"压缩列表占用的内存空间就需要重新分配\",{\"1\":{\"666\":1}}],[\"压缩列表占用的内存空间需要重新分配\",{\"1\":{\"664\":1}}],[\"压缩列表新增某个元素或修改某个元素时\",{\"1\":{\"666\":1}}],[\"压缩列表除了查找复杂度高的问题\",{\"1\":{\"666\":1}}],[\"压缩列表里的每个节点中的\",{\"1\":{\"665\":1}}],[\"压缩列表就会根据数据是字符串还是整数\",{\"1\":{\"665\":1}}],[\"压缩列表节点的\",{\"1\":{\"666\":1}}],[\"压缩列表节点包含三部分内容\",{\"1\":{\"665\":1}}],[\"压缩列表节点\",{\"1\":{\"665\":1}}],[\"压缩列表在表头有三个字段\",{\"1\":{\"665\":1}}],[\"压缩列表是\",{\"1\":{\"665\":1}}],[\"压缩列表结构设计\",{\"0\":{\"665\":1}}],[\"压缩列表的缺陷\",{\"0\":{\"667\":1}}],[\"压缩列表的缺陷也是有的\",{\"1\":{\"664\":1}}],[\"压缩列表的最大特点\",{\"1\":{\"664\":1}}],[\"压缩列表\",{\"0\":{\"664\":1},\"1\":{\"517\":1}}],[\"压力颇大\",{\"1\":{\"988\":1}}],[\"压力\",{\"1\":{\"770\":1}}],[\"压力小\",{\"1\":{\"769\":1}}],[\"堆外内存最好是手动来释放\",{\"1\":{\"775\":1}}],[\"堆内存\",{\"0\":{\"769\":1}}],[\"堆中的每个节点存放每个有序小文件对应的输入流\",{\"1\":{\"478\":1}}],[\"出错时使用请求转发方式跳转\",{\"1\":{\"1413\":1}}],[\"出站消息最终都会转为\",{\"1\":{\"775\":1}}],[\"出站处理器中\",{\"1\":{\"766\":1}}],[\"出站处理器通常是\",{\"1\":{\"766\":1}}],[\"出站\",{\"1\":{\"766\":1,\"775\":1}}],[\"出现异常\",{\"1\":{\"1438\":1}}],[\"出现的位置\",{\"1\":{\"1174\":1}}],[\"出现的位置置1\",{\"1\":{\"353\":1}}],[\"出现一些问题\",{\"1\":{\"1013\":1}}],[\"出现背景\",{\"1\":{\"875\":1}}],[\"出现时\",{\"1\":{\"742\":1}}],[\"出现了异常\",{\"1\":{\"717\":1,\"718\":2,\"1411\":1}}],[\"出现丢包\",{\"1\":{\"707\":1}}],[\"出现这个问题的原因主要还是在于redis的过期数据删除策略\",{\"1\":{\"529\":1}}],[\"出现原因\",{\"1\":{\"452\":1}}],[\"出现having的原因是where关键字无法与聚合函数一起使用\",{\"1\":{\"307\":1}}],[\"出现上面加粗的限制原因\",{\"1\":{\"306\":1}}],[\"出现问题的原因是jvm在实例化对象的时候会进行优化和指令重排序操作\",{\"1\":{\"66\":1}}],[\"填充结果\",{\"1\":{\"759\":1}}],[\"医生\",{\"1\":{\"755\":1}}],[\"💡\",{\"0\":{\"749\":1,\"837\":1}}],[\"细分2\",{\"1\":{\"748\":1}}],[\"细分1\",{\"1\":{\"748\":2}}],[\"细节应该依赖抽象\",{\"1\":{\"74\":1}}],[\"演示主类推断\",{\"1\":{\"1446\":1}}],[\"演示4\",{\"0\":{\"1278\":1}}],[\"演示3\",{\"0\":{\"1258\":1,\"1275\":1,\"1337\":1,\"1377\":1,\"1434\":1}}],[\"演示2\",{\"0\":{\"1244\":1,\"1249\":1,\"1256\":1,\"1265\":1,\"1272\":1,\"1295\":1,\"1306\":1,\"1311\":1,\"1334\":1,\"1344\":1,\"1356\":1,\"1374\":1,\"1415\":1,\"1431\":1,\"1450\":1}}],[\"演示1\",{\"0\":{\"1241\":1,\"1246\":1,\"1253\":1,\"1262\":1,\"1269\":1,\"1291\":1,\"1304\":1,\"1309\":1,\"1331\":1,\"1341\":1,\"1353\":1,\"1371\":1,\"1412\":1,\"1427\":1,\"1448\":1}}],[\"演示\",{\"0\":{\"748\":1,\"750\":1,\"751\":1,\"1282\":1,\"1287\":1,\"1315\":1,\"1319\":1,\"1323\":1,\"1327\":1,\"1348\":1,\"1360\":1,\"1364\":1,\"1381\":1,\"1388\":1,\"1392\":1,\"1396\":1,\"1400\":1,\"1404\":1,\"1408\":1,\"1419\":1,\"1423\":1,\"1445\":1,\"1463\":1,\"1470\":1,\"1474\":1,\"1478\":1,\"1483\":1,\"1487\":1,\"1491\":1,\"1495\":1}}],[\"醒来后\",{\"1\":{\"742\":1}}],[\"超卖问题是典型的多线程安全问题\",{\"1\":{\"1135\":1}}],[\"超时释放\",{\"1\":{\"1141\":1,\"1149\":1}}],[\"超时剔除\",{\"1\":{\"1119\":1}}],[\"超时时才能被执行\",{\"1\":{\"742\":1}}],[\"超时时间为\",{\"1\":{\"742\":2}}],[\"超过了文件末尾\",{\"1\":{\"817\":1}}],[\"超过\",{\"1\":{\"723\":1,\"820\":1}}],[\"超过几个g\",{\"1\":{\"486\":1}}],[\"超过三个表禁止join\",{\"1\":{\"481\":1}}],[\"超过阈值\",{\"1\":{\"139\":1}}],[\"看需要的类型是否为\",{\"1\":{\"1482\":1}}],[\"看看内存占用和统计效果如何\",{\"1\":{\"1180\":1}}],[\"看看有没有小伙伴这么想\",{\"1\":{\"1155\":1}}],[\"看病可以细分为四个步骤\",{\"1\":{\"755\":1}}],[\"看是否应当阻塞\",{\"1\":{\"741\":1}}],[\"看如下类图\",{\"1\":{\"75\":1}}],[\"剖析\",{\"0\":{\"741\":1,\"743\":1,\"744\":1}}],[\"附近商户\",{\"0\":{\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":1}}],[\"附件为\",{\"1\":{\"740\":1}}],[\"附录\",{\"0\":{\"117\":1,\"123\":1,\"130\":1,\"143\":1}}],[\"日志管理和权限管理等\",{\"1\":{\"1500\":1}}],[\"日志管理程序会定期清理这些日志\",{\"1\":{\"1056\":1}}],[\"日志文件\",{\"1\":{\"1196\":1}}],[\"日志\",{\"1\":{\"1196\":1}}],[\"日志合并\",{\"1\":{\"1056\":1}}],[\"日志大小\",{\"1\":{\"1056\":1}}],[\"日志删除\",{\"1\":{\"1056\":1}}],[\"日志处理\",{\"1\":{\"1009\":1}}],[\"日志记录\",{\"1\":{\"740\":1,\"743\":1}}],[\"日期格式要求\",{\"1\":{\"337\":1}}],[\"日期减少函数\",{\"1\":{\"337\":2}}],[\"日期增加函数\",{\"1\":{\"337\":2}}],[\"日期比较函数\",{\"1\":{\"337\":2}}],[\"日期转秒函数\",{\"1\":{\"337\":1}}],[\"日期转分钟函数\",{\"1\":{\"337\":1}}],[\"日期转小时函数\",{\"1\":{\"337\":1}}],[\"日期转天函数\",{\"1\":{\"337\":1}}],[\"日期转月函数\",{\"1\":{\"337\":1}}],[\"日期转周函数\",{\"1\":{\"337\":2}}],[\"日期转年函数\",{\"1\":{\"337\":2}}],[\"日期转unix时间戳函数\",{\"1\":{\"337\":2}}],[\"日期函数\",{\"0\":{\"337\":1},\"1\":{\"337\":1}}],[\"日期day\",{\"1\":{\"236\":1}}],[\"立刻返回\",{\"1\":{\"832\":1}}],[\"立刻写入磁盘\",{\"1\":{\"819\":1}}],[\"立刻\",{\"1\":{\"753\":1}}],[\"立刻调用\",{\"1\":{\"740\":1}}],[\"立刻就可以开始去做其他事\",{\"1\":{\"679\":1}}],[\"入站\",{\"1\":{\"775\":1}}],[\"入站处理器中\",{\"1\":{\"766\":1}}],[\"入站处理器通常是\",{\"1\":{\"766\":1}}],[\"入口\",{\"1\":{\"740\":1}}],[\"入门案例详细步骤\",{\"1\":{\"1213\":1}}],[\"入门操作\",{\"0\":{\"1069\":1}}],[\"入门\",{\"0\":{\"218\":1,\"229\":1}}],[\"绑定事件\",{\"1\":{\"831\":1}}],[\"绑定监听端口\",{\"1\":{\"826\":1,\"827\":1}}],[\"绑定\",{\"0\":{\"831\":1},\"1\":{\"787\":1,\"1444\":1,\"1446\":1}}],[\"绑定的事件类型可以有\",{\"1\":{\"831\":1}}],[\"绑定的事件\",{\"1\":{\"831\":1}}],[\"绑定的监听端口\",{\"1\":{\"784\":1}}],[\"绑定的是同一个线程\",{\"1\":{\"749\":1}}],[\"绑定到\",{\"1\":{\"740\":1}}],[\"绑定端口\",{\"1\":{\"740\":1}}],[\"绑定会话\",{\"1\":{\"701\":1}}],[\"序列号的位数\",{\"1\":{\"1132\":1}}],[\"序列号的最大值是4095\",{\"1\":{\"999\":1}}],[\"序列号\",{\"1\":{\"1131\":1}}],[\"序列号最大值为4095\",{\"1\":{\"999\":2}}],[\"序列化错误\",{\"1\":{\"723\":1}}],[\"序列化方法\",{\"1\":{\"723\":1,\"972\":1,\"985\":1}}],[\"序列化时\",{\"1\":{\"723\":1}}],[\"序列化算法\",{\"1\":{\"712\":1}}],[\"序列化serde相关的语法\",{\"1\":{\"251\":1}}],[\"序列化是对象转化为字节码的过程\",{\"1\":{\"249\":1}}],[\"序列化\",{\"1\":{\"69\":1,\"723\":2,\"956\":1}}],[\"序列化反序列化\",{\"1\":{\"68\":1}}],[\"序号\",{\"1\":{\"738\":1}}],[\"待支付\",{\"1\":{\"1005\":1}}],[\"待实现\",{\"1\":{\"733\":2}}],[\"待以后需要的时候再重新申请一下\",{\"1\":{\"176\":1}}],[\"框架的支持\",{\"1\":{\"1499\":2}}],[\"框架的工具类\",{\"1\":{\"574\":1}}],[\"框架内部的类常用内置注入和初始化\",{\"1\":{\"1284\":1}}],[\"框架集成\",{\"0\":{\"1086\":1}}],[\"框架概述\",{\"0\":{\"939\":1}}],[\"框架在\",{\"1\":{\"791\":1}}],[\"框架\",{\"0\":{\"732\":1},\"1\":{\"791\":2}}],[\"启示\",{\"0\":{\"1443\":1}}],[\"启用spring\",{\"1\":{\"1525\":1}}],[\"启用trash功能后\",{\"1\":{\"909\":1}}],[\"启用擦除编码策略\",{\"1\":{\"875\":1}}],[\"启用\",{\"1\":{\"875\":1}}],[\"启用isa\",{\"1\":{\"875\":1}}],[\"启用的情况下\",{\"1\":{\"726\":1}}],[\"启动日志\",{\"1\":{\"1522\":1}}],[\"启动过程\",{\"0\":{\"1444\":1,\"1445\":1}}],[\"启动后\",{\"1\":{\"1442\":1}}],[\"启动后就初始化\",{\"1\":{\"1355\":1}}],[\"启动redis\",{\"1\":{\"1196\":1}}],[\"启动kafka\",{\"1\":{\"1012\":1}}],[\"启动kms\",{\"1\":{\"936\":1}}],[\"启动zookeeper\",{\"1\":{\"1012\":1}}],[\"启动服务器\",{\"1\":{\"1012\":1}}],[\"启动applicationmaster\",{\"1\":{\"953\":1}}],[\"启动container容器\",{\"1\":{\"944\":1}}],[\"启动三次\",{\"1\":{\"748\":2}}],[\"启动死循环\",{\"1\":{\"741\":1}}],[\"启动剖析\",{\"0\":{\"740\":1}}],[\"启动监控器线程\",{\"1\":{\"536\":1}}],[\"启动jvm进程\",{\"1\":{\"444\":1}}],[\"启动方式\",{\"1\":{\"244\":1}}],[\"启动\",{\"0\":{\"1194\":1},\"1\":{\"241\":1,\"740\":1,\"741\":1,\"1013\":1,\"1019\":1,\"1046\":1,\"1196\":1,\"1197\":1,\"1449\":1}}],[\"启动块位于磁盘的固定位置\",{\"1\":{\"206\":1}}],[\"启动分区\",{\"1\":{\"206\":1}}],[\"启动磁头臂时间为s\",{\"1\":{\"204\":1}}],[\"队列等限制条件\",{\"1\":{\"945\":1}}],[\"队列里可以堆放多个\",{\"1\":{\"787\":1}}],[\"队列满了\",{\"1\":{\"726\":1}}],[\"队列\",{\"1\":{\"726\":1}}],[\"队列的最大长度取决于系统为进程分配了多少个内存块\",{\"1\":{\"191\":1}}],[\"收获💡\",{\"0\":{\"1243\":1,\"1248\":1,\"1251\":1,\"1255\":1,\"1260\":1,\"1264\":1,\"1267\":1,\"1271\":1,\"1274\":1,\"1277\":1,\"1280\":1,\"1284\":1,\"1289\":1,\"1293\":1,\"1297\":1,\"1300\":1,\"1302\":1,\"1305\":1,\"1307\":1,\"1310\":1,\"1313\":1,\"1317\":1,\"1321\":1,\"1325\":1,\"1329\":1,\"1333\":1,\"1336\":1,\"1339\":1,\"1343\":1,\"1346\":1,\"1350\":1,\"1355\":1,\"1358\":1,\"1362\":1,\"1366\":1,\"1373\":1,\"1376\":1,\"1379\":1,\"1382\":1,\"1390\":1,\"1394\":1,\"1398\":1,\"1402\":1,\"1406\":1,\"1410\":1,\"1414\":1,\"1417\":1,\"1421\":1,\"1425\":1,\"1430\":1,\"1433\":1,\"1436\":1,\"1446\":1,\"1465\":1,\"1467\":1,\"1472\":1,\"1476\":1,\"1480\":1,\"1485\":1,\"1489\":1,\"1493\":1,\"1497\":1}}],[\"收一个小尾巴\",{\"1\":{\"1224\":1}}],[\"收件箱满足可以根据时间戳排序\",{\"1\":{\"1167\":1}}],[\"收到pipeline中所有datanode确认信息后\",{\"1\":{\"901\":1}}],[\"收到\",{\"1\":{\"726\":3}}],[\"收集的地址\",{\"1\":{\"1171\":1}}],[\"收集操作发生的频率\",{\"1\":{\"637\":1}}],[\"收集频率\",{\"1\":{\"637\":1}}],[\"收集整个java堆和方法区的垃圾收集\",{\"1\":{\"628\":1}}],[\"收集整个新生代以及部分老年代的垃圾收集\",{\"1\":{\"628\":1}}],[\"收集\",{\"0\":{\"621\":1}}],[\"慢\",{\"1\":{\"719\":1}}],[\"玖\",{\"1\":{\"718\":1}}],[\"捌\",{\"1\":{\"718\":1}}],[\"柒\",{\"1\":{\"718\":1}}],[\"陆\",{\"1\":{\"718\":1}}],[\"伍\",{\"1\":{\"718\":1}}],[\"肆\",{\"1\":{\"718\":1}}],[\"肆虐的毛豆的博客\",{\"1\":{\"602\":1}}],[\"叁\",{\"1\":{\"718\":1}}],[\"贰\",{\"1\":{\"718\":1}}],[\"壹\",{\"1\":{\"718\":1}}],[\"零拷贝适合小文件传输\",{\"1\":{\"855\":1}}],[\"零拷贝的优点有\",{\"1\":{\"855\":1}}],[\"零拷贝\",{\"0\":{\"853\":1},\"1\":{\"776\":1,\"777\":1,\"779\":1,\"780\":1,\"855\":1}}],[\"零\",{\"1\":{\"718\":1}}],[\"协调这些线程执行的先后顺序\",{\"1\":{\"716\":1}}],[\"协议\",{\"1\":{\"1447\":1}}],[\"协议向\",{\"1\":{\"949\":1,\"953\":2}}],[\"协议向rm注册和撤销自己\",{\"1\":{\"949\":1}}],[\"协议更新yarn集群系统配置文件\",{\"1\":{\"949\":1}}],[\"协议提交应用程序\",{\"1\":{\"949\":1}}],[\"协议举例\",{\"0\":{\"710\":1,\"711\":1}}],[\"协议是这样的\",{\"1\":{\"709\":1}}],[\"协议的目的就是划定消息的边界\",{\"1\":{\"709\":1}}],[\"协议设计与解析\",{\"0\":{\"708\":1}}],[\"魔数\",{\"1\":{\"712\":1}}],[\"束脩\",{\"1\":{\"709\":1}}],[\"肉亦可\",{\"1\":{\"709\":1}}],[\"鸭亦可\",{\"1\":{\"709\":1}}],[\"然主家亦振振有词\",{\"1\":{\"709\":1}}],[\"然后自定义捕获异常类型即可对这些捕获的异常进行统一处理\",{\"1\":{\"1526\":1}}],[\"然后判断这一位是\",{\"1\":{\"1177\":1}}],[\"然后当用户来查询数据时\",{\"1\":{\"1177\":1}}],[\"然后不停的向前统计\",{\"1\":{\"1176\":1}}],[\"然后到对应的地址上去修改\",{\"1\":{\"1175\":1}}],[\"然后保存到一个\",{\"1\":{\"1175\":1}}],[\"然后记录下当前最后一次拿取的记录\",{\"1\":{\"1167\":1}}],[\"然后是6~2\",{\"1\":{\"1167\":1}}],[\"然后按照时间排序即可\",{\"1\":{\"1166\":1}}],[\"然后按指定的步长进行自增\",{\"1\":{\"997\":1}}],[\"然后直接把内容推送给用户\",{\"1\":{\"1166\":1}}],[\"然后异步执行\",{\"1\":{\"1157\":1}}],[\"然后我后边慢慢做就可以了\",{\"1\":{\"1155\":1}}],[\"然后我们期望的是分线程全部走完之后\",{\"1\":{\"1132\":1}}],[\"然后说\",{\"1\":{\"1147\":1}}],[\"然后启动两个线程\",{\"1\":{\"1144\":1}}],[\"然后启动第三种磁盘到磁盘的merge方式生成最终的文件\",{\"1\":{\"980\":1}}],[\"然后删除锁\",{\"1\":{\"1143\":1}}],[\"然后线程2在持有锁执行过程中\",{\"1\":{\"1143\":1}}],[\"然后修改redis\",{\"1\":{\"1196\":1}}],[\"然后修改nginx的conf目录下的nginx\",{\"1\":{\"1138\":1}}],[\"然后修改分区状态\",{\"1\":{\"182\":1}}],[\"然后大家一起去进行扣减\",{\"1\":{\"1136\":1}}],[\"然后要求version\",{\"1\":{\"1135\":1}}],[\"然后从这个位置开始去读取数据\",{\"1\":{\"1167\":1}}],[\"然后从value中判断出来当前的数据已经过期了\",{\"1\":{\"1126\":1}}],[\"然后从线程中取出线程的成员变量map\",{\"1\":{\"1100\":1}}],[\"然后存入redis\",{\"1\":{\"1118\":1}}],[\"然后让前端带来这个token就能完成我们的整体逻辑了\",{\"1\":{\"1105\":1}}],[\"然后让用户在对应的snapshot上进行相关的实验和测试\",{\"1\":{\"912\":1}}],[\"然后和用户输入的验证码进行校验\",{\"1\":{\"1098\":1}}],[\"然后和自己读取的大数据集进行join关联\",{\"1\":{\"990\":1}}],[\"然后开始从offset往后顺序拉取数据\",{\"1\":{\"1051\":1}}],[\"然后进行或运行\",{\"1\":{\"999\":1}}],[\"然后进行正序排序\",{\"1\":{\"313\":1}}],[\"然后需要全局唯一\",{\"1\":{\"998\":1}}],[\"然后交给reducer处理\",{\"1\":{\"984\":1}}],[\"然后取第一个即是最大值\",{\"1\":{\"974\":1}}],[\"然后取值\",{\"1\":{\"351\":1}}],[\"然后它将为各个任务申请资源\",{\"1\":{\"953\":1}}],[\"然后nn将edek发送给client\",{\"1\":{\"934\":1}}],[\"然后namenode选择一个datanode进行恢复工作\",{\"1\":{\"875\":1}}],[\"然后用while循环去不停去尝试拿锁\",{\"1\":{\"1153\":1}}],[\"然后用这个线程转发到工程中的controller\",{\"1\":{\"1100\":1}}],[\"然后用这个整数值对16384进行取模来得到具体槽位\",{\"1\":{\"528\":1}}],[\"然后用于后续的权限管理\",{\"1\":{\"921\":1}}],[\"然后根据规则被授予权限\",{\"1\":{\"916\":1}}],[\"然后根据num分组\",{\"1\":{\"313\":1}}],[\"然后寻找下一个块的最佳datanode\",{\"1\":{\"902\":1}}],[\"然后重载系统服务\",{\"1\":{\"1197\":1}}],[\"然后重演操作记录同步到自己的目录镜像树里面\",{\"1\":{\"886\":1}}],[\"然后重新利用这块缓冲区\",{\"1\":{\"979\":1}}],[\"然后重新编译内核但是性能可能受到影响\",{\"1\":{\"680\":1}}],[\"然后重新提交被拒绝的任务\",{\"1\":{\"573\":1}}],[\"然后重新调整此堆为小顶堆\",{\"1\":{\"477\":1}}],[\"然后计算出校验数据\",{\"1\":{\"875\":1}}],[\"然后切换至写模式\",{\"1\":{\"798\":1}}],[\"然后程序就可以执行了\",{\"1\":{\"689\":1}}],[\"然后离散的存储在不同的物理块中\",{\"1\":{\"683\":1}}],[\"然后查询每个fd对应的设备状态\",{\"1\":{\"680\":1}}],[\"然后kernel返回结果\",{\"1\":{\"679\":1}}],[\"然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"679\":1}}],[\"然后才会从操作系统的内核缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"678\":1}}],[\"然后才执行实际的修改操作\",{\"1\":{\"663\":1}}],[\"然后对于\",{\"1\":{\"662\":1}}],[\"然后对数据进行更新或删除操作时会对当前字段的version进行加一操作\",{\"1\":{\"507\":1}}],[\"然后返回订单id\",{\"1\":{\"1134\":1}}],[\"然后返回\",{\"1\":{\"679\":1,\"1155\":1}}],[\"然后返回已经统计到的字符个数\",{\"1\":{\"662\":1}}],[\"然后返回放弃前offset行\",{\"1\":{\"481\":1}}],[\"然后把数据推送到粉丝的redis中去\",{\"1\":{\"1167\":1}}],[\"然后把这个数据重新加载到缓存的\",{\"1\":{\"1126\":1}}],[\"然后把缓存中的数据进行删除\",{\"1\":{\"1122\":1}}],[\"然后把文件描述符传递给b\",{\"1\":{\"872\":1}}],[\"然后把所有流连接成一个流\",{\"1\":{\"617\":1}}],[\"然后把输入数据中的每个元素拆开变成一行数据\",{\"1\":{\"346\":1}}],[\"然后唤醒entrylist中等待的线程来竞争锁\",{\"1\":{\"541\":1}}],[\"然后调度执行其他同优先级的线程\",{\"1\":{\"533\":1}}],[\"然后调用outputformat\",{\"1\":{\"250\":1}}],[\"然后调用serde\",{\"1\":{\"250\":1}}],[\"然后向slave发送一个del命令\",{\"1\":{\"529\":1}}],[\"然后为每条待插入记录的auto\",{\"1\":{\"510\":1}}],[\"然后处理所有的行\",{\"1\":{\"422\":1}}],[\"然后通过轮询方式逐个将分区以此分配给每个消费者\",{\"1\":{\"1041\":1}}],[\"然后通过比较不同备份之间差异性\",{\"1\":{\"912\":1}}],[\"然后通过算法进行恢复\",{\"1\":{\"875\":1}}],[\"然后通过\",{\"1\":{\"605\":1}}],[\"然后通过union\",{\"1\":{\"409\":1}}],[\"然后通过二进制来表示的\",{\"1\":{\"353\":1}}],[\"然后针对struct应用max找出最大元素\",{\"1\":{\"351\":1}}],[\"然后\",{\"1\":{\"326\":2,\"679\":1,\"870\":1,\"902\":1}}],[\"然后insert到分桶表实现的\",{\"1\":{\"266\":1}}],[\"然后在拦截其中进行拦截处理\",{\"1\":{\"1232\":1}}],[\"然后在进行排序\",{\"1\":{\"1166\":1}}],[\"然后在任务队列的任务都处理完成后\",{\"1\":{\"747\":1}}],[\"然后在两者之间选择一个小值作为\",{\"1\":{\"694\":1}}],[\"然后在该文件中进行查找\",{\"1\":{\"263\":1}}],[\"然后在修改奖状上的名字即可\",{\"1\":{\"52\":1}}],[\"然后将课前资料提供的redis安装包上传到虚拟机的任意目录\",{\"1\":{\"1193\":1}}],[\"然后将这个值从\",{\"1\":{\"1177\":1}}],[\"然后将数据存入redis\",{\"1\":{\"1117\":1}}],[\"然后将数据拷贝到用户内存\",{\"1\":{\"679\":1}}],[\"然后将standby转换为active状态\",{\"1\":{\"885\":1}}],[\"然后将物理块号与页内偏移地址拼接成实际物理地址\",{\"1\":{\"683\":1}}],[\"然后将对应的位数组的下标设置为\",{\"1\":{\"659\":1}}],[\"然后将364gb的数据过滤掉\",{\"1\":{\"414\":1}}],[\"然后将结果与c联接到第二个map\",{\"1\":{\"326\":1}}],[\"然后将结构化数据加载到仓库中\",{\"1\":{\"228\":1}}],[\"然后将程序提交到hadoop群集执行\",{\"1\":{\"229\":1}}],[\"然后执行转换操作\",{\"1\":{\"228\":1}}],[\"然后由操作系统的缺页中断处理程序处理中断\",{\"1\":{\"190\":1}}],[\"然后继续执行程序\",{\"1\":{\"689\":1}}],[\"然后继续执行\",{\"1\":{\"189\":1,\"190\":1}}],[\"然后采取某种措施解除死锁\",{\"1\":{\"175\":1}}],[\"然后再根据编号去调用目标方法\",{\"1\":{\"1321\":1}}],[\"然后再根据优惠卷id和用户id查询是否已经下过这个订单\",{\"1\":{\"1137\":1}}],[\"然后再直接写一份到活跃粉丝收件箱里边去\",{\"1\":{\"1166\":1}}],[\"然后再通过api去查看这两个set集合中的交集数据\",{\"1\":{\"1165\":1}}],[\"然后再通过短信的方式将验证码发送给用户\",{\"1\":{\"1098\":1}}],[\"然后再来个线程异步的下单\",{\"1\":{\"1155\":1}}],[\"然后再来执行逻辑\",{\"1\":{\"1126\":1}}],[\"然后再统一做返回\",{\"1\":{\"1155\":1}}],[\"然后再删除锁\",{\"1\":{\"1141\":1}}],[\"然后再以key相同的为一组\",{\"1\":{\"961\":1}}],[\"然后再进行回表操作\",{\"1\":{\"495\":1}}],[\"然后再对它进行更新或删除\",{\"1\":{\"493\":1}}],[\"然后再关联\",{\"1\":{\"481\":1}}],[\"然后再使用消去重复行的操作将上述两个结果集合并为一个结果集\",{\"1\":{\"323\":1}}],[\"然后再程序中以委托的方式来使用算法\",{\"1\":{\"79\":1}}],[\"然后再把内裤外穿\",{\"1\":{\"19\":1}}],[\"遂与主家理论\",{\"1\":{\"709\":1}}],[\"丝毫未见鸡鸭鱼肉的款待\",{\"1\":{\"709\":1}}],[\"私塾先生据理力争\",{\"1\":{\"709\":1}}],[\"私塾先生临行时\",{\"1\":{\"709\":1}}],[\"私塾先生先是很不解\",{\"1\":{\"709\":1}}],[\"私塾先生虽然认真教课\",{\"1\":{\"709\":1}}],[\"私有构造方法\",{\"1\":{\"66\":7,\"68\":2,\"69\":2}}],[\"留\",{\"1\":{\"709\":1}}],[\"留我不\",{\"1\":{\"709\":1}}],[\"留客天\",{\"1\":{\"709\":1}}],[\"天才基本法\",{\"1\":{\"1525\":1}}],[\"天里边签到了多少次呢\",{\"1\":{\"1176\":1}}],[\"天然的问题就是自旋\",{\"1\":{\"1136\":1}}],[\"天然的幂等性\",{\"1\":{\"1004\":1}}],[\"天留\",{\"1\":{\"709\":1}}],[\"天猫\",{\"1\":{\"633\":1}}],[\"制定通信双方要共同遵守的通信规则\",{\"1\":{\"709\":1}}],[\"制定构建打包时\",{\"1\":{\"102\":1}}],[\"触发的原始流程\",{\"1\":{\"766\":1}}],[\"触发上一个出站处理器\",{\"1\":{\"766\":1}}],[\"触发\",{\"1\":{\"740\":3,\"743\":3,\"744\":2}}],[\"触发了写空闲事件\",{\"1\":{\"707\":1}}],[\"触发了读空闲事件\",{\"1\":{\"707\":1}}],[\"触动主动清理策略\",{\"1\":{\"522\":1}}],[\"仍应被施加于原始对象\",{\"1\":{\"1336\":1}}],[\"仍然使用\",{\"1\":{\"1294\":1}}],[\"仍然占用着资源\",{\"1\":{\"707\":1}}],[\"仍指向原有属性所指向的对象的内存地址\",{\"1\":{\"51\":1}}],[\"机制\",{\"0\":{\"1036\":1,\"1152\":1}}],[\"机制是java集合\",{\"1\":{\"602\":1}}],[\"机器\",{\"1\":{\"1001\":1}}],[\"机器号+服务号\",{\"1\":{\"998\":1}}],[\"机器id+服务id\",{\"1\":{\"998\":1}}],[\"机架数量=\",{\"1\":{\"875\":1}}],[\"机房等\",{\"1\":{\"707\":1}}],[\"群不存在\",{\"1\":{\"704\":2}}],[\"群加入成功\",{\"1\":{\"704\":1}}],[\"群管理器\",{\"1\":{\"704\":1}}],[\"群聊\",{\"0\":{\"704\":1},\"1\":{\"704\":1,\"712\":1}}],[\"登录拦截器\",{\"1\":{\"1100\":1}}],[\"登录shell\",{\"1\":{\"924\":1}}],[\"登录成功\",{\"1\":{\"702\":1,\"703\":1}}],[\"登录成功返回\",{\"1\":{\"701\":1}}],[\"登录\",{\"0\":{\"702\":1},\"1\":{\"701\":1,\"703\":1,\"1099\":1}}],[\"登录等\",{\"1\":{\"110\":1}}],[\"聊天组会话管理接口\",{\"1\":{\"701\":1}}],[\"聊天室业务\",{\"0\":{\"702\":1,\"703\":1,\"704\":1,\"705\":1,\"706\":1}}],[\"聊天室业务介绍\",{\"0\":{\"701\":1}}],[\"聊天室案例\",{\"0\":{\"700\":1}}],[\"聊聊树状数组\",{\"1\":{\"672\":1}}],[\"剥离字节数\",{\"1\":{\"699\":1}}],[\"剥夺调度方式\",{\"1\":{\"165\":1}}],[\"浪费\",{\"1\":{\"697\":1}}],[\"浪费了宝贵的内存资源\",{\"1\":{\"189\":1}}],[\"略\",{\"1\":{\"696\":1,\"740\":1,\"743\":1,\"894\":1,\"895\":1,\"988\":1,\"1138\":1}}],[\"刨去\",{\"1\":{\"694\":1}}],[\"光纤分布式数据接口\",{\"1\":{\"694\":1}}],[\"半径\",{\"1\":{\"1170\":1}}],[\"半连接队列\",{\"1\":{\"726\":1}}],[\"半包用这种办法还是不好解决\",{\"1\":{\"696\":1}}],[\"半包\",{\"1\":{\"694\":1,\"792\":1,\"809\":1}}],[\"半包现象\",{\"0\":{\"693\":1}}],[\"半结构化数据文件映射为一张数据库表\",{\"1\":{\"229\":1}}],[\"次调用生成的代理类\",{\"1\":{\"1313\":1}}],[\"次调用会生成代理类\",{\"1\":{\"1313\":1}}],[\"次反射性能较低\",{\"1\":{\"1313\":1}}],[\"次\",{\"1\":{\"774\":1,\"854\":2,\"855\":2,\"1174\":1}}],[\"次发送\",{\"1\":{\"696\":1}}],[\"次接收\",{\"1\":{\"692\":1}}],[\"次方\",{\"1\":{\"663\":2}}],[\"哪怕你单独去提取这个主键\",{\"1\":{\"1177\":1}}],[\"哪怕此时redis中的数据过期了\",{\"1\":{\"1123\":1}}],[\"哪些是\",{\"1\":{\"1176\":1}}],[\"哪些情况不适合创建索引\",{\"0\":{\"494\":1}}],[\"哪些情况适合创建索引\",{\"0\":{\"493\":1}}],[\"哪假如说返回一个数字\",{\"1\":{\"1176\":1}}],[\"哪个\",{\"1\":{\"701\":4}}],[\"哪一个页面是未来最长时间内不再被访问的\",{\"1\":{\"690\":1}}],[\"永远为0\",{\"1\":{\"1131\":1}}],[\"永不终止运行的应用程序\",{\"1\":{\"951\":1}}],[\"永不过时\",{\"1\":{\"519\":1}}],[\"永久关闭\",{\"1\":{\"878\":1}}],[\"永久\",{\"1\":{\"689\":1}}],[\"腾出足够的内存空间后\",{\"1\":{\"688\":1}}],[\"尚未开始\",{\"1\":{\"1137\":2}}],[\"尚未调入内存\",{\"1\":{\"688\":1}}],[\"尚不支持begin\",{\"1\":{\"267\":1,\"296\":1}}],[\"顺序的沿着一个方向传输\",{\"1\":{\"898\":1}}],[\"顺序\",{\"1\":{\"787\":1}}],[\"顺序执行的\",{\"1\":{\"687\":1}}],[\"顺序文件\",{\"1\":{\"195\":1}}],[\"像控制反转和依赖注入功能\",{\"1\":{\"1245\":1}}],[\"像个弹簧一样\",{\"1\":{\"1113\":1}}],[\"像企业级mysql加上固态硬盘能够支撑的并发\",{\"1\":{\"1094\":1}}],[\"像c语言中指针存储的数值就可以理解为逻辑地址\",{\"1\":{\"684\":1}}],[\"像reentrantlock\",{\"1\":{\"581\":1}}],[\"线路上存在a\",{\"1\":{\"795\":1}}],[\"线性下降性能问题\",{\"1\":{\"680\":1}}],[\"线程变量中如果有province字段\",{\"1\":{\"1232\":1}}],[\"线程唯一标识\",{\"1\":{\"1151\":1}}],[\"线程1现在持有锁之后\",{\"1\":{\"1145\":1}}],[\"线程1卡顿\",{\"1\":{\"1143\":1}}],[\"线程1反应过来\",{\"1\":{\"1143\":1}}],[\"线程1再执行更新动作时\",{\"1\":{\"1121\":1}}],[\"线程读取过程中不需要等待\",{\"1\":{\"1126\":1}}],[\"线程去进行\",{\"1\":{\"1126\":1}}],[\"线程2进入到锁的内部执行逻辑\",{\"1\":{\"1143\":1}}],[\"线程2来尝试获得锁\",{\"1\":{\"1143\":1}}],[\"线程2\",{\"1\":{\"1135\":1}}],[\"线程2也去查询库存\",{\"1\":{\"1135\":1}}],[\"线程2获得到锁\",{\"1\":{\"1126\":1}}],[\"线程2在执行过程中\",{\"1\":{\"1126\":1}}],[\"线程4同时过来访问当前这个方法\",{\"1\":{\"1126\":1}}],[\"线程3也直接返回数据\",{\"1\":{\"1126\":1}}],[\"线程3\",{\"1\":{\"1126\":1}}],[\"线程会找到用户想要访问的工程\",{\"1\":{\"1100\":1}}],[\"线程仅能处理一个\",{\"1\":{\"866\":1}}],[\"线程上下文切换成本高\",{\"1\":{\"864\":1}}],[\"线程上执行\",{\"1\":{\"740\":1}}],[\"线程需要等待结果\",{\"1\":{\"856\":1}}],[\"线程自己不去获取结果\",{\"1\":{\"851\":1}}],[\"线程自己去获取结果\",{\"1\":{\"851\":1}}],[\"线程才会恢复运行\",{\"1\":{\"840\":1}}],[\"线程阻塞\",{\"1\":{\"840\":1}}],[\"线程大部分时间都在做无用功\",{\"1\":{\"828\":1}}],[\"线程仍然会继续运行\",{\"1\":{\"827\":1}}],[\"线程仍然在不断运行\",{\"1\":{\"827\":1}}],[\"线程还会继续运行\",{\"1\":{\"827\":1}}],[\"线程实际还是阻塞的\",{\"1\":{\"827\":1}}],[\"线程只是等待数据写入\",{\"1\":{\"827\":1}}],[\"线程停止运行\",{\"1\":{\"826\":2}}],[\"线程连接建立好之后\",{\"1\":{\"753\":1}}],[\"线程被打断\",{\"1\":{\"742\":1}}],[\"线程唤醒\",{\"1\":{\"742\":1}}],[\"线程调用\",{\"1\":{\"742\":1}}],[\"线程来调用\",{\"1\":{\"742\":1}}],[\"线程抢先将\",{\"1\":{\"741\":1}}],[\"线程和提交任务线程都有可能执行\",{\"1\":{\"741\":1}}],[\"线程执行接下来的操作\",{\"1\":{\"740\":1}}],[\"线程间的依赖顺序是一件非常麻烦的事情\",{\"1\":{\"716\":1}}],[\"线程间并发\",{\"1\":{\"163\":1}}],[\"线程持有的锁\",{\"1\":{\"631\":1}}],[\"线程不必等待结果\",{\"1\":{\"856\":1}}],[\"线程不仅要处理\",{\"1\":{\"741\":1}}],[\"线程不被回收\",{\"1\":{\"577\":1}}],[\"线程不安全\",{\"1\":{\"66\":2}}],[\"线程个数始终为1\",{\"1\":{\"574\":1}}],[\"线程数固定为\",{\"1\":{\"574\":1}}],[\"线程工厂\",{\"1\":{\"572\":1}}],[\"线程池版缺点⚠️\",{\"0\":{\"866\":1}}],[\"线程池版设计\",{\"0\":{\"865\":1}}],[\"线程池创建多少线程合适\",{\"0\":{\"576\":1}}],[\"线程池状态\",{\"0\":{\"571\":1}}],[\"线程池的好处\",{\"0\":{\"570\":1}}],[\"线程池\",{\"0\":{\"569\":1},\"1\":{\"757\":1,\"784\":1}}],[\"线程池以及字符串连接池都运用了享元模式的思想\",{\"1\":{\"568\":1}}],[\"线程交替输出\",{\"0\":{\"555\":1}}],[\"线程已经拥有了至少一种资\",{\"1\":{\"551\":1}}],[\"线程刚被创建\",{\"1\":{\"538\":1}}],[\"线程状态\",{\"0\":{\"538\":1}}],[\"线程休眠\",{\"1\":{\"536\":1}}],[\"线程优先级\",{\"0\":{\"535\":1}}],[\"线程启动后自动调用\",{\"1\":{\"532\":1}}],[\"线程切换由操作系统内核完成\",{\"1\":{\"163\":1}}],[\"线程切换可以在用户态下完成\",{\"1\":{\"163\":1}}],[\"线程管理的系统开销小\",{\"1\":{\"163\":1}}],[\"线程的切换\",{\"1\":{\"740\":1,\"743\":1}}],[\"线程的方法\",{\"1\":{\"565\":1}}],[\"线程的状态\",{\"1\":{\"538\":1}}],[\"线程的状态转换\",{\"1\":{\"538\":1}}],[\"线程的管理工作是操作系统内核完成\",{\"1\":{\"163\":1}}],[\"线程的实现方式\",{\"1\":{\"163\":1}}],[\"线程的属性\",{\"1\":{\"163\":1}}],[\"线程几乎不拥有系统资源\",{\"1\":{\"163\":1}}],[\"线程也有就绪\",{\"1\":{\"163\":1}}],[\"线程控制块\",{\"1\":{\"163\":1}}],[\"线程是稀缺资源\",{\"1\":{\"570\":1}}],[\"线程是处理机调度的单位\",{\"1\":{\"163\":1}}],[\"线程是调度的基本单位\",{\"1\":{\"163\":1}}],[\"线程是一个基本的cpu执行单位\",{\"1\":{\"163\":1}}],[\"线程是程序执行流的最小单位\",{\"1\":{\"163\":1}}],[\"线程概念\",{\"1\":{\"163\":1}}],[\"线程\",{\"0\":{\"163\":1},\"1\":{\"549\":1,\"702\":1,\"737\":1,\"740\":3,\"741\":1,\"742\":1,\"743\":2}}],[\"线程安全问题\",{\"1\":{\"66\":1}}],[\"线程安全\",{\"1\":{\"66\":2}}],[\"迅速激活这个文件描述符\",{\"1\":{\"680\":1}}],[\"水平触发和边缘触发\",{\"1\":{\"680\":1}}],[\"水平触发\",{\"1\":{\"680\":1}}],[\"套接字描述符\",{\"1\":{\"679\":1}}],[\"套娃\",{\"1\":{\"186\":1}}],[\"监控功能\",{\"1\":{\"1045\":1}}],[\"监控所有任务运行状态\",{\"1\":{\"947\":1}}],[\"监控\",{\"1\":{\"945\":1}}],[\"监控器运行中\",{\"1\":{\"536\":1}}],[\"监督程序的执行情况\",{\"1\":{\"944\":1}}],[\"监听器发送通知\",{\"1\":{\"1522\":1}}],[\"监听器会统一转换为\",{\"1\":{\"1497\":1}}],[\"监听的端口\",{\"1\":{\"1196\":1}}],[\"监听所有\",{\"1\":{\"843\":1}}],[\"监听\",{\"0\":{\"832\":1}}],[\"监视容器的资源使用情况\",{\"1\":{\"944\":1}}],[\"监视和管理namenode健康状态\",{\"1\":{\"885\":1}}],[\"监视\",{\"1\":{\"679\":1}}],[\"寄存器\",{\"1\":{\"676\":2}}],[\"虽说如此\",{\"1\":{\"667\":1}}],[\"虽然spring执行不报错\",{\"1\":{\"1230\":1}}],[\"虽然我们采用了\",{\"1\":{\"1149\":1}}],[\"虽然我们会对各个收集器进行比较\",{\"1\":{\"638\":1}}],[\"虽然后续的spark\",{\"1\":{\"1055\":1}}],[\"虽然可以设置reduce的并行度\",{\"1\":{\"988\":1}}],[\"虽然可以提供给多个进程使用\",{\"1\":{\"155\":1}}],[\"虽然有文件\",{\"1\":{\"883\":1}}],[\"虽然有channel对象\",{\"1\":{\"753\":1}}],[\"虽然连接数有上限\",{\"1\":{\"680\":1}}],[\"虽然压缩列表紧凑型的内存布局能节省内存开销\",{\"1\":{\"667\":1}}],[\"虽然\",{\"1\":{\"663\":1}}],[\"虽然reids是c语言编写的\",{\"1\":{\"515\":1}}],[\"虽然数据仓库存储数据规模大\",{\"1\":{\"222\":1}}],[\"虽然算法性能好\",{\"1\":{\"191\":1}}],[\"虽然它不强制要求所有的子类必须遵循这些契约\",{\"1\":{\"73\":1}}],[\"推断主启动类\",{\"1\":{\"1444\":1}}],[\"推断应用类型\",{\"1\":{\"1444\":1}}],[\"推送\",{\"1\":{\"1167\":1}}],[\"推送笔记id给所有粉丝\",{\"1\":{\"1167\":1}}],[\"推送到粉丝的收件箱\",{\"1\":{\"1167\":1}}],[\"推送到粉丝收件箱\",{\"0\":{\"1167\":1}}],[\"推送用户感兴趣信息来吸引用户\",{\"1\":{\"1166\":1}}],[\"推拉模式是一个折中的方案\",{\"1\":{\"1166\":1}}],[\"推拉结合模式\",{\"1\":{\"1166\":1}}],[\"推拉结合\",{\"1\":{\"1166\":1}}],[\"推模式是没有写邮箱的\",{\"1\":{\"1166\":1}}],[\"推模式\",{\"1\":{\"1166\":2}}],[\"推动了第二张牌倒下\",{\"1\":{\"666\":1}}],[\"推荐的主键设计\",{\"0\":{\"502\":1}}],[\"推荐受用具体字段查询\",{\"1\":{\"498\":1}}],[\"推荐\",{\"1\":{\"369\":1,\"480\":5,\"481\":6,\"482\":1,\"483\":1,\"728\":1}}],[\"推荐使用\",{\"1\":{\"1513\":1}}],[\"推荐使用生产5000w消息\",{\"1\":{\"1021\":1}}],[\"推荐使用增长的数值类型值作为主键来说不适合\",{\"1\":{\"997\":1}}],[\"推荐使用uuid\",{\"1\":{\"502\":1}}],[\"推荐使用orc文件格式中的索引\",{\"1\":{\"419\":1}}],[\"推荐使用物化视图和列式存储文件格式来加快查询的速度\",{\"1\":{\"274\":1}}],[\"推荐使用mysql\",{\"1\":{\"243\":1,\"244\":1}}],[\"了不起的我\",{\"1\":{\"1525\":1}}],[\"了它的功能\",{\"1\":{\"1243\":1}}],[\"了\",{\"1\":{\"665\":1,\"666\":1,\"775\":1,\"1141\":1}}],[\"了解到软件\",{\"1\":{\"1019\":1}}],[\"了解\",{\"1\":{\"473\":1,\"1485\":2}}],[\"了解即可\",{\"1\":{\"228\":1}}],[\"十进制255\",{\"1\":{\"665\":1}}],[\"十进制表示\",{\"1\":{\"353\":1}}],[\"尾部\",{\"1\":{\"665\":1}}],[\"翻倍扩容\",{\"1\":{\"663\":1}}],[\"翻炒是一样的\",{\"1\":{\"85\":1}}],[\"翻炒\",{\"1\":{\"85\":1}}],[\"翻炒等步骤\",{\"1\":{\"85\":1}}],[\"稍微一不注意\",{\"1\":{\"662\":1}}],[\"视频中未讲解\",{\"1\":{\"1497\":1}}],[\"视频文化这样的二进制数据\",{\"1\":{\"662\":1}}],[\"视情况而定\",{\"1\":{\"680\":1}}],[\"视图名固定为\",{\"1\":{\"1436\":1}}],[\"视图的目的是简化降低查询语句的复杂度\",{\"1\":{\"275\":1}}],[\"视图的相关语法\",{\"0\":{\"271\":1}}],[\"视图的相关概念\",{\"0\":{\"270\":1}}],[\"视图是虚拟的\",{\"1\":{\"275\":1}}],[\"视图是用来简化操作的\",{\"1\":{\"270\":1}}],[\"视图插入演示\",{\"1\":{\"271\":1}}],[\"视图不能进行修改操作\",{\"1\":{\"270\":1}}],[\"视图\",{\"0\":{\"269\":1},\"1\":{\"318\":1,\"1441\":1,\"1528\":1}}],[\"音频\",{\"1\":{\"662\":1}}],[\"肯定没有第一台服务器存放的session\",{\"1\":{\"1102\":1}}],[\"肯定是\",{\"1\":{\"661\":1}}],[\"肯定会出现数据倾斜的现象\",{\"1\":{\"463\":1}}],[\"邮箱的垃圾邮件过滤\",{\"1\":{\"660\":1}}],[\"综合\",{\"1\":{\"1368\":1}}],[\"综合考虑使用方案一\",{\"1\":{\"1121\":1}}],[\"综合考虑了等待时间和运行时间\",{\"1\":{\"167\":1}}],[\"综合考虑作业\",{\"1\":{\"167\":1}}],[\"综上\",{\"1\":{\"659\":1,\"1168\":1}}],[\"≈\",{\"1\":{\"658\":1}}],[\"年左右\",{\"1\":{\"1177\":1}}],[\"年关将至\",{\"1\":{\"709\":1}}],[\"年提出的\",{\"1\":{\"658\":1}}],[\"年龄区间\",{\"1\":{\"480\":1}}],[\"思路\",{\"1\":{\"1175\":1}}],[\"思路分析\",{\"1\":{\"988\":1,\"990\":1,\"1128\":1}}],[\"思考注释中两个问题\",{\"1\":{\"839\":1}}],[\"思考\",{\"1\":{\"794\":3}}],[\"思考下面的场景\",{\"1\":{\"755\":1}}],[\"思否\",{\"1\":{\"651\":2}}],[\"思想\",{\"1\":{\"181\":1}}],[\"彻底弄清post和get请求的区别\",{\"1\":{\"651\":1}}],[\"彻底和对象解耦\",{\"1\":{\"25\":1}}],[\"件物品\",{\"1\":{\"649\":2}}],[\"件物品的情况\",{\"1\":{\"649\":4}}],[\"递减更新的话前面是旧值\",{\"1\":{\"648\":1}}],[\"递增\",{\"1\":{\"363\":1}}],[\"求差集\",{\"1\":{\"1211\":1}}],[\"求s1与s2的不同\",{\"1\":{\"1210\":1}}],[\"求交集\",{\"1\":{\"1210\":1}}],[\"求key1和key2的并集\",{\"1\":{\"1210\":1}}],[\"求key1与key2的差集\",{\"1\":{\"1210\":1}}],[\"求key1与key2的交集\",{\"1\":{\"1210\":1}}],[\"求第\",{\"1\":{\"648\":1}}],[\"求出每个用户截止到当天\",{\"1\":{\"360\":1}}],[\"求出每个用户总pv数\",{\"1\":{\"360\":1}}],[\"求出每个用户的pv数\",{\"1\":{\"360\":1}}],[\"求出网站总的pv数\",{\"1\":{\"360\":1}}],[\"价值\",{\"1\":{\"648\":2}}],[\"背压可以理解为订阅者能和发布者交互\",{\"1\":{\"719\":1}}],[\"背压\",{\"0\":{\"719\":1}}],[\"背包体积\",{\"1\":{\"648\":1}}],[\"背包问题开始讲起吧\",{\"1\":{\"648\":1}}],[\"背包问题\",{\"1\":{\"648\":1,\"649\":1}}],[\"背包\",{\"0\":{\"647\":1},\"1\":{\"649\":1}}],[\"背景知识\",{\"0\":{\"882\":1}}],[\"背景\",{\"0\":{\"452\":1,\"455\":1,\"997\":1}}],[\"埃氏筛\",{\"0\":{\"646\":1}}],[\"青色虚线\",{\"1\":{\"638\":1}}],[\"弃用parallel\",{\"1\":{\"638\":1}}],[\"绿色虚线\",{\"1\":{\"638\":1}}],[\"串行回收器\",{\"1\":{\"638\":1}}],[\"快照重命名\",{\"1\":{\"914\":1}}],[\"快照功能的命令实现\",{\"0\":{\"914\":1}}],[\"快照功能的理论实现\",{\"0\":{\"913\":1}}],[\"快照的作用\",{\"0\":{\"912\":1}}],[\"快照\",{\"1\":{\"911\":1}}],[\"快排\",{\"0\":{\"645\":1}}],[\"快速完成映射\",{\"1\":{\"1355\":1}}],[\"快速入门\",{\"0\":{\"1150\":1,\"1218\":1}}],[\"快速\",{\"1\":{\"637\":1}}],[\"快表的作用和缓存很类似\",{\"1\":{\"683\":1}}],[\"快表解决\",{\"1\":{\"683\":1}}],[\"快表和多级页表\",{\"1\":{\"683\":1}}],[\"快表\",{\"1\":{\"185\":1,\"683\":2}}],[\"吞吐量的补数\",{\"1\":{\"637\":1}}],[\"吞吐量\",{\"1\":{\"637\":3,\"840\":1,\"1019\":1,\"1066\":1,\"1067\":1}}],[\"造成这个问题的原因是\",{\"1\":{\"1161\":1}}],[\"造成该分区的消息数量远大于其他的分区\",{\"1\":{\"1034\":1}}],[\"造成内存资源的严重浪费\",{\"1\":{\"689\":1}}],[\"造成访问压缩列表性能的下降\",{\"1\":{\"666\":1}}],[\"造成系统吞吐量的下降\",{\"1\":{\"634\":1}}],[\"造者模式所创建的产品一般具有较多的共同点\",{\"1\":{\"15\":1}}],[\"知识小扩展\",{\"1\":{\"1136\":1}}],[\"知识小贴士\",{\"1\":{\"1132\":1}}],[\"知识点\",{\"1\":{\"112\":1,\"113\":1}}],[\"知道设备就绪或者主动超时\",{\"1\":{\"680\":1}}],[\"知道垃圾收集完成\",{\"1\":{\"634\":1}}],[\"讲一讲垃圾回收算法\",{\"1\":{\"633\":1}}],[\"讲解gan精巧的自监督对抗学习范式背后的算法和数学原理\",{\"1\":{\"124\":1}}],[\"流逝\",{\"1\":{\"1525\":1}}],[\"流的滚动分页\",{\"1\":{\"1167\":1}}],[\"流是不适用的\",{\"1\":{\"1167\":1}}],[\"流中的数据会不断更新\",{\"1\":{\"1167\":1}}],[\"流采用推模式\",{\"1\":{\"1167\":1}}],[\"流量削峰\",{\"1\":{\"1009\":1}}],[\"流程中的异常\",{\"1\":{\"1411\":1}}],[\"流程如下图\",{\"1\":{\"1005\":1}}],[\"流程如上图所示\",{\"1\":{\"679\":2}}],[\"流程梳理\",{\"0\":{\"786\":1}}],[\"流程\",{\"1\":{\"633\":1,\"1254\":1,\"1411\":3}}],[\"流式文件\",{\"1\":{\"195\":1}}],[\"京东\",{\"1\":{\"633\":1}}],[\"滴滴\",{\"1\":{\"633\":1}}],[\"垃圾收集器组合关系\",{\"1\":{\"638\":1}}],[\"垃圾收集所用时间与总运行时间的比例\",{\"1\":{\"637\":1}}],[\"垃圾收集开销\",{\"1\":{\"637\":1}}],[\"垃圾收集线程只收集一小片区域的内存空间\",{\"1\":{\"634\":1}}],[\"垃圾收集策略和算法\",{\"1\":{\"633\":1}}],[\"垃圾回收的影响\",{\"1\":{\"855\":1}}],[\"垃圾回收的管理\",{\"1\":{\"769\":1}}],[\"垃圾回收\",{\"1\":{\"775\":1}}],[\"垃圾回收器的选择\",{\"0\":{\"639\":1}}],[\"垃圾回收器就是一个守护线程\",{\"1\":{\"537\":1}}],[\"垃圾回收算法的实现原理\",{\"1\":{\"633\":1}}],[\"垃圾回收算法有哪些\",{\"1\":{\"633\":1}}],[\"蚂蚁金服\",{\"1\":{\"633\":1}}],[\"拼接key\",{\"1\":{\"1165\":1,\"1175\":1,\"1176\":1}}],[\"拼接点赞key\",{\"1\":{\"1161\":1}}],[\"拼接并返回\",{\"1\":{\"1132\":1}}],[\"拼接前后\",{\"1\":{\"632\":1}}],[\"拼凑\",{\"1\":{\"182\":1}}],[\"权限\",{\"1\":{\"905\":1}}],[\"权限没有要求\",{\"1\":{\"629\":1}}],[\"权限必须是public\",{\"1\":{\"629\":1}}],[\"混合收集\",{\"1\":{\"628\":1}}],[\"混合索引\",{\"1\":{\"197\":1}}],[\"老大\",{\"1\":{\"944\":1}}],[\"老年代收集器\",{\"1\":{\"638\":1}}],[\"老年代收集\",{\"1\":{\"628\":1}}],[\"老年代\",{\"1\":{\"628\":1}}],[\"老版本keras\",{\"1\":{\"128\":1}}],[\"逃逸分析\",{\"1\":{\"627\":1}}],[\"栈大小分为固定的\",{\"1\":{\"626\":1}}],[\"举例来说\",{\"1\":{\"1521\":1}}],[\"举例栈溢出的情况\",{\"0\":{\"626\":1}}],[\"举个例子\",{\"1\":{\"662\":2,\"663\":1,\"1113\":1,\"1167\":1}}],[\"举个简单的例子\",{\"1\":{\"659\":1}}],[\"举个hashset插入对象的例子\",{\"1\":{\"596\":1}}],[\"沙箱安全机制\",{\"0\":{\"624\":1}}],[\"沙发\",{\"1\":{\"147\":1}}],[\"倘若父类加载器无法完成此加载任务\",{\"1\":{\"623\":1}}],[\"映射器与适配器小结\",{\"0\":{\"1437\":1}}],[\"映射欢迎页\",{\"1\":{\"1436\":1}}],[\"映射路径\",{\"1\":{\"1430\":1}}],[\"映射信息\",{\"1\":{\"1355\":1}}],[\"映射\",{\"0\":{\"617\":1,\"1065\":1},\"1\":{\"1352\":1}}],[\"筛选时会考虑\",{\"1\":{\"1482\":1}}],[\"筛选\",{\"1\":{\"616\":1}}],[\"筛选与切片\",{\"0\":{\"616\":1}}],[\"返同一个扔了前n个元素的流\",{\"1\":{\"616\":1}}],[\"返回json或xml形式数据\",{\"1\":{\"1525\":1}}],[\"返回json格式的执行计划\",{\"1\":{\"441\":1}}],[\"返回不为null\",{\"1\":{\"1505\":1}}],[\"返回set中元素的个数\",{\"1\":{\"1210\":1}}],[\"返回shop信息\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"返回目前的age的值\",{\"1\":{\"1206\":1}}],[\"返回空\",{\"1\":{\"1165\":1}}],[\"返回查询结果\",{\"1\":{\"1161\":1,\"1164\":1,\"1165\":1}}],[\"返回id\",{\"1\":{\"1159\":1,\"1167\":1}}],[\"返回2\",{\"1\":{\"1156\":1}}],[\"返回了1\",{\"1\":{\"1141\":1}}],[\"返回订单id\",{\"1\":{\"1137\":2,\"1157\":1}}],[\"返回错误\",{\"1\":{\"1129\":1}}],[\"返回错误信息\",{\"1\":{\"1099\":2,\"1107\":1,\"1129\":1,\"1142\":1,\"1150\":1,\"1157\":1}}],[\"返回过期的商铺信息\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"返回1\",{\"1\":{\"1127\":1,\"1156\":1}}],[\"返回数据\",{\"1\":{\"1127\":1,\"1172\":1}}],[\"返回token\",{\"1\":{\"1107\":1}}],[\"返回true即拼接否则不拼接\",{\"1\":{\"1234\":1}}],[\"返回true\",{\"1\":{\"69\":1,\"585\":1}}],[\"返回401状态码\",{\"1\":{\"1100\":1}}],[\"返回ok\",{\"1\":{\"1099\":1}}],[\"返回给producer\",{\"1\":{\"1051\":1}}],[\"返回成功\",{\"1\":{\"1043\":1}}],[\"返回<k\",{\"1\":{\"985\":1}}],[\"返回<key\",{\"1\":{\"979\":1}}],[\"返回的\",{\"1\":{\"1464\":1}}],[\"返回的是一个十进制的数字\",{\"1\":{\"1176\":1}}],[\"返回的是锁的失效时间\",{\"1\":{\"1152\":1}}],[\"返回的数据是\",{\"1\":{\"1176\":1}}],[\"返回的都是脏数据\",{\"1\":{\"1126\":1}}],[\"返回的资源便是用\",{\"1\":{\"948\":1}}],[\"返回的也是一个抽象的产品\",{\"1\":{\"23\":1}}],[\"返回fsdataoutputstream输出流对象给客户端用于写数据\",{\"1\":{\"901\":1}}],[\"返回null保持原有对象不变\",{\"1\":{\"1505\":1}}],[\"返回null\",{\"1\":{\"756\":1}}],[\"返回n行\",{\"1\":{\"481\":1}}],[\"返回值省略\",{\"1\":{\"1394\":1}}],[\"返回值添加了\",{\"1\":{\"1394\":2}}],[\"返回值类型为\",{\"1\":{\"1394\":3}}],[\"返回值类型为boolean类型\",{\"1\":{\"84\":1}}],[\"返回值处理器体现了组合模式\",{\"1\":{\"1437\":1}}],[\"返回值处理器\",{\"0\":{\"1391\":1},\"1\":{\"1406\":1,\"1438\":2}}],[\"返回值数据class类型\",{\"1\":{\"1129\":1}}],[\"返回值数据类型\",{\"1\":{\"1129\":2}}],[\"返回值class类型\",{\"1\":{\"1129\":1}}],[\"返回值表示读到了多少字节\",{\"1\":{\"814\":1}}],[\"返回值\",{\"1\":{\"733\":1}}],[\"返回响应体前包装\",{\"1\":{\"1402\":1}}],[\"返回响应\",{\"1\":{\"711\":1}}],[\"返回流中最小值\",{\"1\":{\"619\":1}}],[\"返回流中最大值\",{\"1\":{\"619\":1}}],[\"返回流中元泰的总个数\",{\"1\":{\"619\":1}}],[\"返回当前流中的任意元素\",{\"1\":{\"619\":1}}],[\"返回第一个元素\",{\"1\":{\"619\":1}}],[\"返回第一个不为空的值\",{\"1\":{\"351\":1}}],[\"返回为4\",{\"1\":{\"482\":1}}],[\"返回为12\",{\"1\":{\"482\":1}}],[\"返回字符串的hash编码\",{\"1\":{\"342\":1}}],[\"返回参数中的第一个非空值\",{\"1\":{\"340\":1}}],[\"返回一段角标范围内的所有元素\",{\"1\":{\"1209\":1}}],[\"返回一个错误信息\",{\"1\":{\"1129\":1}}],[\"返回一个0到1范围内的随机数\",{\"1\":{\"338\":1}}],[\"返回一条一条kv键值对记录\",{\"1\":{\"250\":1}}],[\"返回double类型的整数值部分\",{\"1\":{\"338\":1}}],[\"返回指定member的坐标\",{\"1\":{\"1170\":1}}],[\"返回指定精度d的double类型\",{\"1\":{\"338\":1}}],[\"返回指定日期所示年份第几周\",{\"1\":{\"337\":1}}],[\"返回指定个数空格\",{\"1\":{\"336\":1}}],[\"返回结果\",{\"1\":{\"734\":1,\"1151\":2,\"1159\":1}}],[\"返回结果的行数等于两个表行数的乘积\",{\"1\":{\"325\":1}}],[\"返回结果集前n条limit\",{\"1\":{\"309\":1}}],[\"返回所有匹配的行\",{\"1\":{\"303\":2}}],[\"返回原进程继续往下执行\",{\"1\":{\"157\":1}}],[\"返回进程对象\",{\"1\":{\"70\":1}}],[\"返回\",{\"1\":{\"70\":2,\"562\":10,\"744\":1,\"827\":1,\"1122\":1,\"1129\":1,\"1146\":1,\"1152\":1,\"1162\":1,\"1165\":1,\"1172\":1,\"1222\":1}}],[\"截取\",{\"1\":{\"1172\":1}}],[\"截断流\",{\"1\":{\"616\":1}}],[\"截止到当前行\",{\"1\":{\"365\":2}}],[\"田七\",{\"1\":{\"615\":2}}],[\"赵六\",{\"1\":{\"615\":1,\"1210\":1}}],[\"王五\",{\"1\":{\"615\":1,\"1210\":2}}],[\"王者荣耀\",{\"1\":{\"260\":1}}],[\"断开连接自动释放\",{\"1\":{\"1140\":1}}],[\"断开连接\",{\"1\":{\"1140\":1}}],[\"断开原来的head节点\",{\"1\":{\"591\":1}}],[\"断点类型加以区分\",{\"1\":{\"740\":1}}],[\"断点2\",{\"1\":{\"725\":1}}],[\"断点1\",{\"1\":{\"725\":1}}],[\"断言型接口\",{\"1\":{\"614\":1}}],[\"供大家参考\",{\"1\":{\"1245\":1}}],[\"供后续使用\",{\"1\":{\"976\":1}}],[\"供给型接口\",{\"1\":{\"614\":1}}],[\"供子类实现\",{\"1\":{\"87\":1}}],[\"声明式事务\",{\"1\":{\"1513\":1}}],[\"声明了\",{\"1\":{\"663\":1}}],[\"声明类\",{\"1\":{\"614\":1}}],[\"声明函数式接口\",{\"1\":{\"614\":1}}],[\"声明版本\",{\"1\":{\"99\":1}}],[\"充分调用os参与并发操作\",{\"1\":{\"612\":1}}],[\"决定用户是否抢购成功\",{\"1\":{\"1156\":1}}],[\"决定系统中所有应用程序之间资源分配的最终权限\",{\"1\":{\"944\":1}}],[\"决定\",{\"1\":{\"731\":1,\"744\":1}}],[\"决定入站缓冲区的大小\",{\"1\":{\"731\":1}}],[\"决定的\",{\"1\":{\"610\":1}}],[\"决定hash表的最大填满程度\",{\"1\":{\"606\":1}}],[\"决定抽样的比例\",{\"1\":{\"369\":1}}],[\"尺寸\",{\"1\":{\"606\":1}}],[\"拆箱\",{\"1\":{\"599\":1}}],[\"强调的是所属关系\",{\"1\":{\"595\":1}}],[\"强制性\",{\"1\":{\"1514\":1}}],[\"强制目录采用3x复制方案\",{\"1\":{\"875\":1}}],[\"强制写入\",{\"0\":{\"819\":1}}],[\"强制\",{\"1\":{\"480\":9,\"481\":4,\"482\":8,\"483\":7,\"493\":1}}],[\"强制撤销部分\",{\"1\":{\"178\":1}}],[\"竞争成功\",{\"1\":{\"591\":1}}],[\"竞争的时候是非公平的\",{\"1\":{\"541\":1}}],[\"乐观读\",{\"1\":{\"590\":2}}],[\"乐观锁解决超卖问题\",{\"0\":{\"1136\":1}}],[\"乐观锁的典型代表\",{\"1\":{\"1135\":1}}],[\"乐观锁的时间戳机制\",{\"1\":{\"507\":1}}],[\"乐观锁的版本号机制\",{\"1\":{\"507\":1}}],[\"乐观锁也是一种思想\",{\"1\":{\"507\":1}}],[\"乐观锁\",{\"1\":{\"507\":1,\"1135\":2}}],[\"戳\",{\"1\":{\"590\":1}}],[\"尝试一次\",{\"1\":{\"1141\":1}}],[\"尝试释放被丢弃对象占用的内存\",{\"1\":{\"635\":1}}],[\"尝试释放锁\",{\"1\":{\"585\":2}}],[\"尝试获取锁\",{\"1\":{\"585\":2,\"1142\":2,\"1150\":2,\"1157\":1}}],[\"象棋中的一个cell累加计数\",{\"1\":{\"579\":1}}],[\"追加字符串函数\",{\"1\":{\"663\":1}}],[\"追加至链表尾\",{\"1\":{\"579\":1}}],[\"追求的是最低的缺页率\",{\"1\":{\"191\":1}}],[\"追求最少的平均等待时间\",{\"1\":{\"167\":1}}],[\"核数\",{\"1\":{\"576\":1}}],[\"核心模块\",{\"1\":{\"1499\":1}}],[\"核心对象\",{\"1\":{\"1455\":1}}],[\"核心的意思\",{\"1\":{\"1167\":1}}],[\"核心的思想是尽量避免reduce\",{\"1\":{\"467\":1}}],[\"核心逻辑\",{\"1\":{\"1144\":1}}],[\"核心思路就是利用redis的setnx方法来表示获取锁\",{\"1\":{\"1127\":1}}],[\"核心思路\",{\"1\":{\"1127\":1,\"1141\":1}}],[\"核心思路如下\",{\"1\":{\"1122\":1,\"1124\":1}}],[\"核心思路分析\",{\"1\":{\"1102\":1}}],[\"核心cpu\",{\"1\":{\"1094\":1}}],[\"核心算法\",{\"1\":{\"999\":1}}],[\"核心交互流程\",{\"0\":{\"942\":1}}],[\"核心数的线程\",{\"1\":{\"846\":1}}],[\"核心代码如下\",{\"1\":{\"723\":1}}],[\"核心线程数\",{\"1\":{\"572\":1,\"574\":1}}],[\"核心部分是counter\",{\"1\":{\"549\":1}}],[\"核心语法就是insert+select\",{\"1\":{\"261\":1}}],[\"核心态\",{\"1\":{\"156\":1,\"157\":2}}],[\"希望大家在学习过程中\",{\"1\":{\"1152\":1}}],[\"希望尽可能发送足够大的数据\",{\"1\":{\"694\":1}}],[\"希望多个任务排队执行\",{\"1\":{\"574\":1}}],[\"希捷硬盘类\",{\"1\":{\"74\":1}}],[\"丢弃队列最前面的任务\",{\"1\":{\"573\":1}}],[\"丢弃任务\",{\"1\":{\"573\":1}}],[\"丢弃该任务并抛出rejectedexecutionexception异常\",{\"1\":{\"573\":1}}],[\"拒绝策略\",{\"0\":{\"573\":1},\"1\":{\"572\":1}}],[\"救急线程空闲时的最大空闲时间\",{\"1\":{\"572\":1}}],[\"救急线程在没有空闲核心线程和任务队列满了的情况下才会创建使用\",{\"1\":{\"572\":1}}],[\"救急线程数\",{\"1\":{\"572\":1}}],[\"终结状态\",{\"1\":{\"571\":1}}],[\"终止状态\",{\"1\":{\"538\":1}}],[\"终止线程执行\",{\"1\":{\"536\":1}}],[\"终止态\",{\"1\":{\"160\":1}}],[\"活跃\",{\"1\":{\"680\":1}}],[\"活动线程为0时\",{\"1\":{\"571\":1}}],[\"活锁是因为线程间修改了对方的结束条件\",{\"1\":{\"552\":1}}],[\"活锁出现在两个线程\",{\"1\":{\"552\":1}}],[\"活锁\",{\"0\":{\"550\":1,\"552\":1}}],[\"低延迟\",{\"1\":{\"1190\":1}}],[\"低版本在安装时会报错\",{\"1\":{\"876\":1}}],[\"低16为存储互斥锁状态\",{\"1\":{\"582\":1}}],[\"低\",{\"1\":{\"571\":1}}],[\"低级调度的时间\",{\"1\":{\"166\":1}}],[\"低级调度\",{\"1\":{\"164\":1}}],[\"享元模式简单理解就是重用数量有限的同一对象\",{\"1\":{\"568\":1}}],[\"享元模式\",{\"0\":{\"568\":1}}],[\"构成\",{\"1\":{\"875\":1}}],[\"构造方法注入\",{\"1\":{\"1500\":1}}],[\"构造方法中所做的操作\",{\"1\":{\"1446\":1}}],[\"构造\",{\"1\":{\"1257\":1,\"1444\":1,\"1445\":1}}],[\"构造函数省略\",{\"1\":{\"985\":1}}],[\"构造函数\",{\"1\":{\"972\":1}}],[\"构造函数传入的count值最终都会赋值给state\",{\"1\":{\"592\":1}}],[\"构造job对象实例\",{\"1\":{\"962\":1}}],[\"构造消息对象\",{\"1\":{\"702\":1}}],[\"构造时设置计数个数\",{\"1\":{\"593\":1}}],[\"构造器分析\",{\"1\":{\"579\":1}}],[\"构造新字符串对象时\",{\"1\":{\"566\":1}}],[\"构建数据\",{\"1\":{\"1073\":1}}],[\"构建job作业的实例\",{\"1\":{\"962\":1}}],[\"构建表中列的数据的元数据信息\",{\"1\":{\"458\":1}}],[\"构建表中分区数据的元数据信息\",{\"1\":{\"458\":1}}],[\"构建\",{\"1\":{\"423\":1}}],[\"构建分桶表\",{\"1\":{\"417\":1}}],[\"构建公共粒度的汇总指标事实表\",{\"1\":{\"226\":1}}],[\"构建可复用的面向分析和统计的明细事实表\",{\"1\":{\"226\":1}}],[\"构建和发布一组相关的项目\",{\"1\":{\"108\":1}}],[\"构建配置是在pom\",{\"1\":{\"102\":1}}],[\"构建不需要额外配置\",{\"1\":{\"102\":1}}],[\"构建项目时\",{\"1\":{\"101\":1}}],[\"构建概念和构建过程\",{\"0\":{\"94\":1}}],[\"构建管理\",{\"1\":{\"91\":1}}],[\"构建phone对象\",{\"1\":{\"17\":1}}],[\"做与运算就可以了\",{\"1\":{\"1176\":1}}],[\"做的\",{\"1\":{\"1398\":1}}],[\"做的经纬度位置去\",{\"1\":{\"1171\":1}}],[\"做的事就是将原生\",{\"1\":{\"740\":1}}],[\"做的事就是添加一个初始化器\",{\"1\":{\"740\":1}}],[\"做好热点参数的限流\",{\"1\":{\"1124\":1}}],[\"做好数据的基础格式校验\",{\"1\":{\"1124\":1}}],[\"做一个标记\",{\"1\":{\"804\":1}}],[\"做拒绝逻辑\",{\"1\":{\"741\":1}}],[\"做出了修改\",{\"1\":{\"566\":1}}],[\"做其他处理\",{\"1\":{\"168\":1}}],[\"懒惰初始化\",{\"1\":{\"564\":1}}],[\"懒汉式\",{\"1\":{\"66\":7}}],[\"懒汉式双重锁校验\",{\"1\":{\"22\":1}}],[\"懒汉式线程安全\",{\"1\":{\"22\":1}}],[\"懒汉式线程不安全\",{\"1\":{\"22\":1}}],[\"累加cell\",{\"1\":{\"564\":1}}],[\"累加\",{\"1\":{\"564\":1,\"620\":1}}],[\"累加单元数组\",{\"1\":{\"564\":1}}],[\"累计死亡案例数\",{\"1\":{\"972\":1}}],[\"累计死亡病例\",{\"1\":{\"265\":2,\"266\":1}}],[\"累计的总pv\",{\"1\":{\"360\":1}}],[\"累计确诊病例\",{\"1\":{\"265\":2,\"266\":1}}],[\"你只要添加spring\",{\"1\":{\"1521\":1}}],[\"你只要签到就打上一个勾\",{\"1\":{\"1174\":1}}],[\"你打算做个web应用程序\",{\"1\":{\"1521\":1}}],[\"你觉得时效性会非常重要\",{\"1\":{\"1155\":1}}],[\"你能发现有个\",{\"1\":{\"1152\":1}}],[\"你想一想\",{\"1\":{\"1147\":1}}],[\"你会发现在threadlocal中\",{\"1\":{\"1100\":1}}],[\"你的索引将会有1个主分片和另外1个复制分片\",{\"1\":{\"1067\":1}}],[\"你得指定对象的排序规则是什么\",{\"1\":{\"956\":1}}],[\"你所看到的数据其实是当前物理路径所指的内容\",{\"1\":{\"913\":1}}],[\"你好\",{\"1\":{\"805\":3,\"839\":1}}],[\"你来我往\",{\"1\":{\"709\":1}}],[\"你有什么要说的呢\",{\"1\":{\"709\":1}}],[\"你知道哪几种垃圾收集器\",{\"1\":{\"633\":1}}],[\"你知道哪几种垃圾回收器\",{\"1\":{\"633\":1}}],[\"你可以在任何时候动态地改变复制的数量\",{\"1\":{\"1067\":1}}],[\"你可以指定你想要的分片的数量\",{\"1\":{\"1066\":1}}],[\"你可以存储任意多的文档\",{\"1\":{\"1063\":1}}],[\"你可以拥有某一个客户的文档\",{\"1\":{\"1063\":1}}],[\"你可以定义一种或多种类型\",{\"1\":{\"1062\":1}}],[\"你可以有一个客户数据的索引\",{\"1\":{\"1061\":1}}],[\"你可以利用多线程提高它的利用率\",{\"1\":{\"576\":1}}],[\"你可以使用gan实现照片转成油画\",{\"1\":{\"124\":1}}],[\"你们才有机会\",{\"1\":{\"561\":1}}],[\"得知自己暗恋多年的校园男神裴之即将出国深造的消息\",{\"1\":{\"1525\":1}}],[\"得先来看看\",{\"1\":{\"661\":1}}],[\"得防着其他线程来修改共享变量\",{\"1\":{\"561\":1}}],[\"得到\",{\"1\":{\"1444\":1}}],[\"得到的结果是这样的\",{\"1\":{\"1222\":1}}],[\"得到的反馈是发送超时\",{\"1\":{\"707\":1}}],[\"得到了锁\",{\"1\":{\"1147\":1}}],[\"得到值之后判断位数组中的每个元素是否都为\",{\"1\":{\"659\":2}}],[\"得到哈希值\",{\"1\":{\"659\":1}}],[\"得到一个值\",{\"1\":{\"620\":1}}],[\"得到一个稳定的随机数序列\",{\"1\":{\"338\":1}}],[\"得到不正确的结果\",{\"1\":{\"480\":1}}],[\"~\",{\"1\":{\"809\":1,\"878\":1,\"879\":2,\"999\":3,\"1172\":1}}],[\"~selectionkey\",{\"1\":{\"742\":1}}],[\"~~\",{\"1\":{\"561\":1}}],[\"~junyanz\",{\"1\":{\"119\":1}}],[\"准生产级别\",{\"1\":{\"1520\":1}}],[\"准备容器\",{\"1\":{\"1444\":1}}],[\"准备参数\",{\"1\":{\"1438\":1}}],[\"准备对象绑定与类型转换\",{\"1\":{\"1362\":1}}],[\"准备\",{\"0\":{\"1381\":1,\"1388\":1,\"1408\":1},\"1\":{\"759\":1,\"1362\":1,\"1381\":1,\"1389\":1,\"1444\":1}}],[\"准备一个空\",{\"1\":{\"737\":1}}],[\"准备工作\",{\"0\":{\"733\":1}}],[\"准备数据绑定工厂\",{\"1\":{\"1438\":1}}],[\"准备数据\",{\"1\":{\"679\":1}}],[\"准备常量1\",{\"1\":{\"560\":1}}],[\"准确的\",{\"1\":{\"107\":1}}],[\"固定长度\",{\"0\":{\"697\":1}}],[\"固定值\",{\"1\":{\"665\":1}}],[\"固定线程运行顺序\",{\"0\":{\"554\":1}}],[\"固定分隔符\",{\"0\":{\"698\":1}}],[\"固定分配\",{\"1\":{\"192\":2}}],[\"固定分区分配分为两种\",{\"1\":{\"182\":1}}],[\"固定分区分配\",{\"1\":{\"182\":1}}],[\"却一直运行不完的现象\",{\"1\":{\"552\":1}}],[\"停止\",{\"1\":{\"1197\":1}}],[\"停止服务\",{\"1\":{\"1196\":1}}],[\"停止了\",{\"1\":{\"1037\":1}}],[\"停止任务\",{\"1\":{\"947\":1}}],[\"停止等各种请求\",{\"1\":{\"946\":1}}],[\"停止线程的运行\",{\"1\":{\"747\":1}}],[\"停止运行的现象\",{\"1\":{\"552\":1}}],[\"停车收费米表\",{\"1\":{\"147\":1}}],[\"源码分析\",{\"0\":{\"937\":1}}],[\"源码解析\",{\"1\":{\"69\":1}}],[\"源\",{\"1\":{\"551\":1,\"1444\":1}}],[\"唤醒下一个线程后如果发现该线程占有的是共享锁\",{\"1\":{\"583\":1}}],[\"唤醒\",{\"1\":{\"549\":1,\"702\":1,\"741\":1}}],[\"唤醒阻塞队列来竞争\",{\"1\":{\"542\":1}}],[\"满足\",{\"1\":{\"1144\":1}}],[\"满足分布式系统或集群模式下多进程可见并且互斥的锁\",{\"1\":{\"1140\":1}}],[\"满足下列需求\",{\"1\":{\"1129\":1}}],[\"满足下面的需求\",{\"1\":{\"1122\":1}}],[\"满足开闭原则\",{\"1\":{\"35\":1}}],[\"满时不会再加入数据\",{\"1\":{\"548\":1}}],[\"偏向时间戳\",{\"1\":{\"631\":1}}],[\"偏向线程id\",{\"1\":{\"631\":1}}],[\"偏向锁\",{\"0\":{\"544\":1}}],[\"偏移量\",{\"1\":{\"184\":1,\"1026\":1}}],[\"轻松扛下上万并发\",{\"1\":{\"1094\":1}}],[\"轻松工作\",{\"1\":{\"482\":2}}],[\"轻负载的hash表具有冲突少\",{\"1\":{\"606\":1}}],[\"轻量级锁\",{\"0\":{\"543\":1}}],[\"持久化等文件会保存在这个目录\",{\"1\":{\"1196\":1}}],[\"持久性和隔离性都是为了保证数据库状态的一致性\",{\"1\":{\"506\":1}}],[\"持久性实现原理\",{\"1\":{\"506\":1}}],[\"持久性\",{\"1\":{\"506\":1}}],[\"持有锁的线程在锁的内部出现了阻塞\",{\"1\":{\"1143\":1}}],[\"持锁线程执行完synchronized同步块后\",{\"1\":{\"542\":1}}],[\"途中waitset中的thread\",{\"1\":{\"541\":1}}],[\"刚开始\",{\"1\":{\"591\":1}}],[\"刚开始monitor中的owner为null\",{\"1\":{\"541\":1}}],[\"刚刚换入的页面马上又要换出外存\",{\"1\":{\"192\":1}}],[\"刚刚换出的页面马上又要换入内存\",{\"1\":{\"192\":1}}],[\"成交价格\",{\"1\":{\"990\":1}}],[\"成为一个文件\",{\"1\":{\"965\":1}}],[\"成为内核空间\",{\"1\":{\"676\":1}}],[\"成功删除1个\",{\"1\":{\"1205\":1}}],[\"成功返回true\",{\"1\":{\"1141\":1}}],[\"成功的概率太低\",{\"1\":{\"1136\":1}}],[\"成功\",{\"1\":{\"1127\":1,\"1128\":1,\"1129\":1}}],[\"成功插入的key的线程我们认为他就是获得到锁的线程\",{\"1\":{\"1127\":1}}],[\"成功时返回组对象\",{\"1\":{\"701\":1}}],[\"成功演示\",{\"1\":{\"542\":1}}],[\"成员按类型查找装配\",{\"1\":{\"1489\":1}}],[\"成员或参数\",{\"1\":{\"1482\":1}}],[\"成员中\",{\"1\":{\"1472\":2}}],[\"成员集合\",{\"1\":{\"701\":1}}],[\"成员名\",{\"1\":{\"701\":2}}],[\"成员\",{\"1\":{\"701\":2}}],[\"成员变量的数据类型不同\",{\"1\":{\"663\":1}}],[\"成员变量的线程安全性\",{\"1\":{\"562\":1}}],[\"成员变量来记录长度\",{\"1\":{\"663\":1}}],[\"成员变量\",{\"1\":{\"663\":3}}],[\"成员变量和静态变量的线程安全分析\",{\"1\":{\"539\":1}}],[\"成组链接法\",{\"1\":{\"198\":1}}],[\"变成\",{\"1\":{\"1175\":1,\"1177\":1}}],[\"变成了下面的两个\",{\"1\":{\"809\":1}}],[\"变更用户组\",{\"1\":{\"920\":1}}],[\"变更目录或文件的属主或用户组\",{\"1\":{\"920\":1}}],[\"变更目录或文件的权限\",{\"1\":{\"920\":1}}],[\"变量变为0时\",{\"1\":{\"1132\":1}}],[\"变量代表还剩余多少字节\",{\"1\":{\"820\":1}}],[\"变量拼接的原理是stringbuilder\",{\"1\":{\"632\":1}}],[\"变量的赋值也会通过\",{\"1\":{\"567\":1}}],[\"变量的线程安全分析\",{\"0\":{\"539\":1}}],[\"变量\",{\"1\":{\"564\":1}}],[\"变化和消亡的\",{\"1\":{\"159\":1}}],[\"涵盖了操作系统层面的\",{\"1\":{\"538\":1}}],[\"睡眠结束后的线程未必会立刻得到执行\",{\"1\":{\"533\":1}}],[\"陷入死循环\",{\"1\":{\"529\":1}}],[\"告诉发布者后面不接受数据了\",{\"1\":{\"717\":1,\"718\":2}}],[\"告诉他read操作完成了\",{\"1\":{\"679\":1}}],[\"告诉编译器取消结构体在编译过程中的优化对齐\",{\"1\":{\"663\":1}}],[\"告诉其他人这个数据页或数据表已经有人给它上过排他锁了\",{\"1\":{\"510\":1}}],[\"告知slave也删除这个key\",{\"1\":{\"529\":1}}],[\"槽位\",{\"1\":{\"948\":1}}],[\"槽位定位算法\",{\"1\":{\"528\":1}}],[\"槽位的信息存储于每个节点中\",{\"1\":{\"528\":1}}],[\"扩容超过\",{\"1\":{\"773\":1}}],[\"扩容规则是\",{\"1\":{\"773\":1}}],[\"扩容\",{\"0\":{\"773\":1},\"1\":{\"663\":1}}],[\"扩容的时候还是会将扩容后的数据长度与integer\",{\"1\":{\"601\":1}}],[\"扩容线程数\",{\"1\":{\"579\":1}}],[\"扩容时如果某个bin迁移完毕\",{\"1\":{\"579\":1}}],[\"扩容时\",{\"1\":{\"527\":1,\"579\":1}}],[\"扩展性\",{\"1\":{\"1189\":2}}],[\"扩展性高\",{\"1\":{\"23\":1}}],[\"扩展你的搜索量\",{\"1\":{\"1067\":1}}],[\"扩展你的内容容量\",{\"1\":{\"1066\":1}}],[\"扩展困难\",{\"1\":{\"888\":1}}],[\"扩展属性信息的保留\",{\"1\":{\"869\":1}}],[\"扩展序列化算法\",{\"0\":{\"723\":1}}],[\"扩展一样\",{\"1\":{\"666\":1}}],[\"扩展\",{\"0\":{\"30\":1,\"54\":1},\"1\":{\"666\":1}}],[\"据官方文档称可以线性扩展到上万个节点\",{\"1\":{\"527\":1}}],[\"涉及到了分布式选举\",{\"1\":{\"526\":1}}],[\"影响的底层接收缓冲区\",{\"1\":{\"693\":1}}],[\"影响数据恢复或主从同步的效率\",{\"1\":{\"526\":1}}],[\"影响查询性能\",{\"1\":{\"481\":1}}],[\"哨兵会发现主机宕机\",{\"1\":{\"1153\":1}}],[\"哨兵\",{\"1\":{\"526\":1}}],[\"哨兵通常需要3个实例\",{\"1\":{\"526\":1}}],[\"哨兵集群还是能正常工作的\",{\"1\":{\"526\":1}}],[\"哨兵用于实现redis集群的高可用\",{\"1\":{\"526\":1}}],[\"哨兵是redis集群中非常重要的一个组件\",{\"1\":{\"526\":1}}],[\"哨兵的配置略微复杂\",{\"1\":{\"526\":1}}],[\"哨兵模式\",{\"0\":{\"526\":1}}],[\"之\",{\"0\":{\"1380\":1,\"1387\":1,\"1399\":1,\"1407\":1}}],[\"之外\",{\"1\":{\"1289\":1}}],[\"之别\",{\"1\":{\"1067\":1}}],[\"之比\",{\"1\":{\"882\":1}}],[\"之和\",{\"1\":{\"683\":1}}],[\"之间也会有顺序问题\",{\"1\":{\"1437\":1}}],[\"之间进行平衡\",{\"1\":{\"873\":1}}],[\"之间进行了绑定\",{\"1\":{\"748\":1}}],[\"之间相差不超过给定阈值百分比\",{\"1\":{\"873\":1}}],[\"之间\",{\"1\":{\"666\":1}}],[\"之间的关系是固定的\",{\"1\":{\"1113\":1}}],[\"之间的通信协议\",{\"1\":{\"949\":1}}],[\"之间的协议\",{\"1\":{\"949\":4}}],[\"之间的内容进行切片\",{\"1\":{\"776\":1}}],[\"之间的节点\",{\"1\":{\"666\":1}}],[\"之间的遍历顺序关系\",{\"1\":{\"649\":1}}],[\"之所以有这个问题\",{\"1\":{\"1145\":1}}],[\"之所以\",{\"1\":{\"663\":1}}],[\"之前介绍的都是将具体类交给\",{\"1\":{\"1455\":1}}],[\"之前学习的代理是运行时生成新的字节码\",{\"1\":{\"1298\":1}}],[\"之前存在的age\",{\"1\":{\"1206\":1}}],[\"之前存在的name\",{\"1\":{\"1206\":1}}],[\"之前的点赞是放到set集合\",{\"1\":{\"1162\":1}}],[\"之前的方式要修改前后都保持一致\",{\"1\":{\"1136\":1}}],[\"之前的分配结果\",{\"1\":{\"1042\":1}}],[\"之前咱们已经重点分析过这个逻辑啦\",{\"1\":{\"1107\":1}}],[\"之前正在消费某几个分区\",{\"1\":{\"1042\":1}}],[\"之前比较当前服务器时钟是否被回拨\",{\"1\":{\"1000\":1}}],[\"之前没有其它出站处理器了\",{\"1\":{\"766\":1}}],[\"之前\",{\"1\":{\"726\":1,\"770\":1,\"1042\":1}}],[\"之前atomiclong等都是在一个共享资源变量上进行竞争\",{\"1\":{\"564\":1}}],[\"之前一共实现了6中内存淘汰机制\",{\"1\":{\"522\":1}}],[\"之后通过role\",{\"1\":{\"1230\":1}}],[\"之后注册等操作在\",{\"1\":{\"740\":1}}],[\"之后\",{\"1\":{\"726\":1}}],[\"之后能在线程使用完后自己释放\",{\"1\":{\"551\":1}}],[\"之后再进行读操作时\",{\"1\":{\"503\":1}}],[\"之后再传送到输出设备上\",{\"1\":{\"212\":1}}],[\"之后在转存到输入井中\",{\"1\":{\"212\":1}}],[\"之后开始访问临界区\",{\"1\":{\"169\":1}}],[\"惰性删除对cpu更加友好\",{\"1\":{\"520\":1}}],[\"惰性删除\",{\"1\":{\"520\":1}}],[\"折半查找\",{\"1\":{\"518\":1}}],[\"跳过这些查询过的数据\",{\"1\":{\"1168\":1}}],[\"跳过对齐填充的一个字节\",{\"1\":{\"713\":1}}],[\"跳过元素\",{\"1\":{\"616\":1}}],[\"跳过扫描不包含的stripes\",{\"1\":{\"437\":1}}],[\"跳表\",{\"1\":{\"517\":1}}],[\"闭区间\",{\"1\":{\"511\":1}}],[\"间接\",{\"1\":{\"1317\":2}}],[\"间接实现了图像配对\",{\"1\":{\"117\":1}}],[\"间断性地还执行了应用程序代码\",{\"1\":{\"634\":1}}],[\"间隙锁\",{\"1\":{\"511\":1}}],[\"想要去看共同关注的好友\",{\"1\":{\"1165\":1}}],[\"想要达到这样的效果\",{\"1\":{\"72\":1}}],[\"想上锁的那个事务需要遍历有没有行锁\",{\"1\":{\"510\":1}}],[\"悲观锁中又可以再细分为公平锁\",{\"1\":{\"1135\":1}}],[\"悲观锁可以实现对于数据的串行化执行\",{\"1\":{\"1135\":1}}],[\"悲观锁是一种思想\",{\"1\":{\"507\":1}}],[\"悲观锁\",{\"1\":{\"507\":1,\"1135\":1}}],[\"锁重试和\",{\"0\":{\"1152\":1}}],[\"锁已经存在\",{\"1\":{\"1151\":1}}],[\"锁失效时间\",{\"1\":{\"1151\":1}}],[\"锁名称\",{\"1\":{\"1151\":1}}],[\"锁中\",{\"1\":{\"1151\":1}}],[\"锁都是可重入的\",{\"1\":{\"1149\":1}}],[\"锁自动释放时间\",{\"1\":{\"1150\":1}}],[\"锁自动释放\",{\"1\":{\"1143\":1}}],[\"锁持有的超时事件\",{\"1\":{\"1142\":1}}],[\"锁\",{\"1\":{\"1137\":1}}],[\"锁定这80mb的内存\",{\"1\":{\"979\":1}}],[\"锁定一个范围包含记录本身\",{\"1\":{\"511\":1}}],[\"锁定一个范围\",{\"1\":{\"511\":1}}],[\"锁状态标志\",{\"1\":{\"631\":1}}],[\"锁升级\",{\"1\":{\"590\":1}}],[\"锁住链表头节点\",{\"1\":{\"579\":1}}],[\"锁的基本接口\",{\"1\":{\"1142\":1}}],[\"锁的粒度太粗了\",{\"1\":{\"1137\":1}}],[\"锁的粒度更小\",{\"1\":{\"579\":1}}],[\"锁的信息链表\",{\"1\":{\"513\":1}}],[\"锁可以分为表锁\",{\"1\":{\"506\":1}}],[\"锁机制的基本原理可以概括为\",{\"1\":{\"506\":1}}],[\"锁机制保证隔离性\",{\"1\":{\"506\":1}}],[\"既可以支持正向检索和也可以支持反向检索\",{\"1\":{\"1209\":1}}],[\"既可用于\",{\"1\":{\"729\":1}}],[\"既不需要手动修改\",{\"1\":{\"663\":1}}],[\"既然没有接口都可以用cglib\",{\"0\":{\"1512\":1}}],[\"既然之前的拦截器无法对不需要拦截的路径生效\",{\"1\":{\"1110\":1}}],[\"既然每个请求都是独立的\",{\"1\":{\"1100\":1}}],[\"既然\",{\"1\":{\"661\":1}}],[\"既然redo\",{\"1\":{\"506\":1}}],[\"既想返回源表字段又想返回explode生成的虚拟表字段\",{\"1\":{\"348\":1}}],[\"于是就希望转发至\",{\"1\":{\"1411\":1}}],[\"于是再过10s后又再设置一个timertask\",{\"1\":{\"1152\":1}}],[\"于是删除这把锁\",{\"1\":{\"1143\":1}}],[\"于是不进行删除锁逻辑\",{\"1\":{\"1143\":1}}],[\"于是乎我们需要保证id的唯一性\",{\"1\":{\"1131\":1}}],[\"于是他可以再次发送read操作\",{\"1\":{\"679\":1}}],[\"于是\",{\"1\":{\"506\":1}}],[\"于是一个超人就诞生了\",{\"1\":{\"19\":1}}],[\"少则几十万\",{\"1\":{\"1114\":1}}],[\"少一次拷贝\",{\"1\":{\"801\":1}}],[\"少一次内存复制\",{\"1\":{\"769\":1}}],[\"少不得束修金\",{\"1\":{\"709\":1}}],[\"少用or\",{\"1\":{\"505\":1}}],[\"少量大分区\",{\"1\":{\"182\":1}}],[\"记住如下几个步骤即可\",{\"1\":{\"1221\":1}}],[\"记得引用老师画的图\",{\"1\":{\"992\":1}}],[\"记作事务a\",{\"1\":{\"503\":1}}],[\"记录监听器\",{\"1\":{\"1444\":1}}],[\"记录1次pv\",{\"1\":{\"1179\":1}}],[\"记录最后一次使用的毫秒时间戳\",{\"1\":{\"999\":1}}],[\"记录最后使用的毫秒时间戳\",{\"1\":{\"999\":1}}],[\"记录文件块和datanode之间的映射信息\",{\"1\":{\"905\":1}}],[\"记录\",{\"1\":{\"741\":1,\"1444\":2}}],[\"记录日志\",{\"1\":{\"740\":1,\"742\":3}}],[\"记录了这个\",{\"1\":{\"779\":1}}],[\"记录了当前节点的实际数据\",{\"1\":{\"665\":1}}],[\"记录了当前节点实际数据的类型以及长度\",{\"1\":{\"665\":1}}],[\"记录了\",{\"1\":{\"665\":1,\"1321\":2}}],[\"记录了字符串长度\",{\"1\":{\"663\":1}}],[\"记录压缩列表包含的节点数量\",{\"1\":{\"665\":1}}],[\"记录压缩列表\",{\"1\":{\"665\":1}}],[\"记录整个压缩列表占用对内存字节数\",{\"1\":{\"665\":1}}],[\"记录锁\",{\"1\":{\"511\":1}}],[\"记录可以是定长的或可变长的\",{\"1\":{\"195\":1}}],[\"记录式文件\",{\"1\":{\"195\":1}}],[\"记录型信号量\",{\"1\":{\"171\":1}}],[\"隐藏用户敏感信息\",{\"0\":{\"1101\":1}}],[\"隐藏\",{\"1\":{\"1005\":1}}],[\"隐藏列中包含了本行数据的事务id\",{\"1\":{\"503\":1}}],[\"隐藏列\",{\"1\":{\"503\":1}}],[\"隐式连接表示法\",{\"1\":{\"320\":1}}],[\"隐式转换\",{\"1\":{\"248\":1}}],[\"隐式链接\",{\"1\":{\"197\":2}}],[\"掘金\",{\"1\":{\"503\":1,\"1532\":1}}],[\"谈谈你对mvcc的了解\",{\"0\":{\"503\":1},\"1\":{\"506\":2}}],[\"改成了\",{\"1\":{\"1317\":1}}],[\"改成stock大于0\",{\"1\":{\"1136\":1}}],[\"改造原始代码\",{\"0\":{\"1216\":1}}],[\"改造原因是因为我们需要在用户关注了某位用户后\",{\"1\":{\"1165\":1}}],[\"改造uuid\",{\"1\":{\"502\":1}}],[\"改为\",{\"1\":{\"1136\":1}}],[\"改变程序结果且不易发现\",{\"1\":{\"970\":1}}],[\"改变\",{\"1\":{\"804\":1}}],[\"改进的地方\",{\"1\":{\"827\":1}}],[\"改进方法\",{\"1\":{\"213\":1}}],[\"改进型时钟置换算法思想\",{\"1\":{\"191\":1}}],[\"改进型的时钟置换算法\",{\"1\":{\"191\":1}}],[\"改进工厂类\",{\"1\":{\"42\":1}}],[\"回顾缓存穿透\",{\"1\":{\"1177\":1}}],[\"回答是不太好\",{\"1\":{\"779\":1}}],[\"回到了熟悉的代码\",{\"1\":{\"743\":1}}],[\"回到用户态\",{\"1\":{\"676\":1}}],[\"回调aware接口的方法\",{\"1\":{\"1505\":1}}],[\"回调的接口换了一下\",{\"1\":{\"1317\":1}}],[\"回调各种\",{\"1\":{\"1252\":1}}],[\"回调对象\",{\"1\":{\"753\":1}}],[\"回调\",{\"1\":{\"740\":2,\"1309\":1}}],[\"回复\",{\"1\":{\"726\":1}}],[\"回来了\",{\"1\":{\"694\":1}}],[\"回滚和提交是由事务管理器来完成的\",{\"1\":{\"1515\":1}}],[\"回滚操作\",{\"1\":{\"1456\":1}}],[\"回滚不会\",{\"1\":{\"892\":1}}],[\"回滚需要停机\",{\"1\":{\"892\":1}}],[\"回滚时则会执行相反的update\",{\"1\":{\"506\":1}}],[\"回滚时会执行insert\",{\"1\":{\"506\":1}}],[\"回滚时会执行delete\",{\"1\":{\"506\":1}}],[\"回滚段上用于恢复数据的信息\",{\"1\":{\"499\":1}}],[\"回收站中的文件多少分钟后会被系统永久删除\",{\"1\":{\"910\":1}}],[\"回收内存的源码实现\",{\"1\":{\"775\":1}}],[\"回收内存即可\",{\"1\":{\"775\":1}}],[\"回收算法\",{\"1\":{\"633\":1}}],[\"回收区的前\",{\"1\":{\"182\":2}}],[\"回收区的前或后面有一个相邻的空闲分区\",{\"1\":{\"182\":1}}],[\"回收资源\",{\"1\":{\"161\":1}}],[\"北京市\",{\"1\":{\"495\":1}}],[\"散列性\",{\"1\":{\"493\":1}}],[\"张\",{\"1\":{\"493\":1,\"495\":1}}],[\"张三的好友有\",{\"1\":{\"1210\":1}}],[\"张三\",{\"1\":{\"52\":1,\"54\":2,\"615\":1,\"713\":1,\"735\":1,\"737\":1,\"1186\":2}}],[\"连上了\",{\"1\":{\"837\":1}}],[\"连锁更新\",{\"0\":{\"666\":1},\"1\":{\"666\":2,\"667\":2}}],[\"连接等待时间\",{\"1\":{\"1220\":1}}],[\"连接池的初始化\",{\"1\":{\"1215\":1}}],[\"连接\",{\"1\":{\"866\":1}}],[\"连接已建立\",{\"1\":{\"836\":3}}],[\"连接已经断开了\",{\"1\":{\"707\":1}}],[\"连接集合\",{\"1\":{\"826\":1,\"827\":1}}],[\"连接肯定建立了\",{\"1\":{\"753\":2}}],[\"连接未建立\",{\"1\":{\"753\":2}}],[\"连接事件\",{\"1\":{\"742\":1}}],[\"连接假死\",{\"0\":{\"707\":1}}],[\"连接建立后\",{\"1\":{\"609\":1}}],[\"连接表的数量尽量不要超过\",{\"1\":{\"493\":1}}],[\"连接操作时\",{\"1\":{\"493\":1}}],[\"连续登录三天的只需要略作修改即可\",{\"1\":{\"400\":1}}],[\"连续登录用户\",{\"0\":{\"399\":1}}],[\"连续登陆2天\",{\"1\":{\"400\":1}}],[\"连续三天登陆\",{\"1\":{\"399\":1}}],[\"连续两天登陆\",{\"1\":{\"399\":1}}],[\"连续累积求和\",{\"1\":{\"360\":2}}],[\"连续分配的文件在顺序访问时速度最快\",{\"1\":{\"197\":1}}],[\"连续分配方式要求每个文件在磁盘上占有一组连续的块\",{\"1\":{\"197\":1}}],[\"连续分配\",{\"1\":{\"182\":1,\"197\":1,\"198\":1}}],[\"连续分配管理方式是指为一个程序分配一个连续的内存空间\",{\"1\":{\"683\":1}}],[\"连续分配管理方式\",{\"0\":{\"182\":1}}],[\"尤其是在数据量大的情况下\",{\"1\":{\"493\":1}}],[\"尤其是数据规模很大和工作负载密集的情况下\",{\"1\":{\"432\":1}}],[\"频繁作为\",{\"1\":{\"493\":1}}],[\"聚簇索引包含的信息多\",{\"1\":{\"497\":1}}],[\"聚簇索引和非聚簇索引\",{\"1\":{\"492\":1}}],[\"聚合查询\",{\"0\":{\"1084\":1},\"1\":{\"1084\":1}}],[\"聚合等等操作的性能\",{\"1\":{\"438\":1}}],[\"聚合操作时针对null的处理\",{\"1\":{\"351\":1}}],[\"聚合参数不支持嵌套聚合函数\",{\"1\":{\"351\":1}}],[\"聚合函数和case\",{\"1\":{\"351\":1}}],[\"聚合函数\",{\"1\":{\"334\":1,\"358\":1}}],[\"聚合演示\",{\"1\":{\"108\":1}}],[\"聚合语法\",{\"1\":{\"108\":1}}],[\"聚合作用\",{\"1\":{\"108\":1}}],[\"聚合可以帮助我们更好地管理一组相关的子项目\",{\"1\":{\"108\":1}}],[\"聚合是指将多个项目组织到一个父级项目中\",{\"1\":{\"108\":1}}],[\"聚合概念\",{\"1\":{\"108\":1}}],[\"聚合或组合关系\",{\"1\":{\"76\":1}}],[\"叶子节点之间会有指针\",{\"1\":{\"488\":1}}],[\"树状数组\",{\"0\":{\"672\":1}}],[\"树非叶子节点也存储数据\",{\"1\":{\"488\":1}}],[\"树形结构不便于实现文件的共享\",{\"1\":{\"196\":1}}],[\"树形目录结构可以很方便的对文件进行分类\",{\"1\":{\"196\":1}}],[\"深入了解读数据的流程\",{\"1\":{\"1052\":1}}],[\"深度为3可以存储1000\",{\"1\":{\"487\":1}}],[\"深克隆\",{\"0\":{\"54\":1},\"1\":{\"51\":1}}],[\"速度快\",{\"1\":{\"482\":1,\"1190\":1}}],[\"速度非常慢\",{\"1\":{\"481\":1}}],[\"比锁\",{\"1\":{\"1145\":1,\"1146\":1,\"1147\":1}}],[\"比较常用的比如annotationconfigapplicationcontext\",{\"1\":{\"1502\":1}}],[\"比较常见的\",{\"1\":{\"1009\":1}}],[\"比较适合用来实现特殊的功能需求\",{\"1\":{\"1212\":1}}],[\"比较延迟\",{\"1\":{\"1166\":1}}],[\"比较节约空间\",{\"1\":{\"1166\":1}}],[\"比较不同快照的差异\",{\"1\":{\"914\":1}}],[\"比较的是不同机器之间的\",{\"1\":{\"874\":1}}],[\"比较同台机器上不同卷之间的数据分布情况\",{\"1\":{\"874\":1}}],[\"比较费解\",{\"1\":{\"742\":1}}],[\"比较好理解\",{\"1\":{\"742\":1}}],[\"比\",{\"1\":{\"482\":1,\"861\":1,\"1243\":1}}],[\"比如get和post\",{\"1\":{\"1531\":1}}],[\"比如当我们引用第三方库中的类需要装配到spring容器中时\",{\"1\":{\"1507\":1}}],[\"比如当前没有人持有这把锁\",{\"1\":{\"1151\":1}}],[\"比如dao\",{\"1\":{\"1506\":1}}],[\"比如beannameaware中setbeanname\",{\"1\":{\"1505\":1}}],[\"比如条件是\",{\"1\":{\"1466\":1}}],[\"比如我们tomcat中的线程池\",{\"1\":{\"1214\":1}}],[\"比如我只要确定他能做这件事\",{\"1\":{\"1155\":1}}],[\"比如唯一性\",{\"1\":{\"1182\":1}}],[\"比如最早点赞的top5\",{\"1\":{\"1162\":1}}],[\"比如是否一人一单\",{\"1\":{\"1155\":1}}],[\"比如是否库存足够\",{\"1\":{\"1155\":1}}],[\"比如续个\",{\"1\":{\"1147\":1}}],[\"比如他已经拿到了当前这把锁确实是属于他自己的\",{\"1\":{\"1145\":1}}],[\"比如时间是否充足\",{\"1\":{\"1134\":1,\"1137\":1}}],[\"比如商城在一天时间内\",{\"1\":{\"1131\":1}}],[\"比如之前提到的map\",{\"1\":{\"1115\":1}}],[\"比如在退款的时候\",{\"1\":{\"1005\":1}}],[\"比如在put操作中\",{\"1\":{\"579\":1}}],[\"比如订单的状态有提交\",{\"1\":{\"1005\":1}}],[\"比如订单的流水号\",{\"1\":{\"1005\":1}}],[\"比如订单的问题\",{\"1\":{\"1003\":1}}],[\"比如订单提交\",{\"1\":{\"1004\":1}}],[\"比如根据id更新数据\",{\"1\":{\"1004\":1}}],[\"比如根据id删除某一个资源\",{\"1\":{\"1004\":1}}],[\"比如互联网\",{\"1\":{\"995\":1}}],[\"比如读取缓存\",{\"1\":{\"989\":1}}],[\"比如节点黑白名单\",{\"1\":{\"949\":1}}],[\"比如超级用户\",{\"1\":{\"927\":1}}],[\"比如属主root具有权限rwx\",{\"1\":{\"925\":1}}],[\"比如4个9\",{\"1\":{\"882\":1}}],[\"比如对于ec策略rs\",{\"1\":{\"875\":1}}],[\"比如一个公司就可以在网络中建立一个域环境\",{\"1\":{\"923\":1}}],[\"比如一个\",{\"1\":{\"841\":1}}],[\"比如一个线程发起建立连接\",{\"1\":{\"755\":1}}],[\"比如可以通过aop实现应用程序中的日志功能\",{\"1\":{\"1510\":1}}],[\"比如可以用于王者荣耀玩家加载\",{\"1\":{\"592\":1}}],[\"比如可能对操作系统造成伤害以及给同时运行多个程序造成困难\",{\"1\":{\"685\":1}}],[\"比如有\",{\"1\":{\"875\":1}}],[\"比如有缓冲区溢出的风险\",{\"1\":{\"662\":1}}],[\"比如有三个进程a\",{\"1\":{\"176\":1}}],[\"比如爬给定网址的时候对已经爬取过的\",{\"1\":{\"660\":1}}],[\"比如判断一个数字是否存在于包含大量数字的数字集中\",{\"1\":{\"660\":1}}],[\"比如自定义string类\",{\"1\":{\"624\":1}}],[\"比如相册服务器\",{\"1\":{\"612\":1}}],[\"比如聊天服务器等等\",{\"1\":{\"612\":1}}],[\"比如字符串常量池\",{\"1\":{\"568\":1}}],[\"比如字符串string\",{\"1\":{\"248\":1}}],[\"比如atomicinteger\",{\"1\":{\"560\":1}}],[\"比如volatile修饰的i\",{\"1\":{\"558\":1}}],[\"比如vingkin数据库下的t\",{\"1\":{\"235\":1}}],[\"比如直播间礼物排行\",{\"1\":{\"515\":1}}],[\"比如集合的交集和并集\",{\"1\":{\"515\":1}}],[\"比如用户的访问次数\",{\"1\":{\"515\":1}}],[\"比如数据页或数据表加上意向锁\",{\"1\":{\"510\":1}}],[\"比如数据仓库\",{\"1\":{\"221\":1}}],[\"比如运行时的operator和sort\",{\"1\":{\"442\":1}}],[\"比如文件的路径信息\",{\"1\":{\"441\":1}}],[\"比如按照join的关联字段\",{\"1\":{\"418\":1}}],[\"比如orcserde\",{\"1\":{\"374\":1}}],[\"比如向前2行\",{\"1\":{\"361\":1}}],[\"比如lead\",{\"1\":{\"358\":1}}],[\"比如reentrantreadwritelock中的写锁可以降级为读锁\",{\"1\":{\"582\":1}}],[\"比如reentrantreadwritelock\",{\"1\":{\"582\":1,\"583\":1}}],[\"比如rank\",{\"1\":{\"358\":1}}],[\"比如rollup有a\",{\"1\":{\"352\":1}}],[\"比如spring中的bean的创建\",{\"1\":{\"1215\":1}}],[\"比如spf如果有源源不断的短进程到来\",{\"1\":{\"175\":1}}],[\"比如syn\",{\"1\":{\"1135\":1}}],[\"比如string则比较的具体内容是否相等\",{\"1\":{\"597\":1}}],[\"比如substring\",{\"1\":{\"566\":1}}],[\"比如sum\",{\"1\":{\"358\":1}}],[\"比如cube有a\",{\"1\":{\"352\":1}}],[\"比如copy\",{\"1\":{\"190\":1}}],[\"比如手机号\",{\"1\":{\"344\":1}}],[\"比如下面代码\",{\"1\":{\"1232\":1}}],[\"比如下面这种情况\",{\"1\":{\"593\":1}}],[\"比如下面这些\",{\"1\":{\"585\":1}}],[\"比如下面的两种情况\",{\"1\":{\"372\":1}}],[\"比如下面的案例就是先手动设定reducetask的个数为2\",{\"1\":{\"313\":1}}],[\"比如下图中t2和t3就占有共享锁\",{\"1\":{\"583\":1}}],[\"比如下述代码\",{\"1\":{\"260\":1}}],[\"比如说我们的数据库连接池\",{\"1\":{\"1214\":1}}],[\"比如说以下这张表\",{\"1\":{\"1174\":1}}],[\"比如说\",{\"1\":{\"1061\":1}}],[\"比如说下面的month\",{\"1\":{\"353\":1}}],[\"比如说这个count\",{\"1\":{\"304\":1}}],[\"比如说先按省分区\",{\"1\":{\"262\":1}}],[\"比如分桶表就需要通过insert+select语句加载数据\",{\"1\":{\"286\":1}}],[\"比如mysql\",{\"1\":{\"241\":1}}],[\"比如名为vingkin的数据库的存储路径为\",{\"1\":{\"234\":1}}],[\"比如常见的关系型数据库系统\",{\"1\":{\"221\":1}}],[\"比如p2中申请一个r1\",{\"1\":{\"178\":1}}],[\"比如使用spooling技术\",{\"1\":{\"176\":1}}],[\"比如使用继承会给程序带来侵入性\",{\"1\":{\"73\":1}}],[\"比如flag\",{\"1\":{\"169\":1}}],[\"比如摄像头\",{\"1\":{\"168\":1}}],[\"比如打印机\",{\"1\":{\"163\":1}}],[\"比如qq要发送文件\",{\"1\":{\"163\":1}}],[\"比如共享空间里只能放一个长度为10的数组\",{\"1\":{\"162\":1}}],[\"比如获取打印机等\",{\"1\":{\"160\":1}}],[\"比如代码和数据存储的位置\",{\"1\":{\"159\":1}}],[\"比如进程切换\",{\"1\":{\"157\":1}}],[\"比如虚拟存储技术\",{\"1\":{\"155\":1}}],[\"比如扬声器可以同时播放两个地方的\",{\"1\":{\"155\":1}}],[\"比如\",{\"1\":{\"155\":3,\"160\":1,\"168\":1,\"171\":1,\"175\":2,\"182\":1,\"187\":1,\"191\":1,\"194\":1,\"195\":1,\"198\":1,\"201\":1,\"211\":1,\"272\":1,\"355\":1,\"420\":1,\"459\":1,\"493\":1,\"496\":1,\"501\":1,\"517\":1,\"623\":1,\"662\":2,\"663\":5,\"665\":1,\"927\":1,\"951\":2,\"1061\":1,\"1063\":1,\"1066\":1,\"1149\":1,\"1155\":1,\"1177\":1,\"1500\":1,\"1525\":1}}],[\"比如将文件拖拽到垃圾箱\",{\"1\":{\"154\":1}}],[\"比如13∗13\",{\"1\":{\"138\":1}}],[\"比如创建美团外卖等\",{\"1\":{\"28\":1}}],[\"跟业务相关\",{\"1\":{\"712\":1}}],[\"跟null和非null无关\",{\"1\":{\"482\":1}}],[\"跟数据库无关\",{\"1\":{\"482\":1}}],[\"抵制惟一索引\",{\"1\":{\"481\":1}}],[\"宁缺勿滥\",{\"1\":{\"481\":1}}],[\"宁滥勿缺\",{\"1\":{\"481\":1}}],[\"级联更新是强阻塞\",{\"1\":{\"482\":1}}],[\"级联累加求和\",{\"0\":{\"401\":1}}],[\"级别断点\",{\"1\":{\"795\":1}}],[\"级别\",{\"1\":{\"481\":1}}],[\"至\",{\"1\":{\"1446\":1}}],[\"至于一个分片怎样分布\",{\"1\":{\"1066\":1}}],[\"至于是否调用还是得看cpu的分配\",{\"1\":{\"532\":1}}],[\"至少应该包含大于\",{\"1\":{\"1026\":1}}],[\"至少两个线程\",{\"1\":{\"851\":1}}],[\"至少要达到\",{\"1\":{\"481\":1}}],[\"至此双方相安无事\",{\"1\":{\"709\":1}}],[\"至尊宝\",{\"1\":{\"256\":1}}],[\"必然导致\",{\"1\":{\"826\":1}}],[\"必然导致索引的大小也会很大\",{\"1\":{\"486\":1}}],[\"必然存在一个线程\",{\"1\":{\"551\":1}}],[\"必然有脏数据产生\",{\"1\":{\"481\":1}}],[\"必须添加如下依赖\",{\"1\":{\"1442\":1}}],[\"必须调用到足够次数才会进行优化\",{\"1\":{\"1317\":1}}],[\"必须提前创建\",{\"1\":{\"1285\":1}}],[\"必须用redis的数据结构实现\",{\"1\":{\"1167\":1}}],[\"必须全部是小写字母\",{\"1\":{\"1061\":1}}],[\"必须指定文件的完整路径名\",{\"1\":{\"880\":2}}],[\"必须指定索引长度\",{\"1\":{\"481\":1,\"493\":1}}],[\"必须将事件移除\",{\"1\":{\"834\":1}}],[\"必须将hive事务管理器设置为org\",{\"1\":{\"296\":1}}],[\"必须处理\",{\"1\":{\"834\":1,\"836\":1}}],[\"必须工作在非阻塞模式\",{\"1\":{\"831\":1}}],[\"必须关闭\",{\"1\":{\"816\":1}}],[\"必须通过\",{\"1\":{\"813\":1}}],[\"必须\",{\"1\":{\"775\":2}}],[\"必须配合多线程\",{\"1\":{\"755\":1}}],[\"必须和\",{\"1\":{\"714\":1,\"723\":1}}],[\"必须使用非阻塞套接口\",{\"1\":{\"680\":1}}],[\"必须使用is\",{\"1\":{\"480\":1}}],[\"必须同时更新记录对应的gmt\",{\"1\":{\"483\":1}}],[\"必须是unsigned\",{\"1\":{\"480\":1}}],[\"必须是互斥的进程\",{\"1\":{\"168\":1}}],[\"必须开启这个属性\",{\"1\":{\"470\":1}}],[\"必须经过shuffle\",{\"1\":{\"449\":1}}],[\"必须对需要使用索引的字段进行排序\",{\"1\":{\"437\":1}}],[\"必须手动执行一个alter\",{\"1\":{\"424\":1}}],[\"必须要给子查询一个名称\",{\"1\":{\"316\":1}}],[\"必须自己把数据加载到增加的分区中\",{\"1\":{\"280\":1}}],[\"必须先顺序查找第i\",{\"1\":{\"195\":1}}],[\"必须由程序员声明覆盖结构\",{\"1\":{\"181\":1}}],[\"必须分配其要求的全部内存空间\",{\"1\":{\"179\":1}}],[\"必须按规定次序申请资源\",{\"1\":{\"176\":1}}],[\"必须考虑到所有的子类\",{\"1\":{\"73\":1}}],[\"太阳\",{\"1\":{\"480\":1}}],[\"太阳花的小绿豆\",{\"1\":{\"145\":1}}],[\"恐龙化石\",{\"1\":{\"480\":1}}],[\"龟\",{\"1\":{\"480\":1}}],[\"参与选举\",{\"1\":{\"1048\":1}}],[\"参见定义pojo类以及数据库字段定义规定第8条\",{\"1\":{\"483\":1}}],[\"参考🔖\",{\"0\":{\"852\":1}}],[\"参考实现\",{\"1\":{\"841\":1}}],[\"参考下图\",{\"1\":{\"742\":1}}],[\"参考\",{\"1\":{\"480\":1,\"481\":1,\"482\":2,\"483\":2}}],[\"参数名解析\",{\"0\":{\"1363\":1}}],[\"参数解析器\",{\"0\":{\"1359\":1},\"1\":{\"1437\":1}}],[\"参数列表\",{\"1\":{\"1156\":1}}],[\"参数3\",{\"1\":{\"1152\":2}}],[\"参数2\",{\"1\":{\"1152\":1}}],[\"参数分别是\",{\"1\":{\"1150\":1}}],[\"参数对应关系就如下图股\",{\"1\":{\"1147\":1}}],[\"参数信息\",{\"1\":{\"1021\":1}}],[\"参数未配置的话默认为6小时\",{\"1\":{\"903\":1}}],[\"参数与系统参数\",{\"1\":{\"726\":1}}],[\"参数调优\",{\"0\":{\"724\":1}}],[\"参数1\",{\"1\":{\"562\":1}}],[\"参数设置\",{\"0\":{\"297\":1}}],[\"参数位置\",{\"1\":{\"261\":1}}],[\"参数来指定metastore服务运行的机器ip和端口\",{\"1\":{\"244\":1}}],[\"参数值来判断\",{\"1\":{\"243\":1}}],[\"参数\",{\"1\":{\"154\":1,\"395\":1,\"396\":1,\"450\":2,\"725\":1,\"726\":1,\"728\":1,\"729\":3,\"730\":1,\"731\":1,\"847\":1,\"962\":1}}],[\"库存key\",{\"1\":{\"1156\":1}}],[\"库存已经被修改过了\",{\"1\":{\"1136\":1}}],[\"库存超卖问题分析\",{\"0\":{\"1135\":1}}],[\"库存不足\",{\"1\":{\"1134\":2,\"1135\":3,\"1137\":5,\"1142\":1,\"1150\":1,\"1156\":1,\"1157\":2}}],[\"库存是否充足\",{\"1\":{\"1134\":1}}],[\"库名与应用名称尽量一致\",{\"1\":{\"480\":1}}],[\"库函数在应用程序和系统调用之间\",{\"1\":{\"158\":1}}],[\"步走视图解析及渲染流程\",{\"1\":{\"1438\":1}}],[\"步视图解析及渲染流程\",{\"1\":{\"1438\":1}}],[\"步长为指定的increment值\",{\"1\":{\"1211\":1}}],[\"步长为1\",{\"1\":{\"480\":1}}],[\"步骤4\",{\"1\":{\"1441\":1}}],[\"步骤3\",{\"1\":{\"1441\":1}}],[\"步骤2\",{\"1\":{\"1441\":1}}],[\"步骤1\",{\"1\":{\"1441\":1}}],[\"步骤三\",{\"1\":{\"1128\":1}}],[\"步骤二\",{\"1\":{\"1128\":1}}],[\"步骤一\",{\"1\":{\"1128\":1}}],[\"步骤\",{\"1\":{\"172\":1,\"797\":1}}],[\"请你说说spring的核心是什么\",{\"0\":{\"1500\":1}}],[\"请参考\",{\"1\":{\"1440\":1}}],[\"请参考mysql官方保留字\",{\"1\":{\"480\":1}}],[\"请自行查阅\",{\"1\":{\"1243\":1}}],[\"请检查服务器时间\",{\"1\":{\"999\":1}}],[\"请思考\",{\"1\":{\"775\":1}}],[\"请关注下面方法的不同实现\",{\"1\":{\"775\":1}}],[\"请输入密码\",{\"1\":{\"702\":1}}],[\"请输入用户名\",{\"1\":{\"702\":1}}],[\"请选cms\",{\"1\":{\"639\":1}}],[\"请选parallel\",{\"1\":{\"639\":1}}],[\"请选serial\",{\"1\":{\"639\":1}}],[\"请把等号条件的列前置\",{\"1\":{\"481\":1}}],[\"请注意利用索引的有序性\",{\"1\":{\"481\":1}}],[\"请不要在创建表时就分库分表\",{\"1\":{\"480\":1}}],[\"请求类型\",{\"1\":{\"1531\":1}}],[\"请求参数\",{\"1\":{\"1530\":1}}],[\"请求参数如果有中文\",{\"1\":{\"1462\":1}}],[\"请求报文头\",{\"1\":{\"1530\":1}}],[\"请求到达服务器\",{\"1\":{\"1438\":1}}],[\"请求方法等信息\",{\"1\":{\"1355\":1}}],[\"请求方式\",{\"1\":{\"374\":1}}],[\"请求结束时销毁\",{\"1\":{\"1290\":1}}],[\"请求我们的nginx服务器\",{\"1\":{\"1094\":1}}],[\"请求的时候携带这个全局id一起请求\",{\"1\":{\"1005\":1}}],[\"请求雪花算法服务获取\",{\"1\":{\"998\":1}}],[\"请求创建或解密edek的客户端永远不会处理ez密钥\",{\"1\":{\"935\":1}}],[\"请求消息处理器\",{\"1\":{\"733\":1}}],[\"请求消息\",{\"1\":{\"733\":1}}],[\"请求一个数据\",{\"1\":{\"717\":1,\"718\":1}}],[\"请求序号\",{\"1\":{\"712\":1}}],[\"请求体\",{\"1\":{\"711\":1}}],[\"请求头\",{\"1\":{\"711\":1}}],[\"请求行\",{\"1\":{\"711\":1}}],[\"请求段页式存储管理\",{\"1\":{\"689\":1}}],[\"请求分段系统是在分段系统的基础上\",{\"1\":{\"689\":1}}],[\"请求分段存储管理\",{\"1\":{\"689\":1}}],[\"请求分页管理的方式\",{\"1\":{\"190\":1}}],[\"请求分页存储管理可以提供虚拟内存\",{\"1\":{\"689\":1}}],[\"请求分页存储管理不要求将作业全部地址空间同时装入主存\",{\"1\":{\"689\":1}}],[\"请求分页存储管理建立在分页存储管理之上\",{\"1\":{\"689\":1}}],[\"请求分页存储管理与基本分页存储管理的主要区别\",{\"1\":{\"190\":1}}],[\"请求分页存储管理\",{\"0\":{\"190\":1},\"1\":{\"689\":1}}],[\"请求最终将到达顶层的启动类加载器\",{\"1\":{\"623\":1}}],[\"请求状态\",{\"1\":{\"374\":1}}],[\"请求协议\",{\"1\":{\"374\":1}}],[\"请求地址\",{\"1\":{\"374\":1,\"1531\":1}}],[\"请求调页策略\",{\"1\":{\"192\":1}}],[\"请求和响应消息\",{\"1\":{\"733\":1}}],[\"请求和释放资源的顺序不当\",{\"1\":{\"175\":1}}],[\"请求和保持条件\",{\"1\":{\"175\":1,\"551\":1}}],[\"禁止哪些机器加入到当前的hdfs集群中\",{\"1\":{\"880\":1}}],[\"禁止指令重排\",{\"1\":{\"557\":1}}],[\"禁止驱逐数据\",{\"1\":{\"522\":1}}],[\"禁止使用存储过程\",{\"1\":{\"482\":1}}],[\"禁止使用float和double\",{\"1\":{\"480\":1}}],[\"禁止两个下划线中间只出现数字\",{\"1\":{\"480\":1}}],[\"禁止出现数字开头\",{\"1\":{\"480\":1}}],[\"禁用\",{\"1\":{\"1453\":1}}],[\"禁用的前提是该目录的所有快照已经被删除\",{\"1\":{\"914\":1}}],[\"禁用擦除编码策略\",{\"1\":{\"875\":1}}],[\"禁用和删除\",{\"1\":{\"875\":1}}],[\"禁用保留字\",{\"1\":{\"480\":1}}],[\"禁用后对原表的查询通过mr实现\",{\"1\":{\"276\":1}}],[\"禁用物化视图自动重写\",{\"1\":{\"276\":1}}],[\"禁用自动重写\",{\"1\":{\"276\":1}}],[\"拿第一页数据\",{\"1\":{\"1167\":1}}],[\"拿锁比锁删锁的原子性动作了~\",{\"1\":{\"1147\":1}}],[\"拿取一行数据转换为string\",{\"1\":{\"958\":1,\"983\":1}}],[\"拿到的是产品对象\",{\"1\":{\"1472\":1}}],[\"拿到我们需要的数据\",{\"1\":{\"1168\":1}}],[\"拿到了10~6\",{\"1\":{\"1167\":1}}],[\"拿到触发事件的channel\",{\"1\":{\"840\":1}}],[\"拿到\",{\"1\":{\"766\":1}}],[\"拿到一个事件\",{\"1\":{\"743\":1}}],[\"拿到空的\",{\"1\":{\"738\":1}}],[\"拿出堆顶的输入流\",{\"1\":{\"478\":1}}],[\"拿铁咖啡和提拉米苏是同一产品族\",{\"1\":{\"39\":1}}],[\"遍历监听器集合\",{\"1\":{\"1497\":1}}],[\"遍历values\",{\"1\":{\"988\":1}}],[\"遍历数组\",{\"1\":{\"958\":1,\"983\":1}}],[\"遍历所有事件\",{\"1\":{\"834\":1,\"836\":1}}],[\"遍历目录文件\",{\"1\":{\"822\":1}}],[\"遍历链表\",{\"1\":{\"579\":1}}],[\"遍历整个文件\",{\"1\":{\"478\":1}}],[\"遍历步骤2中的小文件\",{\"1\":{\"477\":1}}],[\"遍历第一个文件\",{\"1\":{\"477\":1}}],[\"遍历结束后\",{\"1\":{\"477\":1}}],[\"遍历properties集合对象\",{\"1\":{\"42\":1}}],[\"题目描述\",{\"0\":{\"476\":1}}],[\"依然会有bug\",{\"1\":{\"1141\":1}}],[\"依次内推\",{\"1\":{\"1176\":1}}],[\"依次按照\",{\"1\":{\"787\":1}}],[\"依次反复\",{\"1\":{\"634\":1}}],[\"依次递归\",{\"1\":{\"623\":1}}],[\"依旧建议将metastore放在hive中\",{\"1\":{\"474\":1}}],[\"依赖的前提下\",{\"1\":{\"1443\":1}}],[\"依赖的关系为\",{\"1\":{\"104\":1}}],[\"依赖注入阶段执行\",{\"1\":{\"1505\":1}}],[\"依赖注入阶段执行的方法\",{\"1\":{\"1505\":1}}],[\"依赖注入和初始化影响的是原始对象\",{\"1\":{\"1480\":1}}],[\"依赖注入与初始化不应该被增强\",{\"1\":{\"1336\":1}}],[\"依赖注入前\",{\"1\":{\"1336\":1}}],[\"依赖注入前的增强\",{\"1\":{\"1254\":1}}],[\"依赖注入仅发生了一次\",{\"1\":{\"1294\":1}}],[\"依赖注入\",{\"1\":{\"1252\":1,\"1257\":1,\"1264\":1,\"1472\":1}}],[\"依赖库\",{\"0\":{\"1192\":1}}],[\"依赖库和资源文件等转换成可执行或可部署的应用程序的过程\",{\"1\":{\"94\":1,\"102\":1}}],[\"依赖服务器时间\",{\"1\":{\"1000\":1}}],[\"依赖关系\",{\"1\":{\"440\":1}}],[\"依赖路径长度相同情况下\",{\"1\":{\"105\":1}}],[\"依赖其他两个依赖\",{\"1\":{\"104\":1}}],[\"依赖传递关系\",{\"1\":{\"104\":1}}],[\"依赖传递终止\",{\"1\":{\"104\":1}}],[\"依赖冲突避免出现重复依赖\",{\"1\":{\"105\":1}}],[\"依赖冲突\",{\"1\":{\"104\":1}}],[\"依赖项的版本号或配置文件中的版本号错误\",{\"1\":{\"101\":1}}],[\"依赖对于编译\",{\"1\":{\"100\":1}}],[\"依赖只有在测试阶段才需要\",{\"1\":{\"100\":1}}],[\"依赖在上述三种\",{\"1\":{\"100\":1}}],[\"依赖版本统一提取和维护\",{\"1\":{\"99\":1}}],[\"依赖版本管理等\",{\"1\":{\"91\":1}}],[\"依赖范围\",{\"0\":{\"100\":1},\"1\":{\"99\":1,\"100\":1}}],[\"依赖信息查询方式\",{\"1\":{\"99\":1}}],[\"依赖本地缓存位置\",{\"1\":{\"92\":1}}],[\"依赖管理和依赖添加\",{\"1\":{\"99\":1}}],[\"依赖管理是\",{\"1\":{\"97\":1}}],[\"依赖管理概念\",{\"0\":{\"97\":1}}],[\"依赖管理\",{\"1\":{\"91\":2,\"112\":1}}],[\"依赖管理的工具\",{\"1\":{\"91\":1}}],[\"依赖倒转原则\",{\"0\":{\"74\":1}}],[\"依赖\",{\"1\":{\"73\":1,\"100\":4,\"104\":6,\"723\":1,\"1466\":2}}],[\"面试\",{\"1\":{\"651\":1}}],[\"面对join产生的数据倾斜\",{\"1\":{\"467\":1}}],[\"面向业务定制提供给产品和数据分析使用的数据\",{\"1\":{\"227\":1}}],[\"面向最终用户\",{\"1\":{\"227\":1}}],[\"面向对象的开发很好的解决了这个问题\",{\"1\":{\"74\":1}}],[\"面向对象中的继承性的思考和说明\",{\"1\":{\"73\":1}}],[\"根本就不用等下单逻辑走完\",{\"1\":{\"1155\":1}}],[\"根本原因是因为分区规则导致的\",{\"1\":{\"463\":1}}],[\"根节点是黑色\",{\"1\":{\"656\":1}}],[\"根据监听器方法参数确定事件类型\",{\"1\":{\"1493\":1}}],[\"根据接口泛型确定事件类型\",{\"1\":{\"1493\":1}}],[\"根据接口生成的\",{\"1\":{\"1280\":1}}],[\"根据此类型找到多个\",{\"1\":{\"1489\":2}}],[\"根据一个固定为\",{\"1\":{\"1411\":1}}],[\"根据一个或多个列对结果集进行分组\",{\"1\":{\"306\":1}}],[\"根据状态码去找\",{\"1\":{\"1411\":1}}],[\"根据他俩创建\",{\"1\":{\"1340\":1}}],[\"根据\",{\"1\":{\"1252\":2,\"1322\":1,\"1370\":1,\"1438\":1}}],[\"根据多个key获取多个string类型的value\",{\"1\":{\"1206\":1}}],[\"根据多态的特性\",{\"1\":{\"59\":1}}],[\"根据key获取string类型的value\",{\"1\":{\"1206\":1}}],[\"根据用户id查询用户\",{\"1\":{\"1162\":1}}],[\"根据用户查询\",{\"1\":{\"1161\":1,\"1165\":1}}],[\"根据用户名获取\",{\"1\":{\"701\":1}}],[\"根据指定的key查询缓存\",{\"1\":{\"1129\":4}}],[\"根据指定字段分组\",{\"1\":{\"313\":1}}],[\"根据id查询shop\",{\"1\":{\"1172\":1}}],[\"根据id查询博主的探店笔记\",{\"1\":{\"1165\":1}}],[\"根据id查询用户信息\",{\"1\":{\"1165\":1}}],[\"根据id查询用户\",{\"1\":{\"1165\":1}}],[\"根据id查询blog\",{\"1\":{\"1161\":1,\"1168\":1}}],[\"根据id查询数据库\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":2}}],[\"根据id查询店铺时\",{\"1\":{\"1122\":1}}],[\"根据id修改店铺时\",{\"1\":{\"1122\":1}}],[\"根据手机号查询用户\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"根据经验mysql企业级服务器只要上点并发\",{\"1\":{\"1094\":1}}],[\"根据局部的offset\",{\"1\":{\"1052\":1}}],[\"根据局部性原理\",{\"1\":{\"192\":1}}],[\"根据时间做的索引\",{\"1\":{\"1052\":1}}],[\"根据业务情况来选择ack机制\",{\"1\":{\"1043\":1}}],[\"根据业务需求而变\",{\"1\":{\"1004\":2}}],[\"根据业务需求进行手动设置\",{\"1\":{\"977\":1}}],[\"根据订单数据中的商品id在我们的缓存集合中找出对应的商品名称及相关信息\",{\"1\":{\"990\":1}}],[\"根据文件名进行判断\",{\"1\":{\"988\":1}}],[\"根据文件名来判断当前处理的是订单数据还是商品数据\",{\"1\":{\"988\":1}}],[\"根据cases进行倒序排序\",{\"1\":{\"974\":1}}],[\"根据coct找到chct\",{\"1\":{\"213\":1}}],[\"根据分隔符进行切割\",{\"1\":{\"958\":1,\"983\":1}}],[\"根据分桶字段进行抽样\",{\"1\":{\"369\":1}}],[\"根据容量\",{\"1\":{\"945\":1}}],[\"根据rm命令\",{\"1\":{\"944\":1}}],[\"根据namenode的指令\",{\"1\":{\"903\":1}}],[\"根据虚引用释放堆外内存\",{\"1\":{\"855\":1}}],[\"根据消息类型字节\",{\"1\":{\"723\":1}}],[\"根据上述分析\",{\"1\":{\"1307\":1}}],[\"根据上面的要素\",{\"1\":{\"713\":1}}],[\"根据上一局的手势从概率上计算出下一局的手势从这前的猜拳结果计算下一局出各种拳的概率\",{\"1\":{\"81\":1}}],[\"根据字符串的长度大小\",{\"1\":{\"665\":1}}],[\"根据得到的哈希值\",{\"1\":{\"659\":1}}],[\"根据该字符串是否在常量池中存在\",{\"1\":{\"632\":1}}],[\"根据锁的粒度进行分类\",{\"0\":{\"509\":1}}],[\"根据锁的类型分类\",{\"0\":{\"508\":1}}],[\"根据实际文本区分度决定索引长度\",{\"1\":{\"493\":1}}],[\"根据实际文本区分度决定索引长度即可\",{\"1\":{\"481\":1}}],[\"根据墨菲定律\",{\"1\":{\"481\":1}}],[\"根据mapreduce的hash分区规则\",{\"1\":{\"463\":1}}],[\"根据不同场景所需要付出的代价来合适选择优化的方案\",{\"1\":{\"457\":1}}],[\"根据设定好的规则来对程序进行优化\",{\"1\":{\"456\":1}}],[\"根据设备类型选择调用相应的驱动程序\",{\"1\":{\"210\":1}}],[\"根据对应的规则的数据进行join\",{\"1\":{\"450\":1}}],[\"根据查询的条件\",{\"1\":{\"415\":1}}],[\"根据查询的需求\",{\"1\":{\"415\":1}}],[\"根据需求可以获取指定时间范围状态的数据\",{\"1\":{\"405\":1}}],[\"根据整行数据进行抽样\",{\"1\":{\"369\":1}}],[\"根据数据大小抽样\",{\"1\":{\"368\":1}}],[\"根据数据大小百分比抽样\",{\"1\":{\"368\":1}}],[\"根据行数抽样\",{\"1\":{\"368\":1}}],[\"根据pv倒序排序\",{\"1\":{\"364\":1}}],[\"根据group\",{\"1\":{\"352\":1}}],[\"根据年份倒序排序\",{\"1\":{\"349\":1}}],[\"根据验证结果\",{\"1\":{\"332\":1}}],[\"根据sex进行分组\",{\"1\":{\"313\":1}}],[\"根据sdt找到dct\",{\"1\":{\"213\":1}}],[\"根据hdfs原始文件和delta增量文件做合并\",{\"1\":{\"292\":1}}],[\"根据表的某个字段进行hash求值\",{\"1\":{\"263\":1}}],[\"根据dct找到coct\",{\"1\":{\"213\":1}}],[\"根据进程请求的物理设备名查找sdt\",{\"1\":{\"213\":1}}],[\"根据进程的大小动态建立分区\",{\"1\":{\"182\":1}}],[\"根据各条记录的长度\",{\"1\":{\"195\":1}}],[\"根据拆分的很多个页表建立页目录表\",{\"1\":{\"186\":1}}],[\"根据常在系统中运行的作业大小情况进行划分\",{\"1\":{\"182\":1}}],[\"根据内存的当前情况\",{\"1\":{\"179\":1}}],[\"根据优先级是否可以动态改变\",{\"1\":{\"167\":1}}],[\"根据中断信号类型转入相应的中断处理程序\",{\"1\":{\"157\":1}}],[\"根据依赖的gav属性依次向下查找文件夹\",{\"1\":{\"101\":1}}],[\"根据依赖倒转原则进行改进\",{\"1\":{\"74\":1}}],[\"根据键获取值\",{\"1\":{\"42\":1}}],[\"迟迟不能结束\",{\"1\":{\"462\":1}}],[\"规范环境键名称\",{\"1\":{\"1446\":1}}],[\"规整的话使用碰撞指针否则使用空闲列表\",{\"1\":{\"630\":1}}],[\"规约\",{\"0\":{\"620\":1}}],[\"规则\",{\"0\":{\"461\":1}}],[\"规定每个进程必须按照编号递增的顺序请求资源\",{\"1\":{\"176\":1}}],[\"规定了具体原型对象必须实现的的\",{\"1\":{\"50\":1}}],[\"规定要实现复杂对象的哪些部分的创建\",{\"1\":{\"13\":1}}],[\"谓词\",{\"1\":{\"459\":1}}],[\"谓词下推可按上述结论2和3自由组合\",{\"1\":{\"461\":1}}],[\"谓词下推predicate\",{\"1\":{\"459\":1}}],[\"谓词下推\",{\"0\":{\"459\":1}}],[\"条消息写入成功\",{\"1\":{\"1023\":1}}],[\"条带化的hdfs文件在逻辑上由block\",{\"1\":{\"875\":1}}],[\"条数\",{\"1\":{\"457\":1}}],[\"条件成立\",{\"1\":{\"1466\":1}}],[\"条件装配的底层是本质上是\",{\"1\":{\"1466\":1}}],[\"条件装配底层\",{\"0\":{\"1466\":1}}],[\"条件映射\",{\"1\":{\"1425\":1}}],[\"条件查询+分页\",{\"1\":{\"1089\":1}}],[\"条件查询\",{\"0\":{\"1076\":1},\"1\":{\"1076\":1}}],[\"条件过滤是非常可怕的\",{\"1\":{\"493\":1}}],[\"条件创建索引\",{\"1\":{\"493\":1}}],[\"条件列检索出来这条记录\",{\"1\":{\"493\":1}}],[\"条件列\",{\"1\":{\"493\":1}}],[\"条件中经常被使用到\",{\"1\":{\"493\":1}}],[\"条件\",{\"1\":{\"481\":1}}],[\"条件写在on后面\",{\"1\":{\"461\":1}}],[\"条件1\",{\"1\":{\"380\":1}}],[\"条件转换函数\",{\"1\":{\"340\":2}}],[\"条件函数\",{\"0\":{\"340\":1}}],[\"共\",{\"1\":{\"1174\":1}}],[\"共同关注\",{\"0\":{\"1165\":1}}],[\"共同使用\",{\"1\":{\"841\":1}}],[\"共同点\",{\"1\":{\"595\":1,\"683\":1,\"892\":1}}],[\"共1000条数据\",{\"1\":{\"455\":1}}],[\"共享模式下使用\",{\"1\":{\"585\":2}}],[\"共享变量\",{\"1\":{\"563\":1}}],[\"共享锁允许同时多个线程占有\",{\"1\":{\"582\":1}}],[\"共享锁\",{\"1\":{\"508\":1,\"510\":1}}],[\"共享锁和排他锁既可以加在表上\",{\"1\":{\"508\":1}}],[\"共享设备\",{\"1\":{\"213\":1}}],[\"共享打印机原理分析\",{\"1\":{\"212\":1}}],[\"共享的数据结构\",{\"1\":{\"173\":1}}],[\"共享存储\",{\"1\":{\"162\":1}}],[\"共享\",{\"1\":{\"155\":2}}],[\"桶的个数相等或者成倍数\",{\"1\":{\"450\":2}}],[\"桶个数\",{\"1\":{\"237\":1}}],[\"延用了mapreduce中的设计\",{\"1\":{\"444\":1}}],[\"延迟\",{\"1\":{\"1482\":1}}],[\"延迟加载配置是全局开启的\",{\"1\":{\"1230\":1}}],[\"延迟发送\",{\"1\":{\"694\":1}}],[\"延迟构建索引\",{\"1\":{\"423\":1}}],[\"延迟时间和传输时间都与磁盘转速相关\",{\"1\":{\"204\":1}}],[\"延迟时间tr​\",{\"1\":{\"204\":1}}],[\"辅助用户对hive进行优化\",{\"1\":{\"440\":1}}],[\"便于代码的维护\",{\"1\":{\"1528\":1}}],[\"便于减少系统的重复代码\",{\"1\":{\"1500\":1}}],[\"便于map方法中的join操作\",{\"1\":{\"990\":1}}],[\"便于后续mapper处理数据\",{\"1\":{\"990\":1}}],[\"便于后续join关联拼接数据\",{\"1\":{\"988\":1}}],[\"便于处理\",{\"1\":{\"723\":1}}],[\"便与对应的\",{\"1\":{\"953\":1}}],[\"便发出缺页\",{\"1\":{\"688\":1}}],[\"便可使一个大的用户程序在较小的内存空间中运行\",{\"1\":{\"688\":1}}],[\"便可继续执行下去\",{\"1\":{\"688\":1}}],[\"便可以利用undo\",{\"1\":{\"506\":1}}],[\"便表示所要访问的页表项在快表中\",{\"1\":{\"683\":1}}],[\"便获取事件然后针对每个事件进行相应的处理\",{\"1\":{\"610\":1}}],[\"便会建立row\",{\"1\":{\"437\":1}}],[\"便产生一个缺页中断\",{\"1\":{\"190\":1}}],[\"鉴于磁盘i\",{\"1\":{\"432\":1}}],[\"鉴于使用其会导致项目的可移植性降低\",{\"1\":{\"100\":1}}],[\"选参数\",{\"1\":{\"875\":1}}],[\"选用了textfile作为默认的格式\",{\"1\":{\"427\":1}}],[\"选择走\",{\"1\":{\"1370\":1}}],[\"选择库\",{\"1\":{\"1213\":1,\"1216\":1}}],[\"选择在hadoop中是否启用磁盘平衡器\",{\"1\":{\"874\":1}}],[\"选择客户\",{\"1\":{\"785\":1}}],[\"选择服务\",{\"1\":{\"784\":1}}],[\"选择现有页面中其t值最大的淘汰\",{\"1\":{\"690\":1}}],[\"选择现有页面中t值的最大的\",{\"1\":{\"191\":1}}],[\"选择\",{\"1\":{\"649\":2,\"1202\":1}}],[\"选择排序\",{\"0\":{\"643\":1}}],[\"选择器\",{\"1\":{\"610\":1}}],[\"选择响应比最高的作业\",{\"1\":{\"167\":1}}],[\"选择自己喜欢的配件\",{\"1\":{\"74\":1}}],[\"选择cpu有很多选择\",{\"1\":{\"74\":1}}],[\"几乎无消耗\",{\"1\":{\"855\":1}}],[\"几乎不能正常工作\",{\"1\":{\"826\":1}}],[\"几乎所有的原始数据生成都是textfile格式\",{\"1\":{\"427\":1}}],[\"几个分组\",{\"1\":{\"201\":1}}],[\"几个常用的数量单位\",{\"1\":{\"179\":1}}],[\"过期后自动释放\",{\"1\":{\"1142\":1}}],[\"过期时间单位\",{\"1\":{\"1129\":2}}],[\"过期时间\",{\"1\":{\"1129\":2}}],[\"过期数据删除策略\",{\"0\":{\"520\":1}}],[\"过一会再进行尝试\",{\"1\":{\"1127\":1}}],[\"过程会对\",{\"1\":{\"1038\":1}}],[\"过长的主键索引会令二级索引变得过大\",{\"1\":{\"489\":1}}],[\"过滤器时能用上\",{\"1\":{\"1346\":1}}],[\"过滤掉小于0的\",{\"1\":{\"718\":1}}],[\"过滤后的数据依旧是一张大表\",{\"1\":{\"469\":1}}],[\"过滤条件会下推到map端\",{\"1\":{\"459\":1}}],[\"过滤等操作\",{\"1\":{\"420\":1}}],[\"过滤每个部门的薪资最高的前两名\",{\"1\":{\"404\":1}}],[\"过于繁琐\",{\"1\":{\"375\":1}}],[\"过于复杂\",{\"1\":{\"14\":1}}],[\"搭建\",{\"0\":{\"1012\":1}}],[\"搭建一个电商平台项目\",{\"1\":{\"110\":1}}],[\"搭配cbo引擎一起使用\",{\"1\":{\"458\":1}}],[\"搭配侧视图使用\",{\"1\":{\"396\":1}}],[\"列举一些重要的spring模块\",{\"0\":{\"1499\":1}}],[\"列适合查询\",{\"1\":{\"995\":1}}],[\"列存储在写入效率\",{\"1\":{\"995\":1}}],[\"列式存储\",{\"0\":{\"995\":1}}],[\"列出在hdfs中注册的所有\",{\"1\":{\"875\":1}}],[\"列出需要被授权的条目\",{\"1\":{\"441\":1}}],[\"列名\",{\"1\":{\"481\":1,\"482\":3,\"493\":1}}],[\"列的信息\",{\"1\":{\"458\":1}}],[\"列转行\",{\"0\":{\"386\":1,\"389\":1}}],[\"列\",{\"1\":{\"380\":1}}],[\"列之间用\",{\"1\":{\"290\":1}}],[\"专门用于访问数据库\",{\"1\":{\"1529\":1}}],[\"专门用于搭配explode这样的udtf函数\",{\"1\":{\"348\":1}}],[\"专门处理\",{\"1\":{\"846\":1}}],[\"专门提供了解析url的函数parse\",{\"1\":{\"376\":1}}],[\"性别\",{\"1\":{\"374\":1}}],[\"性能较低\",{\"1\":{\"1350\":1}}],[\"性能较高\",{\"1\":{\"1298\":1}}],[\"性能自然会好一些\",{\"1\":{\"1189\":1}}],[\"性能好\",{\"1\":{\"1126\":1}}],[\"性能是最差的\",{\"1\":{\"1043\":1}}],[\"性能是最好的\",{\"1\":{\"1043\":1}}],[\"性能优化\",{\"0\":{\"993\":1}}],[\"性能优化及\",{\"0\":{\"411\":1}}],[\"性能没有优势\",{\"1\":{\"856\":1}}],[\"性能没有longadder高\",{\"1\":{\"564\":1}}],[\"性能提升的原因很简单\",{\"1\":{\"564\":1}}],[\"性能相对较低\",{\"1\":{\"558\":1}}],[\"性能会更好\",{\"1\":{\"504\":1}}],[\"性能差\",{\"1\":{\"501\":1}}],[\"性能上有提高\",{\"1\":{\"461\":2}}],[\"性能上面没有区别\",{\"1\":{\"461\":1}}],[\"性能\",{\"1\":{\"66\":1}}],[\"性能和安全要求比较高\",{\"1\":{\"53\":1}}],[\"歌手名称\",{\"1\":{\"374\":1}}],[\"歌手id\",{\"1\":{\"374\":1}}],[\"替换原来的位置\",{\"1\":{\"1230\":1}}],[\"替换后的内容作为key\",{\"1\":{\"373\":1}}],[\"替换分隔符\",{\"0\":{\"373\":1}}],[\"替换列\",{\"1\":{\"279\":1}}],[\"效率不高\",{\"1\":{\"1205\":1}}],[\"效率几乎是原来的四倍\",{\"1\":{\"755\":1}}],[\"效率提升\",{\"1\":{\"680\":1}}],[\"效率较低\",{\"1\":{\"680\":1}}],[\"效率会很低\",{\"1\":{\"506\":1}}],[\"效率就非常的低下\",{\"1\":{\"481\":1}}],[\"效率更高\",{\"1\":{\"369\":2,\"962\":1}}],[\"效率高\",{\"1\":{\"163\":1,\"820\":2,\"1000\":1}}],[\"获得\",{\"1\":{\"1340\":1}}],[\"获得age\",{\"1\":{\"1206\":1}}],[\"获得当前这个月的最后一次签到数据\",{\"1\":{\"1176\":1}}],[\"获得当前线程\",{\"1\":{\"1152\":1}}],[\"获得到当前这一天的位数\",{\"1\":{\"1176\":1}}],[\"获得到当前笔记的粉丝\",{\"1\":{\"1167\":1}}],[\"获得到正确的\",{\"1\":{\"753\":1}}],[\"获得了锁的线程他会开启一个\",{\"1\":{\"1126\":1}}],[\"获得对应的消息\",{\"1\":{\"723\":1}}],[\"获得锁之后\",{\"1\":{\"506\":1}}],[\"获得随机数据块的前1k数据\",{\"1\":{\"368\":1}}],[\"获得随机数据块的前50\",{\"1\":{\"368\":1}}],[\"获得随机数据块的第一行数据\",{\"1\":{\"368\":1}}],[\"获取监听器的参数配置\",{\"1\":{\"1522\":1}}],[\"获取泛型参数\",{\"0\":{\"1377\":1},\"1\":{\"1379\":2}}],[\"获取方法上注解信息\",{\"1\":{\"1277\":1}}],[\"获取类名\",{\"1\":{\"1274\":1}}],[\"获取类型id\",{\"1\":{\"1171\":1}}],[\"获取直接或间接标注的注解信息\",{\"1\":{\"1274\":1}}],[\"获取传递的参数\",{\"1\":{\"1232\":1}}],[\"获取参数方法\",{\"1\":{\"1232\":1}}],[\"获取数据\",{\"1\":{\"1213\":1,\"1223\":1}}],[\"获取一个hash类型的key中的所有的field\",{\"1\":{\"1208\":1}}],[\"获取一个hash类型的key中的所有的field和value\",{\"1\":{\"1208\":1}}],[\"获取一个hash类型key的field的值\",{\"1\":{\"1208\":1}}],[\"获取本月截止今天为止的所有的签到记录\",{\"1\":{\"1176\":1}}],[\"获取今天是本月的第几天\",{\"1\":{\"1175\":1,\"1176\":1}}],[\"获取日期\",{\"1\":{\"1175\":1,\"1176\":1}}],[\"获取距离\",{\"1\":{\"1172\":1}}],[\"获取店铺id\",{\"1\":{\"1172\":1}}],[\"获取同类型的店铺的集合\",{\"1\":{\"1171\":1}}],[\"获取分数\",{\"1\":{\"1168\":1}}],[\"获取id\",{\"1\":{\"1168\":1}}],[\"获取粉丝id\",{\"1\":{\"1167\":1}}],[\"获取登录用户\",{\"1\":{\"1159\":1,\"1161\":1,\"1162\":2,\"1167\":1}}],[\"获取原始文件名称\",{\"1\":{\"1159\":1}}],[\"获取用户\",{\"1\":{\"1157\":1}}],[\"获取队列中的订单信息\",{\"1\":{\"1157\":1}}],[\"获取缓存的id\",{\"1\":{\"1144\":1}}],[\"获取锁的最大等待时间\",{\"1\":{\"1150\":1}}],[\"获取锁中的标示\",{\"1\":{\"1146\":1}}],[\"获取锁中的线程标示\",{\"1\":{\"1146\":1}}],[\"获取锁时添加一个超时时间\",{\"1\":{\"1141\":1}}],[\"获取锁\",{\"1\":{\"1141\":1,\"1150\":1,\"1151\":1}}],[\"获取锁成功\",{\"1\":{\"1129\":1}}],[\"获取锁失败\",{\"1\":{\"1129\":1,\"1151\":1,\"1157\":1}}],[\"获取锁失败的线程都将进入到这个队列中排队\",{\"1\":{\"583\":1}}],[\"获取string数据\",{\"1\":{\"1221\":1,\"1223\":1}}],[\"获取sorted\",{\"1\":{\"1211\":3}}],[\"获取set中的所有元素\",{\"1\":{\"1210\":1}}],[\"获取session中的用户\",{\"1\":{\"1100\":1}}],[\"获取session\",{\"1\":{\"1100\":1}}],[\"获取singleton类的私有无参构造方法对象\",{\"1\":{\"68\":1}}],[\"获取singleton类的字节码对象\",{\"1\":{\"68\":1}}],[\"获取singleton类的对象\",{\"1\":{\"68\":1}}],[\"获取头信息\",{\"1\":{\"1004\":1}}],[\"获取指定名称的bean\",{\"1\":{\"1502\":1}}],[\"获取指定score范围内的元素\",{\"1\":{\"1211\":1}}],[\"获取指定排名范围内的元素\",{\"1\":{\"1211\":1}}],[\"获取指定位置\",{\"1\":{\"1174\":1}}],[\"获取指定时间戳的接下来的时间戳\",{\"1\":{\"999\":1}}],[\"获取指定路径下文件或目录的擦除编码策略的详细信息\",{\"1\":{\"875\":1}}],[\"获取两个key的交集\",{\"1\":{\"1165\":1}}],[\"获取两个集合的长度\",{\"1\":{\"988\":1}}],[\"获取两个计数器\",{\"1\":{\"986\":1}}],[\"获取切面所属文件名称\",{\"1\":{\"988\":1}}],[\"获取各个\",{\"1\":{\"949\":1}}],[\"获取到edek会被nn保存到文件的元数据中\",{\"1\":{\"934\":1}}],[\"获取到对应的\",{\"1\":{\"723\":1}}],[\"获取系统中支持的擦除编码编解码器和编码器的列表\",{\"1\":{\"875\":1}}],[\"获取这些\",{\"1\":{\"867\":1}}],[\"获取所有事件\",{\"1\":{\"834\":1,\"836\":1}}],[\"获取的是工厂对象\",{\"1\":{\"1472\":1}}],[\"获取的\",{\"1\":{\"813\":2}}],[\"获取失败信息\",{\"1\":{\"756\":1}}],[\"获取任务结果\",{\"1\":{\"756\":2}}],[\"获取唯一的\",{\"1\":{\"737\":1}}],[\"获取要调用的方法\",{\"1\":{\"734\":1}}],[\"获取真正的实现对象\",{\"1\":{\"734\":1}}],[\"获取\",{\"0\":{\"813\":1},\"1\":{\"733\":1,\"754\":1,\"785\":1,\"840\":1,\"1174\":1,\"1213\":1,\"1438\":1,\"1485\":1}}],[\"获取内容的字节数组\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"获取请求头中的token\",{\"1\":{\"1111\":1}}],[\"获取请求\",{\"1\":{\"711\":1}}],[\"获取组成员的\",{\"1\":{\"701\":1}}],[\"获取组成员\",{\"1\":{\"701\":1}}],[\"获取属性\",{\"1\":{\"701\":1}}],[\"获取字符串长度的时间复杂度为\",{\"1\":{\"662\":1}}],[\"获取字节码对象\",{\"1\":{\"42\":1}}],[\"获取共享锁可中断\",{\"1\":{\"585\":1}}],[\"获取共享锁\",{\"1\":{\"585\":1}}],[\"获取互斥锁后\",{\"1\":{\"1127\":1}}],[\"获取互斥锁可中断\",{\"1\":{\"585\":1}}],[\"获取互斥锁\",{\"1\":{\"585\":1,\"1127\":1,\"1128\":1,\"1129\":2}}],[\"获取元素的线程阻塞在notempty条件上\",{\"1\":{\"584\":1}}],[\"获取并计算\",{\"1\":{\"562\":1}}],[\"获取并更新\",{\"1\":{\"562\":1}}],[\"获取并加值\",{\"1\":{\"562\":1}}],[\"获取并自减\",{\"1\":{\"562\":1}}],[\"获取并自增\",{\"1\":{\"562\":1}}],[\"获取静态变量i的值\",{\"1\":{\"560\":1}}],[\"获取时间\",{\"1\":{\"395\":1}}],[\"获取设备信号强度\",{\"1\":{\"395\":1}}],[\"获取设备类型\",{\"1\":{\"395\":1}}],[\"获取设备名称\",{\"1\":{\"395\":1}}],[\"获取每条数据\",{\"1\":{\"373\":1}}],[\"获取当前登录用户\",{\"1\":{\"1175\":1,\"1176\":1}}],[\"获取当前用户\",{\"1\":{\"1168\":1}}],[\"获取当前用户id\",{\"1\":{\"1161\":1,\"1164\":1,\"1165\":2}}],[\"获取当前页数据\",{\"1\":{\"1161\":1,\"1165\":1}}],[\"获取当前线程的id\",{\"1\":{\"1142\":1,\"1144\":2}}],[\"获取当前url所支持的方法\",{\"1\":{\"1004\":1}}],[\"获取当前unix时间戳函数\",{\"1\":{\"337\":2}}],[\"获取当前处理的切面所属的文件名称\",{\"1\":{\"988\":1}}],[\"获取当前位置\",{\"1\":{\"817\":1}}],[\"获取当前时间戳\",{\"1\":{\"337\":2}}],[\"获取当前日期\",{\"1\":{\"337\":2,\"1132\":1}}],[\"获取下一局要出的手势\",{\"1\":{\"81\":1}}],[\"获取命令执行后的结果\",{\"1\":{\"70\":1}}],[\"获取runtime类对象\",{\"1\":{\"70\":1}}],[\"获取代理对象\",{\"1\":{\"59\":2,\"60\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1157\":1}}],[\"获取c2奖状所属学生对象\",{\"1\":{\"54\":2}}],[\"获取现在状态\",{\"1\":{\"46\":1}}],[\"获取集合中的元素\",{\"1\":{\"43\":1}}],[\"获取迭代器对象\",{\"1\":{\"43\":1}}],[\"采样粒度是hdfs块大小\",{\"1\":{\"368\":1}}],[\"采用cglib比较合适\",{\"1\":{\"1512\":1}}],[\"采用cas配上失败重试的方式保证操作的原子性\",{\"1\":{\"630\":1}}],[\"采用cas失败重试\",{\"1\":{\"630\":1}}],[\"采用cas主线程仅能判断出共享变量的值与初值a是否相同\",{\"1\":{\"563\":1}}],[\"采用双引号进行拼接\",{\"1\":{\"1230\":1}}],[\"采用双缓冲策略\",{\"1\":{\"214\":1}}],[\"采用mysql自带的concat函数进行拼接\",{\"1\":{\"1230\":1}}],[\"采用$\",{\"1\":{\"1230\":1}}],[\"采用in来进行批量删除时只能采用$\",{\"1\":{\"1230\":1}}],[\"采用这种方式来处理\",{\"1\":{\"1177\":1}}],[\"采用这种方法后\",{\"1\":{\"697\":1}}],[\"采用消息队列对阻塞队列进行改写\",{\"1\":{\"1157\":1}}],[\"采用的就是timeline的方式\",{\"1\":{\"1166\":1}}],[\"采用的就是这种模式\",{\"1\":{\"548\":1}}],[\"采用的核心思路就是书写一个userdto对象\",{\"1\":{\"1101\":1}}],[\"采用waitforcompletion参数表示是否开启实时监视追踪作业的执行情况\",{\"1\":{\"962\":1}}],[\"采用轮询方式\",{\"1\":{\"680\":1}}],[\"采用了proactor模式\",{\"1\":{\"611\":1}}],[\"采用固定加锁的顺序\",{\"1\":{\"551\":1}}],[\"采用行级锁和mvcc机制\",{\"1\":{\"497\":1}}],[\"采用分治的思想\",{\"1\":{\"477\":1}}],[\"采用单缓冲策略\",{\"1\":{\"214\":1}}],[\"采用spooling技术将独占设备改造成虚拟的共享设备\",{\"1\":{\"213\":1}}],[\"采用k层索引结构\",{\"1\":{\"197\":1}}],[\"采用两级目录结构\",{\"1\":{\"196\":1}}],[\"采用虚拟内存技术的系统中\",{\"1\":{\"192\":1}}],[\"采用\",{\"1\":{\"180\":1,\"1023\":1,\"1317\":1}}],[\"采用顺序资源分配法\",{\"1\":{\"176\":1}}],[\"采用静态分配方法\",{\"1\":{\"176\":1}}],[\"采用动态优先级\",{\"1\":{\"167\":1}}],[\"采用组合或聚合复用时\",{\"1\":{\"77\":1}}],[\"采用抽象工厂模式则是不需要关心构建过程\",{\"1\":{\"20\":1}}],[\"百度\",{\"1\":{\"633\":1,\"874\":1}}],[\"百分比数据或指定大小的数据\",{\"1\":{\"368\":1}}],[\"百万\",{\"1\":{\"179\":1}}],[\"到底什么是\",{\"1\":{\"1243\":1}}],[\"到期释放\",{\"1\":{\"1140\":1}}],[\"到达服务器端\",{\"1\":{\"785\":1}}],[\"到关闭状态从而拒绝新的任务的加入\",{\"1\":{\"747\":1}}],[\"到再循环进来这个阶段新增的任务会不会及时执行呢\",{\"1\":{\"741\":1}}],[\"到\",{\"0\":{\"1330\":1},\"1\":{\"726\":1,\"743\":1,\"776\":1,\"795\":2,\"1444\":1}}],[\"到在内存中找到对应的实际物理地址单元并取出数据\",{\"1\":{\"683\":1}}],[\"到hive3\",{\"1\":{\"420\":1}}],[\"到当前最后一个值其实就是自己\",{\"1\":{\"365\":1}}],[\"到作业完成为止的这段时间间隔\",{\"1\":{\"166\":1}}],[\"业务号\",{\"1\":{\"1001\":1}}],[\"业务和整体排序相关的\",{\"1\":{\"970\":1}}],[\"业务和数据个数相关的\",{\"1\":{\"970\":1}}],[\"业务需要二外执行一次类似last\",{\"1\":{\"501\":1}}],[\"业务上具有唯一特性的字段\",{\"1\":{\"481\":1,\"493\":1}}],[\"业务名称\",{\"1\":{\"480\":1}}],[\"业务人员只关心其中的一部分\",{\"1\":{\"364\":1}}],[\"业务代码\",{\"1\":{\"344\":1}}],[\"挤占后续位置\",{\"1\":{\"363\":1}}],[\"考虑第\",{\"1\":{\"649\":2}}],[\"考虑第一件物品\",{\"1\":{\"648\":1}}],[\"考虑其余物品\",{\"1\":{\"648\":1}}],[\"考虑重复\",{\"1\":{\"363\":2}}],[\"考虑哪个进程先达到就绪队列\",{\"1\":{\"167\":1}}],[\"考虑哪个作业先到达后备队列\",{\"1\":{\"167\":1}}],[\"边界\",{\"1\":{\"361\":1}}],[\"边装入边链接\",{\"1\":{\"179\":1}}],[\"窗口关闭或者按下ctrl\",{\"1\":{\"1195\":1}}],[\"窗口就可以向前滑动\",{\"1\":{\"694\":1}}],[\"窗口必须停止滑动\",{\"1\":{\"694\":1}}],[\"窗口内的数据才允许被发送\",{\"1\":{\"694\":1}}],[\"窗口实际就起到一个缓冲区的作用\",{\"1\":{\"694\":1}}],[\"窗口大小即决定了无需等待应答而可以继续发送的数据最大值\",{\"1\":{\"694\":1}}],[\"窗口分析函数\",{\"0\":{\"365\":1}}],[\"窗口排序函数\",{\"0\":{\"362\":1}}],[\"窗口聚合函数\",{\"0\":{\"360\":1}}],[\"窗口表达式\",{\"0\":{\"361\":1},\"1\":{\"358\":1}}],[\"窗口\",{\"1\":{\"356\":1}}],[\"窗口函数sum默认就是从第一列到当前列求和\",{\"1\":{\"401\":1}}],[\"窗口函数lead\",{\"1\":{\"399\":1}}],[\"窗口函数应用实例\",{\"0\":{\"398\":1}}],[\"窗口函数语法树\",{\"1\":{\"358\":1}}],[\"窗口函数聚合\",{\"1\":{\"357\":1}}],[\"窗口函数聚合后还可以访问当中的各个行\",{\"1\":{\"356\":1}}],[\"窗口函数可以简单地解释为类似于聚合函数的计算函数\",{\"1\":{\"356\":1}}],[\"窗口函数\",{\"0\":{\"356\":1},\"1\":{\"356\":1}}],[\"窗口颜色和声音等元素的组合\",{\"1\":{\"72\":1}}],[\"增强逻辑\",{\"1\":{\"1310\":2}}],[\"增强\",{\"0\":{\"1400\":1},\"1\":{\"1307\":1,\"1401\":1,\"1438\":2}}],[\"增强id的复杂度\",{\"1\":{\"1124\":1}}],[\"增强聚合\",{\"0\":{\"352\":1}}],[\"增改查数据都会先加载到mysql的缓存中\",{\"1\":{\"1115\":1}}],[\"增量收集算法\",{\"0\":{\"634\":1}}],[\"增减字段容易与resultmap配置不一致\",{\"1\":{\"483\":1}}],[\"增加1\",{\"1\":{\"1206\":1}}],[\"增加一人一单逻辑\",{\"1\":{\"1137\":1}}],[\"增加配置类和配置文件\",{\"1\":{\"723\":1}}],[\"增加size计数\",{\"1\":{\"579\":1}}],[\"增加查询分析器解析成本\",{\"1\":{\"483\":1}}],[\"增加分区\",{\"1\":{\"280\":1}}],[\"增加对象间的耦合性\",{\"1\":{\"73\":1}}],[\"增加软件的可扩展性和灵活性\",{\"1\":{\"71\":1}}],[\"增加了cpu的l1\",{\"1\":{\"1115\":1}}],[\"增加了请求调段及分段置换功能后形成的段式虚拟存储系统\",{\"1\":{\"689\":1}}],[\"增加了三个元数据\",{\"1\":{\"663\":1}}],[\"增加了延迟时间\",{\"1\":{\"205\":1}}],[\"增加了灵活性\",{\"1\":{\"182\":1}}],[\"增加了用户编程的负担\",{\"1\":{\"181\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"62\":1}}],[\"增加了代码维护的复杂度\",{\"1\":{\"61\":1}}],[\"增加新产品时还是需要修改工厂类的代码\",{\"1\":{\"29\":1}}],[\"女\",{\"1\":{\"351\":2,\"1073\":2,\"1080\":1}}],[\"侧视图\",{\"0\":{\"349\":1}}],[\"错误原因>>>\",{\"1\":{\"1526\":2}}],[\"错误页处理\",{\"0\":{\"1412\":1}}],[\"错误页面之间是通过请求转发跳转的\",{\"1\":{\"1411\":1}}],[\"错误的\",{\"1\":{\"1230\":1}}],[\"错误的演示\",{\"1\":{\"348\":1}}],[\"错位命名\",{\"1\":{\"205\":1}}],[\"任何程序想要运行\",{\"1\":{\"1100\":1}}],[\"任何具有该目录写和执行权限的用户都可以删除和移动其中的文件\",{\"1\":{\"920\":1}}],[\"任何修改操作在active\",{\"1\":{\"886\":1}}],[\"任何场景下都适用的完美收集器存在\",{\"1\":{\"638\":1}}],[\"任何字段如果为非负数\",{\"1\":{\"480\":1}}],[\"任意一个线程执行计算\",{\"1\":{\"759\":1}}],[\"任意方法中获取缓存的数据\",{\"1\":{\"577\":1}}],[\"任意数据类型之间转换\",{\"1\":{\"341\":1}}],[\"任务分为普通任务\",{\"1\":{\"787\":1}}],[\"任务是否完成\",{\"1\":{\"756\":1}}],[\"任务是否取消\",{\"1\":{\"756\":1}}],[\"任务\",{\"1\":{\"741\":2,\"875\":1}}],[\"任务数多于\",{\"1\":{\"574\":1}}],[\"任务执行完毕\",{\"1\":{\"571\":1,\"574\":1}}],[\"任务可以不需要等到线程创建就直接运行\",{\"1\":{\"570\":1}}],[\"任我行\",{\"1\":{\"43\":1}}],[\"男女性别\",{\"1\":{\"493\":1}}],[\"男\",{\"1\":{\"340\":2,\"351\":4,\"1073\":3}}],[\"向set中添加一个或多个元素\",{\"1\":{\"1210\":1}}],[\"向列表右侧插入一个或多个元素\",{\"1\":{\"1209\":1}}],[\"向列表左侧插入一个或多个元素\",{\"1\":{\"1209\":1}}],[\"向hyperloglog中添加100万条数据\",{\"1\":{\"1180\":1}}],[\"向指定位置\",{\"1\":{\"1174\":1}}],[\"向namenode发送心跳\",{\"1\":{\"903\":1}}],[\"向量\",{\"1\":{\"875\":1}}],[\"向客户端发送内容\",{\"1\":{\"843\":1}}],[\"向\",{\"0\":{\"802\":1},\"1\":{\"796\":1,\"797\":1,\"809\":1,\"840\":1,\"948\":1,\"953\":2}}],[\"向下兼容性\",{\"1\":{\"792\":1}}],[\"向下取整函数\",{\"1\":{\"338\":2}}],[\"向假死的连接发送数据\",{\"1\":{\"707\":1}}],[\"向basecount累加计数\",{\"1\":{\"579\":1}}],[\"向表中加载数据时\",{\"1\":{\"437\":1}}],[\"向后台传入当前\",{\"1\":{\"1171\":1}}],[\"向后传递\",{\"1\":{\"775\":2}}],[\"向后偏移几行\",{\"1\":{\"399\":1}}],[\"向后3行\",{\"1\":{\"361\":1}}],[\"向前三行至当前行\",{\"1\":{\"361\":1}}],[\"向上取整函数\",{\"1\":{\"338\":2}}],[\"向上层提供统一的调用接口\",{\"1\":{\"210\":1}}],[\"带\",{\"1\":{\"1444\":1}}],[\"带参数绑定的通知方法调用\",{\"0\":{\"1348\":1}}],[\"带参的构造器\",{\"1\":{\"629\":1}}],[\"带来巨大压力\",{\"1\":{\"1125\":1}}],[\"带你了解一波\",{\"1\":{\"1002\":1}}],[\"带有group\",{\"1\":{\"351\":1}}],[\"带分隔符字符串连接函数\",{\"1\":{\"336\":2}}],[\"带权周转时间很大\",{\"1\":{\"167\":1}}],[\"带权周转时间与周转时间都是越小越好\",{\"1\":{\"166\":1}}],[\"带权周转时间肯定是大于1的\",{\"1\":{\"166\":1}}],[\"带权周转时间\",{\"1\":{\"166\":2}}],[\"功能的实现提供一些最基础的支持\",{\"1\":{\"1499\":1}}],[\"功能丰富\",{\"1\":{\"1190\":1}}],[\"功能演示\",{\"0\":{\"1174\":1}}],[\"功能一致\",{\"1\":{\"1170\":1}}],[\"功能介绍\",{\"0\":{\"1149\":1}}],[\"功能开启\",{\"0\":{\"910\":1}}],[\"功能描述\",{\"0\":{\"909\":1}}],[\"功能将它们调入内存\",{\"1\":{\"688\":1}}],[\"功能\",{\"1\":{\"399\":1,\"458\":1,\"756\":1,\"944\":1,\"1368\":1}}],[\"功能与rlike相同\",{\"1\":{\"330\":1}}],[\"功能和目标\",{\"1\":{\"154\":1}}],[\"^\",{\"1\":{\"330\":2,\"331\":3,\"342\":1,\"344\":1,\"374\":6}}],[\"^i\",{\"1\":{\"330\":2}}],[\"确诊病例\",{\"1\":{\"974\":1}}],[\"确诊病例数\",{\"1\":{\"972\":1}}],[\"确诊数\",{\"1\":{\"972\":1}}],[\"确定你是身份证上的本人\",{\"1\":{\"923\":1}}],[\"确定单次读取大小\",{\"1\":{\"744\":1}}],[\"确定具体消息类型\",{\"1\":{\"723\":1}}],[\"确定分界点x\",{\"1\":{\"645\":1}}],[\"确定该对象所属类型\",{\"1\":{\"631\":1}}],[\"确定字符串是否匹配正则表达式\",{\"1\":{\"330\":1}}],[\"确保只能执行一次\",{\"1\":{\"1215\":1}}],[\"确保只能有一个线程获取锁\",{\"1\":{\"1141\":1}}],[\"确保多条命令执行时的原子性\",{\"1\":{\"1146\":1}}],[\"确保事务不会出现问题\",{\"1\":{\"1137\":1}}],[\"确保leader是均匀分配的\",{\"1\":{\"1050\":1}}],[\"确保每个消费者消费的数据是一致的\",{\"1\":{\"1048\":1}}],[\"确保消息写入到leader分区\",{\"1\":{\"1043\":1}}],[\"确保要递归删除的文件夹没有重要内容\",{\"1\":{\"823\":1}}],[\"确保接到的\",{\"1\":{\"714\":1,\"723\":1}}],[\"确保这个原子引用没有引用过别人\",{\"1\":{\"562\":1}}],[\"确保依赖版本正确\",{\"1\":{\"104\":1}}],[\"确保依赖项的版本号与项目对应的版本号匹配\",{\"1\":{\"101\":1}}],[\"确认无误才能执行更新语句\",{\"1\":{\"482\":1}}],[\"往往形式松散\",{\"1\":{\"1185\":1}}],[\"往往用来衡量网站的流量\",{\"1\":{\"1179\":1}}],[\"往往是图文结合\",{\"1\":{\"1159\":1}}],[\"往往会先生成两个表行数乘积的行的数据表然后才根据where条件从中选择\",{\"1\":{\"325\":1}}],[\"往后\",{\"1\":{\"361\":1}}],[\"往前\",{\"1\":{\"361\":1}}],[\"往文件中写对象\",{\"1\":{\"68\":1}}],[\"右侧的表写在where后面\",{\"1\":{\"461\":1}}],[\"右侧的表写在on后面\",{\"1\":{\"461\":1}}],[\"右补足函数\",{\"1\":{\"336\":2}}],[\"右边去空格函数\",{\"1\":{\"336\":2}}],[\"右边与之关联\",{\"1\":{\"321\":1}}],[\"右表数据全部返回\",{\"1\":{\"322\":1}}],[\"右表关联上的显示返回\",{\"1\":{\"321\":1}}],[\"右连接\",{\"0\":{\"322\":1}}],[\"左侧的表写在on后面\",{\"1\":{\"461\":1}}],[\"左侧的表写在where后面\",{\"1\":{\"461\":1}}],[\"左补足函数\",{\"1\":{\"336\":2}}],[\"左边去空格函数\",{\"1\":{\"336\":2}}],[\"左边与之关联\",{\"1\":{\"322\":1}}],[\"左半开连接\",{\"0\":{\"324\":1},\"1\":{\"324\":1}}],[\"左表关联上的显示返回\",{\"1\":{\"322\":1}}],[\"左表数据全部返回\",{\"1\":{\"321\":1}}],[\"左连接\",{\"0\":{\"321\":1}}],[\"左右语法二选一\",{\"1\":{\"247\":1}}],[\"紧接在select或insert关键字之前\",{\"1\":{\"318\":1}}],[\"偶数分为一组\",{\"1\":{\"313\":1}}],[\"裁剪掉没有必要访问的分区\",{\"1\":{\"305\":1}}],[\"去调用它创建和运行\",{\"1\":{\"1442\":1}}],[\"去调用操作系统\",{\"1\":{\"854\":1}}],[\"去降低代的耦合\",{\"1\":{\"1215\":1}}],[\"去用相同的哈希算法\",{\"1\":{\"1177\":1}}],[\"去拿这段时间的数据\",{\"1\":{\"1176\":1}}],[\"去查询用户的笔记\",{\"1\":{\"1165\":1}}],[\"去查询用户的详情\",{\"1\":{\"1165\":1}}],[\"去描述什么时候去做参数1的事情\",{\"1\":{\"1152\":1}}],[\"去判断一下当前这把锁是否属于自己\",{\"1\":{\"1143\":1}}],[\"去执行关闭\",{\"1\":{\"755\":1}}],[\"去重\",{\"1\":{\"660\":2}}],[\"去重非常方便\",{\"1\":{\"659\":1}}],[\"去重且排序\",{\"1\":{\"386\":1}}],[\"去读大表的数据\",{\"1\":{\"448\":1}}],[\"去除重复元素\",{\"1\":{\"616\":1}}],[\"去除重复的结果\",{\"1\":{\"303\":1}}],[\"去除左右两边的空格\",{\"1\":{\"336\":1}}],[\"去空格函数\",{\"1\":{\"336\":2}}],[\"去银行办理业务一般要经过以下4个流程\",{\"1\":{\"83\":1}}],[\"`is\",{\"1\":{\"1174\":1}}],[\"`id`\",{\"1\":{\"1164\":2,\"1174\":2}}],[\"`date`\",{\"1\":{\"1174\":1}}],[\"`month`\",{\"1\":{\"1174\":1}}],[\"`map`\",{\"1\":{\"339\":4,\"347\":1}}],[\"`year`\",{\"1\":{\"1174\":1}}],[\"`create\",{\"1\":{\"1164\":1}}],[\"`follow\",{\"1\":{\"1164\":1}}],[\"`firstname`\",{\"1\":{\"495\":1}}],[\"`user\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"`tb\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"`time`\",{\"1\":{\"397\":1}}],[\"`下一个定时任务执行时间\",{\"1\":{\"742\":1}}],[\"`lastname`\",{\"1\":{\"495\":1}}],[\"`zipcode`\",{\"1\":{\"495\":1}}],[\"`zip\",{\"1\":{\"495\":1}}],[\"`array`\",{\"1\":{\"339\":5,\"347\":1}}],[\"`\",{\"1\":{\"302\":1}}],[\"`^c\",{\"1\":{\"302\":1}}],[\"好友关注\",{\"0\":{\"1163\":1,\"1164\":1,\"1165\":1,\"1166\":1,\"1167\":1,\"1168\":1}}],[\"好\",{\"1\":{\"1140\":4}}],[\"好用\",{\"1\":{\"1114\":1}}],[\"好了\",{\"1\":{\"662\":1}}],[\"好像不用分桶表也可以\",{\"1\":{\"296\":1}}],[\"好处\",{\"1\":{\"263\":1,\"829\":1}}],[\"局限性\",{\"0\":{\"296\":1}}],[\"局部变量被初始化为基本数据类型则是安全的\",{\"1\":{\"539\":1}}],[\"局部变量线程安全分析\",{\"1\":{\"539\":1}}],[\"局部唯一性\",{\"1\":{\"501\":1}}],[\"局部置换\",{\"1\":{\"192\":2}}],[\"局部性原理有表现在下述两个方面\",{\"1\":{\"687\":1}}],[\"局部性原理是虚拟内存技术的基础\",{\"1\":{\"686\":1}}],[\"局部性原理\",{\"0\":{\"687\":1},\"1\":{\"189\":1}}],[\"小伙伴们就会发现那个class数据已经不在了\",{\"1\":{\"1223\":1}}],[\"小value是lucy\",{\"1\":{\"1208\":1}}],[\"小key是name\",{\"1\":{\"1208\":1}}],[\"小米11\",{\"1\":{\"1186\":2,\"1207\":1}}],[\"小总结\",{\"1\":{\"1124\":1,\"1147\":1,\"1157\":1}}],[\"小端写入\",{\"1\":{\"772\":1}}],[\"小时\",{\"1\":{\"755\":1}}],[\"小故事\",{\"1\":{\"709\":1}}],[\"小于或等于0\",{\"1\":{\"870\":1}}],[\"小于最大次数\",{\"1\":{\"744\":1}}],[\"小于实际发送数据量\",{\"1\":{\"694\":1}}],[\"小于\",{\"1\":{\"663\":1}}],[\"小于等于x的放在区间左边\",{\"1\":{\"645\":1}}],[\"小林coding\",{\"1\":{\"661\":1,\"664\":1}}],[\"小概率会误判\",{\"1\":{\"659\":1}}],[\"小\",{\"1\":{\"643\":1}}],[\"小数组是hashentry数组\",{\"1\":{\"579\":1}}],[\"小数类型为decimal\",{\"1\":{\"480\":1}}],[\"小表驱动大表\",{\"1\":{\"496\":1}}],[\"小顶堆中就是出现频率前100的单词了\",{\"1\":{\"478\":1}}],[\"小写字母转换为x\",{\"1\":{\"342\":1}}],[\"小合并会将一组delta增量文件重写为单个增量文件\",{\"1\":{\"294\":1}}],[\"小合并\",{\"1\":{\"294\":1}}],[\"小结\",{\"1\":{\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"168\":1,\"171\":1,\"172\":1,\"186\":1,\"187\":1}}],[\"合法数据\",{\"1\":{\"986\":1}}],[\"合在一起就是\",{\"1\":{\"787\":1}}],[\"合理进行任务拆分\",{\"1\":{\"755\":1}}],[\"合适的字符存储长度\",{\"1\":{\"480\":1}}],[\"合并为一个逻辑上的\",{\"1\":{\"779\":1}}],[\"合并数据到临时表中\",{\"1\":{\"409\":1}}],[\"合并拉链表和增量表\",{\"1\":{\"409\":1}}],[\"合并操作分为两种\",{\"1\":{\"294\":1}}],[\"合并后\",{\"1\":{\"294\":1}}],[\"合并器compactor是一套在hive\",{\"1\":{\"294\":1}}],[\"合并器\",{\"0\":{\"294\":1}}],[\"合成复用原则是指\",{\"1\":{\"77\":1}}],[\"合成复用原则\",{\"0\":{\"77\":1}}],[\"底层第二套转换接口\",{\"0\":{\"1369\":1}}],[\"底层第一套转换接口与实现\",{\"0\":{\"1368\":1}}],[\"底层切点\",{\"0\":{\"1323\":1}}],[\"底层实现\",{\"1\":{\"1298\":1}}],[\"底层实现方式之一是代理\",{\"1\":{\"1298\":1}}],[\"底层一行一行读取表中的数据\",{\"1\":{\"985\":1}}],[\"底层是字节数组\",{\"1\":{\"979\":1}}],[\"底层是有一个数组\",{\"1\":{\"610\":1}}],[\"底层采用了\",{\"1\":{\"855\":1}}],[\"底层使用mapreduce在集群之间或并行地在同一集群内复制文件\",{\"1\":{\"869\":1}}],[\"底层使用的是水平触发\",{\"1\":{\"835\":1}}],[\"底层使用了轻量级资源隔离机制cgroups进行资源隔离\",{\"1\":{\"948\":1}}],[\"底层使用了\",{\"1\":{\"780\":1}}],[\"底层会利用操作系统的零拷贝进行优化\",{\"1\":{\"820\":1}}],[\"底层会用操作系统的零拷贝进行优化\",{\"1\":{\"820\":1}}],[\"底层也不会有拷贝操作\",{\"1\":{\"780\":1}}],[\"底层内存会被回收\",{\"1\":{\"775\":1}}],[\"底层为数组实现\",{\"1\":{\"742\":1}}],[\"底层为双向链表\",{\"1\":{\"515\":1}}],[\"底层的切面实现\",{\"1\":{\"1325\":1}}],[\"底层的切点实现\",{\"1\":{\"1325\":1}}],[\"底层的通知实现\",{\"1\":{\"1325\":1}}],[\"底层的实现是一个跳表\",{\"1\":{\"1211\":1}}],[\"底层的真正读写是操作系统来完成的\",{\"1\":{\"854\":1}}],[\"底层的\",{\"1\":{\"707\":1}}],[\"底层数据结构的不同导致应用场景也有所不同\",{\"1\":{\"604\":1}}],[\"底层解析的方案有时候不是最佳的方案\",{\"1\":{\"455\":1}}],[\"底层不需要经过shuffle\",{\"1\":{\"448\":1}}],[\"底层无法使用mapjoin提高join的性能\",{\"1\":{\"418\":1}}],[\"底层通过mapreduce中的多个reduce来实现\",{\"1\":{\"417\":1}}],[\"底层二级制\",{\"1\":{\"293\":1}}],[\"底层细节对用户不透明\",{\"1\":{\"213\":1}}],[\"语言代码中会有一个\",{\"1\":{\"1151\":1}}],[\"语言版本\",{\"1\":{\"998\":1}}],[\"语言标准库的函数\",{\"1\":{\"663\":1}}],[\"语言标准库中字符串的操作函数是很不安全的\",{\"1\":{\"662\":1}}],[\"语言标准库中的字符串操作函数就通过判断字符是不是\",{\"1\":{\"662\":1}}],[\"语言字符串用\",{\"1\":{\"662\":1}}],[\"语言字符串的缺陷\",{\"0\":{\"662\":1},\"1\":{\"663\":1}}],[\"语言获取字符串长度的时间复杂度是\",{\"1\":{\"662\":1}}],[\"语言获取字符串长度的函数\",{\"1\":{\"662\":1}}],[\"语言里\",{\"1\":{\"662\":1}}],[\"语言的字符串标准库提供的字符串操作函数\",{\"1\":{\"663\":1}}],[\"语言的字符串长度获取\",{\"1\":{\"663\":1}}],[\"语言的字符串不足之处以及可以改进的地方\",{\"1\":{\"662\":1}}],[\"语言的字符串是不会记录自身的缓冲区大小的\",{\"1\":{\"662\":1}}],[\"语言的字符串只能保存文本数据\",{\"1\":{\"662\":1}}],[\"语言的字符串其实就是一个字符数组\",{\"1\":{\"662\":1}}],[\"语言的同学\",{\"1\":{\"662\":1}}],[\"语言的\",{\"1\":{\"661\":2}}],[\"语言实现的\",{\"1\":{\"661\":1}}],[\"语句的\",{\"1\":{\"493\":1}}],[\"语句相同\",{\"1\":{\"482\":1}}],[\"语句\",{\"1\":{\"296\":1}}],[\"语句id\",{\"1\":{\"293\":1}}],[\"语法有统一标准\",{\"1\":{\"1187\":1}}],[\"语法完整的情况下\",{\"1\":{\"361\":1}}],[\"语法树\",{\"0\":{\"358\":1}}],[\"语法报错\",{\"1\":{\"307\":1}}],[\"语法规则\",{\"1\":{\"286\":1,\"315\":1}}],[\"语法如下\",{\"1\":{\"276\":1,\"369\":1,\"1146\":2}}],[\"语法\",{\"0\":{\"441\":1},\"1\":{\"255\":1,\"399\":1,\"450\":2}}],[\"语法分析\",{\"1\":{\"232\":1}}],[\"红色虚线\",{\"1\":{\"638\":1}}],[\"红黑树\",{\"0\":{\"656\":1},\"1\":{\"579\":2}}],[\"红框标出的就是一次update操作\",{\"1\":{\"292\":1}}],[\"红绿灯\",{\"1\":{\"147\":1}}],[\"正确写法\",{\"1\":{\"1230\":2}}],[\"正确使用姿势\",{\"0\":{\"797\":1}}],[\"正准备删除锁\",{\"1\":{\"1145\":1}}],[\"正准备去扣减库存\",{\"1\":{\"1135\":1}}],[\"正式代码\",{\"1\":{\"1128\":1}}],[\"正式环境应放在finally或者try\",{\"1\":{\"717\":1,\"718\":1}}],[\"正在同步的副本\",{\"1\":{\"1049\":1}}],[\"正在执行中的事务\",{\"1\":{\"292\":1}}],[\"正常\",{\"1\":{\"1438\":1}}],[\"正常化路径\",{\"1\":{\"821\":1}}],[\"正常遍历链表\",{\"1\":{\"579\":1}}],[\"正文长度\",{\"1\":{\"712\":1}}],[\"正如扩展\",{\"1\":{\"666\":1}}],[\"正是因为程序具有局部性原理\",{\"1\":{\"686\":1}}],[\"正是因为这两个阶段\",{\"1\":{\"679\":1}}],[\"正是\",{\"1\":{\"665\":1}}],[\"正例\",{\"1\":{\"480\":5,\"481\":4,\"482\":2,\"483\":1}}],[\"正则表达式解析函数\",{\"1\":{\"336\":2}}],[\"正则表达式替换函数\",{\"1\":{\"336\":2}}],[\"正负样本\",{\"0\":{\"139\":1}}],[\"谨慎使用\",{\"1\":{\"290\":1}}],[\"我相信一切都会过去\",{\"1\":{\"1525\":1}}],[\"我放到了\",{\"1\":{\"1193\":1}}],[\"我最后判断你是否签到\",{\"1\":{\"1174\":1}}],[\"我最初在认识上有这样的误区\",{\"1\":{\"795\":1}}],[\"我并不需要他一口气做完这件事\",{\"1\":{\"1155\":1}}],[\"我这里直接将实现加入了枚举类\",{\"1\":{\"723\":1}}],[\"我不留\",{\"1\":{\"709\":1}}],[\"我用\",{\"1\":{\"663\":1}}],[\"我先直接说答案\",{\"1\":{\"663\":1}}],[\"我改完了解开锁\",{\"1\":{\"561\":1}}],[\"我上了锁你们都别想改\",{\"1\":{\"561\":1}}],[\"我通过yarn发现下面的案例依然是执行了两次mr程序\",{\"1\":{\"288\":1}}],[\"我们发送post请求到这个接口\",{\"1\":{\"1525\":1}}],[\"我们发现\",{\"1\":{\"1042\":2}}],[\"我们有个注册的接口\",{\"1\":{\"1525\":1}}],[\"我们知道\",{\"1\":{\"1411\":1}}],[\"我们平时使用的配置类\",{\"1\":{\"1248\":1}}],[\"我们课上讲的\",{\"1\":{\"1240\":1}}],[\"我们只需再自定义一个方法使用\",{\"1\":{\"1526\":1}}],[\"我们只需引入对应的starter\",{\"1\":{\"1524\":1}}],[\"我们只需要让得到的\",{\"1\":{\"1176\":1}}],[\"我们只需要进行快速的逻辑判断\",{\"1\":{\"1155\":1}}],[\"我们只需要编写对应的controller即可\",{\"1\":{\"1134\":1}}],[\"我们只需要调用一次countdown\",{\"1\":{\"1132\":1}}],[\"我们只需要修改适配器类\",{\"1\":{\"7\":1}}],[\"我们只采用string的序列化器\",{\"1\":{\"1223\":1}}],[\"我们该如何区分不同类型的key呢\",{\"1\":{\"1207\":1}}],[\"我们先将这个配置文件备份一份\",{\"1\":{\"1196\":1}}],[\"我们先来改造当前的关注列表\",{\"1\":{\"1165\":1}}],[\"我们不再使用\",{\"1\":{\"1177\":1}}],[\"我们不会返回404\",{\"1\":{\"1124\":1}}],[\"我们直接利用单元测试\",{\"1\":{\"1180\":1}}],[\"我们直接去判断\",{\"1\":{\"1177\":1}}],[\"我们直接给用户返回成功\",{\"1\":{\"1155\":1}}],[\"我们按月来统计用户签到信息\",{\"1\":{\"1174\":1}}],[\"我们如何能够简化一点呢\",{\"1\":{\"1174\":1}}],[\"我们如果没有countdownlatch\",{\"1\":{\"1132\":1}}],[\"我们如果发现命中之后\",{\"1\":{\"1124\":1}}],[\"我们如果发现这个数据在mysql中不存在\",{\"1\":{\"1124\":1}}],[\"我们如果让tomcat直接去访问mysql\",{\"1\":{\"1094\":1}}],[\"我们针对签到功能完全可以通过\",{\"1\":{\"1174\":1}}],[\"我们此处是写死的\",{\"1\":{\"1171\":1}}],[\"我们此时关注的是距离\",{\"1\":{\"1171\":1}}],[\"我们这个地方可以采用sortedset来做\",{\"1\":{\"1167\":1}}],[\"我们这样可以大大减少了equals的次数\",{\"1\":{\"596\":1}}],[\"我们从t1时刻开始\",{\"1\":{\"1167\":1}}],[\"我们来读取第二页\",{\"1\":{\"1167\":1}}],[\"我们来回顾一下下单流程\",{\"1\":{\"1155\":1}}],[\"我们去读取第一页\",{\"1\":{\"1167\":1}}],[\"我们去代售点买票就方便很多了\",{\"1\":{\"58\":1}}],[\"我们本次针对好友的操作\",{\"1\":{\"1166\":1}}],[\"我们是通过该类的main方法启动spring\",{\"1\":{\"1522\":1}}],[\"我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容\",{\"1\":{\"1166\":1}}],[\"我们是直接操作从数据库中去进行查询的\",{\"1\":{\"1116\":1}}],[\"我们接下来来对比一下这些集合的区别是什么\",{\"1\":{\"1162\":1}}],[\"我们现在的逻辑\",{\"1\":{\"1161\":1}}],[\"我们现在来看看整体思路\",{\"1\":{\"1155\":1}}],[\"我们会发生他的误差是在允许范围内\",{\"1\":{\"1180\":1}}],[\"我们会将一些信息返回给前端\",{\"1\":{\"1155\":1}}],[\"我们会搭建集群或者主从\",{\"1\":{\"1153\":1}}],[\"我们在获得连接时\",{\"1\":{\"1216\":1}}],[\"我们在加载当前工厂类的时候\",{\"1\":{\"1215\":1}}],[\"我们在加锁时增加了过期时间\",{\"1\":{\"1149\":1}}],[\"我们在返回前\",{\"1\":{\"1101\":1}}],[\"我们认为合理的情况是\",{\"1\":{\"1149\":1}}],[\"我们的请求参数中就需要携带\",{\"1\":{\"1168\":1}}],[\"我们的重点在于共同关注功能\",{\"1\":{\"1165\":1}}],[\"我们的也支持支持可重入锁\",{\"1\":{\"1151\":1}}],[\"我们的\",{\"1\":{\"1149\":1}}],[\"我们的redistemplate中\",{\"1\":{\"1147\":1}}],[\"我们一路走来\",{\"1\":{\"1147\":1}}],[\"我们重启工程\",{\"1\":{\"1144\":1}}],[\"我们利用redis\",{\"1\":{\"1141\":1}}],[\"我们将耗时比较短的逻辑判断放入到\",{\"1\":{\"1155\":1}}],[\"我们将服务启动两份\",{\"1\":{\"1138\":1}}],[\"我们将网络通信部分隐藏起来\",{\"1\":{\"63\":1}}],[\"我们通常有两种解决方案\",{\"1\":{\"1135\":1}}],[\"我们通过接口文档发现\",{\"1\":{\"1175\":1}}],[\"我们通过浏览器观察到此时用户的全部信息都在\",{\"1\":{\"1101\":1}}],[\"我们通过定义\",{\"1\":{\"97\":1}}],[\"我们通过案例来感受一下静态代理\",{\"1\":{\"58\":1}}],[\"我们应当给他一些过期时间\",{\"1\":{\"1205\":1}}],[\"我们应当去查询优惠卷信息\",{\"1\":{\"1134\":1}}],[\"我们应当是先操作数据库\",{\"1\":{\"1121\":1}}],[\"我们让分线程和变量绑定\",{\"1\":{\"1132\":1}}],[\"我们担心分线程没有执行完时\",{\"1\":{\"1132\":1}}],[\"我们要做的事情是\",{\"1\":{\"1171\":1}}],[\"我们要分析出查询出数据的最小时间戳\",{\"1\":{\"1168\":1}}],[\"我们要执行\",{\"1\":{\"1146\":1}}],[\"我们要执行set\",{\"1\":{\"1146\":1}}],[\"我们要先执行set\",{\"1\":{\"1146\":1}}],[\"我们要防止刚才的情况发生\",{\"1\":{\"1145\":1}}],[\"我们要进行拆库拆表\",{\"1\":{\"1131\":1}}],[\"我们要有监控系统\",{\"1\":{\"1055\":1}}],[\"我们采用第二个方案\",{\"1\":{\"1128\":1}}],[\"我们把签到结果和\",{\"1\":{\"1176\":1}}],[\"我们把\",{\"1\":{\"1171\":1}}],[\"我们把过期时间设置在\",{\"1\":{\"1126\":1}}],[\"我们把session换成redis\",{\"1\":{\"1102\":1}}],[\"我们之所以会出现这个缓存击穿问题\",{\"1\":{\"1126\":1}}],[\"我们之前讲过需要满足两点\",{\"1\":{\"1105\":1}}],[\"我们确定了采用删除策略\",{\"1\":{\"1122\":1}}],[\"我们能如何解决这个问题呢\",{\"1\":{\"1102\":1}}],[\"我们能做的就是逐一加载每个磁盘页\",{\"1\":{\"486\":1}}],[\"我们仅仅只需要按照提示的逻辑写出代码即可\",{\"1\":{\"1099\":1}}],[\"我们也可以通过配置来实现开机自启\",{\"1\":{\"1197\":1}}],[\"我们也可以在pom\",{\"1\":{\"102\":1}}],[\"我们也把这个数据存入到redis中去\",{\"1\":{\"1123\":1}}],[\"我们也会加入redis\",{\"1\":{\"1094\":1}}],[\"我们都知道数据库能够承载的并发不如redis这么高\",{\"1\":{\"1123\":1}}],[\"我们都知道一台4核8g的tomcat\",{\"1\":{\"1094\":1}}],[\"我们都需要\",{\"1\":{\"689\":1}}],[\"我们就不需要在内存中就不用多存储数据\",{\"1\":{\"1223\":1}}],[\"我们就可以操作redis\",{\"1\":{\"1198\":1}}],[\"我们就能完成逐个遍历的效果了\",{\"1\":{\"1176\":1}}],[\"我们就能够实现\",{\"1\":{\"1147\":1}}],[\"我们就利用该方法\",{\"1\":{\"1141\":1}}],[\"我们就需要使用分布式锁来解决这个问题\",{\"1\":{\"1138\":1}}],[\"我们就来看看\",{\"1\":{\"740\":1}}],[\"我们就只和工厂打交道就可以了\",{\"1\":{\"25\":1}}],[\"我们称之为碎片\",{\"1\":{\"683\":1}}],[\"我们恰恰需要上一行的旧值\",{\"1\":{\"648\":1}}],[\"我们必须让\",{\"1\":{\"648\":1}}],[\"我们还可以自己定义函数式接口完成相关操作\",{\"1\":{\"614\":1}}],[\"我们尽可能给arraylist一个初始长度\",{\"1\":{\"601\":1}}],[\"我们假设\",{\"1\":{\"530\":1}}],[\"我们无法直接将大文件的所有词一次性读到内存中\",{\"1\":{\"477\":1}}],[\"我们常见的处理方式是将手机号中间4位进行\",{\"1\":{\"344\":1}}],[\"我们写的代码最终被翻译成cpu能够识别的指令\",{\"1\":{\"179\":1}}],[\"我们同时运行多个程序\",{\"1\":{\"155\":1}}],[\"我们主要休要修改的有三个配置\",{\"1\":{\"92\":1}}],[\"我们想要打成war部署到服务器中\",{\"1\":{\"91\":1}}],[\"我们试着将继承复用改为聚合复用看一下\",{\"1\":{\"77\":1}}],[\"我们需要综合考虑很多因素\",{\"1\":{\"1179\":1}}],[\"我们需要找到与上一次查询相同的查询个数作为偏移量\",{\"1\":{\"1168\":1}}],[\"我们需要记录每次操作的最后一条\",{\"1\":{\"1167\":1}}],[\"我们需要获得原始的事务对象\",{\"1\":{\"1137\":1}}],[\"我们需要慢慢的来思考\",{\"1\":{\"1137\":1}}],[\"我们需要根据索引需要确定分片个数\",{\"1\":{\"1067\":1}}],[\"我们需要了解布隆过滤器的概念\",{\"1\":{\"658\":1}}],[\"我们需要需改maven\",{\"1\":{\"92\":1}}],[\"我们需要创建一个黑马品牌的安全门\",{\"1\":{\"75\":1}}],[\"我们需要使用接口和抽象类\",{\"1\":{\"72\":1}}],[\"我们需要调整加锁的时机\",{\"1\":{\"66\":1}}],[\"我们需要实现网络通信\",{\"1\":{\"63\":1}}],[\"我们可以自定义redistemplate的序列化方式\",{\"1\":{\"1222\":1}}],[\"我们可以这样定义key\",{\"1\":{\"1207\":1}}],[\"我们可以用下面这组命令来操作redis了\",{\"1\":{\"1197\":1}}],[\"我们可以将数据库的数据\",{\"1\":{\"1177\":1}}],[\"我们可以判断当前\",{\"1\":{\"1155\":1}}],[\"我们可以不可以使用异步编排来做\",{\"1\":{\"1155\":1}}],[\"我们可以不直接使用redis自增的数值\",{\"1\":{\"1131\":1}}],[\"我们可以给他续期一下\",{\"1\":{\"1147\":1}}],[\"我们可以采用手动序列化的方式\",{\"1\":{\"1223\":1}}],[\"我们可以采用类似这样的方案来实现我们的签到需求\",{\"1\":{\"1174\":1}}],[\"我们可以采用逻辑过期方案\",{\"1\":{\"1126\":1}}],[\"我们可以采用trylock方法\",{\"1\":{\"1126\":1}}],[\"我们可以把\",{\"1\":{\"1177\":1,\"1525\":1}}],[\"我们可以把年和月作为\",{\"1\":{\"1175\":1}}],[\"我们可以把两人的关注的人分别放入到一个set集合中\",{\"1\":{\"1165\":1}}],[\"我们可以把缓存删除\",{\"1\":{\"1121\":1}}],[\"我们可以把它看作由二进制向量\",{\"1\":{\"658\":1}}],[\"我们可以手动调用方法把缓存删掉\",{\"1\":{\"1119\":1}}],[\"我们可以考虑使用string\",{\"1\":{\"1104\":1}}],[\"我们可以通过xml配置或者注解来进行配置\",{\"1\":{\"1503\":1}}],[\"我们可以通过给key添加前缀加以区分\",{\"1\":{\"1207\":1}}],[\"我们可以通过true\",{\"1\":{\"1127\":1}}],[\"我们可以通过基准测试\",{\"1\":{\"1019\":1}}],[\"我们可以通过修改参数\",{\"1\":{\"446\":1}}],[\"我们可以得知\",{\"1\":{\"662\":1,\"1100\":1}}],[\"我们可以得出\",{\"1\":{\"659\":1}}],[\"我们可以使用isolation属性声明事物的隔离级别\",{\"1\":{\"1515\":1}}],[\"我们可以使用工厂\",{\"1\":{\"1215\":1}}],[\"我们可以使用\",{\"1\":{\"1155\":1}}],[\"我们可以使用lua去操作redis\",{\"1\":{\"1146\":1}}],[\"我们可以使用longaddr这个类去解决\",{\"1\":{\"1136\":1}}],[\"我们可以使用threadlocal来做到线程隔离\",{\"1\":{\"1100\":1}}],[\"我们可以使用版本号机制或时间戳机制来实现\",{\"1\":{\"507\":1}}],[\"我们可以使用resources标签\",{\"1\":{\"102\":1}}],[\"我们可以配置底层的优化器引擎为cbo引擎\",{\"1\":{\"457\":1}}],[\"我们可以有两种方案来实现\",{\"1\":{\"452\":1}}],[\"我们可以对用户id进行分区\",{\"1\":{\"399\":1}}],[\"我们可以基于用户的登陆信息\",{\"1\":{\"399\":1}}],[\"我们可以在build\",{\"1\":{\"102\":1}}],[\"我们可以方便地维护项目所依赖的外部库\",{\"1\":{\"91\":1}}],[\"我们可以进行灵活处理\",{\"1\":{\"61\":1}}],[\"我们可以看到以下几个信息\",{\"1\":{\"59\":1}}],[\"我们再次使用cglib代理实现\",{\"1\":{\"60\":1}}],[\"我们看通过类图看看结构\",{\"1\":{\"43\":1}}],[\"我们使用不同的数据库访问框架\",{\"1\":{\"1515\":1}}],[\"我们使用锁必须保证锁必须是同一把\",{\"1\":{\"1137\":1}}],[\"我们使用properties文件作为配置文件\",{\"1\":{\"42\":1}}],[\"我们使用对象适配器模式将读卡器的案例进行改写\",{\"1\":{\"7\":1}}],[\"我们势必要需求修改simplecoffeefactory的代码\",{\"1\":{\"28\":1}}],[\"我们明确地计划不同条件下创建不同实例时\",{\"1\":{\"23\":1}}],[\"我们举个简单例子来说明两者的差异\",{\"1\":{\"19\":1}}],[\"载入数据后\",{\"1\":{\"285\":1}}],[\"您已被拉入\",{\"1\":{\"704\":1}}],[\"您可以将新列添加到现有列的末尾但在分区列之前\",{\"1\":{\"279\":1}}],[\"您所点的咖啡没有\",{\"1\":{\"28\":1}}],[\"注解进行查找\",{\"1\":{\"1530\":1}}],[\"注解了解吗\",{\"0\":{\"1516\":1}}],[\"注解的作用与\",{\"1\":{\"1455\":1}}],[\"注解的接口\",{\"1\":{\"1455\":2}}],[\"注解的平级\",{\"1\":{\"1260\":1}}],[\"注解且返回非简单类型时\",{\"1\":{\"1394\":1}}],[\"注解时\",{\"1\":{\"1394\":2}}],[\"注解来辅助获得参数名\",{\"1\":{\"1366\":1}}],[\"注入其它\",{\"0\":{\"1294\":1},\"1\":{\"1290\":1}}],[\"注入\",{\"1\":{\"1284\":4,\"1285\":1}}],[\"注入redistemplate\",{\"1\":{\"1221\":1}}],[\"注入redissonclient\",{\"1\":{\"1150\":1}}],[\"注销并关闭自己\",{\"1\":{\"953\":1}}],[\"注册拦截器\",{\"1\":{\"1532\":2}}],[\"注册所有\",{\"1\":{\"1413\":1}}],[\"注册一个\",{\"1\":{\"1248\":1}}],[\"注册到容器中\",{\"1\":{\"1280\":1}}],[\"注册到\",{\"1\":{\"740\":1,\"843\":1}}],[\"注册\",{\"1\":{\"712\":1,\"740\":2,\"743\":1,\"840\":1,\"949\":1,\"953\":1,\"1098\":1}}],[\"注册成为临时函数\",{\"1\":{\"344\":1}}],[\"注释或添加\",{\"1\":{\"1285\":1}}],[\"注释第69行\",{\"1\":{\"1046\":1}}],[\"注释第6行\",{\"1\":{\"1046\":1}}],[\"注释性描述\",{\"1\":{\"924\":1}}],[\"注释\",{\"1\":{\"279\":1}}],[\"注意文件名与控制器方法返回的视图逻辑名一致\",{\"1\":{\"1441\":1}}],[\"注意看commandexecutor\",{\"1\":{\"1152\":1}}],[\"注意到复制分片从不与原\",{\"1\":{\"1067\":1}}],[\"注意和zookeeper区分\",{\"1\":{\"1048\":1}}],[\"注意实现hadoop的序列化机制\",{\"1\":{\"972\":1}}],[\"注意自定义对象需要实现hadoop的序列化机制\",{\"1\":{\"972\":1}}],[\"注意分区与分组的区别\",{\"1\":{\"968\":1}}],[\"注意必须是ha集群\",{\"1\":{\"890\":1}}],[\"注意需要创建短路本地读取的文件夹\",{\"1\":{\"878\":1}}],[\"注意各种异常\",{\"1\":{\"775\":1}}],[\"注意不包括hadoop\",{\"1\":{\"878\":1}}],[\"注意不包含dn\",{\"1\":{\"872\":1}}],[\"注意不能仅捕获\",{\"1\":{\"765\":1}}],[\"注意不是threadlocal对象\",{\"1\":{\"577\":1}}],[\"注意不是到了串行化才解决了幻读\",{\"1\":{\"503\":1}}],[\"注意发送的数据未必能够一次读完\",{\"1\":{\"744\":1}}],[\"注意⚠️\",{\"0\":{\"742\":1}}],[\"注意此时没有注册\",{\"1\":{\"740\":1}}],[\"注意两种结构都需要考虑是在中间操作还是在两端操作\",{\"1\":{\"600\":1}}],[\"注意线程池线程数和cyclicbarrier的计数要一样\",{\"1\":{\"593\":1}}],[\"注意callable中的是call方法\",{\"1\":{\"532\":1}}],[\"注意字符统计函数的区别\",{\"1\":{\"482\":1}}],[\"注意explode的参数只能是map或者array\",{\"1\":{\"389\":1}}],[\"注意下面写法的错误示范\",{\"1\":{\"378\":1}}],[\"注意要和侧视图lateral\",{\"1\":{\"376\":1}}],[\"注意要想一次解析出多个\",{\"1\":{\"336\":1}}],[\"注意group\",{\"1\":{\"351\":1}}],[\"注意每个select语句返回的列的数量和名称必须相同\",{\"1\":{\"315\":1}}],[\"注意每次读写的只能是连续的多个块\",{\"1\":{\"209\":1}}],[\"注意是table\",{\"1\":{\"271\":1}}],[\"注意这里使用synchronized同步\",{\"1\":{\"999\":1}}],[\"注意这里\",{\"1\":{\"261\":1}}],[\"注意事项\",{\"0\":{\"1001\":1},\"1\":{\"248\":1,\"259\":1,\"968\":1,\"970\":1}}],[\"注意\",{\"1\":{\"7\":1,\"14\":1,\"54\":1,\"85\":1,\"175\":1,\"182\":1,\"186\":1,\"191\":1,\"208\":1,\"268\":1,\"276\":1,\"278\":1,\"309\":1,\"313\":1,\"369\":1,\"420\":1,\"438\":1,\"482\":1,\"541\":1,\"628\":1,\"668\":1,\"693\":1,\"697\":1,\"742\":1,\"753\":1,\"772\":1,\"804\":1,\"873\":1,\"876\":1,\"889\":1,\"914\":1,\"976\":1,\"990\":2,\"1001\":1,\"1012\":1,\"1040\":1,\"1126\":1,\"1137\":1,\"1140\":1,\"1157\":1,\"1159\":1,\"1164\":1,\"1168\":1,\"1176\":1,\"1211\":1,\"1243\":1,\"1244\":1,\"1285\":1,\"1294\":1,\"1300\":1,\"1313\":1,\"1317\":1,\"1325\":1,\"1464\":1}}],[\"移除set中的指定元素\",{\"1\":{\"1210\":1}}],[\"移除serde属性\",{\"1\":{\"279\":1}}],[\"移除并返回列表右侧的第一个元素\",{\"1\":{\"1209\":1}}],[\"移除并返回列表左侧的第一个元素\",{\"1\":{\"1209\":1}}],[\"移除用户\",{\"1\":{\"1111\":1}}],[\"移除初始化器\",{\"1\":{\"740\":1}}],[\"移除聊天组\",{\"1\":{\"701\":1}}],[\"移除组成员\",{\"1\":{\"701\":1}}],[\"移除了cms垃圾收集器\",{\"1\":{\"640\":1}}],[\"移除\",{\"1\":{\"638\":1}}],[\"移出最近最少使用的key\",{\"1\":{\"522\":1}}],[\"移动文件\",{\"1\":{\"822\":1}}],[\"移动端\",{\"1\":{\"638\":1}}],[\"移动操作\",{\"1\":{\"283\":1}}],[\"移动时是纯复制\",{\"1\":{\"283\":1}}],[\"移动磁头时间\",{\"1\":{\"204\":1}}],[\"里也能获取到\",{\"1\":{\"1411\":1}}],[\"里边把这个空数据缓存起来\",{\"1\":{\"1177\":1}}],[\"里边也不存在的数据\",{\"1\":{\"1177\":1}}],[\"里德所罗门\",{\"1\":{\"875\":1}}],[\"里的数据\",{\"1\":{\"663\":1}}],[\"里面的同步log发生变化了会读取jn里面的edits\",{\"1\":{\"886\":1}}],[\"里面有\",{\"1\":{\"746\":1}}],[\"里面包含了要删除的文件\",{\"1\":{\"293\":1}}],[\"里面存储着预计算的数据\",{\"1\":{\"275\":1}}],[\"里氏替换原则告诉我们\",{\"1\":{\"73\":1}}],[\"里氏替换原则\",{\"1\":{\"73\":1}}],[\"里氏代换原则\",{\"0\":{\"73\":1}}],[\"物品个数\",{\"1\":{\"648\":1}}],[\"物化视图来代替hive\",{\"1\":{\"419\":1}}],[\"物化视图相关语法\",{\"0\":{\"276\":1}}],[\"物化视图相关概念\",{\"0\":{\"274\":1}}],[\"物化视图能够缓存数据\",{\"1\":{\"275\":1}}],[\"物化视图是真实的\",{\"1\":{\"275\":1}}],[\"物化视图和视图的区别\",{\"0\":{\"275\":1}}],[\"物理存在的\",{\"1\":{\"275\":1}}],[\"物理设备名\",{\"1\":{\"213\":1}}],[\"物理设备名是进程请求分配时提供的参数\",{\"1\":{\"213\":1}}],[\"物理块对应着物理地址\",{\"1\":{\"683\":1}}],[\"物理块\",{\"1\":{\"197\":1}}],[\"物理地址=\",{\"1\":{\"184\":1}}],[\"物理地址的转换\",{\"1\":{\"179\":1}}],[\"物理地址即绝对地址\",{\"1\":{\"179\":1}}],[\"物理地址\",{\"1\":{\"179\":1}}],[\"物理实体是实际存在的\",{\"1\":{\"155\":1}}],[\"报错信息说没有main方法\",{\"1\":{\"624\":1}}],[\"报错\",{\"1\":{\"271\":1,\"351\":1,\"1099\":1,\"1107\":1}}],[\"报告的数据系统\",{\"1\":{\"219\":1}}],[\"仅根据视图名找视图\",{\"1\":{\"1436\":1}}],[\"仅做类型转换\",{\"1\":{\"1370\":1}}],[\"仅是调用\",{\"1\":{\"1321\":3}}],[\"仅为根据接口名生成\",{\"1\":{\"1280\":1}}],[\"仅被一次消费\",{\"1\":{\"1054\":1}}],[\"仅有一次\",{\"1\":{\"1053\":1}}],[\"仅kms可以根据要求使用ez密钥创建和解密edek\",{\"1\":{\"935\":1}}],[\"仅适合短连接场景\",{\"1\":{\"866\":1}}],[\"仅支持阻塞\",{\"1\":{\"850\":1}}],[\"仅支持orc文件格式\",{\"1\":{\"267\":1}}],[\"仅执行一次\",{\"1\":{\"784\":1,\"785\":1}}],[\"仅会打印\",{\"1\":{\"766\":1}}],[\"仅关联\",{\"1\":{\"740\":1}}],[\"仅决定了\",{\"1\":{\"693\":1}}],[\"仅分配引用变量空间即可\",{\"1\":{\"630\":1}}],[\"仅用在一个写线程\",{\"1\":{\"558\":1}}],[\"仅在语言层面创建了线程对象\",{\"1\":{\"538\":1}}],[\"仅仅是一个提示\",{\"1\":{\"535\":1}}],[\"仅限compile范围\",{\"1\":{\"114\":1,\"115\":1}}],[\"部署效率\",{\"1\":{\"1520\":1}}],[\"部署等构建过程\",{\"1\":{\"91\":1}}],[\"部分\",{\"1\":{\"1343\":1,\"1350\":1}}],[\"部分收集\",{\"1\":{\"628\":1}}],[\"部分数据展示\",{\"1\":{\"265\":1}}],[\"州相等的情况\",{\"1\":{\"974\":1}}],[\"州相同的为一组\",{\"1\":{\"974\":1}}],[\"州state\",{\"1\":{\"974\":1}}],[\"州\",{\"1\":{\"265\":2,\"266\":1,\"972\":1,\"974\":1}}],[\"县确诊病例cases\",{\"1\":{\"974\":1}}],[\"县county\",{\"1\":{\"974\":1}}],[\"县编码\",{\"1\":{\"265\":1,\"266\":1}}],[\"县编码code\",{\"1\":{\"265\":1}}],[\"县\",{\"1\":{\"265\":2,\"266\":1,\"974\":1}}],[\"统计score值在给定范围内的所有元素的个数\",{\"1\":{\"1211\":1}}],[\"统计当前用户截止当前时间在本月的连续签到天数\",{\"1\":{\"1176\":1}}],[\"统计有多少个\",{\"1\":{\"1176\":1}}],[\"统计出来的时间也就是所有分线程执行完后的时间\",{\"1\":{\"1132\":1}}],[\"统计美国2021\",{\"1\":{\"972\":1,\"974\":1}}],[\"统计变量\",{\"1\":{\"960\":1}}],[\"统计\",{\"0\":{\"1178\":1,\"1179\":1},\"1\":{\"822\":1,\"1174\":1}}],[\"统计文件夹和文件个数\",{\"1\":{\"822\":1}}],[\"统计数据表的行数只需要o\",{\"1\":{\"497\":1}}],[\"统计修正等\",{\"1\":{\"483\":1}}],[\"统计每个部门工资最高的前两名\",{\"1\":{\"403\":1}}],[\"统计每个用户每个月的消费总金额以及当前累计消费总金额\",{\"1\":{\"401\":1}}],[\"统计每个用户pv最多的前1\",{\"1\":{\"364\":1}}],[\"统计每个球队获取总冠军的次数\",{\"1\":{\"349\":1}}],[\"统计死亡病例数大于10000的州\",{\"1\":{\"307\":1}}],[\"统计日期\",{\"1\":{\"265\":2,\"266\":1}}],[\"统一采用\",{\"1\":{\"731\":1}}],[\"统一更新子工程打包插件\",{\"1\":{\"112\":1}}],[\"统一管理依赖项\",{\"1\":{\"108\":1}}],[\"降级会保留现有的数据状态\",{\"1\":{\"892\":1}}],[\"降级可以滚动降级\",{\"1\":{\"892\":1}}],[\"降级和回滚的区别\",{\"0\":{\"892\":1}}],[\"降低项目依赖的复杂度\",{\"1\":{\"1521\":1}}],[\"降低模块间的耦合度\",{\"1\":{\"1500\":1}}],[\"降低对象之间的耦合度\",{\"1\":{\"1500\":1}}],[\"降低耦合\",{\"1\":{\"1216\":1}}],[\"降低资源消耗\",{\"1\":{\"570\":1}}],[\"降低系统吞吐量\",{\"1\":{\"176\":1}}],[\"降序获取sorted\",{\"1\":{\"1211\":1}}],[\"降序\",{\"1\":{\"312\":1}}],[\"降序排序\",{\"1\":{\"264\":1}}],[\"社会调查普遍采用的一种经济有效的工作和研究方法\",{\"1\":{\"263\":1}}],[\"质量检验\",{\"1\":{\"263\":1}}],[\"省略\",{\"1\":{\"1362\":2}}],[\"省略创建productlist过程\",{\"1\":{\"1089\":1}}],[\"省略一些不重要的方法\",{\"1\":{\"772\":1}}],[\"省略旧的代码\",{\"1\":{\"733\":1}}],[\"省份\",{\"1\":{\"374\":1}}],[\"省去了我们自定义redistemplate的序列化方式的步骤\",{\"1\":{\"1223\":1}}],[\"省去from关键字\",{\"1\":{\"302\":1}}],[\"省去其他的修改操作\",{\"1\":{\"28\":1}}],[\"省里面再按市分区\",{\"1\":{\"262\":1}}],[\"值为多个自动配置类名\",{\"1\":{\"1464\":1}}],[\"值也有所不同\",{\"1\":{\"694\":1}}],[\"值有时也是字符串类型\",{\"1\":{\"661\":1}}],[\"值很重要\",{\"1\":{\"606\":1}}],[\"值时\",{\"1\":{\"606\":1}}],[\"值\",{\"1\":{\"261\":1,\"726\":1,\"772\":9,\"997\":1,\"1170\":1}}],[\"值存储的是对应的对象\",{\"1\":{\"42\":1}}],[\"针对用户的操作\",{\"1\":{\"1164\":1}}],[\"针对cas中的自旋压力过大\",{\"1\":{\"1136\":1}}],[\"针对这一问题的常见解决方案就是加锁\",{\"1\":{\"1135\":1}}],[\"针对每个生产者\",{\"1\":{\"1029\":1}}],[\"针对客户端连续点击或者调用方的超时重试等情况\",{\"1\":{\"1005\":1}}],[\"针对reduce\",{\"1\":{\"991\":1}}],[\"针对静态数据集\",{\"1\":{\"955\":1}}],[\"针对linux操作系统而言\",{\"1\":{\"676\":1}}],[\"针对压缩列表在设计上的不足\",{\"1\":{\"667\":1}}],[\"针对hotspot\",{\"1\":{\"628\":1}}],[\"针对jdk\",{\"1\":{\"606\":1}}],[\"针对救急线程\",{\"1\":{\"572\":1}}],[\"针对所有的key做处理\",{\"1\":{\"522\":1}}],[\"针对设置了过期时间的key做处理\",{\"1\":{\"522\":1}}],[\"针对同一份数据\",{\"1\":{\"508\":1}}],[\"针对分桶表进行了优化\",{\"1\":{\"369\":1}}],[\"针对explode案例中nba冠军球队年份排名案例\",{\"1\":{\"349\":1}}],[\"针对的是分区表\",{\"1\":{\"305\":1}}],[\"针对事务表进行insert\",{\"1\":{\"268\":1,\"298\":1}}],[\"针对\",{\"1\":{\"260\":1}}],[\"针对上例中的缺点\",{\"1\":{\"31\":1}}],[\"扫描被\",{\"1\":{\"1525\":1}}],[\"扫描时\",{\"1\":{\"1476\":1}}],[\"扫描具体包\",{\"1\":{\"1455\":1}}],[\"扫描本文件夹下本分区下的文件即可\",{\"1\":{\"259\":1}}],[\"扫描算法\",{\"1\":{\"204\":1}}],[\"缓存击穿\",{\"1\":{\"1129\":1}}],[\"缓存击穿问题也叫热点key问题\",{\"1\":{\"1126\":1}}],[\"缓存击穿问题及解决思路\",{\"0\":{\"1126\":1}}],[\"缓存重建\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"缓存雪崩是指在同一时段大量的缓存key同时失效或者redis服务宕机\",{\"1\":{\"1125\":1}}],[\"缓存雪崩问题及解决思路\",{\"0\":{\"1125\":1}}],[\"缓存null值\",{\"1\":{\"1124\":1}}],[\"缓存空对象思路分析\",{\"1\":{\"1123\":1}}],[\"缓存空对象\",{\"1\":{\"1123\":1}}],[\"缓存穿透的解决方案有哪些\",{\"1\":{\"1124\":1}}],[\"缓存穿透产生的原因是什么\",{\"1\":{\"1124\":1}}],[\"缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在\",{\"1\":{\"1123\":1}}],[\"缓存穿透\",{\"1\":{\"1123\":1,\"1124\":1,\"1127\":1,\"1129\":2}}],[\"缓存穿透问题的解决思路\",{\"0\":{\"1123\":1}}],[\"缓存调用者在更新完数据库后再去更新缓存\",{\"1\":{\"1120\":1}}],[\"缓存更新是redis为了节约内存而设计出来的一个东西\",{\"1\":{\"1119\":1}}],[\"缓存更新策略\",{\"0\":{\"1119\":1}}],[\"缓存模型和思路\",{\"0\":{\"1117\":1}}],[\"缓存可以大大降低用户访问并发量带来的服务器读写压力\",{\"1\":{\"1114\":1}}],[\"缓存数据存储于代码中\",{\"1\":{\"1114\":1}}],[\"缓存伪共享\",{\"1\":{\"855\":1}}],[\"缓存i\",{\"1\":{\"678\":2}}],[\"缓存\",{\"0\":{\"678\":1},\"1\":{\"258\":1,\"664\":1,\"1113\":1}}],[\"缓冲可写\",{\"1\":{\"844\":1}}],[\"缓冲池有位置了\",{\"1\":{\"719\":1}}],[\"缓冲池\",{\"1\":{\"214\":1}}],[\"缓冲区是有大小限制\",{\"1\":{\"979\":1}}],[\"缓冲区的作用是批量收集map结果\",{\"1\":{\"979\":1}}],[\"缓冲区的数据写入网卡\",{\"1\":{\"854\":1,\"855\":1}}],[\"缓冲区写不下时再关注可写事件\",{\"1\":{\"844\":1}}],[\"缓冲区对象内置了一些机制\",{\"1\":{\"610\":1}}],[\"缓冲区本质上是一个可以读写数据的内存块\",{\"1\":{\"610\":1}}],[\"缓冲区\",{\"1\":{\"610\":1,\"833\":1,\"854\":1,\"855\":2}}],[\"缓冲区介绍以及作用\",{\"1\":{\"214\":1}}],[\"缓冲区管理\",{\"0\":{\"214\":1}}],[\"事件监听器的两种方式\",{\"1\":{\"1493\":1}}],[\"事件监听器\",{\"0\":{\"1490\":1,\"1491\":1}}],[\"事件7️⃣\",{\"1\":{\"1444\":1}}],[\"事件6️⃣\",{\"1\":{\"1444\":1}}],[\"事件5️⃣\",{\"1\":{\"1444\":1}}],[\"事件4️⃣\",{\"1\":{\"1444\":1}}],[\"事件1️⃣\",{\"1\":{\"1444\":1}}],[\"事件解耦\",{\"1\":{\"1243\":1}}],[\"事件发布器模拟实现\",{\"1\":{\"1497\":1}}],[\"事件发布器\",{\"0\":{\"1494\":1,\"1495\":1}}],[\"事件发布还可以异步\",{\"1\":{\"1243\":1}}],[\"事件发布与监听\",{\"1\":{\"1240\":1,\"1243\":1}}],[\"事件发生后要么处理\",{\"1\":{\"840\":1}}],[\"事件发生后\",{\"1\":{\"835\":1}}],[\"事件发生后能否不处理💡\",{\"0\":{\"835\":1}}],[\"事件发生时\",{\"1\":{\"833\":1}}],[\"事件发生线程才去处理\",{\"1\":{\"829\":1}}],[\"事件处理时的线程安全\",{\"1\":{\"746\":1}}],[\"事件处理耗时\",{\"1\":{\"741\":1}}],[\"事件都由此\",{\"1\":{\"746\":1}}],[\"事件循环组\",{\"1\":{\"746\":1}}],[\"事件循环对象\",{\"1\":{\"746\":1}}],[\"事件\",{\"0\":{\"748\":1,\"831\":1,\"832\":1,\"834\":1,\"836\":1,\"842\":1},\"1\":{\"610\":1,\"680\":1,\"702\":1,\"705\":1,\"707\":2,\"710\":1,\"740\":4,\"741\":3,\"742\":1,\"743\":5,\"744\":3,\"746\":1,\"748\":2,\"750\":1,\"833\":3,\"837\":2,\"840\":1,\"843\":1,\"846\":2,\"859\":2}}],[\"事务将不会发生回滚\",{\"1\":{\"1514\":1}}],[\"事务传播类型\",{\"1\":{\"1514\":1}}],[\"事务处理也是通过aop实现的\",{\"1\":{\"1510\":1}}],[\"事务通知类\",{\"1\":{\"1456\":1}}],[\"事务切面类\",{\"1\":{\"1456\":1}}],[\"事务自动配置类有两个\",{\"1\":{\"1456\":1}}],[\"事务会失效\",{\"1\":{\"1157\":1}}],[\"事务会影响数据库的qps\",{\"1\":{\"483\":1}}],[\"事务想要生效\",{\"1\":{\"1137\":1}}],[\"事务等待链表\",{\"1\":{\"513\":1}}],[\"事务都无法推进下去\",{\"1\":{\"513\":1}}],[\"事务有意向对表中的某些行加排他锁\",{\"1\":{\"510\":1}}],[\"事务有意向对表中的某些行加共享锁\",{\"1\":{\"510\":1}}],[\"事务便可以修改数据\",{\"1\":{\"506\":1}}],[\"事务在修改数据之前\",{\"1\":{\"506\":1}}],[\"事务的打开\",{\"1\":{\"1515\":1}}],[\"事务的持久性无法保证\",{\"1\":{\"506\":1}}],[\"事务的四大特性以及如何实现\",{\"0\":{\"506\":1}}],[\"事务一旦提交\",{\"1\":{\"506\":1}}],[\"事务与事务之间的操作时互相隔离互不干扰的\",{\"1\":{\"506\":1}}],[\"事务中任何一个sql语句执行失败\",{\"1\":{\"506\":1}}],[\"事务表不支持load\",{\"1\":{\"296\":1}}],[\"事务表使用设置与局限性\",{\"0\":{\"295\":1}}],[\"事务表使用时的相关局限性\",{\"1\":{\"267\":1}}],[\"事务表基本操作\",{\"1\":{\"291\":1}}],[\"事务表创建要素\",{\"1\":{\"268\":1}}],[\"事务表\",{\"0\":{\"267\":1,\"291\":1}}],[\"事务性性的保障\",{\"1\":{\"1053\":1}}],[\"事务性\",{\"1\":{\"258\":1}}],[\"事务\",{\"0\":{\"1188\":1},\"1\":{\"258\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"事实上\",{\"1\":{\"189\":1,\"191\":1,\"679\":1,\"680\":1}}],[\"托管表\",{\"1\":{\"258\":1}}],[\"皮肤价格\",{\"1\":{\"256\":1}}],[\"皮肤及价格\",{\"1\":{\"256\":1}}],[\"街头霸王\",{\"1\":{\"256\":1}}],[\"街景转语义分割标签等图像转译应用上表现出色\",{\"1\":{\"117\":1}}],[\"教廷特使\",{\"1\":{\"256\":1}}],[\"白名单\",{\"1\":{\"880\":1}}],[\"白白浪费了\",{\"1\":{\"827\":1}}],[\"白菜豆腐不可\",{\"1\":{\"709\":1}}],[\"白菜豆腐不可少\",{\"1\":{\"709\":1}}],[\"白龙吟\",{\"1\":{\"256\":1}}],[\"白箱\",{\"1\":{\"77\":1}}],[\"韩信\",{\"1\":{\"256\":1}}],[\"曙光守护者\",{\"1\":{\"256\":1}}],[\"龙域领主\",{\"1\":{\"256\":1}}],[\"铠\",{\"1\":{\"256\":1}}],[\"黄金射手座\",{\"1\":{\"256\":1}}],[\"辉光之辰\",{\"1\":{\"256\":1}}],[\"精确到天\",{\"1\":{\"1132\":1}}],[\"精灵王\",{\"1\":{\"256\":1}}],[\"精简的访问列表\",{\"1\":{\"201\":1}}],[\"星空梦想\",{\"1\":{\"256\":1}}],[\"福禄兄弟\",{\"1\":{\"256\":1}}],[\"木偶奇遇记\",{\"1\":{\"256\":1}}],[\"木盏\",{\"1\":{\"145\":1}}],[\"鲁班七号\",{\"1\":{\"256\":1}}],[\"地空闲状态\",{\"1\":{\"689\":1}}],[\"地域\",{\"1\":{\"259\":1}}],[\"地狱火\",{\"1\":{\"256\":1}}],[\"地址\",{\"1\":{\"1200\":1,\"1212\":1}}],[\"地址转换时不需要访问磁盘\",{\"1\":{\"197\":1}}],[\"地址变换机构\",{\"1\":{\"190\":2}}],[\"地址变换是在装入的时候一次性完成的\",{\"1\":{\"179\":1}}],[\"孙悟空\",{\"1\":{\"256\":1}}],[\"换句话说\",{\"1\":{\"1223\":1}}],[\"换句话说使用扰动函数之后可以减少碰撞\",{\"1\":{\"605\":1}}],[\"换取访问server端的票\",{\"1\":{\"923\":1}}],[\"换人\",{\"1\":{\"749\":1}}],[\"换来了一个更大的空间来支持程序的运行\",{\"1\":{\"688\":1}}],[\"换算出一页大概能存储1000条数据\",{\"1\":{\"487\":1}}],[\"换行的分隔符号\",{\"1\":{\"252\":1}}],[\"换出需要磁盘的i\",{\"1\":{\"191\":1}}],[\"换出\",{\"1\":{\"189\":1}}],[\"集成\",{\"0\":{\"1450\":1}}],[\"集成是部署透明加密的第一步\",{\"1\":{\"932\":1}}],[\"集群环境下\",{\"1\":{\"1138\":1}}],[\"集群环境下的并发问题\",{\"0\":{\"1138\":1}}],[\"集群的容错\",{\"1\":{\"1026\":1}}],[\"集群的分布式就是由分区来实现的\",{\"1\":{\"1026\":1}}],[\"集群的主角色\",{\"1\":{\"903\":1}}],[\"集群中\",{\"1\":{\"1026\":1}}],[\"集群\",{\"1\":{\"1019\":1}}],[\"集群占有组织之间没有隔离\",{\"1\":{\"888\":1}}],[\"集群是轻量级分布式系统\",{\"1\":{\"886\":1}}],[\"集群实现edits\",{\"1\":{\"884\":1}}],[\"集群多主\",{\"1\":{\"882\":1}}],[\"集群无主\",{\"1\":{\"882\":1}}],[\"集群可用性评判标准\",{\"1\":{\"882\":1}}],[\"集群和硬件配置\",{\"1\":{\"875\":1}}],[\"集群管理与运维\",{\"0\":{\"868\":1}}],[\"集群模式\",{\"0\":{\"527\":1}}],[\"集群监控\",{\"1\":{\"526\":1}}],[\"集群数据同步等\",{\"1\":{\"516\":1}}],[\"集合中\",{\"1\":{\"1177\":2}}],[\"集合中即可\",{\"1\":{\"1171\":1}}],[\"集合中没有这条记录\",{\"1\":{\"1155\":1}}],[\"集合中没有这条数据\",{\"1\":{\"1155\":1}}],[\"集合中真正删除\",{\"1\":{\"840\":1}}],[\"集合中移除\",{\"1\":{\"837\":1}}],[\"集合中删除\",{\"1\":{\"836\":1,\"838\":1,\"840\":1}}],[\"集合\",{\"1\":{\"523\":1,\"701\":2,\"837\":1,\"1368\":1,\"1489\":1}}],[\"集合运算\",{\"1\":{\"515\":1}}],[\"集合元素size函数\",{\"1\":{\"339\":1}}],[\"集合元素个数函数\",{\"1\":{\"339\":1}}],[\"集合元素之间分隔符\",{\"1\":{\"252\":1}}],[\"集合元素之间\",{\"1\":{\"252\":1}}],[\"集合函数\",{\"0\":{\"339\":1},\"1\":{\"339\":1}}],[\"集合查找函数\",{\"1\":{\"336\":2}}],[\"集上面二者的优点\",{\"1\":{\"163\":1}}],[\"甚至是一张图片或一个pdf文档等不同的媒体形式\",{\"1\":{\"1530\":2}}],[\"甚至可以是图格式\",{\"1\":{\"1185\":1}}],[\"甚至可能引发连锁更新的问题\",{\"1\":{\"664\":1}}],[\"甚至json\",{\"1\":{\"1182\":1}}],[\"甚至支持用户自定义serde类\",{\"1\":{\"251\":1}}],[\"甚至全部死锁的进程\",{\"1\":{\"178\":1}}],[\"杂项数据类型\",{\"1\":{\"248\":1}}],[\"蓝色字体是建表语法的关键字\",{\"1\":{\"247\":1}}],[\"蓝色表示正在请求的资源\",{\"1\":{\"178\":1}}],[\"区间查询\",{\"1\":{\"673\":1}}],[\"区间求和\",{\"0\":{\"673\":1}}],[\"区间的数据\",{\"1\":{\"527\":1}}],[\"区域加锁保证更新的原子性\",{\"1\":{\"630\":1}}],[\"区域一起回收\",{\"1\":{\"628\":1}}],[\"区分事件类型\",{\"1\":{\"840\":1}}],[\"区分度\",{\"1\":{\"493\":1}}],[\"区分度会\",{\"1\":{\"493\":1}}],[\"区分度会高达90\",{\"1\":{\"481\":1}}],[\"区分度最高的在最左边\",{\"1\":{\"481\":1}}],[\"区分3种配置方式的关键是弄清楚两个问题\",{\"1\":{\"241\":1}}],[\"区别就是nn直接读取加密文件元数据里的edek返回给客户端\",{\"1\":{\"935\":1}}],[\"区别就是在于cyclibarrier计数变为0后下次再调用可以恢复到初始设定的值\",{\"1\":{\"593\":1}}],[\"区别在于打包方式选择\",{\"1\":{\"1441\":1}}],[\"区别在于\",{\"1\":{\"763\":1}}],[\"区别\",{\"1\":{\"159\":1,\"222\":1,\"533\":1,\"574\":1,\"595\":1,\"683\":1}}],[\"历史数据\",{\"1\":{\"238\":1}}],[\"未设置延迟\",{\"1\":{\"1290\":1}}],[\"未签到则记录为\",{\"1\":{\"1174\":1}}],[\"未点赞过则点赞数+1\",{\"1\":{\"1161\":1}}],[\"未过期\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"未必时时可写\",{\"1\":{\"828\":1}}],[\"未关注事件\",{\"1\":{\"740\":1}}],[\"未使用空间\",{\"1\":{\"663\":2}}],[\"未分桶表\",{\"1\":{\"237\":1}}],[\"未修改过的页面不用写回外存\",{\"1\":{\"190\":1}}],[\"余数相同的分到同一个文件\",{\"1\":{\"237\":1}}],[\"经度\",{\"1\":{\"1170\":1,\"1171\":1}}],[\"经拆分后每个步骤需要\",{\"1\":{\"755\":1}}],[\"经研究发现\",{\"1\":{\"755\":1}}],[\"经常被用来实现排行榜这样的功能\",{\"1\":{\"1211\":1}}],[\"经常用到这两个接口\",{\"1\":{\"756\":1}}],[\"经常\",{\"1\":{\"493\":1}}],[\"经过适配转换成\",{\"1\":{\"1368\":1}}],[\"经过测试\",{\"1\":{\"1180\":1}}],[\"经过以上代码改造后\",{\"1\":{\"1147\":1}}],[\"经过nginx的负载均衡分流后\",{\"1\":{\"1094\":1}}],[\"经过日志合并\",{\"1\":{\"1056\":1}}],[\"经过很多工序的加工\",{\"1\":{\"766\":1}}],[\"经过地址变换\",{\"1\":{\"683\":1}}],[\"经过shuffle阶段对id进行排序\",{\"1\":{\"452\":1}}],[\"经过shuffle阶段对id做分组\",{\"1\":{\"452\":1}}],[\"经过hash计算规则将数据文件划分成指定的若干个小文件\",{\"1\":{\"237\":1}}],[\"经纪人类\",{\"1\":{\"76\":1}}],[\"元数据文件\",{\"1\":{\"905\":1}}],[\"元数据按存储形式分类\",{\"1\":{\"905\":1}}],[\"元数据类型\",{\"1\":{\"905\":1}}],[\"元数据管理综述\",{\"0\":{\"905\":1}}],[\"元数据锁\",{\"1\":{\"510\":1}}],[\"元数据也采用外部数据库来存储元数据\",{\"1\":{\"244\":1}}],[\"元数据\",{\"0\":{\"238\":1},\"1\":{\"238\":1,\"258\":2}}],[\"元数据存储在内置的derby数据库\",{\"1\":{\"242\":1}}],[\"元数据存储在关系型数据库中\",{\"1\":{\"239\":1}}],[\"元数据存储\",{\"1\":{\"232\":1}}],[\"元素不重复\",{\"1\":{\"1211\":1}}],[\"元素不可重复\",{\"1\":{\"1210\":1}}],[\"元素可以重复\",{\"1\":{\"1209\":1}}],[\"元素配合使用\",{\"1\":{\"100\":1}}],[\"元素指定本地依赖的路径\",{\"1\":{\"100\":1}}],[\"元素的缺省值\",{\"1\":{\"100\":1}}],[\"架构原理\",{\"0\":{\"893\":1}}],[\"架构图\",{\"0\":{\"231\":1}}],[\"架构\",{\"0\":{\"230\":1}}],[\"抽取第4个bucket的数据\",{\"1\":{\"369\":1}}],[\"抽取\",{\"1\":{\"369\":2}}],[\"抽取日期函数\",{\"1\":{\"337\":2}}],[\"抽取extra\",{\"1\":{\"228\":1}}],[\"抽样函数\",{\"0\":{\"366\":1}}],[\"抽样可以从被抽取的数据中估计和推断出整体的特性\",{\"1\":{\"263\":1}}],[\"抽样就显得尤其重要了\",{\"1\":{\"263\":1}}],[\"抽象一个\",{\"1\":{\"723\":1}}],[\"抽象语法树ast\",{\"1\":{\"442\":1}}],[\"抽象方法\",{\"1\":{\"84\":1,\"88\":1}}],[\"抽象类主要用于代码复用\",{\"1\":{\"595\":1}}],[\"抽象类\",{\"1\":{\"84\":1}}],[\"抽象不应该依赖细节\",{\"1\":{\"74\":1}}],[\"抽象主题\",{\"1\":{\"57\":1}}],[\"抽象原型类\",{\"1\":{\"50\":1}}],[\"抽象工厂\",{\"1\":{\"33\":1,\"34\":1,\"38\":1,\"39\":1}}],[\"抽象工厂模式有多个抽象产品\",{\"1\":{\"38\":1}}],[\"抽象工厂模式的主要角色如下\",{\"1\":{\"38\":1}}],[\"抽象工厂模式是工厂方法模式的升级版本\",{\"1\":{\"37\":1}}],[\"抽象工厂模式\",{\"0\":{\"36\":1},\"1\":{\"25\":1}}],[\"抽象工厂模式实现对产品家族的创建\",{\"1\":{\"20\":1}}],[\"抽象工厂模式vs建造者模式\",{\"0\":{\"20\":1}}],[\"抽象产品\",{\"1\":{\"27\":1,\"33\":1,\"38\":1}}],[\"抽象\",{\"1\":{\"14\":2}}],[\"抽象建造者类\",{\"1\":{\"13\":1}}],[\"仪表盘\",{\"1\":{\"227\":1}}],[\"明显是不合理的\",{\"1\":{\"1161\":1}}],[\"明显会大于二级索引\",{\"1\":{\"497\":1}}],[\"明细粒度事实层\",{\"1\":{\"226\":1}}],[\"明星类\",{\"1\":{\"76\":1}}],[\"明星由于全身心投入艺术\",{\"1\":{\"76\":1}}],[\"明星与经纪人的关系实例\",{\"1\":{\"76\":1}}],[\"临键锁\",{\"1\":{\"511\":1}}],[\"临时节点\",{\"1\":{\"1140\":1}}],[\"临时表操作\",{\"0\":{\"409\":1}}],[\"临时缓存层\",{\"1\":{\"225\":1}}],[\"临界区\",{\"1\":{\"168\":1}}],[\"临界资源\",{\"1\":{\"168\":1}}],[\"阿里\",{\"1\":{\"633\":1}}],[\"阿里巴巴数仓3层架构\",{\"1\":{\"224\":1}}],[\"阿尔法小队\",{\"1\":{\"256\":1}}],[\"阿尔萨斯\",{\"1\":{\"59\":1}}],[\"操作元数据的工具类\",{\"1\":{\"1274\":1}}],[\"操作完之后\",{\"1\":{\"1155\":1}}],[\"操作数据库的回调函数\",{\"1\":{\"1129\":1}}],[\"操作代码\",{\"1\":{\"1127\":1}}],[\"操作锁的代码\",{\"1\":{\"1127\":1}}],[\"操作缓存和数据库时有三个问题需要考虑\",{\"1\":{\"1121\":1}}],[\"操作阻塞\",{\"1\":{\"857\":1}}],[\"操作时就不满足version=1\",{\"1\":{\"1135\":1}}],[\"操作时和正常删除操作一样\",{\"1\":{\"910\":1}}],[\"操作时\",{\"1\":{\"576\":1}}],[\"操作系内存\",{\"1\":{\"565\":1}}],[\"操作系统使用\",{\"1\":{\"854\":1}}],[\"操作系统出于性能的考虑\",{\"1\":{\"819\":1}}],[\"操作系统必须在内存中选择一个页面将其移出内存\",{\"1\":{\"690\":1}}],[\"操作系统虚拟内存介绍\",{\"0\":{\"686\":1}}],[\"操作系统就分配给它一块\",{\"1\":{\"683\":1}}],[\"操作系统内存管理介绍\",{\"0\":{\"681\":1}}],[\"操作系统会将i\",{\"1\":{\"678\":1}}],[\"操作系统会回收进程拥有的资源\",{\"1\":{\"160\":1}}],[\"操作系统将虚拟空间划分成两部分\",{\"1\":{\"676\":1}}],[\"操作系统将进程划分为几种状态\",{\"1\":{\"160\":1}}],[\"操作系统io介绍\",{\"0\":{\"675\":1}}],[\"操作系统层面\",{\"1\":{\"538\":1}}],[\"操作系统是无法修复的\",{\"1\":{\"206\":1}}],[\"操作系统向上提供的功能\",{\"1\":{\"194\":1}}],[\"操作系统下\",{\"0\":{\"193\":1}}],[\"操作系统为每一个进程分配一组固定数目的物理块\",{\"1\":{\"192\":1}}],[\"操作系统为进程分配资源\",{\"1\":{\"160\":1}}],[\"操作系统无法提前预判页面访问序列\",{\"1\":{\"191\":1}}],[\"操作系统用某种数据结构记录\",{\"1\":{\"184\":1}}],[\"操作系统如何记录各个分区空闲或者分配的情况\",{\"1\":{\"182\":1}}],[\"操作系统如何找到各个程序代码以及数据存储的位置\",{\"1\":{\"159\":1}}],[\"操作系统完成自动覆盖\",{\"1\":{\"181\":1}}],[\"操作系统负责内存空间的分配和回收\",{\"1\":{\"180\":1}}],[\"操作系统中\",{\"0\":{\"174\":1}}],[\"操作系统更偏向i\",{\"1\":{\"167\":1}}],[\"操作系统只看得见内核级线程\",{\"1\":{\"163\":1}}],[\"操作系统只负责提供共享空间和同步互斥工具\",{\"1\":{\"162\":1}}],[\"操作系统在内存中开辟一个区域供进程间共同使用\",{\"1\":{\"162\":1}}],[\"操作系统提供了一些方法\",{\"1\":{\"162\":1}}],[\"操作系统需要实现文件保护功能\",{\"1\":{\"211\":1}}],[\"操作系统需要实现的功能\",{\"0\":{\"154\":1}}],[\"操作系统需要建立一个数据结构\",{\"1\":{\"182\":1}}],[\"操作系统需要提供内存保护功能\",{\"1\":{\"180\":1}}],[\"操作系统需要提供地址转换功能\",{\"1\":{\"180\":1}}],[\"操作系统需要提供某种技术从逻辑上对内存空间进程扩充\",{\"1\":{\"180\":1}}],[\"操作系统需要提供进程同步机制来解决异步问题\",{\"1\":{\"159\":1}}],[\"操作系统通过pcb来管理进程\",{\"1\":{\"159\":1}}],[\"操作系统的内存管理主要负责内存的分配与回收\",{\"1\":{\"682\":1}}],[\"操作系统的内核\",{\"1\":{\"156\":1}}],[\"操作系统的核心是内核\",{\"1\":{\"676\":1}}],[\"操作系统的体系结构分为大内核和微内核\",{\"1\":{\"156\":1}}],[\"操作系统的体系结构\",{\"1\":{\"156\":1}}],[\"操作系统的并发性\",{\"1\":{\"155\":1}}],[\"操作系统的四个特征\",{\"0\":{\"155\":1}}],[\"操作系统的概念\",{\"0\":{\"153\":1}}],[\"操作系统作为最接近硬件的层次\",{\"1\":{\"154\":1}}],[\"操作系统作为用户和计算机硬件之间的接口\",{\"1\":{\"154\":1}}],[\"操作系统作为系统资源的管理者需要实现的功能和目标\",{\"1\":{\"154\":1}}],[\"操作系统\",{\"0\":{\"674\":1},\"1\":{\"153\":1,\"576\":1}}],[\"操作系统上\",{\"0\":{\"152\":1}}],[\"操作的数据范围\",{\"1\":{\"358\":1}}],[\"操作\",{\"0\":{\"278\":1},\"1\":{\"258\":1,\"742\":1,\"787\":2,\"1135\":1,\"1174\":1}}],[\"操作型数据层\",{\"1\":{\"224\":1,\"225\":1}}],[\"理想情况下为9个或更多\",{\"1\":{\"875\":1}}],[\"理论情况下\",{\"1\":{\"658\":1}}],[\"理论情况下添加到集合中的元素越多\",{\"1\":{\"658\":1}}],[\"理论上可以支持所有数据源\",{\"1\":{\"1454\":1}}],[\"理论上ide结果应该是1000\",{\"1\":{\"560\":1}}],[\"理论上分为三个层\",{\"1\":{\"224\":1}}],[\"理解为处理数据的工人\",{\"1\":{\"787\":1}}],[\"理解为数据的处理工序\",{\"1\":{\"787\":1}}],[\"理解为数据的通道\",{\"1\":{\"787\":1}}],[\"理解为流动的数据\",{\"1\":{\"787\":1}}],[\"理解什么是bio\",{\"1\":{\"608\":1}}],[\"理解\",{\"1\":{\"364\":1}}],[\"理解生成对抗网络\",{\"1\":{\"120\":1,\"127\":1}}],[\"英特尔isa\",{\"1\":{\"875\":1}}],[\"英雄数据\",{\"1\":{\"260\":1}}],[\"英雄名称\",{\"1\":{\"256\":2}}],[\"英语\",{\"1\":{\"219\":1}}],[\"英伟达gaugan2神笔马良\",{\"1\":{\"125\":1}}],[\"独占设备\",{\"1\":{\"213\":1}}],[\"独立线程去重构数据\",{\"1\":{\"1128\":1}}],[\"独立出来\",{\"1\":{\"703\":1}}],[\"独立出来一张表\",{\"1\":{\"480\":1}}],[\"独立于普通的应用程序\",{\"1\":{\"676\":1}}],[\"独立接收调度的基本单位\",{\"1\":{\"159\":1}}],[\"独立获得资源\",{\"1\":{\"159\":1}}],[\"独立性\",{\"1\":{\"159\":1}}],[\"输出最终的结果\",{\"1\":{\"990\":1}}],[\"输出的时候以goodsid号作为key\",{\"1\":{\"988\":1}}],[\"输出的结果<单词\",{\"1\":{\"958\":1,\"983\":1}}],[\"输出组件\",{\"1\":{\"986\":1}}],[\"输出组成\",{\"0\":{\"442\":1}}],[\"输出到不同文件中\",{\"1\":{\"973\":1}}],[\"输出文件的个数与reducetask个数是一种对等关系\",{\"1\":{\"968\":1}}],[\"输出数据路径\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"输出数据\",{\"1\":{\"958\":1,\"983\":1}}],[\"输出\",{\"1\":{\"668\":1,\"696\":1,\"746\":2,\"748\":1,\"750\":1,\"751\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"768\":1,\"775\":1,\"776\":6,\"779\":1,\"780\":2,\"796\":1,\"805\":1,\"808\":1,\"820\":1,\"836\":1,\"839\":1,\"848\":1,\"857\":1,\"1294\":2}}],[\"输出结果\",{\"1\":{\"373\":1,\"466\":1,\"988\":1}}],[\"输出缓冲区\",{\"1\":{\"212\":1}}],[\"输出进程\",{\"1\":{\"212\":1}}],[\"输出井\",{\"1\":{\"212\":1}}],[\"输出技术\",{\"1\":{\"212\":1}}],[\"输入输出的组件实现都是针对文本数据处理的\",{\"1\":{\"984\":1}}],[\"输入输出的数据路径\",{\"1\":{\"962\":1}}],[\"输入输出的数据类型\",{\"1\":{\"962\":1}}],[\"输入网址到网页显示期间发生了什么\",{\"0\":{\"652\":1}}],[\"输入文件的总大小小于\",{\"1\":{\"444\":1}}],[\"输入值是从select语句的结果集中的一行或多行的\",{\"1\":{\"356\":1}}],[\"输入缓冲区用于暂存从输入设备输入的数据\",{\"1\":{\"212\":1}}],[\"输入缓冲区\",{\"1\":{\"212\":1}}],[\"输入进程\",{\"1\":{\"212\":1}}],[\"输入井\",{\"1\":{\"212\":1}}],[\"输入法换皮肤\",{\"1\":{\"41\":1}}],[\"脱机技术简介\",{\"1\":{\"212\":1}}],[\"脱机命令接口\",{\"1\":{\"154\":1}}],[\"加上rollbackfor=exception\",{\"1\":{\"1516\":1}}],[\"加上实现循环检查的一系列指令即可\",{\"1\":{\"209\":1}}],[\"加在\",{\"1\":{\"1294\":1}}],[\"加在成员变量上就不行了\",{\"1\":{\"1294\":1}}],[\"加在也可以加在成员变量上\",{\"1\":{\"1294\":1}}],[\"加\",{\"1\":{\"1211\":1}}],[\"加锁原理是什么呢\",{\"1\":{\"1153\":1}}],[\"加锁\",{\"1\":{\"1144\":1}}],[\"加锁逻辑\",{\"1\":{\"1142\":1}}],[\"加锁解锁流程\",{\"1\":{\"591\":1}}],[\"加强用户权限校验\",{\"1\":{\"1124\":1}}],[\"加速纠删码的编码和解码\",{\"1\":{\"875\":1}}],[\"加入到消费者组\",{\"1\":{\"1037\":1}}],[\"加入依赖\",{\"1\":{\"783\":1}}],[\"加入至\",{\"1\":{\"740\":1}}],[\"加入群聊\",{\"1\":{\"704\":1}}],[\"加入自己\",{\"1\":{\"702\":1}}],[\"加入聊天组\",{\"1\":{\"701\":1}}],[\"加入\",{\"1\":{\"698\":1}}],[\"加解写锁\",{\"1\":{\"590\":1}}],[\"加解读锁\",{\"1\":{\"590\":1}}],[\"加值并获取\",{\"1\":{\"562\":1}}],[\"加mdl写锁\",{\"1\":{\"510\":1}}],[\"加mdl读锁\",{\"1\":{\"510\":1}}],[\"加载spring\",{\"1\":{\"1524\":1}}],[\"加载student表数据\",{\"1\":{\"287\":1}}],[\"加载\",{\"1\":{\"1444\":1,\"1446\":1}}],[\"加载的是主存中最新数据\",{\"1\":{\"557\":1}}],[\"加载数据\",{\"1\":{\"351\":1,\"408\":1}}],[\"加载数据文件到表中\",{\"1\":{\"348\":1}}],[\"加载一个文件dual\",{\"1\":{\"329\":1}}],[\"加密区域里的每个文件都有其自己加密密钥\",{\"1\":{\"931\":1}}],[\"加密区域\",{\"0\":{\"930\":1}}],[\"加密\",{\"1\":{\"201\":1}}],[\"加密保护\",{\"1\":{\"201\":1}}],[\"轮流处理\",{\"1\":{\"846\":1}}],[\"轮流的让各个进程执行一个时间片\",{\"1\":{\"167\":1}}],[\"轮流的为各个进程服务\",{\"1\":{\"167\":1}}],[\"轮询策略是将消费组内所有消费者以及消费者所订阅的所有\",{\"1\":{\"1041\":1}}],[\"轮询策略\",{\"0\":{\"1032\":1}}],[\"轮询\",{\"1\":{\"209\":1}}],[\"属组具有权限rwx\",{\"1\":{\"925\":1}}],[\"属性值\",{\"1\":{\"701\":2}}],[\"属性名\",{\"1\":{\"701\":2}}],[\"属性也必须从\",{\"1\":{\"666\":1}}],[\"属性从原来的\",{\"1\":{\"666\":1}}],[\"属性只有\",{\"1\":{\"666\":1}}],[\"属性会根据前一个节点的长度进行不同的空间大小分配\",{\"1\":{\"666\":1}}],[\"属性的空间大小跟数据是字符串还是整数\",{\"1\":{\"665\":1}}],[\"属性的空间大小跟前一个节点长度值有关\",{\"1\":{\"665\":1}}],[\"属性需要用\",{\"1\":{\"665\":2,\"666\":3}}],[\"属性都记录了\",{\"1\":{\"665\":1}}],[\"属性定义下面的结构体\",{\"1\":{\"663\":1}}],[\"属性定义结构体\",{\"1\":{\"663\":1}}],[\"属性用final修饰保证该属性是只读的\",{\"1\":{\"566\":1}}],[\"属性\",{\"1\":{\"239\":1,\"610\":1,\"1531\":1}}],[\"属性中引用的其他对象也会被克隆\",{\"1\":{\"51\":1}}],[\"属于哪个partition\",{\"1\":{\"1025\":1}}],[\"属于哪个topic\",{\"1\":{\"1025\":1}}],[\"属于同一个州的各个县输出到同一个结果文件中\",{\"1\":{\"973\":1}}],[\"属于比较昂贵的操作\",{\"1\":{\"741\":1}}],[\"属于操作系统参数\",{\"1\":{\"727\":1}}],[\"属于操作系统的内核部分\",{\"1\":{\"211\":1}}],[\"属于\",{\"1\":{\"725\":1,\"726\":1,\"728\":1,\"729\":1,\"730\":1,\"731\":1}}],[\"属于小概率事件\",{\"1\":{\"507\":1}}],[\"属于顺序io\",{\"1\":{\"506\":1}}],[\"属于udtf\",{\"1\":{\"396\":1}}],[\"属于硬件故障\",{\"1\":{\"206\":1}}],[\"坏块\",{\"1\":{\"206\":1}}],[\"坏块管理\",{\"1\":{\"206\":1}}],[\"盘\",{\"1\":{\"206\":1}}],[\"盘面\",{\"1\":{\"203\":1}}],[\"转发至\",{\"1\":{\"1436\":1}}],[\"转为需要的\",{\"1\":{\"1370\":1}}],[\"转为类型\",{\"1\":{\"1368\":1}}],[\"转为其它类型\",{\"1\":{\"1368\":1}}],[\"转到与中断信号对应的处理程序去执行\",{\"1\":{\"676\":1}}],[\"转向正确的节点\",{\"1\":{\"527\":1}}],[\"转换\",{\"1\":{\"1370\":2,\"1482\":1}}],[\"转换为\",{\"1\":{\"1174\":1}}],[\"转换为其它类型的\",{\"1\":{\"775\":1}}],[\"转换至可运行状态\",{\"1\":{\"538\":1}}],[\"转换成了对物化视图的查询\",{\"1\":{\"276\":1}}],[\"转换器第1面插入当地的插座\",{\"1\":{\"4\":1}}],[\"转化transfer\",{\"1\":{\"228\":1}}],[\"转化成特定设备能听得懂的一些列操作\",{\"1\":{\"210\":1}}],[\"转两圈读取完0号盘面的数据以后\",{\"1\":{\"205\":1}}],[\"转两圈读完的原因\",{\"1\":{\"205\":1}}],[\"减少正常用法\",{\"1\":{\"1206\":1}}],[\"减少溢写到磁盘的数据量\",{\"1\":{\"979\":1}}],[\"减少磁盘io的影响\",{\"1\":{\"979\":1}}],[\"减少\",{\"1\":{\"855\":1}}],[\"减少内存溢出的可能\",{\"1\":{\"770\":1,\"781\":1}}],[\"减少内存碎片\",{\"1\":{\"683\":1}}],[\"减少了一次数据拷贝\",{\"1\":{\"855\":1}}],[\"减少了线程上下文切换\",{\"1\":{\"829\":1}}],[\"减少了系统开销\",{\"1\":{\"610\":1}}],[\"减少了比较次数\",{\"1\":{\"450\":1}}],[\"减少select\",{\"1\":{\"505\":1}}],[\"减少map到reduce的传输数据\",{\"1\":{\"459\":1}}],[\"减少不必要的数据加载\",{\"1\":{\"415\":1}}],[\"减少笛卡尔积数量\",{\"1\":{\"263\":1,\"418\":1}}],[\"减少延迟时间的方法\",{\"0\":{\"205\":1},\"1\":{\"205\":2}}],[\"减少信号量的数目\",{\"1\":{\"172\":1}}],[\"循环遍历\",{\"1\":{\"1176\":1}}],[\"循环\",{\"1\":{\"746\":1}}],[\"循环栅栏\",{\"1\":{\"593\":1}}],[\"循环进行cas重试\",{\"1\":{\"564\":1}}],[\"循环这个过程\",{\"1\":{\"478\":1}}],[\"循环缓冲区\",{\"1\":{\"214\":1}}],[\"循环扫描算法\",{\"1\":{\"204\":1}}],[\"循环等待条件\",{\"1\":{\"175\":1,\"551\":1}}],[\"寻道时间\",{\"1\":{\"204\":2}}],[\"寻找时间\",{\"1\":{\"204\":1}}],[\"柱面\",{\"1\":{\"203\":2}}],[\"扇区都一一对应\",{\"1\":{\"205\":1}}],[\"扇区\",{\"1\":{\"203\":1}}],[\"磁道\",{\"1\":{\"203\":1}}],[\"磁盘到磁盘\",{\"1\":{\"980\":1}}],[\"磁盘上相应的就会有多个临时文件存在\",{\"1\":{\"979\":1}}],[\"磁盘均衡器\",{\"0\":{\"874\":1}}],[\"磁盘调度\",{\"1\":{\"211\":1}}],[\"磁盘调度算法\",{\"0\":{\"204\":1},\"1\":{\"204\":1}}],[\"磁盘初始化\",{\"1\":{\"206\":1}}],[\"磁盘的管理\",{\"0\":{\"206\":1}}],[\"磁盘的分类\",{\"1\":{\"203\":1}}],[\"磁盘的结构\",{\"0\":{\"203\":1}}],[\"磁盘i\",{\"1\":{\"197\":1,\"432\":1}}],[\"磁盘块的大小与内存块\",{\"1\":{\"197\":1}}],[\"磁盘块\",{\"1\":{\"197\":1}}],[\"磁盘中的存储单元也会被分为一个个\",{\"1\":{\"197\":1}}],[\"磁盘\",{\"1\":{\"181\":1,\"203\":1,\"873\":1,\"874\":2,\"948\":1}}],[\"标注监听方法\",{\"1\":{\"1493\":1}}],[\"标注\",{\"1\":{\"1489\":1}}],[\"标注方法作为扩展点\",{\"1\":{\"1376\":1}}],[\"标注的\",{\"1\":{\"1489\":1}}],[\"标注的接口\",{\"1\":{\"1455\":1}}],[\"标注的销毁方法\",{\"1\":{\"1289\":1}}],[\"标注的初始化方法\",{\"1\":{\"1289\":1}}],[\"标注需排序的元素\",{\"1\":{\"644\":1}}],[\"标示业务状态\",{\"1\":{\"1174\":1}}],[\"标示是否被当前用户点赞\",{\"1\":{\"1161\":1}}],[\"标准的操作方式就是查询数据库之前先查询缓存\",{\"1\":{\"1117\":1}}],[\"标准语法\",{\"1\":{\"290\":1}}],[\"标点符号\",{\"1\":{\"709\":1}}],[\"标记为❤的就是推荐使用的java客户端\",{\"1\":{\"1212\":1}}],[\"标记压缩列表的结束点\",{\"1\":{\"665\":1}}],[\"标记当前position位置\",{\"1\":{\"610\":1}}],[\"标记各\",{\"1\":{\"201\":1}}],[\"标签\",{\"1\":{\"92\":2}}],[\"译码\",{\"1\":{\"201\":1}}],[\"软链接\",{\"1\":{\"200\":1}}],[\"软件的一个核心功能之一\",{\"1\":{\"97\":1}}],[\"软件中最重要的功能之一\",{\"1\":{\"97\":1}}],[\"软件\",{\"1\":{\"91\":1,\"876\":1}}],[\"软件设计原则\",{\"0\":{\"71\":1}}],[\"硬着陆导致的损害\",{\"1\":{\"1113\":1}}],[\"硬件的性能水平\",{\"1\":{\"1019\":1}}],[\"硬件性能的提升也有助于降低收集器运行时对应用程序的影响\",{\"1\":{\"637\":1}}],[\"硬链接\",{\"1\":{\"200\":1}}],[\"硬盘全部打满\",{\"1\":{\"1094\":1}}],[\"硬盘只能是希捷的\",{\"1\":{\"74\":1}}],[\"硬盘可以选择希捷\",{\"1\":{\"74\":1}}],[\"硬盘\",{\"1\":{\"74\":1}}],[\"足够\",{\"1\":{\"198\":1}}],[\"离散分配都适用\",{\"1\":{\"198\":1}}],[\"离散分配时所分配地址空间的基本单位不同\",{\"1\":{\"187\":1}}],[\"位对应当月的每一天\",{\"1\":{\"1174\":1}}],[\"位\",{\"1\":{\"826\":2,\"920\":1,\"1174\":1,\"1176\":2}}],[\"位数组中的每个元素都只占用\",{\"1\":{\"658\":1}}],[\"位表示线程数量\",{\"1\":{\"571\":1}}],[\"位来表示线程池状态\",{\"1\":{\"571\":1}}],[\"位异或操作\",{\"1\":{\"331\":1}}],[\"位或操作\",{\"1\":{\"331\":1}}],[\"位与操作\",{\"1\":{\"331\":1}}],[\"位视图法\",{\"1\":{\"198\":1}}],[\"位置\",{\"0\":{\"817\":1},\"1\":{\"98\":1,\"99\":1,\"279\":1,\"771\":1,\"804\":1}}],[\"③混合索引\",{\"1\":{\"197\":1}}],[\"③用户模块\",{\"0\":{\"114\":1}}],[\"②分配第一个分组中的100个空闲块\",{\"1\":{\"198\":1}}],[\"②多层索引\",{\"1\":{\"197\":1}}],[\"②通用模块\",{\"0\":{\"113\":1}}],[\"①检查第一个分组的块数是否足够\",{\"1\":{\"198\":1}}],[\"①链接方案\",{\"1\":{\"197\":1}}],[\"①父模块\",{\"0\":{\"112\":1}}],[\"支持两大类数据源\",{\"1\":{\"1454\":1}}],[\"支持\",{\"1\":{\"1441\":1}}],[\"支持五种\",{\"1\":{\"1290\":1}}],[\"支持基于redis的jdkcollection实现\",{\"1\":{\"1217\":1}}],[\"支持基于jdk\",{\"1\":{\"1217\":1}}],[\"支持基于lettuce的响应式编程\",{\"1\":{\"1217\":1}}],[\"支持redis哨兵和redis集群\",{\"1\":{\"1217\":1}}],[\"支持redis的发布订阅模型\",{\"1\":{\"1217\":1}}],[\"支持交集\",{\"1\":{\"1210\":1}}],[\"支持多语言客户端\",{\"1\":{\"1190\":1}}],[\"支持多种type\",{\"1\":{\"1062\":1}}],[\"支持主从集群\",{\"1\":{\"1190\":1}}],[\"支持数据持久化\",{\"1\":{\"1190\":1}}],[\"支持数据单位\",{\"1\":{\"368\":1}}],[\"支持每秒产生2^32个不同id\",{\"1\":{\"1131\":1}}],[\"支持超过两个\",{\"1\":{\"883\":1}}],[\"支持链式调用\",{\"1\":{\"781\":1}}],[\"支持一个进程所能打开的最大连接数\",{\"1\":{\"680\":1}}],[\"支持配置为阻塞同步\",{\"1\":{\"527\":1}}],[\"支持非等值连接\",{\"1\":{\"326\":1}}],[\"支持结果缓存\",{\"1\":{\"258\":1}}],[\"支持asc\",{\"1\":{\"358\":1}}],[\"支持acid系统的后台进程\",{\"1\":{\"294\":1}}],[\"支持acid\",{\"1\":{\"258\":1}}],[\"支持archive\",{\"1\":{\"258\":1}}],[\"支持顺序访问和直接访问\",{\"1\":{\"197\":1}}],[\"支持用户级线程和内核级线程的系统中\",{\"1\":{\"163\":1}}],[\"块存储\",{\"1\":{\"888\":1}}],[\"块存储层\",{\"1\":{\"888\":1}}],[\"块管理通过处理注册和定期心跳来提供datanode群集成员身份\",{\"1\":{\"888\":1}}],[\"块管理\",{\"1\":{\"888\":1}}],[\"块和目录组成的统一抽象的目录树结构\",{\"1\":{\"888\":1}}],[\"块组\",{\"1\":{\"875\":1}}],[\"块大小信息等等\",{\"1\":{\"869\":1}}],[\"块式管理\",{\"1\":{\"683\":1}}],[\"块io的效率比流io高很多\",{\"1\":{\"612\":1}}],[\"块\",{\"1\":{\"197\":1,\"209\":1}}],[\"层次结构清晰\",{\"1\":{\"196\":1}}],[\"显然当只有一件物品的时候\",{\"1\":{\"649\":1}}],[\"显然比较麻烦\",{\"1\":{\"58\":1}}],[\"显式类型转换使用cast函数\",{\"1\":{\"248\":1}}],[\"显示所有的函数和运算符\",{\"1\":{\"328\":1}}],[\"显示select返回的行数\",{\"1\":{\"309\":1}}],[\"显示已有的物化视图\",{\"1\":{\"276\":1}}],[\"显示当前已有视图\",{\"1\":{\"271\":1}}],[\"显示转换\",{\"1\":{\"248\":1}}],[\"显示链接\",{\"1\":{\"197\":2}}],[\"显示目录\",{\"1\":{\"196\":1}}],[\"搜索关键词unix\",{\"1\":{\"872\":1}}],[\"搜索引擎\",{\"1\":{\"791\":1}}],[\"搜索引擎回滚\",{\"1\":{\"483\":1}}],[\"搜索\",{\"1\":{\"196\":1,\"1061\":1}}],[\"搜狗输入法\",{\"1\":{\"72\":3}}],[\"索引查询getsettings\",{\"1\":{\"1072\":1}}],[\"索引查询getmappings\",{\"1\":{\"1072\":1}}],[\"索引查询getaliases\",{\"1\":{\"1072\":1}}],[\"索引删除\",{\"1\":{\"1072\":1}}],[\"索引操作\",{\"0\":{\"1072\":1},\"1\":{\"1072\":1}}],[\"索引下推\",{\"0\":{\"495\":1}}],[\"索引列按递增的顺序\",{\"1\":{\"493\":1}}],[\"索引就是让数据按照某种顺序进行存储或检索\",{\"1\":{\"493\":1}}],[\"索引主要有4种\",{\"1\":{\"492\":1}}],[\"索引树会一次性加载吗\",{\"0\":{\"486\":1}}],[\"索引也要进行动态维护\",{\"1\":{\"485\":1}}],[\"索引需要占磁盘空间\",{\"1\":{\"485\":1}}],[\"索引是在存储引擎中实现的\",{\"1\":{\"485\":1}}],[\"索引物理文件全扫描\",{\"1\":{\"481\":1}}],[\"索引a\",{\"1\":{\"481\":1}}],[\"索引中有范围查找\",{\"1\":{\"481\":1}}],[\"索引\",{\"0\":{\"1061\":1},\"1\":{\"481\":1,\"1066\":2}}],[\"索引长度\",{\"1\":{\"481\":1,\"493\":1}}],[\"索引规约\",{\"0\":{\"481\":1}}],[\"索引默认的优化器引擎rbo\",{\"1\":{\"455\":1}}],[\"索引表不会自动更新\",{\"1\":{\"424\":1}}],[\"索引类型为compact\",{\"1\":{\"423\":1}}],[\"索引的分类\",{\"0\":{\"492\":1}}],[\"索引的长度与区分度是一对矛盾体\",{\"1\":{\"481\":1,\"493\":1}}],[\"索引的问题\",{\"0\":{\"424\":1}}],[\"索引的使用\",{\"0\":{\"423\":1}}],[\"索引的目的\",{\"0\":{\"422\":1}}],[\"索引的原理\",{\"0\":{\"421\":1}}],[\"索引功能支持是从hive0\",{\"1\":{\"420\":1}}],[\"索引设计\",{\"0\":{\"419\":1}}],[\"索引分配\",{\"1\":{\"197\":1}}],[\"索引结点\",{\"1\":{\"196\":1}}],[\"索引顺序文件\",{\"1\":{\"195\":1}}],[\"索引文件可能比数据文件更快达到最大文件尺寸\",{\"1\":{\"485\":1}}],[\"索引文件具有b\",{\"1\":{\"481\":1}}],[\"索引文件\",{\"1\":{\"195\":1}}],[\"索引方式\",{\"1\":{\"159\":1}}],[\"逻辑视图名\",{\"1\":{\"1530\":1}}],[\"逻辑代码\",{\"1\":{\"1176\":1}}],[\"逻辑说明\",{\"1\":{\"1143\":1}}],[\"逻辑分析\",{\"1\":{\"1126\":1}}],[\"逻辑过期时间单位\",{\"1\":{\"1129\":2}}],[\"逻辑过期时间\",{\"1\":{\"1128\":1,\"1129\":2}}],[\"逻辑过期方案\",{\"1\":{\"1126\":2}}],[\"逻辑过期\",{\"1\":{\"1126\":1,\"1129\":1}}],[\"逻辑规划后\",{\"1\":{\"979\":1}}],[\"逻辑规划结果写入规划文件\",{\"1\":{\"976\":1}}],[\"逻辑规划机制由fileinputformat类的getsplits方法完成\",{\"1\":{\"976\":1}}],[\"逻辑规划\",{\"1\":{\"976\":1}}],[\"逻辑是否存在\",{\"1\":{\"332\":2}}],[\"逻辑运算符\",{\"0\":{\"332\":1},\"1\":{\"328\":1}}],[\"逻辑存在的\",{\"1\":{\"275\":1}}],[\"逻辑上没有最大值限制\",{\"1\":{\"726\":1}}],[\"逻辑上\",{\"1\":{\"195\":1}}],[\"逻辑地址和物理地址\",{\"0\":{\"684\":1}}],[\"逻辑地址转物理地址\",{\"1\":{\"188\":1}}],[\"逻辑地址在页面的偏移量\",{\"1\":{\"184\":1}}],[\"逻辑地址如何转换为物理地址\",{\"1\":{\"184\":1}}],[\"逻辑地址就是相对初始位置的距离\",{\"1\":{\"179\":1}}],[\"逻辑地址\",{\"1\":{\"179\":3,\"184\":2}}],[\"定期在集群间或集群内部进行数据备份\",{\"1\":{\"869\":1}}],[\"定期删除对内存更加友好\",{\"1\":{\"520\":1}}],[\"定期删除\",{\"1\":{\"520\":1}}],[\"定时任务\",{\"1\":{\"787\":1}}],[\"定长字节表示内容长度\",{\"1\":{\"709\":1}}],[\"定长记录\",{\"1\":{\"195\":1}}],[\"定制排序\",{\"1\":{\"618\":1}}],[\"定位死锁的方法\",{\"1\":{\"551\":1}}],[\"定义配置类\",{\"1\":{\"1532\":1}}],[\"定义配置文件\",{\"1\":{\"42\":1}}],[\"定义等\",{\"1\":{\"1446\":1}}],[\"定义出来具体的返回值实体类\",{\"1\":{\"1168\":1}}],[\"定义最终订阅者\",{\"1\":{\"718\":1}}],[\"定义处理器\",{\"1\":{\"718\":1}}],[\"定义订阅者\",{\"1\":{\"717\":1}}],[\"定义发布者\",{\"1\":{\"717\":1,\"718\":1}}],[\"定义字段类型为text\",{\"1\":{\"480\":1}}],[\"定义输出的value\",{\"1\":{\"373\":1}}],[\"定义输出的key\",{\"1\":{\"373\":1}}],[\"定义了对其他库的传递依赖\",{\"1\":{\"1521\":1}}],[\"定义了算法的骨架\",{\"1\":{\"84\":1}}],[\"定义了产品的规范\",{\"1\":{\"27\":1,\"33\":1,\"38\":1}}],[\"定义一个计数器\",{\"1\":{\"1176\":1}}],[\"定义一个操作中的算法骨架\",{\"1\":{\"83\":1}}],[\"定义一个用于创建对象的接口\",{\"1\":{\"32\":1}}],[\"定义一个创建对象的接口\",{\"1\":{\"23\":1}}],[\"定义一个适配器类来实现当前系统的业务接口\",{\"1\":{\"6\":1}}],[\"定义各种抽象组件\",{\"1\":{\"14\":1}}],[\"定义适配器类\",{\"1\":{\"6\":1}}],[\"定义\",{\"1\":{\"4\":1,\"83\":1,\"1271\":1,\"1444\":1,\"1446\":1}}],[\"占用整个服务器\",{\"1\":{\"1056\":1}}],[\"占用\",{\"1\":{\"742\":1}}],[\"占用空间都发生变化\",{\"1\":{\"666\":1}}],[\"占用一块连续的内存空间\",{\"1\":{\"664\":1}}],[\"占用36字节\",{\"1\":{\"502\":1}}],[\"占用8个字节\",{\"1\":{\"487\":1}}],[\"占用4个字节\",{\"1\":{\"487\":1}}],[\"占用的存储空间\",{\"1\":{\"195\":1}}],[\"占了总数据的90\",{\"1\":{\"455\":1}}],[\"占有cpu\",{\"1\":{\"160\":1}}],[\"工序有多道\",{\"1\":{\"787\":1}}],[\"工人按照\",{\"1\":{\"787\":1}}],[\"工人既可以执行\",{\"1\":{\"787\":1}}],[\"工人可以管理多个\",{\"1\":{\"787\":1}}],[\"工人执行\",{\"1\":{\"748\":2}}],[\"工人也分别绑定了\",{\"1\":{\"748\":1}}],[\"工人和\",{\"1\":{\"748\":1}}],[\"工人\",{\"1\":{\"748\":2}}],[\"工资总和\",{\"1\":{\"620\":1}}],[\"工作目录\",{\"1\":{\"1196\":1}}],[\"工作流job控制器\",{\"1\":{\"991\":1}}],[\"工作流\",{\"0\":{\"991\":1}}],[\"工作在非阻塞模式下\",{\"1\":{\"867\":1}}],[\"工作模式⚠️\",{\"0\":{\"812\":1}}],[\"工作量大\",{\"1\":{\"792\":1}}],[\"工作原理\",{\"1\":{\"623\":1}}],[\"工作时\",{\"1\":{\"601\":1}}],[\"工作中最常见的数据文件格式就是textfile文件\",{\"1\":{\"427\":1}}],[\"工作集\",{\"1\":{\"192\":1}}],[\"工具反编译第\",{\"1\":{\"1313\":1}}],[\"工具反编译代理类\",{\"1\":{\"1310\":1}}],[\"工具类\",{\"1\":{\"1022\":1}}],[\"工具\",{\"0\":{\"217\":1}}],[\"工厂设计模式是实际开发中非常常用的一种设计模式\",{\"1\":{\"1215\":1}}],[\"工厂方法使一个产品类的实例化延迟到其工厂的子类\",{\"1\":{\"32\":1}}],[\"工厂方法模式只生产一个等级的产品\",{\"1\":{\"37\":1}}],[\"工厂方法模式只考虑生产同等级的产品\",{\"1\":{\"36\":1}}],[\"工厂方法模式保持了简单工厂模式的优点\",{\"1\":{\"34\":1}}],[\"工厂方法模式是简单工厂模式的进一步抽象\",{\"1\":{\"34\":1}}],[\"工厂方法模式的主要角色\",{\"1\":{\"33\":1}}],[\"工厂方法模式\",{\"0\":{\"31\":1},\"1\":{\"25\":1}}],[\"工厂方法模式注重的是整体对象的创建方式\",{\"1\":{\"19\":1}}],[\"工厂方法模式vs建造者模式\",{\"0\":{\"19\":1}}],[\"工厂类的客户端可能有很多\",{\"1\":{\"28\":1}}],[\"工厂类代码如下\",{\"1\":{\"28\":1}}],[\"工厂对象和商品对象的耦合\",{\"1\":{\"28\":1}}],[\"工厂\",{\"1\":{\"28\":1}}],[\"工厂模式最大的优点就是\",{\"1\":{\"25\":1}}],[\"工厂模式使其创建过程延迟到子类进行\",{\"1\":{\"23\":1}}],[\"工厂模式\",{\"0\":{\"23\":1,\"24\":1}}],[\"颠簸\",{\"1\":{\"192\":1}}],[\"抖动\",{\"1\":{\"192\":1}}],[\"预设长度\",{\"0\":{\"699\":1}}],[\"预计废弃\",{\"1\":{\"638\":1}}],[\"预写式日志\",{\"1\":{\"506\":1}}],[\"预调页策略\",{\"1\":{\"192\":1}}],[\"预防死锁\",{\"0\":{\"176\":1},\"1\":{\"175\":1}}],[\"何时不阻塞💡\",{\"0\":{\"833\":1}}],[\"何时调入页面\",{\"1\":{\"192\":1}}],[\"何时使用\",{\"1\":{\"23\":1}}],[\"√\",{\"1\":{\"192\":3}}],[\"全称page\",{\"1\":{\"1179\":1}}],[\"全称unique\",{\"1\":{\"1179\":1}}],[\"全部进行合并merge\",{\"1\":{\"966\":1}}],[\"全部数据处理完成\",{\"1\":{\"717\":1,\"718\":2}}],[\"全连接队列\",{\"1\":{\"726\":1}}],[\"全程没有加锁\",{\"1\":{\"579\":1}}],[\"全局异常捕获\",{\"1\":{\"1526\":2}}],[\"全局异常捕获>>>\",{\"1\":{\"1526\":1}}],[\"全局异常处理器\",{\"1\":{\"1526\":1}}],[\"全局增强点5️⃣\",{\"1\":{\"1438\":1}}],[\"全局增强点4️⃣\",{\"1\":{\"1438\":1}}],[\"全局增强点3️⃣\",{\"1\":{\"1438\":1}}],[\"全局增强点2️⃣\",{\"1\":{\"1438\":1}}],[\"全局增强点1️⃣\",{\"1\":{\"1438\":1}}],[\"全局id生成器\",{\"1\":{\"1131\":1}}],[\"全局hash表以及多种高效数据结构\",{\"1\":{\"517\":1}}],[\"全局唯一id\",{\"0\":{\"1131\":1}}],[\"全局唯一\",{\"1\":{\"502\":1}}],[\"全局唯一保证在各系统之间都是唯一的\",{\"1\":{\"502\":1}}],[\"全局置换\",{\"1\":{\"192\":2}}],[\"全外连接\",{\"0\":{\"323\":1}}],[\"全息碎片\",{\"1\":{\"256\":1}}],[\"全类名\",{\"1\":{\"42\":1}}],[\"驻留集的大小不能小于工作集的大小\",{\"1\":{\"192\":1}}],[\"驻留集大小可变\",{\"1\":{\"192\":1}}],[\"驻留集大小不变\",{\"1\":{\"192\":1}}],[\"驻留集大小一般小于进程的总大小\",{\"1\":{\"192\":1}}],[\"驻留集太大\",{\"1\":{\"192\":1}}],[\"驻留集太小\",{\"1\":{\"192\":1}}],[\"驻留集\",{\"1\":{\"192\":1}}],[\"暂停期间不会占用\",{\"1\":{\"826\":1}}],[\"暂停时间的重要性日益凸显\",{\"1\":{\"637\":1}}],[\"暂停时间\",{\"1\":{\"637\":3}}],[\"暂不换出\",{\"1\":{\"191\":1}}],[\"暂时用不到的部分留在外存\",{\"1\":{\"189\":1}}],[\"暂时用不到的数据放在更低速的存储器中\",{\"1\":{\"189\":1}}],[\"暂时用不到的数据\",{\"1\":{\"189\":1}}],[\"暂时放到外存上\",{\"1\":{\"178\":1}}],[\"暂时调到外存的进程状态为挂起状态\",{\"1\":{\"164\":1}}],[\"找对应的\",{\"1\":{\"1155\":1}}],[\"找出词频top100的词\",{\"1\":{\"477\":1}}],[\"找出每个用户访问pv的最多的top3\",{\"1\":{\"363\":1}}],[\"找出student中男女学生年龄最大的及其名字\",{\"1\":{\"351\":1}}],[\"找最晚出现的淘汰掉\",{\"1\":{\"191\":1}}],[\"找到\",{\"1\":{\"1355\":1}}],[\"找到有\",{\"1\":{\"1333\":1}}],[\"找到这些方法编号\",{\"1\":{\"1321\":1}}],[\"找到该圆内包含的所有member\",{\"1\":{\"1170\":1}}],[\"找到该文件对应的目录项\",{\"1\":{\"196\":1}}],[\"找到对应的数据位置\",{\"1\":{\"1052\":1}}],[\"找到一条完整消息\",{\"1\":{\"840\":1}}],[\"找到反序列化算法\",{\"1\":{\"723\":1}}],[\"找到合适的插入位置\",{\"1\":{\"644\":1}}],[\"找到最大\",{\"1\":{\"643\":1}}],[\"找到相同的key\",{\"1\":{\"579\":1}}],[\"找到如下规律\",{\"1\":{\"399\":1}}],[\"找到目标扇区平均需要转半圈\",{\"1\":{\"204\":1}}],[\"找到大小能够满足要求的第一个空闲分区\",{\"1\":{\"183\":4}}],[\"找到第一个能满足大小的空闲分区\",{\"1\":{\"183\":1}}],[\"放行\",{\"1\":{\"1100\":1,\"1111\":1}}],[\"放入自己线程的标识\",{\"1\":{\"1144\":1}}],[\"放入到事务中提交\",{\"1\":{\"1051\":1}}],[\"放入\",{\"1\":{\"726\":1,\"775\":1,\"837\":1,\"1368\":1,\"1394\":4,\"1411\":1}}],[\"放入新的hash表中\",{\"1\":{\"606\":1}}],[\"放入阻塞队列\",{\"1\":{\"190\":1,\"1157\":1}}],[\"放到子查询中做条件验证\",{\"1\":{\"332\":1}}],[\"放回就绪队列\",{\"1\":{\"190\":1}}],[\"远古时代的计算机操作系统的内存管理方式\",{\"1\":{\"683\":1}}],[\"远大于实际的容量\",{\"1\":{\"189\":1}}],[\"远程词典服务器\",{\"1\":{\"1190\":1}}],[\"远程连接需要配置server\",{\"1\":{\"1018\":1}}],[\"远程rpc\",{\"1\":{\"576\":1}}],[\"远程模式下\",{\"1\":{\"244\":1}}],[\"远程模式\",{\"0\":{\"244\":1},\"1\":{\"241\":2,\"244\":2}}],[\"远程\",{\"1\":{\"63\":1}}],[\"直至\",{\"1\":{\"1243\":1}}],[\"直至作业运行结束\",{\"1\":{\"189\":1}}],[\"直译为投喂\",{\"1\":{\"1166\":1}}],[\"直击数据库\",{\"1\":{\"1123\":1}}],[\"直到遍历完所有的数据\",{\"1\":{\"1176\":1}}],[\"直到获得第一个非\",{\"1\":{\"1176\":1}}],[\"直到获取到锁为止\",{\"1\":{\"1127\":1}}],[\"直到遇到第一次未签到为止\",{\"1\":{\"1176\":1}}],[\"直到减少成\",{\"1\":{\"1151\":1}}],[\"直到新开的线程完成这个逻辑后\",{\"1\":{\"1126\":1}}],[\"直到线程1把锁释放后\",{\"1\":{\"1126\":1}}],[\"直到\",{\"1\":{\"1038\":1}}],[\"直到没有map端的数据时才结束\",{\"1\":{\"980\":1}}],[\"直到运行结束\",{\"1\":{\"953\":1}}],[\"直到运行完成\",{\"1\":{\"952\":1}}],[\"直到运行了n个task以后\",{\"1\":{\"445\":1}}],[\"直到返回\",{\"1\":{\"775\":1}}],[\"直到超时\",{\"1\":{\"741\":1}}],[\"直到有描述符就绪\",{\"1\":{\"680\":1}}],[\"直到数据变为可以读取之前\",{\"1\":{\"610\":1}}],[\"直到找到一个未过期的key返回\",{\"1\":{\"529\":1}}],[\"直到所有文件输入流都没有数据为止\",{\"1\":{\"478\":1}}],[\"直到构造好有100个结点的小顶堆为止\",{\"1\":{\"477\":1}}],[\"直接把数据写入到他的粉丝中去\",{\"1\":{\"1166\":1}}],[\"直接删除\",{\"1\":{\"1151\":1}}],[\"直接删除数据\",{\"1\":{\"280\":1}}],[\"直接放行\",{\"1\":{\"1132\":1}}],[\"直接就返回404了\",{\"1\":{\"1124\":1}}],[\"直接查询数据库那肯定慢咯\",{\"1\":{\"1116\":1}}],[\"直接访问关系型数据库\",{\"1\":{\"984\":1}}],[\"直接使用\",{\"1\":{\"973\":1}}],[\"直接使用hdfs命令删除分区表的某一个分区文件夹\",{\"1\":{\"281\":1}}],[\"直接调用即可\",{\"1\":{\"1343\":1}}],[\"直接调用\",{\"1\":{\"749\":1}}],[\"直接内存对\",{\"1\":{\"769\":1}}],[\"直接内存创建和销毁的代价昂贵\",{\"1\":{\"769\":1}}],[\"直接内存\",{\"0\":{\"769\":1},\"1\":{\"731\":1,\"801\":1}}],[\"直接返回失败或者重试\",{\"1\":{\"1157\":1}}],[\"直接返回null\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"直接返回\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":2}}],[\"直接返回指定的结果给客户端\",{\"1\":{\"1005\":1}}],[\"直接返回这个成员变量的值就行\",{\"1\":{\"663\":1}}],[\"直接返回实际\",{\"1\":{\"66\":1}}],[\"直接返回实例\",{\"1\":{\"66\":1}}],[\"直接释放掉\",{\"1\":{\"551\":1}}],[\"直接通过union\",{\"1\":{\"409\":1}}],[\"直接在本地运行\",{\"1\":{\"444\":1}}],[\"直接在select后单独使用\",{\"1\":{\"378\":1}}],[\"直接在工厂里更换该对象即可\",{\"1\":{\"25\":1}}],[\"直接存储器存取\",{\"1\":{\"209\":1}}],[\"直接可以导入data\",{\"1\":{\"104\":1}}],[\"直接抛异常\",{\"1\":{\"69\":1}}],[\"直接进行获取即可\",{\"1\":{\"42\":1}}],[\"直接产生出来的就是一个力大无穷\",{\"1\":{\"19\":1}}],[\"段\",{\"1\":{\"688\":8,\"689\":1}}],[\"段式管理通过段表对应逻辑地址和物理地址\",{\"1\":{\"683\":1}}],[\"段式管理\",{\"1\":{\"683\":1}}],[\"段页式存储管理结合了页式管理和段式管理的优点\",{\"1\":{\"683\":1}}],[\"段页式系统的逻辑地址结构由段号\",{\"1\":{\"188\":1}}],[\"段页式管理\",{\"1\":{\"188\":1,\"683\":1}}],[\"段页式管理方式\",{\"0\":{\"188\":1}}],[\"段表寄存器\",{\"1\":{\"187\":1}}],[\"段表\",{\"1\":{\"187\":1,\"188\":1}}],[\"段内地址\",{\"1\":{\"188\":1}}],[\"段内地址位数决定了每个段的最大长度是多少\",{\"1\":{\"187\":1}}],[\"段内偏移量\",{\"1\":{\"187\":1}}],[\"段名\",{\"1\":{\"187\":1}}],[\"段号是隐含的\",{\"1\":{\"188\":1}}],[\"段号是可以隐含的\",{\"1\":{\"187\":1}}],[\"段号的位数决定了每个进程最多可以分几个段\",{\"1\":{\"187\":1}}],[\"段号\",{\"1\":{\"187\":1}}],[\"没配置或没找到\",{\"1\":{\"1411\":1}}],[\"没法利用多路复用\",{\"1\":{\"828\":1}}],[\"没法支持很高的并发\",{\"1\":{\"526\":1}}],[\"没学过\",{\"1\":{\"662\":1}}],[\"没必要对全字段建立索引\",{\"1\":{\"481\":1,\"493\":1}}],[\"没必要让整个页表常驻内存\",{\"1\":{\"186\":1}}],[\"没写表示hdfs路径\",{\"1\":{\"261\":1}}],[\"没有实例变量\",{\"1\":{\"1506\":1}}],[\"没有向下走\",{\"1\":{\"1482\":1}}],[\"没有则返回nil\",{\"1\":{\"1209\":1}}],[\"没有类似mysql那么严格的约束\",{\"1\":{\"1182\":1}}],[\"没有参数怎么确实是哪一天签到呢\",{\"1\":{\"1175\":1}}],[\"没有下一页了\",{\"1\":{\"1172\":1}}],[\"没有抢到锁的哥们\",{\"1\":{\"1141\":1}}],[\"没有多余key\",{\"1\":{\"1123\":1}}],[\"没有x可执行文件的概念\",{\"1\":{\"918\":1}}],[\"没有启动快照功能的目录创建快照会报错\",{\"1\":{\"914\":1}}],[\"没有启动mr\",{\"1\":{\"276\":1}}],[\"没有此情况\",{\"1\":{\"851\":1}}],[\"没有充分利用多核\",{\"1\":{\"846\":1}}],[\"没有事件发生\",{\"1\":{\"840\":1}}],[\"没有移除\",{\"1\":{\"837\":1}}],[\"没有非阻塞模式\",{\"1\":{\"831\":1}}],[\"没有明显的性能提升\",{\"1\":{\"792\":1}}],[\"没有发生\",{\"1\":{\"1042\":1}}],[\"没有发生数据复制\",{\"1\":{\"776\":1}}],[\"没有发生更新的数据不进行状态存储\",{\"1\":{\"405\":1}}],[\"没有成功传递到下一个\",{\"1\":{\"775\":1}}],[\"没有成员会返回\",{\"1\":{\"701\":1}}],[\"没有池化\",{\"1\":{\"770\":1}}],[\"没有任何签到结果\",{\"1\":{\"1176\":1}}],[\"没有任何软件支持的计算机称为裸机\",{\"1\":{\"154\":1}}],[\"没有任务\",{\"1\":{\"741\":1}}],[\"没有边界\",{\"1\":{\"709\":1}}],[\"没有写数据了\",{\"1\":{\"707\":1}}],[\"没有读到数据了\",{\"1\":{\"707\":1}}],[\"没有就可以判定为连接假死\",{\"1\":{\"707\":1}}],[\"没有最大并发连接的限制\",{\"1\":{\"680\":1}}],[\"没有文件描述符限制\",{\"1\":{\"680\":1}}],[\"没有一种放之四海皆准\",{\"1\":{\"638\":1}}],[\"没有返回到外部\",{\"1\":{\"627\":1}}],[\"没有竞争发生\",{\"1\":{\"579\":1}}],[\"没有上限\",{\"1\":{\"574\":1}}],[\"没有线程来取是放不进去的\",{\"1\":{\"574\":1}}],[\"没有线程切换开销\",{\"1\":{\"517\":1}}],[\"没有容量\",{\"1\":{\"574\":1}}],[\"没有核心线程\",{\"1\":{\"574\":1}}],[\"没有救急线程被创建\",{\"1\":{\"574\":1}}],[\"没有\",{\"1\":{\"493\":1,\"742\":1,\"1111\":1}}],[\"没有依赖的stage并行执行\",{\"1\":{\"446\":1}}],[\"没有索引时\",{\"1\":{\"422\":1}}],[\"没有group\",{\"1\":{\"351\":1}}],[\"没有数据\",{\"1\":{\"275\":1}}],[\"没有专门的临时数据库\",{\"1\":{\"228\":1}}],[\"没有内部碎片\",{\"1\":{\"182\":1}}],[\"没有并发性就谈不上虚拟性\",{\"1\":{\"155\":1}}],[\"联盟\",{\"1\":{\"889\":1}}],[\"联邦federation架构\",{\"0\":{\"889\":1}}],[\"联合索引优于单值\",{\"1\":{\"493\":1}}],[\"联合\",{\"1\":{\"438\":1}}],[\"联机分析处理\",{\"1\":{\"221\":1}}],[\"联机事务处理\",{\"1\":{\"221\":1}}],[\"联机命令接口\",{\"1\":{\"154\":1}}],[\"联想寄存器\",{\"1\":{\"185\":1}}],[\"结合目标与环绕通知链\",{\"1\":{\"1343\":1}}],[\"结合目标用\",{\"1\":{\"1317\":1}}],[\"结合代理用\",{\"1\":{\"1317\":1}}],[\"结合cas和volatile可以实现无锁并发\",{\"1\":{\"561\":1}}],[\"结束\",{\"1\":{\"1172\":1}}],[\"结束时间等等字段\",{\"1\":{\"1133\":1}}],[\"结束抢购时间\",{\"1\":{\"1133\":1}}],[\"结束后\",{\"1\":{\"717\":1,\"718\":1}}],[\"结果仍\",{\"1\":{\"1482\":1}}],[\"结果个数为\",{\"1\":{\"1482\":1}}],[\"结果客户端可以在流上重复调用read\",{\"1\":{\"902\":1}}],[\"结果又是节点6\",{\"1\":{\"766\":1}}],[\"结果容器\",{\"1\":{\"759\":1}}],[\"结果是一样的\",{\"1\":{\"779\":1}}],[\"结果是\",{\"1\":{\"757\":1,\"758\":1,\"759\":1,\"766\":2,\"772\":2,\"773\":1}}],[\"结果就在堆中\",{\"1\":{\"632\":1}}],[\"结果发现也没有\",{\"1\":{\"566\":1}}],[\"结果\",{\"1\":{\"562\":10,\"737\":1,\"741\":1,\"774\":1,\"779\":1,\"807\":1,\"983\":1,\"1172\":1,\"1362\":1,\"1526\":1}}],[\"结果写到一个大文件中\",{\"1\":{\"478\":1}}],[\"结果输出在一个文件中\",{\"1\":{\"314\":1}}],[\"结论\",{\"1\":{\"184\":1,\"214\":2}}],[\"结构化与非结构化\",{\"0\":{\"1185\":1}}],[\"结构用来存储锁\",{\"1\":{\"1151\":1}}],[\"结构体实际占用多少内存空间\",{\"1\":{\"663\":1}}],[\"结构头占用空间也比较少\",{\"1\":{\"663\":1}}],[\"结构中有个\",{\"1\":{\"663\":1}}],[\"结构中的每个成员变量分别介绍下\",{\"1\":{\"663\":1}}],[\"结构里引入了\",{\"1\":{\"663\":1}}],[\"结构因为加入了\",{\"1\":{\"663\":1}}],[\"结构在原本字符数组之上\",{\"1\":{\"663\":1}}],[\"结构设计\",{\"0\":{\"663\":1}}],[\"结构来表示字符串\",{\"1\":{\"661\":1}}],[\"结构上与源系统保持一致\",{\"1\":{\"225\":1}}],[\"结构上看进程由pcb\",{\"1\":{\"159\":1}}],[\"结构性\",{\"1\":{\"159\":1}}],[\"结构\",{\"0\":{\"5\":1,\"13\":1,\"27\":1,\"33\":1,\"38\":1,\"46\":1,\"50\":1,\"57\":1,\"80\":1,\"84\":1,\"798\":1}}],[\"算出来当前这个\",{\"1\":{\"1177\":1}}],[\"算出当前这个\",{\"1\":{\"1177\":1}}],[\"算出逻辑地址对应的页号\",{\"1\":{\"184\":1}}],[\"算术运算符操作数必须是数值类型\",{\"1\":{\"331\":1}}],[\"算术运算符\",{\"0\":{\"331\":1},\"1\":{\"328\":1}}],[\"算法公式\",{\"1\":{\"1040\":1}}],[\"算法中可通过记录最后一个生成\",{\"1\":{\"1000\":1}}],[\"算法简单\",{\"1\":{\"1000\":1}}],[\"算法优缺点\",{\"0\":{\"1000\":1}}],[\"算法实现\",{\"0\":{\"999\":1}}],[\"算法实现简单\",{\"1\":{\"167\":1}}],[\"算法产生的缘由\",{\"1\":{\"694\":1}}],[\"算法\",{\"1\":{\"694\":2}}],[\"算法是hash散列\",{\"1\":{\"314\":1}}],[\"算法的实现需要专门的硬件支持\",{\"1\":{\"191\":1}}],[\"算法的整体步骤很固定\",{\"1\":{\"87\":1}}],[\"算法种类\",{\"1\":{\"191\":1}}],[\"算法思想\",{\"1\":{\"167\":5,\"169\":4,\"183\":4}}],[\"算法规则\",{\"1\":{\"167\":6,\"191\":1}}],[\"页的调入调出\",{\"1\":{\"688\":1}}],[\"页的大小是固定的\",{\"1\":{\"683\":1}}],[\"页的地址结构\",{\"1\":{\"683\":1}}],[\"页和段都是离散存储的\",{\"1\":{\"683\":1}}],[\"页和块的大小相同\",{\"1\":{\"683\":1}}],[\"页\",{\"1\":{\"683\":2}}],[\"页式管理虽然提高了内存利用率\",{\"1\":{\"683\":1}}],[\"页式管理中将进程的逻辑地址空间分成若干个页\",{\"1\":{\"683\":1}}],[\"页式管理\",{\"1\":{\"683\":1}}],[\"页锁和行锁\",{\"1\":{\"509\":1}}],[\"页锁\",{\"1\":{\"506\":1}}],[\"页分裂\",{\"1\":{\"490\":1}}],[\"页内地址组成\",{\"1\":{\"188\":1}}],[\"页内偏移量\",{\"1\":{\"184\":1}}],[\"页表也会很大的问题\",{\"1\":{\"683\":1}}],[\"页表机制\",{\"1\":{\"190\":2}}],[\"页表的作用是实现页号到物理块号的地址映射\",{\"1\":{\"683\":1}}],[\"页表的起始地址\",{\"1\":{\"188\":1}}],[\"页表的开始地址\",{\"1\":{\"185\":1}}],[\"页表存放块号\",{\"1\":{\"188\":1}}],[\"页表长度\",{\"1\":{\"188\":1}}],[\"页表必须连续存放\",{\"1\":{\"186\":1}}],[\"页表起始地址和长度放在pcb在\",{\"1\":{\"185\":1}}],[\"页表中的一条记录\",{\"1\":{\"184\":1}}],[\"页表项中的访问字段记录页面自上次被访问以来所经历的时间t\",{\"1\":{\"191\":1}}],[\"页表项的个数\",{\"1\":{\"185\":1}}],[\"页表项\",{\"1\":{\"184\":1}}],[\"页表由页号和块号\",{\"1\":{\"184\":1}}],[\"页表\",{\"1\":{\"184\":1,\"188\":1,\"683\":1}}],[\"页号是隐含\",{\"1\":{\"188\":1}}],[\"页号在内存中的起始地址\",{\"1\":{\"184\":1}}],[\"页号\",{\"1\":{\"184\":1,\"188\":1}}],[\"页号也是从0开始\",{\"1\":{\"184\":1}}],[\"页面流程\",{\"1\":{\"1099\":1}}],[\"页面对应着逻辑地址\",{\"1\":{\"683\":1}}],[\"页面\",{\"1\":{\"683\":2}}],[\"页面搜索严禁左模糊或者全模糊\",{\"1\":{\"481\":1}}],[\"页面的大小相同\",{\"1\":{\"197\":1}}],[\"页面的换入\",{\"1\":{\"191\":1}}],[\"页面分配策略\",{\"0\":{\"192\":1}}],[\"页面置换发生了6次\",{\"1\":{\"191\":1}}],[\"页面置换算法\",{\"0\":{\"191\":1,\"690\":1}}],[\"页面存放的内存块号组成\",{\"1\":{\"188\":1}}],[\"页面长度\",{\"1\":{\"184\":2}}],[\"页面不必连续存放\",{\"1\":{\"184\":1}}],[\"页面与页框有一一对应关系\",{\"1\":{\"184\":1}}],[\"页框\",{\"1\":{\"683\":1}}],[\"页框号\",{\"1\":{\"184\":1}}],[\"页框号从0开始\",{\"1\":{\"184\":1}}],[\"页框不能太大\",{\"1\":{\"184\":1}}],[\"邻近适应算法\",{\"1\":{\"183\":1}}],[\"尽管json的序列化方式可以满足我们的需求\",{\"1\":{\"1223\":1}}],[\"尽管这两类应用程序作用不同\",{\"1\":{\"951\":1}}],[\"尽管天级别或者更长时间的也存在\",{\"1\":{\"951\":1}}],[\"尽可能缩减加锁的范围\",{\"1\":{\"551\":1}}],[\"尽可能更多的留下大片的空闲区\",{\"1\":{\"183\":1}}],[\"尽量使用覆盖索引\",{\"1\":{\"505\":1}}],[\"尽量使用map\",{\"1\":{\"448\":1}}],[\"尽量将过滤条件提前执行\",{\"1\":{\"459\":1}}],[\"尽量先使用组合或者聚合等关联关系来实现\",{\"1\":{\"77\":1}}],[\"外\",{\"1\":{\"726\":1}}],[\"外存\",{\"1\":{\"687\":1}}],[\"外存利用率高\",{\"1\":{\"197\":2}}],[\"外围设备完成用户请求的操作后\",{\"1\":{\"676\":1}}],[\"外键影响数据库的插入速度\",{\"1\":{\"482\":1}}],[\"外键与级联更新适用于单机低并发\",{\"1\":{\"482\":1}}],[\"外部表无法创建为事务表\",{\"1\":{\"296\":1}}],[\"外部表不能成为acid表\",{\"1\":{\"267\":1}}],[\"外部表只会删除表的元数据\",{\"1\":{\"258\":1}}],[\"外部表\",{\"0\":{\"258\":1},\"1\":{\"258\":1}}],[\"外部碎片\",{\"1\":{\"182\":1}}],[\"外中断的处理过程\",{\"1\":{\"157\":1}}],[\"情况三\",{\"1\":{\"182\":1}}],[\"情况二\",{\"1\":{\"182\":1}}],[\"情况一\",{\"1\":{\"182\":1}}],[\"状态机\",{\"1\":{\"1005\":1}}],[\"状态改变为\",{\"1\":{\"726\":3}}],[\"状态修改为\",{\"1\":{\"726\":1}}],[\"状态转移方程\",{\"1\":{\"649\":1}}],[\"状态如下\",{\"1\":{\"591\":1}}],[\"状态变量state\",{\"0\":{\"582\":1}}],[\"状态名称\",{\"1\":{\"571\":1}}],[\"状态寄存器对应一个具体的设备\",{\"1\":{\"208\":1}}],[\"状态寄存器可能也有多个\",{\"1\":{\"208\":1}}],[\"状态等信息\",{\"1\":{\"182\":1}}],[\"状态\",{\"1\":{\"182\":1,\"209\":1,\"533\":2,\"798\":2}}],[\"划分更加细粒度\",{\"1\":{\"259\":1}}],[\"划分为小分区\",{\"1\":{\"183\":1}}],[\"划分多个小分区\",{\"1\":{\"182\":1}}],[\"划分可分为白色汽车\",{\"1\":{\"77\":1}}],[\"划分可分为汽油汽车\",{\"1\":{\"77\":1}}],[\"缺页\",{\"1\":{\"689\":1}}],[\"缺页次数不减反增的异常现象\",{\"1\":{\"191\":1}}],[\"缺页发生9次\",{\"1\":{\"191\":1}}],[\"缺页发生10次\",{\"1\":{\"191\":1}}],[\"缺页9次\",{\"1\":{\"191\":1}}],[\"缺页率\",{\"1\":{\"191\":1}}],[\"缺页时未必发生页面置换\",{\"1\":{\"191\":1}}],[\"缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的\",{\"1\":{\"190\":1}}],[\"缺页中断机构\",{\"1\":{\"190\":2}}],[\"缺乏灵活性\",{\"1\":{\"182\":1}}],[\"缺点在于有锁就有死锁问题的发生\",{\"1\":{\"1126\":1}}],[\"缺点在于在构建完缓存之前\",{\"1\":{\"1126\":1}}],[\"缺点需要转义\",{\"1\":{\"695\":1}}],[\"缺点浪费空间\",{\"1\":{\"695\":1}}],[\"缺点效率太低\",{\"1\":{\"695\":1}}],[\"缺点是数据读取过程中会产生冗余数据\",{\"1\":{\"995\":1}}],[\"缺点是数据拷贝耗费性能\",{\"1\":{\"841\":1}}],[\"缺点是效率低\",{\"1\":{\"840\":1}}],[\"缺点是浪费带宽\",{\"1\":{\"840\":1}}],[\"缺点是包的往返时间越长性能就越差\",{\"1\":{\"694\":1}}],[\"缺点是不随机\",{\"1\":{\"368\":1}}],[\"缺点是\",{\"1\":{\"243\":1,\"697\":1,\"840\":1}}],[\"缺点\",{\"1\":{\"15\":1,\"23\":1,\"29\":1,\"35\":1,\"40\":1,\"62\":1,\"86\":1,\"163\":2,\"167\":4,\"170\":3,\"176\":4,\"181\":1,\"182\":2,\"183\":4,\"188\":1,\"197\":3,\"201\":1,\"209\":3,\"213\":1,\"485\":1,\"634\":1,\"698\":1,\"779\":1,\"1123\":2,\"1166\":4,\"1222\":1}}],[\"覆盖掉\",{\"1\":{\"822\":1}}],[\"覆盖拉链表\",{\"1\":{\"410\":1}}],[\"覆盖到拉链表\",{\"0\":{\"410\":1}}],[\"覆盖与交换\",{\"0\":{\"181\":1}}],[\"覆盖技术\",{\"1\":{\"180\":1,\"181\":1}}],[\"绝大多数情况都是用lru策略\",{\"1\":{\"522\":1}}],[\"绝大多数情况下使用的是行锁\",{\"1\":{\"506\":1}}],[\"绝大部分的操作都是读操作\",{\"1\":{\"66\":1}}],[\"绝对路径\",{\"1\":{\"821\":2}}],[\"绝对值函数\",{\"1\":{\"338\":2}}],[\"绝对装入只适用于单道程序的环境\",{\"1\":{\"179\":1}}],[\"绝对装入\",{\"1\":{\"179\":1}}],[\"绝对地址\",{\"1\":{\"179\":1}}],[\"个事件\",{\"1\":{\"1445\":1}}],[\"个初始化方法\",{\"1\":{\"1289\":1}}],[\"个消费者消费\",{\"1\":{\"1040\":1}}],[\"个消息\",{\"1\":{\"692\":1,\"693\":1}}],[\"个的副本\",{\"1\":{\"1026\":1}}],[\"个副本的\",{\"1\":{\"1019\":1}}],[\"个分区\",{\"1\":{\"1019\":1}}],[\"个数发生变化\",{\"1\":{\"1037\":1}}],[\"个数作为输出的value通过context上下文对象进行输出\",{\"1\":{\"961\":1}}],[\"个数\",{\"1\":{\"847\":1}}],[\"个数💡\",{\"0\":{\"847\":1}}],[\"个数超过一个时\",{\"1\":{\"780\":1}}],[\"个医生一天工作\",{\"1\":{\"755\":1}}],[\"个医生给人看病\",{\"1\":{\"755\":1}}],[\"个客户端连接时\",{\"1\":{\"726\":1}}],[\"个客户端都打印\",{\"1\":{\"726\":1}}],[\"个\",{\"1\":{\"726\":1,\"1040\":2,\"1174\":1}}],[\"个元素的位数组只占用\",{\"1\":{\"658\":1}}],[\"个格子\",{\"1\":{\"648\":1}}],[\"个格子和\",{\"1\":{\"648\":1}}],[\"个格子的值时\",{\"1\":{\"648\":1}}],[\"个索引位置进行截取子串\",{\"1\":{\"614\":1}}],[\"个小文件中的单词进行排序\",{\"1\":{\"478\":1}}],[\"个房间\",{\"1\":{\"179\":1}}],[\"个存储单元\",{\"1\":{\"179\":1}}],[\"个字节后\",{\"1\":{\"798\":1}}],[\"个字节后的状态\",{\"1\":{\"798\":1}}],[\"个字节大小\",{\"1\":{\"666\":1}}],[\"个字节被浪费掉了\",{\"1\":{\"663\":1}}],[\"个字节是为了字节对齐而分配的\",{\"1\":{\"663\":1}}],[\"个字节\",{\"1\":{\"179\":1,\"663\":5,\"692\":1,\"713\":1,\"714\":1,\"723\":1,\"772\":2}}],[\"亿个\",{\"1\":{\"1177\":1}}],[\"亿条\",{\"1\":{\"1174\":1}}],[\"亿以上\",{\"1\":{\"660\":1}}],[\"亿\",{\"1\":{\"179\":1}}],[\"兆\",{\"1\":{\"179\":1}}],[\"千变万化\",{\"1\":{\"1310\":1}}],[\"千兆\",{\"1\":{\"179\":1}}],[\"千\",{\"1\":{\"179\":1}}],[\"挂起\",{\"1\":{\"178\":1}}],[\"挂起介绍\",{\"1\":{\"164\":1}}],[\"还不如声明这是一个web应用程序来的简单\",{\"1\":{\"1521\":1}}],[\"还支持比如事件发布\",{\"1\":{\"1501\":1}}],[\"还支持java数据类型\",{\"1\":{\"248\":1}}],[\"还提供了许多分布式服务\",{\"1\":{\"1149\":1}}],[\"还得利用代理来生效\",{\"1\":{\"1137\":1}}],[\"还得根据变量是基本类型和引用类型两种情况分类讨论\",{\"1\":{\"627\":1}}],[\"还具有库存\",{\"1\":{\"1133\":1}}],[\"还包含从主分片复制数据的过程\",{\"1\":{\"1068\":1}}],[\"还确保消息写入到对应副本都成功后\",{\"1\":{\"1043\":1}}],[\"还改变了最终的执行结果\",{\"1\":{\"970\":1}}],[\"还可以实现\",{\"1\":{\"1289\":1}}],[\"还可以通过web\",{\"1\":{\"914\":1}}],[\"还可以在进程间传递文件描述符\",{\"1\":{\"872\":1}}],[\"还可以使用回调的方式\",{\"1\":{\"753\":1}}],[\"还可以使用自旋来进行优化\",{\"1\":{\"542\":1}}],[\"还没有结果\",{\"1\":{\"760\":1}}],[\"还没有完成\",{\"1\":{\"740\":1}}],[\"还有库存判断\",{\"1\":{\"1155\":1}}],[\"还有内容\",{\"1\":{\"859\":1}}],[\"还有种办法是采用\",{\"1\":{\"774\":1}}],[\"还有一类方法是\",{\"1\":{\"772\":1}}],[\"还有一个相关的\",{\"1\":{\"1455\":1}}],[\"还有一个订单数据的索引\",{\"1\":{\"1061\":1}}],[\"还有一个特点是\",{\"1\":{\"680\":1}}],[\"还有一个问题\",{\"1\":{\"666\":1}}],[\"还有一个案例如下\",{\"1\":{\"289\":1}}],[\"还有一个适配器模式是接口适配器模式\",{\"1\":{\"7\":1}}],[\"还有同学会笼统地回答\",{\"1\":{\"755\":1}}],[\"还要处理\",{\"1\":{\"741\":1}}],[\"还要再遍历源字符串才能完成追加\",{\"1\":{\"662\":1}}],[\"还要再回收一块\",{\"1\":{\"198\":1}}],[\"还未准备好\",{\"1\":{\"1285\":1}}],[\"还未产生结果时返回\",{\"1\":{\"756\":1}}],[\"还未涉及数据读取\",{\"1\":{\"743\":1}}],[\"还未绑定\",{\"1\":{\"740\":1}}],[\"还未与操作系统线程关联\",{\"1\":{\"538\":1}}],[\"还更差一些\",{\"1\":{\"679\":1}}],[\"还需再次利用切点表达式\",{\"1\":{\"1350\":1}}],[\"还需记录数组的长度\",{\"1\":{\"631\":1}}],[\"还需要再加一个版本号\",{\"1\":{\"563\":1}}],[\"还会再对合并后的数据排序\",{\"1\":{\"980\":1}}],[\"还会给\",{\"1\":{\"663\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"570\":1}}],[\"还会唤醒阻塞的线程\",{\"1\":{\"549\":1}}],[\"还会在redo\",{\"1\":{\"506\":1}}],[\"还是时间存在于我们之中\",{\"1\":{\"1525\":1}}],[\"还是建议用业务来维护关联关系\",{\"1\":{\"1186\":1}}],[\"还是\",{\"1\":{\"1177\":1,\"1370\":1}}],[\"还是力不从心\",{\"1\":{\"1171\":1}}],[\"还是从6后一点的5去拿\",{\"1\":{\"1167\":1}}],[\"还是会把这个数据写入到redis中\",{\"1\":{\"1124\":1}}],[\"还是在同一毫秒内\",{\"1\":{\"999\":1}}],[\"还是相当于闲置\",{\"1\":{\"856\":1}}],[\"还是使用原始\",{\"1\":{\"776\":1}}],[\"还是where后面\",{\"1\":{\"461\":1}}],[\"还是第三方rdbms\",{\"1\":{\"241\":1}}],[\"还连着的边的那些进程就是死锁进程\",{\"1\":{\"178\":1}}],[\"检测和解除\",{\"0\":{\"178\":1}}],[\"检查workid的合法值\",{\"1\":{\"999\":1}}],[\"检查datacenterid的合法值\",{\"1\":{\"999\":1}}],[\"检查通过namenode就会为本次请求记下一条记录\",{\"1\":{\"901\":1}}],[\"检查libisal\",{\"1\":{\"876\":1}}],[\"检查\",{\"1\":{\"843\":1}}],[\"检查文件是否存在\",{\"1\":{\"822\":1}}],[\"检查是否没有匹配所有元素\",{\"1\":{\"619\":1}}],[\"检查是否至少匹配一个元素\",{\"1\":{\"619\":1}}],[\"检查是否匹配所有元素\",{\"1\":{\"619\":1}}],[\"检查是否会发生抢占\",{\"1\":{\"167\":1}}],[\"检查设备状态等\",{\"1\":{\"210\":1}}],[\"检查后\",{\"1\":{\"169\":1}}],[\"检查网络连接和\",{\"1\":{\"101\":1}}],[\"处\",{\"1\":{\"784\":6,\"785\":8}}],[\"处的\",{\"1\":{\"766\":3,\"785\":1}}],[\"处返回的是\",{\"1\":{\"753\":1}}],[\"处代码\",{\"1\":{\"740\":1,\"766\":4}}],[\"处于不安全状态未必发生了死锁\",{\"1\":{\"177\":1}}],[\"处理返回值\",{\"1\":{\"1438\":1}}],[\"处理流程\",{\"0\":{\"1438\":1}}],[\"处理控制器方法返回值\",{\"1\":{\"1355\":1}}],[\"处理订单异常\",{\"1\":{\"1157\":1}}],[\"处理订单数据\",{\"1\":{\"988\":1}}],[\"处理商品数据\",{\"1\":{\"988\":1}}],[\"处理事件\",{\"1\":{\"840\":1}}],[\"处理消息的边界\",{\"0\":{\"840\":1}}],[\"处理key\",{\"1\":{\"836\":1,\"840\":1}}],[\"处理数据\",{\"1\":{\"787\":1}}],[\"处理原则\",{\"1\":{\"775\":2}}],[\"处理的病人总数是\",{\"1\":{\"755\":1}}],[\"处理关闭之后的操作\",{\"1\":{\"754\":3}}],[\"处理定时任务\",{\"0\":{\"751\":1}}],[\"处理普通任务\",{\"0\":{\"750\":1}}],[\"处理异常流程\",{\"1\":{\"1438\":1}}],[\"处理异常或视图渲染\",{\"1\":{\"1438\":1}}],[\"处理异常\",{\"1\":{\"740\":3}}],[\"处理完第一个\",{\"1\":{\"859\":2}}],[\"处理完毕\",{\"1\":{\"834\":1}}],[\"处理完成后\",{\"1\":{\"741\":1}}],[\"处理完了\",{\"1\":{\"717\":1}}],[\"处理完调用request再请求一个数据\",{\"1\":{\"717\":1,\"718\":1}}],[\"处理器映射器找到具体的处理器\",{\"1\":{\"1530\":1}}],[\"处理器完成业务逻辑的处理后\",{\"1\":{\"1530\":1}}],[\"处理器和最终订阅者建立订阅关系\",{\"1\":{\"718\":1}}],[\"处理器处理完了\",{\"1\":{\"718\":1}}],[\"处理器接收到的数据\",{\"1\":{\"718\":1}}],[\"处理器\",{\"1\":{\"716\":1,\"784\":1,\"785\":1}}],[\"处理字符数据比较合适\",{\"1\":{\"698\":1}}],[\"处理字符串\",{\"1\":{\"614\":1}}],[\"处理剩余物品\",{\"1\":{\"649\":1}}],[\"处理并发安全问题\",{\"1\":{\"630\":1}}],[\"处理后续任务\",{\"1\":{\"536\":1}}],[\"处理\",{\"0\":{\"748\":1,\"834\":1,\"836\":1,\"842\":1},\"1\":{\"344\":2,\"694\":1,\"717\":1,\"742\":1,\"743\":1,\"744\":1,\"785\":1,\"859\":2,\"1352\":1,\"1436\":1,\"1437\":4,\"1444\":1}}],[\"处理一个数据块的平均耗时为max\",{\"1\":{\"214\":1}}],[\"处理一块数据平均耗时max\",{\"1\":{\"214\":1}}],[\"处理机调度的概念\",{\"1\":{\"164\":1}}],[\"处理机的调度\",{\"0\":{\"164\":1}}],[\"处理机管理\",{\"1\":{\"154\":1}}],[\"处理其中可能的异常\",{\"1\":{\"63\":1}}],[\"处理创建对象的细节\",{\"1\":{\"28\":1}}],[\"首字符ascii函数\",{\"1\":{\"336\":2}}],[\"首先编写条件判断类\",{\"1\":{\"1466\":1}}],[\"首先看\",{\"1\":{\"1398\":1}}],[\"首先看是否有自定义转换器\",{\"1\":{\"1370\":1}}],[\"首先根据方法名和参数个数\",{\"1\":{\"1321\":1}}],[\"首先根据州的正序排序\",{\"1\":{\"974\":1}}],[\"首先我们搞懂两个概念\",{\"1\":{\"1179\":1}}],[\"首先我们的初始方案是封装了一个createvoucherorder方法\",{\"1\":{\"1137\":1}}],[\"首先我们要思考一下利用redis来存储数据\",{\"1\":{\"1104\":1}}],[\"首先必须要有一个确定的主题\",{\"1\":{\"1015\":1}}],[\"首先分析处理的数据集\",{\"1\":{\"990\":1}}],[\"首先向\",{\"1\":{\"953\":1}}],[\"首先启动服务器端\",{\"1\":{\"848\":1}}],[\"首先要说明\",{\"1\":{\"756\":1}}],[\"首先他会立刻返回\",{\"1\":{\"679\":1}}],[\"首先计算对象占用空间大小\",{\"1\":{\"630\":1}}],[\"首先去检查这个指令的参数能否在metaspace的常量池中定位到一个类的符号引用\",{\"1\":{\"630\":1}}],[\"首先会从fsimage和edits日志文件加载文件系统状态\",{\"1\":{\"870\":1}}],[\"首先会从buffer\",{\"1\":{\"506\":1}}],[\"首先会调用cas进行一次抢锁\",{\"1\":{\"588\":1}}],[\"首先会检查该key是否过期\",{\"1\":{\"529\":1}}],[\"首先\",{\"1\":{\"493\":1,\"658\":1,\"1197\":1,\"1522\":1}}],[\"首先遍历大文件\",{\"1\":{\"477\":1}}],[\"首先设置动态分区模式为非严格模式\",{\"1\":{\"289\":1}}],[\"首先调用serde\",{\"1\":{\"250\":1}}],[\"首先调用inputformat\",{\"1\":{\"250\":1}}],[\"首先从数据源池中提取数据\",{\"1\":{\"228\":1}}],[\"首先给系统中的资源编号\",{\"1\":{\"176\":1}}],[\"首次执行\",{\"1\":{\"740\":1,\"1340\":1}}],[\"首次适应算法\",{\"1\":{\"183\":1}}],[\"首次创建会同步\",{\"1\":{\"22\":1}}],[\"释放一次就\",{\"1\":{\"1151\":1}}],[\"释放原有\",{\"1\":{\"776\":1}}],[\"释放未处理消息逻辑\",{\"1\":{\"775\":1}}],[\"释放共享锁\",{\"1\":{\"585\":1}}],[\"释放互斥锁\",{\"1\":{\"585\":1,\"1127\":1}}],[\"释放锁时先判断线程标示是否与自己一致\",{\"1\":{\"1147\":1}}],[\"释放锁的业务流程是这样的\",{\"1\":{\"1146\":1}}],[\"释放锁的时候也需要将state减为0\",{\"1\":{\"582\":1}}],[\"释放锁逻辑\",{\"1\":{\"1142\":1}}],[\"释放锁\",{\"1\":{\"542\":1,\"1128\":1,\"1129\":2,\"1141\":2,\"1142\":3,\"1144\":1,\"1150\":2,\"1157\":1}}],[\"释放已经获得的资源可能造成前一阶段工作的失效\",{\"1\":{\"176\":1}}],[\"释放资源\",{\"1\":{\"172\":1,\"1213\":1}}],[\"破坏\",{\"1\":{\"792\":1}}],[\"破坏循环等待条件\",{\"1\":{\"176\":1}}],[\"破坏请求和保持条件\",{\"1\":{\"176\":1}}],[\"破坏不剥夺条件\",{\"1\":{\"176\":1}}],[\"破坏互斥条件\",{\"1\":{\"176\":1}}],[\"破坏死锁产生的四个必要条件中的一个或几个\",{\"1\":{\"175\":1}}],[\"破坏单例模式\",{\"1\":{\"68\":1}}],[\"那怎么处理呢\",{\"1\":{\"1179\":1}}],[\"那会由监听线程创建socket连接\",{\"1\":{\"1100\":1}}],[\"那样不是也可以吗\",{\"1\":{\"755\":1}}],[\"那就会冲突了\",{\"1\":{\"1207\":1}}],[\"那就可以防止下次过来直击数据\",{\"1\":{\"1177\":1}}],[\"那就从\",{\"1\":{\"648\":1}}],[\"那就是充分必要条件了\",{\"1\":{\"175\":1}}],[\"那为什么还要使用b+树索引呢\",{\"0\":{\"491\":1}}],[\"那当offset特别大的时候\",{\"1\":{\"481\":1}}],[\"那么事务只会在遇到runtimeexception的时候才会回滚\",{\"1\":{\"1516\":1}}],[\"那么spring\",{\"1\":{\"1500\":1}}],[\"那么以自己添加的为准\",{\"1\":{\"1453\":1}}],[\"那么最终也会走到\",{\"1\":{\"1411\":1}}],[\"那么最后所有剩余的会作为一个切片\",{\"1\":{\"976\":1}}],[\"那么最后的join依旧是一个reduce\",{\"1\":{\"469\":1}}],[\"那么它们的执行顺序是\",{\"1\":{\"1289\":1}}],[\"那么它并不会block用户进程\",{\"1\":{\"679\":1}}],[\"那么我哪儿知道到底哪些是\",{\"1\":{\"1176\":1}}],[\"那么我们服务获取到的数据就是\",{\"1\":{\"1525\":1}}],[\"那么我们就可以从当前月的第一天开始\",{\"1\":{\"1176\":1}}],[\"那么我们就读取到了重复的数据\",{\"1\":{\"1167\":1}}],[\"那么我们就能锁住线程\",{\"1\":{\"1140\":1}}],[\"那么我们拿到的就是\",{\"1\":{\"1167\":1}}],[\"那么我们采用写扩散的方式\",{\"1\":{\"1166\":1}}],[\"那么我们应该把这些数据推送给用户\",{\"1\":{\"1166\":1}}],[\"那么我们如何知道到底哪个单他最后是否成功\",{\"1\":{\"1155\":1}}],[\"那么我们如何进行修改呢\",{\"1\":{\"75\":1}}],[\"那么我们执行项目c时\",{\"1\":{\"104\":1}}],[\"那么我们可以添加一个拦截器\",{\"1\":{\"1110\":1}}],[\"那么我们可以说\",{\"1\":{\"104\":1}}],[\"那么我们可以将想要的依赖项的信息编写到maven工程的配置文件\",{\"1\":{\"91\":1}}],[\"那么大v和普通的人发的都会直接写入到自己收件箱里边来\",{\"1\":{\"1166\":1}}],[\"那么大家可以想一想\",{\"1\":{\"1152\":1}}],[\"那么时间就是4500ms\",{\"1\":{\"1153\":1}}],[\"那么mutilock\",{\"1\":{\"1153\":1}}],[\"那么什么是\",{\"1\":{\"1149\":1}}],[\"那么什么时候countdownlatch\",{\"1\":{\"1132\":1}}],[\"那么什么时候main线程不再阻塞呢\",{\"1\":{\"1132\":1}}],[\"那么什么时候赋值的呢\",{\"1\":{\"66\":1}}],[\"那么续期问题怎么解决呢\",{\"1\":{\"1147\":1}}],[\"那么此时查询出来就是\",{\"1\":{\"1205\":1}}],[\"那么此时读取到的第二页实际上是从6\",{\"1\":{\"1167\":1}}],[\"那么此时才算是加锁成功\",{\"1\":{\"1153\":1}}],[\"那么此时就会拉取海量的内容\",{\"1\":{\"1166\":1}}],[\"那么此时就会递归调用自己\",{\"1\":{\"1152\":1}}],[\"那么此时就是安全的\",{\"1\":{\"1136\":1}}],[\"那么此时如果是不可重入的\",{\"1\":{\"1149\":1}}],[\"那么此时线程2进来\",{\"1\":{\"1145\":1}}],[\"那么分布式锁他应该满足一些什么样的条件呢\",{\"1\":{\"1140\":1}}],[\"那么假设在服务器a的tomcat内部\",{\"1\":{\"1138\":1}}],[\"那么假设我们每次操作数据库后\",{\"1\":{\"1121\":1}}],[\"那么第一个线程在操作后\",{\"1\":{\"1135\":1}}],[\"那么由于程序是异步的\",{\"1\":{\"1132\":1}}],[\"那么其他线程会进行阻塞\",{\"1\":{\"1126\":1}}],[\"那么线程池中的线程可能一下子就被消耗完了\",{\"1\":{\"1155\":1}}],[\"那么线程2就可以进行到休眠\",{\"1\":{\"1126\":1}}],[\"那么线程1就会一个人去执行逻辑\",{\"1\":{\"1126\":1}}],[\"那么到底使用哪种结构呢\",{\"1\":{\"1104\":1}}],[\"那么如果是\",{\"1\":{\"1411\":1}}],[\"那么如果有人问\",{\"1\":{\"639\":1}}],[\"那么如何加速呢\",{\"1\":{\"1155\":1}}],[\"那么如何保证水平分表后的多张表中的\",{\"1\":{\"997\":1}}],[\"那么现在就是使用combiner的时候了\",{\"1\":{\"979\":1}}],[\"那么可将减少的位数补充给机器码用\",{\"1\":{\"1001\":1}}],[\"那么可用减少时间戳占用的位数\",{\"1\":{\"1001\":1}}],[\"那么可能会出现需要读多个块的情况\",{\"1\":{\"976\":1}}],[\"那么可以让不同表初始化一个不同的初始值\",{\"1\":{\"997\":1}}],[\"那么可以使用消息队列\",{\"1\":{\"547\":1}}],[\"那么可以在这些列上建立\",{\"1\":{\"493\":1}}],[\"那么可以关闭这个流\",{\"1\":{\"478\":1}}],[\"那么可以以下几种方案来解决join产生的数据倾斜问题\",{\"1\":{\"467\":1}}],[\"那么可以省略\",{\"1\":{\"107\":1}}],[\"那么也必须\",{\"1\":{\"775\":1}}],[\"那么也就失去实现虚拟性的意义\",{\"1\":{\"155\":1}}],[\"那么便无须再传递\",{\"1\":{\"775\":1}}],[\"那么任务就会等到下次\",{\"1\":{\"742\":1}}],[\"那么必须加以区分\",{\"1\":{\"709\":1}}],[\"那么epoll的效率并不会比select\",{\"1\":{\"680\":1}}],[\"那么整个进程会被block\",{\"1\":{\"679\":1}}],[\"那么整张表的所有行就是一组\",{\"1\":{\"358\":1}}],[\"那么他是直接将数据先写入到一份到发件箱里边去\",{\"1\":{\"1166\":1}}],[\"那么他是线程安全的\",{\"1\":{\"627\":1}}],[\"那么他会从读取他自己的收件箱\",{\"1\":{\"1166\":1}}],[\"那么他去获得锁的时候\",{\"1\":{\"1153\":1}}],[\"那么他去执行业务\",{\"1\":{\"1141\":1}}],[\"那么他们的锁对象是同一个\",{\"1\":{\"1138\":1}}],[\"那么他们就会同一时刻来访问查询缓存\",{\"1\":{\"1126\":1}}],[\"那么他马上就将数据拷贝到了用户内存\",{\"1\":{\"679\":1}}],[\"那么\",{\"1\":{\"665\":2,\"666\":2,\"775\":1,\"1151\":3}}],[\"那么获取字符串长度的时候\",{\"1\":{\"663\":1}}],[\"那么说明这个值在布隆过滤器中\",{\"1\":{\"659\":2}}],[\"那么在可视化界面中\",{\"1\":{\"1207\":1}}],[\"那么在redis中也能找到这个数据就不会进入到缓存了\",{\"1\":{\"1123\":1}}],[\"那么在第二台服务器上\",{\"1\":{\"1102\":1}}],[\"那么在双亲委派模式下\",{\"1\":{\"630\":1}}],[\"那么在大数据的环境中耗时是十分恐怖的\",{\"1\":{\"286\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"605\":1}}],[\"那么会在队列中再往后判断下一个节点的线程时候占有的是共享锁\",{\"1\":{\"583\":1}}],[\"那么后面公平锁和非公平锁是一样的\",{\"1\":{\"588\":1}}],[\"那么下次poll时会再次报告该fd\",{\"1\":{\"680\":1}}],[\"那么下面就看一看这些方法是\",{\"1\":{\"566\":1}}],[\"那么下一局也出一样的手势\",{\"1\":{\"81\":1}}],[\"那么自己的cas就算失败\",{\"1\":{\"563\":1}}],[\"那么变量是安全的\",{\"1\":{\"539\":1}}],[\"那么当前线程就可以不用进行上下文切换\",{\"1\":{\"542\":1}}],[\"那么当它被杀死后就再也没有机会释放锁\",{\"1\":{\"536\":1}}],[\"那么当关联字段中某一种值过多的时候依旧会导致数据倾斜的问题\",{\"1\":{\"467\":1}}],[\"那么不能保证让当前线程暂停的效果\",{\"1\":{\"533\":1}}],[\"那么不久后这条指令很有可能再次执行\",{\"1\":{\"189\":1}}],[\"那么问题会更严重\",{\"1\":{\"529\":1}}],[\"那么这\",{\"1\":{\"1176\":1}}],[\"那么这两个线程都会去扣减库存\",{\"1\":{\"1135\":1}}],[\"那么这些线程都不能从缓存中查询到数据\",{\"1\":{\"1126\":1}}],[\"那么这些列将序列化为json格式\",{\"1\":{\"290\":1}}],[\"那么这个更新动作实际上只有最后一次生效\",{\"1\":{\"1121\":1}}],[\"那么这个拦截器就不会生效\",{\"1\":{\"1109\":1}}],[\"那么这个元素一定不在\",{\"1\":{\"659\":1}}],[\"那么这个外部对象是不能被回收的\",{\"1\":{\"636\":1}}],[\"那么这个线程就回到新的链表中get\",{\"1\":{\"579\":1}}],[\"那么这个循环会持续很久才结束\",{\"1\":{\"529\":1}}],[\"那么哨兵负责发送消息作为报警通知给管理员\",{\"1\":{\"526\":1}}],[\"那么之前已经执行成功的sql语句也必须撤销\",{\"1\":{\"506\":1}}],[\"那么对这个字段创建索引\",{\"1\":{\"493\":1}}],[\"那么就要通过spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中\",{\"1\":{\"1514\":1}}],[\"那么就可以直接往\",{\"1\":{\"1177\":1}}],[\"那么就可以让垃圾收集线程和应用程序线程交替执行\",{\"1\":{\"634\":1}}],[\"那么就是\",{\"1\":{\"1176\":1}}],[\"那么就意味着操作过程中没有人对他进行过修改\",{\"1\":{\"1135\":1}}],[\"那么就能够避免这个尴尬的问题了\",{\"1\":{\"1101\":1}}],[\"那么就能防止前面提到的误判\",{\"1\":{\"707\":1}}],[\"那么就使用新的时间戳\",{\"1\":{\"999\":1}}],[\"那么就直接调用\",{\"1\":{\"749\":1}}],[\"那么就直接获取到锁返回了\",{\"1\":{\"588\":1}}],[\"那么就会解析错误\",{\"1\":{\"698\":1}}],[\"那么就需要给这个字段创建索引了\",{\"1\":{\"493\":1}}],[\"那么就不应当发生直接的相互调用\",{\"1\":{\"76\":1}}],[\"那么盘块所能容纳的关键字数量也越多\",{\"1\":{\"488\":1}}],[\"那么成绩表中的student\",{\"1\":{\"482\":1}}],[\"那么即使另一列有不同的值\",{\"1\":{\"482\":1}}],[\"那么即使a的区分度更高\",{\"1\":{\"481\":1}}],[\"那么只需要单建idx\",{\"1\":{\"481\":1}}],[\"那么只会加载和处理文件的一部分\",{\"1\":{\"422\":1}}],[\"那么索引有序性无法利用\",{\"1\":{\"481\":1}}],[\"那么无法使用此索引\",{\"1\":{\"481\":1}}],[\"那么放在堆中\",{\"1\":{\"478\":1}}],[\"那么上一个单词及其频率如果大于堆顶的词的频率\",{\"1\":{\"478\":1}}],[\"那么将这个输入流再一次添加到栈中\",{\"1\":{\"478\":1}}],[\"那么表目录下的所有文件将都会被加载\",{\"1\":{\"413\":1}}],[\"那么建议直接使用jsonserde来实现处理最为方便\",{\"1\":{\"395\":1}}],[\"那么建造者模式就是一个汽车组装工厂\",{\"1\":{\"20\":1}}],[\"那么lazysimpleserde就不再适用了\",{\"1\":{\"371\":1}}],[\"那么返回null\",{\"1\":{\"340\":1}}],[\"那么数据的前两个字段作为表的字段载入表中\",{\"1\":{\"285\":1}}],[\"那么系统会自动重写查询语句\",{\"1\":{\"276\":1}}],[\"那么一个磁盘块是装不下文件的整张索引表的\",{\"1\":{\"197\":1}}],[\"链路层对一次能够发送的最大数据有限制\",{\"1\":{\"694\":1}}],[\"链表不支持随机访问\",{\"1\":{\"600\":1}}],[\"链表\",{\"1\":{\"579\":1}}],[\"链表就会转换为红黑树\",{\"1\":{\"579\":1}}],[\"链表等等\",{\"1\":{\"517\":1}}],[\"链式\",{\"1\":{\"318\":1}}],[\"链中的每一个进程已获得的资源同时被下一个进程所请求\",{\"1\":{\"175\":1}}],[\"链接\",{\"1\":{\"630\":1}}],[\"链接方案\",{\"1\":{\"197\":1}}],[\"链接方式\",{\"1\":{\"159\":1}}],[\"链接分配采取离散分配的方式\",{\"1\":{\"197\":1}}],[\"链接分配\",{\"1\":{\"197\":1}}],[\"链接的三种方式\",{\"1\":{\"179\":1}}],[\"链接依赖库\",{\"1\":{\"94\":1,\"102\":1}}],[\"异或\",{\"1\":{\"1174\":1}}],[\"异或表示两者的值不同\",{\"1\":{\"331\":1}}],[\"异常报告\",{\"1\":{\"1522\":1}}],[\"异常信息由于会被\",{\"1\":{\"1411\":1}}],[\"异常处理等辅助操作\",{\"1\":{\"1522\":1}}],[\"异常处理\",{\"0\":{\"1411\":1},\"1\":{\"1438\":1}}],[\"异常处理原则\",{\"1\":{\"775\":1}}],[\"异常解析器\",{\"0\":{\"1403\":1}}],[\"异常关闭时\",{\"1\":{\"833\":1}}],[\"异常值\",{\"1\":{\"733\":1}}],[\"异常是\",{\"1\":{\"705\":1}}],[\"异常\",{\"1\":{\"676\":1,\"725\":1,\"765\":1,\"776\":1,\"1482\":2}}],[\"异如上\",{\"1\":{\"175\":1}}],[\"异步秒杀思路\",{\"0\":{\"1155\":1}}],[\"异步的构建缓存\",{\"1\":{\"1126\":1}}],[\"异步模型需要底层操作系统\",{\"1\":{\"856\":1}}],[\"异步意味着\",{\"1\":{\"856\":1}}],[\"异步阻塞\",{\"1\":{\"851\":1}}],[\"异步处理线程池\",{\"1\":{\"1157\":1}}],[\"异步处理\",{\"1\":{\"1009\":1}}],[\"异步处理任务失败\",{\"1\":{\"764\":1}}],[\"异步处理任务成功\",{\"1\":{\"761\":1}}],[\"异步处理关闭\",{\"1\":{\"754\":1}}],[\"异步接收结果\",{\"1\":{\"756\":1,\"761\":1}}],[\"异步并没有缩短响应时间\",{\"1\":{\"755\":1}}],[\"异步方式用了多线程\",{\"1\":{\"755\":1}}],[\"异步方式处理关闭\",{\"1\":{\"754\":1}}],[\"异步提升的是什么💡\",{\"0\":{\"755\":1}}],[\"异步非阻塞\",{\"1\":{\"753\":1,\"851\":1}}],[\"异步执行distcp拷贝任务\",{\"1\":{\"869\":1}}],[\"异步执行\",{\"1\":{\"740\":1}}],[\"异步io的实现会负责把数据从内核空间拷贝到用户空间\",{\"1\":{\"680\":1}}],[\"异步io\",{\"1\":{\"679\":1}}],[\"异步i\",{\"1\":{\"679\":2}}],[\"异步性\",{\"1\":{\"159\":1}}],[\"异步\",{\"1\":{\"155\":2,\"851\":2}}],[\"死亡数\",{\"1\":{\"972\":1}}],[\"死亡病例数\",{\"1\":{\"972\":1}}],[\"死循环的异同\",{\"1\":{\"175\":1}}],[\"死循环的概念\",{\"1\":{\"175\":1}}],[\"死锁检查抛出的\",{\"1\":{\"765\":1}}],[\"死锁检查\",{\"1\":{\"765\":1}}],[\"死锁是因为线程互相持有对象想要的锁\",{\"1\":{\"552\":1}}],[\"死锁是指两个或两个以上的事务在执行过程中\",{\"1\":{\"513\":1}}],[\"死锁与活锁的区别\",{\"1\":{\"552\":1}}],[\"死锁的检测和解除\",{\"1\":{\"175\":1}}],[\"死锁的处理策略\",{\"0\":{\"176\":1,\"177\":1,\"178\":1},\"1\":{\"175\":1}}],[\"死锁的概念\",{\"0\":{\"175\":1}}],[\"死锁结束\",{\"1\":{\"175\":1}}],[\"死锁产生的条件\",{\"1\":{\"175\":1}}],[\"死锁\",{\"0\":{\"550\":1,\"551\":1},\"1\":{\"175\":1}}],[\"什么叫做连续签到天数\",{\"1\":{\"1176\":1}}],[\"什么情况下触发垃圾回收\",{\"1\":{\"633\":1}}],[\"什么是mvc\",{\"0\":{\"1528\":1}}],[\"什么是锁不住呢\",{\"1\":{\"1147\":1}}],[\"什么是缓存\",{\"0\":{\"1113\":1},\"1\":{\"1113\":1}}],[\"什么是布隆过滤器\",{\"0\":{\"658\":1}}],[\"什么是内存\",{\"1\":{\"179\":1}}],[\"什么是安全序列\",{\"1\":{\"177\":1}}],[\"什么是死锁\",{\"1\":{\"175\":1}}],[\"什么时候可以加\",{\"0\":{\"714\":1}}],[\"什么时候会从用户态切换到内核态\",{\"1\":{\"676\":1}}],[\"什么时候会发生死锁\",{\"1\":{\"175\":1}}],[\"什么时候应该交换\",{\"1\":{\"181\":1}}],[\"什么时候调整\",{\"1\":{\"167\":1}}],[\"函数式接口\",{\"1\":{\"1437\":1}}],[\"函数式\",{\"1\":{\"1437\":1}}],[\"函数式sql\",{\"0\":{\"1235\":1}}],[\"函数式编程接口\",{\"1\":{\"562\":4}}],[\"函数时\",{\"1\":{\"726\":1}}],[\"函数返回\",{\"1\":{\"680\":1}}],[\"函数来说\",{\"1\":{\"662\":1}}],[\"函数类似\",{\"1\":{\"662\":1}}],[\"函数和\",{\"1\":{\"662\":1}}],[\"函数假定程序员在执行这个函数时\",{\"1\":{\"662\":1}}],[\"函数是可以将两个字符串拼接在一起\",{\"1\":{\"662\":1}}],[\"函数的执行流程\",{\"1\":{\"662\":1}}],[\"函数型接口\",{\"1\":{\"614\":1}}],[\"函数重要应用案例\",{\"0\":{\"370\":1}}],[\"函数高阶\",{\"0\":{\"345\":1}}],[\"函数功能\",{\"1\":{\"338\":1,\"339\":1,\"340\":1}}],[\"函数功能测试\",{\"1\":{\"329\":1}}],[\"函数作用\",{\"1\":{\"336\":1,\"337\":1}}],[\"函数名\",{\"1\":{\"336\":1,\"337\":1,\"338\":1,\"339\":1,\"340\":1}}],[\"函数入门\",{\"0\":{\"333\":1}}],[\"函数\",{\"0\":{\"327\":1},\"1\":{\"173\":1,\"505\":1,\"663\":1}}],[\"易出错\",{\"1\":{\"173\":1}}],[\"易于维护和升级\",{\"1\":{\"72\":1}}],[\"编程式事务\",{\"1\":{\"1513\":1}}],[\"编程添加\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"编程客户端\",{\"1\":{\"1198\":1}}],[\"编辑日志\",{\"1\":{\"886\":1}}],[\"编写条件判断逻辑\",{\"1\":{\"1466\":1}}],[\"编写控制器\",{\"1\":{\"1441\":1}}],[\"编写代码\",{\"1\":{\"1023\":1,\"1024\":1}}],[\"编写\",{\"1\":{\"794\":2,\"1441\":1}}],[\"编写程序困难\",{\"1\":{\"173\":1}}],[\"编解码器\",{\"0\":{\"713\":1}}],[\"编号\",{\"1\":{\"1321\":6}}],[\"编号从0至15\",{\"1\":{\"1202\":1}}],[\"编号0~15\",{\"1\":{\"1196\":1}}],[\"编号相同\",{\"1\":{\"403\":2}}],[\"编号相同资源一次申请完\",{\"1\":{\"176\":1}}],[\"编号id\",{\"1\":{\"237\":1}}],[\"编码解决商品查询的缓存穿透问题\",{\"0\":{\"1124\":1}}],[\"编码和解码工作会消耗hdfs客户端和datanode上的额外cpu\",{\"1\":{\"875\":1}}],[\"编码\",{\"1\":{\"201\":1}}],[\"编译阶段\",{\"1\":{\"1508\":1}}],[\"编译时会进行预处理用\",{\"1\":{\"1230\":1}}],[\"编译安装isa\",{\"1\":{\"876\":1}}],[\"编译器增强能突破代理仅能通过方法重写增强的限制\",{\"1\":{\"1300\":1}}],[\"编译器也能修改\",{\"1\":{\"1300\":1}}],[\"编译器也会给它分配\",{\"1\":{\"663\":1}}],[\"编译器\",{\"0\":{\"1299\":1},\"1\":{\"1300\":1}}],[\"编译器在编译\",{\"1\":{\"1298\":1}}],[\"编译器就分配多少空间\",{\"1\":{\"663\":1}}],[\"编译器是使用\",{\"1\":{\"663\":1}}],[\"编译器会按照\",{\"1\":{\"663\":1}}],[\"编译\",{\"1\":{\"232\":1}}],[\"编译和链接之后装入模块的地址都是从0开始\",{\"1\":{\"179\":1}}],[\"编译和链接之后指令中的地址都是从0开始的逻辑地址\",{\"1\":{\"179\":1}}],[\"编译程序产生绝对地址的目标代码\",{\"1\":{\"179\":1}}],[\"编译依赖范围\",{\"1\":{\"100\":1}}],[\"编译环境\",{\"1\":{\"100\":1}}],[\"编译项目\",{\"1\":{\"95\":1}}],[\"初步了解\",{\"1\":{\"1362\":1}}],[\"初步代码\",{\"1\":{\"1137\":1}}],[\"初识文件管理\",{\"0\":{\"194\":1}}],[\"初始redis\",{\"0\":{\"1183\":1}}],[\"初始代码\",{\"1\":{\"1161\":1}}],[\"初始方案思路总结\",{\"0\":{\"1109\":1}}],[\"初始时间戳\",{\"1\":{\"999\":1}}],[\"初始时为1\",{\"1\":{\"574\":1}}],[\"初始时为1时的区别\",{\"1\":{\"574\":1}}],[\"初始主键值为1\",{\"1\":{\"997\":1}}],[\"初始容量是\",{\"1\":{\"768\":1,\"773\":1}}],[\"初始状态\",{\"1\":{\"538\":1}}],[\"初始值为0\",{\"1\":{\"172\":1}}],[\"初始化之前执行\",{\"1\":{\"1505\":1}}],[\"初始化之前执行的方法\",{\"1\":{\"1505\":1}}],[\"初始化之后执行\",{\"1\":{\"1505\":1}}],[\"初始化之后执行的方法\",{\"1\":{\"1505\":1}}],[\"初始化之后\",{\"1\":{\"1336\":1}}],[\"初始化前用它增强\",{\"1\":{\"1413\":1}}],[\"初始化前后的增强\",{\"1\":{\"1254\":1}}],[\"初始化时准备参数解析器\",{\"1\":{\"1438\":2}}],[\"初始化时记录映射关系\",{\"1\":{\"1438\":1}}],[\"初始化时会优先到容器里寻找各种组件\",{\"1\":{\"1438\":1}}],[\"初始化时会解析\",{\"1\":{\"1382\":1,\"1390\":1,\"1410\":1}}],[\"初始化时\",{\"1\":{\"1355\":2}}],[\"初始化销毁顺序\",{\"0\":{\"1287\":1}}],[\"初始化销毁方法是什么\",{\"1\":{\"1248\":1}}],[\"初始化与销毁\",{\"0\":{\"1286\":1}}],[\"初始化器增强\",{\"1\":{\"1446\":1}}],[\"初始化器的\",{\"1\":{\"740\":1}}],[\"初始化器的职责是将\",{\"1\":{\"740\":1}}],[\"初始化器是一次性的\",{\"1\":{\"740\":1}}],[\"初始化器\",{\"1\":{\"740\":1,\"743\":1,\"1444\":1}}],[\"初始化零值\",{\"1\":{\"630\":1}}],[\"初始化成员变量\",{\"1\":{\"630\":1}}],[\"初始化才正式开始\",{\"1\":{\"630\":1}}],[\"初始化分配到的空间\",{\"1\":{\"630\":1}}],[\"初始化容量\",{\"1\":{\"606\":1}}],[\"初始化table使用了cas\",{\"1\":{\"579\":1}}],[\"初始化一个100个节点的小顶堆\",{\"1\":{\"478\":1}}],[\"初始化一个小顶堆\",{\"1\":{\"478\":1}}],[\"初始化程序\",{\"1\":{\"206\":1}}],[\"初始化\",{\"0\":{\"1353\":1},\"1\":{\"171\":1,\"630\":1,\"673\":1,\"737\":1,\"740\":1,\"1252\":1,\"1257\":1,\"1264\":1,\"1285\":1,\"1438\":1}}],[\"初始化pcb\",{\"1\":{\"160\":1}}],[\"初值为1\",{\"1\":{\"172\":1}}],[\"相较于原来从缓存中查询不到数据后直接查询数据库而言\",{\"1\":{\"1127\":1}}],[\"相同goodsid的商品和订单会到同一个reduce的同一个分组\",{\"1\":{\"988\":1}}],[\"相同的构建器\",{\"1\":{\"12\":1}}],[\"相同的装配\",{\"1\":{\"12\":1}}],[\"相应地将内存的物理地址空间分成若干个块\",{\"1\":{\"683\":1}}],[\"相应地\",{\"1\":{\"683\":1}}],[\"相应就大大提高了执行速度\",{\"1\":{\"596\":1}}],[\"相对消费者\",{\"1\":{\"1026\":1}}],[\"相对路径\",{\"1\":{\"821\":1}}],[\"相对于整体偏移量等信息\",{\"1\":{\"779\":1}}],[\"相对于select和poll而言\",{\"1\":{\"680\":1}}],[\"相对于应用程序的执行\",{\"1\":{\"637\":1}}],[\"相对还算比较容易\",{\"1\":{\"614\":1}}],[\"相对来说\",{\"1\":{\"588\":1,\"1501\":1}}],[\"相对来说io读写次数也就降低了\",{\"1\":{\"488\":1}}],[\"相对耗时的任务\",{\"1\":{\"574\":1}}],[\"相对性能比较差\",{\"1\":{\"418\":1}}],[\"相对地址\",{\"1\":{\"179\":2}}],[\"相关算法原理大家可以参考\",{\"1\":{\"1179\":1}}],[\"相关介绍\",{\"1\":{\"989\":1}}],[\"相关解析\",{\"0\":{\"959\":1,\"961\":1}}],[\"相关概念\",{\"0\":{\"929\":1}}],[\"相关命令\",{\"0\":{\"926\":1}}],[\"相关方法都会不会让线程暂停\",{\"1\":{\"827\":1}}],[\"相关方法都会导致线程暂停\",{\"1\":{\"826\":1}}],[\"相关的\",{\"1\":{\"780\":1}}],[\"相关配置\",{\"1\":{\"733\":1,\"1453\":1}}],[\"相关依赖\",{\"1\":{\"344\":1,\"985\":1,\"1022\":1}}],[\"相关子查询\",{\"1\":{\"317\":2}}],[\"相当于字符串拼接\",{\"1\":{\"1230\":1}}],[\"相当于占位符\",{\"1\":{\"1230\":1}}],[\"相当于减\",{\"1\":{\"1206\":1}}],[\"相当于条件判断并没有起到作用\",{\"1\":{\"1145\":1}}],[\"相当于是数据表的字段\",{\"1\":{\"1064\":1}}],[\"相当于回到没有设置acl之前的样子\",{\"1\":{\"926\":1}}],[\"相当于有\",{\"1\":{\"663\":1}}],[\"相当于外表循环\",{\"1\":{\"496\":1}}],[\"相当于in\",{\"1\":{\"317\":1}}],[\"相当于\",{\"1\":{\"303\":1,\"324\":1,\"1206\":1}}],[\"相当于从数据预处理的角度优化数据访问\",{\"1\":{\"274\":1}}],[\"相当于宾馆的房间\",{\"1\":{\"179\":1}}],[\"相比于我们平时常用的的\",{\"1\":{\"658\":1}}],[\"相比于对segment加锁\",{\"1\":{\"579\":1}}],[\"相比于隐式链接来说\",{\"1\":{\"197\":1}}],[\"相比软件实现方法\",{\"1\":{\"170\":1}}],[\"利用其它们实现转换\",{\"1\":{\"1368\":1}}],[\"利用智能算法屏蔽掉违规的\",{\"1\":{\"1166\":1}}],[\"利用redis\",{\"1\":{\"1196\":1}}],[\"利用redis中恰当的数据结构\",{\"1\":{\"1165\":1}}],[\"利用redis的set集合判断是否点赞过\",{\"1\":{\"1161\":1}}],[\"利用redis集群保证高可用和高并发特性\",{\"1\":{\"1147\":1}}],[\"利用redis集群提高服务的可用性\",{\"1\":{\"1125\":1}}],[\"利用独立线程异步下单\",{\"1\":{\"1157\":1}}],[\"利用lua同样可以保证不会删除别人的锁\",{\"1\":{\"1147\":1}}],[\"利用添加过期时间\",{\"1\":{\"1147\":1}}],[\"利用java代码调用lua脚本改造分布式锁\",{\"0\":{\"1147\":1}}],[\"利用锁超时时间\",{\"1\":{\"1140\":1}}],[\"利用节点的唯一性和有序性实现互斥\",{\"1\":{\"1140\":1}}],[\"利用mysql本身的互斥锁机制\",{\"1\":{\"1140\":1}}],[\"利用mmap\",{\"1\":{\"680\":1}}],[\"利用这套逻辑来实现分布式锁\",{\"1\":{\"1140\":1}}],[\"利用set的命令实现下列功能\",{\"1\":{\"1210\":1}}],[\"利用set\",{\"1\":{\"1147\":3}}],[\"利用setnx方法进行加锁\",{\"1\":{\"1142\":1}}],[\"利用setnx这样的互斥命令\",{\"1\":{\"1140\":1}}],[\"利用setnx这个方法\",{\"1\":{\"1140\":1}}],[\"利用shuffle过程中的分组来实现关联\",{\"1\":{\"449\":1}}],[\"利用cas进行无锁化机制加锁\",{\"1\":{\"1135\":1}}],[\"利用缓存空值的方式解决缓存穿透问题\",{\"1\":{\"1129\":2}}],[\"利用单元测试进行缓存预热\",{\"1\":{\"1128\":1}}],[\"利用逻辑过期解决缓存击穿问题\",{\"0\":{\"1128\":1}}],[\"利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑\",{\"1\":{\"1127\":1}}],[\"利用互斥锁解决缓存击穿问题\",{\"0\":{\"1127\":1}}],[\"利用tcc等分布式事务方案\",{\"1\":{\"1121\":1}}],[\"利用集群支撑起整个项目\",{\"1\":{\"1094\":1}}],[\"利用数据库唯一索引特性\",{\"1\":{\"1005\":1}}],[\"利用分布式缓存\",{\"1\":{\"990\":1}}],[\"利用它两个进程除了可以传递普通数据外\",{\"1\":{\"872\":1}}],[\"利用多线程优化💡\",{\"0\":{\"846\":1}}],[\"利用局部性原理实现高速缓存\",{\"1\":{\"687\":1}}],[\"利用率\",{\"1\":{\"576\":1}}],[\"利用延迟关联或者子查询优化超多分页场景\",{\"1\":{\"481\":1}}],[\"利用覆盖索引来进行查询操作\",{\"1\":{\"481\":1}}],[\"利用\",{\"1\":{\"170\":1}}],[\"遵循四舍五入\",{\"1\":{\"338\":1}}],[\"遵循了空闲让进\",{\"1\":{\"169\":1}}],[\"遵循里氏替换原则\",{\"1\":{\"73\":1}}],[\"数量大可能会影响到数据的处理效率\",{\"1\":{\"995\":1}}],[\"数量级增长会非常快\",{\"1\":{\"493\":1}}],[\"数字集很大\",{\"1\":{\"660\":1}}],[\"数字转换为n\",{\"1\":{\"342\":1}}],[\"数千万岁\",{\"1\":{\"480\":1}}],[\"数百岁\",{\"1\":{\"480\":1}}],[\"数值\",{\"1\":{\"1182\":1}}],[\"数值出现的次数\",{\"1\":{\"457\":1}}],[\"数值类型\",{\"1\":{\"248\":1}}],[\"数组中指定范围内第一个\",{\"1\":{\"1174\":1}}],[\"数组中的指定位置\",{\"1\":{\"1174\":1}}],[\"数组中的各个元素用来标志各进程想进入临界区的意愿\",{\"1\":{\"169\":1}}],[\"数组转换为二叉树\",{\"1\":{\"669\":1}}],[\"数组\",{\"1\":{\"610\":1,\"687\":1,\"779\":1,\"1174\":1}}],[\"数组支持随机访问\",{\"1\":{\"600\":1}}],[\"数组和链表在插入删除方面的区别\",{\"1\":{\"600\":1}}],[\"数组排序函数\",{\"1\":{\"339\":2}}],[\"数学函数\",{\"0\":{\"338\":1},\"1\":{\"338\":1}}],[\"数据绑定工厂\",{\"0\":{\"1374\":1}}],[\"数据序列化器\",{\"0\":{\"1222\":1}}],[\"数据利用哈希思想\",{\"1\":{\"1177\":1}}],[\"数据抽象成一个非常大的\",{\"1\":{\"1177\":1}}],[\"数据并不在\",{\"1\":{\"1177\":1}}],[\"数据安全问题\",{\"1\":{\"1157\":1}}],[\"数据安全与隐私保护\",{\"0\":{\"907\":1}}],[\"数据key\",{\"1\":{\"1156\":1}}],[\"数据量会非常恐怖\",{\"1\":{\"1179\":1}}],[\"数据量过大之后\",{\"1\":{\"1131\":1}}],[\"数据量小的表\",{\"1\":{\"494\":1}}],[\"数据清理\",{\"0\":{\"1056\":1},\"1\":{\"1056\":1}}],[\"数据积压指的是消费者因为有一些外部的io\",{\"1\":{\"1055\":1}}],[\"数据积压\",{\"0\":{\"1055\":1}}],[\"数据集大时成本极高\",{\"1\":{\"988\":1}}],[\"数据集市通常只涉及一个主题领域\",{\"1\":{\"223\":1}}],[\"数据集市\",{\"0\":{\"220\":1,\"223\":1},\"1\":{\"223\":1}}],[\"数据就会变得无须\",{\"1\":{\"1035\":1}}],[\"数据就会被分到同一个分区\",{\"1\":{\"973\":1}}],[\"数据就一定可以分区到同一个reducetask\",{\"1\":{\"968\":1}}],[\"数据归约是指在尽可能保持数据原貌的前提下\",{\"1\":{\"969\":1}}],[\"数据分区的核心是分区规则\",{\"1\":{\"968\":1}}],[\"数据测试\",{\"1\":{\"912\":1}}],[\"数据备份\",{\"1\":{\"912\":1}}],[\"数据恢复\",{\"1\":{\"912\":1}}],[\"数据块大小\",{\"1\":{\"905\":1}}],[\"数据块+奇偶校验块\",{\"1\":{\"875\":1}}],[\"数据本身实际存储在datanodes中\",{\"1\":{\"903\":1}}],[\"数据从datanode流回客户端\",{\"1\":{\"902\":1}}],[\"数据从内核缓冲区传输到\",{\"1\":{\"855\":1}}],[\"数据状态不同步\",{\"1\":{\"882\":1}}],[\"数据状态同步问题\",{\"1\":{\"882\":1}}],[\"数据损坏\",{\"1\":{\"882\":1}}],[\"数据密度绝对值的总和\",{\"1\":{\"874\":1}}],[\"数据密度\",{\"1\":{\"874\":1}}],[\"数据拷贝了\",{\"1\":{\"855\":2}}],[\"数据拷贝了共\",{\"1\":{\"854\":1}}],[\"数据包大小一样\",{\"1\":{\"840\":1}}],[\"数据包的大小不好把握\",{\"1\":{\"697\":1}}],[\"数据暂不能写出的情况\",{\"1\":{\"831\":1}}],[\"数据暂不能读入的情况\",{\"1\":{\"831\":1}}],[\"数据暂存层\",{\"1\":{\"225\":1}}],[\"数据可写出时触发\",{\"1\":{\"831\":1}}],[\"数据可读入时触发\",{\"1\":{\"831\":1}}],[\"数据可以安全使用\",{\"1\":{\"590\":1}}],[\"数据复制过程中\",{\"1\":{\"827\":1}}],[\"数据之间使用\",{\"1\":{\"809\":1}}],[\"数据经过网络传输\",{\"1\":{\"785\":1}}],[\"数据写完之后再取消关注\",{\"1\":{\"844\":1}}],[\"数据写出\",{\"1\":{\"766\":1}}],[\"数据写入的时候时什么样的\",{\"1\":{\"663\":1}}],[\"数据读取\",{\"1\":{\"766\":1}}],[\"数据读取到了一个它稍微处理的缓冲区\",{\"1\":{\"610\":1}}],[\"数据也一般是以向量\",{\"1\":{\"687\":1}}],[\"数据或代码页会根据需要在物理内存与磁盘之间移动\",{\"1\":{\"685\":1}}],[\"数据会先被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"679\":1}}],[\"数据会被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"678\":1}}],[\"数据结构的基本用法\",{\"0\":{\"1170\":1}}],[\"数据结构\",{\"0\":{\"655\":1},\"1\":{\"661\":1,\"664\":1}}],[\"数据总是从通道读取到缓冲区中\",{\"1\":{\"612\":1}}],[\"数据先写入主节点\",{\"1\":{\"527\":1}}],[\"数据是存放在磁盘中的\",{\"1\":{\"506\":1}}],[\"数据无序\",{\"1\":{\"502\":1}}],[\"数据相似性大的就不适合建立索引\",{\"1\":{\"493\":1}}],[\"数据又是递增的\",{\"1\":{\"488\":1}}],[\"数据页\",{\"1\":{\"486\":1}}],[\"数据订正\",{\"1\":{\"482\":1}}],[\"数据类型的底层数据结构是\",{\"1\":{\"661\":1}}],[\"数据类型必须绝对一致\",{\"1\":{\"481\":1}}],[\"数据类型是unsigned\",{\"1\":{\"480\":1}}],[\"数据类型英文字母大小写不敏感\",{\"1\":{\"248\":1}}],[\"数据倾斜时自动负载均衡\",{\"0\":{\"466\":1}}],[\"数据倾斜的现象是\",{\"1\":{\"462\":1}}],[\"数据倾斜\",{\"0\":{\"462\":1},\"1\":{\"1034\":1}}],[\"数据压缩对于节省资源\",{\"1\":{\"432\":1}}],[\"数据压缩\",{\"0\":{\"431\":1}}],[\"数据字段中包含了分隔符\",{\"1\":{\"372\":1}}],[\"数据字段含义\",{\"1\":{\"265\":1}}],[\"数据脱敏函数\",{\"0\":{\"342\":1},\"1\":{\"342\":1}}],[\"数据导出操作使用的是overwrite操作\",{\"1\":{\"290\":1}}],[\"数据操控\",{\"0\":{\"282\":1}}],[\"数据文件为了维持b+树的特性而频繁的分裂调整\",{\"1\":{\"490\":1}}],[\"数据文件的倒数第二个字段为一级分区\",{\"1\":{\"285\":1}}],[\"数据文件\",{\"1\":{\"256\":1}}],[\"数据定义语言\",{\"0\":{\"245\":1}}],[\"数据模型\",{\"0\":{\"233\":1}}],[\"数据在传输过程中需要在应用程序地址空间和内核之间进行多次数据拷贝操作\",{\"1\":{\"678\":1}}],[\"数据在数据仓库系统中进行转换\",{\"1\":{\"228\":1}}],[\"数据在从源数据池中提取后立即加载\",{\"1\":{\"228\":1}}],[\"数据保存在临时暂存数据库中\",{\"1\":{\"228\":1}}],[\"数据挖掘等分析\",{\"1\":{\"227\":1}}],[\"数据应用层\",{\"1\":{\"227\":1}}],[\"数据引入层\",{\"1\":{\"225\":1}}],[\"数据库引擎不支持事务\",{\"1\":{\"1517\":1}}],[\"数据库数量\",{\"1\":{\"1196\":1}}],[\"数据库中有一张tb\",{\"1\":{\"1164\":1}}],[\"数据库中的version变成了2\",{\"1\":{\"1135\":1}}],[\"数据库点赞数\",{\"1\":{\"1161\":1,\"1162\":2}}],[\"数据库点赞数+1\",{\"1\":{\"1161\":1}}],[\"数据库存在\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":1}}],[\"数据库不存在返回错误\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":1}}],[\"数据库和缓存不一致采用什么方案\",{\"0\":{\"1121\":1}}],[\"数据库与缓存的问题交由系统本身去处理\",{\"1\":{\"1120\":1}}],[\"数据库与数据仓库的区别实际讲的是oltp与olap的区别\",{\"1\":{\"222\":1}}],[\"数据库缓存不一致解决方案\",{\"0\":{\"1120\":1}}],[\"数据库缓存\",{\"1\":{\"1115\":1}}],[\"数据库去重表\",{\"1\":{\"1005\":1}}],[\"数据库死锁问题以及解决办法\",{\"0\":{\"513\":1}}],[\"数据库会自动给更大一级的空间\",{\"1\":{\"510\":1}}],[\"数据库也能将数据恢复\",{\"1\":{\"506\":1}}],[\"数据库的完整性约束没有被破坏\",{\"1\":{\"506\":1}}],[\"数据库状态应该退回到执行事务前的状态\",{\"1\":{\"506\":1}}],[\"数据库索引失效了怎么办\",{\"0\":{\"505\":1}}],[\"数据库索引是存储在磁盘上的\",{\"1\":{\"486\":1}}],[\"数据库名\",{\"1\":{\"480\":1}}],[\"数据库字段名的修改代价很大\",{\"1\":{\"480\":1}}],[\"数据库开发规范\",{\"0\":{\"479\":1}}],[\"数据库是为捕获数据而设计\",{\"1\":{\"222\":1}}],[\"数据库是面向事务的设计\",{\"1\":{\"222\":1}}],[\"数据库一般存储业务数据\",{\"1\":{\"222\":1}}],[\"数据库\",{\"0\":{\"220\":1,\"222\":1,\"234\":1,\"278\":1},\"1\":{\"791\":1,\"1184\":1}}],[\"数据仓库从各数据源获取数据及在数据仓库内的数据转换和流动都可以认为是etl\",{\"1\":{\"228\":1}}],[\"数据仓库层\",{\"1\":{\"224\":1,\"226\":1}}],[\"数据仓库分层架构\",{\"0\":{\"224\":1}}],[\"数据仓库是为分析数据而设计\",{\"1\":{\"222\":1}}],[\"数据仓库是面向主题设计的\",{\"1\":{\"222\":1}}],[\"数据仓库存储的一般是历史数据\",{\"1\":{\"222\":1}}],[\"数据仓库的出现\",{\"1\":{\"222\":1}}],[\"数据仓库的目的是构建面向分析的集成化数据环境\",{\"1\":{\"219\":1}}],[\"数据仓库不是大型的数据库\",{\"1\":{\"222\":1}}],[\"数据仓库\",{\"0\":{\"219\":1,\"220\":1,\"222\":1,\"223\":1},\"1\":{\"219\":1,\"223\":1}}],[\"数据仓库基础与\",{\"0\":{\"218\":1}}],[\"数据缓冲区管理\",{\"1\":{\"210\":1}}],[\"数据传输中的数据恢复\",{\"1\":{\"875\":1}}],[\"数据传输效率进一步增加\",{\"1\":{\"209\":1}}],[\"数据传输以\",{\"1\":{\"209\":1}}],[\"数据传送单位\",{\"1\":{\"209\":1}}],[\"数据传送的单位\",{\"1\":{\"209\":2}}],[\"数据输出\",{\"1\":{\"209\":3}}],[\"数据输入\",{\"1\":{\"209\":3}}],[\"数据的同步\",{\"1\":{\"1026\":1}}],[\"数据的读取和写入是通过buffer\",{\"1\":{\"610\":1}}],[\"数据的最后一个字段作为分区字段进行分区\",{\"1\":{\"285\":1}}],[\"数据的传输不再需要先经过cpu再写入内存\",{\"1\":{\"209\":1}}],[\"数据的流向\",{\"1\":{\"209\":3}}],[\"数据的形式\",{\"1\":{\"162\":1}}],[\"数据寄存器\",{\"1\":{\"208\":1}}],[\"数据一旦被读出\",{\"1\":{\"162\":1}}],[\"数据以字符流的形式写入管道\",{\"1\":{\"162\":1}}],[\"数据段等等\",{\"1\":{\"683\":1}}],[\"数据段d和栈段s等\",{\"1\":{\"683\":1}}],[\"数据段组成\",{\"1\":{\"159\":1}}],[\"数据段\",{\"1\":{\"159\":1}}],[\"数据\",{\"1\":{\"74\":1,\"368\":1,\"840\":1,\"1035\":1,\"1177\":1}}],[\"试着一个boolean类型的数组flag\",{\"1\":{\"169\":1}}],[\"忙等\",{\"1\":{\"209\":1}}],[\"忙则等待\",{\"1\":{\"168\":1,\"169\":1}}],[\"忙碌\",{\"1\":{\"166\":1}}],[\"退款等等状态\",{\"1\":{\"1005\":1}}],[\"退回之前版本\",{\"1\":{\"892\":1}}],[\"退出锁逻辑\",{\"1\":{\"1141\":1}}],[\"退出客户端\",{\"1\":{\"962\":1,\"988\":1}}],[\"退出程序\",{\"1\":{\"962\":1}}],[\"退出循环\",{\"1\":{\"742\":4}}],[\"退出\",{\"0\":{\"705\":1}}],[\"退出群聊\",{\"1\":{\"704\":1}}],[\"退出区\",{\"1\":{\"168\":1}}],[\"退货\",{\"1\":{\"110\":1}}],[\"打头的注解本质是利用了\",{\"1\":{\"1465\":1}}],[\"打散流量\",{\"1\":{\"1094\":1}}],[\"打开\",{\"1\":{\"1441\":1}}],[\"打开不同的浏览器\",{\"1\":{\"1292\":1}}],[\"打开图标统计\",{\"1\":{\"1046\":1}}],[\"打开文件\",{\"1\":{\"199\":2}}],[\"打个比喻\",{\"1\":{\"766\":1}}],[\"打印banner信息\",{\"1\":{\"1522\":1}}],[\"打印可读取内容\",{\"1\":{\"799\":1}}],[\"打印所有内容\",{\"1\":{\"799\":1}}],[\"打印\",{\"1\":{\"753\":4,\"1025\":1,\"1444\":1}}],[\"打印机\",{\"1\":{\"168\":1}}],[\"打断线程\",{\"1\":{\"536\":1}}],[\"打快照\",{\"1\":{\"503\":1}}],[\"打包插件版本过低\",{\"1\":{\"102\":1}}],[\"打包方式默认就是jar\",{\"1\":{\"113\":1}}],[\"打包方式\",{\"1\":{\"98\":1,\"102\":1,\"962\":1}}],[\"打包是将工程打成jar或war文件\",{\"1\":{\"95\":1}}],[\"打包后上传到maven本地仓库\",{\"1\":{\"95\":1}}],[\"打包项目\",{\"1\":{\"95\":1}}],[\"打包和部署等多个步骤\",{\"1\":{\"94\":1,\"102\":1}}],[\"打包和发布项目\",{\"1\":{\"91\":1}}],[\"打包\",{\"1\":{\"91\":1,\"95\":1}}],[\"新\",{\"1\":{\"1245\":3}}],[\"新学一种代码之间解耦途径\",{\"1\":{\"1243\":1}}],[\"新功能\",{\"1\":{\"1170\":2}}],[\"新华字典前面的目录就是索引的意思\",{\"1\":{\"1061\":1}}],[\"新机器上配置hadoop环境变量\",{\"1\":{\"878\":1}}],[\"新机器基础环境准备\",{\"1\":{\"878\":1}}],[\"新增笔记失败\",{\"1\":{\"1167\":1}}],[\"新增秒杀优惠券的同时\",{\"1\":{\"1156\":1}}],[\"新增秒杀卷代码\",{\"1\":{\"1133\":1}}],[\"新增普通卷代码\",{\"1\":{\"1133\":1}}],[\"新增此方法\",{\"1\":{\"1128\":1}}],[\"新增文档\",{\"1\":{\"1073\":1,\"1089\":1}}],[\"新增设计了两种数据结构\",{\"1\":{\"667\":1}}],[\"新增或修改某个元素时\",{\"1\":{\"664\":1}}],[\"新增node\",{\"1\":{\"579\":1}}],[\"新生代收集器\",{\"1\":{\"638\":1}}],[\"新生代收集\",{\"1\":{\"628\":1}}],[\"新生代\",{\"1\":{\"628\":1}}],[\"新建\",{\"1\":{\"1441\":1}}],[\"新建一个单元测试类\",{\"1\":{\"1213\":1}}],[\"新建一个系统服务文件\",{\"1\":{\"1197\":1}}],[\"新建一个实体类\",{\"1\":{\"1128\":1}}],[\"新建一张事务表\",{\"1\":{\"276\":1}}],[\"新建的文件\",{\"1\":{\"926\":1}}],[\"新建countercells\",{\"1\":{\"579\":1}}],[\"新的数据被旧数据覆盖了\",{\"1\":{\"1121\":1}}],[\"新的检查点被创建后\",{\"1\":{\"910\":1}}],[\"新的\",{\"1\":{\"579\":1}}],[\"新写入操作会报错\",{\"1\":{\"522\":1}}],[\"新特性\",{\"0\":{\"285\":1,\"411\":1}}],[\"新进程到达时先进入第一级队列\",{\"1\":{\"167\":1}}],[\"新对象可以动态地引用与成分对象类型相同的对象\",{\"1\":{\"77\":1}}],[\"新对象可以调用已有对象的功能\",{\"1\":{\"77\":1}}],[\"新对象的属性和原来对象完全相同\",{\"1\":{\"51\":1}}],[\"抢购成功需要将用户\",{\"1\":{\"1156\":1}}],[\"抢购时间\",{\"1\":{\"1133\":1}}],[\"抢锁的逻辑就是之前说的那三个逻辑\",{\"1\":{\"1152\":1}}],[\"抢锁过程中\",{\"1\":{\"1152\":1}}],[\"抢占式算法\",{\"1\":{\"167\":1}}],[\"抢占式和非抢占式都有\",{\"1\":{\"167\":1}}],[\"抢到锁之后再次判断是否为空\",{\"1\":{\"66\":1}}],[\"抢到锁之后再次判断是否为null\",{\"1\":{\"66\":1}}],[\"若是错误的配置了以下三种事务传播行为\",{\"1\":{\"1514\":1}}],[\"若要支持\",{\"1\":{\"1443\":1}}],[\"若想获取更多用法\",{\"1\":{\"1440\":1}}],[\"若namenode出现了故障\",{\"1\":{\"883\":1}}],[\"若其所要访问的页面不在内存\",{\"1\":{\"690\":1}}],[\"若其中有与此相匹配地页号\",{\"1\":{\"683\":1}}],[\"若流中元素不足n个\",{\"1\":{\"616\":1}}],[\"若之前的counter值为0\",{\"1\":{\"549\":1}}],[\"若这个途中存在回路\",{\"1\":{\"513\":1}}],[\"若无外力作用\",{\"1\":{\"513\":1}}],[\"若无外力干涉\",{\"1\":{\"175\":1}}],[\"若将时间高低位互换\",{\"1\":{\"502\":1}}],[\"若实在避免不了\",{\"1\":{\"482\":1}}],[\"若count为0应直接返回\",{\"1\":{\"482\":1}}],[\"若存在\",{\"1\":{\"477\":1}}],[\"若进程请求的物理设备正在忙碌\",{\"1\":{\"213\":1}}],[\"若进程未能在时间片内运行完\",{\"1\":{\"167\":1}}],[\"若进程未在一个时间片内执行完毕\",{\"1\":{\"167\":1}}],[\"若换了一个物理设备\",{\"1\":{\"213\":1}}],[\"若通道忙碌则将进程pcb挂到通道等待队列中\",{\"1\":{\"213\":1}}],[\"若控制器忙碌则将进程pcb挂到控制器等待队列中\",{\"1\":{\"213\":1}}],[\"若设备忙碌则将进程pcb挂到设备等待队列中\",{\"1\":{\"213\":1}}],[\"若每个磁盘块1kb\",{\"1\":{\"197\":1}}],[\"若第三轮扫描失败\",{\"1\":{\"191\":1}}],[\"若第二轮扫描失败\",{\"1\":{\"191\":1}}],[\"若第一轮扫描失败\",{\"1\":{\"191\":1}}],[\"若第一轮扫描所有页面都是1\",{\"1\":{\"191\":1}}],[\"若还有可用的空闲内存块\",{\"1\":{\"191\":1}}],[\"若该页面在内存期间被修改过\",{\"1\":{\"190\":1}}],[\"若内存空间不够\",{\"1\":{\"189\":1,\"190\":1}}],[\"若更上级的队列中进入了一个新进程\",{\"1\":{\"167\":1}}],[\"若用完时间片进程还没有结束\",{\"1\":{\"167\":1}}],[\"若源源不断的有高优先级进程到来\",{\"1\":{\"167\":1}}],[\"若配置了以下标签\",{\"1\":{\"104\":1}}],[\"否定比较\",{\"1\":{\"330\":1}}],[\"否则向下走\",{\"1\":{\"1482\":4}}],[\"否则级联部分sql语句也会执行\",{\"1\":{\"1230\":1}}],[\"否则不执行\",{\"1\":{\"1206\":1,\"1208\":1}}],[\"否则不放\",{\"1\":{\"478\":1}}],[\"否则进行下单\",{\"1\":{\"1137\":1}}],[\"否则进程运行过程中将频繁缺页\",{\"1\":{\"192\":1}}],[\"否则报错\",{\"1\":{\"962\":1}}],[\"否则随机\",{\"1\":{\"900\":1}}],[\"否则无法实现\",{\"1\":{\"890\":1}}],[\"否则只能重启机器\",{\"1\":{\"879\":1}}],[\"否则下次处理就会有问题\",{\"1\":{\"836\":1,\"840\":1}}],[\"否则下次该事件仍会触发\",{\"1\":{\"835\":1}}],[\"否则\",{\"1\":{\"749\":1,\"765\":1,\"779\":1,\"1476\":1}}],[\"否则查询效率就会降低\",{\"1\":{\"664\":1}}],[\"否则最先被程序读入的\",{\"1\":{\"662\":1}}],[\"否则就是版本冲突\",{\"1\":{\"507\":1}}],[\"否则就改为新数据的开始时间\",{\"1\":{\"409\":1}}],[\"否则说明该文件输入流中没有数据了\",{\"1\":{\"478\":1}}],[\"否则failed\",{\"1\":{\"369\":1}}],[\"否则返回false\",{\"1\":{\"1142\":1,\"1144\":1}}],[\"否则返回组对象\",{\"1\":{\"701\":3}}],[\"否则返回\",{\"1\":{\"701\":2}}],[\"否则返回第一个\",{\"1\":{\"340\":1}}],[\"否则返回null\",{\"1\":{\"340\":2}}],[\"否则返回a\",{\"1\":{\"340\":1}}],[\"否则为false\",{\"1\":{\"332\":3}}],[\"否则metastore\",{\"1\":{\"281\":1}}],[\"否则会报错\",{\"1\":{\"878\":1}}],[\"否则会抛异常\",{\"1\":{\"822\":1}}],[\"否则会抛notserializableexception异常\",{\"1\":{\"54\":1}}],[\"否则会导致持久化文件过大\",{\"1\":{\"526\":1}}],[\"否则会产生过大的内部碎片\",{\"1\":{\"184\":1}}],[\"否\",{\"1\":{\"167\":1,\"241\":2}}],[\"随时都是有可能要执行的\",{\"1\":{\"1157\":1}}],[\"随时掌握各个任务的运行状态\",{\"1\":{\"953\":1}}],[\"随机生成token\",{\"1\":{\"1107\":1}}],[\"随机策略\",{\"1\":{\"1033\":1}}],[\"随机抽取2个学生的情况进行查看\",{\"1\":{\"367\":1}}],[\"随机抽样\",{\"0\":{\"367\":1}}],[\"随即策略\",{\"0\":{\"1033\":1}}],[\"随之旧的检查点就会被系统永久删除\",{\"1\":{\"910\":1}}],[\"随着类的加载而加载\",{\"1\":{\"1215\":1}}],[\"随着我们商城规模越来越大\",{\"1\":{\"1131\":1}}],[\"随着datanode的block汇报持续进行\",{\"1\":{\"870\":1}}],[\"随着分时操作系统的出现\",{\"1\":{\"167\":1}}],[\"随着等待时间越来越长\",{\"1\":{\"167\":1}}],[\"随身物品\",{\"1\":{\"147\":1}}],[\"响应结果\",{\"1\":{\"1416\":1}}],[\"响应状态\",{\"1\":{\"1072\":3}}],[\"响应太慢\",{\"1\":{\"1066\":1}}],[\"响应文件读取成功的是另一个线程\",{\"1\":{\"857\":1}}],[\"响应消息处理器\",{\"1\":{\"733\":1}}],[\"响应消息\",{\"1\":{\"733\":1}}],[\"响应式流\",{\"0\":{\"715\":1}}],[\"响应快\",{\"1\":{\"167\":1}}],[\"响应比\",{\"1\":{\"167\":1}}],[\"响应时间\",{\"1\":{\"166\":1}}],[\"饥饿的概念\",{\"1\":{\"175\":1}}],[\"饥饿\",{\"0\":{\"550\":1,\"553\":1},\"1\":{\"167\":1,\"175\":1}}],[\"短信验证码登录\",{\"1\":{\"1098\":1}}],[\"短信登录\",{\"0\":{\"1091\":1}}],[\"短应用程序\",{\"1\":{\"951\":1}}],[\"短路本地读取\",{\"0\":{\"872\":1},\"1\":{\"872\":1}}],[\"短路优先原则\",{\"1\":{\"105\":1}}],[\"短链接\",{\"0\":{\"696\":1},\"1\":{\"695\":1}}],[\"短任务优先\",{\"1\":{\"213\":1}}],[\"短进程优先\",{\"1\":{\"167\":1}}],[\"短作业优先算法\",{\"1\":{\"167\":1}}],[\"排他锁\",{\"1\":{\"508\":1,\"510\":1}}],[\"排序是mapreduce模型默认的行为\",{\"1\":{\"979\":1}}],[\"排序\",{\"0\":{\"618\":1,\"642\":1},\"1\":{\"961\":1}}],[\"排序字段\",{\"1\":{\"450\":1}}],[\"排序之后分为3个部分\",{\"1\":{\"364\":1}}],[\"排序函数\",{\"1\":{\"358\":1}}],[\"排在长作业\",{\"1\":{\"167\":1}}],[\"排队和对银行工作人员进行评分的业务对每个客户是一样的\",{\"1\":{\"83\":1}}],[\"排队\",{\"1\":{\"83\":1}}],[\"排队等一系列的操作\",{\"1\":{\"58\":1}}],[\"周转时间包括四个部分\",{\"1\":{\"166\":1}}],[\"周转时间\",{\"1\":{\"166\":3}}],[\"给一个key设置有效期\",{\"1\":{\"1205\":1}}],[\"给blog类中添加一个islike字段\",{\"1\":{\"1161\":1}}],[\"给业务添加多级缓存\",{\"1\":{\"1125\":1}}],[\"给缓存业务添加降级限流策略\",{\"1\":{\"1125\":1}}],[\"给不同的key的ttl添加随机值\",{\"1\":{\"1125\":1}}],[\"给数据库带来巨大压力\",{\"1\":{\"1124\":1}}],[\"给单点故障设置备份\",{\"1\":{\"882\":1}}],[\"给\",{\"1\":{\"726\":2}}],[\"给线程取名字\",{\"1\":{\"572\":1}}],[\"给udf命名\",{\"1\":{\"344\":1}}],[\"给出将a除以b所得的整数部分\",{\"1\":{\"331\":1}}],[\"给内存的存储单元编地址\",{\"1\":{\"179\":1}}],[\"给他们分配内存等必要资源\",{\"1\":{\"164\":1}}],[\"给程序设计带来便利的同时\",{\"1\":{\"73\":1}}],[\"客服了他们的缺点\",{\"1\":{\"163\":1}}],[\"客户程序就不需要变化\",{\"1\":{\"74\":1}}],[\"客户端对象\",{\"0\":{\"1071\":1},\"1\":{\"1071\":1}}],[\"客户端调用业务请求的时候必须携带这个token\",{\"1\":{\"1005\":1}}],[\"客户端先发送获取token的请求\",{\"1\":{\"1005\":1}}],[\"客户端提交job之前会对待处理数据进行逻辑切片\",{\"1\":{\"976\":1}}],[\"客户端通过该\",{\"1\":{\"949\":1}}],[\"客户端通过fsdataoutputstream开始写入数据\",{\"1\":{\"901\":1}}],[\"客户端一样把edek发送给kms获取dek\",{\"1\":{\"935\":1}}],[\"客户端与nn进行交互时\",{\"1\":{\"922\":1}}],[\"客户端从流中读取数据时\",{\"1\":{\"902\":1}}],[\"客户端在进行每次文件操时\",{\"1\":{\"916\":1}}],[\"客户端在fsdatainputstream输入流上调用read\",{\"1\":{\"902\":1}}],[\"客户端在每条消息之后\",{\"1\":{\"698\":1}}],[\"客户端完成数据写入后\",{\"1\":{\"901\":1}}],[\"客户端写入数据时\",{\"1\":{\"901\":1}}],[\"客户端是否具有创建该文件的权限\",{\"1\":{\"901\":1}}],[\"客户端就是一个datanode的话优先客户端本地\",{\"1\":{\"900\":1}}],[\"客户端将数据块写入第一个数据节点\",{\"1\":{\"898\":1}}],[\"客户端的读写路径得到了增强\",{\"1\":{\"875\":1}}],[\"客户端扩展\",{\"1\":{\"875\":1}}],[\"客户端正常\",{\"1\":{\"833\":1}}],[\"客户端发送数据过来\",{\"1\":{\"833\":1}}],[\"客户端发起连接请求\",{\"1\":{\"833\":1}}],[\"客户端连接成功时触发\",{\"1\":{\"831\":1}}],[\"客户端向服务器端发送\",{\"1\":{\"783\":1}}],[\"客户端\",{\"0\":{\"736\":1,\"738\":1,\"785\":1},\"1\":{\"748\":1,\"766\":1,\"795\":1,\"826\":1,\"839\":1,\"840\":1,\"843\":1,\"1150\":1}}],[\"客户端架子\",{\"1\":{\"733\":1}}],[\"客户端启动\",{\"1\":{\"726\":1}}],[\"客户端可以定义如下心跳处理器\",{\"1\":{\"707\":1}}],[\"客户端可以定时向服务器端发送数据\",{\"1\":{\"707\":1}}],[\"客户端定时心跳\",{\"1\":{\"707\":1}}],[\"客户端代码为\",{\"1\":{\"834\":1}}],[\"客户端代码不变\",{\"1\":{\"748\":1,\"827\":1}}],[\"客户端代码第一版\",{\"0\":{\"735\":1}}],[\"客户端代码\",{\"0\":{\"737\":1},\"1\":{\"699\":1}}],[\"客户端代码希望发送\",{\"1\":{\"692\":1,\"693\":1}}],[\"客户端输出\",{\"1\":{\"697\":1,\"698\":1,\"699\":1}}],[\"客户端什么时候\",{\"1\":{\"697\":1}}],[\"客户端测试代码\",{\"1\":{\"697\":1}}],[\"客户端命令行中添加jar包到hive的classpath\",{\"1\":{\"344\":1}}],[\"客户端如果需要对象\",{\"1\":{\"42\":1}}],[\"客户端不应该被迫依赖于它不使用的方法\",{\"1\":{\"75\":1}}],[\"客户端不依赖产品实例的创建细节和内部结构\",{\"1\":{\"41\":1}}],[\"客户端不必知道产品内部组成的细节\",{\"1\":{\"15\":1}}],[\"别的线程还可以执行\",{\"1\":{\"163\":1}}],[\"整合时\",{\"1\":{\"1245\":2}}],[\"整合\",{\"1\":{\"1240\":1,\"1243\":1}}],[\"整体可读性有了很大提升\",{\"1\":{\"1222\":1}}],[\"整体访问流程\",{\"0\":{\"1106\":1}}],[\"整体流程核心代码解读\",{\"0\":{\"992\":1}}],[\"整体概述\",{\"0\":{\"952\":1}}],[\"整数类型\",{\"1\":{\"1206\":1}}],[\"整数时\",{\"1\":{\"773\":1}}],[\"整数\",{\"1\":{\"772\":1,\"774\":1}}],[\"整堆收集器\",{\"1\":{\"638\":1}}],[\"整堆收集\",{\"1\":{\"628\":1}}],[\"整个自动配置的过程是\",{\"1\":{\"1524\":1}}],[\"整个过程开始于客户端发出一个http请求\",{\"1\":{\"1530\":1}}],[\"整个过程需要保证是原子性的\",{\"1\":{\"1155\":1}}],[\"整个过程仅只发生了一次用户态与内核态的切换\",{\"1\":{\"855\":1}}],[\"整个登录拦截功能就会出现问题\",{\"1\":{\"1102\":1}}],[\"整个用户的process其实是一直被block的\",{\"1\":{\"679\":1}}],[\"整个进程会被阻塞\",{\"1\":{\"679\":1}}],[\"整个进程都会被阻塞\",{\"1\":{\"163\":1}}],[\"整个concurrenthashmap就是一个node\",{\"1\":{\"579\":1}}],[\"整个线程池表现为线程数会根据任务量不断增长\",{\"1\":{\"574\":1}}],[\"整个事务才算执行成功\",{\"1\":{\"506\":1}}],[\"整个系统只建立一张目录表\",{\"1\":{\"196\":1}}],[\"整型信号量\",{\"1\":{\"171\":1}}],[\"整理自同济子豪兄\",{\"1\":{\"134\":1}}],[\"多例bean不存在线程安全问题\",{\"1\":{\"1506\":1}}],[\"多项\",{\"1\":{\"1459\":2}}],[\"多了一个\",{\"1\":{\"1442\":1}}],[\"多点啥\",{\"1\":{\"1243\":1}}],[\"多字节\",{\"1\":{\"1174\":1}}],[\"多字符分隔符\",{\"1\":{\"372\":1}}],[\"多则几千万\",{\"1\":{\"1114\":1}}],[\"多少m的数据\",{\"1\":{\"1021\":1}}],[\"多少条数据\",{\"1\":{\"1021\":1}}],[\"多少个分区\",{\"1\":{\"1018\":1}}],[\"多少个topic\",{\"1\":{\"1018\":1}}],[\"多用户使用一个客户端会导致权限混淆\",{\"1\":{\"922\":1}}],[\"多出来的数据会被默默抛弃\",{\"1\":{\"848\":1}}],[\"多关注\",{\"1\":{\"843\":1}}],[\"多路复用仅针对网络\",{\"1\":{\"828\":1}}],[\"多路复用\",{\"0\":{\"828\":1},\"1\":{\"851\":2}}],[\"多路归并排序对大文件进行排序的步骤如下\",{\"1\":{\"478\":1}}],[\"多\",{\"1\":{\"792\":1}}],[\"多核\",{\"1\":{\"755\":1}}],[\"多核cpu的场景下\",{\"1\":{\"561\":1}}],[\"多核cpu自旋才能发挥优势\",{\"1\":{\"542\":1}}],[\"多米诺牌的效应就此开始\",{\"1\":{\"666\":1}}],[\"多使用commit\",{\"0\":{\"499\":1}}],[\"多表\",{\"1\":{\"493\":1}}],[\"多表关联查询时\",{\"1\":{\"481\":1}}],[\"多列转多行\",{\"0\":{\"386\":1}}],[\"多行转单列\",{\"0\":{\"383\":1}}],[\"多行转多列\",{\"0\":{\"380\":1}}],[\"多进一出\",{\"1\":{\"334\":1}}],[\"多次提交很可能产生多笔订单\",{\"1\":{\"1004\":1}}],[\"多次提交很可能产生副作用\",{\"1\":{\"1004\":1}}],[\"多次操作会带来性能的损耗\",{\"1\":{\"779\":1}}],[\"多次调用会抛illegalthreadstateexception异常\",{\"1\":{\"532\":1}}],[\"多次插入\",{\"1\":{\"288\":2}}],[\"多次性\",{\"1\":{\"189\":1}}],[\"多分区表\",{\"1\":{\"262\":1}}],[\"多重插入\",{\"0\":{\"288\":1},\"1\":{\"288\":1}}],[\"多重\",{\"1\":{\"262\":1}}],[\"多重分区\",{\"0\":{\"262\":1}}],[\"多层索引\",{\"1\":{\"197\":1}}],[\"多级页表的提出主要是解决下面两个问题\",{\"1\":{\"683\":1}}],[\"多级页表\",{\"1\":{\"683\":1}}],[\"多级页表解决\",{\"1\":{\"683\":1}}],[\"多级目录结构\",{\"1\":{\"196\":1}}],[\"多级索引顺序文件\",{\"1\":{\"195\":1}}],[\"多级反馈队列调度算法\",{\"1\":{\"167\":1}}],[\"多对多模型\",{\"1\":{\"163\":1}}],[\"多对一模型\",{\"1\":{\"163\":1}}],[\"多线程版缺点⚠️\",{\"0\":{\"864\":1}}],[\"多线程版设计\",{\"0\":{\"863\":1}}],[\"多线程和异步所提升的效率并不是所认为的\",{\"1\":{\"755\":1}}],[\"多线程就效率高\",{\"1\":{\"755\":1}}],[\"多线程可以在多核处理机上执行\",{\"1\":{\"163\":1}}],[\"多线程模型\",{\"0\":{\"163\":1}}],[\"多个单词之间用\",{\"1\":{\"1207\":1}}],[\"多个消费者可以消费一个消息\",{\"1\":{\"1010\":1}}],[\"多个表中会生成重复的\",{\"1\":{\"997\":1}}],[\"多个namenode的情况意味着有多个namespace\",{\"1\":{\"889\":1}}],[\"多个channel以事件的形式注册到同一个selector\",{\"1\":{\"610\":1}}],[\"多个线程都能看到相同的结果\",{\"1\":{\"1140\":1}}],[\"多个线程同时读取这个共享变量的值\",{\"1\":{\"560\":1}}],[\"多个线程不可以在多核处理机上并行运行\",{\"1\":{\"163\":1}}],[\"多个读线程的情况\",{\"1\":{\"558\":1}}],[\"多个事务的读操作可以同时进行而不会互相影响\",{\"1\":{\"508\":1}}],[\"多个版本的数据可以共存\",{\"1\":{\"503\":1}}],[\"多个字段distinct整体去重\",{\"1\":{\"303\":1}}],[\"多个字段看成一个整体\",{\"1\":{\"303\":1}}],[\"多个用户共享同一个文件\",{\"1\":{\"200\":1}}],[\"多个用户级线程映射到一个内核级线程\",{\"1\":{\"163\":1}}],[\"多个模块\",{\"1\":{\"181\":1}}],[\"阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题\",{\"1\":{\"1003\":1}}],[\"阻塞等待\",{\"1\":{\"756\":1}}],[\"阻塞直到绑定事件发生\",{\"1\":{\"832\":2}}],[\"阻塞直到事件发生\",{\"1\":{\"743\":1}}],[\"阻塞方法\",{\"1\":{\"826\":2}}],[\"阻塞方法之间相互影响\",{\"1\":{\"826\":1}}],[\"阻塞模式下\",{\"1\":{\"826\":1,\"866\":1}}],[\"阻塞的表现其实就是线程暂停了\",{\"1\":{\"826\":1}}],[\"阻塞的\",{\"1\":{\"742\":1}}],[\"阻塞线程io\",{\"1\":{\"741\":1}}],[\"阻塞了\",{\"1\":{\"741\":1}}],[\"阻塞写操作把处理多个文件描述符的任务饿死\",{\"1\":{\"680\":1}}],[\"阻塞io\",{\"1\":{\"679\":1}}],[\"阻塞i\",{\"1\":{\"679\":2}}],[\"阻塞非阻塞\",{\"1\":{\"675\":1}}],[\"阻塞队列使用的是synchronousqueue\",{\"1\":{\"574\":1}}],[\"阻塞队列是无界的\",{\"1\":{\"574\":1}}],[\"阻塞队列\",{\"1\":{\"572\":1}}],[\"阻塞状态不会\",{\"1\":{\"533\":1}}],[\"阻塞状态\",{\"1\":{\"533\":1,\"538\":3}}],[\"阻塞\",{\"0\":{\"825\":1,\"826\":1},\"1\":{\"163\":1,\"549\":1,\"725\":1,\"741\":1,\"851\":2}}],[\"阻塞态\",{\"1\":{\"160\":1}}],[\"故称为雪花算法\",{\"1\":{\"998\":1}}],[\"故障转移时\",{\"1\":{\"526\":1}}],[\"故障转移\",{\"1\":{\"526\":1}}],[\"故不细加阐述\",{\"1\":{\"1230\":1}}],[\"故不建议在开发代码中使用此语句\",{\"1\":{\"482\":1}}],[\"故不需要\",{\"1\":{\"100\":1}}],[\"故这种策略主要用于进程首次调入\",{\"1\":{\"192\":1}}],[\"故意设计的死循环除外\",{\"1\":{\"175\":1}}],[\"故读进程最多只能有一个\",{\"1\":{\"162\":1}}],[\"写在主机上\",{\"1\":{\"1153\":1}}],[\"写好脚本以后\",{\"1\":{\"1146\":1}}],[\"写权限\",{\"1\":{\"918\":1}}],[\"写流程\",{\"0\":{\"901\":1},\"1\":{\"1051\":1}}],[\"写访问权限来管理存储空间\",{\"1\":{\"888\":1}}],[\"写出剩余内容\",{\"1\":{\"859\":1}}],[\"写出\",{\"1\":{\"854\":1}}],[\"写完了\",{\"1\":{\"843\":1}}],[\"写事件由\",{\"1\":{\"859\":1}}],[\"写事件\",{\"1\":{\"843\":1}}],[\"写事务的id范围\",{\"1\":{\"293\":1}}],[\"写模式下\",{\"1\":{\"798\":1}}],[\"写模式\",{\"1\":{\"796\":1}}],[\"写也不会阻塞读\",{\"1\":{\"795\":1}}],[\"写回结果\",{\"1\":{\"766\":1}}],[\"写回响应\",{\"1\":{\"711\":1}}],[\"写空闲时间过长\",{\"1\":{\"707\":2}}],[\"写过程和普通锁没什么区别\",{\"1\":{\"590\":1}}],[\"写锁可以降级为读锁\",{\"1\":{\"589\":1}}],[\"写锁之间是互斥的\",{\"1\":{\"510\":1}}],[\"写屏障\",{\"1\":{\"567\":1}}],[\"写屏障会确保指令重排序时\",{\"1\":{\"557\":1,\"567\":1}}],[\"写屏障保证该屏障之前的\",{\"1\":{\"557\":1,\"567\":1}}],[\"写不写都一样\",{\"1\":{\"361\":1}}],[\"写\",{\"0\":{\"918\":1},\"1\":{\"294\":1,\"809\":1,\"840\":1,\"1048\":1}}],[\"写了表示客户端路径\",{\"1\":{\"261\":1}}],[\"写指令之后\",{\"1\":{\"209\":1}}],[\"写都需要cpu的帮助\",{\"1\":{\"209\":1}}],[\"写一个java类\",{\"1\":{\"344\":1}}],[\"写一个或多个连续的数据块\",{\"1\":{\"209\":1}}],[\"写一个或多个块\",{\"1\":{\"209\":1}}],[\"写一个字\",{\"1\":{\"209\":2}}],[\"写一个磁道所需的时间刚好又是转一圈所需要的时间r1​\",{\"1\":{\"204\":1}}],[\"写的字节数为b\",{\"1\":{\"204\":1}}],[\"写数据操作\",{\"1\":{\"985\":1}}],[\"写数据时\",{\"1\":{\"827\":1}}],[\"写数据前\",{\"1\":{\"204\":1}}],[\"写数据\",{\"1\":{\"203\":1}}],[\"写数据必须在读数据之前完成\",{\"1\":{\"168\":1}}],[\"写文件\",{\"1\":{\"199\":1}}],[\"写操作完成后\",{\"1\":{\"578\":1}}],[\"写操作在该副本上进行\",{\"1\":{\"578\":1}}],[\"写操作则通过操作操作底层数组的新副本来实现\",{\"1\":{\"578\":1}}],[\"写操作的流程\",{\"1\":{\"209\":3}}],[\"写操作需要的时间\",{\"1\":{\"204\":1}}],[\"写操作\",{\"1\":{\"197\":1,\"209\":3}}],[\"写进程的write\",{\"1\":{\"162\":1}}],[\"写入一条string数据\",{\"1\":{\"1221\":1,\"1223\":1}}],[\"写入到一个\",{\"1\":{\"1177\":1}}],[\"写入redis时\",{\"1\":{\"1223\":1}}],[\"写入redis\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":3,\"1171\":1,\"1175\":1}}],[\"写入磁盘\",{\"1\":{\"979\":1}}],[\"写入加密文件的过程\",{\"0\":{\"934\":1}}],[\"写入的正确姿势如下\",{\"1\":{\"815\":1}}],[\"写入数据会有一个返回结果\",{\"1\":{\"1043\":1}}],[\"写入数据\",{\"0\":{\"802\":1},\"1\":{\"797\":1,\"1223\":1}}],[\"写入消息并清空缓冲区\",{\"1\":{\"785\":1}}],[\"写入字符串\",{\"1\":{\"772\":1}}],[\"写入后\",{\"1\":{\"772\":2}}],[\"写入\",{\"0\":{\"772\":1,\"815\":1},\"1\":{\"772\":12,\"796\":1,\"854\":1}}],[\"写入内容\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"写入文件系统的数据被序列化为文本\",{\"1\":{\"290\":1}}],[\"写入acid表\",{\"1\":{\"267\":1}}],[\"写入tf卡功能\",{\"1\":{\"6\":1}}],[\"写入sd卡功能\",{\"1\":{\"6\":1}}],[\"恢复用户态现场\",{\"1\":{\"676\":1}}],[\"恢复运行环境\",{\"1\":{\"161\":1}}],[\"恢复原进程的cpu环境并退出中断\",{\"1\":{\"157\":1}}],[\"更为极端的误删逻辑说明\",{\"1\":{\"1145\":1}}],[\"更为底层\",{\"1\":{\"850\":1,\"861\":1}}],[\"更是可以做到动静分离\",{\"1\":{\"1094\":1}}],[\"更重要的是\",{\"1\":{\"935\":1}}],[\"更重要的是提升检索速度\",{\"1\":{\"480\":1}}],[\"更方便内部的资源管理\",{\"1\":{\"923\":1}}],[\"更方便使用\",{\"1\":{\"183\":1}}],[\"更少的用户态与内核态的切换\",{\"1\":{\"855\":1}}],[\"更进一步\",{\"0\":{\"845\":1}}],[\"更简洁\",{\"1\":{\"792\":1}}],[\"更节约内存\",{\"1\":{\"781\":1}}],[\"更节省资源\",{\"1\":{\"455\":1}}],[\"更没有移植性\",{\"1\":{\"482\":1}}],[\"更不能是text字段\",{\"1\":{\"480\":1}}],[\"更加方便redis获取数据\",{\"1\":{\"1207\":1}}],[\"更加没有万能的收集器\",{\"1\":{\"638\":1}}],[\"更加严谨\",{\"1\":{\"478\":1}}],[\"更加容易扩展\",{\"1\":{\"29\":1}}],[\"更新数据库\",{\"1\":{\"1122\":1}}],[\"更新数据库时让缓存失效\",{\"1\":{\"1121\":1}}],[\"更新数据表记录时\",{\"1\":{\"483\":1}}],[\"更新缓存\",{\"1\":{\"1121\":1}}],[\"更新和删除的时候\",{\"1\":{\"1061\":1}}],[\"更新\",{\"1\":{\"579\":1}}],[\"更新并获取\",{\"1\":{\"562\":1}}],[\"更新的字段是非索引字段\",{\"1\":{\"493\":1}}],[\"更新索引\",{\"1\":{\"423\":1}}],[\"更新pcb中的信息\",{\"1\":{\"161\":1}}],[\"更改分区位置\",{\"1\":{\"280\":1}}],[\"更改分区文件存储格式\",{\"1\":{\"280\":1}}],[\"更改列名称\",{\"1\":{\"279\":1}}],[\"更改serde属性\",{\"1\":{\"279\":1}}],[\"更改表的存储位置路径\",{\"1\":{\"279\":1}}],[\"更改表的文件存储格式\",{\"1\":{\"279\":1}}],[\"更改表注释\",{\"1\":{\"279\":1}}],[\"更改表属性\",{\"1\":{\"279\":1}}],[\"更改表名\",{\"1\":{\"279\":1}}],[\"更改数据库位置\",{\"1\":{\"278\":1}}],[\"更改数据库所有者\",{\"1\":{\"278\":1}}],[\"更改数据库属性\",{\"1\":{\"278\":1}}],[\"更改视图定义\",{\"1\":{\"271\":1}}],[\"更改视图属性\",{\"1\":{\"271\":1}}],[\"关系型数据库因为表之间存在关联关系\",{\"1\":{\"1189\":1}}],[\"关系型数据库集群模式一般是主从\",{\"1\":{\"1189\":1}}],[\"关系型数据库基于磁盘进行存储\",{\"1\":{\"1189\":1}}],[\"关系运算符返回的都是boolean结果\",{\"1\":{\"330\":1}}],[\"关系运算符\",{\"0\":{\"330\":1},\"1\":{\"328\":1}}],[\"关注的是所有标注\",{\"1\":{\"1455\":1}}],[\"关注推送也叫做feed流\",{\"1\":{\"1166\":1}}],[\"关注是user之间的关系\",{\"1\":{\"1164\":1}}],[\"关注和取关接口\",{\"1\":{\"1164\":1}}],[\"关注和取消关注\",{\"0\":{\"1164\":1}}],[\"关注\",{\"1\":{\"743\":2,\"1164\":2,\"1165\":1,\"1168\":1}}],[\"关注事件\",{\"1\":{\"740\":1}}],[\"关闭hdfs集群\",{\"1\":{\"910\":1,\"936\":1}}],[\"关闭当下\",{\"1\":{\"878\":1}}],[\"关闭\",{\"0\":{\"816\":1},\"1\":{\"752\":2,\"1028\":1}}],[\"关闭了nagle算法\",{\"1\":{\"728\":1}}],[\"关闭发布者\",{\"1\":{\"717\":1,\"718\":1}}],[\"关闭文件\",{\"1\":{\"199\":1}}],[\"关于使用\",{\"0\":{\"1177\":1}}],[\"关于countdownlatch\",{\"1\":{\"1132\":1}}],[\"关于threadlocal\",{\"1\":{\"1100\":1}}],[\"关于缓存文件的路径直接指定文件名称即可\",{\"1\":{\"990\":1}}],[\"关于select\",{\"0\":{\"498\":1}}],[\"关于部分年份的nba总冠军球队名单\",{\"1\":{\"348\":1}}],[\"关联和非关联\",{\"0\":{\"1186\":1}}],[\"关联的用户id\",{\"1\":{\"1164\":1}}],[\"关联的结果直接输出\",{\"1\":{\"448\":1}}],[\"关联不上的显示null返回\",{\"1\":{\"321\":1,\"322\":1}}],[\"关中断指令\",{\"1\":{\"161\":1,\"170\":1}}],[\"关键点在于如下拦截器的编写\",{\"1\":{\"1232\":1}}],[\"关键代码\",{\"0\":{\"1257\":1,\"1413\":1,\"1416\":1,\"1420\":1,\"1424\":1,\"1429\":1,\"1432\":1,\"1435\":1,\"1449\":1,\"1451\":1,\"1464\":1},\"1\":{\"740\":10,\"743\":1,\"749\":1}}],[\"关键在于上面例子里面的订阅关系subscription这个接口\",{\"1\":{\"719\":1}}],[\"关键使用union关键字\",{\"1\":{\"386\":1}}],[\"关键词\",{\"1\":{\"85\":1}}],[\"关键字指定\",{\"1\":{\"426\":1}}],[\"关键字之后的双重检查锁模式是一种比较好的单例实现模式\",{\"1\":{\"66\":1}}],[\"关键字可以保证可见性和有序性\",{\"1\":{\"66\":1}}],[\"关键字\",{\"1\":{\"66\":1,\"361\":1}}],[\"答案是课程中的好\",{\"1\":{\"1155\":1}}],[\"答\",{\"1\":{\"161\":1}}],[\"撤销已有进程\",{\"1\":{\"161\":1}}],[\"撤销pcb\",{\"1\":{\"160\":1}}],[\"撤销进程之前的运行都芜湖了\",{\"1\":{\"178\":1}}],[\"撤销进程法\",{\"1\":{\"178\":1}}],[\"撤销进程\",{\"1\":{\"159\":1}}],[\"除此以外\",{\"1\":{\"1298\":1}}],[\"除此之外还需要引入aspectj依赖\",{\"1\":{\"1137\":1}}],[\"除此之外\",{\"1\":{\"102\":1,\"614\":1,\"1501\":1}}],[\"除非是只有一个副本\",{\"1\":{\"1054\":1}}],[\"除非运行结束\",{\"1\":{\"181\":1}}],[\"除上述情况\",{\"1\":{\"694\":1}}],[\"除数据库层面的保障\",{\"1\":{\"506\":1}}],[\"除了上述核心操作\",{\"1\":{\"1522\":1}}],[\"除了上述四点以外\",{\"1\":{\"1189\":1}}],[\"除了课堂上讲的\",{\"1\":{\"1289\":1}}],[\"除了用\",{\"1\":{\"753\":1}}],[\"除了可以处理\",{\"1\":{\"750\":1}}],[\"除了设计不同类型的结构体\",{\"1\":{\"663\":1}}],[\"除了字符串的末尾之外\",{\"1\":{\"662\":1}}],[\"除了超时机制\",{\"1\":{\"513\":1}}],[\"除了修改buffer\",{\"1\":{\"506\":1}}],[\"除了数据表占数据空间之外\",{\"1\":{\"485\":1}}],[\"除了lazysimpleserde外\",{\"1\":{\"374\":1}}],[\"除了前n个字符\",{\"1\":{\"342\":1}}],[\"除了cpu以外\",{\"1\":{\"160\":1}}],[\"除sql数据类型外\",{\"1\":{\"248\":1}}],[\"除文件的最后一个盘块之外\",{\"1\":{\"197\":1}}],[\"已具备等价功能\",{\"1\":{\"1472\":1}}],[\"已初始化事件3️⃣\",{\"1\":{\"1444\":1}}],[\"已准备事件2️⃣\",{\"1\":{\"1444\":1}}],[\"已点赞过则点赞数\",{\"1\":{\"1161\":1}}],[\"已过期\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"已支付\",{\"1\":{\"1005\":1}}],[\"已存储datanode地址的dfsinputstream连接到文件中第一个块的最近的datanode\",{\"1\":{\"902\":1}}],[\"已有hdfs集群容量已不能满足存储数据的需求\",{\"1\":{\"878\":1}}],[\"已汇报可用数据块数量占整体块数量的百分比阈值\",{\"1\":{\"870\":1}}],[\"已废弃\",{\"1\":{\"792\":1}}],[\"已完成了它的使命\",{\"1\":{\"775\":1}}],[\"已退出群\",{\"1\":{\"704\":1}}],[\"已发送的数据都收到\",{\"1\":{\"694\":1}}],[\"已调入内存\",{\"1\":{\"688\":1}}],[\"已经配置了\",{\"1\":{\"1462\":1}}],[\"已经不够了\",{\"1\":{\"773\":1}}],[\"已经读取过的部分\",{\"1\":{\"771\":1}}],[\"已经\",{\"1\":{\"707\":1}}],[\"已经异常断开\",{\"1\":{\"705\":1}}],[\"已经断开\",{\"1\":{\"705\":1}}],[\"已经存在\",{\"1\":{\"704\":1}}],[\"已经为\",{\"1\":{\"662\":1}}],[\"已经是最后的节点了\",{\"1\":{\"579\":1}}],[\"已经知道文件的起始地址\",{\"1\":{\"195\":1}}],[\"已经具备运行条件\",{\"1\":{\"160\":1}}],[\"已提供依赖范围\",{\"1\":{\"100\":1}}],[\"单元测试和集成测试变得更简单\",{\"1\":{\"1499\":1}}],[\"单元测试\",{\"1\":{\"1213\":1}}],[\"单体系统\",{\"1\":{\"1121\":1}}],[\"单位也是分钟\",{\"1\":{\"910\":1}}],[\"单位时间内能够处理请求的数量\",{\"1\":{\"755\":1}}],[\"单位时间内完成的作业的数量\",{\"1\":{\"166\":1}}],[\"单个hll的内存永远小于16kb\",{\"1\":{\"1179\":1}}],[\"单个namenode的吞吐量决定了集群的性能\",{\"1\":{\"888\":1}}],[\"单个进程所能打开的最大连接数由fd\",{\"1\":{\"680\":1}}],[\"单从字面意思不好理解\",{\"1\":{\"862\":1}}],[\"单线程配一个选择器\",{\"1\":{\"846\":1}}],[\"单线程可以配合\",{\"1\":{\"828\":1}}],[\"单线程\",{\"1\":{\"826\":1,\"827\":1,\"1190\":1}}],[\"单线程下\",{\"1\":{\"826\":1}}],[\"单线程没法异步提高效率\",{\"1\":{\"755\":1}}],[\"单聊\",{\"0\":{\"703\":1},\"1\":{\"703\":1,\"712\":1}}],[\"单点登录\",{\"1\":{\"1532\":1}}],[\"单点故障\",{\"1\":{\"882\":1}}],[\"单点修改\",{\"1\":{\"673\":1}}],[\"单点更新\",{\"0\":{\"673\":1}}],[\"单核cpu自选就是浪费\",{\"1\":{\"542\":1}}],[\"单核cp每次最多处理一个进程\",{\"1\":{\"160\":1}}],[\"单节点理论支持最高并发量为10万\",{\"1\":{\"526\":1}}],[\"单调递增是希望插入时不影响数据库性能\",{\"1\":{\"502\":1}}],[\"单列索引和联合索引\",{\"1\":{\"492\":1}}],[\"单列转多行\",{\"0\":{\"389\":1}}],[\"单表中最多只有一个匹配行\",{\"1\":{\"481\":1}}],[\"单表行数超过500万行或者单表容量超过2gb\",{\"1\":{\"480\":1}}],[\"单表时自增\",{\"1\":{\"480\":1}}],[\"单词小的输入文件流放在堆顶\",{\"1\":{\"478\":1}}],[\"单独使用\",{\"1\":{\"396\":1}}],[\"单独启动\",{\"1\":{\"241\":1}}],[\"单缓冲\",{\"1\":{\"214\":1}}],[\"单级目录结构\",{\"1\":{\"196\":1}}],[\"单级页表的问题\",{\"1\":{\"186\":1}}],[\"单任务的操作系统中\",{\"1\":{\"182\":1}}],[\"单一连续分配方式\",{\"1\":{\"182\":1}}],[\"单标志法\",{\"1\":{\"169\":1}}],[\"单例bean存在线程安全问题\",{\"1\":{\"1506\":1}}],[\"单例bean的线程安全问题了解吗\",{\"0\":{\"1506\":1}}],[\"单例bean\",{\"1\":{\"1504\":1}}],[\"单例的产品不会存储于\",{\"1\":{\"1472\":1}}],[\"单例的生命周期和应用程序是一样长的\",{\"1\":{\"636\":1}}],[\"单例注入其它\",{\"1\":{\"1297\":1}}],[\"单例对象\",{\"1\":{\"636\":1}}],[\"单例设计模式分类两种\",{\"1\":{\"66\":1}}],[\"单例类\",{\"1\":{\"65\":1}}],[\"单例模式的实现\",{\"0\":{\"66\":1}}],[\"单例模式的主要有以下角色\",{\"1\":{\"65\":1}}],[\"单例模式的结构\",{\"0\":{\"65\":1}}],[\"单例模式的应用场景\",{\"1\":{\"22\":1}}],[\"单例模式\",{\"0\":{\"22\":1,\"64\":1},\"1\":{\"64\":1}}],[\"应当落在\",{\"1\":{\"1177\":1}}],[\"应当是泛指教师应当得到的报酬\",{\"1\":{\"709\":1}}],[\"应设计好数据文件中的字段\",{\"1\":{\"285\":1}}],[\"应该就安装成功了\",{\"1\":{\"1193\":1}}],[\"应该把给该笔记点赞的人显示出来\",{\"1\":{\"1162\":1}}],[\"应该具体操作缓存还是操作数据库\",{\"1\":{\"1121\":1}}],[\"应该加在后面\",{\"1\":{\"668\":1}}],[\"应该要把设置的key\",{\"1\":{\"577\":1}}],[\"应该替换成where子句\",{\"1\":{\"504\":1}}],[\"应该将坏块标记出来\",{\"1\":{\"206\":1}}],[\"应该优先淘汰没有修改过的页面\",{\"1\":{\"191\":1}}],[\"应该选择哪个分区进行分配\",{\"1\":{\"182\":1}}],[\"应该换出哪些进程\",{\"1\":{\"181\":1}}],[\"应该在外存\",{\"1\":{\"181\":1}}],[\"应该采取适当的方式将这些pcb组织起来\",{\"1\":{\"159\":1}}],[\"应立即释放处理机\",{\"1\":{\"168\":1}}],[\"应保证能在有限时间内进入临界区\",{\"1\":{\"168\":1}}],[\"应用可以直接使用aop的功能\",{\"1\":{\"1510\":1}}],[\"应用2\",{\"1\":{\"1447\":1}}],[\"应用1\",{\"1\":{\"1447\":1}}],[\"应用类型推断\",{\"1\":{\"1446\":1}}],[\"应用层缓存\",{\"1\":{\"1115\":1}}],[\"应用层\",{\"1\":{\"694\":2}}],[\"应用\",{\"1\":{\"591\":1}}],[\"应用的是装饰器模式\",{\"1\":{\"574\":1}}],[\"应用操作\",{\"1\":{\"438\":1}}],[\"应用程序值得是servletcontext\",{\"1\":{\"1504\":1}}],[\"应用程序销毁时bean销毁\",{\"1\":{\"1504\":1}}],[\"应用程序启动时bean创建\",{\"1\":{\"1504\":1}}],[\"应用程序运行完成后\",{\"1\":{\"953\":1}}],[\"应用程序管理器\",{\"1\":{\"945\":1}}],[\"应用程序内的\",{\"1\":{\"944\":1}}],[\"应用程序线程阻塞\",{\"1\":{\"707\":1}}],[\"应用程序在运行之前没有必要将之全部装入内存\",{\"1\":{\"688\":1}}],[\"应用程序必须立即处理该事件\",{\"1\":{\"680\":1}}],[\"应用程序可以不立即处理该事件下次调用epoll\",{\"1\":{\"680\":1}}],[\"应用程序可以发出系统调用请求来获得操作系统的服务\",{\"1\":{\"158\":1}}],[\"应用程序通过系统调用请求操作系统的服务\",{\"1\":{\"158\":1}}],[\"应用程序\",{\"1\":{\"156\":1}}],[\"应用场景不同\",{\"1\":{\"10\":1}}],[\"应用场景\",{\"0\":{\"8\":1},\"1\":{\"102\":1,\"448\":1,\"449\":1,\"450\":1,\"515\":5}}],[\"凡是与资源有关的操作\",{\"1\":{\"158\":1}}],[\"→\",{\"1\":{\"157\":2}}],[\"开机自启\",{\"0\":{\"1197\":1},\"1\":{\"1194\":1}}],[\"开机时计算机先运行\",{\"1\":{\"206\":1}}],[\"开机时文件分配表放入内存\",{\"1\":{\"197\":1}}],[\"开源的消息队列\",{\"1\":{\"791\":1}}],[\"开发拦截器\",{\"1\":{\"1532\":1}}],[\"开发的一种网络身份认证协议\",{\"1\":{\"923\":1}}],[\"开发中的地位\",{\"1\":{\"791\":1}}],[\"开发一个简单的服务器端和客户端\",{\"1\":{\"783\":1}}],[\"开头\",{\"1\":{\"1437\":1}}],[\"开头的\",{\"1\":{\"1421\":1}}],[\"开头的一系列方法\",{\"1\":{\"772\":1,\"774\":1}}],[\"开头并不能命中\",{\"1\":{\"495\":1}}],[\"开始抢购时间\",{\"1\":{\"1133\":1}}],[\"开始时间戳\",{\"1\":{\"1132\":1}}],[\"开始顺序读取\",{\"1\":{\"1052\":1}}],[\"开始\",{\"1\":{\"1042\":1,\"1167\":1}}],[\"开始计算\",{\"1\":{\"759\":1}}],[\"开始不停的监控\",{\"1\":{\"536\":1}}],[\"开区间\",{\"1\":{\"511\":1}}],[\"开启线程任务\",{\"1\":{\"1156\":1}}],[\"开启缓存重建\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"开启独立线程\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"开启mysql\",{\"1\":{\"1046\":1}}],[\"开启map端聚合\",{\"0\":{\"464\":1}}],[\"开启mapreduce最终输出数据压缩\",{\"1\":{\"433\":1}}],[\"开启mapreduce中map输出压缩功能\",{\"1\":{\"433\":1}}],[\"开启行号\",{\"1\":{\"1046\":1}}],[\"开启\",{\"0\":{\"1045\":1}}],[\"开启两个客户端\",{\"1\":{\"836\":1}}],[\"开启了nagle算法\",{\"1\":{\"728\":1}}],[\"开启运行过程中skewjoin\",{\"1\":{\"470\":1}}],[\"开启该参数以后\",{\"1\":{\"466\":1}}],[\"开启stage并行化\",{\"1\":{\"446\":1}}],[\"开启并行执行\",{\"1\":{\"446\":1}}],[\"开启本地模式\",{\"1\":{\"444\":1}}],[\"开启矢量化查询\",{\"1\":{\"438\":1}}],[\"开启索引配置\",{\"1\":{\"437\":1}}],[\"开启hive最终输出数据压缩功能\",{\"1\":{\"433\":1}}],[\"开启hive中间传输数据压缩功能\",{\"1\":{\"433\":2}}],[\"开启reduce输出阶段压缩\",{\"1\":{\"433\":1}}],[\"开启参数\",{\"1\":{\"268\":1,\"298\":1,\"459\":1,\"1028\":1}}],[\"开启事务配置\",{\"1\":{\"268\":1}}],[\"开启分桶功能\",{\"1\":{\"266\":1}}],[\"开关中断权限比较大\",{\"1\":{\"170\":1}}],[\"开关中断权限非常大\",{\"1\":{\"161\":1}}],[\"开\",{\"1\":{\"170\":1}}],[\"开销大\",{\"1\":{\"163\":1,\"191\":1}}],[\"开中断指令\",{\"1\":{\"161\":1}}],[\"开展管理工作\",{\"1\":{\"157\":1}}],[\"开闭原则\",{\"0\":{\"72\":1},\"1\":{\"29\":1,\"86\":1}}],[\"普通类\",{\"1\":{\"1366\":1}}],[\"普通字符串\",{\"1\":{\"1206\":1}}],[\"普通用户\",{\"1\":{\"923\":1}}],[\"普通文件\",{\"1\":{\"828\":1}}],[\"普通索引三种\",{\"1\":{\"481\":1}}],[\"普通索引名则为idx字段名\",{\"1\":{\"480\":1}}],[\"普通表结构问题\",{\"0\":{\"414\":1}}],[\"普通聚合\",{\"1\":{\"357\":1}}],[\"普通函数\",{\"1\":{\"334\":1}}],[\"普通应用程序只能执行非特权指令\",{\"1\":{\"156\":1}}],[\"普通的运算指令\",{\"1\":{\"156\":1}}],[\"管程中定义的数据结构\",{\"1\":{\"173\":1}}],[\"管程有一个名字\",{\"1\":{\"173\":1}}],[\"管程的基本特征\",{\"1\":{\"173\":1}}],[\"管程的组成\",{\"1\":{\"173\":1}}],[\"管程的定义和基本特征\",{\"1\":{\"173\":1}}],[\"管程作用\",{\"1\":{\"173\":1}}],[\"管程\",{\"0\":{\"173\":1}}],[\"管道\",{\"1\":{\"610\":1}}],[\"管道变空\",{\"1\":{\"162\":1}}],[\"管道只能采用半双工通信\",{\"1\":{\"162\":1}}],[\"管道通信中\",{\"1\":{\"168\":1}}],[\"管道通信\",{\"1\":{\"162\":1}}],[\"管态\",{\"1\":{\"156\":1}}],[\"管理的本质\",{\"1\":{\"1280\":1}}],[\"管理的\",{\"1\":{\"1252\":1}}],[\"管理员\",{\"1\":{\"949\":1}}],[\"管理员以某个时刻的snapshot作为备份的起始结点\",{\"1\":{\"912\":1}}],[\"管理各个机器上的计算资源\",{\"1\":{\"944\":1}}],[\"管理自己的区域\",{\"1\":{\"889\":1}}],[\"管理多个job\",{\"1\":{\"991\":1}}],[\"管理多个\",{\"1\":{\"840\":1}}],[\"管理多个子项目\",{\"1\":{\"108\":1}}],[\"管理一个\",{\"1\":{\"779\":1}}],[\"管理\",{\"1\":{\"737\":1,\"1455\":2,\"1465\":1,\"1466\":1}}],[\"管理上述3种资源种的内部花费\",{\"1\":{\"499\":1}}],[\"管理jar\",{\"1\":{\"91\":1}}],[\"特殊处理\",{\"1\":{\"1376\":1}}],[\"特有语法\",{\"1\":{\"1298\":1}}],[\"特征也与linkedlist类似\",{\"1\":{\"1209\":1}}],[\"特征\",{\"1\":{\"1190\":1}}],[\"特征或者客体之间关系的词项\",{\"1\":{\"459\":1}}],[\"特性\",{\"1\":{\"1147\":1}}],[\"特价卷除了具有优惠卷的基本信息以外\",{\"1\":{\"1133\":1}}],[\"特价优惠券才需要填写这些信息\",{\"1\":{\"1133\":1}}],[\"特别是自动化运维方面会有较大影响\",{\"1\":{\"924\":1}}],[\"特别是删除\",{\"1\":{\"482\":1}}],[\"特别时主从切换的瞬间存在访问瞬断的情况\",{\"1\":{\"526\":1}}],[\"特点就是先由操作系统完成后才通知服务端程序启动线程去处理\",{\"1\":{\"611\":1}}],[\"特点是每次只能返回json对象中一列的值\",{\"1\":{\"395\":1}}],[\"特点\",{\"1\":{\"165\":2,\"179\":2,\"181\":1,\"182\":3,\"574\":2}}],[\"特权指令和非特权指令都可执行\",{\"1\":{\"156\":1}}],[\"特权指令\",{\"1\":{\"156\":1}}],[\"特发此状\",{\"1\":{\"52\":1,\"54\":1}}],[\"才是\",{\"1\":{\"1176\":1}}],[\"才是对数据条件的过滤\",{\"1\":{\"493\":1}}],[\"才释放锁\",{\"1\":{\"1126\":1}}],[\"才修复\",{\"1\":{\"847\":1}}],[\"才将\",{\"1\":{\"843\":1}}],[\"才推荐进行分库分表\",{\"1\":{\"480\":1}}],[\"才可以实现高效的双向通信\",{\"1\":{\"795\":1}}],[\"才可以只装入部分程序到内存就开始运行\",{\"1\":{\"686\":1}}],[\"才可以使用事务功能\",{\"1\":{\"267\":1}}],[\"才可能导致异步性\",{\"1\":{\"155\":1}}],[\"才需要关注写事件\",{\"1\":{\"843\":1}}],[\"才需要cpu的干预\",{\"1\":{\"209\":1}}],[\"才需要写回外存\",{\"1\":{\"191\":1}}],[\"才对他进行连接\",{\"1\":{\"179\":1}}],[\"才有资格申请更大编号的资源\",{\"1\":{\"176\":1}}],[\"才会关心\",{\"1\":{\"831\":1}}],[\"才会返回\",{\"1\":{\"701\":1}}],[\"才会进行读写\",{\"1\":{\"610\":1}}],[\"才会将任务放入该阻塞队列中\",{\"1\":{\"574\":1}}],[\"才会采用主键索引来进行统计\",{\"1\":{\"497\":1}}],[\"才会放入页表寄存器\",{\"1\":{\"185\":1}}],[\"才会修改turn\",{\"1\":{\"169\":1}}],[\"才会为k\",{\"1\":{\"167\":1}}],[\"才能操作\",{\"1\":{\"1135\":1}}],[\"才能进行查询\",{\"1\":{\"1127\":1}}],[\"才能得到结果\",{\"1\":{\"756\":1}}],[\"才能得到cpu的服务\",{\"1\":{\"160\":1}}],[\"才能发挥异步的优势\",{\"1\":{\"755\":1}}],[\"才能看下一个病人\",{\"1\":{\"755\":1}}],[\"才能执行\",{\"1\":{\"741\":1}}],[\"才能开始游戏\",{\"1\":{\"592\":1}}],[\"才能实现不合并\",{\"1\":{\"470\":1}}],[\"才能方便cpu操作\",{\"1\":{\"208\":1}}],[\"才能被cpu处理\",{\"1\":{\"154\":1}}],[\"空的\",{\"1\":{\"1244\":1}}],[\"空\",{\"1\":{\"1244\":1}}],[\"空轮询导致\",{\"1\":{\"792\":1}}],[\"空轮询\",{\"1\":{\"742\":1}}],[\"空间扩展操作也就是重新分配内存\",{\"1\":{\"667\":1}}],[\"空间够的话\",{\"1\":{\"663\":1}}],[\"空间之前\",{\"1\":{\"663\":1}}],[\"空间优化\",{\"1\":{\"648\":1}}],[\"空间局部性通常是使用较大的高速缓存\",{\"1\":{\"687\":1}}],[\"空间局部性\",{\"1\":{\"189\":1,\"687\":1}}],[\"空时不会再消耗数据\",{\"1\":{\"548\":1}}],[\"空值转换函数\",{\"1\":{\"340\":2}}],[\"空判断函数\",{\"1\":{\"340\":2}}],[\"空格字符串函数\",{\"1\":{\"336\":2}}],[\"空闲检测\",{\"0\":{\"706\":1}}],[\"空闲列表\",{\"1\":{\"630\":1}}],[\"空闲\",{\"1\":{\"574\":1}}],[\"空闲时生存时间为60秒\",{\"1\":{\"574\":1}}],[\"空闲盘区链\",{\"1\":{\"198\":1}}],[\"空闲盘块链\",{\"1\":{\"198\":1}}],[\"空闲链表法\",{\"1\":{\"198\":1}}],[\"空闲表法\",{\"1\":{\"198\":1}}],[\"空闲分区按照容量递减的次序链接\",{\"1\":{\"183\":1}}],[\"空闲分区按照容量递增次序链接\",{\"1\":{\"183\":1}}],[\"空闲分区以地址递增的次序排列\",{\"1\":{\"183\":2}}],[\"空闲分区链\",{\"1\":{\"182\":1}}],[\"空闲分区表\",{\"1\":{\"182\":1}}],[\"空闲让进\",{\"1\":{\"168\":1}}],[\"空分复用技术\",{\"1\":{\"155\":1}}],[\"空调等\",{\"1\":{\"41\":1}}],[\"互不干扰\",{\"1\":{\"1514\":1}}],[\"互不影响\",{\"1\":{\"979\":1}}],[\"互转\",{\"0\":{\"805\":1}}],[\"互补\",{\"1\":{\"616\":1}}],[\"互相改变对方的结束条件\",{\"1\":{\"552\":1}}],[\"互相协同工作\",{\"1\":{\"526\":1}}],[\"互相不阻塞\",{\"1\":{\"508\":1}}],[\"互斥是分布式锁的最基本的条件\",{\"1\":{\"1140\":1}}],[\"互斥模式下使用\",{\"1\":{\"585\":2}}],[\"互斥锁实现缓存重建\",{\"1\":{\"1127\":1}}],[\"互斥锁方案\",{\"1\":{\"1126\":1}}],[\"互斥锁是一种独占锁\",{\"1\":{\"582\":1}}],[\"互斥锁+共享锁\",{\"1\":{\"582\":1}}],[\"互斥锁\",{\"1\":{\"582\":1,\"1126\":1}}],[\"互斥条件\",{\"1\":{\"175\":1,\"551\":1}}],[\"互斥\",{\"1\":{\"168\":1,\"1140\":2,\"1141\":1}}],[\"互斥共享方式\",{\"1\":{\"155\":1}}],[\"互斥共享方式和同时共享方式\",{\"1\":{\"155\":1}}],[\"互为存在的条件\",{\"1\":{\"155\":1}}],[\"发射调用目标方法\",{\"1\":{\"1309\":1}}],[\"发起了一个数据库不存在的\",{\"1\":{\"1177\":1}}],[\"发起了调用\",{\"1\":{\"753\":1}}],[\"发起请求只是给数据库\",{\"1\":{\"1161\":1}}],[\"发出\",{\"1\":{\"785\":1}}],[\"发完即关\",{\"1\":{\"696\":1}}],[\"发一个包建立一次连接\",{\"1\":{\"695\":1}}],[\"发现没有环绕通知\",{\"1\":{\"1340\":1}}],[\"发现有下一个环绕通知\",{\"1\":{\"1340\":2}}],[\"发现它们是同一个对象\",{\"1\":{\"1294\":1}}],[\"发现在dao层方法接口的参数中不用\",{\"1\":{\"1229\":1}}],[\"发现这个数量一定也大于1\",{\"1\":{\"1135\":1}}],[\"发现\",{\"1\":{\"567\":1}}],[\"发现其方法最后是调用string\",{\"1\":{\"566\":1}}],[\"发生异常时\",{\"1\":{\"1411\":1}}],[\"发生\",{\"1\":{\"1038\":1,\"1042\":1}}],[\"发生变化\",{\"1\":{\"1037\":1}}],[\"发生故障时\",{\"1\":{\"1026\":1}}],[\"发生时\",{\"1\":{\"833\":1}}],[\"发生成功消息\",{\"1\":{\"704\":1}}],[\"发生在多线程数组扩容的的情况下\",{\"1\":{\"607\":1}}],[\"发生了变化\",{\"1\":{\"1037\":1}}],[\"发生了读写就绪事件\",{\"1\":{\"867\":1}}],[\"发生了事件\",{\"1\":{\"832\":1}}],[\"发生了一些没有预知的异常\",{\"1\":{\"676\":1}}],[\"发生了索引列的隐式转换\",{\"1\":{\"505\":1}}],[\"发生了中断\",{\"1\":{\"157\":1}}],[\"发生缺页时只能选进程自己的物理块进行置换\",{\"1\":{\"192\":1}}],[\"发生死锁时\",{\"1\":{\"551\":1}}],[\"发生死锁的必要条件\",{\"1\":{\"551\":1}}],[\"发生死锁的时候一定有循环等待\",{\"1\":{\"175\":1}}],[\"发生死锁的进程一定是在阻塞态\",{\"1\":{\"175\":1}}],[\"发生死锁后\",{\"1\":{\"175\":1}}],[\"发生死锁至少有两个或两个以上的进程同时发生死锁\",{\"1\":{\"175\":1}}],[\"发送验证码\",{\"1\":{\"1098\":1,\"1099\":2}}],[\"发送到指定主题分区的消息都对应一个从0开始递增的sequence\",{\"1\":{\"1029\":1}}],[\"发送到reduce\",{\"1\":{\"974\":1}}],[\"发送邮件\",{\"1\":{\"1009\":1}}],[\"发送短信验证码成功\",{\"1\":{\"1099\":1}}],[\"发送短信验证码\",{\"1\":{\"1009\":1}}],[\"发送数据不会管\",{\"1\":{\"848\":1}}],[\"发送数据时\",{\"1\":{\"844\":1}}],[\"发送缓冲区和接受缓冲区\",{\"1\":{\"729\":1}}],[\"发送信息方式如下\",{\"1\":{\"709\":1}}],[\"发送一个心跳包\",{\"1\":{\"707\":1}}],[\"发送拉群消息\",{\"1\":{\"704\":1}}],[\"发送内容随机的数据包\",{\"1\":{\"697\":1}}],[\"发送方的报文大小是\",{\"1\":{\"694\":1}}],[\"发送\",{\"1\":{\"694\":2,\"726\":1}}],[\"发送消息\",{\"1\":{\"162\":1,\"702\":1}}],[\"发送文件\",{\"1\":{\"155\":1}}],[\"发布前先通过\",{\"1\":{\"1497\":1}}],[\"发布事件\",{\"1\":{\"1497\":1}}],[\"发布探店笔记\",{\"0\":{\"1159\":1},\"1\":{\"1159\":1}}],[\"发布订阅\",{\"1\":{\"1010\":1}}],[\"发布出去\",{\"1\":{\"718\":1}}],[\"发布的数据类型是integer\",{\"1\":{\"717\":1,\"718\":1}}],[\"发布者就会被阻塞\",{\"1\":{\"719\":1}}],[\"发布者就会停\",{\"1\":{\"719\":1}}],[\"发布者调用submit方法发布数据就会被阻塞\",{\"1\":{\"719\":1}}],[\"发布者和处理器之间建立订阅关系\",{\"1\":{\"718\":1}}],[\"发布者订阅者之间建立订阅关系\",{\"1\":{\"717\":1}}],[\"发布者关闭了\",{\"1\":{\"717\":1,\"718\":2}}],[\"发布者\",{\"1\":{\"716\":1}}],[\"发布\",{\"0\":{\"44\":1},\"1\":{\"45\":1,\"1444\":7}}],[\"微服务形式的\",{\"1\":{\"997\":1}}],[\"微观上可能是交替访问\",{\"1\":{\"155\":1}}],[\"微波炉\",{\"1\":{\"147\":1}}],[\"允许在该类中使用\",{\"1\":{\"1525\":1}}],[\"允许访问的地址\",{\"1\":{\"1196\":1}}],[\"允许访问的部分应该隔离出来可以访问\",{\"1\":{\"187\":1}}],[\"允许存储地理坐标信息\",{\"1\":{\"1170\":1}}],[\"允许你在分片之上进行分布式的\",{\"1\":{\"1066\":1}}],[\"允许你水平分割\",{\"1\":{\"1066\":1}}],[\"允许创建对象实例\",{\"1\":{\"974\":1}}],[\"允许哪些机器加入到当前的hdfs集群中\",{\"1\":{\"880\":1}}],[\"允许hdfs群集中的文件和目录具有不同的复制和纠删码策略\",{\"1\":{\"875\":1}}],[\"允许多个stage并行执行\",{\"1\":{\"446\":1}}],[\"允许多个程序并发执行\",{\"1\":{\"155\":1}}],[\"允许程序不提交给yarn\",{\"1\":{\"444\":1}}],[\"允许使用复杂的联接表达式\",{\"1\":{\"326\":1}}],[\"允许一个作业分多次调入内存\",{\"1\":{\"189\":1}}],[\"允许一个时间段内由多个进程同时对他们进行访问\",{\"1\":{\"155\":1}}],[\"允许死锁的产生\",{\"1\":{\"175\":1}}],[\"允许用户为字段构建索引\",{\"1\":{\"420\":1}}],[\"允许用户通过程序间接使用\",{\"1\":{\"154\":1}}],[\"允许用户直接使用\",{\"1\":{\"154\":1}}],[\"摄像头\",{\"1\":{\"155\":1}}],[\"虚拟主机\",{\"1\":{\"1447\":1}}],[\"虚拟地址空间\",{\"1\":{\"689\":1}}],[\"虚拟地址空间大\",{\"1\":{\"683\":1}}],[\"虚拟地址到物理地址的转换要快\",{\"1\":{\"683\":1}}],[\"虚拟存储器地实现\",{\"1\":{\"689\":1}}],[\"虚拟存储器允许将一个作业分多次调入内存\",{\"1\":{\"689\":1}}],[\"虚拟存储器的实现方法\",{\"0\":{\"689\":1}}],[\"虚拟存储器\",{\"0\":{\"688\":1}}],[\"虚拟存储空间\",{\"1\":{\"676\":1}}],[\"虚拟存储技术\",{\"1\":{\"180\":1}}],[\"虚拟设备\",{\"1\":{\"213\":1}}],[\"虚拟性\",{\"1\":{\"189\":1}}],[\"虚拟内存类似于时间换空间\",{\"1\":{\"688\":1}}],[\"虚拟内存技术实际上就是建立了\",{\"1\":{\"687\":1}}],[\"虚拟内存技术\",{\"1\":{\"189\":1}}],[\"虚拟内存的实现有以下三种方式\",{\"1\":{\"689\":1}}],[\"虚拟内存的实现需要建立在离散分配的内存管理方式的基础上\",{\"1\":{\"189\":1}}],[\"虚拟内存的三个主要特征\",{\"1\":{\"189\":1}}],[\"虚拟内存的概念\",{\"0\":{\"189\":1}}],[\"虚拟内存实际的物理内存大小没有变\",{\"1\":{\"189\":1}}],[\"虚拟内存\",{\"0\":{\"688\":1},\"1\":{\"189\":1,\"685\":1}}],[\"虚拟处理器\",{\"1\":{\"155\":1}}],[\"虚拟技术分为\",{\"1\":{\"155\":1}}],[\"虚拟\",{\"1\":{\"155\":2}}],[\"虚拟机遇到一条new指令\",{\"1\":{\"630\":1}}],[\"虚拟机试图使用的最大内存量\",{\"1\":{\"70\":1}}],[\"虚拟机中的内存总量\",{\"1\":{\"70\":1}}],[\"虚拟机加载singletonholder\",{\"1\":{\"66\":1}}],[\"又支持如下数据源\",{\"1\":{\"1454\":1}}],[\"又提供了一个\",{\"1\":{\"1411\":1}}],[\"又用了一大堆\",{\"1\":{\"1321\":1}}],[\"又可以分为3类\",{\"1\":{\"1206\":1}}],[\"又可以分为定长记录和可变长记录\",{\"1\":{\"195\":1}}],[\"又能保证他的原子性\",{\"1\":{\"1146\":1}}],[\"又能够将以往的经验沉淀下来\",{\"1\":{\"107\":1}}],[\"又有很多操作是要去操作数据库的\",{\"1\":{\"1155\":1}}],[\"又有两个线程\",{\"1\":{\"1138\":1}}],[\"又有排序\",{\"1\":{\"314\":1}}],[\"又不具备\",{\"1\":{\"854\":1}}],[\"又读了一个字节\",{\"1\":{\"776\":1}}],[\"又对\",{\"1\":{\"756\":1}}],[\"又回到了熟悉的\",{\"1\":{\"743\":1}}],[\"又推动了第三张牌倒下\",{\"1\":{\"666\":1}}],[\"又会走上面的静态资源处理流程\",{\"1\":{\"1436\":1}}],[\"又会引发对\",{\"1\":{\"666\":1}}],[\"又会导致多道程序并发度下降\",{\"1\":{\"192\":1}}],[\"又增加了2种策略\",{\"1\":{\"522\":1}}],[\"又称中介数据\",{\"1\":{\"238\":1}}],[\"又称设备无关性软件\",{\"1\":{\"210\":1}}],[\"又称树形目录结构\",{\"1\":{\"196\":1}}],[\"又称\",{\"1\":{\"195\":1,\"212\":1}}],[\"又称clock算法\",{\"1\":{\"191\":1}}],[\"又称限长寄存器\",{\"1\":{\"180\":1}}],[\"又称为外连接\",{\"1\":{\"323\":1}}],[\"又称为右外连接\",{\"1\":{\"322\":1}}],[\"又称为左外连接\",{\"1\":{\"321\":1}}],[\"又称为\",{\"1\":{\"195\":1}}],[\"又称为基址寄存器\",{\"1\":{\"180\":1}}],[\"又称为动态运行时装入\",{\"1\":{\"179\":1}}],[\"又称为虚拟机\",{\"1\":{\"154\":1}}],[\"又称可重定位装入\",{\"1\":{\"179\":1}}],[\"又称抢占方式\",{\"1\":{\"165\":1}}],[\"又称非抢占方式\",{\"1\":{\"165\":1}}],[\"存入redis\",{\"1\":{\"1223\":1}}],[\"存入一个0或1\",{\"1\":{\"1174\":1}}],[\"存入同一个\",{\"1\":{\"1171\":1}}],[\"存入\",{\"1\":{\"1156\":1}}],[\"存入数据\",{\"1\":{\"815\":1,\"1213\":1}}],[\"存击穿问题\",{\"1\":{\"1129\":1}}],[\"存放在\",{\"1\":{\"663\":1}}],[\"存放在布隆过滤器的数据不容易删除\",{\"1\":{\"658\":1}}],[\"存放页表的起始地址\",{\"1\":{\"185\":1}}],[\"存放进程的上\",{\"1\":{\"180\":1}}],[\"存放起始地址\",{\"1\":{\"179\":1}}],[\"存放的位置都由进程控制\",{\"1\":{\"162\":1}}],[\"存在误判\",{\"1\":{\"1123\":1}}],[\"存在误判可能\",{\"1\":{\"1123\":1}}],[\"存在\",{\"1\":{\"1100\":1,\"1101\":1,\"1111\":1,\"1129\":2,\"1156\":1,\"1476\":1}}],[\"存在自增id回溯的问题\",{\"1\":{\"501\":1}}],[\"存在数据库更新风暴的风险\",{\"1\":{\"482\":1}}],[\"存在非等号和等号混合判断条件时\",{\"1\":{\"481\":1}}],[\"存在精度损失问题\",{\"1\":{\"480\":1}}],[\"存在问题\",{\"0\":{\"477\":1},\"1\":{\"1137\":1}}],[\"存在一种进程资源的循环等待链\",{\"1\":{\"175\":1}}],[\"存在的问题\",{\"0\":{\"67\":1},\"1\":{\"922\":1}}],[\"存储在不同机器上\",{\"1\":{\"1189\":1}}],[\"存储方式\",{\"1\":{\"1189\":1}}],[\"存储的data\",{\"1\":{\"1129\":1}}],[\"存储的value\",{\"1\":{\"1129\":1}}],[\"存储的key\",{\"1\":{\"1129\":2}}],[\"存储的索引内容不同\",{\"1\":{\"423\":1}}],[\"存储于本地代码\",{\"1\":{\"1113\":1}}],[\"存储密钥\",{\"1\":{\"932\":1}}],[\"存储数据\",{\"1\":{\"886\":1}}],[\"存储\",{\"1\":{\"740\":1,\"1107\":1}}],[\"存储parent\",{\"1\":{\"579\":1}}],[\"存储root和first\",{\"1\":{\"579\":1}}],[\"存储过程难以调试和扩展\",{\"1\":{\"482\":1}}],[\"存储优化\",{\"0\":{\"434\":1}}],[\"存储形式为按行存储\",{\"1\":{\"427\":1}}],[\"存储为orc\",{\"1\":{\"268\":1}}],[\"存储空间管理\",{\"1\":{\"198\":4}}],[\"存储空间的划分与初始化\",{\"1\":{\"198\":1}}],[\"存储空间利用率低\",{\"1\":{\"197\":1}}],[\"存储器利用率极低\",{\"1\":{\"182\":1}}],[\"存储器管理\",{\"1\":{\"154\":1}}],[\"存储管理所需要的各种信息\",{\"1\":{\"159\":1}}],[\"进制数字和\",{\"1\":{\"1176\":1}}],[\"进制\",{\"1\":{\"1176\":1}}],[\"进制转换函数\",{\"1\":{\"338\":2}}],[\"进而提高性能\",{\"1\":{\"1066\":1}}],[\"进而直接将单个小文件读取到内存中处理\",{\"1\":{\"477\":1}}],[\"进一步理解代理增强基于方法重写\",{\"1\":{\"1480\":1}}],[\"进一步熟悉注解元数据\",{\"1\":{\"1277\":1}}],[\"进一步降低tomcat服务的压力\",{\"1\":{\"1094\":1}}],[\"进一步优化\",{\"1\":{\"855\":2}}],[\"进一步提高了系统的并发度\",{\"1\":{\"163\":1}}],[\"进入了控制器\",{\"1\":{\"1441\":1}}],[\"进入环绕通知2\",{\"1\":{\"1340\":1}}],[\"进入环绕通知1\",{\"1\":{\"1340\":1}}],[\"进入代理方法\",{\"1\":{\"1309\":1}}],[\"进入redis安装目录\",{\"1\":{\"1196\":1}}],[\"进入redis目录\",{\"1\":{\"1193\":1}}],[\"进入用户自己继承的mapper类中\",{\"1\":{\"979\":1}}],[\"进入死循环\",{\"1\":{\"741\":1}}],[\"进入内核态\",{\"1\":{\"676\":1}}],[\"进入aqs队列park阻塞\",{\"1\":{\"591\":1}}],[\"进入下一轮循环\",{\"1\":{\"579\":1}}],[\"进入阻塞状态\",{\"1\":{\"538\":1}}],[\"进入区的检查和上锁两个处理不是一气呵成的\",{\"1\":{\"169\":1}}],[\"进入区\",{\"1\":{\"168\":1}}],[\"进程只有在调用一定的方法后\",{\"1\":{\"680\":1}}],[\"进程只作为除cpu之外的系统资源的分配单元\",{\"1\":{\"163\":1}}],[\"进程id命令查看线程状态有java层面死锁线程信息\",{\"1\":{\"551\":1}}],[\"进程对已获得的资源在未使用完成前不能被抢占\",{\"1\":{\"551\":1}}],[\"进程也必须阻塞等待\",{\"1\":{\"213\":1}}],[\"进程运行过程中动态申请设备资源\",{\"1\":{\"213\":1}}],[\"进程运行前为其分配全部所需资源\",{\"1\":{\"213\":1}}],[\"进程前将各页面装入各内存块中\",{\"1\":{\"188\":1}}],[\"进程未执行时\",{\"1\":{\"185\":1}}],[\"进程根据页框大小拆分为一个个区域\",{\"1\":{\"184\":1}}],[\"进程回退法\",{\"1\":{\"178\":1}}],[\"进程实际访问页面的集合\",{\"1\":{\"192\":1}}],[\"进程实际使用资源的顺序可能和编号递增顺序不一致\",{\"1\":{\"176\":1}}],[\"进程实体是静态的\",{\"1\":{\"159\":1}}],[\"进程实体的概念\",{\"1\":{\"159\":1}}],[\"进程实体\",{\"1\":{\"159\":2}}],[\"进程c需要用到a资源1和2\",{\"1\":{\"176\":1}}],[\"进程在运行期间发现缺页时才将所缺页面调入内存\",{\"1\":{\"192\":1}}],[\"进程在运行前一次申请完它所需要的全部资源\",{\"1\":{\"176\":1}}],[\"进程在内存与磁盘间动态调度\",{\"1\":{\"181\":1}}],[\"进程在cpu执行的时间\",{\"1\":{\"166\":1}}],[\"进程推进顺序非法\",{\"1\":{\"175\":1}}],[\"进程已经至少保持了一个资源\",{\"1\":{\"175\":1}}],[\"进程所获得的资源在未使用完之前\",{\"1\":{\"175\":1}}],[\"进程会调用wait里面的block原语进行自我阻塞\",{\"1\":{\"171\":1}}],[\"进程异步是指\",{\"1\":{\"168\":1}}],[\"进程互斥的实现方式\",{\"1\":{\"170\":1}}],[\"进程互斥的硬件实现方法\",{\"0\":{\"170\":1}}],[\"进程互斥的软件实现方法\",{\"0\":{\"169\":1}}],[\"进程互斥需要遵循的原则\",{\"1\":{\"168\":1}}],[\"进程互斥\",{\"0\":{\"168\":1},\"1\":{\"168\":2}}],[\"进程同步是为了结局进程异步的问题\",{\"1\":{\"168\":1}}],[\"进程同步\",{\"0\":{\"168\":1},\"1\":{\"168\":1,\"171\":1,\"172\":1}}],[\"进程有各自的优先级\",{\"1\":{\"167\":1}}],[\"进程为其服务\",{\"1\":{\"167\":1}}],[\"进程长时间得不到服务\",{\"1\":{\"167\":1}}],[\"进程到来\",{\"1\":{\"167\":1}}],[\"进程到达的先后顺序进行服务\",{\"1\":{\"167\":1}}],[\"进程优先得到服务\",{\"1\":{\"167\":1}}],[\"进程等待i\",{\"1\":{\"166\":1}}],[\"进程切换比较频繁\",{\"1\":{\"167\":1}}],[\"进程切换是有代价的\",{\"1\":{\"165\":1}}],[\"进程切换主要完成了\",{\"1\":{\"165\":1}}],[\"进程切换\",{\"1\":{\"165\":1}}],[\"进程调度指的是从就绪队列中选中一个要执行的进程\",{\"1\":{\"165\":1}}],[\"进程调度的方式\",{\"1\":{\"165\":1}}],[\"进程调度的时机\",{\"0\":{\"165\":1},\"1\":{\"165\":1}}],[\"进程调度是操作系统中最基本的一种调度\",{\"1\":{\"164\":1}}],[\"进程调度\",{\"1\":{\"164\":1,\"167\":7}}],[\"进程内各线程也可以并发\",{\"1\":{\"163\":1}}],[\"进程通过操作系统提供的\",{\"1\":{\"162\":1}}],[\"进程通信方法\",{\"1\":{\"162\":1}}],[\"进程通信是指进程之间信息交换\",{\"1\":{\"162\":1}}],[\"进程通信概念\",{\"1\":{\"162\":1}}],[\"进程通信\",{\"0\":{\"162\":1}}],[\"进程之间的数据交换以格式化消息为单位\",{\"1\":{\"162\":1}}],[\"进程控制相关的原语\",{\"1\":{\"161\":1}}],[\"进程控制是使用原语进行的\",{\"1\":{\"161\":1}}],[\"进程控制的主要功能就是对系统中的所有进程实施有效的管理\",{\"1\":{\"161\":1}}],[\"进程控制\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"进程状态的转换\",{\"1\":{\"160\":1}}],[\"进程正在从系统中撤销\",{\"1\":{\"160\":1}}],[\"进程正在被创建\",{\"1\":{\"160\":1}}],[\"进程特征\",{\"1\":{\"159\":1}}],[\"进程是分配系统资源的单位\",{\"1\":{\"162\":1}}],[\"进程是程序的一次执行\",{\"1\":{\"160\":1}}],[\"进程是程序的一次执行过程\",{\"1\":{\"159\":1}}],[\"进程是资源分配的基本单位\",{\"1\":{\"163\":1}}],[\"进程是资源分配和调度的基本单位\",{\"1\":{\"163\":1}}],[\"进程是资源分配\",{\"1\":{\"159\":1}}],[\"进程是能够独立运行\",{\"1\":{\"159\":1}}],[\"进程是动态的\",{\"1\":{\"159\":1}}],[\"进程是一个程序的执行过程\",{\"1\":{\"154\":1}}],[\"进程映像\",{\"1\":{\"159\":1}}],[\"进程的最后一个页面可能没有一个页框那么大\",{\"1\":{\"184\":1}}],[\"进程的指令要访问某个地址的时候\",{\"1\":{\"180\":1}}],[\"进程的运行原理\",{\"1\":{\"179\":1}}],[\"进程的运行时间是由用户提供的\",{\"1\":{\"167\":1}}],[\"进程的偏好程度\",{\"1\":{\"167\":1}}],[\"进程的响应比\",{\"1\":{\"167\":1}}],[\"进程的等待时间和要求服务的时间\",{\"1\":{\"167\":1}}],[\"进程的基本状态\",{\"1\":{\"160\":1}}],[\"进程的状态\",{\"0\":{\"160\":1}}],[\"进程的组织\",{\"1\":{\"159\":1}}],[\"进程的定义\",{\"1\":{\"159\":1}}],[\"进程的执行不是一贯到底的\",{\"1\":{\"155\":1}}],[\"进程\",{\"0\":{\"159\":1},\"1\":{\"159\":1,\"167\":2}}],[\"进行查找\",{\"1\":{\"1489\":1}}],[\"进行查询之后\",{\"1\":{\"1127\":1}}],[\"进行装配\",{\"1\":{\"1489\":1}}],[\"进行筛选\",{\"1\":{\"1482\":2}}],[\"进行配置\",{\"1\":{\"1411\":1}}],[\"进行sql编写\",{\"1\":{\"1230\":1}}],[\"进行字符串拼接\",{\"1\":{\"1230\":1}}],[\"进行与操作\",{\"1\":{\"1176\":1}}],[\"进行续约逻辑\",{\"1\":{\"1152\":1}}],[\"进行抢锁\",{\"1\":{\"1152\":2}}],[\"进行对比\",{\"1\":{\"1126\":1}}],[\"进行系统解耦\",{\"1\":{\"1009\":1}}],[\"进行位与运行后如果值为0\",{\"1\":{\"999\":1}}],[\"进行工作流处理\",{\"1\":{\"991\":1}}],[\"进行读取\",{\"1\":{\"979\":1}}],[\"进行累加即可得出每个州累计确诊病例\",{\"1\":{\"972\":1}}],[\"进行累积聚合操作\",{\"1\":{\"361\":1}}],[\"进行分隔\",{\"1\":{\"809\":1}}],[\"进行增强\",{\"1\":{\"792\":1}}],[\"进行切片\",{\"1\":{\"776\":1}}],[\"进行切片成多个\",{\"1\":{\"776\":1}}],[\"进行一些初始操作\",{\"1\":{\"776\":1}}],[\"进行了扩展\",{\"1\":{\"756\":1}}],[\"进行\",{\"1\":{\"741\":1,\"1444\":1}}],[\"进行相应编码\",{\"1\":{\"664\":1}}],[\"进行相应的处理\",{\"1\":{\"611\":1}}],[\"进行链表转为红黑树\",{\"1\":{\"579\":1}}],[\"进行排序\",{\"1\":{\"493\":1,\"1041\":1}}],[\"进行哈希取余\",{\"1\":{\"477\":1}}],[\"进行处理\",{\"1\":{\"466\":1,\"718\":1}}],[\"进行划分分区存储\",{\"1\":{\"415\":1}}],[\"进行多次中断处理才能完成\",{\"1\":{\"209\":1}}],[\"进行越界检查\",{\"1\":{\"180\":1}}],[\"进行重复依赖选择\",{\"1\":{\"105\":1}}],[\"进行maven依赖管理\",{\"0\":{\"96\":1}}],[\"进行封装\",{\"1\":{\"9\":1}}],[\"补充自定义类型转换器\",{\"1\":{\"1438\":1}}],[\"补充模型数据\",{\"1\":{\"1438\":1}}],[\"补充关于时间片的大小\",{\"1\":{\"167\":1}}],[\"补充\",{\"1\":{\"154\":1,\"167\":1}}],[\"他采用\",{\"1\":{\"1151\":1}}],[\"他在\",{\"1\":{\"1151\":1}}],[\"他应该能再次尝试获得锁\",{\"1\":{\"1149\":1}}],[\"他直接就会执行删除锁那行代码\",{\"1\":{\"1145\":1}}],[\"他正准备删除锁\",{\"1\":{\"1145\":1}}],[\"他拿到的对象实际上是不同的对象\",{\"1\":{\"1137\":1}}],[\"他查询缓存没有命中\",{\"1\":{\"1126\":1}}],[\"他查询缓存数据并不存在\",{\"1\":{\"1121\":1}}],[\"他先把缓存删了\",{\"1\":{\"1121\":1}}],[\"他确实可以使用对应路径的拦截\",{\"1\":{\"1109\":1}}],[\"他还是另一个著名网络应用框架\",{\"1\":{\"790\":1}}],[\"他有request和cancel\",{\"1\":{\"719\":1}}],[\"他只告诉进程哪些fd刚刚变为就绪态\",{\"1\":{\"680\":1}}],[\"他没有最大连接数的限制\",{\"1\":{\"680\":1}}],[\"他将用户传入的fd数组拷贝到内核空间\",{\"1\":{\"680\":1}}],[\"他的方法都是使用\",{\"1\":{\"1149\":1}}],[\"他的操作逻辑是在操作时\",{\"1\":{\"1135\":1}}],[\"他的操作就是安全的\",{\"1\":{\"1135\":1}}],[\"他的基本原理就是select\",{\"1\":{\"679\":1}}],[\"他的寻址空间\",{\"1\":{\"676\":1}}],[\"他就会进行自动配置\",{\"1\":{\"1515\":1}}],[\"他就会自动被删除~\",{\"1\":{\"1205\":1}}],[\"他就会将数据从kernel中拷贝到用户内存中\",{\"1\":{\"679\":1}}],[\"他就去进行续约\",{\"1\":{\"1152\":1}}],[\"他就知道数据还没有准备好\",{\"1\":{\"679\":1}}],[\"他会经历两个阶段\",{\"1\":{\"679\":1}}],[\"他会阻断其他共享锁和排他锁\",{\"1\":{\"508\":1}}],[\"他是在beanfactory的基础上构建的\",{\"1\":{\"1501\":1}}],[\"他是借助于底层的一个\",{\"1\":{\"1151\":1}}],[\"他是一个索引值\",{\"1\":{\"677\":1}}],[\"他是计算机系统中最基本的系统软件\",{\"1\":{\"153\":1}}],[\"他们在扣减时\",{\"1\":{\"1136\":1}}],[\"他们从逻辑上讲他们是同一张表\",{\"1\":{\"1131\":1}}],[\"他们有业务重合的点并且都属于yunying\",{\"1\":{\"923\":1}}],[\"他们就能够满负荷工作\",{\"1\":{\"755\":1}}],[\"他们共同的缺点是什么\",{\"1\":{\"633\":1}}],[\"他们的作用一样\",{\"1\":{\"1503\":1}}],[\"他们的操作更多的是依赖于内存来操作\",{\"1\":{\"1189\":1}}],[\"他们的构造方法对\",{\"1\":{\"714\":1}}],[\"他们的线程状态都是timed\",{\"1\":{\"546\":1}}],[\"他们的插座如下图最左边\",{\"1\":{\"4\":1}}],[\"他们不需要查找具体的行\",{\"1\":{\"497\":1}}],[\"🤪😒🎈🔥😊😂💕😘👌😍❤️🤣👍✌️🤞🙌🤦‍♀️😉😎🤦‍♂️🤷‍♀️🎶🎆🎈🧨✨🎉🎎🎁🎀🎍🎋🧧🍟🌭🧇🍳🥗🍞🥨🥖🫓❤️🧡💛💚💙💜❤️‍🩹❤️‍🔥💔🤍🖤🤎🚗🚓🚘🚜🚎🚑🚑🚔\",{\"1\":{\"150\":1}}],[\"牙刷\",{\"1\":{\"147\":1}}],[\"泰迪熊\",{\"1\":{\"147\":1}}],[\"花瓶\",{\"1\":{\"147\":1}}],[\"钟表\",{\"1\":{\"147\":1}}],[\"书籍\",{\"0\":{\"216\":1}}],[\"书\",{\"1\":{\"147\":1}}],[\"冰箱\",{\"1\":{\"147\":1}}],[\"洗碗槽\",{\"1\":{\"147\":1}}],[\"洗衣机\",{\"1\":{\"41\":1}}],[\"烤吐司炉\",{\"1\":{\"147\":1}}],[\"烤箱\",{\"1\":{\"147\":1}}],[\"键值\",{\"1\":{\"1190\":1}}],[\"键值型\",{\"1\":{\"1182\":1}}],[\"键值对\",{\"1\":{\"1023\":1}}],[\"键值对中的键是字符串类型\",{\"1\":{\"661\":1}}],[\"键相等的键值对组成一组\",{\"1\":{\"980\":1}}],[\"键相等的键值对调用一次reduce方法\",{\"1\":{\"966\":1}}],[\"键入网址到网页显示\",{\"1\":{\"652\":1}}],[\"键盘\",{\"1\":{\"147\":1}}],[\"键存储的是名称\",{\"1\":{\"42\":1}}],[\"遥控器\",{\"1\":{\"147\":1}}],[\"鼠标\",{\"1\":{\"147\":1}}],[\"厕所\",{\"1\":{\"147\":1}}],[\"餐桌\",{\"1\":{\"147\":1}}],[\"餐刀\",{\"1\":{\"147\":1}}],[\"床\",{\"1\":{\"147\":1}}],[\"床单充电线作画gommy\",{\"1\":{\"132\":1}}],[\"盆栽\",{\"1\":{\"147\":1}}],[\"椅子\",{\"1\":{\"147\":1}}],[\"家具\",{\"1\":{\"147\":1}}],[\"蛋糕\",{\"1\":{\"147\":1}}],[\"甜甜圈\",{\"1\":{\"147\":1}}],[\"甜点工厂类\",{\"1\":{\"39\":1}}],[\"热点文章的点赞数和转发数等等\",{\"1\":{\"515\":1}}],[\"热门英雄胜率及皮肤价格\",{\"1\":{\"256\":1}}],[\"热狗\",{\"1\":{\"147\":1}}],[\"热油是一样的\",{\"1\":{\"85\":1}}],[\"热油\",{\"1\":{\"85\":3}}],[\"胡萝卜\",{\"1\":{\"147\":1}}],[\"橘子\",{\"1\":{\"147\":1}}],[\"苹果\",{\"1\":{\"147\":1}}],[\"香蕉\",{\"1\":{\"147\":1}}],[\"食物\",{\"1\":{\"147\":1}}],[\"碗\",{\"1\":{\"147\":1}}],[\"勺子\",{\"1\":{\"147\":1}}],[\"叉子\",{\"1\":{\"147\":1}}],[\"茶杯\",{\"1\":{\"147\":1}}],[\"玻璃酒杯\",{\"1\":{\"147\":1}}],[\"瓶子\",{\"1\":{\"147\":1}}],[\"器皿餐具\",{\"1\":{\"147\":1}}],[\"网管\",{\"1\":{\"1147\":1}}],[\"网费到了之后\",{\"1\":{\"1147\":1}}],[\"网络等\",{\"1\":{\"948\":1}}],[\"网络带宽也非常重要\",{\"1\":{\"875\":1}}],[\"网络\",{\"0\":{\"859\":1},\"1\":{\"850\":1}}],[\"网络编程\",{\"0\":{\"824\":1},\"1\":{\"852\":1}}],[\"网络上有多条数据发送给服务端\",{\"1\":{\"809\":1}}],[\"网络应用框架中的地位就好比\",{\"1\":{\"791\":1}}],[\"网络传输\",{\"1\":{\"772\":1}}],[\"网络设备出现故障\",{\"1\":{\"707\":1}}],[\"网络协议\",{\"1\":{\"651\":1}}],[\"网络中获取一个对象的二进制流\",{\"1\":{\"629\":1}}],[\"网络数据传输\",{\"1\":{\"432\":1}}],[\"网络结构\",{\"0\":{\"135\":1}}],[\"网球拍\",{\"1\":{\"147\":1}}],[\"冲浪板\",{\"1\":{\"147\":1}}],[\"滑动窗口\",{\"1\":{\"694\":3}}],[\"滑板\",{\"1\":{\"147\":1}}],[\"滑雪板\",{\"1\":{\"147\":1}}],[\"棒球手套\",{\"1\":{\"147\":1}}],[\"棒球棒\",{\"1\":{\"147\":1}}],[\"篮球\",{\"1\":{\"147\":1}}],[\"飞衡\",{\"1\":{\"256\":1}}],[\"飞盘\",{\"1\":{\"147\":1}}],[\"飞机\",{\"1\":{\"147\":1}}],[\"运算符在两个操作数之间\",{\"1\":{\"331\":1}}],[\"运算符使用\",{\"0\":{\"327\":1}}],[\"运算数据存放的位置不同\",{\"1\":{\"159\":1}}],[\"运动\",{\"1\":{\"147\":1}}],[\"运行安装程序即可安装\",{\"1\":{\"1201\":1}}],[\"运行编译命令\",{\"1\":{\"1193\":1}}],[\"运行前端项目\",{\"0\":{\"1097\":1}}],[\"运行前调入\",{\"1\":{\"192\":1}}],[\"运行情况\",{\"1\":{\"949\":1}}],[\"运行balancer\",{\"1\":{\"873\":1}}],[\"运行客户端\",{\"1\":{\"848\":1}}],[\"运行非\",{\"1\":{\"741\":1}}],[\"运行用户代码的时间占总运行时间的比例\",{\"1\":{\"637\":1}}],[\"运行状态并在失败时重新启动它等\",{\"1\":{\"945\":1}}],[\"运行状态\",{\"1\":{\"538\":2}}],[\"运行结果与\",{\"1\":{\"1306\":1}}],[\"运行结果\",{\"1\":{\"1304\":1}}],[\"运行结果为\",{\"1\":{\"54\":2}}],[\"运行结束后归还资源\",{\"1\":{\"213\":1}}],[\"运行时请添加\",{\"1\":{\"1243\":1,\"1292\":1,\"1296\":1,\"1313\":1}}],[\"运行时元数据\",{\"1\":{\"631\":1}}],[\"运行时会调用unsafe类中的native方法\",{\"1\":{\"549\":1}}],[\"运行时调入\",{\"1\":{\"192\":1}}],[\"运行时动态链接\",{\"1\":{\"179\":1}}],[\"运行时依赖范围\",{\"1\":{\"100\":1}}],[\"运行三种基本状态\",{\"1\":{\"163\":1}}],[\"运行态\",{\"1\":{\"160\":1}}],[\"运行在用户态\",{\"1\":{\"156\":1}}],[\"运行在核心态\",{\"1\":{\"156\":1}}],[\"运行一个gta需要4g内存\",{\"1\":{\"155\":1}}],[\"运行阶段才需要实现了\",{\"1\":{\"100\":1}}],[\"运行\",{\"1\":{\"100\":1,\"873\":1,\"1013\":1}}],[\"运行过程都是必须的\",{\"1\":{\"100\":1}}],[\"运行环境\",{\"1\":{\"100\":1}}],[\"行适合插入\",{\"1\":{\"995\":1}}],[\"行存储的写入是一次性完成\",{\"1\":{\"995\":1}}],[\"行式存储\",{\"0\":{\"995\":1}}],[\"行的第\",{\"1\":{\"648\":1}}],[\"行第\",{\"1\":{\"648\":1}}],[\"行级锁只在存储引擎层实现\",{\"1\":{\"511\":1}}],[\"行锁又称为记录锁\",{\"1\":{\"511\":1}}],[\"行锁\",{\"0\":{\"511\":1}}],[\"行锁则之锁定需要操作的数据\",{\"1\":{\"506\":1}}],[\"行锁以及其他位于二至之间的锁\",{\"1\":{\"506\":1}}],[\"行转列\",{\"0\":{\"380\":1,\"383\":1}}],[\"行列转换应用与实现\",{\"0\":{\"379\":1}}],[\"行之间用换行符隔开\",{\"1\":{\"290\":1}}],[\"行数据之间的分隔符\",{\"1\":{\"252\":1}}],[\"行李箱\",{\"1\":{\"147\":1}}],[\"行时不可能发生变化\",{\"1\":{\"77\":1}}],[\"领带\",{\"1\":{\"147\":1}}],[\"领域的经典深度学习算法\",{\"1\":{\"117\":1}}],[\"雨伞\",{\"1\":{\"147\":1}}],[\"双击即可运行\",{\"1\":{\"1201\":1}}],[\"双向通信\",{\"0\":{\"793\":1}}],[\"双向的\",{\"1\":{\"610\":1}}],[\"双方唇枪舌战\",{\"1\":{\"709\":1}}],[\"双方签订了一纸协议\",{\"1\":{\"709\":1}}],[\"双亲委派机制\",{\"0\":{\"623\":1}}],[\"双分区表的数据加载\",{\"1\":{\"262\":1}}],[\"双缓冲在通信时的区别\",{\"1\":{\"214\":1}}],[\"双缓冲\",{\"1\":{\"214\":1}}],[\"双标志发虽然解决了忙则等待的问题\",{\"1\":{\"169\":1}}],[\"双标志后检查法\",{\"1\":{\"169\":1}}],[\"双标志先检查法\",{\"1\":{\"169\":1}}],[\"双肩背包\",{\"1\":{\"147\":1}}],[\"双重检查方式\",{\"1\":{\"66\":2}}],[\"双重检查锁模式是一种非常好的单例实现模式\",{\"1\":{\"66\":1}}],[\"双重检查锁模式\",{\"1\":{\"66\":1}}],[\"双重检查锁\",{\"1\":{\"66\":1}}],[\"双重校验锁\",{\"1\":{\"22\":1}}],[\"长应用程序\",{\"1\":{\"951\":1}}],[\"长度\",{\"1\":{\"713\":1,\"714\":1,\"723\":1,\"840\":1}}],[\"长度调整\",{\"1\":{\"699\":1}}],[\"长度占用字节\",{\"1\":{\"699\":1}}],[\"长度偏移\",{\"1\":{\"699\":1}}],[\"长度定的太小\",{\"1\":{\"697\":1}}],[\"长度定的太大\",{\"1\":{\"697\":1}}],[\"长度在\",{\"1\":{\"666\":1}}],[\"长度为\",{\"1\":{\"493\":1}}],[\"长度为20的索引\",{\"1\":{\"481\":1}}],[\"长度不要超过5000\",{\"1\":{\"480\":1}}],[\"长期处于\",{\"1\":{\"209\":1}}],[\"长颈鹿\",{\"1\":{\"147\":1}}],[\"长椅\",{\"1\":{\"147\":1}}],[\"斑马\",{\"1\":{\"147\":1}}],[\"熊\",{\"1\":{\"147\":1}}],[\"奶牛\",{\"1\":{\"147\":1}}],[\"绵羊\",{\"1\":{\"147\":1}}],[\"马上就开始新的篇章~~~进入到我们的redis实战篇\",{\"1\":{\"1224\":1}}],[\"马\",{\"1\":{\"147\":1}}],[\"狗\",{\"1\":{\"147\":1}}],[\"猫\",{\"1\":{\"147\":1}}],[\"鸟\",{\"1\":{\"147\":1}}],[\"消耗的时间比列存储少\",{\"1\":{\"995\":1}}],[\"消费组\",{\"0\":{\"1036\":1}}],[\"消费消息都需要指定\",{\"1\":{\"1026\":1}}],[\"消费消息\",{\"0\":{\"1017\":1}}],[\"消费者消费不丢失\",{\"1\":{\"1054\":1}}],[\"消费者数量\",{\"1\":{\"1040\":2}}],[\"消费者的offset是一个针对partition全局offset\",{\"1\":{\"1052\":1}}],[\"消费者的分区分配策略\",{\"0\":{\"1039\":1}}],[\"消费者的速度更快\",{\"1\":{\"1021\":1}}],[\"消费者可以订阅多个主题\",{\"1\":{\"1037\":1}}],[\"消费者组中\",{\"1\":{\"1037\":1}}],[\"消费者组之间互不影响\",{\"1\":{\"1026\":1}}],[\"消费者组内每个消费者负责消费不同分区的数据\",{\"1\":{\"1026\":1}}],[\"消费者组\",{\"1\":{\"1026\":1}}],[\"消费者组的概念\",{\"1\":{\"1024\":1}}],[\"消费者程序开发\",{\"0\":{\"1024\":1}}],[\"消费者程序等等\",{\"1\":{\"1013\":1}}],[\"消费者\",{\"1\":{\"1021\":1,\"1026\":1}}],[\"消费者基准测试程序\",{\"1\":{\"1019\":1}}],[\"消费者是另外一个程序\",{\"1\":{\"1010\":1}}],[\"消费者负责从mq中获取消息\",{\"1\":{\"1010\":1}}],[\"消费者模型\",{\"1\":{\"1010\":1}}],[\"消费得慢\",{\"1\":{\"719\":1}}],[\"消费得快\",{\"1\":{\"719\":1}}],[\"消费string类型数据\",{\"1\":{\"718\":1}}],[\"消费型接口\",{\"1\":{\"614\":1}}],[\"消费队列可以用来平衡生产和消费的线程资源\",{\"1\":{\"548\":1}}],[\"消费模式\",{\"0\":{\"44\":1}}],[\"消息服务\",{\"1\":{\"1499\":1}}],[\"消息转换器\",{\"1\":{\"1438\":2}}],[\"消息是有序的\",{\"1\":{\"1035\":1}}],[\"消息是完整的\",{\"1\":{\"714\":1,\"723\":1}}],[\"消息的元数据\",{\"1\":{\"1025\":1}}],[\"消息会经过通道\",{\"1\":{\"785\":1}}],[\"消息对象\",{\"1\":{\"737\":1}}],[\"消息\",{\"1\":{\"723\":2,\"1035\":1}}],[\"消息类型字节\",{\"1\":{\"723\":2}}],[\"消息正文\",{\"1\":{\"712\":1}}],[\"消息正文到底采用哪种序列化反序列化方式\",{\"1\":{\"712\":1}}],[\"消息无边界\",{\"1\":{\"694\":1}}],[\"消息通知\",{\"1\":{\"526\":1}}],[\"消息队列的模式\",{\"1\":{\"1010\":1}}],[\"消息队列的两种模型\",{\"0\":{\"1010\":1}}],[\"消息队列的组件\",{\"1\":{\"1008\":1}}],[\"消息队列中间件\",{\"1\":{\"1008\":1}}],[\"消息队列是有容量限制的\",{\"1\":{\"548\":1}}],[\"消息队列\",{\"0\":{\"1008\":1},\"1\":{\"515\":1,\"1008\":1}}],[\"消息补偿\",{\"1\":{\"483\":1}}],[\"消息传递的语义性\",{\"0\":{\"1053\":1}}],[\"消息传递方式\",{\"1\":{\"680\":1}}],[\"消息传递\",{\"1\":{\"162\":1}}],[\"消防栓\",{\"1\":{\"147\":1}}],[\"船\",{\"1\":{\"147\":1}}],[\"火车\",{\"1\":{\"147\":1}}],[\"火车站类\",{\"1\":{\"60\":1}}],[\"火车站具有卖票功能\",{\"1\":{\"58\":1,\"59\":1}}],[\"火车站\",{\"1\":{\"58\":1,\"59\":1,\"60\":1}}],[\"火车站是目标对象\",{\"1\":{\"58\":1}}],[\"火车站卖票\",{\"1\":{\"58\":2,\"59\":1,\"60\":1}}],[\"公司在其内部用于分布式环境下生成唯一\",{\"1\":{\"998\":1}}],[\"公司或者组织的唯一标志\",{\"1\":{\"98\":1}}],[\"公网网络不稳定\",{\"1\":{\"707\":1}}],[\"公用表表达式\",{\"1\":{\"318\":1}}],[\"公共范围\",{\"1\":{\"1376\":1}}],[\"公共汇总粒度事实层\",{\"1\":{\"226\":1}}],[\"公共维度层\",{\"1\":{\"226\":1}}],[\"公平锁和非公平锁就这两点区别\",{\"1\":{\"588\":1}}],[\"公平的\",{\"1\":{\"167\":1}}],[\"公平\",{\"1\":{\"167\":2}}],[\"公交车\",{\"1\":{\"147\":1}}],[\"摩托车\",{\"1\":{\"147\":1}}],[\"摩拜单车builder类\",{\"1\":{\"14\":1}}],[\"人工编码方式\",{\"1\":{\"1120\":1}}],[\"人机速度矛盾明显\",{\"1\":{\"212\":1}}],[\"人\",{\"1\":{\"147\":1,\"480\":1}}],[\"人脸简笔画转肖像画\",{\"1\":{\"132\":1}}],[\"人脸图像自动戴口罩\",{\"1\":{\"118\":1}}],[\"交集\",{\"1\":{\"1211\":1}}],[\"交给调用者自己处理\",{\"1\":{\"1129\":1}}],[\"交互\",{\"1\":{\"1499\":1}}],[\"交互多\",{\"1\":{\"501\":1}}],[\"交互式命令接口\",{\"1\":{\"154\":1}}],[\"交互式趣味demo\",{\"1\":{\"131\":1}}],[\"交互式可视化gan\",{\"1\":{\"125\":2}}],[\"交叉连接cross\",{\"1\":{\"325\":1}}],[\"交叉连接\",{\"0\":{\"325\":1}}],[\"交替编号\",{\"1\":{\"205\":1}}],[\"交换通常发生在许多进程运行且内存吃紧时进行\",{\"1\":{\"181\":1}}],[\"交换技术\",{\"1\":{\"180\":1,\"181\":1}}],[\"交通\",{\"1\":{\"147\":1}}],[\"qjm全称quorum\",{\"1\":{\"884\":1}}],[\"qjm\",{\"0\":{\"884\":1}}],[\"q\",{\"1\":{\"645\":14,\"669\":8,\"754\":1,\"794\":1}}],[\"q2\",{\"1\":{\"318\":4}}],[\"q1\",{\"1\":{\"318\":14}}],[\"qualifier指定bean名称注入需要与\",{\"1\":{\"1503\":1}}],[\"qualifier\",{\"1\":{\"1023\":1,\"1024\":1,\"1264\":1,\"1482\":1,\"1489\":1,\"1503\":1}}],[\"quasimondo\",{\"1\":{\"132\":1}}],[\"quithandler\",{\"1\":{\"705\":1}}],[\"quit\",{\"1\":{\"702\":2}}],[\"quicklist\",{\"1\":{\"667\":1}}],[\"quick\",{\"1\":{\"645\":4}}],[\"queue等\",{\"1\":{\"1212\":1}}],[\"queue\",{\"1\":{\"726\":7,\"901\":1,\"1155\":2}}],[\"queue<treenode\",{\"1\":{\"669\":1}}],[\"querywrapper\",{\"1\":{\"1235\":2}}],[\"querywrapper<>\",{\"1\":{\"1234\":1,\"1235\":1}}],[\"querywrapper<user>\",{\"1\":{\"1234\":1,\"1235\":1}}],[\"querywithlogicalexpire\",{\"1\":{\"1128\":1,\"1129\":3}}],[\"querywithmutex\",{\"1\":{\"1127\":2,\"1129\":3}}],[\"querywithpassthrough\",{\"1\":{\"1124\":1,\"1129\":3}}],[\"queryshopbytype\",{\"1\":{\"1172\":3}}],[\"queryshopbyid\",{\"1\":{\"1116\":1}}],[\"queryuserbyid\",{\"1\":{\"1165\":1}}],[\"queryhotblog\",{\"1\":{\"1161\":1}}],[\"queryblogoffollow\",{\"1\":{\"1168\":3}}],[\"queryblogbyuserid\",{\"1\":{\"1165\":1}}],[\"queryblogbyid\",{\"1\":{\"1160\":1,\"1161\":1}}],[\"querybloglikes\",{\"1\":{\"1161\":1,\"1162\":3}}],[\"querybloguser\",{\"1\":{\"1160\":2,\"1161\":2,\"1168\":1}}],[\"querybyid\",{\"1\":{\"1116\":1}}],[\"querybuilders\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":3,\"1081\":1,\"1082\":1,\"1083\":1,\"1089\":1}}],[\"query\",{\"1\":{\"377\":2,\"378\":8,\"441\":1,\"442\":1,\"457\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":5,\"1081\":1,\"1082\":1,\"1083\":1,\"1099\":1,\"1107\":1,\"1137\":3,\"1157\":1,\"1161\":1,\"1162\":1,\"1165\":1,\"1167\":1,\"1168\":1,\"1172\":2}}],[\"query=1\",{\"1\":{\"336\":1}}],[\"quoted\",{\"1\":{\"302\":1}}],[\"ql\",{\"1\":{\"268\":1,\"276\":1,\"296\":1,\"297\":1,\"298\":1,\"436\":1}}],[\"qqwweee\",{\"1\":{\"146\":1}}],[\"qq\",{\"1\":{\"145\":2,\"562\":1,\"648\":1,\"649\":1}}],[\"郭冠华\",{\"1\":{\"145\":1}}],[\"江大白\",{\"1\":{\"145\":1}}],[\"训练过程\",{\"0\":{\"141\":1}}],[\"−log\",{\"1\":{\"140\":2}}],[\"λcoord​i=0∑s2​j=0∑b​1i\",{\"1\":{\"140\":1}}],[\"损失函数\",{\"0\":{\"140\":1},\"1\":{\"145\":1}}],[\"查了很多资料解释是idea进行了预处理\",{\"1\":{\"1229\":1}}],[\"查数据库\",{\"1\":{\"1129\":1}}],[\"查询张三和李四的好友总共有哪些人\",{\"1\":{\"1210\":1}}],[\"查询哪些人是张三的好友却不是李四的好友\",{\"1\":{\"1210\":1}}],[\"查询速度快\",{\"1\":{\"1211\":1}}],[\"查询速度一般\",{\"1\":{\"1209\":1}}],[\"查询速度会加快\",{\"1\":{\"276\":1}}],[\"查询以a开头的key\",{\"1\":{\"1205\":1}}],[\"查询以str为前缀的单词数量\",{\"1\":{\"668\":1}}],[\"查询性能上关系型与非关系型也都有着显著差异\",{\"1\":{\"1189\":1}}],[\"查询方式\",{\"0\":{\"1187\":1}}],[\"查询redis\",{\"1\":{\"1172\":1}}],[\"查询店铺信息\",{\"1\":{\"1171\":1}}],[\"查询店铺数据\",{\"1\":{\"1128\":1}}],[\"查询收件箱\",{\"1\":{\"1168\":1}}],[\"查询收件箱数据时\",{\"1\":{\"1167\":1}}],[\"查询并展示推送的blog信息\",{\"1\":{\"1168\":1}}],[\"查询笔记作者的所有粉丝\",{\"1\":{\"1167\":1}}],[\"查询详情\",{\"1\":{\"1165\":1}}],[\"查询当前用户是否关注了指定用户\",{\"1\":{\"1164\":1}}],[\"查询当前数据库\",{\"1\":{\"302\":1}}],[\"查询top5的点赞用户\",{\"1\":{\"1162\":1}}],[\"查询用户\",{\"1\":{\"1161\":1}}],[\"查询blog是否被点赞\",{\"1\":{\"1168\":1}}],[\"查询blog用户\",{\"1\":{\"1161\":1}}],[\"查询blog有关的用户\",{\"1\":{\"1160\":1,\"1168\":1}}],[\"查询blog\",{\"1\":{\"1160\":1}}],[\"查询订单\",{\"1\":{\"1137\":2,\"1155\":1,\"1157\":1}}],[\"查询优惠券\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1155\":1}}],[\"查询到优惠卷信息\",{\"1\":{\"1134\":1}}],[\"查询后将数据写入redis\",{\"1\":{\"1127\":1}}],[\"查询结果\",{\"1\":{\"1089\":1}}],[\"查询字段过滤\",{\"0\":{\"1079\":1},\"1\":{\"1079\":1}}],[\"查询排序\",{\"0\":{\"1078\":1},\"1\":{\"1078\":1}}],[\"查询文档\",{\"1\":{\"1073\":1}}],[\"查询索引中所有的数据\",{\"0\":{\"1075\":1},\"1\":{\"1075\":1}}],[\"查询索引\",{\"1\":{\"1072\":2}}],[\"查询应用程序的当前运行状态\",{\"1\":{\"953\":1}}],[\"查询应用程序状态等\",{\"1\":{\"949\":1}}],[\"查询前index位置的前缀和\",{\"1\":{\"673\":1}}],[\"查询条件的字段\",{\"1\":{\"493\":1}}],[\"查询\",{\"1\":{\"491\":1,\"1174\":1}}],[\"查询所有id\",{\"1\":{\"455\":1}}],[\"查询所有字段或者指定字段\",{\"1\":{\"302\":1}}],[\"查询原来拉链表的所有数据\",{\"1\":{\"409\":1}}],[\"查询时发现缓存中没有数据\",{\"1\":{\"1122\":1}}],[\"查询时再更新缓存\",{\"1\":{\"1121\":1}}],[\"查询时\",{\"1\":{\"405\":1,\"420\":1}}],[\"查询使用函数\",{\"1\":{\"302\":1}}],[\"查询匹配正则表达式的所有字段\",{\"1\":{\"302\":1}}],[\"查询数据库\",{\"1\":{\"1137\":1}}],[\"查询数据\",{\"0\":{\"300\":1},\"1\":{\"1073\":1}}],[\"查询最新的数据\",{\"1\":{\"292\":1}}],[\"查询语言\",{\"0\":{\"282\":1}}],[\"查询语句从词法分析\",{\"1\":{\"232\":1}}],[\"查询发现还有分区信息\",{\"1\":{\"281\":1}}],[\"查询指定表的元数据信息\",{\"1\":{\"279\":1}}],[\"查询指定分区的数据\",{\"1\":{\"260\":1}}],[\"查询被自动重写为tablescan\",{\"1\":{\"276\":1}}],[\"查询执行计划可以发现\",{\"1\":{\"276\":1}}],[\"查询自动重写的意思是\",{\"1\":{\"276\":1}}],[\"查询视图\",{\"1\":{\"271\":1}}],[\"查询的时候尽量先使用where进行分区过滤\",{\"1\":{\"260\":1}}],[\"查询过滤的时候只需要根据分区值找到对应的文件夹\",{\"1\":{\"259\":1}}],[\"查找控制器方法\",{\"1\":{\"1438\":1}}],[\"查找方式与\",{\"1\":{\"1321\":1}}],[\"查找快\",{\"1\":{\"1210\":1}}],[\"查找\",{\"1\":{\"1174\":1}}],[\"查找该单词是否存在\",{\"1\":{\"668\":1}}],[\"查找与匹配\",{\"0\":{\"619\":1}}],[\"查找效率低\",{\"1\":{\"197\":1}}],[\"查找第一个\",{\"1\":{\"191\":3}}],[\"查过阈值\",{\"1\":{\"139\":1}}],[\"查看需要的类型\",{\"1\":{\"1482\":1}}],[\"查看需要的类型是否为\",{\"1\":{\"1482\":2}}],[\"查看\",{\"1\":{\"1243\":1}}],[\"查看一个key的剩余有效期\",{\"1\":{\"1205\":1}}],[\"查看符合模板的所有key\",{\"1\":{\"1205\":1}}],[\"查看状态\",{\"1\":{\"1197\":1}}],[\"查看探店笔记\",{\"0\":{\"1160\":1}}],[\"查看目前kafka中的主题\",{\"1\":{\"1015\":1}}],[\"查看应用程序的运行状态\",{\"1\":{\"953\":1}}],[\"查看acl权限\",{\"1\":{\"926\":1}}],[\"查看创建的快照\",{\"1\":{\"914\":1}}],[\"查看成员\",{\"1\":{\"704\":1}}],[\"查看构建的列的元数据\",{\"1\":{\"458\":1}}],[\"查看索引内容\",{\"1\":{\"423\":1}}],[\"查看索引结构\",{\"1\":{\"423\":1}}],[\"查看运算符或者函数的使用说明\",{\"1\":{\"328\":1}}],[\"查看视图定义\",{\"1\":{\"271\":1}}],[\"查看父工程的pom\",{\"1\":{\"115\":1}}],[\"查看代理类的结构\",{\"1\":{\"59\":1}}],[\"假死的连接占用的资源不能自动释放\",{\"1\":{\"707\":1}}],[\"假脱机技术\",{\"0\":{\"212\":1},\"1\":{\"212\":1}}],[\"假设已有第三方的两个自动配置类\",{\"1\":{\"1464\":1}}],[\"假设今天是\",{\"1\":{\"1176\":1}}],[\"假设在t1\",{\"1\":{\"1167\":1}}],[\"假设在这4500ms内\",{\"1\":{\"1153\":1}}],[\"假设此时李四再来读取\",{\"1\":{\"1166\":1}}],[\"假设用户关注了大量的用户\",{\"1\":{\"1166\":1}}],[\"假设用户第一次访问第一台tomcat\",{\"1\":{\"1102\":1}}],[\"假设赵六要读取信息\",{\"1\":{\"1166\":1}}],[\"假设现在t2时候又发布了一条记录\",{\"1\":{\"1167\":1}}],[\"假设现在某个节点挂了\",{\"1\":{\"1153\":1}}],[\"假设现在线程3过来访问\",{\"1\":{\"1126\":1}}],[\"假设现在线程2过来\",{\"1\":{\"1126\":1}}],[\"假设现在线程1过来访问\",{\"1\":{\"1126\":1}}],[\"假设我们的线程出现了宕机他还会续约吗\",{\"1\":{\"1152\":1}}],[\"假设我们不设置过期时间\",{\"1\":{\"1126\":1}}],[\"假设还是上边的情况\",{\"1\":{\"1143\":1}}],[\"假设线程过来\",{\"1\":{\"1126\":1}}],[\"假设线程1过来查询库存\",{\"1\":{\"1135\":1}}],[\"假设线程1去查询缓存\",{\"1\":{\"1126\":1}}],[\"假设线程1在查询缓存之后\",{\"1\":{\"1126\":1}}],[\"假设线程1先来\",{\"1\":{\"1121\":1}}],[\"假设布隆过滤器判断这个数据不存在\",{\"1\":{\"1123\":1}}],[\"假设当前用户访问了一些不需要拦截的路径\",{\"1\":{\"1109\":1}}],[\"假设当前的消费者组订阅了三个主题\",{\"1\":{\"1037\":1}}],[\"假设消息一直向后传\",{\"1\":{\"775\":1}}],[\"假设病人源源不断地来\",{\"1\":{\"755\":1}}],[\"假设一个大v写信息\",{\"1\":{\"1166\":1}}],[\"假设一个中文字符长度为\",{\"1\":{\"709\":1}}],[\"假设一个一级分区表有两个字段\",{\"1\":{\"285\":1}}],[\"假设长度为\",{\"1\":{\"697\":1}}],[\"假设接收方的窗口只剩了\",{\"1\":{\"694\":1}}],[\"假设发送方\",{\"1\":{\"694\":1}}],[\"假设访问一次内存的时间为t\",{\"1\":{\"683\":1}}],[\"假设下面这个结构体\",{\"1\":{\"663\":1}}],[\"假设有如下两张表\",{\"1\":{\"1230\":1}}],[\"假设有3个锁\",{\"1\":{\"1153\":1}}],[\"假设有一进程\",{\"1\":{\"690\":1}}],[\"假设有个字符串中有个\",{\"1\":{\"662\":1}}],[\"假设有1000个线程对i执行++操作\",{\"1\":{\"560\":1}}],[\"假设thread\",{\"1\":{\"591\":1}}],[\"假设redis中存在大量已过期但是未被清理的key\",{\"1\":{\"529\":1}}],[\"假设每天有1g的数据增量\",{\"1\":{\"414\":1}}],[\"假设每个分组最多为100个空闲块\",{\"1\":{\"198\":1}}],[\"假设磁盘转速为r\",{\"1\":{\"204\":1}}],[\"假设是匀速移动\",{\"1\":{\"204\":1}}],[\"假设采用的数据结构是空闲分区表\",{\"1\":{\"182\":1}}],[\"假设iou阈值为0\",{\"1\":{\"139\":1}}],[\"假如他在一个方法内\",{\"1\":{\"1149\":1}}],[\"假如有\",{\"1\":{\"1174\":1}}],[\"假如有人持有这把锁\",{\"1\":{\"1151\":1}}],[\"假如有一个1g大小的文件\",{\"1\":{\"476\":1}}],[\"假如有maven项目a\",{\"1\":{\"104\":1}}],[\"假如我们要更换对象\",{\"1\":{\"25\":1}}],[\"与其向项目的构建文件里添加一堆单独的库依赖\",{\"1\":{\"1521\":1}}],[\"与其它类型相互转换\",{\"1\":{\"1369\":1}}],[\"与传统类工厂不同的是\",{\"1\":{\"1502\":1}}],[\"与成员变量名或方法参数名同名\",{\"1\":{\"1489\":1}}],[\"与应用配置类解耦\",{\"1\":{\"1465\":1}}],[\"与第一套接口直接可以通过\",{\"1\":{\"1369\":1}}],[\"与第二次访问内存时间\",{\"1\":{\"683\":1}}],[\"与初始化类似\",{\"1\":{\"1289\":1}}],[\"与java中的treeset有些类似\",{\"1\":{\"1211\":1}}],[\"与lpop和rpop类似\",{\"1\":{\"1209\":1}}],[\"与lateral\",{\"1\":{\"378\":1}}],[\"与redis服务端做心跳测试\",{\"1\":{\"1199\":1}}],[\"与int最大值是为了避免哈希值为负的情况\",{\"1\":{\"968\":1}}],[\"与调度器协商资源以启动\",{\"1\":{\"945\":1}}],[\"与hdfs本身是分离的\",{\"1\":{\"932\":1}}],[\"与之对应\",{\"1\":{\"931\":1}}],[\"与客户端的网络拓扑距离近的排序靠前\",{\"1\":{\"902\":1}}],[\"与集群的利用率\",{\"1\":{\"873\":1}}],[\"与前面的区别是消息存储不连续解析复杂\",{\"1\":{\"841\":1}}],[\"与前面的保护性暂停中的guardobjct不同\",{\"1\":{\"548\":1}}],[\"与\",{\"0\":{\"1241\":1,\"1352\":1,\"1418\":1,\"1422\":1,\"1426\":1},\"1\":{\"649\":1,\"756\":1,\"763\":1,\"947\":2,\"949\":5,\"1170\":1,\"1174\":1,\"1248\":1,\"1264\":1,\"1352\":1,\"1368\":1,\"1370\":1,\"1411\":1,\"1437\":2,\"1464\":1,\"1466\":1,\"1499\":1}}],[\"与与limit\",{\"1\":{\"616\":1}}],[\"与对应的客户端进行数据处理\",{\"1\":{\"609\":1}}],[\"与wait\",{\"1\":{\"549\":1}}],[\"与可运行状态的区别是\",{\"1\":{\"538\":1}}],[\"与yield\",{\"0\":{\"533\":1}}],[\"与过期数据删除策略有关\",{\"1\":{\"519\":1}}],[\"与全表扫描是小巫见大巫\",{\"1\":{\"481\":1}}],[\"与操作系统线程相关\",{\"1\":{\"538\":1}}],[\"与操作\",{\"1\":{\"332\":1}}],[\"与表示两个都为1则结果为1\",{\"1\":{\"331\":1}}],[\"与设备的硬件特性无关的功能都几乎在这一层实现\",{\"1\":{\"210\":1}}],[\"与程序直接控制方式相比\",{\"1\":{\"209\":1}}],[\"与分页的最大区别\",{\"1\":{\"187\":1}}],[\"与原语的实现思想相同\",{\"1\":{\"170\":1}}],[\"与ground\",{\"1\":{\"138\":1}}],[\"与明星\",{\"1\":{\"76\":2}}],[\"调整一行数据中的字段顺序\",{\"1\":{\"988\":1}}],[\"调整区间\",{\"1\":{\"645\":1}}],[\"调试工具类💡\",{\"0\":{\"799\":1}}],[\"调试时也需要通过\",{\"1\":{\"740\":1}}],[\"调入内存\",{\"1\":{\"688\":1}}],[\"调入后就不再调出\",{\"1\":{\"181\":1}}],[\"调至盘上\",{\"1\":{\"688\":1}}],[\"调优和监控\",{\"1\":{\"570\":1}}],[\"调页完成之后再将其唤醒\",{\"1\":{\"190\":1}}],[\"调出\",{\"1\":{\"164\":1}}],[\"调出必然是作业运行结束\",{\"1\":{\"164\":1}}],[\"调出一次\",{\"1\":{\"164\":1}}],[\"调度器协商以获取资源\",{\"1\":{\"947\":1}}],[\"调度器\",{\"1\":{\"945\":2}}],[\"调度器就一直不会考虑调度他们\",{\"1\":{\"538\":1}}],[\"调度器甚至可以忽略\",{\"1\":{\"535\":1}}],[\"调度时选择优先级最高的作业\",{\"1\":{\"167\":1}}],[\"调度算法\",{\"0\":{\"167\":1}}],[\"调度算法评价指标\",{\"0\":{\"166\":1}}],[\"调度的三个层次\",{\"1\":{\"164\":1}}],[\"调度\",{\"1\":{\"163\":1}}],[\"调色板生成\",{\"1\":{\"132\":1}}],[\"调用初始化方法\",{\"1\":{\"1505\":1}}],[\"调用beanpostprocessor的初始化后的方法\",{\"1\":{\"1505\":1}}],[\"调用beanpostprocessor的初始化前的方法\",{\"1\":{\"1505\":1}}],[\"调用blocking\",{\"1\":{\"679\":1}}],[\"调用拦截器的\",{\"1\":{\"1438\":3}}],[\"调用链\",{\"1\":{\"1438\":1}}],[\"调用链会断开\",{\"1\":{\"766\":1}}],[\"调用此\",{\"1\":{\"1430\":1}}],[\"调用过程中所处的位置\",{\"1\":{\"1381\":1,\"1389\":1,\"1401\":1}}],[\"调用控制器方法\",{\"1\":{\"1352\":1}}],[\"调用到没有更多通知了\",{\"1\":{\"1346\":1}}],[\"调用它的\",{\"1\":{\"1340\":2}}],[\"调用目标对象的方法\",{\"1\":{\"1317\":1}}],[\"调用目标时有所改进\",{\"1\":{\"1317\":1}}],[\"调用代理方法时\",{\"1\":{\"1322\":1}}],[\"调用代理对象的方法\",{\"1\":{\"1317\":1}}],[\"调用代理对象的创建代金券订单方法\",{\"1\":{\"1142\":1,\"1150\":1}}],[\"调用代理\",{\"1\":{\"1304\":1,\"1306\":1}}],[\"调用对象的各种初始化方法\",{\"1\":{\"1252\":1}}],[\"调用<select\",{\"1\":{\"1230\":1}}],[\"调用另一个方法\",{\"1\":{\"1149\":1}}],[\"调用另一个微服务\",{\"1\":{\"1009\":1}}],[\"调用lua脚本\",{\"1\":{\"1147\":1}}],[\"调用脚本的常见命令如下\",{\"1\":{\"1146\":1}}],[\"调用多次和n次的作用是相同的\",{\"1\":{\"1004\":1}}],[\"调用方可以调用n次而不用担心引起的错误\",{\"1\":{\"1004\":1}}],[\"调用方调用查询接口\",{\"1\":{\"1003\":1}}],[\"调用方法\",{\"1\":{\"734\":1}}],[\"调用一次map方法\",{\"1\":{\"965\":1}}],[\"调用一次reduce方法\",{\"1\":{\"980\":1}}],[\"调用一次reduce\",{\"1\":{\"961\":1}}],[\"调用mapper类中的map方法处理数据\",{\"1\":{\"965\":1}}],[\"调用distributedfilesystem对象的open\",{\"1\":{\"902\":1}}],[\"调用distributedfilesystem对象的create\",{\"1\":{\"901\":1}}],[\"调用操作系统的写能力\",{\"1\":{\"854\":1}}],[\"调用\",{\"1\":{\"775\":3,\"797\":2,\"802\":2,\"803\":2,\"833\":2,\"854\":1,\"855\":3,\"867\":1,\"1023\":2,\"1317\":1,\"1340\":2,\"1421\":1,\"1425\":1,\"1436\":1,\"1438\":2}}],[\"调用下一个入站处理器\",{\"1\":{\"766\":1}}],[\"调用外部类\",{\"1\":{\"741\":1}}],[\"调用失败\",{\"1\":{\"737\":1}}],[\"调用正常\",{\"1\":{\"737\":1}}],[\"调用异常\",{\"1\":{\"734\":1}}],[\"调用成功\",{\"1\":{\"734\":1}}],[\"调用接口中的方法名\",{\"1\":{\"733\":1}}],[\"调用的接口全限定名\",{\"1\":{\"733\":1}}],[\"调用的就是自己实现的invoke方法\",{\"1\":{\"59\":1}}],[\"调用subscription\",{\"1\":{\"719\":1}}],[\"调用sleep会让当前线程从running进入timed\",{\"1\":{\"533\":1}}],[\"调用cancel告诉发布者不在调用数据\",{\"1\":{\"717\":1,\"718\":1}}],[\"调用后select函数会阻塞\",{\"1\":{\"680\":1}}],[\"调用类的构造方法\",{\"1\":{\"630\":1}}],[\"调用了xxxvalue\",{\"1\":{\"599\":1}}],[\"调用了无参的read方法\",{\"1\":{\"88\":1}}],[\"调用包装类的valueof\",{\"1\":{\"599\":1}}],[\"调用时需要的各个组件\",{\"1\":{\"1355\":1}}],[\"调用时\",{\"1\":{\"576\":1}}],[\"调用unpark后将counter置为1\",{\"1\":{\"549\":1}}],[\"调用yield会让当前线程从running进入runnalbe\",{\"1\":{\"533\":1}}],[\"调用者只操作缓存\",{\"1\":{\"1120\":1}}],[\"调用者只关心产品的接口\",{\"1\":{\"23\":1}}],[\"调用者通过它访问具体工厂的工厂方法来创建产品\",{\"1\":{\"33\":1}}],[\"调用者通过该方法来获取产品\",{\"1\":{\"27\":1}}],[\"调用具体建造者来创建复杂对象的各个部分\",{\"1\":{\"13\":1}}],[\"卫星航拍图转地图等图像转译任务上表现优秀\",{\"1\":{\"130\":1}}],[\"判别器采用patchgan网络结构\",{\"1\":{\"130\":1}}],[\"判断支持该事件类型才发事件\",{\"1\":{\"1497\":1}}],[\"判断张三是否是李四的好友\",{\"1\":{\"1210\":1}}],[\"判断李四是否是张三的好友\",{\"1\":{\"1210\":1}}],[\"判断一个元素是否存在于set中\",{\"1\":{\"1210\":1}}],[\"判断一个master\",{\"1\":{\"526\":1}}],[\"判断key是否存在\",{\"1\":{\"1205\":1}}],[\"判断blog是否被点赞\",{\"1\":{\"1161\":1}}],[\"判断字段blog类的islike属性\",{\"1\":{\"1161\":1}}],[\"判断结果是否为0\",{\"1\":{\"1157\":1}}],[\"判断用户是否下单\",{\"1\":{\"1156\":1}}],[\"判断用户是否存在\",{\"1\":{\"1099\":1,\"1100\":1,\"1107\":1,\"1111\":1}}],[\"判断秒杀库存\",{\"1\":{\"1156\":1}}],[\"判断秒杀库存是否足够\",{\"1\":{\"1155\":1}}],[\"判断秒杀是否已经结束\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"判断秒杀是否开始\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"判断重入次数是否已经为0\",{\"1\":{\"1151\":1}}],[\"判断threadid是否是自己\",{\"1\":{\"1151\":1}}],[\"判断获取锁成功\",{\"1\":{\"1150\":1}}],[\"判断当前用户是否已经点赞\",{\"1\":{\"1161\":1}}],[\"判断当前登录用户是否已经点赞\",{\"1\":{\"1161\":1,\"1162\":2}}],[\"判断当前登录用户是否点赞过\",{\"1\":{\"1161\":2}}],[\"判断当前这把锁是否是属于当前线程\",{\"1\":{\"1152\":1}}],[\"判断当前这把锁的标识是不是自己存入的\",{\"1\":{\"1144\":1}}],[\"判断当前锁是否还是被自己所持有\",{\"1\":{\"1151\":1}}],[\"判断当前线程是否被打断了\",{\"1\":{\"536\":1}}],[\"判断出来库存大于1\",{\"1\":{\"1135\":1}}],[\"判断库存是否充足只需要导\",{\"1\":{\"1155\":1}}],[\"判断库存是否充足\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1156\":1}}],[\"判断命中的是否是空值\",{\"1\":{\"1129\":1}}],[\"判断锁是否获取成功\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"判断缓存是否过期\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"判断缓存中是否存在\",{\"1\":{\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":2}}],[\"判断value中的过期时间是否满足\",{\"1\":{\"1128\":1}}],[\"判断这个value是否是null\",{\"1\":{\"1124\":1}}],[\"判断输入的字段是否有缺失\",{\"1\":{\"986\":1}}],[\"判断输出路径是否存在\",{\"1\":{\"972\":1,\"973\":1,\"974\":1,\"988\":1}}],[\"判断事件类型\",{\"1\":{\"834\":1,\"836\":1}}],[\"判断任务是否成功\",{\"1\":{\"756\":1}}],[\"判断\",{\"1\":{\"756\":1,\"1177\":1}}],[\"判断请求的数据是否有效避免直接绕过缓存请求数据库\",{\"1\":{\"660\":1}}],[\"判断给定数据是否存在\",{\"1\":{\"660\":1}}],[\"判断对象所对应的类是否加载链接初始化\",{\"1\":{\"630\":1}}],[\"判断对象对应的类是否加载\",{\"1\":{\"630\":1}}],[\"判断类元信息是否存在\",{\"1\":{\"630\":1}}],[\"判断是否支持方法参数\",{\"1\":{\"1362\":1}}],[\"判断是否需要根据坐标查询\",{\"1\":{\"1172\":1}}],[\"判断是否需要拦截\",{\"1\":{\"1111\":1}}],[\"判断是否关注的接口\",{\"1\":{\"1164\":1}}],[\"判断是否与指定的标示\",{\"1\":{\"1146\":1}}],[\"判断是否与当前线程标示一致\",{\"1\":{\"1144\":1,\"1146\":1}}],[\"判断是否满足秒杀条件\",{\"1\":{\"1134\":1}}],[\"判断是否过期\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"判断是否命中\",{\"1\":{\"1128\":1}}],[\"判断是否获得锁成功\",{\"1\":{\"1157\":1}}],[\"判断是否获得到了锁\",{\"1\":{\"1127\":1}}],[\"判断是否获取成功\",{\"1\":{\"1127\":1,\"1129\":1}}],[\"判断是否是\",{\"1\":{\"1127\":1}}],[\"判断是否是key为\",{\"1\":{\"1124\":1,\"1129\":1}}],[\"判断是否存在\",{\"1\":{\"1122\":1,\"1129\":1,\"1137\":3,\"1151\":1,\"1157\":1}}],[\"判断是否存在这个数据\",{\"1\":{\"1106\":1}}],[\"判断是否要扩容\",{\"1\":{\"601\":1}}],[\"判断是否全为数字\",{\"1\":{\"330\":1}}],[\"判断数组是否包含指定元素\",{\"1\":{\"339\":2}}],[\"判断通过反射创建的两个singleton对象是否是同一个对象\",{\"1\":{\"68\":1}}],[\"判断两个反序列化后的对象是否是同一个对象\",{\"1\":{\"68\":1}}],[\"判断stu对象和stu1对象是否是同一个对象\",{\"1\":{\"54\":2}}],[\"融合底层细粒度特征和高层抽象语义特征\",{\"1\":{\"130\":1}}],[\"扒一下低调的yoshua\",{\"1\":{\"126\":1}}],[\"照片转动漫animegan\",{\"1\":{\"125\":1}}],[\"趣味案例\",{\"0\":{\"132\":1}}],[\"趣味demo\",{\"0\":{\"125\":1}}],[\"趣味应用\",{\"0\":{\"118\":1}}],[\"野马转成斑马\",{\"1\":{\"124\":1}}],[\"野马转斑马花纹\",{\"1\":{\"117\":1}}],[\"风筝\",{\"1\":{\"147\":1}}],[\"风格迁移\",{\"1\":{\"124\":1}}],[\"风清扬\",{\"1\":{\"43\":1}}],[\"论文地址\",{\"1\":{\"144\":1}}],[\"论文\",{\"1\":{\"131\":1}}],[\"论文作者为\",{\"1\":{\"124\":1}}],[\"论文主页\",{\"1\":{\"117\":1,\"124\":1,\"131\":1}}],[\"李勇\",{\"1\":{\"351\":1}}],[\"李宏毅生成对抗网络公开课\",{\"1\":{\"120\":1,\"127\":1}}],[\"李四的好友有\",{\"1\":{\"1210\":1}}],[\"李四\",{\"1\":{\"52\":1,\"54\":3,\"615\":1,\"1210\":1}}],[\"博客园\",{\"1\":{\"602\":1}}],[\"博客\",{\"0\":{\"120\":1,\"127\":1,\"145\":1}}],[\"ymlreturnvaluehandler\",{\"1\":{\"1357\":1}}],[\"yml配置redis信息\",{\"1\":{\"1221\":1}}],[\"yes\",{\"1\":{\"1196\":1}}],[\"year\",{\"1\":{\"337\":3,\"348\":6,\"349\":6,\"1174\":1}}],[\"yunying\",{\"1\":{\"923\":3}}],[\"yum\",{\"1\":{\"876\":2,\"1192\":1}}],[\"yarn集群模式\",{\"1\":{\"963\":1}}],[\"yarn集群中的主角色\",{\"1\":{\"944\":1}}],[\"yarn上的应用类型\",{\"0\":{\"951\":1}}],[\"yarn交互流程\",{\"0\":{\"950\":1}}],[\"yarn实际上采用的是拉式\",{\"1\":{\"949\":1}}],[\"yarn底层使用rpc协议实现通信\",{\"1\":{\"949\":1}}],[\"yarn通信协议\",{\"0\":{\"949\":1}}],[\"yarn中的从角色\",{\"1\":{\"944\":1}}],[\"yarn组件及功能\",{\"0\":{\"943\":1}}],[\"yarn架构体系\",{\"0\":{\"940\":1}}],[\"yarn\",{\"0\":{\"939\":1,\"1553\":1},\"1\":{\"948\":1,\"951\":1,\"952\":2,\"963\":3}}],[\"yasm\",{\"1\":{\"876\":2}}],[\"yan\",{\"1\":{\"119\":1}}],[\"yield没有时间参数\",{\"1\":{\"533\":1}}],[\"yield\",{\"1\":{\"533\":1}}],[\"y必须是table总bucket数的倍数或者因子\",{\"1\":{\"369\":1}}],[\"yyyymm\",{\"1\":{\"1176\":1}}],[\"yyyymmdd\",{\"1\":{\"337\":1}}],[\"yyyy\",{\"1\":{\"337\":3,\"1132\":1,\"1175\":1}}],[\"y\",{\"1\":{\"317\":1,\"369\":1,\"649\":6,\"671\":4,\"876\":2,\"1171\":1,\"1172\":7,\"1192\":1}}],[\"yolo3\",{\"1\":{\"146\":2}}],[\"yolo\",{\"1\":{\"144\":1}}],[\"yolov3目标检测demo视频\",{\"1\":{\"144\":1}}],[\"yolov3的head部分\",{\"1\":{\"138\":1}}],[\"yolov3\",{\"0\":{\"134\":1},\"1\":{\"146\":2}}],[\"you\",{\"1\":{\"809\":3}}],[\"young\",{\"1\":{\"628\":1}}],[\"youtube\",{\"1\":{\"144\":1}}],[\"your\",{\"1\":{\"76\":1,\"775\":1}}],[\"作为它的成员变量\",{\"1\":{\"1438\":1}}],[\"作为静态资源\",{\"1\":{\"1430\":1}}],[\"作为\",{\"1\":{\"1416\":1}}],[\"作为扩展点\",{\"1\":{\"1376\":1}}],[\"作为对比\",{\"1\":{\"1298\":1}}],[\"作为代价\",{\"1\":{\"1179\":1}}],[\"作为java程序员这一块并不作一个简单要求\",{\"1\":{\"1146\":1}}],[\"作为本地缓存\",{\"1\":{\"1113\":1}}],[\"作为登录令牌\",{\"1\":{\"1107\":1}}],[\"作为复制源的原来的分片\",{\"1\":{\"1067\":1}}],[\"作为消费者\",{\"1\":{\"1003\":1}}],[\"作为消息放入\",{\"1\":{\"743\":1}}],[\"作为key输出\",{\"1\":{\"974\":1}}],[\"作为分布式文件系统\",{\"1\":{\"916\":1}}],[\"作为分隔符\",{\"1\":{\"698\":1}}],[\"作为附件加入\",{\"1\":{\"843\":1}}],[\"作为附件关联到\",{\"1\":{\"840\":1}}],[\"作为服务器端\",{\"1\":{\"791\":1}}],[\"作为treebin的节点\",{\"1\":{\"579\":1}}],[\"作为treebin\",{\"1\":{\"579\":1}}],[\"作为一个哨兵集群去运行\",{\"1\":{\"526\":1}}],[\"作为一个单独的发行版提供\",{\"1\":{\"474\":1}}],[\"作为访问数据库的缓冲\",{\"1\":{\"506\":1}}],[\"作为查询的字段列表\",{\"1\":{\"483\":1,\"498\":1}}],[\"作为大数据系统中olap查询的优化方案\",{\"1\":{\"429\":1}}],[\"作为外部查询的条件使用\",{\"1\":{\"317\":1}}],[\"作品\",{\"1\":{\"374\":1}}],[\"作业等\",{\"1\":{\"951\":1}}],[\"作业提交客户端\",{\"1\":{\"949\":1}}],[\"作业提交时间\",{\"1\":{\"166\":2}}],[\"作业的地址空间被划分为若干个段\",{\"1\":{\"683\":1}}],[\"作业很大时\",{\"1\":{\"189\":1}}],[\"作业一旦进入内存之后\",{\"1\":{\"179\":1}}],[\"作业\",{\"1\":{\"167\":1,\"951\":1}}],[\"作业在外存后备队列中等待的时间\",{\"1\":{\"166\":1}}],[\"作业处于等待处理机状态时间之和\",{\"1\":{\"166\":1}}],[\"作业实际运行时间\",{\"1\":{\"166\":1}}],[\"作业实际运行的时间\",{\"1\":{\"166\":1}}],[\"作业周转时间\",{\"1\":{\"166\":1}}],[\"作业数\",{\"1\":{\"166\":2}}],[\"作业完成时间\",{\"1\":{\"166\":2}}],[\"作业调出时撤销pcb\",{\"1\":{\"164\":1}}],[\"作业调入时创建pcb\",{\"1\":{\"164\":1}}],[\"作业调度\",{\"1\":{\"164\":1,\"167\":1}}],[\"作者\",{\"1\":{\"1190\":1}}],[\"作者jun\",{\"1\":{\"119\":1}}],[\"作者相关\",{\"0\":{\"119\":1,\"126\":1}}],[\"作用之一\",{\"1\":{\"1485\":1}}],[\"作用是不执行逻辑\",{\"1\":{\"1436\":1}}],[\"作用域\",{\"0\":{\"1291\":1},\"1\":{\"1411\":1}}],[\"作用字段个数\",{\"1\":{\"492\":1}}],[\"作用\",{\"1\":{\"104\":1,\"1251\":1}}],[\"zunion\",{\"1\":{\"1211\":1}}],[\"zdiff\",{\"1\":{\"1211\":1}}],[\"zinter\",{\"1\":{\"1211\":1}}],[\"zincrby\",{\"1\":{\"1211\":1}}],[\"zipcode\",{\"1\":{\"495\":1}}],[\"zipper\",{\"1\":{\"407\":1,\"408\":1,\"409\":5,\"410\":2}}],[\"zcount\",{\"1\":{\"1211\":1}}],[\"zcard\",{\"1\":{\"515\":1,\"1211\":1}}],[\"zero\",{\"1\":{\"1526\":1}}],[\"zerodatetimebehavior=converttonull\",{\"1\":{\"1046\":1}}],[\"zeromq\",{\"1\":{\"1008\":1}}],[\"zoneoffset\",{\"1\":{\"1132\":1}}],[\"zone\",{\"1\":{\"931\":1,\"936\":2}}],[\"zookeeper也是企业级开发中较好的一个实现分布式锁的方案\",{\"1\":{\"1140\":1}}],[\"zookeeper\",{\"1\":{\"791\":1,\"1012\":2,\"1020\":1,\"1140\":2}}],[\"zoo\",{\"1\":{\"120\":1,\"127\":1}}],[\"zk的压力可能会比较大\",{\"1\":{\"1050\":1}}],[\"zk的leader负责读\",{\"1\":{\"1048\":1}}],[\"zkfc选举失败\",{\"1\":{\"885\":1}}],[\"zkfc\",{\"0\":{\"885\":1}}],[\"zk\",{\"0\":{\"885\":1},\"1\":{\"1046\":3}}],[\"zxvf\",{\"1\":{\"876\":1}}],[\"zlib\",{\"1\":{\"876\":1}}],[\"zlend\",{\"1\":{\"665\":1}}],[\"zllen\",{\"1\":{\"665\":1}}],[\"zltail\",{\"1\":{\"665\":1}}],[\"zlbytes\",{\"1\":{\"665\":1}}],[\"zs\",{\"1\":{\"1210\":8}}],[\"zstd\",{\"1\":{\"876\":1}}],[\"zsetoperations\",{\"1\":{\"1168\":1}}],[\"zset\",{\"1\":{\"664\":1}}],[\"zscore\",{\"1\":{\"515\":1,\"1211\":1}}],[\"zrank\",{\"1\":{\"1211\":2}}],[\"zrangebyscore\",{\"1\":{\"1211\":1}}],[\"zrange\",{\"1\":{\"515\":1,\"1162\":1,\"1211\":1}}],[\"zrevrank\",{\"1\":{\"1211\":1}}],[\"zrevrangebyscore\",{\"1\":{\"1168\":1}}],[\"zrevrange\",{\"1\":{\"515\":1}}],[\"zrem\",{\"1\":{\"1211\":1}}],[\"zrem等\",{\"1\":{\"515\":1}}],[\"zadd\",{\"1\":{\"515\":1,\"1162\":1,\"1211\":1}}],[\"zh\",{\"1\":{\"1244\":1}}],[\"zhaoliu\",{\"1\":{\"1210\":4}}],[\"zhangsan\",{\"1\":{\"339\":4,\"347\":1,\"713\":1,\"737\":1,\"748\":6,\"809\":3,\"1073\":2,\"1210\":1}}],[\"zhanshi\",{\"1\":{\"261\":1}}],[\"zhì\",{\"1\":{\"920\":1}}],[\"zhejiang\",{\"1\":{\"262\":2}}],[\"zhuanlan\",{\"1\":{\"126\":2,\"145\":3}}],[\"zhu主页\",{\"1\":{\"119\":1}}],[\"zhihu\",{\"1\":{\"118\":1,\"126\":2,\"145\":3}}],[\"zvideo\",{\"1\":{\"118\":1}}],[\"见过的有\",{\"1\":{\"1459\":1}}],[\"见视频中同时加\",{\"1\":{\"1248\":1}}],[\"见下图\",{\"1\":{\"1135\":1}}],[\"见下方\",{\"1\":{\"875\":1}}],[\"见下面代码片段\",{\"1\":{\"1317\":1}}],[\"见下面的演示1\",{\"1\":{\"1252\":1}}],[\"见下面\",{\"1\":{\"450\":1}}],[\"见论文主页\",{\"1\":{\"118\":1}}],[\"见面了\",{\"1\":{\"76\":1}}],[\"夏天转冬天景色\",{\"1\":{\"117\":1}}],[\"巧妙实现了两个非配对图像域的相互迁移\",{\"1\":{\"117\":1}}],[\"图3\",{\"0\":{\"1386\":1}}],[\"图2\",{\"0\":{\"1385\":1}}],[\"图形化桌面客户端\",{\"0\":{\"1200\":1},\"1\":{\"1198\":1}}],[\"图形用户接口\",{\"1\":{\"154\":1}}],[\"图片上传接口\",{\"1\":{\"1159\":1}}],[\"图片等\",{\"1\":{\"1159\":1}}],[\"图中不同颜色对应一次环绕通知或目标的调用起始至终结\",{\"1\":{\"1340\":1}}],[\"图中\",{\"1\":{\"1322\":1}}],[\"图中数字代表了处理步骤的先后次序\",{\"1\":{\"766\":1}}],[\"图中深色的部分即要发送的数据\",{\"1\":{\"694\":1}}],[\"图1\",{\"0\":{\"1384\":1},\"1\":{\"766\":1}}],[\"图的构建\",{\"0\":{\"670\":1}}],[\"图像转译和生成对抗网络gan必读论文\",{\"1\":{\"130\":1}}],[\"图像转译\",{\"1\":{\"117\":1,\"133\":1}}],[\"图解设计模式\",{\"1\":{\"44\":1,\"78\":1}}],[\"原来存在\",{\"1\":{\"1206\":1}}],[\"原来不存在\",{\"1\":{\"1206\":1}}],[\"原来消费的分区大多发生了改变\",{\"1\":{\"1042\":1}}],[\"原来运行的进程放回k级队列队尾\",{\"1\":{\"167\":1}}],[\"原先一个微服务是通过接口\",{\"1\":{\"1009\":1}}],[\"原始\",{\"1\":{\"776\":2}}],[\"原始的\",{\"1\":{\"775\":1}}],[\"原始论文\",{\"1\":{\"117\":1,\"124\":1}}],[\"原本为\",{\"1\":{\"742\":1}}],[\"原本的长度在\",{\"1\":{\"666\":1}}],[\"原子累加器\",{\"1\":{\"562\":1}}],[\"原子数组\",{\"1\":{\"562\":1}}],[\"原子引用aba问题\",{\"0\":{\"563\":1}}],[\"原子引用的作用\",{\"1\":{\"562\":1}}],[\"原子引用\",{\"1\":{\"562\":1}}],[\"原子整数\",{\"1\":{\"562\":1}}],[\"原子类总结\",{\"1\":{\"562\":1}}],[\"原子性实现原理\",{\"1\":{\"506\":1}}],[\"原子性指整个数据库事务是不可分割的工作单位\",{\"1\":{\"506\":1}}],[\"原子性\",{\"1\":{\"506\":1,\"556\":1}}],[\"原则\",{\"1\":{\"505\":1}}],[\"原则上是通过将group\",{\"1\":{\"353\":1}}],[\"原因在于\",{\"1\":{\"1121\":1}}],[\"原因是他是基于链表来存储的\",{\"1\":{\"680\":2}}],[\"原因\",{\"1\":{\"498\":1,\"694\":2,\"707\":1}}],[\"原生的\",{\"1\":{\"740\":2}}],[\"原生类型从窄类型到宽类型的转换称为隐式转换\",{\"1\":{\"248\":1}}],[\"原生数据类型\",{\"1\":{\"248\":2}}],[\"原理和\",{\"1\":{\"1151\":1}}],[\"原理是编译期优化\",{\"1\":{\"632\":1}}],[\"原理是因为我们需要先根据\",{\"1\":{\"493\":1}}],[\"原理\",{\"0\":{\"1473\":1},\"1\":{\"182\":1,\"448\":1,\"449\":1,\"450\":1,\"470\":1}}],[\"原理分析\",{\"1\":{\"176\":1}}],[\"原语和signal\",{\"1\":{\"171\":1}}],[\"原语\",{\"1\":{\"171\":2}}],[\"原语使用\",{\"1\":{\"161\":1}}],[\"原语的特点是执行期间不允许中断\",{\"1\":{\"161\":1}}],[\"原型模式的克隆分为浅克隆和深克隆\",{\"1\":{\"51\":1}}],[\"原型模式包含如下角色\",{\"1\":{\"50\":1}}],[\"原型模式\",{\"0\":{\"48\":1}}],[\"④订单模块\",{\"0\":{\"115\":1}}],[\"订单key\",{\"1\":{\"1156\":1}}],[\"订单id\",{\"1\":{\"1134\":1,\"1137\":3,\"1156\":1,\"1157\":1}}],[\"订单创建成功去减库存时\",{\"1\":{\"1003\":1}}],[\"订单编号作为key\",{\"1\":{\"988\":1}}],[\"订单编号\",{\"1\":{\"988\":4,\"990\":1}}],[\"订单查看等\",{\"1\":{\"110\":1}}],[\"订单支付时\",{\"1\":{\"1003\":1}}],[\"订单支付\",{\"1\":{\"110\":1}}],[\"订单服务\",{\"1\":{\"110\":2}}],[\"订阅的\",{\"1\":{\"1037\":2}}],[\"订阅者消费了数据之后\",{\"1\":{\"719\":1}}],[\"订阅者会有一个缓冲池\",{\"1\":{\"719\":1}}],[\"订阅者处理完了\",{\"1\":{\"718\":1}}],[\"订阅者\",{\"1\":{\"716\":1}}],[\"订阅\",{\"1\":{\"45\":1}}],[\"订阅模式\",{\"0\":{\"44\":1},\"1\":{\"717\":1}}],[\"六种状态\",{\"1\":{\"538\":1}}],[\"六\",{\"0\":{\"109\":1}}],[\"产品口碑等\",{\"1\":{\"1120\":1}}],[\"产品类\",{\"1\":{\"13\":1}}],[\"产生的误差\",{\"1\":{\"1177\":1}}],[\"产生的原因\",{\"1\":{\"169\":1,\"969\":1}}],[\"产生非常严重的影响\",{\"1\":{\"1038\":1}}],[\"产生时间局部性的典型原因是程序中存在着大量的循环操作\",{\"1\":{\"687\":1}}],[\"产生指定个数整数并放入集合中\",{\"1\":{\"614\":1}}],[\"产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数\",{\"1\":{\"192\":1}}],[\"产生原因与动态分区分配相似\",{\"1\":{\"188\":1}}],[\"产生\",{\"1\":{\"167\":1}}],[\"产生13∗13\",{\"1\":{\"138\":1}}],[\"产生反应堆\",{\"1\":{\"108\":1}}],[\"子域的概念可以理解为一个集团在不同业务上分公司\",{\"1\":{\"923\":1}}],[\"子程序段x\",{\"1\":{\"683\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"623\":1}}],[\"子句的\",{\"1\":{\"482\":1}}],[\"子句中的子查询\",{\"0\":{\"316\":1,\"317\":1}}],[\"子查询的where子句中支持对父查询的引用\",{\"1\":{\"317\":1}}],[\"子查询只能选择一个列\",{\"1\":{\"317\":1}}],[\"子查询引用父查询中的列\",{\"1\":{\"317\":1}}],[\"子查询\",{\"1\":{\"316\":1}}],[\"子查询也可以是带有union的查询表达式\",{\"1\":{\"316\":1}}],[\"子查询返回结果中的列在外部查询中可用\",{\"1\":{\"316\":1}}],[\"子查询返回结果中的列必须具有唯一的名称\",{\"1\":{\"316\":1}}],[\"子文件命名标准\",{\"1\":{\"236\":1}}],[\"子豪兄论文精读视频\",{\"1\":{\"131\":1}}],[\"子豪兄会带你逐句精读gan开山之作经典论文\",{\"1\":{\"124\":1}}],[\"子豪兄精读论文视频\",{\"1\":{\"117\":1}}],[\"子工程引用父工程中的依赖信息时\",{\"1\":{\"107\":1}}],[\"子工程引用版本\",{\"1\":{\"107\":1}}],[\"子工程的坐标\",{\"1\":{\"107\":1}}],[\"子工程\",{\"1\":{\"107\":1}}],[\"子类执行的结果会影响父类的结果\",{\"1\":{\"86\":1}}],[\"子类与父类的耦合度高\",{\"1\":{\"77\":1}}],[\"父目录是否存在\",{\"1\":{\"901\":1}}],[\"父项目中包含的子项目列表\",{\"1\":{\"108\":1}}],[\"父工程的打包方式为pom\",{\"1\":{\"112\":1}}],[\"父工程的坐标\",{\"1\":{\"107\":1}}],[\"父工程声明版本\",{\"1\":{\"107\":1}}],[\"父工程依赖统一管理\",{\"1\":{\"107\":1}}],[\"父工程\",{\"1\":{\"107\":1}}],[\"父类\",{\"1\":{\"714\":2}}],[\"父类中的抽象方法由子类实现\",{\"1\":{\"86\":1}}],[\"父类中凡是已经实现好的方法\",{\"1\":{\"73\":1}}],[\"父类的实现的任何改变都会导致子类的实现发生变化\",{\"1\":{\"77\":1}}],[\"父类对子类是透明的\",{\"1\":{\"77\":1}}],[\"五花八门各种各样\",{\"1\":{\"1187\":1}}],[\"五种状态\",{\"1\":{\"538\":1}}],[\"五\",{\"0\":{\"106\":1},\"1\":{\"651\":1}}],[\"先解析\",{\"1\":{\"1482\":1}}],[\"先利用\",{\"1\":{\"1157\":1}}],[\"先判断当前这把锁是否存在\",{\"1\":{\"1152\":1}}],[\"先执行\",{\"1\":{\"1146\":1}}],[\"先请求redis\",{\"1\":{\"1123\":1}}],[\"先修改数据库\",{\"1\":{\"1122\":1}}],[\"先操作数据库\",{\"1\":{\"1121\":1}}],[\"先操作缓存还是先操作数据库\",{\"1\":{\"1121\":1}}],[\"先删除缓存\",{\"1\":{\"1121\":1}}],[\"先后执行job任务\",{\"1\":{\"991\":1}}],[\"先后被触发\",{\"1\":{\"785\":1}}],[\"先行分发到各个task执行的机器上\",{\"1\":{\"989\":1}}],[\"先clean再package\",{\"1\":{\"962\":1}}],[\"先将longwritable类型的value转换成string类型\",{\"1\":{\"959\":1}}],[\"先通过\",{\"1\":{\"1411\":1}}],[\"先通过user\",{\"1\":{\"1230\":1}}],[\"先通过node\",{\"1\":{\"874\":1}}],[\"先通过两次cas操作去争抢锁\",{\"1\":{\"588\":1}}],[\"先写入\",{\"1\":{\"772\":1}}],[\"先写入长度\",{\"1\":{\"699\":1}}],[\"先搞清楚顺序\",{\"1\":{\"766\":1}}],[\"先经过一道道入站工序\",{\"1\":{\"766\":1}}],[\"先来看看\",{\"1\":{\"857\":1}}],[\"先来看可接入事件处理\",{\"1\":{\"743\":1}}],[\"先来先服务\",{\"1\":{\"213\":1}}],[\"先来先服务算法\",{\"1\":{\"167\":1,\"204\":1}}],[\"先约定用定长字节表示接下来数据的长度\",{\"1\":{\"699\":1}}],[\"先预处理第一件物品\",{\"1\":{\"649\":1}}],[\"先处理\",{\"1\":{\"648\":1}}],[\"先会去创造一个新的长度的数组\",{\"1\":{\"601\":1}}],[\"先查后插\",{\"1\":{\"481\":1}}],[\"先快速定位需要获取的id段\",{\"1\":{\"481\":1}}],[\"先过滤再join\",{\"1\":{\"460\":1}}],[\"先从bloomfilter中获取以下是否包含该值\",{\"1\":{\"437\":1}}],[\"先where分组前过滤\",{\"1\":{\"307\":1}}],[\"先基于分区过滤\",{\"1\":{\"260\":1}}],[\"先创建一个新的空文件夹\",{\"1\":{\"194\":1}}],[\"先为进程分配一定数目的物理块\",{\"1\":{\"192\":1}}],[\"先进先出页面置换算法\",{\"1\":{\"690\":1}}],[\"先进先出置换算法\",{\"1\":{\"191\":2}}],[\"先进入的页面在之后也有可能经常的访问到\",{\"1\":{\"191\":1}}],[\"先用大的\",{\"1\":{\"183\":1}}],[\"先用小的\",{\"1\":{\"183\":1}}],[\"先上锁后检查\",{\"1\":{\"169\":1}}],[\"先声明的\",{\"1\":{\"105\":1}}],[\"先声明优先\",{\"1\":{\"105\":1}}],[\"先说说jdk提供的动态代理\",{\"1\":{\"59\":1}}],[\"非静态方法\",{\"1\":{\"1515\":1}}],[\"非延迟\",{\"1\":{\"1482\":1}}],[\"非内嵌数据库连接池\",{\"1\":{\"1454\":1}}],[\"非关系型数据库可以将数据拆分\",{\"1\":{\"1189\":1}}],[\"非关系型数据库\",{\"1\":{\"1189\":1}}],[\"非sql的\",{\"1\":{\"1184\":1}}],[\"非法数据\",{\"1\":{\"986\":2}}],[\"非池化\",{\"0\":{\"770\":1}}],[\"非要用这么复杂的异步方式\",{\"1\":{\"755\":1}}],[\"非\",{\"1\":{\"741\":1,\"748\":1,\"770\":1}}],[\"非常不经济\",{\"1\":{\"694\":1}}],[\"非连续分配管理方式允许一个程序员使用的内存分布在离散或者说不相邻的内存中\",{\"1\":{\"683\":1}}],[\"非阻塞模式\",{\"1\":{\"827\":2}}],[\"非阻塞模式下\",{\"1\":{\"827\":1,\"843\":1}}],[\"非阻塞\",{\"0\":{\"825\":1,\"827\":1},\"1\":{\"756\":2,\"827\":2,\"850\":1,\"851\":1,\"1141\":1}}],[\"非阻塞io\",{\"1\":{\"679\":1}}],[\"非阻塞i\",{\"1\":{\"679\":2}}],[\"非阻塞写入同理\",{\"1\":{\"610\":1}}],[\"非公平锁\",{\"1\":{\"1135\":1}}],[\"非公平锁让获得锁的时间变得更加不确定\",{\"1\":{\"588\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"588\":1}}],[\"非公平锁会直接cas抢锁\",{\"1\":{\"588\":1}}],[\"非公平锁在cas失败后\",{\"1\":{\"588\":1}}],[\"非公平锁在调用lock方法后\",{\"1\":{\"588\":1}}],[\"非单调的主键会造成在插入新纪录时\",{\"1\":{\"490\":1}}],[\"非空判断\",{\"1\":{\"1168\":1}}],[\"非空判断函数\",{\"1\":{\"340\":2}}],[\"非空查找函数\",{\"1\":{\"340\":2}}],[\"非空值判断\",{\"1\":{\"330\":1}}],[\"非操作\",{\"1\":{\"332\":1}}],[\"非严格\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"非抢占式算法\",{\"1\":{\"167\":2}}],[\"非剥夺调度方式\",{\"1\":{\"165\":1}}],[\"非特权指令\",{\"1\":{\"156\":1}}],[\"非compile范围进行依赖传递\",{\"1\":{\"104\":1}}],[\"非默认名称\",{\"1\":{\"102\":1}}],[\"时都有问题\",{\"1\":{\"1317\":1}}],[\"时创建\",{\"1\":{\"1290\":3}}],[\"时刻\",{\"1\":{\"1167\":2}}],[\"时效快\",{\"1\":{\"1166\":1}}],[\"时时刻刻都保证较高的可用性\",{\"1\":{\"1140\":1}}],[\"时的时间戳来解决\",{\"1\":{\"1000\":1}}],[\"时的读写模式决定\",{\"1\":{\"813\":1}}],[\"时的倾斜\",{\"0\":{\"463\":1}}],[\"时便得到通知\",{\"1\":{\"680\":1}}],[\"时钟周期不被浪费\",{\"1\":{\"576\":1}}],[\"时钟置换算法是一种性能和开销较均衡的算法\",{\"1\":{\"191\":1}}],[\"时钟置换算法\",{\"1\":{\"191\":2}}],[\"时需注意npe问题\",{\"1\":{\"482\":1}}],[\"时就可以基于构建的索引进行查询\",{\"1\":{\"437\":1}}],[\"时间的本质\",{\"1\":{\"1525\":1}}],[\"时间的秩序\",{\"1\":{\"1525\":1}}],[\"时间戳\",{\"1\":{\"999\":1,\"1131\":1,\"1168\":2}}],[\"时间戳需要左移的位数\",{\"1\":{\"999\":1}}],[\"时间戳和版本号机制一样\",{\"1\":{\"507\":1}}],[\"时间同步\",{\"1\":{\"878\":2}}],[\"时间单位为\",{\"1\":{\"832\":1}}],[\"时间单位\",{\"1\":{\"572\":1,\"1150\":1}}],[\"时间复杂度是\",{\"1\":{\"663\":1}}],[\"时间复杂度只需要\",{\"1\":{\"663\":1}}],[\"时间复杂度也很高\",{\"1\":{\"662\":1}}],[\"时间复杂度为o\",{\"1\":{\"523\":2}}],[\"时间复杂度\",{\"1\":{\"523\":1}}],[\"时间\",{\"1\":{\"374\":1,\"1056\":1,\"1525\":1}}],[\"时间日期类型\",{\"1\":{\"248\":1}}],[\"时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中\",{\"1\":{\"687\":1}}],[\"时间局部性\",{\"1\":{\"189\":1,\"687\":1}}],[\"时间片从小到大\",{\"1\":{\"167\":1}}],[\"时间片轮转算法\",{\"1\":{\"167\":1}}],[\"时\",{\"1\":{\"104\":1,\"482\":1,\"574\":1,\"593\":1,\"605\":1,\"663\":1,\"694\":1,\"740\":1,\"741\":2,\"753\":5,\"775\":1,\"836\":1,\"840\":1,\"859\":2,\"1038\":1,\"1042\":1,\"1151\":1,\"1244\":1,\"1394\":3,\"1524\":1}}],[\"时使用\",{\"1\":{\"104\":2}}],[\"时使用的依赖范围以及配置\",{\"1\":{\"104\":1}}],[\"或其子接口\",{\"1\":{\"1489\":1}}],[\"或其它一些手段\",{\"1\":{\"1252\":1}}],[\"或其它原因导致暂停时\",{\"1\":{\"576\":1}}],[\"或64g内存\",{\"1\":{\"1094\":1}}],[\"或多次\",{\"1\":{\"1067\":1}}],[\"或失败\",{\"1\":{\"756\":1}}],[\"或成功\",{\"1\":{\"756\":1}}],[\"或是在引导类加了\",{\"1\":{\"1456\":1}}],[\"或是超时\",{\"1\":{\"832\":1}}],[\"或是去执行\",{\"1\":{\"827\":1}}],[\"或是由非\",{\"1\":{\"742\":1}}],[\"或是元素变大了\",{\"1\":{\"667\":1}}],[\"或bigint\",{\"1\":{\"487\":1}}],[\"或count\",{\"1\":{\"482\":1}}],[\"或操作\",{\"1\":{\"332\":1}}],[\"或表示有一个为1则结果为1\",{\"1\":{\"331\":1}}],[\"或从hdfs中直接删除分区文件夹\",{\"1\":{\"281\":1}}],[\"或ads层\",{\"0\":{\"227\":1}}],[\"或每次写出一块\",{\"1\":{\"197\":1}}],[\"或颠簸\",{\"1\":{\"192\":1}}],[\"或最近未使用算法\",{\"1\":{\"191\":1}}],[\"或页面\",{\"1\":{\"184\":1}}],[\"或称顶级页表\",{\"1\":{\"186\":1}}],[\"或称外层页表\",{\"1\":{\"186\":1}}],[\"或称为页帧\",{\"1\":{\"184\":1}}],[\"或称i\",{\"1\":{\"167\":1}}],[\"或终止进程法\",{\"1\":{\"178\":1}}],[\"或简称xchg指令\",{\"1\":{\"170\":1}}],[\"或\",{\"1\":{\"104\":1,\"332\":1,\"493\":1,\"683\":1,\"698\":1,\"707\":2,\"714\":1,\"723\":2,\"740\":1,\"797\":1,\"851\":1,\"1174\":2,\"1321\":1,\"1442\":1,\"1482\":1,\"1489\":1}}],[\"或者不能严格保证acid的特性\",{\"1\":{\"1188\":1}}],[\"或者可重入完毕\",{\"1\":{\"1152\":1}}],[\"或者把他叫为淘汰更合适\",{\"1\":{\"1119\":1}}],[\"或者由于任何原因消失了\",{\"1\":{\"1067\":1}}],[\"或者单个节点处理搜索请求\",{\"1\":{\"1066\":1}}],[\"或者成功生产消息到\",{\"1\":{\"1025\":1}}],[\"或者一种通信管道\",{\"1\":{\"1009\":1}}],[\"或者一个线程对集合进行删除时也可能会产生\",{\"1\":{\"602\":1}}],[\"或者是no\",{\"1\":{\"1184\":1}}],[\"或者是下单完成\",{\"1\":{\"1155\":1}}],[\"或者是false\",{\"1\":{\"1127\":1}}],[\"或者是使用redis作为缓存\",{\"1\":{\"1115\":1}}],[\"或者是使用哈希\",{\"1\":{\"1104\":1}}],[\"或者是某个\",{\"1\":{\"1037\":1}}],[\"或者是其他可区别标识的10位比特位的整数值都行\",{\"1\":{\"998\":1}}],[\"或者是在最长时间内不再被访问的页面\",{\"1\":{\"690\":1}}],[\"或者运行的环境中有配置\",{\"1\":{\"963\":1}}],[\"或者某些目录\",{\"1\":{\"912\":1}}],[\"或者jps命令获取相关进程\",{\"1\":{\"878\":1}}],[\"或者调用\",{\"1\":{\"766\":1,\"803\":1}}],[\"或者有任务\",{\"1\":{\"742\":1}}],[\"或者已经达到目标\",{\"1\":{\"717\":1,\"718\":1}}],[\"或者超时\",{\"1\":{\"680\":1}}],[\"或者元素值不大的情况才会使用压缩列表作为底层数据结构\",{\"1\":{\"664\":1}}],[\"或者runtime\",{\"1\":{\"635\":1}}],[\"或者从缓冲区写入到通道中\",{\"1\":{\"612\":1}}],[\"或者使用\",{\"1\":{\"493\":1}}],[\"或者100\",{\"1\":{\"462\":1}}],[\"或者storage\",{\"1\":{\"437\":1}}],[\"或者\",{\"1\":{\"336\":1,\"658\":1,\"813\":1,\"816\":1,\"1325\":1}}],[\"或者根据查询结果位置自动推断\",{\"1\":{\"259\":1}}],[\"或者第三方如mysql等\",{\"1\":{\"239\":1}}],[\"或者要将数据分别写到不同内存区域时\",{\"1\":{\"209\":1}}],[\"或者在最长时间内不再被访问的页面\",{\"1\":{\"191\":1}}],[\"或者说我开启n多线程\",{\"1\":{\"1155\":1}}],[\"或者说位数组\",{\"1\":{\"658\":1}}],[\"或者说连接后无事可做\",{\"1\":{\"609\":1}}],[\"或者说依赖信息组合\",{\"1\":{\"107\":1}}],[\"或者说某些步骤的实现与具体的环境相关\",{\"1\":{\"83\":1}}],[\"或者依赖项没有正确定义\",{\"1\":{\"101\":1}}],[\"范围可以是圆形或矩形\",{\"1\":{\"1170\":1}}],[\"范围查询\",{\"0\":{\"1081\":1},\"1\":{\"1081\":1}}],[\"范围分配策略是针对每个\",{\"1\":{\"1040\":1}}],[\"范围分配策略是\",{\"1\":{\"1040\":1}}],[\"范围分配策略\",{\"0\":{\"1040\":1}}],[\"范围是0\",{\"1\":{\"606\":1}}],[\"范围的缓存数据\",{\"1\":{\"598\":1}}],[\"范围\",{\"1\":{\"104\":2,\"723\":1}}],[\"四次挥手\",{\"1\":{\"652\":1}}],[\"四舍五入\",{\"1\":{\"338\":1}}],[\"四种软件实现方式\",{\"1\":{\"170\":1}}],[\"四个特征\",{\"1\":{\"155\":1}}],[\"四\",{\"0\":{\"103\":1}}],[\"配合\",{\"1\":{\"1465\":1}}],[\"配合目标对象一起使用\",{\"1\":{\"1321\":1}}],[\"配合代理对象一起使用\",{\"1\":{\"1321\":1}}],[\"配合接口方法反射\",{\"1\":{\"1310\":1}}],[\"配合distinct关键字去重聚合\",{\"1\":{\"351\":1}}],[\"配额限速\",{\"0\":{\"1056\":1},\"1\":{\"1056\":1}}],[\"配jdk的编译版本\",{\"1\":{\"102\":1}}],[\"配置或spring容器中是否存在某个bean等\",{\"1\":{\"1524\":1}}],[\"配置相应的初始化参数\",{\"1\":{\"1524\":1}}],[\"配置视图路径\",{\"1\":{\"1441\":1}}],[\"配置了\",{\"1\":{\"1411\":1}}],[\"配置为\",{\"1\":{\"1411\":1}}],[\"配置类包含\",{\"1\":{\"1285\":1}}],[\"配置类不包含\",{\"1\":{\"1285\":1}}],[\"配置类\",{\"0\":{\"1285\":1},\"1\":{\"1285\":1}}],[\"配置类的容器\",{\"1\":{\"1245\":1}}],[\"配置类编写\",{\"0\":{\"1088\":1}}],[\"配置数据源信息\",{\"1\":{\"1236\":1}}],[\"配置连接池\",{\"1\":{\"1215\":1}}],[\"配置反向代理和负载均衡\",{\"1\":{\"1138\":1}}],[\"配置0或者1有可能会存在丢失\",{\"1\":{\"1054\":1}}],[\"配置成all\",{\"1\":{\"1054\":1}}],[\"配置zk集群地址\",{\"1\":{\"1046\":1}}],[\"配置消费者的partition\",{\"1\":{\"1040\":1,\"1041\":1}}],[\"配置使用\",{\"1\":{\"1035\":1}}],[\"配置幂等性\",{\"0\":{\"1028\":1}}],[\"配置kafka集群别名\",{\"1\":{\"1046\":1}}],[\"配置kafkaconsumer\",{\"1\":{\"1024\":1}}],[\"配置kafkaproducer\",{\"1\":{\"1023\":1}}],[\"配置kms\",{\"1\":{\"936\":1}}],[\"配置当前作业写入数据库的表\",{\"1\":{\"986\":1}}],[\"配置当前作业的jdbc信息\",{\"1\":{\"985\":1,\"986\":1}}],[\"配置创建作业的job类\",{\"1\":{\"985\":1,\"986\":1}}],[\"配置作业的输出数据路径\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"配置作业的输入数据路径\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"配置本次作业的输入数据路径\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"配置本地仓库地址\",{\"1\":{\"92\":1}}],[\"配置对象\",{\"1\":{\"962\":1}}],[\"配置中心\",{\"1\":{\"526\":1}}],[\"配置映射关系\",{\"1\":{\"483\":1}}],[\"配置common\",{\"1\":{\"114\":1,\"115\":1}}],[\"配置commons\",{\"1\":{\"113\":1}}],[\"配置junit\",{\"1\":{\"113\":1}}],[\"配置jackson\",{\"1\":{\"113\":1}}],[\"配置jdk8版本项目构建\",{\"1\":{\"92\":1}}],[\"配置spring\",{\"1\":{\"113\":1}}],[\"配置依赖插件\",{\"1\":{\"102\":1}}],[\"配置更高版本插件\",{\"1\":{\"102\":1}}],[\"配置maven的参数\",{\"1\":{\"99\":1}}],[\"配置国内阿里镜像\",{\"1\":{\"92\":1}}],[\"配置文件的容器\",{\"1\":{\"1245\":1}}],[\"配置文件对象\",{\"1\":{\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1}}],[\"配置文件\",{\"0\":{\"1220\":1},\"1\":{\"91\":1,\"723\":1,\"1245\":2}}],[\"配置\",{\"1\":{\"91\":1,\"444\":1,\"453\":1,\"470\":1,\"847\":1,\"1012\":1,\"1040\":1,\"1041\":1,\"1046\":3,\"1150\":2,\"1376\":1,\"1442\":1,\"1459\":1}}],[\"修复方案就是给randomkey增加最多执行次数\",{\"1\":{\"529\":1}}],[\"修复分区\",{\"0\":{\"281\":1},\"1\":{\"280\":1}}],[\"修改目标字节码\",{\"1\":{\"1298\":1}}],[\"修改目标类的字节码\",{\"1\":{\"1298\":1}}],[\"修改目录\",{\"1\":{\"196\":1}}],[\"修改redistemplate的序列化器为genericjackson2jsonredisserializer\",{\"1\":{\"1223\":1}}],[\"修改reducetask个数\",{\"1\":{\"988\":1,\"990\":1,\"991\":1}}],[\"修改为yes后即可后台运行\",{\"1\":{\"1196\":1}}],[\"修改为0\",{\"1\":{\"1196\":1}}],[\"修改为=1\",{\"1\":{\"191\":1}}],[\"修改为=0\",{\"1\":{\"191\":1}}],[\"修改自己的\",{\"1\":{\"1172\":1}}],[\"修改新增探店笔记的业务\",{\"1\":{\"1167\":1}}],[\"修改代码\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"修改代码方案二\",{\"1\":{\"1136\":1}}],[\"修改代码方案一\",{\"1\":{\"1136\":1}}],[\"修改分页查询blog业务\",{\"1\":{\"1161\":2}}],[\"修改分区\",{\"1\":{\"280\":1}}],[\"修改根据id查询blog的业务\",{\"1\":{\"1161\":2}}],[\"修改根据id查询商铺的业务\",{\"1\":{\"1128\":1}}],[\"修改点赞功能\",{\"1\":{\"1161\":1}}],[\"修改点赞数量\",{\"1\":{\"1161\":1}}],[\"修改下单动作\",{\"1\":{\"1157\":1}}],[\"修改之前的分布式锁实现\",{\"1\":{\"1144\":1}}],[\"修改业务代码\",{\"1\":{\"1142\":1}}],[\"修改秒杀业务\",{\"1\":{\"1137\":1}}],[\"修改重点代码2\",{\"1\":{\"1122\":1}}],[\"修改重点代码1\",{\"1\":{\"1122\":1}}],[\"修改shopserviceimpl的querybyid方法\",{\"1\":{\"1122\":1}}],[\"修改shopcontroller中的业务逻辑\",{\"1\":{\"1122\":1}}],[\"修改数据\",{\"1\":{\"1073\":1}}],[\"修改文档\",{\"1\":{\"1073\":1,\"1089\":1}}],[\"修改第77行\",{\"1\":{\"1046\":1}}],[\"修改第32行\",{\"1\":{\"1046\":1}}],[\"修改第5行\",{\"1\":{\"1046\":1}}],[\"修改第4行\",{\"1\":{\"1046\":1}}],[\"修改\",{\"1\":{\"1012\":1,\"1046\":1,\"1174\":1,\"1302\":1}}],[\"修改core\",{\"1\":{\"910\":1}}],[\"修改时间\",{\"1\":{\"905\":1}}],[\"修改或获取块位置\",{\"1\":{\"888\":1}}],[\"修改workers配置文件\",{\"1\":{\"878\":1}}],[\"修改副本数等操作\",{\"1\":{\"870\":1}}],[\"修改一下发送文字\",{\"1\":{\"836\":1}}],[\"修改编解码器\",{\"1\":{\"723\":1}}],[\"修改就不会成功\",{\"1\":{\"507\":1}}],[\"修改记录操作\",{\"1\":{\"482\":1}}],[\"修改位\",{\"1\":{\"191\":1}}],[\"修改进程状态标志\",{\"1\":{\"161\":1}}],[\"修改jdk版本\",{\"1\":{\"102\":1}}],[\"修饰的\",{\"1\":{\"1149\":1}}],[\"修饰\",{\"1\":{\"66\":1,\"1482\":1}}],[\"常见返回值处理器\",{\"0\":{\"1392\":1}}],[\"常见参数的解析\",{\"1\":{\"1362\":1}}],[\"常见参数解析器\",{\"0\":{\"1360\":1}}],[\"常见\",{\"0\":{\"1249\":1},\"1\":{\"1329\":1}}],[\"常见方法\",{\"0\":{\"800\":1}}],[\"常见的返回值处理器\",{\"1\":{\"1394\":1}}],[\"常见的有\",{\"1\":{\"1205\":1}}],[\"常见的命令有\",{\"1\":{\"1170\":1}}],[\"常见的分布式锁有三种\",{\"1\":{\"1140\":1}}],[\"常见的解决方案有两种\",{\"1\":{\"1123\":1,\"1126\":1}}],[\"常见的\",{\"1\":{\"861\":2,\"1251\":1}}],[\"常见的如页式管理和段式管理\",{\"1\":{\"683\":1}}],[\"常见的如块式管理\",{\"1\":{\"683\":1}}],[\"常见的几种内存管理机制\",{\"0\":{\"683\":1}}],[\"常见的垃圾回收器算法有哪些\",{\"1\":{\"633\":1}}],[\"常见的构建工具包括\",{\"1\":{\"94\":1}}],[\"常用注解有那些\",{\"0\":{\"1515\":1}}],[\"常用来存储一个有序数据\",{\"1\":{\"1209\":1}}],[\"常用于好友或关注\",{\"1\":{\"1166\":1}}],[\"常用于sorted\",{\"1\":{\"518\":1}}],[\"常用对象\",{\"1\":{\"1149\":1}}],[\"常用命令\",{\"1\":{\"515\":5}}],[\"常用的方法比如getbean\",{\"1\":{\"1502\":1}}],[\"常用的channel有\",{\"1\":{\"610\":1}}],[\"常用的段常驻内存\",{\"1\":{\"181\":1}}],[\"常用的插件\",{\"1\":{\"102\":1}}],[\"常量池中不会存在相同内容的变量\",{\"1\":{\"632\":1}}],[\"常量与常量引用的拼接结果在常量池\",{\"1\":{\"632\":1}}],[\"常量\",{\"1\":{\"482\":1}}],[\"指大流程已经固定好了\",{\"1\":{\"1255\":1}}],[\"指不出意外\",{\"1\":{\"951\":1}}],[\"指一定时间内\",{\"1\":{\"951\":1}}],[\"指计算机安全领域的一个架构模式\",{\"1\":{\"916\":1}}],[\"指针\",{\"1\":{\"776\":1}}],[\"指针只是指向字符数组的起始位置\",{\"1\":{\"662\":1}}],[\"指针碰撞\",{\"1\":{\"630\":1}}],[\"指针类型也一般为4\",{\"1\":{\"487\":1}}],[\"指获取了cpu时间片运行中的状态\",{\"1\":{\"538\":1}}],[\"指该线程已经被创建\",{\"1\":{\"538\":1}}],[\"指该手机内存可以存放4\",{\"1\":{\"179\":1}}],[\"指向内核为每一个进程所维护的该进程打开文件的记录表\",{\"1\":{\"677\":1}}],[\"指向类元数据instanceklass\",{\"1\":{\"631\":1}}],[\"指向undo\",{\"1\":{\"503\":1}}],[\"指向下一个盘块的指针也需要耗费少量的存储空间\",{\"1\":{\"197\":1}}],[\"指的是\",{\"1\":{\"1152\":1}}],[\"指的是jdk提供的新的api\",{\"1\":{\"610\":1}}],[\"指的是使用普通的索引\",{\"1\":{\"481\":1}}],[\"指的是表中列的字段类型\",{\"1\":{\"248\":1}}],[\"指exists和not\",{\"1\":{\"317\":1}}],[\"指在退出安全模式之前必须存活的datanode数量\",{\"1\":{\"870\":1}}],[\"指在用户看来\",{\"1\":{\"195\":1}}],[\"指在某段时间间隔里\",{\"1\":{\"192\":1}}],[\"指请求分页存储管理中给进程分配的物理块的集合\",{\"1\":{\"192\":1}}],[\"指进程\",{\"1\":{\"166\":1}}],[\"指cpu\",{\"1\":{\"166\":1}}],[\"指令类型\",{\"1\":{\"712\":1}}],[\"指令来完成\",{\"1\":{\"567\":1}}],[\"指令是用硬件实现的\",{\"1\":{\"170\":1}}],[\"指令\",{\"1\":{\"156\":1,\"179\":1}}],[\"指两个或多个事件在同一时刻同时发生\",{\"1\":{\"155\":1}}],[\"指两个或多个事件在同一个时间间隔内发生\",{\"1\":{\"155\":1}}],[\"指定的销毁方法\",{\"1\":{\"1289\":1}}],[\"指定的初始化方法\",{\"1\":{\"1289\":1}}],[\"指定访问数据源\",{\"1\":{\"1236\":1}}],[\"指定redis的访问密码\",{\"1\":{\"1199\":1}}],[\"指定reducer阶段输出的key\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"指定配置启动\",{\"0\":{\"1196\":1},\"1\":{\"1194\":1}}],[\"指定圆心\",{\"1\":{\"1170\":1}}],[\"指定锁的名称\",{\"1\":{\"1150\":1}}],[\"指定kafka集群地址\",{\"1\":{\"1021\":1}}],[\"指定kafka数据的位置\",{\"1\":{\"1012\":1}}],[\"指定吞吐量\",{\"1\":{\"1021\":1}}],[\"指定broker的id\",{\"1\":{\"1012\":1}}],[\"指定毫秒时间戳\",{\"1\":{\"999\":1}}],[\"指定计数器所属组的名字\",{\"1\":{\"983\":1}}],[\"指定mapper阶段输出的key\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"指定map元素kv之间的分隔符\",{\"1\":{\"256\":1}}],[\"指定各种组件属性\",{\"1\":{\"962\":1}}],[\"指定参数运行\",{\"1\":{\"873\":1}}],[\"指定\",{\"1\":{\"726\":2,\"737\":1,\"742\":1}}],[\"指定并行化线程数\",{\"1\":{\"446\":1}}],[\"指定表参数orc\",{\"1\":{\"437\":1}}],[\"指定返回的字段\",{\"1\":{\"396\":1}}],[\"指定解析的json字符串\",{\"1\":{\"396\":1}}],[\"指定正则表达式\",{\"1\":{\"374\":1}}],[\"指定使用regexserde加载数据\",{\"1\":{\"374\":2}}],[\"指定种子取随机数函数\",{\"1\":{\"338\":1}}],[\"指定精度取整函数\",{\"1\":{\"338\":2}}],[\"指定格式日期转unix时间戳函数\",{\"1\":{\"337\":1}}],[\"指定动态分区模式\",{\"1\":{\"261\":1}}],[\"指定集合元素之间的分隔符\",{\"1\":{\"256\":1}}],[\"指定字段之间的分隔符\",{\"1\":{\"256\":1}}],[\"指定存储路径\",{\"0\":{\"255\":1}}],[\"指定要连接的redis节点的端口\",{\"1\":{\"1199\":1}}],[\"指定要连接的redis节点的ip地址\",{\"1\":{\"1199\":1}}],[\"指定要连接的服务器和端口\",{\"1\":{\"785\":1}}],[\"指定要返回的字段\",{\"1\":{\"395\":1}}],[\"指定要解析的json字符串\",{\"1\":{\"395\":1}}],[\"指定要排除的依赖的坐标\",{\"1\":{\"105\":1}}],[\"指定要打包资源的文件夹要把哪些静态资源打包到\",{\"1\":{\"102\":1}}],[\"指定打包文件\",{\"1\":{\"102\":1}}],[\"指定打包命名\",{\"1\":{\"102\":1}}],[\"指定包含文件格式和排除文件\",{\"1\":{\"102\":1}}],[\"指定构建打包文件的名称\",{\"1\":{\"102\":1}}],[\"指挥者类\",{\"1\":{\"13\":1,\"14\":2}}],[\"刷新\",{\"1\":{\"1292\":1}}],[\"刷新token有效期\",{\"1\":{\"1111\":1}}],[\"刷新集群\",{\"1\":{\"879\":1}}],[\"刷新重新下载即可\",{\"1\":{\"101\":1}}],[\"刷新也不会重新下载\",{\"1\":{\"101\":1}}],[\"最初获得方法顺序是不确定的\",{\"1\":{\"1321\":1}}],[\"最初产生自apache\",{\"1\":{\"430\":1}}],[\"最高只支持到\",{\"1\":{\"1300\":1}}],[\"最高1位固定值0\",{\"1\":{\"998\":1}}],[\"最重要的实现\",{\"1\":{\"1245\":1}}],[\"最常使用\",{\"1\":{\"1230\":1}}],[\"最常用\",{\"1\":{\"522\":2}}],[\"最低12位为1\",{\"1\":{\"999\":2}}],[\"最多一次\",{\"1\":{\"1053\":1}}],[\"最多可以部署210=1024台机器\",{\"1\":{\"998\":1}}],[\"最多执行一定数量的作业等\",{\"1\":{\"945\":1}}],[\"最多只有一个任务的阻塞队列\",{\"1\":{\"572\":1}}],[\"最多只需1~3次磁盘io\",{\"0\":{\"487\":1}}],[\"最早是\",{\"1\":{\"998\":1}}],[\"最早是由twitter和cloudera合作开发\",{\"1\":{\"429\":1}}],[\"最早用于通信行业\",{\"1\":{\"875\":1}}],[\"最开始输入是\",{\"1\":{\"787\":1}}],[\"最开始读写指针都在\",{\"1\":{\"771\":1}}],[\"最好别修改\",{\"1\":{\"729\":1}}],[\"最少一次\",{\"1\":{\"1053\":1}}],[\"最少使用页面置换算法\",{\"1\":{\"690\":1}}],[\"最少的平均带权周转时间\",{\"1\":{\"167\":1}}],[\"最少的平均周转时间\",{\"1\":{\"167\":1}}],[\"最糟糕的是会有\",{\"1\":{\"667\":1}}],[\"最悲观的估计\",{\"1\":{\"561\":1}}],[\"最乐观的估计\",{\"1\":{\"561\":1}}],[\"最小连接数等\",{\"1\":{\"1454\":1}}],[\"最小空闲连接\",{\"1\":{\"1220\":1}}],[\"最小复制是由参数dfs\",{\"1\":{\"901\":1}}],[\"最小化推送所有数据的延时\",{\"1\":{\"898\":1}}],[\"最小化磁盘i\",{\"1\":{\"432\":1}}],[\"最小块副本数\",{\"1\":{\"870\":1}}],[\"最小1\",{\"1\":{\"535\":1}}],[\"最左前缀\",{\"1\":{\"505\":1}}],[\"最左前缀原则\",{\"1\":{\"493\":1}}],[\"最大空闲连接\",{\"1\":{\"1220\":1}}],[\"最大连接\",{\"1\":{\"1220\":1}}],[\"最大值可为\",{\"1\":{\"999\":1}}],[\"最大值31\",{\"1\":{\"999\":2}}],[\"最大限度地精简数据量\",{\"1\":{\"969\":1}}],[\"最大块副本数\",{\"1\":{\"870\":1}}],[\"最大长度\",{\"1\":{\"699\":1}}],[\"最大的特点在于\",{\"1\":{\"1155\":1}}],[\"最大的特点就在于边缘触发\",{\"1\":{\"680\":1}}],[\"最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理\",{\"1\":{\"61\":1}}],[\"最大线程数为integer\",{\"1\":{\"574\":1}}],[\"最大线程数\",{\"1\":{\"572\":1,\"574\":1}}],[\"最大年龄\",{\"1\":{\"351\":1}}],[\"最后按\",{\"1\":{\"1398\":1}}],[\"最后有一些特殊处理\",{\"1\":{\"1370\":1}}],[\"最后小总结\",{\"1\":{\"1223\":1}}],[\"最后提供返回连接池中连接的方法\",{\"1\":{\"1215\":1}}],[\"最后返回一个完整的值\",{\"1\":{\"1136\":1}}],[\"最后也需要加上条件version\",{\"1\":{\"1135\":1}}],[\"最后也就导致无大分区可用\",{\"1\":{\"183\":1}}],[\"最后将用户数据保存到redis\",{\"1\":{\"1106\":1}}],[\"最后将结果汇总\",{\"1\":{\"564\":1}}],[\"最后计算出来的机器码能区分开来即可\",{\"1\":{\"1001\":1}}],[\"最后12位\",{\"1\":{\"999\":1}}],[\"最后12位存储序列号\",{\"1\":{\"998\":1}}],[\"最后通过lua表达式来解决这个问题\",{\"1\":{\"1147\":1}}],[\"最后通过maven将程序打包放到yarn集群上运行即可\",{\"1\":{\"990\":1}}],[\"最后通过context上下文对象将每个单词都组成<单词\",{\"1\":{\"959\":1}}],[\"最后可以再通过mapreduce程序排序功能\",{\"1\":{\"988\":1}}],[\"最后把这些输出的键值对写入到hdfs文件中\",{\"1\":{\"966\":1}}],[\"最后使用\",{\"1\":{\"855\":1}}],[\"最后输出又变成\",{\"1\":{\"787\":1}}],[\"最后输出\",{\"1\":{\"748\":1}}],[\"最后到时线程阻塞\",{\"1\":{\"552\":1}}],[\"最后\",{\"1\":{\"493\":1}}],[\"最后的字段是组合索引的一部分\",{\"1\":{\"481\":1}}],[\"最后一个值\",{\"1\":{\"365\":1}}],[\"最后一个字段为二级分区\",{\"1\":{\"285\":1}}],[\"最近删除的文件被移动到回收站current目录\",{\"1\":{\"909\":1}}],[\"最近最久未使用页面置换算法\",{\"1\":{\"690\":1}}],[\"最近最久未使用置换算法\",{\"1\":{\"191\":2}}],[\"最近访问过\",{\"1\":{\"191\":2}}],[\"最近没访问\",{\"1\":{\"191\":1}}],[\"最近没有访问且没有修改过的页面\",{\"1\":{\"191\":1}}],[\"最坏适应算法\",{\"1\":{\"183\":1}}],[\"最佳页面置换算法所选择的被淘汰页面将是以后永不使用的\",{\"1\":{\"690\":1}}],[\"最佳页面置换算法\",{\"1\":{\"690\":1}}],[\"最佳置换算法\",{\"1\":{\"191\":2}}],[\"最佳适应算法\",{\"1\":{\"183\":1}}],[\"最佳导入\",{\"1\":{\"104\":1}}],[\"最简单的多道程序的内存管理方式\",{\"1\":{\"182\":1}}],[\"最短寻找时间优先\",{\"1\":{\"204\":1}}],[\"最短的平均等待时间\",{\"1\":{\"167\":1}}],[\"最短剩余时间优先算法\",{\"1\":{\"167\":1}}],[\"最核心的部分\",{\"1\":{\"156\":1}}],[\"最终客户端得到的响应消息可能是有一个普通的html页面\",{\"1\":{\"1530\":2}}],[\"最终将结果相应给前端\",{\"1\":{\"1230\":1}}],[\"最终将map\",{\"1\":{\"470\":1}}],[\"最终结果如图\",{\"1\":{\"1222\":1}}],[\"最终返回\",{\"1\":{\"1205\":1}}],[\"最终返回一个结果\",{\"1\":{\"306\":1}}],[\"最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样\",{\"1\":{\"1146\":1}}],[\"最终多个线程相当于一起去扣减库存\",{\"1\":{\"1135\":1}}],[\"最终输出\",{\"1\":{\"988\":2}}],[\"最终输出一行\",{\"1\":{\"356\":1}}],[\"最终使用outputformat进行数据的输出操作\",{\"1\":{\"984\":1}}],[\"最终使用上下文对此项输出结果\",{\"1\":{\"960\":1}}],[\"最终程序就输出几个文件\",{\"1\":{\"968\":1}}],[\"最终都需要变成\",{\"1\":{\"723\":1}}],[\"最终\",{\"1\":{\"478\":1}}],[\"最终聚合得到结果\",{\"1\":{\"466\":1}}],[\"最终能够消除所有边\",{\"1\":{\"178\":1}}],[\"最终确定一个可用组合\",{\"1\":{\"107\":1}}],[\"最终删除内部的文件\",{\"1\":{\"101\":1}}],[\"清空集合\",{\"1\":{\"988\":1}}],[\"清空sb\",{\"1\":{\"988\":1}}],[\"清除上一次的\",{\"1\":{\"741\":1}}],[\"清除本地\",{\"1\":{\"101\":1}}],[\"清理工作\",{\"1\":{\"741\":1}}],[\"清理编译或打包后的项目结构\",{\"1\":{\"95\":1}}],[\"导出数据到本地文件系统指定目录下\",{\"1\":{\"290\":1}}],[\"导出时指定分隔符和文件存储格式\",{\"1\":{\"290\":1}}],[\"导出查询结果到hdfs指定目录下\",{\"1\":{\"290\":1}}],[\"导入pom坐标\",{\"0\":{\"1219\":1}}],[\"导入\",{\"1\":{\"1172\":1}}],[\"导入店铺数据到\",{\"0\":{\"1171\":1}}],[\"导入前端工程\",{\"0\":{\"1096\":1}}],[\"导入后端项目\",{\"0\":{\"1095\":1}}],[\"导入sql\",{\"0\":{\"1093\":1}}],[\"导入黑马点评项目\",{\"0\":{\"1092\":1}}],[\"导入数据时把数据文件拷贝至hdfs不进行处理\",{\"1\":{\"427\":1}}],[\"导入数据到student\",{\"1\":{\"276\":1}}],[\"导入jackson依赖\",{\"1\":{\"104\":1}}],[\"导入依赖范围\",{\"1\":{\"100\":1}}],[\"导致他的锁自动释放\",{\"1\":{\"1143\":1}}],[\"导致大量请求到达数据库\",{\"1\":{\"1125\":1}}],[\"导致大作业无法运行\",{\"1\":{\"189\":1}}],[\"导致缓存失效\",{\"1\":{\"1113\":1}}],[\"导致其操作线程无法及时处理信息而瘫痪\",{\"1\":{\"1113\":1}}],[\"导致不必要的系统开销\",{\"1\":{\"1042\":1}}],[\"导致不断空轮询\",{\"1\":{\"742\":1}}],[\"导致系统混乱\",{\"1\":{\"882\":1}}],[\"导致整个系统不可用\",{\"1\":{\"882\":1}}],[\"导致整体的进度卡在99\",{\"1\":{\"462\":1}}],[\"导致整体性能较差\",{\"1\":{\"424\":1}}],[\"导致每个元素的空间都要重新分配\",{\"1\":{\"666\":1}}],[\"导致每一数据的查询效率相当\",{\"1\":{\"488\":1}}],[\"导致一直无法获得资源的现象\",{\"1\":{\"553\":1}}],[\"导致redis实例卡死\",{\"1\":{\"529\":1}}],[\"导致事务需要回滚\",{\"1\":{\"506\":1}}],[\"导致索引失效\",{\"1\":{\"481\":1}}],[\"导致资源的浪费\",{\"1\":{\"435\":1}}],[\"导致了大量的磁盘和网络的io的损耗\",{\"1\":{\"414\":1}}],[\"导致多道程序并发度下降\",{\"1\":{\"189\":1}}],[\"导致低地址出现很多小的难以利用的空闲区\",{\"1\":{\"183\":1}}],[\"导致各进程都阻塞\",{\"1\":{\"175\":1}}],[\"导致状态转移不完整\",{\"1\":{\"161\":1}}],[\"导致\",{\"1\":{\"101\":2,\"1042\":1,\"1285\":1}}],[\"导致无法连接至\",{\"1\":{\"101\":1}}],[\"导致该方法的执行效果特别低\",{\"1\":{\"66\":1}}],[\"仓库缓存\",{\"1\":{\"101\":1}}],[\"仓库服务器状态\",{\"1\":{\"101\":1}}],[\"仓库或缓存被污染或损坏\",{\"1\":{\"101\":1}}],[\"仓库\",{\"1\":{\"101\":1}}],[\"仓库的本地依赖\",{\"1\":{\"100\":1}}],[\"仓库自动下载和管理依赖\",{\"1\":{\"97\":1}}],[\"驱动实现依赖\",{\"1\":{\"100\":1}}],[\"有如下区别\",{\"1\":{\"1455\":1}}],[\"有如下几种方案\",{\"1\":{\"1120\":1}}],[\"有循环依赖时\",{\"1\":{\"1336\":1}}],[\"有几种\",{\"1\":{\"1293\":1}}],[\"有几个reducetask\",{\"1\":{\"968\":1}}],[\"有几个哈希函数得到几个哈希值\",{\"1\":{\"659\":1}}],[\"有user和product两种不同类型的数据\",{\"1\":{\"1207\":1}}],[\"有很大差异的一种特殊的数据库\",{\"1\":{\"1184\":1}}],[\"有很大差异的一种数据库\",{\"1\":{\"1182\":1}}],[\"有小于0\",{\"1\":{\"1179\":1}}],[\"有交集并集补集的api\",{\"1\":{\"1165\":1}}],[\"有安全隐患\",{\"1\":{\"1149\":1}}],[\"有关池化思想\",{\"1\":{\"1214\":1}}],[\"有关代码实操说明\",{\"1\":{\"1144\":1}}],[\"有关锁失效原因分析\",{\"1\":{\"1138\":1}}],[\"有关超卖问题分析\",{\"1\":{\"1135\":1}}],[\"有关当前模型\",{\"0\":{\"1094\":1}}],[\"有用户有时间我们就可以组织出对应的\",{\"1\":{\"1176\":1}}],[\"有用户\",{\"1\":{\"1111\":1}}],[\"有新的\",{\"1\":{\"1037\":1}}],[\"有新的问题\",{\"1\":{\"826\":1}}],[\"有副作用\",{\"1\":{\"1004\":2}}],[\"有多次这样的溢写发生\",{\"1\":{\"979\":1}}],[\"有多少个split就对应启动多少个maptask\",{\"1\":{\"979\":1}}],[\"有个技术叫做unix\",{\"1\":{\"872\":1}}],[\"有助于\",{\"1\":{\"855\":1}}],[\"有事件\",{\"1\":{\"840\":1}}],[\"有因为发送能力弱\",{\"1\":{\"831\":1}}],[\"有因为接收能力弱\",{\"1\":{\"831\":1}}],[\"有可写事件才去写入\",{\"1\":{\"828\":1}}],[\"有可读事件才去读取\",{\"1\":{\"828\":1}}],[\"有可连接事件时才去连接\",{\"1\":{\"828\":1}}],[\"有可能会出现重复消费\",{\"1\":{\"1053\":1}}],[\"有可能会出现\",{\"1\":{\"1034\":1}}],[\"有可能会一条消息被发送了多次\",{\"1\":{\"1027\":1}}],[\"有可能会造成程序运行终止\",{\"1\":{\"662\":1}}],[\"有可能造成事故\",{\"1\":{\"482\":1}}],[\"有以下重要属性\",{\"1\":{\"798\":1}}],[\"有些文章提到有\",{\"1\":{\"1290\":1}}],[\"有些同学看到这里会有疑问\",{\"1\":{\"755\":1}}],[\"有些地方也称这种io方式为事件驱动io\",{\"1\":{\"679\":1}}],[\"有\",{\"1\":{\"742\":2,\"861\":2,\"1333\":2,\"1460\":1,\"1489\":1}}],[\"有任务\",{\"1\":{\"741\":1}}],[\"有没有问题\",{\"1\":{\"839\":2}}],[\"有没有\",{\"1\":{\"741\":1}}],[\"有限时阻塞\",{\"1\":{\"742\":1}}],[\"有限制\",{\"1\":{\"714\":1}}],[\"有限等待三个原则\",{\"1\":{\"169\":1}}],[\"有限等待\",{\"1\":{\"168\":1}}],[\"有协议为证\",{\"1\":{\"709\":1}}],[\"有五个物理块\",{\"1\":{\"690\":1}}],[\"有主程序段main\",{\"1\":{\"683\":1}}],[\"有数据可读\",{\"1\":{\"680\":1}}],[\"有点类似于数组\",{\"1\":{\"665\":1}}],[\"有竞争发生\",{\"1\":{\"579\":1}}],[\"有返回值返回一个future的对象\",{\"1\":{\"575\":1}}],[\"有界阻塞队列\",{\"1\":{\"572\":1}}],[\"有序\",{\"1\":{\"1209\":1}}],[\"有序递增\",{\"1\":{\"1000\":1}}],[\"有序性\",{\"1\":{\"556\":1}}],[\"有序集合或哈希表类型的key\",{\"1\":{\"523\":1}}],[\"有大量重复数据的列\",{\"1\":{\"494\":1}}],[\"有id=100的值有900条\",{\"1\":{\"455\":1}}],[\"有map和reducetask\",{\"1\":{\"435\":1}}],[\"有两个线程\",{\"1\":{\"1138\":1}}],[\"有两个主要原因\",{\"1\":{\"1067\":1}}],[\"有两个\",{\"1\":{\"779\":1}}],[\"有两张表\",{\"1\":{\"348\":1}}],[\"有两种办法\",{\"1\":{\"802\":1}}],[\"有两种共享存储的方式\",{\"1\":{\"162\":1}}],[\"有两种方式\",{\"1\":{\"68\":1}}],[\"有一定的规范\",{\"1\":{\"1207\":1}}],[\"有一点类似于\",{\"1\":{\"861\":1}}],[\"有一普通文本文件\",{\"1\":{\"796\":1}}],[\"有一些数据量不大的表也会转换为mapreduce处理\",{\"1\":{\"444\":1}}],[\"有一份数据the\",{\"1\":{\"348\":1}}],[\"有一个单例对象\",{\"1\":{\"1294\":1}}],[\"有一个商品id恰好也是1\",{\"1\":{\"1207\":1}}],[\"有一个用户id是1\",{\"1\":{\"1207\":1}}],[\"有一个额外的线程持有锁去进行重构数据\",{\"1\":{\"1126\":1}}],[\"有一个故障转移机制是非常有用并且是强烈推荐的\",{\"1\":{\"1067\":1}}],[\"有一个文本文件\",{\"1\":{\"807\":1}}],[\"有一个结果需要从一个线程传递到另一个线程\",{\"1\":{\"547\":1}}],[\"有一个数据文件tab1\",{\"1\":{\"285\":1}}],[\"有一个代码段中有很多变量\",{\"1\":{\"187\":1}}],[\"有了控制反转\",{\"1\":{\"1499\":1}}],[\"有了这个\",{\"1\":{\"1355\":1}}],[\"有了\",{\"1\":{\"1267\":1}}],[\"有了池化\",{\"1\":{\"770\":1}}],[\"有了metastore服务\",{\"1\":{\"240\":1}}],[\"有了中断才能实现多道程序并发执行\",{\"1\":{\"157\":1}}],[\"有结构文件\",{\"1\":{\"195\":1}}],[\"有内部碎片\",{\"1\":{\"182\":1}}],[\"有的返回值处理器调用了\",{\"1\":{\"1438\":1}}],[\"有的计算机会让这些寄存器占用内存地址的一部分\",{\"1\":{\"208\":1}}],[\"有的系统还会考虑进程在内存中的驻留时间\",{\"1\":{\"181\":1}}],[\"有的进程可能需要同时做很多事情\",{\"1\":{\"163\":1}}],[\"有何作用\",{\"1\":{\"179\":1}}],[\"有时候不清楚\",{\"1\":{\"775\":1}}],[\"有时候我们需要对某个字段进行去重\",{\"1\":{\"493\":1}}],[\"有时候stage彼此之间有依赖关系\",{\"1\":{\"446\":1}}],[\"有时候等待cpu的服务\",{\"1\":{\"160\":1}}],[\"有时会有这样的需求\",{\"1\":{\"364\":1}}],[\"有时是程序员故意为之\",{\"1\":{\"175\":1}}],[\"有时是因为程序bug导致的\",{\"1\":{\"175\":1}}],[\"有时进程正在被cpu处理\",{\"1\":{\"160\":1}}],[\"有效期到期时该key会被自动删除\",{\"1\":{\"1205\":1}}],[\"有效访问时间为第一次访间\",{\"1\":{\"683\":1}}],[\"有效的减少内存分配次数\",{\"1\":{\"663\":1}}],[\"有效的请求才会启动线程\",{\"1\":{\"611\":1}}],[\"有效\",{\"1\":{\"100\":3}}],[\"均以utf\",{\"1\":{\"482\":1}}],[\"均会被引入\",{\"1\":{\"100\":1}}],[\"均有效\",{\"1\":{\"100\":1}}],[\"47\",{\"0\":{\"1486\":1}}],[\"47499c2a\",{\"1\":{\"765\":2}}],[\"42\",{\"0\":{\"1466\":1}}],[\"4294967294\",{\"1\":{\"820\":1}}],[\"4种解决方法\",{\"0\":{\"1295\":1}}],[\"4来执行我们接下来的任务了\",{\"1\":{\"1156\":1}}],[\"4~7\",{\"1\":{\"953\":1}}],[\"4k\",{\"1\":{\"841\":2}}],[\"48\",{\"0\":{\"1490\":1},\"1\":{\"748\":5}}],[\"484c54717461b527d7e199d942448f1\",{\"1\":{\"186\":1}}],[\"4b\",{\"1\":{\"698\":1,\"748\":2}}],[\"41\",{\"0\":{\"1452\":1},\"1\":{\"694\":1,\"762\":1}}],[\"4999\",{\"1\":{\"1089\":1,\"1186\":1,\"1207\":1}}],[\"49979\",{\"1\":{\"699\":17}}],[\"49\",{\"0\":{\"1494\":1},\"1\":{\"693\":2,\"761\":3}}],[\"46\",{\"0\":{\"1481\":1},\"1\":{\"692\":2}}],[\"4352\",{\"1\":{\"694\":1}}],[\"43\",{\"0\":{\"1469\":1},\"1\":{\"615\":1,\"693\":2}}],[\"4之前唯一的选择\",{\"1\":{\"612\":1}}],[\"4开始支持\",{\"1\":{\"612\":1}}],[\"4开始\",{\"1\":{\"610\":1}}],[\"4释放了锁\",{\"1\":{\"591\":1}}],[\"4=\",{\"1\":{\"369\":1}}],[\"4个bucket\",{\"1\":{\"369\":1}}],[\"4<\",{\"1\":{\"344\":1,\"957\":5,\"985\":1}}],[\"446943\",{\"1\":{\"1021\":1}}],[\"4444\",{\"1\":{\"615\":1}}],[\"44\",{\"0\":{\"1473\":1},\"1\":{\"285\":1,\"332\":1,\"693\":7,\"857\":3,\"962\":2}}],[\"400\",{\"1\":{\"1224\":3}}],[\"401\",{\"1\":{\"1100\":1,\"1111\":1}}],[\"4095\",{\"1\":{\"999\":2}}],[\"40\",{\"0\":{\"1447\":1},\"1\":{\"265\":1,\"694\":1,\"748\":3}}],[\"40332004\",{\"1\":{\"145\":1}}],[\"45\",{\"0\":{\"1477\":1},\"1\":{\"191\":1,\"1080\":1}}],[\"4\",{\"0\":{\"100\":1,\"156\":1,\"178\":1,\"197\":1,\"228\":1,\"237\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"253\":1,\"254\":1,\"255\":1,\"267\":1,\"268\":1,\"290\":1,\"299\":1,\"305\":1,\"315\":1,\"323\":1,\"332\":1,\"339\":1,\"360\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"375\":1,\"389\":1,\"390\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"396\":1,\"397\":1,\"410\":1,\"423\":1,\"430\":1,\"438\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"471\":1,\"472\":1,\"473\":1,\"474\":1,\"728\":1,\"736\":1,\"771\":1,\"875\":1,\"877\":1,\"878\":1,\"879\":1,\"880\":1,\"904\":1,\"905\":1,\"924\":1,\"927\":1,\"950\":1,\"951\":1,\"952\":1,\"953\":1,\"964\":1,\"965\":1,\"966\":1,\"975\":1,\"976\":1,\"977\":1,\"991\":1,\"1018\":1,\"1019\":1,\"1020\":1,\"1021\":1,\"1043\":1,\"1064\":1,\"1073\":1,\"1078\":1,\"1086\":1,\"1087\":1,\"1088\":1,\"1089\":1,\"1096\":1,\"1100\":1,\"1122\":1,\"1134\":1,\"1139\":1,\"1140\":1,\"1141\":1,\"1142\":1,\"1143\":2,\"1144\":1,\"1145\":1,\"1146\":1,\"1147\":1,\"1152\":1,\"1162\":1,\"1167\":1,\"1177\":1,\"1188\":1,\"1195\":1,\"1198\":1,\"1199\":1,\"1200\":1,\"1201\":1,\"1202\":2,\"1207\":1,\"1212\":1,\"1213\":1,\"1214\":1,\"1215\":1,\"1216\":1,\"1224\":1,\"1261\":1},\"1\":{\"112\":3,\"113\":3,\"114\":3,\"115\":3,\"160\":1,\"162\":1,\"163\":1,\"168\":2,\"175\":1,\"176\":1,\"184\":1,\"256\":1,\"279\":1,\"280\":1,\"289\":1,\"309\":1,\"323\":1,\"331\":6,\"336\":1,\"338\":1,\"342\":4,\"344\":2,\"363\":3,\"369\":5,\"433\":1,\"444\":1,\"480\":1,\"541\":1,\"567\":1,\"591\":1,\"614\":1,\"620\":1,\"662\":1,\"663\":3,\"668\":1,\"690\":1,\"692\":2,\"693\":3,\"696\":1,\"697\":11,\"698\":11,\"699\":11,\"713\":5,\"714\":4,\"717\":2,\"718\":2,\"723\":5,\"726\":2,\"737\":1,\"740\":3,\"743\":1,\"748\":24,\"755\":5,\"759\":1,\"765\":2,\"766\":2,\"768\":1,\"770\":2,\"772\":6,\"773\":1,\"774\":7,\"776\":7,\"779\":5,\"780\":4,\"784\":2,\"785\":2,\"792\":1,\"796\":2,\"798\":2,\"799\":8,\"805\":2,\"807\":3,\"808\":4,\"826\":1,\"827\":1,\"836\":2,\"839\":1,\"840\":1,\"843\":2,\"848\":1,\"854\":1,\"855\":1,\"857\":1,\"876\":1,\"878\":2,\"879\":1,\"910\":1,\"936\":4,\"973\":1,\"974\":1,\"985\":2,\"986\":1,\"988\":1,\"1012\":6,\"1022\":1,\"1046\":12,\"1073\":6,\"1078\":1,\"1099\":1,\"1100\":1,\"1107\":2,\"1122\":3,\"1124\":3,\"1127\":6,\"1128\":2,\"1129\":11,\"1134\":1,\"1137\":1,\"1142\":1,\"1146\":1,\"1150\":1,\"1155\":1,\"1156\":1,\"1157\":3,\"1161\":3,\"1162\":6,\"1167\":3,\"1168\":5,\"1172\":4,\"1174\":1,\"1175\":1,\"1176\":1,\"1205\":1,\"1206\":1,\"1208\":12,\"1209\":2,\"1210\":1,\"1213\":1,\"1219\":3,\"1230\":1,\"1438\":2,\"1449\":1,\"1451\":1,\"1525\":1}}],[\"引用计数加一\",{\"1\":{\"776\":1}}],[\"引用计数\",{\"1\":{\"713\":1}}],[\"引用properties声明版本\",{\"1\":{\"99\":1}}],[\"引发了对\",{\"1\":{\"666\":1}}],[\"引发缓存雪崩甚至系统崩溃\",{\"1\":{\"530\":1}}],[\"引发所有子模块构建\",{\"1\":{\"108\":1}}],[\"引导块\",{\"1\":{\"206\":1}}],[\"引入自动配置类时\",{\"1\":{\"1466\":1}}],[\"引入自动配置\",{\"1\":{\"1464\":1}}],[\"引入spring\",{\"1\":{\"1221\":1}}],[\"引入依赖\",{\"0\":{\"1070\":1,\"1087\":1},\"1\":{\"1150\":1,\"1213\":1,\"1236\":1}}],[\"引入此类分配策略\",{\"1\":{\"1042\":1}}],[\"引入\",{\"1\":{\"667\":2}}],[\"引入了\",{\"1\":{\"723\":1,\"821\":1}}],[\"引入了窗口概念\",{\"1\":{\"694\":1}}],[\"引入了异步通道的概念\",{\"1\":{\"611\":1}}],[\"引入了进程\",{\"1\":{\"159\":1}}],[\"引入线程之后的变化\",{\"1\":{\"163\":1}}],[\"引入线程之后\",{\"1\":{\"163\":4}}],[\"引入线程后\",{\"1\":{\"163\":2}}],[\"引入具体的依赖包\",{\"1\":{\"99\":1}}],[\"引入第三方依赖\",{\"1\":{\"99\":1}}],[\"命中\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"命名空间可伸缩性\",{\"1\":{\"889\":1}}],[\"命名空间\",{\"1\":{\"888\":1}}],[\"命名随便\",{\"1\":{\"99\":1}}],[\"命令行\",{\"1\":{\"1446\":1}}],[\"命令行客户端\",{\"1\":{\"1198\":1}}],[\"命令不要死记\",{\"1\":{\"1204\":1}}],[\"命令名称\",{\"1\":{\"1146\":1}}],[\"命令来获取用户的所有用户组列表\",{\"1\":{\"924\":1}}],[\"命令启用策略集\",{\"1\":{\"875\":1}}],[\"命令执行是单线程操作\",{\"1\":{\"517\":1}}],[\"命令执行基于内存操作\",{\"1\":{\"517\":1}}],[\"命令接口\",{\"1\":{\"154\":1}}],[\"命令\",{\"1\":{\"95\":1,\"1172\":1,\"1196\":1,\"1205\":1}}],[\"命令方式项目构建\",{\"0\":{\"95\":1}}],[\"后获得\",{\"1\":{\"1333\":1}}],[\"后两种在\",{\"1\":{\"1317\":1}}],[\"后处理增强\",{\"1\":{\"1446\":1}}],[\"后处理\",{\"1\":{\"1444\":1}}],[\"后处理的添加顺序会对解析结果有影响\",{\"1\":{\"1248\":1}}],[\"后处理器对应上方两种情况\",{\"1\":{\"1285\":1}}],[\"后处理器对它做增强\",{\"1\":{\"1248\":1}}],[\"后处理器的作用\",{\"0\":{\"1269\":1}}],[\"后处理器运行分析\",{\"0\":{\"1265\":1}}],[\"后处理器来完成\",{\"1\":{\"1264\":1,\"1271\":1}}],[\"后处理器作用\",{\"0\":{\"1262\":1}}],[\"后处理器排序\",{\"0\":{\"1258\":1}}],[\"后处理器完成的\",{\"1\":{\"1248\":1}}],[\"后处理器\",{\"0\":{\"1261\":1,\"1268\":1},\"1\":{\"1248\":1,\"1252\":1,\"1255\":1,\"1453\":1}}],[\"后自动创建索引\",{\"1\":{\"1089\":1}}],[\"后端需要对这个全局id校验来保证幂等操作\",{\"1\":{\"1005\":1}}],[\"后端可以根据不同的状态去保证幂等性\",{\"1\":{\"1005\":1}}],[\"后端的幂等性如何实现\",{\"1\":{\"1005\":1}}],[\"后台查询出对应的数据再返回\",{\"1\":{\"1171\":1}}],[\"后台线程慢慢的去执行queue里边的消息\",{\"1\":{\"1155\":1}}],[\"后台通过jsessionid从session中拿到用户信息\",{\"1\":{\"1098\":1}}],[\"后台从session中拿到当前验证码\",{\"1\":{\"1098\":1}}],[\"后台此时生成对应的验证码\",{\"1\":{\"1098\":1}}],[\"后台不断从kms拉取新的edek到缓存中\",{\"1\":{\"934\":1}}],[\"后台启动metastore\",{\"1\":{\"244\":1}}],[\"后者功能上对标\",{\"1\":{\"1456\":1}}],[\"后者保存后将其复制到第三个数据节点\",{\"1\":{\"898\":1}}],[\"后者过去分词表示被动更新\",{\"1\":{\"480\":1}}],[\"后果是无服务\",{\"1\":{\"882\":1}}],[\"后提供的\",{\"1\":{\"855\":1}}],[\"后设置成功结果\",{\"1\":{\"761\":1}}],[\"后才能发送剩余部分\",{\"1\":{\"694\":1}}],[\"后\",{\"1\":{\"662\":1,\"775\":1,\"851\":1,\"953\":1,\"1438\":1}}],[\"后续再没有用到多例的\",{\"1\":{\"1294\":1}}],[\"后续操作中\",{\"1\":{\"1155\":1}}],[\"后续的线程2\",{\"1\":{\"1126\":1}}],[\"后续管理\",{\"1\":{\"924\":1}}],[\"后续不会再监听事件\",{\"1\":{\"838\":1}}],[\"后续出站处理器的执行\",{\"1\":{\"766\":1}}],[\"后续这个\",{\"1\":{\"746\":1}}],[\"后续版本中\",{\"0\":{\"640\":1}}],[\"后续数据准备\",{\"0\":{\"359\":1}}],[\"后续讲解\",{\"1\":{\"155\":1}}],[\"后插入\",{\"1\":{\"292\":1,\"293\":1}}],[\"后裔\",{\"1\":{\"256\":1}}],[\"后都没有相邻的空闲分区\",{\"1\":{\"182\":1}}],[\"后各有一个相邻的空闲分区\",{\"1\":{\"182\":1}}],[\"后面解释\",{\"1\":{\"1339\":1}}],[\"后面这些带有\",{\"1\":{\"1245\":1}}],[\"后面会详细展开\",{\"1\":{\"784\":1}}],[\"后面会讲解两个概念\",{\"1\":{\"98\":1}}],[\"后面在说明区别之处\",{\"1\":{\"663\":1}}],[\"后面进行具体阐述\",{\"1\":{\"261\":1}}],[\"后面讲解\",{\"1\":{\"186\":1}}],[\"后面不需要再排\",{\"1\":{\"183\":1}}],[\"后面的短作业需要等待很长时间\",{\"1\":{\"167\":1}}],[\"后一种情况就需要进程切换\",{\"1\":{\"165\":1}}],[\"后期如果再加新品种的咖啡\",{\"1\":{\"28\":1}}],[\"后期如果需要coffee对象直接从工厂中获取即可\",{\"1\":{\"28\":1}}],[\"被这些注解声明的类当被扫描到时就会创建对应的bean\",{\"1\":{\"1503\":1}}],[\"被装配的代理不作为\",{\"1\":{\"1489\":1}}],[\"被\",{\"1\":{\"1472\":1}}],[\"被称为slave\",{\"1\":{\"903\":1}}],[\"被称为master\",{\"1\":{\"903\":1}}],[\"被进行了重新组合\",{\"1\":{\"809\":1}}],[\"被固定为这个区间的大小\",{\"1\":{\"776\":1}}],[\"被引用了多少次\",{\"1\":{\"775\":1}}],[\"被连成一串\",{\"1\":{\"766\":1}}],[\"被唤醒后他又要再次遍历fd\",{\"1\":{\"680\":1}}],[\"被统称为nio\",{\"1\":{\"610\":1}}],[\"被程序语句获得的锁\",{\"1\":{\"499\":1}}],[\"被聚合函数应用的字段\",{\"1\":{\"306\":1}}],[\"被解释为正则表达式\",{\"1\":{\"302\":1}}],[\"被换出的进程数据就存放在对换区\",{\"1\":{\"181\":1}}],[\"被挂起的进程pcb会被放到挂起队列中\",{\"1\":{\"164\":1}}],[\"被管理的依赖并没有真正被引入到工程\",{\"1\":{\"107\":1}}],[\"被其他工程聚合或者继承\",{\"1\":{\"98\":1}}],[\"被评为三好学生\",{\"1\":{\"52\":1,\"54\":1}}],[\"默认作用域\",{\"1\":{\"1504\":1}}],[\"默认全部初始化并进行依赖注入\",{\"1\":{\"1501\":1}}],[\"默认采用延迟初始化策略\",{\"1\":{\"1501\":1}}],[\"默认就是\",{\"1\":{\"1462\":1}}],[\"默认映射路径为\",{\"1\":{\"1438\":1}}],[\"默认false\",{\"1\":{\"1236\":1}}],[\"默认启动\",{\"0\":{\"1195\":1},\"1\":{\"1194\":1}}],[\"默认类型为\",{\"1\":{\"1062\":1}}],[\"默认5000w\",{\"1\":{\"1021\":1}}],[\"默认512\",{\"1\":{\"870\":1}}],[\"默认key的字典序排序\",{\"1\":{\"980\":1}}],[\"默认对key\",{\"1\":{\"979\":1}}],[\"默认linerecordreader\",{\"1\":{\"979\":1}}],[\"默认lazysimpleserde\",{\"1\":{\"250\":2,\"251\":1}}],[\"默认根据key字典序排序\",{\"1\":{\"965\":1}}],[\"默认split\",{\"1\":{\"965\":1}}],[\"默认输出组件为\",{\"1\":{\"962\":1}}],[\"默认输入组件为textinputformat\",{\"1\":{\"962\":1}}],[\"默认组件\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"默认的安装路径是在\",{\"1\":{\"1193\":1}}],[\"默认的分配策略\",{\"1\":{\"1040\":1}}],[\"默认的分区策略就是随机策略\",{\"1\":{\"1033\":1}}],[\"默认的策略\",{\"1\":{\"1032\":1}}],[\"默认的规则可以保证只要map阶段输出的key一样\",{\"1\":{\"968\":1}}],[\"默认的权限就是\",{\"1\":{\"919\":1}}],[\"默认的打包名称\",{\"1\":{\"102\":1}}],[\"默认umask值有属性fs\",{\"1\":{\"919\":1}}],[\"默认副本存储策略是由blockplacementpolicydefault指定\",{\"1\":{\"900\":1}}],[\"默认三副本存储策略\",{\"0\":{\"900\":1}}],[\"默认rs\",{\"1\":{\"875\":1}}],[\"默认参数运行\",{\"1\":{\"873\":1}}],[\"默认0\",{\"1\":{\"870\":2}}],[\"默认30000毫秒\",{\"1\":{\"870\":1}}],[\"默认3\",{\"1\":{\"870\":1}}],[\"默认文件\",{\"1\":{\"858\":1}}],[\"默认开启\",{\"1\":{\"847\":1}}],[\"默认习惯是\",{\"1\":{\"772\":1}}],[\"默认以\",{\"1\":{\"698\":1}}],[\"默认有16个库\",{\"1\":{\"1196\":1}}],[\"默认有如下数据\",{\"1\":{\"615\":1}}],[\"默认有一个根目录\",{\"1\":{\"234\":1}}],[\"默认1\",{\"1\":{\"601\":1,\"870\":1}}],[\"默认使用hashpartitioner\",{\"1\":{\"979\":1}}],[\"默认使用的是rbo优化器引擎\",{\"1\":{\"457\":1}}],[\"默认使用distinct删除重复行\",{\"1\":{\"315\":1}}],[\"默认用9999\",{\"1\":{\"405\":1}}],[\"默认为空\",{\"1\":{\"1196\":1}}],[\"默认为\",{\"1\":{\"744\":1,\"1411\":1}}],[\"默认为flow\",{\"1\":{\"719\":1}}],[\"默认为false\",{\"1\":{\"446\":1}}],[\"默认为0\",{\"1\":{\"579\":1,\"606\":1}}],[\"默认为5\",{\"1\":{\"535\":1}}],[\"默认为8\",{\"1\":{\"446\":1,\"605\":1}}],[\"默认为10\",{\"1\":{\"873\":1}}],[\"默认为16\",{\"1\":{\"606\":1}}],[\"默认为1\",{\"1\":{\"365\":2}}],[\"默认为true\",{\"1\":{\"276\":1,\"1028\":1}}],[\"默认累积聚合行为是\",{\"1\":{\"361\":1}}],[\"默认是采用jdk序列化\",{\"1\":{\"1222\":1}}],[\"默认是6379\",{\"1\":{\"1199\":1}}],[\"默认是当前目录\",{\"1\":{\"1196\":1}}],[\"默认是7天过期\",{\"1\":{\"1056\":1}}],[\"默认是按行读取数据\",{\"1\":{\"965\":1}}],[\"默认是3秒\",{\"1\":{\"903\":1}}],[\"默认是3副本存储\",{\"1\":{\"901\":1}}],[\"默认是127\",{\"1\":{\"1196\":1,\"1199\":1}}],[\"默认是1个\",{\"1\":{\"988\":1}}],[\"默认是100mb\",{\"1\":{\"979\":1}}],[\"默认是1\",{\"1\":{\"901\":1}}],[\"默认是rs\",{\"1\":{\"875\":1}}],[\"默认是非池化实现\",{\"1\":{\"770\":1}}],[\"默认是\",{\"1\":{\"741\":1}}],[\"默认是窗口中所有行\",{\"1\":{\"358\":1}}],[\"默认是一行对应一条键值对\",{\"1\":{\"250\":1}}],[\"默认asc\",{\"1\":{\"312\":1}}],[\"默认不带\",{\"1\":{\"1442\":1}}],[\"默认不允许跨\",{\"1\":{\"1243\":1}}],[\"默认不再支持自定义索引类型\",{\"1\":{\"1062\":1}}],[\"默认不分区\",{\"1\":{\"965\":1}}],[\"默认不开启\",{\"1\":{\"908\":1}}],[\"默认不写为all\",{\"1\":{\"303\":1}}],[\"默认不会被打包\",{\"1\":{\"102\":1}}],[\"默认触发条件为delta文件相应于基础文件占比\",{\"1\":{\"294\":1}}],[\"默认触发条件为10个delta文件\",{\"1\":{\"294\":1}}],[\"默认已经开启了动态分区功能\",{\"1\":{\"289\":1}}],[\"默认值022\",{\"1\":{\"919\":1}}],[\"默认值\",{\"1\":{\"380\":2,\"1065\":1,\"1362\":1}}],[\"默认值是1024\",{\"1\":{\"680\":1}}],[\"默认值是\",{\"1\":{\"254\":1}}],[\"默认值为空\",{\"1\":{\"880\":2}}],[\"默认值为\",{\"1\":{\"234\":1}}],[\"默认存储路径\",{\"0\":{\"254\":1}}],[\"默认hiveignorekeytextoutputformat\",{\"1\":{\"250\":1}}],[\"默认textinputformat\",{\"1\":{\"250\":1,\"979\":1}}],[\"默认数据库default\",{\"1\":{\"234\":1}}],[\"默认情况下第一种形式不启用\",{\"1\":{\"980\":1}}],[\"默认情况下启用rs\",{\"1\":{\"875\":1}}],[\"默认情况下所有的socket都是blocking\",{\"1\":{\"679\":1}}],[\"默认情况下事务配置为关闭\",{\"1\":{\"267\":1}}],[\"默认情况下\",{\"1\":{\"102\":2,\"418\":1,\"663\":1,\"874\":1,\"924\":1,\"984\":1,\"1067\":1,\"1504\":1}}],[\"默认\",{\"1\":{\"98\":1,\"258\":1,\"694\":1,\"742\":1,\"744\":1,\"921\":1,\"963\":1}}],[\"总会被执行\",{\"1\":{\"1284\":1}}],[\"总销售量\",{\"1\":{\"985\":1}}],[\"总是运行完所有非\",{\"1\":{\"741\":1}}],[\"总是淘汰最先进入内存的页面\",{\"1\":{\"690\":1}}],[\"总的来说\",{\"1\":{\"663\":1}}],[\"总的平均存储时间ta​=ts​+2r1​+rnb​\",{\"1\":{\"204\":1}}],[\"总运行时间\",{\"1\":{\"637\":1}}],[\"总结\",{\"0\":{\"612\":1,\"1189\":1},\"1\":{\"651\":1,\"658\":1,\"680\":1,\"683\":1}}],[\"总结一下\",{\"1\":{\"477\":1}}],[\"总结如下\",{\"1\":{\"88\":1,\"1189\":1}}],[\"总共指定生产数据量\",{\"1\":{\"1021\":1}}],[\"总共8种\",{\"1\":{\"522\":1}}],[\"总共500个小文件\",{\"1\":{\"478\":1}}],[\"总共有四种用法\",{\"1\":{\"360\":1}}],[\"总共需要跨越n个磁道\",{\"1\":{\"204\":1}}],[\"总个数是2n\",{\"1\":{\"352\":1}}],[\"总冠军年份之间以|进行分割\",{\"1\":{\"348\":1}}],[\"总之对换区的i\",{\"1\":{\"181\":1}}],[\"总之\",{\"1\":{\"97\":1,\"1003\":1,\"1067\":1,\"1525\":1}}],[\"安全也是程序中必不可少的一环\",{\"1\":{\"1140\":1}}],[\"安全模式下系统可读不可写\",{\"1\":{\"870\":1}}],[\"安全模式\",{\"0\":{\"870\":1}}],[\"安全性不高\",{\"1\":{\"501\":1}}],[\"安全性\",{\"1\":{\"244\":1,\"1140\":2}}],[\"安全\",{\"1\":{\"154\":1}}],[\"安全门案例\",{\"1\":{\"75\":1}}],[\"安装完成redis\",{\"1\":{\"1198\":1}}],[\"安装完成后\",{\"1\":{\"1195\":1,\"1201\":1}}],[\"安装redis\",{\"0\":{\"1191\":1}}],[\"安装\",{\"0\":{\"1201\":1},\"1\":{\"1046\":1}}],[\"安装kafka\",{\"0\":{\"1046\":1}}],[\"安装yasm和nasm\",{\"1\":{\"876\":1}}],[\"安装到本地仓库\",{\"1\":{\"95\":1}}],[\"安装是将当前工程所生成的jar或war文件\",{\"1\":{\"95\":1}}],[\"描述了这个\",{\"1\":{\"1248\":1}}],[\"描述了产品的主要特性和功能\",{\"1\":{\"27\":1,\"33\":1,\"38\":1}}],[\"描述数据库信息\",{\"1\":{\"278\":1}}],[\"描述\",{\"1\":{\"95\":1,\"100\":1,\"571\":1,\"610\":1}}],[\"等特殊类型\",{\"1\":{\"1489\":1}}],[\"等工具实现\",{\"1\":{\"1440\":1}}],[\"等设置选择\",{\"1\":{\"1322\":1}}],[\"等注解中的参数名\",{\"1\":{\"1362\":1}}],[\"等注解失效\",{\"1\":{\"1285\":1}}],[\"等注解的解析属于核心容器\",{\"1\":{\"1271\":1}}],[\"等注解的解析属于\",{\"1\":{\"1264\":1}}],[\"等注解的解析都是\",{\"1\":{\"1248\":1}}],[\"等注解\",{\"1\":{\"1248\":1}}],[\"等于0说明可以释放锁\",{\"1\":{\"1151\":1}}],[\"等于容量\",{\"1\":{\"798\":1}}],[\"等都是可使用的\",{\"1\":{\"1001\":1}}],[\"等都是无限等待的\",{\"1\":{\"725\":1}}],[\"等遇到字符为\",{\"1\":{\"662\":1}}],[\"等等\",{\"1\":{\"660\":1,\"1135\":1,\"1248\":1,\"1525\":1}}],[\"等数据结构\",{\"1\":{\"658\":1}}],[\"等方法进行修改\",{\"1\":{\"574\":1}}],[\"等完成对共享变量的操作时再save到主内存\",{\"1\":{\"560\":1}}],[\"等到操作共享变量的时候才加锁\",{\"1\":{\"551\":1}}],[\"等到遍历的单词和上一个单词不同的话\",{\"1\":{\"478\":1}}],[\"等读写完毕\",{\"1\":{\"538\":1}}],[\"等分组聚合的场景时\",{\"1\":{\"463\":1}}],[\"等价于将不同维度的group\",{\"1\":{\"352\":1}}],[\"等价于对这两个数据集合分别进行左外连接和右外连接\",{\"1\":{\"323\":1}}],[\"等价于\",{\"1\":{\"320\":2,\"321\":1,\"322\":1,\"323\":1,\"353\":2,\"354\":1}}],[\"等它重新具备运行条件并且内存有空闲\",{\"1\":{\"164\":1}}],[\"等待一定时间后重试即可\",{\"1\":{\"1141\":1}}],[\"等待再次查询时\",{\"1\":{\"1121\":1}}],[\"等待namenode确认\",{\"1\":{\"901\":1}}],[\"等待下次继续选举\",{\"1\":{\"885\":1}}],[\"等待datanodes汇报可用的block信息\",{\"1\":{\"870\":1}}],[\"等待数据阶段\",{\"1\":{\"851\":1}}],[\"等待数据准备\",{\"1\":{\"679\":1}}],[\"等待结果\",{\"1\":{\"757\":1,\"758\":1,\"759\":1}}],[\"等待任务结束\",{\"1\":{\"756\":2}}],[\"等待后续操作\",{\"1\":{\"702\":1}}],[\"等待\",{\"1\":{\"694\":1,\"737\":1,\"761\":1}}],[\"等待线程满足某个计数\",{\"1\":{\"593\":1}}],[\"等待所有线程完成倒计时后再恢复运行\",{\"1\":{\"592\":1}}],[\"等待所释放后唤醒下一个排队的线程\",{\"1\":{\"583\":1}}],[\"等待占有锁的线程释放后被唤醒\",{\"1\":{\"584\":1}}],[\"等待图\",{\"1\":{\"513\":1}}],[\"等待资源分配\",{\"1\":{\"444\":1}}],[\"等待i\",{\"1\":{\"209\":1}}],[\"等待当前访问临界资源的进程结束才可以访问\",{\"1\":{\"168\":1}}],[\"等待时间长的邮箱\",{\"1\":{\"167\":1}}],[\"等待时间相同时\",{\"1\":{\"167\":1}}],[\"等待时间为\",{\"1\":{\"166\":1}}],[\"等待时间就是进程建立以后等待被服务的时间之和\",{\"1\":{\"166\":1}}],[\"等待时间\",{\"1\":{\"166\":1,\"167\":1}}],[\"等待读进程将数据取走\",{\"1\":{\"162\":1}}],[\"等待读取磁盘\",{\"1\":{\"160\":1}}],[\"等待分配打印机\",{\"1\":{\"160\":1}}],[\"等\",{\"1\":{\"94\":1,\"566\":1,\"723\":1,\"741\":1,\"951\":1,\"1264\":1,\"1355\":1,\"1362\":1,\"1451\":1,\"1499\":2,\"1501\":1}}],[\"基准测试\",{\"0\":{\"1019\":1},\"1\":{\"1019\":1}}],[\"基础\",{\"0\":{\"1059\":1,\"1181\":1}}],[\"基础操作\",{\"0\":{\"1014\":1}}],[\"基础编程\",{\"0\":{\"967\":1}}],[\"基础入门\",{\"0\":{\"954\":1}}],[\"基础值\",{\"1\":{\"564\":1}}],[\"基础聚合\",{\"0\":{\"351\":1}}],[\"基础数据\",{\"1\":{\"292\":1}}],[\"基础建表语法联系\",{\"0\":{\"256\":1}}],[\"基址\",{\"1\":{\"187\":1}}],[\"基地址变换机构可以借助页表将逻辑地址变换为物理地址\",{\"1\":{\"185\":1}}],[\"基地址变换机构\",{\"0\":{\"185\":1}}],[\"基于内存\",{\"1\":{\"1190\":1}}],[\"基于该表数据结构\",{\"1\":{\"1164\":1}}],[\"基于阻塞队列的异步秒杀存在哪些问题\",{\"1\":{\"1157\":1}}],[\"基于阻塞队列实现秒杀优化\",{\"0\":{\"1157\":1}}],[\"基于\",{\"1\":{\"1149\":1,\"1156\":1,\"1245\":2,\"1513\":1}}],[\"基于spring框架的项目\",{\"1\":{\"1520\":1}}],[\"基于stringredistemplate封装一个缓存工具类\",{\"1\":{\"1129\":1}}],[\"基于session实现登录流程\",{\"0\":{\"1098\":1}}],[\"基于逻辑过期方式来解决缓存击穿问题\",{\"1\":{\"1128\":1}}],[\"基于token获取redis中的用户\",{\"1\":{\"1111\":1}}],[\"基于redis的分布式锁实现思路\",{\"1\":{\"1147\":1}}],[\"基于redis实现短信登录\",{\"0\":{\"1107\":1}}],[\"基于rpc进行远程调用就像本地调用一样\",{\"1\":{\"949\":1}}],[\"基于时间戳\",{\"1\":{\"1000\":1}}],[\"基于事件驱动的网络应用框架\",{\"1\":{\"789\":1}}],[\"基于这一点\",{\"1\":{\"689\":1}}],[\"基于局部性原理可知\",{\"1\":{\"688\":1}}],[\"基于hashmap实现\",{\"1\":{\"604\":1}}],[\"基于死磕\",{\"1\":{\"580\":1}}],[\"基于io多路复用机制\",{\"1\":{\"517\":1}}],[\"基于idea\",{\"0\":{\"96\":1}}],[\"基于idea进行maven工程构建\",{\"0\":{\"93\":1}}],[\"基于跳表实现\",{\"1\":{\"515\":1}}],[\"基于undo\",{\"1\":{\"503\":1}}],[\"基于代价的优化器\",{\"1\":{\"457\":1}}],[\"基于规则的优化器\",{\"1\":{\"456\":1}}],[\"基于有序数据的join\",{\"1\":{\"450\":1}}],[\"基于分桶表抽样\",{\"0\":{\"369\":1}}],[\"基于分桶字段查询可以减少全表扫描\",{\"1\":{\"263\":1}}],[\"基于数据块抽样\",{\"0\":{\"368\":1}}],[\"基于数据结构的共享\",{\"1\":{\"162\":1}}],[\"基于apache\",{\"1\":{\"274\":1}}],[\"基于表提供了一种类似sql的查询模型\",{\"1\":{\"229\":1}}],[\"基于上层的应用和产品的指标需求\",{\"1\":{\"226\":1}}],[\"基于维度建模理念思想\",{\"1\":{\"226\":1}}],[\"基于符号链的共享方式\",{\"1\":{\"200\":1}}],[\"基于索引节点的共享方式\",{\"1\":{\"200\":1}}],[\"基于存储区的共享\",{\"1\":{\"162\":1}}],[\"基本结构\",{\"1\":{\"1447\":1}}],[\"基本的类型转换与数据绑定用法\",{\"1\":{\"1373\":1}}],[\"基本的依赖注入\",{\"1\":{\"1243\":1}}],[\"基本原理和实现方式对比\",{\"0\":{\"1140\":1}}],[\"基本概念\",{\"0\":{\"1060\":1}}],[\"基本保证\",{\"1\":{\"1000\":1}}],[\"基本规则是\",{\"1\":{\"775\":1}}],[\"基本不使用\",{\"1\":{\"522\":1}}],[\"基本思想\",{\"1\":{\"459\":1,\"634\":1}}],[\"基本操作\",{\"0\":{\"284\":1,\"287\":1}}],[\"基本语法\",{\"0\":{\"264\":1}}],[\"基本分段存储管理方式\",{\"0\":{\"187\":1}}],[\"基本分页存储管理的思想\",{\"1\":{\"184\":1}}],[\"基本分页存储管理的基本概念\",{\"0\":{\"184\":1}}],[\"基本方法又可以分为三种\",{\"1\":{\"84\":1}}],[\"基本方法\",{\"1\":{\"84\":1}}],[\"基本上不用修改之前已经测试通过的代码\",{\"1\":{\"15\":1}}],[\"二十二岁的林朝夕在父亲确诊阿尔茨海默病这天\",{\"1\":{\"1525\":1}}],[\"二狗\",{\"1\":{\"1210\":1}}],[\"二阶段事务提交方式\",{\"1\":{\"1053\":1}}],[\"二者成员变量并不共用数据\",{\"1\":{\"1480\":1}}],[\"二者均为全双工\",{\"1\":{\"850\":1}}],[\"二者互为存在的条件\",{\"1\":{\"155\":1}}],[\"二级页表\",{\"1\":{\"683\":1}}],[\"二叉树构建\",{\"0\":{\"669\":1}}],[\"二是效率低\",{\"1\":{\"483\":1}}],[\"二进制程序等\",{\"1\":{\"953\":1}}],[\"二进制安全\",{\"1\":{\"663\":1}}],[\"二进制表示\",{\"1\":{\"353\":1}}],[\"二进制函数\",{\"1\":{\"338\":2}}],[\"二元运算符有两个操作数\",{\"1\":{\"331\":1}}],[\"二\",{\"0\":{\"93\":1}}],[\"5p\",{\"1\":{\"1022\":1}}],[\"5l\",{\"1\":{\"999\":2,\"1089\":1}}],[\"56303b57\",{\"1\":{\"1294\":1}}],[\"56\",{\"1\":{\"857\":3}}],[\"5622464513\",{\"1\":{\"820\":1}}],[\"5612\",{\"1\":{\"265\":1}}],[\"57\",{\"1\":{\"764\":1}}],[\"57351\",{\"1\":{\"753\":1}}],[\"57191\",{\"1\":{\"753\":1}}],[\"59\",{\"1\":{\"726\":1,\"836\":3}}],[\"59221\",{\"1\":{\"693\":7}}],[\"5s\",{\"1\":{\"707\":2}}],[\"58063\",{\"1\":{\"1236\":1}}],[\"58\",{\"1\":{\"726\":1,\"764\":2,\"972\":1,\"973\":1}}],[\"58177\",{\"1\":{\"692\":5}}],[\"588\",{\"1\":{\"256\":1}}],[\"5字节的空间进行编码\",{\"1\":{\"665\":1}}],[\"5e6+5\",{\"1\":{\"646\":1}}],[\"5倍长度进行扩容\",{\"1\":{\"601\":1}}],[\"5也来执行synchronized\",{\"1\":{\"541\":1}}],[\"513\",{\"1\":{\"773\":1}}],[\"512mb\",{\"1\":{\"1196\":1}}],[\"512m\",{\"1\":{\"1174\":1}}],[\"512\",{\"1\":{\"343\":2,\"742\":1,\"773\":2}}],[\"51\",{\"1\":{\"265\":1,\"697\":2,\"699\":1,\"760\":4}}],[\"5555\",{\"1\":{\"615\":1}}],[\"5554\",{\"1\":{\"265\":1}}],[\"55\",{\"1\":{\"285\":1,\"692\":5}}],[\"55行\",{\"1\":{\"92\":1}}],[\"52625\",{\"1\":{\"748\":6}}],[\"52612\",{\"1\":{\"748\":6}}],[\"52588\",{\"1\":{\"748\":6}}],[\"52\",{\"1\":{\"256\":2,\"337\":8}}],[\"52∗52三个尺度的特征\",{\"1\":{\"138\":1}}],[\"54\",{\"1\":{\"256\":1,\"760\":2,\"762\":1,\"763\":2,\"765\":2}}],[\"541a75aa1efce984b24df67aea29aa4\",{\"1\":{\"185\":1}}],[\"53155\",{\"1\":{\"697\":17}}],[\"53\",{\"0\":{\"136\":1},\"1\":{\"256\":2,\"615\":2,\"726\":2,\"760\":2,\"763\":2}}],[\"5ca3e9b122f61f8f06494c97b1afccf3\",{\"1\":{\"124\":2}}],[\"5\",{\"0\":{\"101\":1,\"157\":1,\"179\":1,\"198\":1,\"256\":1,\"269\":1,\"270\":1,\"271\":1,\"272\":1,\"300\":1,\"301\":1,\"302\":1,\"303\":1,\"304\":1,\"305\":1,\"306\":2,\"307\":1,\"308\":1,\"309\":1,\"310\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":2,\"317\":1,\"318\":1,\"324\":1,\"340\":1,\"361\":1,\"398\":1,\"399\":1,\"400\":1,\"401\":1,\"402\":1,\"403\":1,\"404\":1,\"424\":1,\"459\":1,\"460\":1,\"461\":1,\"729\":1,\"737\":1,\"772\":1,\"881\":1,\"882\":1,\"883\":1,\"884\":1,\"906\":1,\"925\":1,\"926\":1,\"928\":1,\"929\":1,\"936\":1,\"978\":1,\"979\":1,\"980\":1,\"1022\":1,\"1023\":1,\"1024\":1,\"1025\":1,\"1065\":1,\"1079\":1,\"1097\":1,\"1101\":1,\"1123\":1,\"1135\":1,\"1144\":1,\"1148\":1,\"1149\":1,\"1150\":1,\"1151\":1,\"1152\":1,\"1153\":2,\"1168\":1,\"1189\":1,\"1196\":1,\"1208\":1,\"1217\":1,\"1218\":1,\"1219\":1,\"1220\":1,\"1221\":1,\"1222\":1,\"1223\":1,\"1224\":1,\"1268\":1},\"1\":{\"110\":1,\"139\":1,\"160\":1,\"162\":1,\"163\":1,\"256\":1,\"265\":1,\"271\":1,\"279\":1,\"280\":1,\"309\":2,\"324\":1,\"336\":2,\"363\":3,\"369\":2,\"495\":1,\"529\":1,\"562\":4,\"567\":1,\"614\":1,\"620\":1,\"648\":2,\"660\":1,\"663\":5,\"665\":1,\"666\":3,\"667\":1,\"692\":2,\"693\":3,\"696\":1,\"697\":11,\"698\":23,\"699\":11,\"707\":1,\"713\":1,\"714\":1,\"717\":2,\"718\":2,\"723\":2,\"740\":1,\"743\":1,\"748\":6,\"755\":2,\"766\":2,\"772\":3,\"773\":1,\"774\":5,\"776\":11,\"779\":7,\"780\":6,\"784\":2,\"785\":3,\"791\":1,\"792\":1,\"796\":1,\"799\":1,\"805\":2,\"807\":4,\"808\":2,\"826\":1,\"827\":1,\"836\":2,\"840\":1,\"848\":1,\"857\":3,\"873\":1,\"878\":1,\"879\":1,\"973\":1,\"985\":2,\"986\":1,\"1024\":1,\"1062\":1,\"1073\":1,\"1079\":1,\"1099\":2,\"1100\":1,\"1101\":1,\"1107\":1,\"1111\":1,\"1122\":1,\"1128\":3,\"1129\":4,\"1134\":1,\"1135\":1,\"1137\":7,\"1142\":1,\"1150\":1,\"1155\":1,\"1156\":1,\"1157\":3,\"1162\":2,\"1167\":2,\"1168\":4,\"1172\":1,\"1175\":1,\"1176\":2,\"1206\":2,\"1208\":2,\"1209\":1,\"1210\":1,\"1219\":1,\"1236\":1,\"1449\":1,\"1499\":2}}],[\"5000000\",{\"1\":{\"1021\":1}}],[\"50000000\",{\"1\":{\"1021\":1}}],[\"500000l\",{\"1\":{\"742\":1}}],[\"500\",{\"1\":{\"477\":1,\"478\":1}}],[\"50\",{\"1\":{\"47\":1,\"340\":1,\"368\":1,\"699\":1,\"741\":1,\"748\":3,\"757\":1,\"772\":2,\"875\":2,\"999\":1,\"1081\":1,\"1127\":1,\"1129\":1}}],[\"$和\",{\"0\":{\"1230\":1}}],[\"$ke\",{\"1\":{\"1046\":1}}],[\"$path\",{\"1\":{\"1012\":1}}],[\"$pwd\",{\"1\":{\"878\":1,\"910\":2}}],[\"$proxy0\",{\"1\":{\"59\":8,\"1309\":4}}],[\"$3\",{\"1\":{\"710\":5}}],[\"$2\",{\"1\":{\"344\":1}}],[\"$1\",{\"1\":{\"344\":1}}],[\"$表示json对象\",{\"1\":{\"336\":1}}],[\"$\",{\"0\":{\"364\":2},\"1\":{\"92\":1,\"204\":1,\"235\":1,\"336\":1,\"344\":1,\"395\":5,\"869\":1,\"909\":2,\"936\":1,\"1012\":1,\"1045\":1,\"1230\":2,\"1248\":1,\"1284\":1,\"1362\":1,\"1411\":1,\"1482\":1,\"1485\":1,\"1525\":2}}],[\"xzf\",{\"1\":{\"1193\":1}}],[\"xcontenttype\",{\"1\":{\"1073\":5}}],[\"xdn12\",{\"1\":{\"1046\":1}}],[\"xdn11\",{\"1\":{\"1046\":1}}],[\"xvzf\",{\"1\":{\"1012\":1,\"1046\":2}}],[\"x权限将无法满足\",{\"1\":{\"925\":1}}],[\"xr\",{\"1\":{\"919\":1}}],[\"x个9表示在系统1年时间的使用过程中\",{\"1\":{\"882\":1}}],[\"x个9\",{\"1\":{\"882\":1}}],[\"x64aaa\",{\"1\":{\"823\":1}}],[\"x64\",{\"1\":{\"823\":1}}],[\"xiao\",{\"1\":{\"662\":1}}],[\"xiaolin\",{\"1\":{\"662\":1}}],[\"xiaolincoding\",{\"1\":{\"661\":1,\"664\":1}}],[\"xijieharddisk\",{\"1\":{\"74\":6}}],[\"x的值必须小于等于y的值\",{\"1\":{\"369\":1}}],[\"x表示从哪个bucket开始抽取\",{\"1\":{\"369\":1}}],[\"xx\",{\"1\":{\"286\":2,\"640\":1}}],[\"xxx的方式命名\",{\"1\":{\"480\":1}}],[\"xxx\",{\"1\":{\"258\":1,\"344\":1,\"629\":1}}],[\"x→∞lim​x222​−∫15​xdx+n=1∑20​n2=j=1∏3​yj​+x→−2lim​xx−2​\",{\"1\":{\"149\":1}}],[\"x\",{\"1\":{\"122\":4,\"317\":1,\"369\":1,\"477\":4,\"508\":3,\"510\":1,\"562\":6,\"645\":3,\"669\":2,\"671\":13,\"673\":3,\"776\":1,\"791\":1,\"792\":5,\"918\":1,\"919\":1,\"920\":2,\"926\":1,\"1002\":2,\"1042\":1,\"1062\":3,\"1171\":1,\"1172\":7,\"1499\":2}}],[\"xsd\",{\"1\":{\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"1219\":2}}],[\"xsi\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"xsi=\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"xmlwebapplicationcontext\",{\"1\":{\"1245\":1}}],[\"xml文件中进行配置\",{\"1\":{\"445\":1}}],[\"xml中可以进行相应的配置\",{\"1\":{\"963\":1}}],[\"xml中配置dfs\",{\"1\":{\"879\":1}}],[\"xml中调整dfs\",{\"1\":{\"874\":1}}],[\"xml中添加以下参数\",{\"1\":{\"445\":1}}],[\"xml中\",{\"1\":{\"234\":1,\"268\":1}}],[\"xmlschema\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"xmlns\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"xmlns=\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"xml配置参数使用\",{\"1\":{\"483\":1}}],[\"xml配置\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"xml配置文件的hive\",{\"1\":{\"254\":1}}],[\"xml配置文件\",{\"1\":{\"92\":1}}],[\"xml<\",{\"1\":{\"102\":1,\"919\":1,\"926\":1}}],[\"xml定制一些配置\",{\"1\":{\"102\":1}}],[\"xml依赖\",{\"1\":{\"101\":1}}],[\"xml\",{\"1\":{\"92\":1,\"98\":1,\"99\":1,\"100\":2,\"102\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":2,\"870\":2,\"872\":1,\"875\":1,\"880\":2,\"910\":3,\"927\":1,\"936\":9,\"963\":1,\"1219\":1,\"1230\":2,\"1245\":3,\"1248\":1,\"1440\":3,\"1447\":2}}],[\"节点失败的情况下\",{\"1\":{\"1067\":1}}],[\"节点不知怎么的就处于离线状态\",{\"1\":{\"1067\":1}}],[\"节点扩容\",{\"0\":{\"878\":1}}],[\"节点数据密度\",{\"1\":{\"874\":1}}],[\"节点的状态汇报\",{\"1\":{\"942\":1}}],[\"节点的\",{\"1\":{\"666\":2}}],[\"节点距离起始地址由多少字节\",{\"1\":{\"665\":1}}],[\"节点是红色或黑色\",{\"1\":{\"656\":1}}],[\"节省运行期间扫描\",{\"1\":{\"1476\":1}}],[\"节省内存空间\",{\"1\":{\"663\":1}}],[\"节省大量时间\",{\"1\":{\"91\":1}}],[\"节约了我们的空间~\",{\"1\":{\"1223\":1}}],[\"节约了线程的数量\",{\"1\":{\"829\":1}}],[\"节约索引存储\",{\"1\":{\"480\":1}}],[\"节约时间和精力\",{\"1\":{\"107\":1}}],[\"节约软件开发成本和维护成本\",{\"1\":{\"71\":1}}],[\"场景分析二\",{\"1\":{\"1131\":1}}],[\"场景分析\",{\"1\":{\"1131\":1}}],[\"场景7\",{\"1\":{\"351\":1}}],[\"场景6\",{\"1\":{\"351\":1}}],[\"场景5\",{\"1\":{\"351\":1}}],[\"场景4\",{\"1\":{\"351\":1}}],[\"场景3\",{\"1\":{\"351\":1}}],[\"场景2\",{\"1\":{\"91\":1,\"351\":1}}],[\"场景1\",{\"1\":{\"91\":1,\"351\":1}}],[\"主分片的拷贝\",{\"1\":{\"1067\":1}}],[\"主\",{\"1\":{\"1026\":1}}],[\"主题中的消息\",{\"1\":{\"1017\":1}}],[\"主题\",{\"1\":{\"1015\":1,\"1026\":1}}],[\"主目录\",{\"1\":{\"924\":1}}],[\"主备节点之间\",{\"1\":{\"882\":1}}],[\"主循环\",{\"1\":{\"741\":1}}],[\"主人把鸡鸭鱼肉的钱都会换为束修金的\",{\"1\":{\"709\":1}}],[\"主线程再走\",{\"1\":{\"1132\":1}}],[\"主线程就已经执行完了\",{\"1\":{\"1132\":1}}],[\"主线程并没有\",{\"1\":{\"857\":1}}],[\"主线程通过\",{\"1\":{\"757\":1}}],[\"主线程通过get方法可以等待其他线程的运行结果\",{\"1\":{\"592\":1}}],[\"主线程可能会发生阻塞\",{\"1\":{\"530\":1}}],[\"主从数据一致\",{\"1\":{\"1189\":1}}],[\"主从一致性\",{\"1\":{\"1149\":1}}],[\"主从切换导致缓存雪崩具体场景\",{\"0\":{\"530\":1}}],[\"主从模式\",{\"0\":{\"525\":1}}],[\"主键\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"主键的设计至少应该是全局唯一且是单调递增\",{\"1\":{\"502\":1}}],[\"主键如何设计\",{\"0\":{\"500\":1}}],[\"主键索引和全文索引\",{\"1\":{\"492\":1}}],[\"主键索引名为pk字段名\",{\"1\":{\"480\":1}}],[\"主键或者唯一索引\",{\"1\":{\"481\":1}}],[\"主机会将数据同步给从机\",{\"1\":{\"1153\":1}}],[\"主机宕机了\",{\"1\":{\"1149\":1}}],[\"主机需要异步的将数据同步给从机\",{\"1\":{\"1149\":1}}],[\"主机等等各种资源\",{\"1\":{\"923\":1}}],[\"主机名\",{\"1\":{\"878\":1}}],[\"主机要浪费很多时间来等待设备\",{\"1\":{\"212\":1}}],[\"主机速度很快\",{\"1\":{\"212\":1}}],[\"主机直接从i\",{\"1\":{\"212\":1}}],[\"主动更新\",{\"1\":{\"1119\":1}}],[\"主动加入到队列等待唤醒\",{\"1\":{\"588\":1}}],[\"主动清理策略再redis4\",{\"1\":{\"522\":1}}],[\"主动放弃处理机\",{\"1\":{\"171\":1}}],[\"主动触发构建\",{\"1\":{\"91\":1}}],[\"主页\",{\"0\":{\"131\":1}}],[\"主要提供ioc依赖注入功能的支持\",{\"1\":{\"1499\":1}}],[\"主要原因是在于我们对key设置了过期时间\",{\"1\":{\"1126\":1}}],[\"主要原因有以下几种\",{\"1\":{\"101\":1}}],[\"主要\",{\"1\":{\"1067\":1}}],[\"主要有两方面的原因\",{\"1\":{\"1066\":1}}],[\"主要有以下功能\",{\"1\":{\"526\":1}}],[\"主要有以下两种方式\",{\"1\":{\"378\":1}}],[\"主要目的\",{\"1\":{\"1042\":1}}],[\"主要测试负载的执行时间\",{\"1\":{\"1019\":1}}],[\"主要的\",{\"1\":{\"1243\":1}}],[\"主要的作用是同步协调在多线程的等待于唤醒问题\",{\"1\":{\"1132\":1}}],[\"主要的流程步骤如下\",{\"1\":{\"1005\":1}}],[\"主要的存储格式如下\",{\"1\":{\"426\":1}}],[\"主要考察的就是自定义分组的实现\",{\"1\":{\"974\":1}}],[\"主要职责\",{\"1\":{\"933\":1}}],[\"主要对写回结果进行加工\",{\"1\":{\"766\":1}}],[\"主要任务是执行死循环\",{\"1\":{\"741\":1}}],[\"主要用来读取客户端数据\",{\"1\":{\"766\":1}}],[\"主要用在阻塞\",{\"1\":{\"725\":1}}],[\"主要用于与自增后的序列号进行位与\",{\"1\":{\"999\":1}}],[\"主要用于判断是否同一毫秒\",{\"1\":{\"999\":1}}],[\"主要用于高速读写数据\",{\"1\":{\"886\":1}}],[\"主要用于实现条件锁\",{\"1\":{\"584\":1}}],[\"主要用于实现读写锁\",{\"1\":{\"582\":1}}],[\"主要用于显式数据类型转换\",{\"1\":{\"341\":1}}],[\"主要抓住两点\",{\"1\":{\"637\":1}}],[\"主要基于以下奇数以及数据结构\",{\"1\":{\"503\":1}}],[\"主要推荐使用orc格式\",{\"1\":{\"426\":1}}],[\"主要map阶段的代码如下\",{\"1\":{\"373\":1}}],[\"主要搭配udtf类型函数一起使用\",{\"1\":{\"349\":1}}],[\"主要是因为当多个线程操作同一个对象的时候存在共享资源竞争的问题\",{\"1\":{\"1506\":1}}],[\"主要是因为内存数据宝贵\",{\"1\":{\"1119\":1}}],[\"主要是存在于浏览器端的缓存\",{\"1\":{\"1115\":1}}],[\"主要是探活的作用\",{\"1\":{\"1004\":1}}],[\"主要是为了避免一个字段产生多个值的歧义\",{\"1\":{\"306\":1}}],[\"主要是描述数据属性\",{\"1\":{\"238\":1}}],[\"主要是实现抽象工厂中的多个抽象方法\",{\"1\":{\"38\":1}}],[\"主要是实现抽象工厂中的抽象方法\",{\"1\":{\"33\":1}}],[\"主要完成数据加工与整合\",{\"1\":{\"226\":1}}],[\"主要完成基础数据引入到数仓的职责\",{\"1\":{\"225\":1}}],[\"主要包括\",{\"1\":{\"211\":1,\"951\":1}}],[\"主要实现的功能\",{\"1\":{\"210\":1}}],[\"主要追求存储空间的利用率\",{\"1\":{\"181\":1}}],[\"主要解决接口选择的问题\",{\"1\":{\"23\":1}}],[\"主要解决\",{\"1\":{\"23\":1}}],[\"主要为控制访问\",{\"1\":{\"10\":1}}],[\"自行调用销毁方法\",{\"1\":{\"1504\":1}}],[\"自行车\",{\"1\":{\"147\":1}}],[\"自行车类\",{\"1\":{\"14\":1}}],[\"自减操作\",{\"1\":{\"1206\":2}}],[\"自减并获取\",{\"1\":{\"562\":1}}],[\"自由\",{\"1\":{\"1185\":1}}],[\"自己测试时请将包名根据情况补全\",{\"1\":{\"1464\":1}}],[\"自己图片所在的地址\",{\"1\":{\"1159\":1}}],[\"自己封装的set方法\",{\"1\":{\"972\":1}}],[\"自己是主角色\",{\"1\":{\"882\":1}}],[\"自己是备份角色\",{\"1\":{\"882\":1}}],[\"自己根据返回值检查是否有事件\",{\"1\":{\"832\":1}}],[\"自己\",{\"1\":{\"766\":1}}],[\"自己的\",{\"1\":{\"746\":2,\"802\":1,\"803\":1}}],[\"自己调用\",{\"1\":{\"742\":1}}],[\"自己创建一个单线程串行执行任务\",{\"1\":{\"574\":1}}],[\"自带的序列化\",{\"1\":{\"723\":1}}],[\"自然排序\",{\"1\":{\"618\":1}}],[\"自旋会占用cpu时间\",{\"1\":{\"542\":1}}],[\"自旋优化\",{\"0\":{\"542\":1}}],[\"自增长\",{\"1\":{\"1132\":1}}],[\"自增步长为3\",{\"1\":{\"997\":1}}],[\"自增并获取\",{\"1\":{\"562\":1}}],[\"自增\",{\"1\":{\"560\":1,\"1174\":1}}],[\"自增锁\",{\"1\":{\"510\":1}}],[\"自增id的性能较差\",{\"1\":{\"501\":1}}],[\"自增id的问题\",{\"0\":{\"501\":1}}],[\"自定义参数与返回值处理器\",{\"0\":{\"1356\":1}}],[\"自定义redistemplate\",{\"1\":{\"1223\":1}}],[\"自定义counter计数器\",{\"0\":{\"983\":1}}],[\"自定义分组规则\",{\"1\":{\"974\":1}}],[\"自定义分区策略\",{\"0\":{\"1035\":1}}],[\"自定义分区器中分区规则的实现方法\",{\"1\":{\"973\":1}}],[\"自定义分区规则\",{\"1\":{\"973\":1}}],[\"自定义分区\",{\"1\":{\"973\":1}}],[\"自定义对象作为数据类型在mapreduce中传递\",{\"1\":{\"972\":1}}],[\"自定义对象covidcountbean\",{\"1\":{\"972\":1}}],[\"自定义对象必须实现hadoop的序列化机制writable\",{\"1\":{\"956\":1}}],[\"自定义javabean实现writable接口来实现hadoop的序列化机制\",{\"1\":{\"972\":1}}],[\"自定义一个customcombiner类\",{\"1\":{\"970\":1}}],[\"自定义协议要素\",{\"0\":{\"712\":1}}],[\"自定义inputformat\",{\"0\":{\"375\":1}}],[\"自定义替换的字母\",{\"1\":{\"342\":1}}],[\"自举装入程序\",{\"1\":{\"206\":2}}],[\"自举程序\",{\"1\":{\"206\":1}}],[\"自动侦测以及自动装配到spring容器中\",{\"1\":{\"1507\":1}}],[\"自动配置类本质上就是一个配置类而已\",{\"1\":{\"1465\":1}}],[\"自动配置类原理\",{\"0\":{\"1463\":1}}],[\"自动配置类为\",{\"1\":{\"1453\":1,\"1455\":1}}],[\"自动配置的本质是通过\",{\"1\":{\"1453\":1}}],[\"自动配置\",{\"0\":{\"1452\":1},\"1\":{\"1453\":1}}],[\"自动释放锁\",{\"1\":{\"1140\":1}}],[\"自动提交\",{\"1\":{\"1051\":1}}],[\"自动离开安全模式\",{\"1\":{\"870\":1}}],[\"自动操作\",{\"1\":{\"870\":1}}],[\"自动递增\",{\"1\":{\"779\":1}}],[\"自动拆箱\",{\"1\":{\"599\":1}}],[\"自动装箱\",{\"1\":{\"599\":1}}],[\"自动装箱与自动拆箱\",{\"0\":{\"599\":1}}],[\"自动推断出来的\",{\"1\":{\"261\":1}}],[\"自动传递\",{\"1\":{\"113\":2}}],[\"自动选择原则\",{\"1\":{\"105\":1}}],[\"自动依赖传递需要的依赖\",{\"1\":{\"104\":1}}],[\"自动下载依赖需要的依赖并且保证版本没有冲突\",{\"1\":{\"91\":1}}],[\"项目可独立运行\",{\"1\":{\"1520\":1}}],[\"项目磁盘路径\",{\"1\":{\"1447\":1}}],[\"项目\",{\"1\":{\"1443\":1,\"1449\":1}}],[\"项目搭建和统一构建\",{\"0\":{\"111\":1}}],[\"项目架构\",{\"1\":{\"110\":1}}],[\"项目需求和结构分析\",{\"0\":{\"110\":1}}],[\"项目c依赖b\",{\"1\":{\"104\":1}}],[\"项目b依赖a\",{\"1\":{\"104\":1}}],[\"项目打成war包\",{\"1\":{\"98\":1}}],[\"项目打成jar包\",{\"1\":{\"98\":1}}],[\"项目的唯一id\",{\"1\":{\"98\":1}}],[\"项目完成开发\",{\"1\":{\"91\":1}}],[\"项目构建还能够将多个开发人员的代码汇合到一起\",{\"1\":{\"94\":1}}],[\"项目构建是软件开发过程中至关重要的一部分\",{\"1\":{\"94\":1}}],[\"项目构建是指将源代码\",{\"1\":{\"91\":1,\"94\":1,\"102\":1}}],[\"项目构建\",{\"1\":{\"91\":1}}],[\"项目管理构建\",{\"1\":{\"91\":1}}],[\"以最快捷\",{\"1\":{\"1524\":1}}],[\"以最左侧的维度为主\",{\"1\":{\"352\":1}}],[\"以达到快速构建项目\",{\"1\":{\"1520\":1}}],[\"以达到动态表名的效果\",{\"1\":{\"1232\":1}}],[\"以非事务方式运行\",{\"1\":{\"1514\":2}}],[\"以完成一个完整的业务操作\",{\"1\":{\"1514\":1}}],[\"以支持判断事件类型\",{\"1\":{\"1497\":1}}],[\"以它为准加载\",{\"1\":{\"1476\":1}}],[\"以单例注入多例为例\",{\"1\":{\"1294\":1}}],[\"以t\",{\"1\":{\"1232\":1}}],[\"以免其他开发环境下出现bug\",{\"1\":{\"1229\":1}}],[\"以免错误的使用到它\",{\"1\":{\"206\":1}}],[\"以当前坐标作为圆心\",{\"1\":{\"1171\":1}}],[\"以秒为单位\",{\"1\":{\"1131\":1}}],[\"以订单编号作为key\",{\"1\":{\"988\":1}}],[\"以记录每个reduce对应数据的偏移量\",{\"1\":{\"979\":1}}],[\"以回车换行作为分隔符\",{\"1\":{\"979\":1}}],[\"以covidcountbean作为value\",{\"1\":{\"972\":1}}],[\"以州作为map阶段输出的key\",{\"1\":{\"972\":1}}],[\"以减少在map和reduce节点之间的数据传输量\",{\"1\":{\"969\":1}}],[\"以减少搜索时间\",{\"1\":{\"605\":1}}],[\"以让\",{\"1\":{\"953\":1}}],[\"以形成加密数据加密密钥\",{\"1\":{\"931\":1}}],[\"以为上面两种方法访问时实现了自动解密\",{\"1\":{\"928\":1}}],[\"以处理计划内和计划外的停机\",{\"1\":{\"875\":1}}],[\"以实现机架容错\",{\"1\":{\"875\":1}}],[\"以实现进程的并发执行\",{\"1\":{\"164\":1}}],[\"以强制目录采用3倍复制方案\",{\"1\":{\"875\":1}}],[\"以对失败的纠删编码块进行后台恢复\",{\"1\":{\"875\":1}}],[\"以每秒字节数为单位\",{\"1\":{\"873\":1}}],[\"以覆盖的方式进行拷贝\",{\"1\":{\"869\":1}}],[\"以避免守护线程意外结束\",{\"1\":{\"858\":1}}],[\"以前的重构数据的逻辑\",{\"1\":{\"1126\":1}}],[\"以前有同学写过这样的代码\",{\"1\":{\"839\":1}}],[\"以前开发的系统存在满足新系统功能需求的类\",{\"1\":{\"8\":1}}],[\"以下是管理bean时常用的一些注解\",{\"1\":{\"1503\":1}}],[\"以下是面向面试\",{\"1\":{\"580\":1}}],[\"以下这段代码需要修改为\",{\"1\":{\"1137\":1}}],[\"以下的框架都使用了\",{\"1\":{\"791\":1}}],[\"以一个简单的实现为例\",{\"1\":{\"746\":1}}],[\"以一个段\",{\"1\":{\"694\":1}}],[\"以解决粘包为例\",{\"1\":{\"696\":1}}],[\"以解决难以找到一块连续的大内存空间的问题\",{\"1\":{\"683\":1}}],[\"以太网的\",{\"1\":{\"694\":1}}],[\"以段为单位\",{\"1\":{\"683\":1}}],[\"以段为单位进行分配\",{\"1\":{\"187\":1}}],[\"以二级页表而言\",{\"1\":{\"683\":1}}],[\"以块为单位\",{\"1\":{\"683\":1}}],[\"以read举例\",{\"1\":{\"679\":1}}],[\"以role角色作为分区字段\",{\"1\":{\"260\":1}}],[\"以该节点结尾的单词数+1\",{\"1\":{\"668\":1}}],[\"以满足修改所需的大小\",{\"1\":{\"663\":1}}],[\"以满足上述需要\",{\"1\":{\"348\":1}}],[\"以保证能够取到上一行的前面的值\",{\"1\":{\"648\":1}}],[\"以递减的形式更新\",{\"1\":{\"648\":1}}],[\"以串并行分类\",{\"1\":{\"638\":1}}],[\"以防越界\",{\"1\":{\"601\":1}}],[\"以后已废弃\",{\"1\":{\"1170\":1}}],[\"以后的查询就根据后台结果作为条件\",{\"1\":{\"1168\":1}}],[\"以后在该目录中新建文件或者子目录时\",{\"1\":{\"926\":1}}],[\"以后在第一次使用时才会真正创建\",{\"1\":{\"579\":1}}],[\"以后通过调段功能和段的置换功能将暂时不运行的段调出\",{\"1\":{\"689\":1}}],[\"以后\",{\"1\":{\"689\":1,\"770\":1}}],[\"以后还可以修改\",{\"1\":{\"574\":1}}],[\"以访问次数的多少作为参考点\",{\"1\":{\"522\":1}}],[\"以学生和成绩的关系为例\",{\"1\":{\"482\":1}}],[\"以上两种\",{\"1\":{\"1382\":1,\"1390\":1,\"1410\":1}}],[\"以上两个功能和共同关注没有什么关系\",{\"1\":{\"1165\":1}}],[\"以上命令除了incrbyfloat\",{\"1\":{\"1206\":1}}],[\"以上逻辑的核心含义是\",{\"1\":{\"1136\":1}}],[\"以上\",{\"1\":{\"481\":1,\"493\":1}}],[\"以使进程能继续执行下去\",{\"1\":{\"688\":1}}],[\"以使真正执行时能直接跳过无关的数据\",{\"1\":{\"459\":1}}],[\"以使他们获得竞争处理机的权利\",{\"1\":{\"164\":1}}],[\"以json格式返回查询所依赖的表和分区的列表\",{\"1\":{\"441\":1}}],[\"以提高查询性能\",{\"1\":{\"480\":1}}],[\"以提升一些操作的效率\",{\"1\":{\"420\":1}}],[\"以提供用户和其他软件方便的接口和环境\",{\"1\":{\"153\":1}}],[\"以month维度进行层级聚合\",{\"1\":{\"355\":1}}],[\"以sdept作为分区字段\",{\"1\":{\"289\":1}}],[\"以便对后续\",{\"1\":{\"1248\":1}}],[\"以便添加更多的处理器\",{\"1\":{\"784\":1,\"785\":1}}],[\"以便后续使用\",{\"1\":{\"741\":1}}],[\"以便为即将调入的页面让出空间\",{\"1\":{\"690\":1}}],[\"以便能将作业分先后地多次装入内存\",{\"1\":{\"689\":1}}],[\"以便于提高小数据量程序的性能\",{\"1\":{\"444\":1}}],[\"以便与商业智能工具\",{\"1\":{\"228\":1}}],[\"以便一起构建和管理的机制\",{\"1\":{\"108\":1}}],[\"以备分析\",{\"1\":{\"228\":1}}],[\"以宽表化手段物理化模型\",{\"1\":{\"226\":1}}],[\"以分析的主题对象作为建模驱动\",{\"1\":{\"226\":1}}],[\"以此来进行不同逻辑的输出\",{\"1\":{\"988\":1}}],[\"以此达到主从库的数据一致性\",{\"1\":{\"529\":1}}],[\"以此实现设备保护功能\",{\"1\":{\"211\":1}}],[\"以此决定是否答应资源分配请求\",{\"1\":{\"177\":1}}],[\"以\",{\"1\":{\"201\":1,\"839\":1,\"1171\":1,\"1340\":1,\"1421\":1,\"1437\":1}}],[\"以及类路径下的\",{\"1\":{\"1454\":1}}],[\"以及分页信息\",{\"1\":{\"1171\":1}}],[\"以及在启动类添加配置\",{\"1\":{\"1137\":1}}],[\"以及消费者消费数据的对象都是\",{\"1\":{\"1026\":1}}],[\"以及同一时间戳下序列号自增\",{\"1\":{\"1000\":1}}],[\"以及用于服务器时钟回拨判断\",{\"1\":{\"999\":1}}],[\"以及为原生\",{\"1\":{\"740\":1}}],[\"以及字符串的长度有关\",{\"1\":{\"665\":1}}],[\"以及数据的大小\",{\"1\":{\"665\":1}}],[\"以及前面的区域\",{\"1\":{\"648\":1}}],[\"以及大表join的优化方案bucket\",{\"1\":{\"447\":1}}],[\"以及映射下推和谓词下推功能\",{\"1\":{\"429\":1}}],[\"以及所在文件中偏移量offset等信息\",{\"1\":{\"421\":1}}],[\"以及语句id\",{\"1\":{\"293\":1}}],[\"以及汇总公共粒度的指标\",{\"1\":{\"226\":1}}],[\"以及剩余的分区大小和起始地址等信息\",{\"1\":{\"182\":1}}],[\"以及基本功能\",{\"1\":{\"91\":1}}],[\"以阻止其他进程同时进入临界区\",{\"1\":{\"168\":1}}],[\"以不可预知的速度向前推进\",{\"1\":{\"155\":1}}],[\"掌握安装\",{\"1\":{\"91\":1}}],[\"大key是\",{\"1\":{\"1208\":1}}],[\"大家可以自行将笔记中的代码拷贝到idea中就可以实现这两个功能了\",{\"1\":{\"1165\":1}}],[\"大家猜猜这个结构体大小是多少\",{\"1\":{\"663\":1}}],[\"大致是什么意思即可\",{\"1\":{\"1147\":1}}],[\"大致逻辑是这样\",{\"1\":{\"1116\":1}}],[\"大量线程并发更新一个原子性的时候\",{\"1\":{\"1136\":1}}],[\"大量的fd数组被整体复制于用户空间和内核空间\",{\"1\":{\"680\":1}}],[\"大概率是你的数据库设计或者系统设计出问题了\",{\"1\":{\"1525\":1}}],[\"大概就是4000起~7000左右\",{\"1\":{\"1094\":1}}],[\"大概可以使用69年\",{\"1\":{\"998\":1}}],[\"大不了就处理1000左右的并发\",{\"1\":{\"1094\":1}}],[\"大部分bean实际都是无状态\",{\"1\":{\"1506\":1}}],[\"大部分步骤与优化前相同\",{\"1\":{\"855\":1}}],[\"大部分时候回收的都是指新生代\",{\"1\":{\"628\":1}}],[\"大端写入\",{\"1\":{\"772\":1}}],[\"大小分配\",{\"0\":{\"841\":1}}],[\"大小的文件传输\",{\"1\":{\"820\":1}}],[\"大小通过\",{\"1\":{\"726\":1}}],[\"大小包括了两个队列的大小\",{\"1\":{\"726\":1}}],[\"大小将数据进行分割发送\",{\"1\":{\"694\":1}}],[\"大小\",{\"0\":{\"818\":1},\"1\":{\"693\":1,\"848\":1}}],[\"大小就是有序小文件的个数500\",{\"1\":{\"478\":1}}],[\"大多数企业都是基于linux服务器来部署项目\",{\"1\":{\"1191\":1}}],[\"大多数操作都是在机架上进行的\",{\"1\":{\"875\":1}}],[\"大多数文件系统的默认i\",{\"1\":{\"678\":1}}],[\"大多数\",{\"1\":{\"663\":1}}],[\"大数据分布式存储框架\",{\"1\":{\"791\":1}}],[\"大数据分布式计算框架\",{\"1\":{\"791\":1}}],[\"大数据时代的数仓这个特点很明显\",{\"1\":{\"228\":1}}],[\"大数组就是segment数组\",{\"1\":{\"579\":1}}],[\"大于0说明不能释放锁\",{\"1\":{\"1151\":1}}],[\"大于1的值将使安全模式永久生效\",{\"1\":{\"870\":1}}],[\"大于等于x的放在区间右边\",{\"1\":{\"645\":1}}],[\"大于\",{\"1\":{\"459\":2,\"663\":1}}],[\"大的数据每个部分都可以与小数据的完整数据进行join\",{\"1\":{\"448\":1}}],[\"大表join大表的reduce\",{\"1\":{\"447\":1}}],[\"大写字母转换为x\",{\"1\":{\"342\":1}}],[\"大合并将一个或多个增量文件和基础文件重写为新的基础文件\",{\"1\":{\"294\":1}}],[\"大合并\",{\"1\":{\"294\":1}}],[\"大圣娶亲\",{\"1\":{\"256\":1}}],[\"大象\",{\"1\":{\"147\":1}}],[\"大尺度特征负责预测小物体\",{\"1\":{\"138\":1}}],[\"大大降低了项目的出错风险和提高开发效率\",{\"1\":{\"94\":1}}],[\"大大提高了开发效率和质量\",{\"1\":{\"91\":1}}],[\"大学既有软件专业又有生物专业等\",{\"1\":{\"36\":1}}],[\"无循环依赖时\",{\"1\":{\"1336\":1}}],[\"无非就是利用了多态\",{\"1\":{\"1310\":1}}],[\"无序\",{\"1\":{\"1210\":1}}],[\"无序长字符串等\",{\"1\":{\"494\":1}}],[\"无数的请求访问会在瞬间给数据库带来巨大的冲击\",{\"1\":{\"1126\":1}}],[\"无关\",{\"1\":{\"778\":1}}],[\"无参\",{\"1\":{\"776\":1}}],[\"无参的\",{\"1\":{\"88\":1}}],[\"无效写操作较多\",{\"1\":{\"1121\":1}}],[\"无效时处理\",{\"1\":{\"742\":1}}],[\"无效\",{\"1\":{\"742\":1}}],[\"无效io大大减少\",{\"1\":{\"506\":1}}],[\"无锁队列\",{\"1\":{\"741\":1}}],[\"无意义\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"无鱼\",{\"1\":{\"709\":1}}],[\"无鱼肉亦可\",{\"1\":{\"709\":1}}],[\"无鸡\",{\"1\":{\"709\":1}}],[\"无鸡鸭亦可\",{\"1\":{\"709\":1}}],[\"无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金\",{\"1\":{\"709\":1}}],[\"无界阻塞队列\",{\"1\":{\"572\":1}}],[\"无阻塞并发\",{\"1\":{\"561\":1}}],[\"无论他怎么操作\",{\"1\":{\"1161\":1}}],[\"无论是他的put方法和他的get方法\",{\"1\":{\"1100\":1}}],[\"无论是否存在\",{\"1\":{\"1098\":1}}],[\"无论是否找到key\",{\"1\":{\"529\":1}}],[\"无论有没有\",{\"1\":{\"741\":1}}],[\"无论哪个原语\",{\"1\":{\"161\":1}}],[\"无环图目录结构\",{\"1\":{\"196\":1}}],[\"无结构文件\",{\"1\":{\"195\":1}}],[\"无外部碎片\",{\"1\":{\"182\":2}}],[\"无法获得参数名\",{\"1\":{\"1366\":1}}],[\"无法利用\",{\"1\":{\"854\":1}}],[\"无法保证把\",{\"1\":{\"843\":1}}],[\"无法保存新节点的长度\",{\"1\":{\"666\":1}}],[\"无法进行数据读写\",{\"1\":{\"707\":1}}],[\"无法再装入新的页\",{\"1\":{\"688\":1}}],[\"无法修改\",{\"1\":{\"610\":1}}],[\"无法唤醒指定的线程\",{\"1\":{\"549\":1}}],[\"无法及时处理客户端请求\",{\"1\":{\"530\":1}}],[\"无法使用覆盖索引\",{\"1\":{\"498\":1}}],[\"无法对单独的一个键或者几个索引键进行判断\",{\"1\":{\"491\":1}}],[\"无法实现map\",{\"1\":{\"467\":1}}],[\"无法管理数据\",{\"1\":{\"296\":1}}],[\"无法正常使用的扇区\",{\"1\":{\"206\":1}}],[\"无法正确地使用现有的依赖项\",{\"1\":{\"101\":1}}],[\"无法破坏\",{\"1\":{\"176\":1}}],[\"无需外部依赖servlet容器\",{\"1\":{\"1520\":1}}],[\"无需特殊设置\",{\"1\":{\"1462\":1}}],[\"无需查询是否点赞\",{\"1\":{\"1162\":1}}],[\"无需过分关心\",{\"1\":{\"1066\":1}}],[\"无需等\",{\"1\":{\"827\":1}}],[\"无需从头编写练习\",{\"1\":{\"733\":1}}],[\"无需synchronized\",{\"1\":{\"579\":1}}],[\"无需synchronized创建成功\",{\"1\":{\"579\":1}}],[\"无需在作业运行时一次性全部装入内存\",{\"1\":{\"189\":1}}],[\"无需操作系统干预\",{\"1\":{\"163\":1}}],[\"无需自己导入jar包\",{\"1\":{\"91\":1}}],[\"无须对原工厂进行任何修改\",{\"1\":{\"35\":1}}],[\"无须知道产品的具体创建过程\",{\"1\":{\"35\":1}}],[\"系统是几乎撑不住的\",{\"1\":{\"1114\":1}}],[\"系统也需要\",{\"1\":{\"1113\":1}}],[\"系统解耦\",{\"1\":{\"1009\":1}}],[\"系统可以正常使用时间与总时间\",{\"1\":{\"882\":1}}],[\"系统异步\",{\"1\":{\"856\":1}}],[\"系统通过\",{\"1\":{\"856\":1}}],[\"系统资源占用较大\",{\"1\":{\"609\":1}}],[\"系统资源是分配给进程的\",{\"1\":{\"163\":1}}],[\"系统将等待所有旧文件的读操作完成后\",{\"1\":{\"294\":1}}],[\"系统将内存中某些进程暂时换出外存\",{\"1\":{\"181\":1}}],[\"系统的可靠性越强\",{\"1\":{\"882\":1}}],[\"系统的组成如下\",{\"1\":{\"212\":1}}],[\"系统的开销减小\",{\"1\":{\"163\":1}}],[\"系统根据fcb中记录的信息来判断该用户是否有相应的访问权限\",{\"1\":{\"211\":1}}],[\"系统会使用httpmessageconverter或者自定义的httpmessageconverter将请求的body中的json字符串转换成java对象\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"系统会扫描\",{\"1\":{\"1089\":1}}],[\"系统会从用户身份认证和数据访问授权两个环节进行验证\",{\"1\":{\"916\":1}}],[\"系统会切换到硬盘读写的中断处理程序中执行后边的操作等\",{\"1\":{\"676\":1}}],[\"系统会自动采用占用空间小的二级索引来进行统计\",{\"1\":{\"497\":1}}],[\"系统会检查该用户所属的分组是否有相应的访问权限\",{\"1\":{\"201\":1}}],[\"系统会根据段内地址自动划分页号和页内偏移地址\",{\"1\":{\"188\":1}}],[\"系统管理员\",{\"1\":{\"201\":1}}],[\"系统要根据文件名搜索目录\",{\"1\":{\"196\":1}}],[\"系统要花大量的时间来处理分页\",{\"1\":{\"192\":1}}],[\"系统要用什么样的数据结构记录内存的使用情况\",{\"1\":{\"182\":1}}],[\"系统区通常位于内存的低地址部分\",{\"1\":{\"182\":1}}],[\"系统还是有可能重新回到安全状态\",{\"1\":{\"177\":1}}],[\"系统就进入了不安全状态\",{\"1\":{\"177\":1}}],[\"系统就是安全状态\",{\"1\":{\"177\":1}}],[\"系统进程优先级高于用于进程\",{\"1\":{\"167\":1}}],[\"系统吞吐量\",{\"1\":{\"166\":1}}],[\"系统开销会增大\",{\"1\":{\"167\":1}}],[\"系统开销很小\",{\"1\":{\"163\":1}}],[\"系统开销小但是无法及时处理紧急任务\",{\"1\":{\"165\":1}}],[\"系统开销小\",{\"1\":{\"163\":1}}],[\"系统开销大\",{\"1\":{\"163\":2}}],[\"系统为每个运行的程序配置一个数据结构\",{\"1\":{\"159\":1}}],[\"系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现\",{\"1\":{\"676\":1}}],[\"系统调用的过程\",{\"1\":{\"158\":1}}],[\"系统调用将被阻塞\",{\"1\":{\"162\":2}}],[\"系统调用和库函数的区别\",{\"1\":{\"158\":1}}],[\"系统调用是操作系统提供给应用程序使用的接口\",{\"1\":{\"158\":1}}],[\"系统调用概念\",{\"1\":{\"158\":1}}],[\"系统调用\",{\"0\":{\"158\":1},\"1\":{\"676\":1}}],[\"系统依赖范围\",{\"1\":{\"100\":1}}],[\"系统更加庞大\",{\"1\":{\"86\":1}}],[\"系统中某个点故障\",{\"1\":{\"882\":1}}],[\"系统中对象数据的存储\",{\"1\":{\"515\":1}}],[\"系统中设置一个页表寄存器\",{\"1\":{\"185\":1}}],[\"系统中找不出任何一个安全序列\",{\"1\":{\"177\":1}}],[\"系统中打印机的数量为1\",{\"1\":{\"171\":1}}],[\"系统中只有一个程序正在执行\",{\"1\":{\"155\":1}}],[\"系统中的各种共享资源都由操作系统统一掌管\",{\"1\":{\"158\":1}}],[\"系统中的某些资源\",{\"1\":{\"155\":2}}],[\"系统中的资源可供内存中多个并发执行的进程共同使用\",{\"1\":{\"155\":1}}],[\"系统中提供了产品的类库\",{\"1\":{\"41\":1}}],[\"系统中有多个产品族\",{\"1\":{\"41\":1}}],[\"炒蒜蓉菜心\",{\"1\":{\"85\":1}}],[\"炒手撕包菜\",{\"1\":{\"85\":1}}],[\"炒啊炒啊炒到熟啊\",{\"1\":{\"85\":1}}],[\"炒菜的步骤是固定的\",{\"1\":{\"85\":1}}],[\"炒菜\",{\"1\":{\"85\":1}}],[\"倒计时结束如果依然满足阈值条件\",{\"1\":{\"870\":1}}],[\"倒序排序后为\",{\"1\":{\"353\":1}}],[\"倒调味料是不一样\",{\"1\":{\"85\":1}}],[\"倒调味料\",{\"1\":{\"85\":1}}],[\"倒调料品\",{\"1\":{\"85\":1}}],[\"倒油\",{\"1\":{\"85\":2}}],[\"倒蔬菜是不一样的\",{\"1\":{\"85\":1}}],[\"倒蔬菜\",{\"1\":{\"85\":2}}],[\"包路径扫描\",{\"1\":{\"1525\":1}}],[\"包装了\",{\"1\":{\"766\":1}}],[\"包装类型的常量池技术\",{\"0\":{\"598\":1}}],[\"包装类型比如integer是不可变类\",{\"1\":{\"560\":1}}],[\"包装类常量池\",{\"1\":{\"568\":1}}],[\"包一层异常\",{\"1\":{\"762\":1}}],[\"包组合\",{\"1\":{\"107\":1}}],[\"包\",{\"1\":{\"107\":2,\"953\":1,\"1013\":1,\"1242\":1,\"1254\":1,\"1263\":1,\"1270\":1,\"1283\":1,\"1288\":1,\"1292\":1,\"1296\":1,\"1316\":1,\"1332\":1,\"1354\":1,\"1361\":1,\"1372\":1,\"1378\":1,\"1389\":1,\"1393\":1,\"1401\":1,\"1409\":1,\"1447\":1,\"1471\":1,\"1475\":1,\"1479\":1,\"1484\":1,\"1488\":1,\"1492\":1,\"1496\":1}}],[\"包时\",{\"1\":{\"104\":1}}],[\"包括url\",{\"1\":{\"1530\":1}}],[\"包括applicationcontext\",{\"1\":{\"1502\":1}}],[\"包括控制器方法对象\",{\"1\":{\"1355\":1}}],[\"包括请求路径\",{\"1\":{\"1355\":1}}],[\"包括分配主分片或者副本\",{\"1\":{\"1068\":1}}],[\"包括分区号\",{\"1\":{\"182\":1}}],[\"包括5位\",{\"1\":{\"998\":1}}],[\"包括text文本\",{\"1\":{\"989\":1}}],[\"包括环境变量\",{\"1\":{\"953\":1}}],[\"包括应用程序提交\",{\"1\":{\"945\":1}}],[\"包括上传文件\",{\"1\":{\"870\":1}}],[\"包括权限信息\",{\"1\":{\"869\":1}}],[\"包括普通任务和定时任务\",{\"1\":{\"741\":1}}],[\"包括当前节点\",{\"1\":{\"668\":1}}],[\"包括原理\",{\"1\":{\"633\":1}}],[\"包括程序代码中定义的各种类型的字段\",{\"1\":{\"631\":1}}],[\"包括自己\",{\"1\":{\"582\":1}}],[\"包括自动下载所需依赖库\",{\"1\":{\"91\":1}}],[\"包括进行数据库操作时\",{\"1\":{\"576\":1}}],[\"包括缓存回滚\",{\"1\":{\"483\":1}}],[\"包括输入与输出\",{\"1\":{\"441\":1}}],[\"包括null行\",{\"1\":{\"351\":2}}],[\"包括内置函数和用户自定义函数\",{\"1\":{\"334\":1}}],[\"包括语法解析器\",{\"1\":{\"232\":1}}],[\"包括\",{\"1\":{\"232\":1,\"737\":1,\"951\":1,\"962\":1,\"1198\":1,\"1212\":1,\"1476\":1}}],[\"包括前端报表\",{\"1\":{\"227\":1}}],[\"包括设置设备寄存器\",{\"1\":{\"210\":1}}],[\"包括线程切换\",{\"1\":{\"163\":1}}],[\"包括用于判断的逻辑方法和需要子类重写的空方法两种\",{\"1\":{\"84\":1}}],[\"包含通知和切点\",{\"1\":{\"1456\":1}}],[\"包含以下三个\",{\"1\":{\"1456\":1}}],[\"包含以下主要角色\",{\"1\":{\"5\":1}}],[\"包含一个\",{\"1\":{\"1322\":2}}],[\"包含对各种数据库的集成\",{\"1\":{\"1217\":1}}],[\"包含\",{\"1\":{\"1170\":1}}],[\"包含笔记中的标题\",{\"1\":{\"1159\":1}}],[\"包含时间\",{\"1\":{\"913\":1}}],[\"包含的元素数量较少\",{\"1\":{\"664\":1}}],[\"包含了每个stage非常重要的信息\",{\"1\":{\"442\":1}}],[\"包含union\",{\"1\":{\"316\":1}}],[\"包含4种子语法\",{\"1\":{\"252\":1}}],[\"包含用hive创建的database\",{\"1\":{\"239\":1}}],[\"包含车架\",{\"1\":{\"14\":1}}],[\"钩子方法\",{\"1\":{\"84\":1}}],[\"办理具体业务\",{\"1\":{\"83\":1}}],[\"取得\",{\"1\":{\"1322\":1}}],[\"取消关注\",{\"1\":{\"1164\":2,\"1165\":1}}],[\"取消点赞\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"取消sqlite数据库连接配置\",{\"1\":{\"1046\":1}}],[\"取消设置先前对目录上的setpolicy的调用所设置的擦除编码策略\",{\"1\":{\"875\":1}}],[\"取消\",{\"1\":{\"840\":1,\"1005\":1}}],[\"取消任务\",{\"1\":{\"756\":1}}],[\"取消或关闭时会导致这个\",{\"1\":{\"742\":1}}],[\"取消访问检查\",{\"1\":{\"68\":1}}],[\"取值是\",{\"1\":{\"740\":1}}],[\"取二者的较小值\",{\"1\":{\"726\":1}}],[\"取下下一次登陆时间\",{\"1\":{\"400\":1}}],[\"取下一次登陆时间\",{\"1\":{\"400\":2}}],[\"取不到就为0\",{\"1\":{\"400\":3}}],[\"取哪一列的值\",{\"1\":{\"399\":1}}],[\"取分组内排序后\",{\"1\":{\"365\":2}}],[\"取默认值\",{\"1\":{\"365\":2}}],[\"取第一部分\",{\"1\":{\"364\":1}}],[\"取哈希值函数\",{\"1\":{\"343\":1}}],[\"取map集合values函数\",{\"1\":{\"339\":2}}],[\"取map集合keys函数\",{\"1\":{\"339\":2}}],[\"取整函数\",{\"1\":{\"338\":1}}],[\"取整操作\",{\"1\":{\"331\":1}}],[\"取随机数函数\",{\"1\":{\"338\":2}}],[\"取余操作\",{\"1\":{\"331\":1}}],[\"取数据\",{\"1\":{\"179\":1}}],[\"取决于具体程序\",{\"1\":{\"683\":1}}],[\"取决于计算机的字长\",{\"1\":{\"179\":1}}],[\"取决于\",{\"1\":{\"104\":1}}],[\"取款或者转账等\",{\"1\":{\"83\":1}}],[\"取号\",{\"1\":{\"83\":1}}],[\"模块的\",{\"1\":{\"1499\":1}}],[\"模板设计模式\",{\"1\":{\"1255\":1}}],[\"模板方法设计模式\",{\"0\":{\"1256\":1}}],[\"模板方法\",{\"0\":{\"585\":1},\"1\":{\"84\":2,\"1257\":1}}],[\"模板方法模式\",{\"0\":{\"82\":1}}],[\"模糊查询时如果使用了\",{\"1\":{\"1230\":1}}],[\"模糊查询\",{\"0\":{\"1082\":1},\"1\":{\"1082\":1}}],[\"模糊图像转成高清图像等酷炫好玩的应用\",{\"1\":{\"124\":1}}],[\"模拟实现这组映射器和适配器\",{\"1\":{\"1421\":1}}],[\"模拟\",{\"0\":{\"1309\":1,\"1315\":1,\"1344\":1}}],[\"模拟解析\",{\"0\":{\"1272\":1,\"1275\":1,\"1278\":1}}],[\"模拟锁超时了\",{\"1\":{\"1147\":1}}],[\"模拟缓存重建延迟\",{\"1\":{\"1127\":1}}],[\"模拟美国各州的数据字典\",{\"1\":{\"973\":1}}],[\"模拟脱机输出时的外围控制机\",{\"1\":{\"212\":1}}],[\"模拟脱机输出时的磁带\",{\"1\":{\"212\":1}}],[\"模拟脱机输入时的外围控制机\",{\"1\":{\"212\":1}}],[\"模拟脱机输入时的磁带\",{\"1\":{\"212\":1}}],[\"模型工厂\",{\"1\":{\"1438\":1}}],[\"模型\",{\"0\":{\"851\":1},\"1\":{\"1528\":1}}],[\"模型时\",{\"1\":{\"795\":1}}],[\"模型版本\",{\"1\":{\"98\":1}}],[\"模式选择\",{\"1\":{\"1167\":1}}],[\"模式包含以下主要角色\",{\"1\":{\"84\":1}}],[\"模式包含如下角色\",{\"1\":{\"13\":1}}],[\"模式分为三种角色\",{\"1\":{\"57\":1}}],[\"模式\",{\"0\":{\"679\":1},\"1\":{\"45\":1,\"726\":1}}],[\"模式扩展\",{\"0\":{\"17\":1,\"42\":1}}],[\"模式创建的是复杂对象\",{\"1\":{\"16\":1}}],[\"负数\",{\"1\":{\"1206\":1}}],[\"负载均衡到下游tomcat服务器\",{\"1\":{\"1094\":1}}],[\"负载平衡器无法在单个datanode上的各个卷\",{\"1\":{\"873\":1}}],[\"负载因子\",{\"1\":{\"606\":3}}],[\"负载为0时\",{\"1\":{\"606\":1}}],[\"负载\",{\"1\":{\"606\":1}}],[\"负责收集容器中的监听器\",{\"1\":{\"1497\":1}}],[\"负责实现对各种各样的\",{\"1\":{\"1437\":1}}],[\"负责建立请求与控制器之间的映射关系\",{\"1\":{\"1437\":1}}],[\"负责解析参数\",{\"1\":{\"1384\":1}}],[\"负责参数名解析\",{\"1\":{\"1384\":1}}],[\"负责对象绑定\",{\"1\":{\"1384\":1}}],[\"负责对硬件设备的具体控制\",{\"1\":{\"210\":1}}],[\"负责获取\",{\"1\":{\"1264\":1}}],[\"负责的两个分区再均匀分配给\",{\"1\":{\"1042\":1}}],[\"负责管理整个系统中所有应用程序\",{\"1\":{\"945\":1}}],[\"负责管理本机器上的计算资源\",{\"1\":{\"944\":1}}],[\"负责程序内部各阶段的资源申请\",{\"1\":{\"944\":1}}],[\"负责程序的逻辑地址与物理地址的转换\",{\"1\":{\"180\":1}}],[\"负责发布事件\",{\"1\":{\"787\":1}}],[\"负责入站数据的分配\",{\"1\":{\"731\":1}}],[\"负责向服务器发送各种消息\",{\"1\":{\"702\":1}}],[\"负责接收用户在控制台的输入\",{\"1\":{\"702\":1}}],[\"负责接触正在访问临界资源的标志\",{\"1\":{\"168\":1}}],[\"负责监控redis\",{\"1\":{\"526\":1}}],[\"负责检查是否可以进入临界区\",{\"1\":{\"168\":1}}],[\"负责预测大物体\",{\"1\":{\"138\":1}}],[\"负责存储其他服务需要通用工具类\",{\"1\":{\"110\":1}}],[\"负责处理返回值\",{\"1\":{\"1384\":1}}],[\"负责处理订单相关的逻辑\",{\"1\":{\"110\":1}}],[\"负责处理用户相关的逻辑\",{\"1\":{\"110\":1}}],[\"负责给出一个算法的轮廓和骨架\",{\"1\":{\"84\":1}}],[\"负责使用strategy角色\",{\"1\":{\"80\":1}}],[\"负\",{\"1\":{\"81\":1}}],[\"胜出的线程获取cpu执行权的过程\",{\"1\":{\"542\":1}}],[\"胜率\",{\"1\":{\"256\":2}}],[\"胜\",{\"1\":{\"81\":1}}],[\"平价卷由于优惠力度并不是很大\",{\"1\":{\"1133\":1}}],[\"平价券可以任意购买\",{\"1\":{\"1133\":1}}],[\"平板\",{\"1\":{\"1089\":1}}],[\"平台启用非池化实现\",{\"1\":{\"770\":1}}],[\"平台默认启用池化实现\",{\"1\":{\"770\":1}}],[\"平时你是如何搭配使用垃圾回收器的\",{\"1\":{\"633\":1}}],[\"平均每人每年签到次数为\",{\"1\":{\"1174\":1}}],[\"平均每个文件的大小\",{\"1\":{\"435\":1}}],[\"平均带权周转时间\",{\"1\":{\"166\":2}}],[\"平均周转时间\",{\"1\":{\"166\":2,\"167\":1}}],[\"平\",{\"1\":{\"81\":1}}],[\"计数器使用\",{\"1\":{\"983\":1}}],[\"计数器的名字\",{\"1\":{\"983\":1}}],[\"计数超过阈值\",{\"1\":{\"742\":1}}],[\"计数重置为\",{\"1\":{\"742\":1}}],[\"计数加\",{\"1\":{\"742\":1}}],[\"计数变为0后\",{\"1\":{\"593\":1}}],[\"计算张三和李四有哪些共同好友\",{\"1\":{\"1210\":1}}],[\"计算张三的好友有几人\",{\"1\":{\"1210\":1}}],[\"计算总的签到次数\",{\"1\":{\"1176\":1}}],[\"计算分页参数\",{\"1\":{\"1172\":1}}],[\"计算指定的两个点之间的距离并返回\",{\"1\":{\"1170\":1}}],[\"计算出来两个校验数据\",{\"1\":{\"875\":1}}],[\"计算出剩余的空间大小\",{\"1\":{\"663\":1}}],[\"计算方法\",{\"1\":{\"874\":1}}],[\"计算完毕后向\",{\"1\":{\"759\":1}}],[\"计算完成后替换为普通node\",{\"1\":{\"579\":1}}],[\"计算等待时间\",{\"1\":{\"742\":1}}],[\"计算\",{\"1\":{\"663\":1,\"855\":1}}],[\"计算字符串长度的时候则会是\",{\"1\":{\"662\":1}}],[\"计算并获取\",{\"1\":{\"562\":1}}],[\"计算该列除null之外的不重复行数\",{\"1\":{\"482\":1}}],[\"计算涉及两个mr作业\",{\"1\":{\"326\":1}}],[\"计算机网络\",{\"0\":{\"650\":1}}],[\"计算机开机时需要进行一系列初始化工作\",{\"1\":{\"206\":1}}],[\"计算机系统中同时存在着多个运行着程序\",{\"1\":{\"155\":1}}],[\"计算机工作\",{\"1\":{\"74\":2}}],[\"计算机才能正常的运行\",{\"1\":{\"74\":1}}],[\"计划编译器\",{\"1\":{\"232\":1}}],[\"计分\",{\"1\":{\"81\":1}}],[\"布隆过滤\",{\"1\":{\"1123\":2,\"1124\":1}}],[\"布隆过滤器走的是哈希思想\",{\"1\":{\"1123\":1}}],[\"布隆过滤器其实采用的是哈希思想来解决这个问题\",{\"1\":{\"1123\":1}}],[\"布隆过滤器使用场景\",{\"0\":{\"660\":1}}],[\"布隆过滤器说某个元素不在\",{\"1\":{\"659\":1}}],[\"布隆过滤器说某个元素存在\",{\"1\":{\"659\":1}}],[\"布隆过滤器hash计算\",{\"1\":{\"659\":1}}],[\"布隆过滤器的原理介绍\",{\"0\":{\"659\":1}}],[\"布隆过滤器示意图\",{\"1\":{\"658\":1}}],[\"布隆过滤器\",{\"0\":{\"657\":1},\"1\":{\"657\":1,\"658\":1}}],[\"布\",{\"1\":{\"81\":1}}],[\"剪刀\",{\"1\":{\"81\":1,\"147\":1}}],[\"石头\",{\"1\":{\"81\":1}}],[\"手动把读取到的json反序列化为对象\",{\"1\":{\"1223\":1}}],[\"手动把对象序列化为json\",{\"1\":{\"1223\":1}}],[\"手动反序列化\",{\"1\":{\"1223\":1}}],[\"手动序列化\",{\"1\":{\"1223\":1}}],[\"手动删除锁\",{\"1\":{\"1147\":1}}],[\"手动释放锁\",{\"1\":{\"1144\":1}}],[\"手动释放\",{\"1\":{\"1141\":1}}],[\"手动提交\",{\"1\":{\"1051\":1}}],[\"手动关闭datanode进程\",{\"1\":{\"879\":1}}],[\"手动启动datanode进程\",{\"1\":{\"878\":1}}],[\"手动离开安全模式\",{\"1\":{\"870\":1}}],[\"手动进入安全模式\",{\"1\":{\"870\":1}}],[\"手动获取安全模式状态信息\",{\"1\":{\"870\":1}}],[\"手动操作\",{\"1\":{\"870\":1}}],[\"手动清除entry对象\",{\"1\":{\"577\":1}}],[\"手动调用threadlocal的remove方法\",{\"1\":{\"577\":1}}],[\"手动加载分区数据\",{\"1\":{\"280\":1}}],[\"手动排除\",{\"1\":{\"105\":1}}],[\"手工操作阶段\",{\"1\":{\"212\":1}}],[\"手提包\",{\"1\":{\"147\":1}}],[\"手势\",{\"1\":{\"81\":1}}],[\"手机号这个的数据来存储当然是可以的\",{\"1\":{\"1105\":1}}],[\"手机号格式错误\",{\"1\":{\"1099\":2,\"1107\":1}}],[\"手机号位数判断\",{\"1\":{\"344\":1}}],[\"手机或者app端发起请求\",{\"1\":{\"1094\":1}}],[\"手机\",{\"1\":{\"147\":1,\"1089\":2}}],[\"手机充电器\",{\"1\":{\"4\":1}}],[\"手机在当地不能直接充电\",{\"1\":{\"4\":1}}],[\"上是否用\",{\"1\":{\"1482\":1}}],[\"上有没有指定\",{\"1\":{\"1398\":1}}],[\"上加了\",{\"1\":{\"1267\":1}}],[\"上或者是云存储上\",{\"1\":{\"1159\":1}}],[\"上万并发\",{\"1\":{\"1094\":1}}],[\"上一次查询的最小时间戳\",{\"1\":{\"1168\":1}}],[\"上一次使用时间戳\",{\"1\":{\"999\":1}}],[\"上一局的手势是否获胜\",{\"1\":{\"81\":1}}],[\"上车的票st\",{\"1\":{\"923\":1}}],[\"上发生的事件\",{\"1\":{\"867\":1}}],[\"上关联的附件\",{\"1\":{\"840\":1}}],[\"上源源不断的\",{\"1\":{\"746\":1}}],[\"上的流程是相同的\",{\"1\":{\"951\":1}}],[\"上的可写事件\",{\"1\":{\"843\":1}}],[\"上的各种事件\",{\"1\":{\"766\":1}}],[\"上的读写\",{\"1\":{\"748\":2}}],[\"上的\",{\"1\":{\"740\":1,\"743\":1,\"744\":2,\"746\":1,\"837\":2,\"838\":1}}],[\"上述配置文件中\",{\"1\":{\"1464\":1}}],[\"上述条件不满足\",{\"1\":{\"694\":1}}],[\"上述添加了一个联合索引\",{\"1\":{\"495\":1}}],[\"上述算法优点的集合\",{\"1\":{\"167\":1}}],[\"上述算法一般适合用于早期的批处理系统\",{\"1\":{\"167\":1}}],[\"上传安装包并解压\",{\"0\":{\"1193\":1}}],[\"上传\",{\"1\":{\"1046\":1}}],[\"上传hs2服务器本地或者hdfs\",{\"1\":{\"344\":1}}],[\"上传到maven私服仓库\",{\"1\":{\"95\":1}}],[\"上\",{\"1\":{\"206\":1,\"729\":1,\"740\":2,\"743\":1,\"748\":2,\"840\":1,\"843\":1,\"867\":1}}],[\"上图反应了有三个channel注册到了该selector\",{\"1\":{\"610\":1}}],[\"上图缺页中断发生了9次\",{\"1\":{\"191\":1}}],[\"上图中绿色表示已经分配的资源\",{\"1\":{\"178\":1}}],[\"上锁前可能会发生进程切换\",{\"1\":{\"169\":1}}],[\"上锁\",{\"1\":{\"168\":1}}],[\"上下文\",{\"1\":{\"80\":1,\"676\":2}}],[\"上面写的传播行为后三个会使之失效\",{\"1\":{\"1517\":1}}],[\"上面如果\",{\"1\":{\"1042\":1}}],[\"上面一起学习了aqs中几个重要的模板方法\",{\"1\":{\"585\":1}}],[\"上面是一些校验\",{\"1\":{\"566\":1}}],[\"上面引用的意思就是出现在group\",{\"1\":{\"306\":1}}],[\"上面的三种更加适合于交互式系统\",{\"1\":{\"167\":1}}],[\"上面的设计我们发现了它存在的问题\",{\"1\":{\"75\":1}}],[\"上面的双重检测锁模式看上去完美无缺\",{\"1\":{\"66\":1}}],[\"上面代码创建了一个默认的\",{\"1\":{\"768\":1}}],[\"上面代码可以看到已经组装了一台电脑\",{\"1\":{\"74\":1}}],[\"上面代码运行结果是false\",{\"1\":{\"68\":2}}],[\"上面在客户端代码中构建phone对象\",{\"1\":{\"17\":1}}],[\"上面示例是\",{\"1\":{\"14\":1}}],[\"策略\",{\"1\":{\"80\":1}}],[\"策略模式\",{\"0\":{\"78\":1}}],[\"颜色\",{\"1\":{\"77\":1}}],[\"按注解提供的\",{\"1\":{\"1489\":1}}],[\"按泛型参数类型筛选\",{\"1\":{\"1489\":1}}],[\"按类型装配的步骤\",{\"0\":{\"1482\":1}}],[\"按名字去获取时\",{\"1\":{\"1472\":1}}],[\"按数字升序\",{\"1\":{\"1260\":1}}],[\"按数据库查询\",{\"1\":{\"1172\":1}}],[\"按着最优规则处理数据对性能提高很大\",{\"1\":{\"1065\":1}}],[\"按key分配策略\",{\"1\":{\"1034\":1}}],[\"按钮置灰\",{\"1\":{\"1005\":1}}],[\"按序转换成所有列名\",{\"1\":{\"498\":1}}],[\"按省份和市划分\",{\"1\":{\"262\":1}}],[\"按信息交换的单位分类\",{\"1\":{\"207\":1}}],[\"按fcfs原则排队等待分配时间片\",{\"1\":{\"167\":1}}],[\"按照score排序后\",{\"1\":{\"1211\":2}}],[\"按照距离排序\",{\"1\":{\"1172\":1}}],[\"按照typeid分组\",{\"1\":{\"1171\":1}}],[\"按照字典序排序\",{\"1\":{\"1041\":1}}],[\"按照确诊病例数cases倒序排序\",{\"1\":{\"974\":1}}],[\"按照一定的规则对map输出的键值对进行分区partition\",{\"1\":{\"965\":1}}],[\"按照上述协议的规则\",{\"1\":{\"709\":1}}],[\"按照上述过程\",{\"1\":{\"178\":1}}],[\"按照实际占用字节数进行对齐\",{\"1\":{\"663\":1}}],[\"按照粒度\",{\"1\":{\"506\":1}}],[\"按照每个有序文件中的下一行数据对所有文件输入流进行排序\",{\"1\":{\"478\":1}}],[\"按照业务需求\",{\"1\":{\"414\":1}}],[\"按照登陆日期排序\",{\"1\":{\"400\":3}}],[\"按照登陆时间进行排序\",{\"1\":{\"399\":1}}],[\"按照用户id分区\",{\"1\":{\"400\":3}}],[\"按照传输速率分类\",{\"1\":{\"207\":1}}],[\"按照使用特性分类\",{\"1\":{\"207\":1}}],[\"按照动态分区分配算法\",{\"1\":{\"182\":1}}],[\"按照152637顺序执行\",{\"1\":{\"169\":1}}],[\"按照152637\",{\"1\":{\"169\":1}}],[\"按照各个进程到达就绪队列的顺序\",{\"1\":{\"167\":1}}],[\"按照作业\",{\"1\":{\"167\":1}}],[\"按照某种方法和策略从就绪队列中选取一个进程\",{\"1\":{\"164\":1}}],[\"按照maven工程结构放置的文件会默认被编译和打包\",{\"1\":{\"102\":1}}],[\"按一定的原则从外存上处于后备队列的作业中选中一个或多个作业\",{\"1\":{\"164\":1}}],[\"按某种顺序调用其包含的基本方法\",{\"1\":{\"84\":1}}],[\"按\",{\"0\":{\"1034\":1},\"1\":{\"77\":1,\"663\":1}}],[\"动作发生后\",{\"1\":{\"798\":2}}],[\"动过了\",{\"1\":{\"563\":1}}],[\"动态通知调用复杂程度高\",{\"1\":{\"1350\":1}}],[\"动态通知调用\",{\"0\":{\"1347\":1}}],[\"动态设置表名的问题\",{\"1\":{\"1230\":1}}],[\"动态缩容\",{\"0\":{\"879\":1}}],[\"动态规划\",{\"1\":{\"648\":1,\"649\":1}}],[\"动态数据加载\",{\"1\":{\"284\":1}}],[\"动态分区插入\",{\"0\":{\"289\":1},\"1\":{\"289\":1}}],[\"动态分区模式\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"动态分区加载\",{\"1\":{\"261\":1}}],[\"动态分区\",{\"1\":{\"259\":1}}],[\"动态分区分配算法\",{\"0\":{\"183\":1}}],[\"动态分区分配\",{\"1\":{\"182\":1}}],[\"动态分配\",{\"1\":{\"213\":1}}],[\"动态重定位时允许程序在内存中发生移动\",{\"1\":{\"179\":1}}],[\"动态重定位\",{\"1\":{\"179\":1}}],[\"动态性\",{\"1\":{\"159\":1}}],[\"动态代理实现为例\",{\"1\":{\"1340\":1}}],[\"动态代理原理查不多\",{\"1\":{\"1317\":1}}],[\"动态代理进阶\",{\"0\":{\"1308\":1}}],[\"动态代理相同\",{\"1\":{\"1306\":1}}],[\"动态代理要求目标必须实现接口\",{\"1\":{\"1305\":1}}],[\"动态代理\",{\"0\":{\"1304\":1,\"1309\":1}}],[\"动态代理与静态代理相比较\",{\"1\":{\"61\":1}}],[\"动态代理和静态代理\",{\"1\":{\"61\":1}}],[\"动态代理的执行流程是什么样\",{\"1\":{\"59\":1}}],[\"动态代理又有jdk代理和cglib代理两种\",{\"1\":{\"56\":1}}],[\"动物\",{\"1\":{\"147\":1}}],[\"动力源\",{\"1\":{\"77\":1}}],[\"汽车\",{\"1\":{\"147\":1}}],[\"汽车按\",{\"1\":{\"77\":1}}],[\"汽车分类管理程序\",{\"1\":{\"77\":1}}],[\"黑名单\",{\"1\":{\"879\":1,\"880\":1}}],[\"黑名单功能等等\",{\"1\":{\"660\":1}}],[\"黑桃队长\",{\"1\":{\"256\":1}}],[\"黑白名单机制\",{\"0\":{\"880\":1}}],[\"黑白图像上色\",{\"1\":{\"130\":1}}],[\"黑白老照片上色\",{\"1\":{\"125\":3}}],[\"黑白老照片上色修复\",{\"1\":{\"124\":1}}],[\"黑夜转成白天\",{\"1\":{\"124\":1}}],[\"黑色汽车和红色汽车等\",{\"1\":{\"77\":1}}],[\"黑箱\",{\"1\":{\"77\":1}}],[\"黑马品牌的安全门具有防盗\",{\"1\":{\"75\":1}}],[\"复杂了很多\",{\"1\":{\"779\":1}}],[\"复杂度是\",{\"1\":{\"665\":1}}],[\"复杂度获取字符串长度\",{\"1\":{\"663\":1}}],[\"复杂数据类型的使用通常需要和分隔符指定语法配合使用\",{\"1\":{\"248\":1}}],[\"复杂数据类型\",{\"1\":{\"248\":2}}],[\"复制分片之所以重要\",{\"1\":{\"1067\":1}}],[\"复制因子\",{\"1\":{\"905\":1}}],[\"复制\",{\"1\":{\"903\":1}}],[\"复制公钥到新机器\",{\"1\":{\"878\":1}}],[\"复制数据阶段\",{\"1\":{\"851\":1}}],[\"复制等操作\",{\"1\":{\"780\":1}}],[\"复制内核态代码执行结果\",{\"1\":{\"676\":1}}],[\"复制用户态参数\",{\"1\":{\"676\":1}}],[\"复制文件\",{\"1\":{\"194\":1}}],[\"复制奖状\",{\"1\":{\"52\":1,\"54\":1}}],[\"复用的灵活性高\",{\"1\":{\"77\":1}}],[\"复用\",{\"1\":{\"77\":2}}],[\"通知调用过程\",{\"0\":{\"1341\":1}}],[\"通知对象如何创建\",{\"1\":{\"1339\":1}}],[\"通知代码从哪儿来\",{\"1\":{\"1339\":1}}],[\"通知和一个\",{\"1\":{\"1322\":1}}],[\"通知\",{\"0\":{\"1323\":1},\"1\":{\"1322\":3}}],[\"通知client客户端新的master地址\",{\"1\":{\"526\":1}}],[\"通信\",{\"1\":{\"953\":1}}],[\"通信模型\",{\"1\":{\"949\":1}}],[\"通信双方有一端是client\",{\"1\":{\"949\":1}}],[\"通信以启动\",{\"1\":{\"947\":1}}],[\"通配符方式获取一组\",{\"1\":{\"1240\":1,\"1243\":1}}],[\"通配符\",{\"1\":{\"927\":1,\"1437\":1}}],[\"通道可以从缓冲区读取数据\",{\"1\":{\"610\":1}}],[\"通道可以实现异步读写数据\",{\"1\":{\"610\":1}}],[\"通道是双向的可以进行读写\",{\"1\":{\"610\":1}}],[\"通道控制方式\",{\"1\":{\"209\":1}}],[\"通俗来说就是hive打算如何去做这件事\",{\"1\":{\"440\":1}}],[\"通俗点讲\",{\"1\":{\"348\":1}}],[\"通用指令是部分数据类型的\",{\"1\":{\"1205\":1}}],[\"通用命令\",{\"0\":{\"1205\":1}}],[\"通用寄存器\",{\"1\":{\"157\":1}}],[\"通用模块\",{\"1\":{\"110\":1}}],[\"通用工具模块等\",{\"1\":{\"110\":1}}],[\"通常来说uv会比pv大很多\",{\"1\":{\"1179\":1}}],[\"通常你可以把他看成一个攻击\",{\"1\":{\"1177\":1}}],[\"通常用于解决缓存和数据库不一致问题\",{\"1\":{\"1119\":1}}],[\"通常用到两种模式\",{\"1\":{\"611\":1}}],[\"通常\",{\"1\":{\"1062\":1}}],[\"通常为了方便使用\",{\"1\":{\"990\":1}}],[\"通常以join的字段作为输出的key\",{\"1\":{\"988\":1}}],[\"通常是通过类路径扫描\",{\"1\":{\"1507\":1}}],[\"通常是一些服务\",{\"1\":{\"951\":1}}],[\"通常是存储在关系数据库如\",{\"1\":{\"232\":1}}],[\"通常缩写为\",{\"1\":{\"916\":1}}],[\"通常可以把页面置换算法看成是淘汰页面的规则\",{\"1\":{\"690\":1}}],[\"通常采用\",{\"1\":{\"576\":1}}],[\"通常采用连续分配方式\",{\"1\":{\"181\":1}}],[\"通常hash索引的效率更高\",{\"1\":{\"491\":1}}],[\"通常在10\",{\"1\":{\"445\":1}}],[\"通常在编程时算法会被写在具体的方法中\",{\"1\":{\"79\":1}}],[\"通常从真实的物理表查询中创建生成视图\",{\"1\":{\"270\":1}}],[\"通常将磁盘空间分为文件区和对换区两部分\",{\"1\":{\"181\":1}}],[\"通常把覆盖了软件的机器称为扩充机器\",{\"1\":{\"154\":1}}],[\"通常类的复用分为继承复用和合成复用两种\",{\"1\":{\"77\":1}}],[\"通过配置虚拟机参数\",{\"1\":{\"1508\":1}}],[\"通过配置文件可以设置仓库数量\",{\"1\":{\"1202\":1}}],[\"通过构造方法实例化得到一个对象\",{\"1\":{\"1505\":1}}],[\"通过构造两个gan网络和两个cycle\",{\"1\":{\"117\":1}}],[\"通过检查容器的\",{\"1\":{\"1454\":1}}],[\"通过监听事件2️⃣来调用\",{\"1\":{\"1446\":1}}],[\"通过它的声明\",{\"1\":{\"1503\":1}}],[\"通过它完成整个调用\",{\"1\":{\"1343\":1}}],[\"通过它可以知道事件和哪个channel的事件\",{\"1\":{\"840\":1}}],[\"通过类元数据\",{\"1\":{\"1274\":1}}],[\"通过注解元数据\",{\"1\":{\"1274\":1}}],[\"通过接口回调将\",{\"1\":{\"1310\":1}}],[\"通过接口回调\",{\"1\":{\"1255\":1}}],[\"通过接口或抽象类声明真实主题和代理对象实现的业务方法\",{\"1\":{\"57\":1}}],[\"通过mybatisx插件自动生成代码\",{\"0\":{\"1237\":1}}],[\"通过分步查询解决多对一映射关系\",{\"1\":{\"1230\":1}}],[\"通过级联查询将结果直接映射在user实体类中\",{\"1\":{\"1230\":1}}],[\"通过aop编织到模块中\",{\"1\":{\"1510\":1}}],[\"通过association解决多对一映射关系\",{\"1\":{\"1230\":1}}],[\"通过atomicmarkablereference判断是否被修改\",{\"1\":{\"563\":1}}],[\"通过atomicstampedreference判断是否更改了版本号\",{\"1\":{\"563\":1}}],[\"通过无限下拉刷新获取新的信息\",{\"1\":{\"1166\":1}}],[\"通过参数2\",{\"1\":{\"1152\":1}}],[\"通过拿锁\",{\"1\":{\"1147\":1}}],[\"通过这个示例结合\",{\"1\":{\"1243\":1}}],[\"通过这个案例初步说明我们解决了锁误删的问题\",{\"1\":{\"1144\":1}}],[\"通过这个递增的序列号来区分\",{\"1\":{\"998\":1}}],[\"通过加锁可以解决在单机情况下的一人一单安全问题\",{\"1\":{\"1138\":1}}],[\"通过不同的前缀来区分不同业务的id\",{\"1\":{\"1132\":1}}],[\"通过不同的文件格式\",{\"1\":{\"426\":1}}],[\"通过定义回调函数\",{\"1\":{\"1129\":1}}],[\"通过之前的淘汰\",{\"1\":{\"1122\":1}}],[\"通过zookeeper找到消费者对应的offset\",{\"1\":{\"1051\":1}}],[\"通过zookeeper找partition对应的leader\",{\"1\":{\"1051\":2}}],[\"通过以上讲解\",{\"1\":{\"1100\":1}}],[\"通过以上的流程分析\",{\"1\":{\"1005\":1}}],[\"通过以上的分析\",{\"1\":{\"662\":1}}],[\"通过以下指令\",{\"1\":{\"1050\":1}}],[\"通过isr快速进行选举\",{\"1\":{\"1050\":1}}],[\"通过消息队列将需要进行处理的消息进行存储\",{\"1\":{\"1009\":1}}],[\"通过雪花算法生成下一个id\",{\"1\":{\"999\":1}}],[\"通过handleradapter对handler进行封装\",{\"1\":{\"1530\":1}}],[\"通过hash的方式\",{\"1\":{\"527\":1}}],[\"通过help\",{\"1\":{\"1205\":1}}],[\"通过http方式请求maptask获取属于自己的文件\",{\"1\":{\"980\":1}}],[\"通过自定义对象封装\",{\"1\":{\"974\":1}}],[\"通过指定input文件夹\",{\"1\":{\"962\":1}}],[\"通过该\",{\"1\":{\"949\":3}}],[\"通过该接口即可访问远程服务提供的功能\",{\"1\":{\"63\":1}}],[\"通过直接产看块信息时是加密的\",{\"1\":{\"928\":1}}],[\"通过web\",{\"1\":{\"928\":1}}],[\"通过ugo来给予不同的角色不同的权限\",{\"1\":{\"925\":1}}],[\"通过相关接口从主机获取相关用户身份\",{\"1\":{\"921\":1}}],[\"通过下述实现\",{\"1\":{\"906\":1}}],[\"通过下面代码可以发现\",{\"1\":{\"261\":1}}],[\"通过tcp端口号定位进程pid\",{\"1\":{\"885\":1}}],[\"通过fencing机制来避免\",{\"1\":{\"885\":1}}],[\"通过矩阵乘法\",{\"1\":{\"875\":1}}],[\"通过在pom文件中配置aspectj编译插件实现\",{\"1\":{\"1508\":1}}],[\"通过在配置文件中指定mybatis\",{\"1\":{\"1230\":1}}],[\"通过在hdfs\",{\"1\":{\"874\":1}}],[\"通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范\",{\"1\":{\"107\":1}}],[\"通过datanode的日志查看是否配置完成\",{\"1\":{\"872\":1}}],[\"通过快照diff信息进行数据的同步\",{\"1\":{\"869\":1}}],[\"通过专门线程访问引用队列\",{\"1\":{\"855\":1}}],[\"通过网络把数据发送出去\",{\"1\":{\"827\":1}}],[\"通过代码里面的调用request和cancel方法交互\",{\"1\":{\"719\":1}}],[\"通过publisher\",{\"1\":{\"717\":1}}],[\"通过页号去页表查找该页号对应的块号\",{\"1\":{\"683\":1}}],[\"通过epoll\",{\"1\":{\"680\":1}}],[\"通过遍历文件描述符来获取已经就绪的socket\",{\"1\":{\"680\":1}}],[\"通过使用二进制安全的\",{\"1\":{\"663\":1}}],[\"通过spring\",{\"1\":{\"1523\":1}}],[\"通过ssh登录目标节点\",{\"1\":{\"885\":1}}],[\"通过system\",{\"1\":{\"635\":1}}],[\"通过select上面的student表\",{\"1\":{\"288\":1}}],[\"通过流所生成元素的hashcode\",{\"1\":{\"616\":1}}],[\"通过collection解决一对多映射关系和通过分步查询解决一对多映射关系如上述代码相差不大\",{\"1\":{\"1230\":1}}],[\"通过compare\",{\"1\":{\"603\":1}}],[\"通过cpu的利用率计算得到\",{\"1\":{\"576\":1}}],[\"通过重复利用已创建的线程来降低线程创建和销毁所带来的消耗\",{\"1\":{\"570\":1}}],[\"通过上图可以看出\",{\"1\":{\"1532\":1}}],[\"通过上图\",{\"1\":{\"1042\":1}}],[\"通过上述链表可以构造出一张图\",{\"1\":{\"513\":1}}],[\"通过上面的案例可以发现cluster\",{\"1\":{\"313\":1}}],[\"通过隐藏列和版本链\",{\"1\":{\"503\":1}}],[\"通过创建唯一索引\",{\"1\":{\"485\":1}}],[\"通过维护一个小顶堆来找出所有小文件中出现频率最高的100词\",{\"1\":{\"477\":1}}],[\"通过run方法进行\",{\"1\":{\"1522\":1}}],[\"通过rpc请求namenode创建文件\",{\"1\":{\"901\":1}}],[\"通过rank函数随机值实现随机分区\",{\"1\":{\"465\":1}}],[\"通过regexserde类\",{\"1\":{\"374\":1}}],[\"通过减少shuffle数据量和reducer阶段的执行时间\",{\"1\":{\"464\":1}}],[\"通过数据编码和压缩\",{\"1\":{\"429\":1}}],[\"通过运行一个mapreduce程序来构建索引\",{\"1\":{\"423\":1}}],[\"通过时间进行标记每个状态的生命周期\",{\"1\":{\"405\":1}}],[\"通过判断nextday和nextlogin是否相等就可以判断有没有连续登录2天\",{\"1\":{\"400\":1}}],[\"通过日期函数计算出登陆以后第二天的日期\",{\"1\":{\"399\":1}}],[\"通过lead函数计算出用户下次登陆时间\",{\"1\":{\"399\":1}}],[\"通过load命令向分区表载入数据\",{\"1\":{\"285\":1}}],[\"通过正则表达式匹配每一行数据即可\",{\"1\":{\"374\":1}}],[\"通过子查询完成\",{\"1\":{\"351\":1}}],[\"通过多重插入进行一次扫描\",{\"1\":{\"288\":1}}],[\"通过一个庞大的二进制数组\",{\"1\":{\"1123\":1}}],[\"通过一个mr程序\",{\"1\":{\"286\":1}}],[\"通过一个父类调用其子类的操作\",{\"1\":{\"86\":1}}],[\"通过视图来限制数据访问可以用来保护信息不被随意查询\",{\"1\":{\"272\":1}}],[\"通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\",{\"1\":{\"210\":1}}],[\"通过执行该程序就可以找到引导块\",{\"1\":{\"206\":1}}],[\"通过旋转磁盘\",{\"1\":{\"204\":1}}],[\"通过中断\",{\"1\":{\"157\":1}}],[\"通过触发父工程构建命令\",{\"1\":{\"108\":1}}],[\"通过聚合\",{\"1\":{\"108\":4}}],[\"通过依赖元素\",{\"1\":{\"100\":1}}],[\"通过设置坐标的依赖范围\",{\"1\":{\"100\":1}}],[\"通过编写依赖jar包的gav必要属性\",{\"1\":{\"99\":1}}],[\"通过实现标准的构建生命周期\",{\"1\":{\"91\":1}}],[\"通过实现一个新的建造者类就可以完成\",{\"1\":{\"15\":1}}],[\"通过\",{\"1\":{\"91\":1,\"395\":1,\"663\":1,\"766\":1,\"813\":3,\"855\":1,\"910\":1,\"953\":1,\"1152\":1,\"1322\":1,\"1343\":1,\"1350\":1,\"1411\":1,\"1425\":1,\"1444\":1,\"1525\":1}}],[\"通过对子类的具体实现扩展不同的行为\",{\"1\":{\"86\":1}}],[\"通过对部件的组装可以返回一辆完整的汽车\",{\"1\":{\"20\":1}}],[\"通过输入流获取\",{\"1\":{\"70\":1}}],[\"通过源代码查看使用的是哪儿种单例模式\",{\"1\":{\"70\":1}}],[\"通过反射将\",{\"1\":{\"742\":1}}],[\"通过反射调用\",{\"1\":{\"69\":1}}],[\"通过反射创建新的单例类\",{\"1\":{\"69\":1}}],[\"通过阿里巴巴开源的\",{\"1\":{\"59\":1}}],[\"通过复制该原型对象来创建一个和原型对象相同的新对象\",{\"1\":{\"49\":1}}],[\"通过继承或引用适配者的对象\",{\"1\":{\"5\":1}}],[\"洽淡业务\",{\"1\":{\"76\":1}}],[\"媒体公司类\",{\"1\":{\"76\":1}}],[\"粉丝类\",{\"1\":{\"76\":1}}],[\"朋友圈点赞列表\",{\"1\":{\"1209\":1}}],[\"朋友\",{\"1\":{\"76\":1}}],[\"说说你对spring\",{\"0\":{\"1520\":1,\"1525\":1}}],[\"说说aop的应用场景\",{\"0\":{\"1510\":1}}],[\"说说对mysql索引的理解\",{\"0\":{\"485\":1}}],[\"说一说你知道的spring\",{\"0\":{\"1531\":1}}],[\"说一说对beanfactory的了解\",{\"0\":{\"1502\":1}}],[\"说一说对spring容器的了解\",{\"0\":{\"1501\":1}}],[\"说一下回收的过程\",{\"1\":{\"633\":1}}],[\"说一下gc算法\",{\"1\":{\"633\":1}}],[\"说到ioc就不得不说di\",{\"1\":{\"1500\":1}}],[\"说下g1的应用场景\",{\"1\":{\"633\":1}}],[\"说话\",{\"1\":{\"76\":1}}],[\"说明是重复下单\",{\"1\":{\"1156\":1}}],[\"说明他可以下单\",{\"1\":{\"1155\":1}}],[\"说明锁的不是自己\",{\"1\":{\"1151\":1}}],[\"说明没有假死\",{\"1\":{\"707\":1}}],[\"说明字符串还没结束\",{\"1\":{\"662\":1}}],[\"说明该元素不在布隆过滤器中\",{\"1\":{\"659\":2}}],[\"说明\",{\"1\":{\"14\":1,\"47\":1,\"81\":1,\"480\":7,\"481\":8,\"482\":6,\"483\":7,\"493\":2,\"631\":2,\"1013\":1,\"1152\":1,\"1504\":1,\"1514\":1}}],[\"陌生人\",{\"1\":{\"76\":1}}],[\"迪米特法则中的\",{\"1\":{\"76\":1}}],[\"迪米特法则又叫最少知识原则\",{\"1\":{\"76\":1}}],[\"迪米特法则\",{\"0\":{\"76\":1}}],[\"防止删除别人的锁\",{\"1\":{\"1142\":1}}],[\"防止死锁问题的发生\",{\"1\":{\"1147\":1}}],[\"防止死锁\",{\"1\":{\"1142\":1}}],[\"防止装包以及拆包引发bug\",{\"1\":{\"1127\":1}}],[\"防止缓存击穿\",{\"1\":{\"1127\":1}}],[\"防止缓存穿透\",{\"1\":{\"660\":1}}],[\"防止过高的数据访问猛冲系统\",{\"1\":{\"1113\":1}}],[\"防止车体加速后因惯性\",{\"1\":{\"1113\":1}}],[\"防止kafka的速度过快\",{\"1\":{\"1056\":1}}],[\"防止好人误做坏事\",{\"1\":{\"922\":1}}],[\"防止由于一个文件句柄的阻塞读\",{\"1\":{\"680\":1}}],[\"防止核心api被随意篡改\",{\"1\":{\"623\":1}}],[\"防止子类无意间破坏不变性\",{\"1\":{\"566\":1}}],[\"防止因字段类型不同造成的隐式转换\",{\"1\":{\"481\":1}}],[\"防止进程忙等待\",{\"1\":{\"168\":1}}],[\"防止用户进行非法操作\",{\"1\":{\"158\":1}}],[\"防火\",{\"1\":{\"75\":2}}],[\"防火的功能\",{\"1\":{\"75\":1}}],[\"防火墙就将你的浏览器的请求转给互联网\",{\"1\":{\"63\":1}}],[\"防火墙\",{\"1\":{\"63\":1,\"878\":1}}],[\"防盗\",{\"1\":{\"75\":2}}],[\"防盗功能提取成一个接口\",{\"1\":{\"75\":1}}],[\"防盗的功能\",{\"1\":{\"75\":1}}],[\"防水功能呢\",{\"1\":{\"75\":1}}],[\"防水\",{\"1\":{\"75\":4}}],[\"各州累计病例数最多top1县\",{\"0\":{\"974\":1}}],[\"各州累计病例数量统计\",{\"0\":{\"972\":1}}],[\"各州累计病例分区统计\",{\"0\":{\"973\":1}}],[\"各自分工\",{\"1\":{\"889\":1}}],[\"各自的优缺点\",{\"1\":{\"633\":3}}],[\"各有什么优劣\",{\"1\":{\"633\":1}}],[\"各级页表的大小不能超过一个面\",{\"1\":{\"186\":1}}],[\"各级队列优先级从高到低\",{\"1\":{\"167\":1}}],[\"各表项的顺序不一定按照地址递增的顺序排序\",{\"1\":{\"182\":1}}],[\"各并发执行的进程以各自独立的\",{\"1\":{\"168\":1}}],[\"各作业带权周转时间之和\",{\"1\":{\"166\":1}}],[\"各作业周转时间之和\",{\"1\":{\"166\":1}}],[\"各种数据寄存器等\",{\"1\":{\"165\":1}}],[\"各种gan的keras实现\",{\"1\":{\"128\":1}}],[\"各线程间也能并发\",{\"1\":{\"163\":1}}],[\"各进程往往是宏观上同时共享使用设备\",{\"1\":{\"213\":1}}],[\"各进程并发同时访问可能造成数据不一致\",{\"1\":{\"187\":1}}],[\"各进程因竞争资源而造成的一种互相等待对方手里的资源\",{\"1\":{\"175\":1}}],[\"各进程要互斥的访问管道\",{\"1\":{\"162\":1}}],[\"各进程按各自独立的\",{\"1\":{\"159\":1}}],[\"各进程可以并发的执行\",{\"1\":{\"159\":1}}],[\"各个任务通过某个\",{\"1\":{\"953\":1}}],[\"各个记录在物理上可以顺序存储或链式存储\",{\"1\":{\"195\":1}}],[\"各个段表项的长度是相同的\",{\"1\":{\"187\":1}}],[\"各个线程可占用不同的cpu\",{\"1\":{\"163\":1}}],[\"各个程序的代码\",{\"1\":{\"159\":1}}],[\"各个配件的接口\",{\"1\":{\"74\":1}}],[\"各部件面临着复杂的变化\",{\"1\":{\"16\":1}}],[\"koushuangbwcx\",{\"1\":{\"1525\":1}}],[\"k4\",{\"1\":{\"1205\":1}}],[\"k3\",{\"1\":{\"1205\":4,\"1206\":2}}],[\"k1\",{\"1\":{\"1205\":3,\"1206\":2}}],[\"kafka就会自动将日志设置为待删除\",{\"1\":{\"1056\":1}}],[\"kafka读写流程\",{\"0\":{\"1051\":1}}],[\"kafka一个topic有多个分区leader\",{\"1\":{\"1048\":1}}],[\"kafka在创建topic的时候\",{\"1\":{\"1048\":1}}],[\"kafka原理\",{\"0\":{\"1047\":1}}],[\"kafka引入了\",{\"1\":{\"1029\":1}}],[\"kafka的消息不丢失\",{\"0\":{\"1054\":1}}],[\"kafka的消费者api是一批一批数据的拉取\",{\"1\":{\"1024\":1}}],[\"kafka的数据组织结构\",{\"1\":{\"1052\":1}}],[\"kafka的物理存储\",{\"0\":{\"1052\":1}}],[\"kafka的leader负责读写\",{\"1\":{\"1048\":1}}],[\"kafka的应用场景\",{\"0\":{\"1009\":1}}],[\"kafka消费者一次拉取一批数据过来\",{\"1\":{\"1024\":1}}],[\"kafkaconsumer\",{\"1\":{\"1024\":1}}],[\"kafkaconsumer<>\",{\"1\":{\"1024\":1}}],[\"kafkaconsumer<string\",{\"1\":{\"1024\":1}}],[\"kafkaconsumerconfigproperties\",{\"1\":{\"1024\":4}}],[\"kafkaconfig\",{\"1\":{\"1023\":1}}],[\"kafkaproducer<>\",{\"1\":{\"1023\":1,\"1025\":1}}],[\"kafkaproducer<string\",{\"1\":{\"1023\":1,\"1025\":1}}],[\"kafkaproducerconfigproperties\",{\"1\":{\"1023\":4,\"1025\":1}}],[\"kafka<\",{\"1\":{\"1022\":1}}],[\"kafka客户端工具\",{\"1\":{\"1022\":1}}],[\"kafka中的leader和follower是相对分区有意义\",{\"1\":{\"1048\":1}}],[\"kafka中的分区副本机制\",{\"0\":{\"1030\":1}}],[\"kafka中的重要概念\",{\"0\":{\"1026\":1}}],[\"kafka中提供了内置的性能测试工具\",{\"1\":{\"1021\":1}}],[\"kafka中所有的消息都是保存在主题中\",{\"1\":{\"1015\":1}}],[\"kafka集群是必须要有zookeeper的\",{\"1\":{\"1012\":1}}],[\"kafka简介\",{\"0\":{\"1007\":1}}],[\"kafka\",{\"0\":{\"1006\":1,\"1011\":1,\"1012\":1,\"1016\":1,\"1017\":1,\"1018\":1,\"1019\":1,\"1022\":1,\"1044\":1},\"1\":{\"1008\":1,\"1012\":12,\"1013\":7,\"1015\":2,\"1016\":1,\"1017\":1,\"1019\":1,\"1020\":1,\"1021\":2,\"1023\":6,\"1024\":3,\"1025\":2,\"1026\":3,\"1029\":1,\"1037\":2,\"1038\":1,\"1040\":2,\"1041\":1,\"1042\":1,\"1045\":2,\"1046\":28,\"1050\":1}}],[\"k2\",{\"1\":{\"968\":1,\"1205\":4,\"1206\":2}}],[\"kms<\",{\"1\":{\"936\":3}}],[\"kms配置\",{\"0\":{\"936\":1}}],[\"kms用对应的ez\",{\"1\":{\"934\":1}}],[\"kms\",{\"0\":{\"933\":1},\"1\":{\"936\":16}}],[\"kdc服务默认会安装在一个域的域控中\",{\"1\":{\"923\":1}}],[\"kdc\",{\"1\":{\"923\":1}}],[\"k个数据块组成一个向量被乘上一个生成矩阵\",{\"1\":{\"875\":1}}],[\"k++\",{\"1\":{\"649\":1}}],[\"klassid=123456\",{\"1\":{\"1525\":1}}],[\"klassid\",{\"1\":{\"1525\":3,\"1531\":3}}],[\"klasses\",{\"1\":{\"1525\":2,\"1531\":1}}],[\"klass\",{\"1\":{\"631\":1}}],[\"kb\",{\"1\":{\"487\":1,\"658\":1}}],[\"k\",{\"1\":{\"368\":2,\"579\":4,\"621\":2,\"649\":4,\"742\":5,\"926\":1}}],[\"kv之间\",{\"1\":{\"252\":1}}],[\"kpi\",{\"1\":{\"227\":1}}],[\"ken的杂谈\",{\"1\":{\"1532\":1}}],[\"ke\",{\"1\":{\"1046\":6}}],[\"kerberos所具有的角色\",{\"1\":{\"923\":1}}],[\"kerberos是麻省理工学院\",{\"1\":{\"923\":1}}],[\"kerberos认证\",{\"0\":{\"923\":1}}],[\"kerberos\",{\"1\":{\"921\":1}}],[\"kernel会给用户进程发送一个signal\",{\"1\":{\"679\":1}}],[\"kernel会等待数据准备完成\",{\"1\":{\"679\":1}}],[\"kernel会\",{\"1\":{\"679\":1}}],[\"kernel就开始了io的第一个阶段\",{\"1\":{\"679\":1}}],[\"kernel\",{\"1\":{\"676\":1,\"854\":1,\"856\":1}}],[\"keras\",{\"1\":{\"128\":1,\"146\":1}}],[\"keepalivetime\",{\"1\":{\"572\":2}}],[\"key的层级结构\",{\"0\":{\"1207\":1}}],[\"key一般是string类型\",{\"1\":{\"1204\":1}}],[\"key一样的会被分到同一分组处理\",{\"1\":{\"988\":1}}],[\"key类型参数会放入keys数组\",{\"1\":{\"1146\":1}}],[\"key前缀\",{\"1\":{\"1129\":2}}],[\"keyprefix\",{\"1\":{\"1129\":9,\"1132\":2}}],[\"key要方便携带\",{\"1\":{\"1105\":1}}],[\"key要具有唯一性\",{\"1\":{\"1105\":1}}],[\"keyword\",{\"1\":{\"1089\":2}}],[\"keyword表示关键字不分开\",{\"1\":{\"1089\":1}}],[\"keywithrandompartitioner\",{\"1\":{\"1035\":2}}],[\"keybytes\",{\"1\":{\"1035\":1}}],[\"key为null\",{\"1\":{\"1032\":1}}],[\"key表示每行首字符偏移值\",{\"1\":{\"979\":1}}],[\"keyout\",{\"1\":{\"959\":1,\"961\":1}}],[\"keyin\",{\"1\":{\"959\":1,\"961\":1}}],[\"keyname\",{\"1\":{\"936\":1}}],[\"keytool\",{\"1\":{\"936\":1}}],[\"key是每一行的起始位置偏移量\",{\"1\":{\"965\":1}}],[\"key是更为重要的数据\",{\"1\":{\"934\":1}}],[\"key是用来加解密所有文件的密匙\",{\"1\":{\"934\":1}}],[\"key将edek解密出dek发送给client\",{\"1\":{\"934\":1}}],[\"key没设置过期时间为什么被redis主动删除了\",{\"0\":{\"521\":1}}],[\"key过期了为什么内存没释放\",{\"0\":{\"519\":1}}],[\"key=100000\",{\"1\":{\"470\":1}}],[\"key2\",{\"1\":{\"326\":3,\"1165\":2,\"1210\":3}}],[\"key1\",{\"1\":{\"326\":9,\"1165\":2,\"1210\":3}}],[\"key\",{\"0\":{\"1034\":1},\"1\":{\"42\":3,\"252\":1,\"326\":15,\"373\":1,\"466\":1,\"480\":2,\"511\":1,\"523\":2,\"528\":1,\"579\":20,\"740\":2,\"742\":2,\"743\":2,\"831\":1,\"834\":3,\"836\":6,\"837\":1,\"838\":1,\"840\":14,\"843\":12,\"846\":8,\"923\":1,\"931\":2,\"932\":1,\"933\":2,\"934\":2,\"936\":6,\"958\":1,\"960\":2,\"968\":2,\"972\":3,\"973\":5,\"974\":4,\"980\":1,\"983\":1,\"985\":2,\"986\":2,\"988\":5,\"990\":2,\"1023\":3,\"1024\":5,\"1034\":1,\"1035\":1,\"1107\":2,\"1111\":4,\"1122\":3,\"1124\":3,\"1127\":9,\"1128\":3,\"1129\":25,\"1133\":1,\"1141\":1,\"1142\":3,\"1144\":3,\"1146\":1,\"1147\":1,\"1151\":3,\"1155\":1,\"1156\":2,\"1161\":8,\"1162\":13,\"1164\":1,\"1165\":3,\"1167\":3,\"1168\":4,\"1171\":5,\"1172\":4,\"1174\":1,\"1175\":5,\"1176\":5,\"1190\":1,\"1205\":6,\"1206\":3,\"1207\":1,\"1208\":2,\"1209\":5,\"1210\":4,\"1211\":11,\"1355\":1,\"1446\":1,\"1464\":1,\"1489\":3}}],[\"keysuffix\",{\"1\":{\"1175\":2,\"1176\":2}}],[\"keystore\",{\"1\":{\"932\":2,\"936\":5}}],[\"keyset\",{\"1\":{\"42\":1}}],[\"keys\",{\"1\":{\"42\":2,\"256\":1,\"290\":1,\"339\":3,\"742\":1,\"834\":2,\"836\":2,\"838\":1,\"840\":1,\"846\":2,\"1146\":3,\"1151\":10,\"1205\":8}}],[\"kingstonmemory\",{\"1\":{\"74\":6}}],[\"海盗船等\",{\"1\":{\"74\":1}}],[\"西部大镖客\",{\"1\":{\"256\":1}}],[\"西兰花\",{\"1\":{\"147\":1}}],[\"西数等\",{\"1\":{\"74\":1}}],[\"西安\",{\"1\":{\"54\":2}}],[\"内的\",{\"1\":{\"1476\":1}}],[\"内嵌数据库连接池\",{\"1\":{\"1454\":1}}],[\"内嵌容器\",{\"0\":{\"1447\":1,\"1448\":1},\"1\":{\"1251\":1}}],[\"内嵌模式\",{\"0\":{\"242\":1},\"1\":{\"241\":2,\"242\":2}}],[\"内容如下\",{\"1\":{\"1197\":1,\"1213\":1}}],[\"内容获取效率低\",{\"1\":{\"1166\":1}}],[\"内容就是keystore设置的密码\",{\"1\":{\"936\":1}}],[\"内容拷贝至\",{\"1\":{\"841\":1}}],[\"内容为\",{\"1\":{\"796\":1}}],[\"内容为一个空格\",{\"1\":{\"329\":1}}],[\"内容来自于刚才的\",{\"1\":{\"779\":1}}],[\"内这个\",{\"1\":{\"775\":1}}],[\"内如果没有向服务器写数据\",{\"1\":{\"707\":1}}],[\"内如果没有收到\",{\"1\":{\"707\":1}}],[\"内置的注入和初始化不受扩展功能的影响\",{\"1\":{\"1284\":1}}],[\"内置\",{\"1\":{\"1284\":2}}],[\"内置了一种专门用于解析json文件的serde解析器\",{\"1\":{\"397\":1}}],[\"内置函数\",{\"1\":{\"334\":1}}],[\"内连接\",{\"0\":{\"320\":1}}],[\"内存非常宝贵\",{\"1\":{\"1205\":1}}],[\"内存压力大\",{\"1\":{\"1166\":1}}],[\"内存限制问题\",{\"1\":{\"1157\":1}}],[\"内存值\",{\"1\":{\"1135\":2}}],[\"内存淘汰\",{\"1\":{\"1119\":1}}],[\"内存的读写速度会非常快\",{\"1\":{\"1189\":1}}],[\"内存的读写性能远高于磁盘\",{\"1\":{\"1114\":1}}],[\"内存的基础知识\",{\"0\":{\"179\":1}}],[\"内存到磁盘\",{\"1\":{\"980\":1}}],[\"内存到内存\",{\"1\":{\"980\":1}}],[\"内存元数据\",{\"1\":{\"905\":1}}],[\"内存回收分成两步\",{\"1\":{\"855\":1}}],[\"内存回收的时间b\",{\"1\":{\"637\":1}}],[\"内存被回收\",{\"1\":{\"775\":1}}],[\"内存被分为系统区和用户区\",{\"1\":{\"182\":1}}],[\"内存管理器会将物理内存页保存到磁盘文件\",{\"1\":{\"685\":1}}],[\"内存管理主要是做什么\",{\"0\":{\"682\":1}}],[\"内存管理的概念\",{\"0\":{\"180\":1}}],[\"内存拷贝\",{\"1\":{\"680\":1}}],[\"内存占用较大\",{\"1\":{\"1222\":1}}],[\"内存占用较少\",{\"1\":{\"1123\":1}}],[\"内存占用低的令人发指\",{\"1\":{\"1179\":1}}],[\"内存占用高\",{\"1\":{\"864\":1}}],[\"内存占用多些越来越能容忍\",{\"1\":{\"637\":1}}],[\"内存占用这三者共同构成一个\",{\"1\":{\"637\":1}}],[\"内存占用\",{\"1\":{\"637\":1}}],[\"内存泄漏\",{\"1\":{\"636\":1}}],[\"内存溢出\",{\"1\":{\"636\":1}}],[\"内存溢出和内存泄漏的原因\",{\"0\":{\"636\":1}}],[\"内存分配完成后虚拟机需要将分配到内存的空间都初始化零值\",{\"1\":{\"630\":1}}],[\"内存分配的并发问题\",{\"1\":{\"630\":1}}],[\"内存分配规则\",{\"1\":{\"187\":1}}],[\"内存不足时就可能出现oom\",{\"1\":{\"626\":1}}],[\"内存大小限制是10m\",{\"1\":{\"476\":1}}],[\"内存\",{\"1\":{\"209\":6,\"687\":1,\"775\":1,\"776\":1,\"841\":1,\"855\":1}}],[\"内存映像i\",{\"1\":{\"208\":1}}],[\"内存与磁盘之间的数据交换\",{\"1\":{\"197\":1}}],[\"内存拆分为一个个大小相等的分区\",{\"1\":{\"184\":1}}],[\"内存利用率低\",{\"1\":{\"182\":1}}],[\"内存空间利用率高\",{\"1\":{\"188\":1}}],[\"内存空间非连续分配管理方式\",{\"1\":{\"184\":1}}],[\"内存空间的分配\",{\"0\":{\"182\":1}}],[\"内存空间的扩充\",{\"0\":{\"181\":1}}],[\"内存空间紧张的时候\",{\"1\":{\"181\":1}}],[\"内存中这片区域叫做环形缓冲区\",{\"1\":{\"979\":1}}],[\"内存中\",{\"1\":{\"855\":1}}],[\"内存中来直接访问使用\",{\"1\":{\"855\":1}}],[\"内存中的某些空闲分区由于太小难以利用\",{\"1\":{\"182\":1}}],[\"内存中只能有一道用户程序\",{\"1\":{\"182\":1}}],[\"内存中分为一个固定区和若干个覆盖区\",{\"1\":{\"181\":1}}],[\"内存中有多个进程实体\",{\"1\":{\"159\":1}}],[\"内存地址从0开始\",{\"1\":{\"179\":1}}],[\"内存地址空间是分配给进程的\",{\"1\":{\"163\":1}}],[\"内存是用于存放数据的硬件\",{\"1\":{\"179\":1}}],[\"内存缓冲区等\",{\"1\":{\"168\":1}}],[\"内存条只能是金士顿的\",{\"1\":{\"74\":1}}],[\"内存条可以选择金士顿\",{\"1\":{\"74\":1}}],[\"内存条\",{\"1\":{\"74\":1}}],[\"内部根据成员变量\",{\"1\":{\"1267\":1}}],[\"内部包含了所有的单例\",{\"1\":{\"1243\":1}}],[\"内部包含了所有发生的事件\",{\"1\":{\"840\":1}}],[\"内部变量就减少1\",{\"1\":{\"1132\":1}}],[\"内部维护的\",{\"1\":{\"1132\":1}}],[\"内部工作流程是这样的\",{\"1\":{\"854\":1}}],[\"内部创建了两个\",{\"1\":{\"746\":1}}],[\"内部使用的是cas\",{\"1\":{\"560\":1}}],[\"内部采用的就是这个原理\",{\"1\":{\"547\":1}}],[\"内部实现也差不多是数组+链表\",{\"1\":{\"515\":1}}],[\"内部表和外部表的主要区别是外部表再删除时会删除hdfs上的源数据\",{\"1\":{\"258\":1}}],[\"内部表\",{\"0\":{\"258\":1},\"1\":{\"258\":1}}],[\"内部具体划分如下\",{\"1\":{\"226\":1}}],[\"内部碎片\",{\"1\":{\"182\":1}}],[\"内部有一些系统调用的封装\",{\"1\":{\"158\":1}}],[\"内部制定版本号即可\",{\"1\":{\"99\":1}}],[\"内核缓冲区的数据写入网卡\",{\"1\":{\"855\":1}}],[\"内核会根据传入的\",{\"1\":{\"726\":1}}],[\"内核会采用类似callback的回调机制\",{\"1\":{\"680\":1}}],[\"内核需要将消息传递到用户空间\",{\"1\":{\"680\":1}}],[\"内核才对所有监视的文件描述符进行扫描\",{\"1\":{\"680\":1}}],[\"内核就会采用类似callback的回调机制来激活该fd\",{\"1\":{\"680\":1}}],[\"内核向进程返回一个文件描述符\",{\"1\":{\"677\":1}}],[\"内核代码对用户不信任\",{\"1\":{\"676\":1}}],[\"内核级线程\",{\"1\":{\"163\":1}}],[\"内核是计算机上配置的底层软件\",{\"1\":{\"156\":1}}],[\"内核程序\",{\"1\":{\"156\":1}}],[\"内裤外穿的超人\",{\"1\":{\"19\":1}}],[\"组装动态表名\",{\"1\":{\"1232\":1}}],[\"组装电脑\",{\"1\":{\"74\":1}}],[\"组和其他条目以与权限位兼容\",{\"1\":{\"926\":1}}],[\"组标识号\",{\"1\":{\"924\":1}}],[\"组名\",{\"1\":{\"701\":6,\"924\":1}}],[\"组织数据和对数据进行操作\",{\"1\":{\"233\":1}}],[\"组件已经被废弃掉\",{\"1\":{\"1499\":1}}],[\"组件扫描等方式都是生成\",{\"1\":{\"1248\":1}}],[\"组件名\",{\"1\":{\"944\":1}}],[\"组件\",{\"0\":{\"230\":1,\"232\":1,\"745\":1},\"1\":{\"1476\":1,\"1499\":1}}],[\"组\",{\"1\":{\"201\":2}}],[\"组成的双向链表\",{\"1\":{\"766\":1}}],[\"组成\",{\"0\":{\"771\":1},\"1\":{\"184\":1,\"188\":1,\"875\":1,\"1026\":2}}],[\"组合模式在\",{\"1\":{\"1362\":1,\"1394\":1}}],[\"组合并扩展了\",{\"1\":{\"1243\":1}}],[\"组合查询\",{\"0\":{\"1080\":1},\"1\":{\"1080\":1}}],[\"组合这些\",{\"1\":{\"779\":1}}],[\"组合索引\",{\"1\":{\"493\":1}}],[\"组合\",{\"1\":{\"73\":1,\"780\":1,\"1243\":2}}],[\"两类服务\",{\"1\":{\"951\":1}}],[\"两类\",{\"1\":{\"787\":1}}],[\"两部分组成的数据结构\",{\"1\":{\"658\":1}}],[\"两者都是用于自定义排序的接口\",{\"1\":{\"603\":1}}],[\"两者都应该依赖其抽象\",{\"1\":{\"74\":1}}],[\"两阶段终止模式\",{\"0\":{\"536\":1}}],[\"两级目录结构\",{\"1\":{\"196\":1}}],[\"两级页表访问内存的次数\",{\"1\":{\"186\":1}}],[\"两级页表的原理\",{\"1\":{\"186\":1}}],[\"两级页表\",{\"0\":{\"186\":1}}],[\"两个操作不具备原子性\",{\"1\":{\"1141\":1}}],[\"两个域树yunying\",{\"1\":{\"923\":1}}],[\"两个\",{\"0\":{\"820\":1}}],[\"两个类型的成员变量\",{\"1\":{\"663\":1}}],[\"两个收集器间有连线\",{\"1\":{\"638\":1}}],[\"两个线程一个i++一个i\",{\"1\":{\"558\":1}}],[\"两个事务同时写\",{\"1\":{\"506\":1}}],[\"两个参数m\",{\"1\":{\"309\":1}}],[\"两个相邻的空闲分区合并为一个\",{\"1\":{\"182\":1}}],[\"两个原语进行数据交换\",{\"1\":{\"162\":1}}],[\"两个进程对共享空间的访问必须是互斥的\",{\"1\":{\"162\":1}}],[\"两个citation\",{\"1\":{\"54\":1}}],[\"两种解决方法\",{\"1\":{\"1506\":1}}],[\"两种方法获取参数名\",{\"0\":{\"1364\":1}}],[\"两种必须要使用$\",{\"1\":{\"1230\":1}}],[\"两种\",{\"1\":{\"766\":1}}],[\"两种io多路复用方案\",{\"1\":{\"611\":1}}],[\"两种情况下生成readview的机制不一样\",{\"1\":{\"503\":1}}],[\"两种程序\",{\"1\":{\"156\":1}}],[\"两种处理器状态\",{\"1\":{\"156\":1}}],[\"两种指令\",{\"1\":{\"156\":2}}],[\"高层接口与实现\",{\"0\":{\"1370\":1}}],[\"高层模块不应该依赖低层模块\",{\"1\":{\"74\":1}}],[\"高性能\",{\"1\":{\"1140\":2}}],[\"高性能的网络服务器和客户端\",{\"1\":{\"789\":1}}],[\"高性能的代码生成包\",{\"1\":{\"60\":1}}],[\"高亮查询\",{\"0\":{\"1083\":1},\"1\":{\"1083\":1}}],[\"高亮的部分即窗口\",{\"1\":{\"694\":1}}],[\"高级\",{\"0\":{\"1238\":1}}],[\"高级查询\",{\"0\":{\"1074\":1}}],[\"高级调度时间\",{\"1\":{\"166\":1}}],[\"高级调度主要指的是调入问题\",{\"1\":{\"164\":1}}],[\"高级调度是外存和内存之间的调度\",{\"1\":{\"164\":1}}],[\"高级调度\",{\"1\":{\"164\":1}}],[\"高吞吐的\",{\"1\":{\"1009\":1}}],[\"高可用\",{\"1\":{\"1140\":2}}],[\"高可用和分片的特性\",{\"1\":{\"527\":1}}],[\"高可靠\",{\"1\":{\"1009\":1}}],[\"高位都为0\",{\"1\":{\"999\":2}}],[\"高阶编程\",{\"0\":{\"981\":1}}],[\"高并发分布式环境下生成不重复\",{\"1\":{\"1000\":1}}],[\"高并发时\",{\"1\":{\"770\":1}}],[\"高并发集群\",{\"1\":{\"482\":1}}],[\"高峰期过去再释放许可\",{\"1\":{\"591\":1}}],[\"高16位存储共享锁的状态\",{\"1\":{\"582\":1}}],[\"高3位的值\",{\"1\":{\"571\":1}}],[\"高的适合作为索引\",{\"1\":{\"493\":1}}],[\"高达90\",{\"1\":{\"493\":1}}],[\"高速缓冲技术\",{\"1\":{\"189\":1}}],[\"高响应比优先\",{\"1\":{\"167\":1}}],[\"高效的数据存储结构\",{\"1\":{\"517\":1}}],[\"高效\",{\"1\":{\"154\":1,\"170\":1}}],[\"9200\",{\"1\":{\"1071\":1,\"1088\":1}}],[\"92803741\",{\"1\":{\"145\":1}}],[\"9<\",{\"1\":{\"1070\":1}}],[\"9越多\",{\"1\":{\"882\":1}}],[\"99\",{\"1\":{\"882\":2}}],[\"999\",{\"1\":{\"1180\":1}}],[\"999f\",{\"1\":{\"870\":1}}],[\"9999\",{\"1\":{\"81\":1,\"409\":1,\"848\":2}}],[\"9092\",{\"1\":{\"1012\":1,\"1015\":2,\"1016\":1,\"1017\":1,\"1018\":2,\"1021\":4,\"1023\":1,\"1024\":1,\"1050\":1}}],[\"9090\",{\"1\":{\"697\":20,\"698\":17,\"699\":20}}],[\"9000\",{\"1\":{\"839\":2}}],[\"91\",{\"1\":{\"822\":2}}],[\"918\",{\"1\":{\"762\":1,\"765\":2}}],[\"96\",{\"1\":{\"755\":1}}],[\"9b\",{\"1\":{\"699\":3}}],[\"9b68045565ab516f5f3e723c7b11f0c\",{\"1\":{\"188\":1}}],[\"97b\",{\"1\":{\"699\":1}}],[\"97\",{\"1\":{\"336\":1}}],[\"95004\",{\"1\":{\"318\":1}}],[\"95002\",{\"1\":{\"318\":7}}],[\"98\",{\"1\":{\"265\":1}}],[\"9\",{\"0\":{\"161\":1,\"183\":1,\"202\":1,\"310\":1,\"776\":1,\"1044\":1,\"1045\":1,\"1046\":1,\"1083\":1,\"1108\":1,\"1109\":1,\"1110\":1,\"1111\":1,\"1127\":1,\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1299\":1},\"1\":{\"73\":1,\"110\":1,\"112\":1,\"163\":1,\"191\":1,\"338\":1,\"344\":2,\"374\":2,\"620\":1,\"692\":2,\"693\":3,\"696\":1,\"697\":11,\"698\":11,\"699\":11,\"723\":1,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":6,\"779\":5,\"780\":3,\"796\":1,\"799\":3,\"805\":2,\"807\":3,\"808\":2,\"836\":2,\"848\":1,\"857\":1,\"875\":2,\"1070\":1,\"1083\":1,\"1172\":1,\"1317\":1}}],[\"来确定扫描的包\",{\"1\":{\"1455\":1}}],[\"来开启了自动代理\",{\"1\":{\"1453\":1}}],[\"来测试\",{\"1\":{\"1442\":1}}],[\"来将结果转换为\",{\"1\":{\"1438\":1}}],[\"来编译\",{\"1\":{\"1300\":1}}],[\"来补充一些\",{\"1\":{\"1248\":1}}],[\"来拼接sql\",{\"1\":{\"1230\":1}}],[\"来对参数进行引用\",{\"1\":{\"1229\":1}}],[\"来对数据进行筛选\",{\"1\":{\"1171\":1}}],[\"来指定密码\",{\"1\":{\"1196\":1}}],[\"来指定为哪些字段建立bloomfilter索引\",{\"1\":{\"437\":1}}],[\"来减少\",{\"1\":{\"1177\":1}}],[\"来完成\",{\"1\":{\"1174\":1}}],[\"来判断是否下单成功\",{\"1\":{\"1155\":1}}],[\"来判断是否为null值\",{\"1\":{\"482\":1}}],[\"来操作\",{\"1\":{\"1155\":1}}],[\"来操作事务\",{\"1\":{\"1137\":1}}],[\"来查询我们\",{\"1\":{\"1155\":1}}],[\"来抢锁\",{\"1\":{\"1147\":1}}],[\"来\",{\"1\":{\"1147\":1}}],[\"来表示是否有线程成功插入key\",{\"1\":{\"1127\":1}}],[\"来解决缓存穿透的方案\",{\"0\":{\"1177\":1}}],[\"来解决双写问题\",{\"1\":{\"1122\":1}}],[\"来解决问题\",{\"1\":{\"73\":1}}],[\"来拉取数据\",{\"1\":{\"1026\":1}}],[\"来作为主键\",{\"1\":{\"997\":1}}],[\"来进行适配\",{\"1\":{\"1369\":1}}],[\"来进行指定\",{\"1\":{\"1168\":1}}],[\"来进行增量备份\",{\"1\":{\"912\":1}}],[\"来进行排序\",{\"1\":{\"603\":1}}],[\"来实现了大量数据的表示\",{\"1\":{\"1174\":1}}],[\"来实现一些管理\",{\"1\":{\"1045\":1}}],[\"来实现文件读\",{\"1\":{\"854\":1}}],[\"来实现各个分区的分配和回收\",{\"1\":{\"182\":1}}],[\"来跟踪\",{\"1\":{\"843\":1}}],[\"来理解非阻塞模式\",{\"1\":{\"827\":1}}],[\"来理解阻塞模式\",{\"1\":{\"826\":1}}],[\"来控制\",{\"1\":{\"822\":1}}],[\"来读取文件内容\",{\"1\":{\"796\":1}}],[\"来获取\",{\"1\":{\"813\":1}}],[\"来获取结果\",{\"1\":{\"757\":1}}],[\"来获取代理对象\",{\"1\":{\"59\":1}}],[\"来处理\",{\"1\":{\"746\":1,\"867\":1}}],[\"来封装线程和\",{\"1\":{\"740\":1}}],[\"来接收结果\",{\"1\":{\"737\":1}}],[\"来设置大小\",{\"1\":{\"726\":1}}],[\"来注册一个文件扫描符\",{\"1\":{\"680\":1}}],[\"来找到就绪的描述符\",{\"1\":{\"680\":1}}],[\"来决定该\",{\"1\":{\"1454\":1}}],[\"来决定要不要停止操作\",{\"1\":{\"662\":1}}],[\"来决定主查询的数据结果是否得以保留\",{\"1\":{\"332\":1}}],[\"来使用\",{\"1\":{\"590\":1}}],[\"来引用外部的局部变量\",{\"1\":{\"562\":1}}],[\"来保证自己的健壮性\",{\"1\":{\"526\":1}}],[\"来避免索引失效\",{\"1\":{\"505\":1}}],[\"来说\",{\"1\":{\"497\":1,\"1026\":1}}],[\"来统计数据行数\",{\"1\":{\"497\":1}}],[\"来替代count\",{\"1\":{\"482\":1}}],[\"来综合判断用哪种处理的方案是最佳方案\",{\"1\":{\"457\":1}}],[\"来加载文本数据\",{\"1\":{\"371\":1}}],[\"来修改默认构建的行为和产物\",{\"1\":{\"102\":1}}],[\"来修改maven的一些默认配置\",{\"1\":{\"92\":1}}],[\"法\",{\"1\":{\"73\":1}}],[\"继续在\",{\"1\":{\"1155\":1}}],[\"继续运行\",{\"1\":{\"827\":1}}],[\"继续执行\",{\"1\":{\"593\":1,\"1143\":1}}],[\"继续遍历其他小文件\",{\"1\":{\"477\":1}}],[\"继续编号\",{\"1\":{\"403\":1}}],[\"继续检查下一个页面\",{\"1\":{\"191\":1}}],[\"继承了messagesource\",{\"1\":{\"1501\":1}}],[\"继承reducer\",{\"1\":{\"970\":1}}],[\"继承自\",{\"1\":{\"746\":1,\"756\":1}}],[\"继承udf\",{\"1\":{\"344\":1}}],[\"继承父工程版本\",{\"1\":{\"113\":4}}],[\"继承语法\",{\"1\":{\"107\":1}}],[\"继承作用\",{\"1\":{\"107\":1}}],[\"继承可以让我们在多个项目中共享同一配置信息\",{\"1\":{\"107\":1}}],[\"继承是指在\",{\"1\":{\"107\":1}}],[\"继承概念\",{\"1\":{\"107\":1}}],[\"继承复用破坏了类的封装性\",{\"1\":{\"77\":1}}],[\"继承复用虽然有简单和易实现的优点\",{\"1\":{\"77\":1}}],[\"继承实际上让两个类耦合性增强了\",{\"1\":{\"73\":1}}],[\"继承在\",{\"1\":{\"73\":1}}],[\"继承包含这样一层含义\",{\"1\":{\"73\":1}}],[\"继而就会调用我们定义的readresolve方法\",{\"1\":{\"69\":1}}],[\"适宜插入和查询的特点\",{\"1\":{\"606\":1}}],[\"适量中等分区\",{\"1\":{\"182\":1}}],[\"适用于任务量已知\",{\"1\":{\"574\":1}}],[\"适用于线程数少\",{\"1\":{\"561\":1}}],[\"适用于测试体验\",{\"1\":{\"242\":1}}],[\"适用于连续分配方式\",{\"1\":{\"198\":1}}],[\"适用于多处理机环境\",{\"1\":{\"170\":2}}],[\"适用于分时操作系统\",{\"1\":{\"167\":2}}],[\"适用场景\",{\"0\":{\"87\":1}}],[\"适合连接数特别多\",{\"1\":{\"867\":1}}],[\"适合配合池化功能一起用\",{\"1\":{\"769\":1}}],[\"适合任务数比较密集\",{\"1\":{\"574\":1}}],[\"适合于大表join大表\",{\"1\":{\"449\":1,\"450\":1}}],[\"适合于小表join大表或者小表join小表\",{\"1\":{\"448\":1}}],[\"适合分时操作系统\",{\"1\":{\"165\":1}}],[\"适合早期批处理系统\",{\"1\":{\"165\":1}}],[\"适应性广\",{\"1\":{\"72\":1}}],[\"适配为\",{\"1\":{\"1343\":2}}],[\"适配器提供跟原始类不同的接口\",{\"1\":{\"10\":1}}],[\"适配器\",{\"0\":{\"10\":1},\"1\":{\"5\":1}}],[\"适配器模式适配器模式是一种事后的补救策略\",{\"1\":{\"10\":1}}],[\"适配器模式分为类适配器模式和对象适配器模式\",{\"1\":{\"4\":1}}],[\"适配器模式\",{\"0\":{\"3\":1},\"1\":{\"5\":1}}],[\"适配者\",{\"1\":{\"5\":1}}],[\"简略版本\",{\"1\":{\"1530\":1}}],[\"简而言之\",{\"1\":{\"1520\":1}}],[\"简写kms\",{\"1\":{\"933\":1}}],[\"简要来说包含mark\",{\"1\":{\"540\":1}}],[\"简称ec\",{\"1\":{\"875\":1}}],[\"简称\",{\"1\":{\"740\":1,\"1340\":1}}],[\"简称数仓\",{\"1\":{\"219\":1}}],[\"简称ts或tsl指令\",{\"1\":{\"170\":1}}],[\"简笔画转真图\",{\"1\":{\"130\":1}}],[\"简笔画的猫转成真猫\",{\"1\":{\"124\":1}}],[\"简化开发\",{\"1\":{\"1164\":1}}],[\"简化了程序编写\",{\"1\":{\"611\":1}}],[\"简化了部署和维护工作\",{\"1\":{\"108\":1}}],[\"简化了开发过程中的工作\",{\"1\":{\"97\":1}}],[\"简化项目的管理和维护工作\",{\"1\":{\"107\":1}}],[\"简化依赖导入过程\",{\"1\":{\"104\":1}}],[\"简单说明一下\",{\"1\":{\"1454\":1}}],[\"简单比较的话\",{\"1\":{\"1298\":1}}],[\"简单地拉取数据\",{\"1\":{\"980\":1}}],[\"简单描述为\",{\"1\":{\"917\":1}}],[\"简单分为连续分配管理方式和非连续分配管理方式\",{\"1\":{\"683\":1}}],[\"简单来说段页式管理机制就是先把用户程序分成若干个段\",{\"1\":{\"683\":1}}],[\"简单来说\",{\"1\":{\"637\":1}}],[\"简单点说就是在不影响最终结果的情况下\",{\"1\":{\"459\":1}}],[\"简单的形式对第三方软件进行集成\",{\"1\":{\"1524\":1}}],[\"简单的按照内容发布时间排序\",{\"1\":{\"1166\":1}}],[\"简单的解决方案就是哪怕这个数据在数据库中也不存在\",{\"1\":{\"1123\":1}}],[\"简单的说就是调用方在调用接口的时候先向后端请求一个全局id\",{\"1\":{\"1005\":1}}],[\"简单的说就是要求对抽象进行编程\",{\"1\":{\"74\":1}}],[\"简单的时钟置换算法仅仅考虑到一个页面最近是否被访问过\",{\"1\":{\"191\":1}}],[\"简单的clock算法实现方法\",{\"1\":{\"191\":1}}],[\"简单\",{\"1\":{\"170\":1}}],[\"简单工厂+配置文件解除耦合\",{\"1\":{\"42\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"27\":1}}],[\"简单工厂不是一种设计模式\",{\"1\":{\"26\":1}}],[\"简单工厂模式\",{\"0\":{\"26\":1},\"1\":{\"25\":1}}],[\"简言之\",{\"1\":{\"72\":1}}],[\"重置有效期然后返回\",{\"1\":{\"1151\":1}}],[\"重置到标记位置\",{\"1\":{\"774\":1}}],[\"重入次数\",{\"1\":{\"1151\":1}}],[\"重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中\",{\"1\":{\"1149\":1}}],[\"重入问题\",{\"1\":{\"1149\":1}}],[\"重启\",{\"1\":{\"1197\":1}}],[\"重启集群\",{\"1\":{\"910\":1}}],[\"重启时可以读取redo\",{\"1\":{\"506\":1}}],[\"重命名\",{\"1\":{\"870\":1}}],[\"重命名分区\",{\"1\":{\"280\":1}}],[\"重写对象的排序规则\",{\"1\":{\"974\":1}}],[\"重写reduce方法\",{\"1\":{\"970\":1}}],[\"重写了相应事件处理方法\",{\"1\":{\"787\":1}}],[\"重写query查询物化视图\",{\"1\":{\"276\":1}}],[\"重建缓存\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"重建\",{\"1\":{\"742\":1}}],[\"重新创建该对象\",{\"1\":{\"956\":1}}],[\"重新创建一张分区表t\",{\"1\":{\"260\":1}}],[\"重新置为\",{\"1\":{\"803\":1}}],[\"重新运行起来\",{\"1\":{\"679\":1}}],[\"重要属性和内部类\",{\"1\":{\"579\":1}}],[\"重要程度\",{\"1\":{\"167\":1}}],[\"重试失败\",{\"1\":{\"564\":1}}],[\"重试即可\",{\"1\":{\"561\":1}}],[\"重载意味着可以在一个java类中实现多个函数功能\",{\"1\":{\"344\":1}}],[\"重复\",{\"1\":{\"643\":1,\"797\":1}}],[\"重复并列的不考虑\",{\"1\":{\"363\":1}}],[\"重复str字符串n次\",{\"1\":{\"336\":1}}],[\"重复字符串函数\",{\"1\":{\"336\":2}}],[\"重复引入该依赖\",{\"1\":{\"100\":1}}],[\"重定位寄存器\",{\"1\":{\"180\":1}}],[\"重点控制offset\",{\"1\":{\"1054\":1}}],[\"重点讲下cms和g1\",{\"1\":{\"633\":1}}],[\"重点讲一下cms和g1\",{\"1\":{\"633\":1}}],[\"重点就是能写好正则表达式\",{\"1\":{\"374\":1}}],[\"重点\",{\"0\":{\"101\":1}}],[\"重点查看readordinaryobject方法\",{\"1\":{\"69\":1}}],[\"重点查看readobject0方法\",{\"1\":{\"69\":1}}],[\"重构完成后释放互斥锁\",{\"1\":{\"1128\":1}}],[\"重构后的代码在使用起来更方便\",{\"1\":{\"17\":1}}],[\"重构后代码\",{\"1\":{\"17\":1}}],[\"重构前代码如下\",{\"1\":{\"17\":1}}],[\"问题3\",{\"1\":{\"1176\":1}}],[\"问题2\",{\"1\":{\"1176\":1}}],[\"问题1\",{\"1\":{\"1176\":1}}],[\"问题分析\",{\"1\":{\"1161\":1}}],[\"问题的原因在于当前方法被spring的事务控制\",{\"1\":{\"1137\":1}}],[\"问题的解决\",{\"0\":{\"69\":1}}],[\"问题来自于上一行\",{\"1\":{\"648\":1}}],[\"问题就出在一个线程读取主存的值后运算完还未刷回主存就被其他线程从主存中读取到了\",{\"1\":{\"560\":1}}],[\"问题和需求\",{\"0\":{\"372\":1}}],[\"问题\",{\"0\":{\"854\":1},\"1\":{\"159\":1,\"161\":1,\"171\":1,\"666\":1,\"707\":1}}],[\"问题提出\",{\"1\":{\"73\":1}}],[\"问题演示\",{\"0\":{\"68\":1}}],[\"表面上只有\",{\"1\":{\"1243\":1}}],[\"表面上epoll的性能更好\",{\"1\":{\"680\":1}}],[\"表等形式簇聚存储的\",{\"1\":{\"687\":1}}],[\"表明该association不开启延迟加载\",{\"1\":{\"1230\":1}}],[\"表明它们可以搭配使用\",{\"1\":{\"638\":1}}],[\"表明序列化和反序列化已经破坏了单例设计模式\",{\"1\":{\"68\":2}}],[\"表锁\",{\"0\":{\"510\":1}}],[\"表锁在操作数据时会锁定整张表\",{\"1\":{\"506\":1}}],[\"表中都为\",{\"1\":{\"493\":1}}],[\"表和\",{\"1\":{\"493\":1}}],[\"表1\",{\"1\":{\"481\":2}}],[\"表必备三字段\",{\"1\":{\"480\":1}}],[\"表必须是\",{\"1\":{\"267\":1}}],[\"表名不能有单引号\",{\"1\":{\"1230\":1}}],[\"表名不使用复数名词\",{\"1\":{\"480\":1}}],[\"表名该单词不存在\",{\"1\":{\"668\":2}}],[\"表名应该仅仅表示表里面的实体内容\",{\"1\":{\"480\":1}}],[\"表名\",{\"1\":{\"480\":2}}],[\"表达式去原子执行判断逻辑\",{\"1\":{\"1157\":1}}],[\"表达式执行完毕后\",{\"1\":{\"1156\":1}}],[\"表达式\",{\"1\":{\"1151\":1,\"1156\":1}}],[\"表达式防止删锁的时候\",{\"1\":{\"1149\":1}}],[\"表达逻辑删除的字段名is\",{\"1\":{\"480\":1}}],[\"表达是否概念的字段\",{\"1\":{\"480\":1}}],[\"表生成函数\",{\"1\":{\"334\":1}}],[\"表文件存储格式仅支持orc\",{\"1\":{\"296\":1}}],[\"表属性参数transactional必须设置为true\",{\"1\":{\"296\":1}}],[\"表属性\",{\"1\":{\"268\":1}}],[\"表参数transactional必须为true\",{\"1\":{\"267\":1}}],[\"表数据\",{\"1\":{\"258\":1,\"357\":1}}],[\"表创建语句中的row\",{\"1\":{\"251\":1}}],[\"表\",{\"0\":{\"235\":1,\"279\":1},\"1\":{\"275\":1}}],[\"表的作用\",{\"1\":{\"480\":1}}],[\"表的命名最好是加上\",{\"1\":{\"480\":1}}],[\"表的信息\",{\"1\":{\"458\":1}}],[\"表的位置\",{\"1\":{\"239\":1}}],[\"表的数据所在目录等\",{\"1\":{\"232\":1}}],[\"表的属性\",{\"1\":{\"232\":1}}],[\"表的列和分区及其属性\",{\"1\":{\"232\":1}}],[\"表项中包含分区\",{\"1\":{\"182\":1}}],[\"表示这是个控制器bean\",{\"1\":{\"1525\":1}}],[\"表示这期间确实没有写操作\",{\"1\":{\"590\":1}}],[\"表示为\",{\"1\":{\"1267\":1}}],[\"表示接受url地址栏传参的注解\",{\"1\":{\"1168\":1}}],[\"表示表示这把锁是否存在\",{\"1\":{\"1151\":1}}],[\"表示表示字符数组长度和分配空间大小不能超过\",{\"1\":{\"663\":1}}],[\"表示当前这把锁被哪个线程持有\",{\"1\":{\"1151\":1}}],[\"表示当前这把锁没有被人持有\",{\"1\":{\"1151\":1}}],[\"表示当生产者生产数据到\",{\"1\":{\"1023\":1}}],[\"表示是否写入成功\",{\"1\":{\"1043\":1}}],[\"表示获取指定topic的分区数量\",{\"1\":{\"1035\":1}}],[\"表示出现异常\",{\"1\":{\"1025\":1}}],[\"表示发送成功\",{\"1\":{\"1025\":1}}],[\"表示发来的数据已确认接收无误\",{\"1\":{\"899\":1}}],[\"表示从哪条消息开始拉取数据\",{\"1\":{\"1024\":1}}],[\"表示从前面的起点\",{\"1\":{\"361\":1}}],[\"表示它们就在一个组中\",{\"1\":{\"1024\":1}}],[\"表示等带服务端的响应\",{\"1\":{\"1023\":1}}],[\"表示改行数据对应的对象类型\",{\"1\":{\"985\":1}}],[\"表示数据的记录行号\",{\"1\":{\"985\":1}}],[\"表示该系统在连续运行1年时间里最多可能的业务中断时间是52\",{\"1\":{\"882\":1}}],[\"表示该由当前线程唤醒\",{\"1\":{\"741\":1}}],[\"表示实际写了多少字节\",{\"1\":{\"843\":1}}],[\"表示到达了文件的末尾\",{\"1\":{\"814\":1}}],[\"表示到后面的终点\",{\"1\":{\"361\":1}}],[\"表示基于\",{\"1\":{\"784\":1,\"785\":1}}],[\"表示基于分桶字段抽样\",{\"1\":{\"369\":1}}],[\"表示增加新的\",{\"1\":{\"779\":1}}],[\"表示调用者没用完之前\",{\"1\":{\"775\":1}}],[\"表示由其它线程来调用\",{\"1\":{\"741\":1}}],[\"表示subscriber消费publisher发布的一个消息的生命周期\",{\"1\":{\"716\":1}}],[\"表示需要连接关闭\",{\"1\":{\"694\":1}}],[\"表示一个处理阶段\",{\"1\":{\"716\":1}}],[\"表示一个完整报文\",{\"1\":{\"694\":1}}],[\"表示一个页面近期被访问过\",{\"1\":{\"191\":1}}],[\"表示字符数组长度和分配空间大小不能超过\",{\"1\":{\"663\":1}}],[\"表示的是\",{\"1\":{\"663\":1}}],[\"表示选择第i个物品\",{\"1\":{\"648\":1}}],[\"表示不选第i个物品\",{\"1\":{\"648\":1}}],[\"表示缓冲区的当前终点\",{\"1\":{\"610\":1}}],[\"表示空的hash表\",{\"1\":{\"606\":1}}],[\"表示某段代码最多可以有n个线程同时访问\",{\"1\":{\"591\":1}}],[\"表示加锁\",{\"1\":{\"564\":1}}],[\"表示线程执行已经完毕\",{\"1\":{\"538\":1}}],[\"表示相等时带上此条件\",{\"1\":{\"483\":1}}],[\"表示随机抽\",{\"1\":{\"369\":1}}],[\"表示总共抽取\",{\"1\":{\"369\":1}}],[\"表示没找到\",{\"1\":{\"336\":1}}],[\"表示任意数量字符\",{\"1\":{\"330\":1}}],[\"表示任意单个字符\",{\"1\":{\"330\":1}}],[\"表示删除\",{\"1\":{\"293\":1}}],[\"表示更新\",{\"1\":{\"293\":1}}],[\"表示插入\",{\"1\":{\"293\":1}}],[\"表示元数据检查操作\",{\"1\":{\"281\":1}}],[\"表示根据那个字段进行升序\",{\"1\":{\"264\":1}}],[\"表示根据哪个字段进行分\",{\"1\":{\"264\":1}}],[\"表示tmp\",{\"1\":{\"261\":1}}],[\"表示使用的时候\",{\"1\":{\"247\":1}}],[\"表示页面被修改过\",{\"1\":{\"191\":1}}],[\"表示页面没有被修改过\",{\"1\":{\"191\":1}}],[\"表示0号进程p0现在想要进入临界区\",{\"1\":{\"169\":1}}],[\"表示进行猜拳游戏的选手类\",{\"1\":{\"81\":1}}],[\"表示\",{\"1\":{\"81\":2,\"662\":1,\"947\":1}}],[\"表示猜拳中出的手势值\",{\"1\":{\"81\":1}}],[\"表示猜拳中的\",{\"1\":{\"81\":1}}],[\"表示猜拳游戏中的策略的类\",{\"1\":{\"81\":1}}],[\"表示以简单图示形式显示熟知的类\",{\"1\":{\"47\":1}}],[\"表示以数字形式显示数值的类\",{\"1\":{\"47\":1}}],[\"表示生成数值的对象的抽象类\",{\"1\":{\"47\":1}}],[\"表示观察者的接口\",{\"1\":{\"47\":1}}],[\"分批完成写入redis\",{\"1\":{\"1171\":1}}],[\"分批次读取\",{\"1\":{\"902\":1}}],[\"分成如下几个步骤\",{\"1\":{\"1155\":1}}],[\"分片集群\",{\"1\":{\"1190\":1}}],[\"分片和复制的数量可以在索引创建的时候指定\",{\"1\":{\"1067\":1}}],[\"分片置于同一节点上是非常重要的\",{\"1\":{\"1067\":1}}],[\"分片很重要\",{\"1\":{\"1066\":1}}],[\"分片\",{\"0\":{\"1066\":1}}],[\"分两组选择器\",{\"1\":{\"846\":1}}],[\"分散读取\",{\"1\":{\"807\":1}}],[\"分钟级或小时级\",{\"1\":{\"951\":1}}],[\"分钟才能执行工作\",{\"1\":{\"755\":1}}],[\"分钟\",{\"1\":{\"755\":2}}],[\"分隔的数据\",{\"1\":{\"809\":1}}],[\"分隔符\",{\"1\":{\"698\":1}}],[\"分隔字符串函数\",{\"1\":{\"336\":1}}],[\"分\",{\"1\":{\"696\":1,\"787\":1}}],[\"分治递归处理子问题\",{\"1\":{\"645\":1}}],[\"分代分类\",{\"1\":{\"638\":1}}],[\"分代回收说下\",{\"1\":{\"633\":1}}],[\"分布式锁的原子性问题\",{\"0\":{\"1145\":1}}],[\"分布式锁的核心思想就是让大家都使用同一把锁\",{\"1\":{\"1140\":1}}],[\"分布式锁\",{\"0\":{\"1139\":1,\"1148\":1,\"1149\":1,\"1150\":1,\"1151\":1,\"1152\":1,\"1153\":1},\"1\":{\"1140\":1}}],[\"分布式系统\",{\"1\":{\"1121\":1}}],[\"分布式环境下\",{\"1\":{\"949\":1}}],[\"分布式协调框架\",{\"1\":{\"791\":1}}],[\"分布式问题\",{\"1\":{\"501\":1}}],[\"分布\",{\"1\":{\"457\":1}}],[\"分割\",{\"1\":{\"348\":1}}],[\"分割字符串函数\",{\"1\":{\"336\":1}}],[\"分组查询\",{\"0\":{\"1085\":1},\"1\":{\"1085\":1}}],[\"分组后新的kv键值对\",{\"1\":{\"961\":1}}],[\"分组后每个分组结果集确定\",{\"1\":{\"307\":1}}],[\"分组\",{\"1\":{\"961\":1}}],[\"分组之后\",{\"1\":{\"961\":1}}],[\"分组等\",{\"1\":{\"465\":1}}],[\"分组topn\",{\"0\":{\"403\":1}}],[\"分组和排序使用的字段可以不同\",{\"1\":{\"313\":1}}],[\"分组规则hash散列\",{\"1\":{\"313\":1}}],[\"分组的个数取决于reducetask的个数\",{\"1\":{\"313\":1}}],[\"分组字段出现select\",{\"1\":{\"306\":1}}],[\"分别测试加入和去除\",{\"1\":{\"1466\":1}}],[\"分别获取其模型和视图名\",{\"1\":{\"1394\":1}}],[\"分别表示每一行起始位置的偏移量和这一行的文本内容\",{\"1\":{\"959\":1}}],[\"分别为\",{\"1\":{\"851\":1}}],[\"分别要等待\",{\"1\":{\"755\":1}}],[\"分别修改发送字符串为\",{\"1\":{\"748\":2}}],[\"分别用来\",{\"1\":{\"1352\":1}}],[\"分别用下面两个参数来控制\",{\"1\":{\"726\":1}}],[\"分别用于指定字段之间\",{\"1\":{\"252\":1}}],[\"分别说下\",{\"1\":{\"665\":1}}],[\"分别是textinputformat\",{\"1\":{\"984\":1}}],[\"分别是writefds\",{\"1\":{\"680\":1}}],[\"分别是\",{\"1\":{\"663\":2}}],[\"分别是普通索引\",{\"1\":{\"492\":1}}],[\"分别是序列化和反射\",{\"1\":{\"68\":1}}],[\"分别与缓存之间进行关联\",{\"1\":{\"448\":1}}],[\"分桶和索引常常是优于分区的\",{\"1\":{\"420\":1}}],[\"分桶字段\",{\"1\":{\"369\":1,\"450\":2}}],[\"分桶的字段必须是表中已经存在的字段\",{\"1\":{\"264\":1}}],[\"分桶的好处是可以优化join查询和方便抽样查询\",{\"1\":{\"237\":1}}],[\"分桶表的设计是按照一定的规则\",{\"1\":{\"417\":1}}],[\"分桶表设计思想\",{\"0\":{\"417\":1}}],[\"分桶表结构设计\",{\"0\":{\"416\":1}}],[\"分桶表规则一样\",{\"1\":{\"313\":1}}],[\"分桶表数据加载是通过对普通表select\",{\"1\":{\"266\":1}}],[\"分桶表数据加载\",{\"0\":{\"266\":1}}],[\"分桶表数据进行高效抽样\",{\"1\":{\"263\":1}}],[\"分桶表创建语句\",{\"1\":{\"265\":1}}],[\"分桶表\",{\"0\":{\"263\":1},\"1\":{\"237\":1,\"267\":1,\"268\":1}}],[\"分桶规则\",{\"1\":{\"237\":1}}],[\"分桶是指根据表中字段\",{\"1\":{\"237\":1}}],[\"分桶\",{\"0\":{\"237\":1}}],[\"分为平价券和特价券\",{\"1\":{\"1133\":1}}],[\"分为入站\",{\"1\":{\"766\":1}}],[\"分为若干个部分\",{\"1\":{\"364\":1}}],[\"分为一元运算符和二元运算符\",{\"1\":{\"331\":1}}],[\"分为几组取决于reducetask的个数\",{\"1\":{\"313\":1}}],[\"分为nonstick非严格模式和strict严格模式\",{\"1\":{\"261\":1}}],[\"分为\",{\"1\":{\"201\":1,\"632\":1}}],[\"分为隐式链接和显式链接两种\",{\"1\":{\"197\":1}}],[\"分为主文件目录\",{\"1\":{\"196\":1}}],[\"分为倒油\",{\"1\":{\"85\":1}}],[\"分页查询\",{\"0\":{\"1077\":1},\"1\":{\"1077\":1,\"1089\":1}}],[\"分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统\",{\"1\":{\"689\":1}}],[\"分页仅仅是为了满足操作系统内存管理的需求\",{\"1\":{\"683\":1}}],[\"分页机制和分段机制都是为了提高内存利用率\",{\"1\":{\"683\":1}}],[\"分页\",{\"1\":{\"188\":1,\"1172\":1}}],[\"分页管理\",{\"1\":{\"188\":1}}],[\"分页和分段的优缺点\",{\"1\":{\"188\":1}}],[\"分页与分段的区别\",{\"1\":{\"187\":1}}],[\"分段则是信息的逻辑单位\",{\"1\":{\"683\":1}}],[\"分段和分页的共同点与区别\",{\"1\":{\"683\":1}}],[\"分段对用户是可见的\",{\"1\":{\"188\":1}}],[\"分段管理\",{\"1\":{\"188\":1}}],[\"分段比分页相比更容易实现信息的共享和保护\",{\"1\":{\"187\":1}}],[\"分段系统的逻辑地址结构由\",{\"1\":{\"187\":1}}],[\"分段\",{\"1\":{\"187\":1,\"188\":1}}],[\"分区中是有leader和follower的概念\",{\"1\":{\"1043\":1}}],[\"分区分配尽可能均匀\",{\"1\":{\"1042\":1}}],[\"分区数量\",{\"1\":{\"1040\":2}}],[\"分区数据加载\",{\"1\":{\"284\":1}}],[\"分区计算之后\",{\"1\":{\"979\":1}}],[\"分区设计思想\",{\"0\":{\"415\":1}}],[\"分区查询\",{\"0\":{\"305\":1}}],[\"分区就是对分区进行继续分区\",{\"1\":{\"262\":1}}],[\"分区值没有手动写死\",{\"1\":{\"261\":1}}],[\"分区值\",{\"1\":{\"261\":1}}],[\"分区字段=\",{\"1\":{\"261\":1}}],[\"分区字段不能和表字段重复\",{\"1\":{\"260\":1,\"261\":1}}],[\"分区字段不能是表中已有的字段\",{\"1\":{\"259\":1}}],[\"分区字段值的确定来自于用户价值数据手动指定\",{\"1\":{\"259\":1}}],[\"分区字段是虚拟字段\",{\"1\":{\"259\":1}}],[\"分区的分配尽可能与上一次分配保持相同\",{\"1\":{\"1042\":1}}],[\"分区的数量\",{\"1\":{\"1034\":1}}],[\"分区的数量就是reducetask运行的数量\",{\"1\":{\"965\":1}}],[\"分区的目的是通过设置reducetask的数量将数据输出到不同的文件中\",{\"1\":{\"968\":1}}],[\"分区的字段值是基于查询结果\",{\"1\":{\"261\":1}}],[\"分区的字段可以是日期\",{\"1\":{\"259\":1}}],[\"分区的概念提供了一种将hive表数据分离为多个文件\",{\"1\":{\"259\":1}}],[\"分区表结构设计\",{\"0\":{\"413\":1}}],[\"分区表数据加载主要分为静态加载和动态加载两种\",{\"1\":{\"261\":1}}],[\"分区表数据加载\",{\"0\":{\"261\":1}}],[\"分区表不是建表的必要语法规则\",{\"1\":{\"259\":1}}],[\"分区表\",{\"0\":{\"259\":1}}],[\"分区列=分区值\",{\"1\":{\"236\":1}}],[\"分区在存储层面上的表现是\",{\"1\":{\"236\":1}}],[\"分区是指根据分区列\",{\"1\":{\"236\":1}}],[\"分区\",{\"0\":{\"236\":1,\"280\":1},\"1\":{\"1025\":1,\"1062\":1}}],[\"分区起始地址\",{\"1\":{\"182\":1}}],[\"分区信息\",{\"1\":{\"182\":1,\"458\":1}}],[\"分区说明表\",{\"1\":{\"182\":1}}],[\"分区大小不等\",{\"1\":{\"182\":1}}],[\"分区大小相等\",{\"1\":{\"182\":1}}],[\"分配和轮询分配都会重新进行分配\",{\"1\":{\"1042\":1}}],[\"分配订阅的\",{\"1\":{\"1037\":1}}],[\"分配策略类似\",{\"1\":{\"1042\":1}}],[\"分配策略\",{\"0\":{\"1034\":1}}],[\"分配合适的\",{\"1\":{\"840\":1}}],[\"分配的效率低\",{\"1\":{\"801\":1}}],[\"分配的这块内存很大一部分几乎被浪费了\",{\"1\":{\"683\":1}}],[\"分配空间\",{\"0\":{\"801\":1},\"1\":{\"801\":1}}],[\"分配额外的\",{\"1\":{\"663\":1}}],[\"分配修改所必须要的空间\",{\"1\":{\"663\":1}}],[\"分配了足够多的内存\",{\"1\":{\"662\":1}}],[\"分配内存的方式有碰撞指针和空闲列表\",{\"1\":{\"630\":1}}],[\"分配给字符数组的空间长度\",{\"1\":{\"663\":1}}],[\"分配给进程的物理块不够\",{\"1\":{\"192\":1}}],[\"分配给某进程的内存区域中\",{\"1\":{\"182\":2}}],[\"分配三个内存块时\",{\"1\":{\"191\":1}}],[\"分配\",{\"0\":{\"1068\":1},\"1\":{\"161\":1}}],[\"分配i\",{\"1\":{\"157\":1}}],[\"分析器\",{\"1\":{\"1065\":1}}],[\"分析优化器\",{\"1\":{\"458\":1}}],[\"分析函数\",{\"1\":{\"358\":1}}],[\"分析图表\",{\"1\":{\"227\":1}}],[\"分析结果为企业提供决策支持\",{\"1\":{\"219\":1}}],[\"分析\",{\"0\":{\"1294\":1},\"1\":{\"72\":1,\"104\":1,\"219\":1,\"399\":1}}],[\"分离了部件的构造\",{\"1\":{\"12\":1}}],[\"枚举的写法非常简单\",{\"1\":{\"66\":1}}],[\"枚举类实现单例模式是极力推荐的单例实现模式\",{\"1\":{\"66\":1}}],[\"枚举方式不会出现这两个问题\",{\"1\":{\"68\":1}}],[\"枚举方式除外\",{\"1\":{\"68\":1}}],[\"枚举方式属于饿汉式方式\",{\"1\":{\"66\":1}}],[\"枚举方式\",{\"1\":{\"66\":2}}],[\"保留\",{\"1\":{\"1042\":1}}],[\"保留用户\",{\"1\":{\"926\":1}}],[\"保留用户态现场\",{\"1\":{\"676\":1}}],[\"保持和\",{\"1\":{\"1026\":1}}],[\"保持任意时刻系统有且只有一个主角色提供服务\",{\"1\":{\"882\":1}}],[\"保密性强\",{\"1\":{\"201\":1}}],[\"保存探店笔记\",{\"1\":{\"1167\":1}}],[\"保存探店博文\",{\"1\":{\"1159\":1}}],[\"保存文件\",{\"1\":{\"1159\":1}}],[\"保存到阻塞队列\",{\"1\":{\"1156\":1}}],[\"保存到数据库\",{\"1\":{\"1098\":1}}],[\"保存用户到redis的set集合\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"保存用户\",{\"1\":{\"1156\":1}}],[\"保存用户信息到\",{\"1\":{\"1107\":1,\"1111\":1}}],[\"保存用户信息到threadlocal\",{\"1\":{\"1100\":1,\"1101\":1}}],[\"保存用户信息到session中\",{\"1\":{\"1099\":1,\"1101\":1}}],[\"保存代金券\",{\"1\":{\"1156\":1}}],[\"保存线程标示\",{\"1\":{\"1147\":1}}],[\"保存秒杀代金券\",{\"1\":{\"1156\":1}}],[\"保存秒杀库存到redis中\",{\"1\":{\"1133\":1}}],[\"保存秒杀信息\",{\"1\":{\"1133\":1}}],[\"保存优惠券\",{\"1\":{\"1133\":1}}],[\"保存验证码到\",{\"1\":{\"1099\":1}}],[\"保存订阅关系\",{\"1\":{\"717\":1,\"718\":1}}],[\"保存\",{\"1\":{\"666\":1}}],[\"保存其运行环境\",{\"1\":{\"161\":1}}],[\"保存在target目录下\",{\"1\":{\"95\":1}}],[\"保证消息有且仅被处理一次\",{\"1\":{\"1053\":1}}],[\"保证文件移动的原子性\",{\"1\":{\"822\":1}}],[\"保证了\",{\"1\":{\"746\":1}}],[\"保证了多线程下的安全\",{\"1\":{\"66\":1}}],[\"保证内核的安全\",{\"1\":{\"676\":1}}],[\"保证对象实例字段在不赋值时可以直接使用\",{\"1\":{\"630\":1}}],[\"保证\",{\"1\":{\"576\":1}}],[\"保证池的正常工作\",{\"1\":{\"574\":1}}],[\"保证在其它线程读到它的值时不会出现为\",{\"1\":{\"567\":1}}],[\"保证多线程访问同一个对象的成员变量时\",{\"1\":{\"562\":1}}],[\"保证数据唯一\",{\"1\":{\"1005\":1}}],[\"保证数据完整性上都不如行存储\",{\"1\":{\"995\":1}}],[\"保证数据安全\",{\"1\":{\"590\":1}}],[\"保证数据不在因mysql宕机而丢失\",{\"1\":{\"506\":1}}],[\"保证数组内元素的线程安全\",{\"1\":{\"562\":1}}],[\"保证引用类型的共享变量是线程安全的\",{\"1\":{\"562\":1}}],[\"保证有序性\",{\"1\":{\"557\":1}}],[\"保证可见性\",{\"1\":{\"557\":1}}],[\"保证指令不会受到cpu指令并行优化的影响\",{\"1\":{\"556\":1}}],[\"保证指令不会受到线程上下文切换的影响\",{\"1\":{\"556\":1}}],[\"保证指令不会受cpu缓存的影响\",{\"1\":{\"556\":1}}],[\"保证被关联的字段需要有索引\",{\"1\":{\"481\":1}}],[\"保证每个文件的大小小于10m\",{\"1\":{\"477\":1}}],[\"保证相同的分布到一起\",{\"1\":{\"466\":1}}],[\"保证各进程在各自存储空间内运行互不干扰\",{\"1\":{\"180\":1}}],[\"保证不会饥饿\",{\"1\":{\"168\":1}}],[\"保证只被实例化一次\",{\"1\":{\"66\":1}}],[\"保护程序安全\",{\"1\":{\"623\":1}}],[\"保护性拷贝\",{\"1\":{\"566\":2}}],[\"保护性暂停模式\",{\"0\":{\"547\":1}}],[\"保护数据隐私\",{\"1\":{\"272\":1}}],[\"保护\",{\"1\":{\"63\":1}}],[\"添加监听器\",{\"1\":{\"1446\":1}}],[\"添加容器初始化器\",{\"1\":{\"1446\":1}}],[\"添加命令行参数\",{\"1\":{\"1444\":1}}],[\"添加自定义转换器\",{\"1\":{\"1376\":2}}],[\"添加的即属于这种\",{\"1\":{\"1370\":1}}],[\"添加的任务的线程需要负责唤醒\",{\"1\":{\"741\":1}}],[\"添加动态表名插件\",{\"1\":{\"1232\":1}}],[\"添加或者修改hash类型key的field的值\",{\"1\":{\"1208\":1}}],[\"添加或者修改已经存在的一个string类型的键值对\",{\"1\":{\"1206\":1}}],[\"添加一个或多个元素到sorted\",{\"1\":{\"1211\":1}}],[\"添加一个hash类型的key的field值\",{\"1\":{\"1208\":1}}],[\"添加一个string类型的键值对\",{\"1\":{\"1206\":2}}],[\"添加一个地理空间信息\",{\"1\":{\"1170\":1}}],[\"添加一个字段\",{\"1\":{\"1161\":1}}],[\"添加一个分区\",{\"1\":{\"280\":1}}],[\"添加锁\",{\"1\":{\"1141\":1}}],[\"添加以下逻辑\",{\"1\":{\"1137\":1}}],[\"添加优惠卷\",{\"0\":{\"1133\":1}}],[\"添加商户缓存\",{\"0\":{\"1116\":1}}],[\"添加分布式缓存文件\",{\"1\":{\"989\":1,\"990\":1}}],[\"添加普通文件到分布式缓存中\",{\"1\":{\"989\":1}}],[\"添加归档文件到分布式缓存中\",{\"1\":{\"989\":1}}],[\"添加缓存文件\",{\"1\":{\"989\":1}}],[\"添加到商品集合中\",{\"1\":{\"988\":2}}],[\"添加到集合中的元素越多\",{\"1\":{\"658\":1}}],[\"添加读取数据库相关参数\",{\"1\":{\"985\":1}}],[\"添加退役节点\",{\"1\":{\"879\":1}}],[\"添加用户定义的擦除编码策略列表\",{\"1\":{\"875\":1}}],[\"添加处理器\",{\"1\":{\"766\":1}}],[\"添加回调\",{\"1\":{\"756\":1}}],[\"添加任务\",{\"1\":{\"741\":1}}],[\"添加初始化器\",{\"1\":{\"740\":1}}],[\"添加了processor进行中间处理\",{\"1\":{\"718\":1}}],[\"添加链表头节点使用了cas\",{\"1\":{\"579\":1}}],[\"添加\",{\"1\":{\"66\":1,\"279\":1,\"743\":1,\"785\":1,\"1045\":1,\"1451\":1}}],[\"解压后\",{\"1\":{\"1193\":1}}],[\"解压缩后\",{\"1\":{\"1201\":1}}],[\"解压缩\",{\"1\":{\"1193\":1}}],[\"解码\",{\"1\":{\"784\":1,\"875\":1}}],[\"解读\",{\"1\":{\"713\":1}}],[\"解绑会话\",{\"1\":{\"701\":1}}],[\"解析类得到beandefinition\",{\"1\":{\"1505\":1}}],[\"解析每个单例\",{\"1\":{\"1493\":1}}],[\"解析每个参数值\",{\"1\":{\"1362\":1}}],[\"解析时机\",{\"1\":{\"1493\":1}}],[\"解析此类的\",{\"1\":{\"1382\":1,\"1390\":1,\"1410\":1}}],[\"解析方法参数\",{\"1\":{\"1362\":1}}],[\"解析参数依赖的就是各种参数解析器\",{\"1\":{\"1362\":1}}],[\"解析控制器方法参数\",{\"1\":{\"1355\":1}}],[\"解析器\",{\"1\":{\"1284\":1}}],[\"解析元数据是基于\",{\"1\":{\"1274\":1}}],[\"解析\",{\"1\":{\"1257\":2,\"1264\":4,\"1444\":1,\"1482\":1}}],[\"解析出id\",{\"1\":{\"1172\":1}}],[\"解析出其中的用户id\",{\"1\":{\"1162\":1}}],[\"解析数据\",{\"1\":{\"1168\":1}}],[\"解析url\",{\"1\":{\"652\":1}}],[\"解析和初始化\",{\"1\":{\"630\":1}}],[\"解析所有字段\",{\"1\":{\"396\":1}}],[\"解法2相对解法1\",{\"1\":{\"478\":1}}],[\"解法2\",{\"0\":{\"478\":1}}],[\"解法1不适用\",{\"1\":{\"478\":1}}],[\"解法1\",{\"0\":{\"477\":1}}],[\"解密\",{\"1\":{\"201\":1}}],[\"解除死锁的主要方法\",{\"1\":{\"178\":1}}],[\"解除死锁\",{\"1\":{\"178\":1}}],[\"解锁\",{\"1\":{\"168\":1}}],[\"解决内存大小有限的问题\",{\"1\":{\"1189\":1}}],[\"解决redis分布式锁误删问题\",{\"0\":{\"1144\":1}}],[\"解决缓存穿透问题\",{\"1\":{\"1124\":1,\"1127\":1,\"1129\":1}}],[\"解决状态登录刷新问题\",{\"0\":{\"1108\":1}}],[\"解决数据同步问题\",{\"1\":{\"884\":1}}],[\"解决脑裂问题\",{\"1\":{\"884\":1}}],[\"解决单点故障\",{\"1\":{\"882\":1}}],[\"解决把订阅者压垮的问题\",{\"1\":{\"719\":1}}],[\"解决办法是\",{\"1\":{\"577\":1}}],[\"解决死锁问题最简单的一种方法是超时\",{\"1\":{\"513\":1}}],[\"解决了dml和ddl操作之间的一致性问题\",{\"1\":{\"510\":1}}],[\"解决了单例\",{\"1\":{\"66\":1}}],[\"解决方法虽然不同\",{\"1\":{\"1297\":1}}],[\"解决方法有\",{\"1\":{\"1290\":1}}],[\"解决方法\",{\"1\":{\"348\":1,\"883\":1,\"1285\":1}}],[\"解决方案就是在每个线程释放锁的时候\",{\"1\":{\"1143\":1}}],[\"解决方案三\",{\"0\":{\"375\":1}}],[\"解决方案二\",{\"0\":{\"374\":1},\"1\":{\"1126\":1}}],[\"解决方案一\",{\"0\":{\"373\":1},\"1\":{\"1126\":1}}],[\"解决方案\",{\"0\":{\"695\":1},\"1\":{\"101\":1,\"560\":1,\"1125\":1,\"1143\":1,\"1177\":1,\"1230\":1}}],[\"解决问题\",{\"1\":{\"195\":1}}],[\"解决的问题\",{\"1\":{\"195\":1,\"196\":1,\"1476\":1}}],[\"解决上面第一个问题\",{\"1\":{\"186\":1}}],[\"解决\",{\"1\":{\"159\":1,\"792\":1,\"1294\":1}}],[\"解决依赖冲突\",{\"1\":{\"105\":1}}],[\"解耦\",{\"1\":{\"25\":1}}],[\"再以统一的适配器接口调用handler\",{\"1\":{\"1530\":1}}],[\"再封装为\",{\"1\":{\"1489\":1}}],[\"再解析\",{\"1\":{\"1482\":1}}],[\"再利用默认的\",{\"1\":{\"1370\":1}}],[\"再看有没有\",{\"1\":{\"1370\":1}}],[\"再从发件箱里边去拉信息\",{\"1\":{\"1166\":1}}],[\"再在后台开一个线程\",{\"1\":{\"1155\":1}}],[\"再重新设置一个timetask\",{\"1\":{\"1152\":1}}],[\"再重新调入内存\",{\"1\":{\"164\":1}}],[\"再给我来10块的\",{\"1\":{\"1147\":1}}],[\"再执行\",{\"1\":{\"1146\":1}}],[\"再执行get\",{\"1\":{\"1146\":1}}],[\"再放行第一个线程\",{\"1\":{\"1144\":1}}],[\"再提交回数据时\",{\"1\":{\"1135\":1}}],[\"再释放锁\",{\"1\":{\"1127\":1}}],[\"再去进行查询\",{\"1\":{\"1127\":1}}],[\"再操作数据库\",{\"1\":{\"1121\":1}}],[\"再删除缓存\",{\"1\":{\"1121\":2,\"1122\":1}}],[\"再找到tomcat端的socket\",{\"1\":{\"1100\":1}}],[\"再统一返回\",{\"1\":{\"1100\":1}}],[\"再均衡\",{\"0\":{\"1037\":1}}],[\"再接下10位存储机器码\",{\"1\":{\"998\":1}}],[\"再对合并后的数据排序\",{\"1\":{\"966\":1}}],[\"再对加密内容解密读取\",{\"1\":{\"935\":1}}],[\"再分配\",{\"1\":{\"841\":1}}],[\"再分配给缺页进程\",{\"1\":{\"192\":1}}],[\"再写入时在新内容和原末尾之间会有空洞\",{\"1\":{\"817\":1}}],[\"再写入一个\",{\"1\":{\"772\":1,\"773\":1}}],[\"再次调用\",{\"1\":{\"1340\":1}}],[\"再次调用是否产生两笔订单\",{\"1\":{\"1003\":1}}],[\"再次传递到后台\",{\"1\":{\"1168\":1}}],[\"再次点击则取消点赞\",{\"1\":{\"1161\":1}}],[\"再次进行\",{\"1\":{\"1152\":1}}],[\"再次进行自旋操作\",{\"1\":{\"1135\":1}}],[\"再次读操作\",{\"1\":{\"776\":1}}],[\"再次确认链表头节点没有被移动\",{\"1\":{\"579\":1}}],[\"再读只能读那些尚未读取的部分\",{\"1\":{\"774\":1}}],[\"再经过一道道出站工序最终变成产品\",{\"1\":{\"766\":1}}],[\"再增加两个非\",{\"1\":{\"748\":1}}],[\"再来看可读事件\",{\"1\":{\"744\":1}}],[\"再来讨论一下懒汉模式中加锁的问题\",{\"1\":{\"66\":1}}],[\"再\",{\"1\":{\"699\":1}}],[\"再关闭\",{\"1\":{\"694\":1}}],[\"再调入即将运行的段\",{\"1\":{\"689\":1}}],[\"再调用park线程发现counter为1继续运行并将counter置为0\",{\"1\":{\"549\":1}}],[\"再通过正则对一行文本进行分隔\",{\"1\":{\"959\":1}}],[\"再通过volume\",{\"1\":{\"874\":1}}],[\"再通过调页功能及页面置换功能陆续地把即将运行的页面调入内存\",{\"1\":{\"689\":1}}],[\"再通过sublist取start\",{\"1\":{\"483\":1}}],[\"再过60分钟你就能了解同步异步\",{\"1\":{\"675\":1}}],[\"再处理\",{\"1\":{\"648\":1}}],[\"再进入这个构造看看\",{\"1\":{\"566\":1}}],[\"再进行处理\",{\"1\":{\"436\":1}}],[\"再进行group\",{\"1\":{\"307\":1}}],[\"再进行第二轮扫描\",{\"1\":{\"191\":1}}],[\"再根据成员名或变量名进行筛选\",{\"1\":{\"1482\":1}}],[\"再根据\",{\"1\":{\"1482\":1}}],[\"再根据这套算法\",{\"1\":{\"1176\":1}}],[\"再根据槽位值和redis节点的对应关系就可以定位到key具体是落在哪个redis节点上\",{\"1\":{\"528\":1}}],[\"再根据索引记录位置去读取对应的数据\",{\"1\":{\"455\":1}}],[\"再同步到从节点\",{\"1\":{\"527\":1}}],[\"再把每个段分成若干个页\",{\"1\":{\"683\":1}}],[\"再把auto\",{\"1\":{\"510\":1}}],[\"再把源文件读入内存\",{\"1\":{\"194\":1}}],[\"再更新到buffer\",{\"1\":{\"506\":1}}],[\"再启动一个或多个maptask\",{\"1\":{\"448\":1}}],[\"再运行task\",{\"1\":{\"444\":1}}],[\"再使用having过滤\",{\"1\":{\"307\":1}}],[\"再查询全部的key\",{\"1\":{\"1205\":1}}],[\"再查询数据库\",{\"1\":{\"1117\":1}}],[\"再查询\",{\"1\":{\"260\":1}}],[\"再将下单业务放入阻塞队列\",{\"1\":{\"1157\":1}}],[\"再将其放入到redis中\",{\"1\":{\"1123\":1}}],[\"再将数据写回到用户端的socket\",{\"1\":{\"1100\":1}}],[\"再将key作为输出的key\",{\"1\":{\"961\":1}}],[\"再将要访问的页\",{\"1\":{\"688\":1}}],[\"再将一个字符串的第\",{\"1\":{\"614\":1}}],[\"再将原来数组赋值过去\",{\"1\":{\"601\":1}}],[\"再将内存中的数据写入到新文件中\",{\"1\":{\"194\":1}}],[\"再将内存中的页面都通过链接指针链接成一个循环队列\",{\"1\":{\"191\":1}}],[\"再将内存空间分为大小相同的页框\",{\"1\":{\"188\":1}}],[\"再将各段分页\",{\"1\":{\"188\":1}}],[\"再按照分区大小把进程拆分为一个个小部分\",{\"1\":{\"184\":1}}],[\"再设计一个咖啡店类\",{\"1\":{\"25\":1}}],[\"该接口中包含如下三个方法\",{\"1\":{\"1532\":1}}],[\"该接口中表示kafka服务器响应给客户端\",{\"1\":{\"1025\":1}}],[\"该注解适用于绑定url中的占位符\",{\"1\":{\"1531\":1}}],[\"该注解的作用就是用来处理请求地址映射的\",{\"1\":{\"1531\":1}}],[\"该模块为与aspectj的集成提供支持\",{\"1\":{\"1499\":1}}],[\"该模式的核心含义就是\",{\"1\":{\"1166\":1}}],[\"该模式的实现方案有三种\",{\"1\":{\"1166\":2}}],[\"该\",{\"1\":{\"1461\":1}}],[\"该怎么办\",{\"1\":{\"1207\":1}}],[\"该目录已经默认配置到环境变量\",{\"1\":{\"1193\":1}}],[\"该抢锁逻辑和之前逻辑相同\",{\"1\":{\"1152\":1}}],[\"该用户组中的用户列表\",{\"1\":{\"924\":1}}],[\"该命令立即从文件系统中删除过期的检查点\",{\"1\":{\"910\":1}}],[\"该概念就和windows的垃圾桶一样\",{\"1\":{\"908\":1}}],[\"该数据包才会从确认队列删除\",{\"1\":{\"901\":1}}],[\"该datanode存储数据包并将它发送到pipeline的第二个datanode\",{\"1\":{\"901\":1}}],[\"该文件包含不允许连接到名称节点的主机列表\",{\"1\":{\"880\":1}}],[\"该文件包含允许连接到namenode的主机列表\",{\"1\":{\"880\":1}}],[\"该参数位于hdfs\",{\"1\":{\"880\":2}}],[\"该属性\",{\"1\":{\"879\":1}}],[\"该操作node2\",{\"1\":{\"879\":1}}],[\"该操作仅更改表元数据\",{\"1\":{\"279\":1}}],[\"该向量由k个数据块\",{\"1\":{\"875\":1}}],[\"该节点上所有volume\",{\"1\":{\"874\":1}}],[\"该节点迁移完成后加入forwardingnode作为当前节点的头节点\",{\"1\":{\"579\":1}}],[\"该步是异步操作\",{\"1\":{\"754\":1}}],[\"该置换算法选择在之前时期使用最少的也页面作为淘汰页\",{\"1\":{\"690\":1}}],[\"该算法是指发送端即使还有应该发送的数据\",{\"1\":{\"694\":1}}],[\"该算法赋予每个页面一个访问字段\",{\"1\":{\"690\":1}}],[\"该算法解决了进程互斥问题\",{\"1\":{\"169\":1}}],[\"该字符串首先由多个哈希函数生成不同的哈希值\",{\"1\":{\"659\":1}}],[\"该字段是虚拟字段\",{\"1\":{\"260\":1}}],[\"该函数会被应用到每个元素上\",{\"1\":{\"617\":1}}],[\"该函数返回null\",{\"1\":{\"248\":1}}],[\"该对象才会进行初始化以及依赖注入的操作\",{\"1\":{\"1501\":1}}],[\"该对象包含了如下信息\",{\"1\":{\"1339\":1}}],[\"该对象提供了一组方法\",{\"1\":{\"610\":1}}],[\"该对象头的mark\",{\"1\":{\"541\":1}}],[\"该线程可以做其他事情\",{\"1\":{\"610\":1}}],[\"该线程可以在任何时刻\",{\"1\":{\"577\":1}}],[\"该线程进入阻塞状态同时不释放自己已有的资源\",{\"1\":{\"551\":1}}],[\"该事务执行期间\",{\"1\":{\"506\":1}}],[\"该sql语句转换为mapreduce时\",{\"1\":{\"452\":1}}],[\"该表记录了该字段的每个值与数据实际物理位置之间的关系\",{\"1\":{\"421\":1}}],[\"该结果集是从with子句中指定的简单查询派生而来的\",{\"1\":{\"318\":1}}],[\"该子查询不引用父查询中的列\",{\"1\":{\"317\":1}}],[\"该条记录的原始写事务id\",{\"1\":{\"293\":1}}],[\"该id在表范围内唯一\",{\"1\":{\"293\":1}}],[\"该平台包括用户服务\",{\"1\":{\"110\":1}}],[\"该依赖范围只能与\",{\"1\":{\"100\":1}}],[\"该方法含义是redis中如果没有这个key\",{\"1\":{\"1127\":1}}],[\"该方法比jps更准确\",{\"1\":{\"885\":1}}],[\"该方法的执行还是nio线程\",{\"1\":{\"753\":1}}],[\"该方法会首先切换\",{\"1\":{\"747\":1}}],[\"该方法是每次读取一个字节数据\",{\"1\":{\"88\":1}}],[\"该方式也实现了懒加载效果\",{\"1\":{\"66\":1}}],[\"该方式在成员位置声明singleton类型的静态变量\",{\"1\":{\"66\":2}}],[\"该安全门具有防火\",{\"1\":{\"75\":1}}],[\"该类自jdk\",{\"1\":{\"590\":1}}],[\"该类中的方法不能被重写\",{\"1\":{\"566\":1}}],[\"该类负责创建自己的对象\",{\"1\":{\"64\":1}}],[\"该类同时实现当前系统的业务接口\",{\"1\":{\"7\":1}}],[\"方案分析\",{\"1\":{\"1126\":1}}],[\"方案三\",{\"0\":{\"466\":1,\"470\":1}}],[\"方案二\",{\"0\":{\"465\":1,\"469\":1},\"1\":{\"176\":1,\"455\":1,\"1223\":1}}],[\"方案一\",{\"0\":{\"464\":1,\"468\":1},\"1\":{\"176\":1,\"452\":1,\"455\":1,\"1223\":1}}],[\"方便我们操作redis\",{\"1\":{\"1212\":1}}],[\"方便后续进行共同关注\",{\"1\":{\"1165\":1}}],[\"方便后续获得当前登录信息\",{\"1\":{\"1098\":1}}],[\"方便咱们继续使用缓存\",{\"1\":{\"1119\":1}}],[\"方便一键启停\",{\"1\":{\"878\":1}}],[\"方便维护\",{\"1\":{\"483\":1}}],[\"方便文件拓展\",{\"1\":{\"197\":2}}],[\"方便用户使用\",{\"1\":{\"154\":1}}],[\"方便管理和维护\",{\"1\":{\"108\":1}}],[\"方式分别实现\",{\"1\":{\"1243\":1}}],[\"方式解决\",{\"1\":{\"481\":1}}],[\"方式\",{\"1\":{\"105\":1}}],[\"方式来实现单例模式的\",{\"1\":{\"70\":1}}],[\"方式4\",{\"1\":{\"66\":1}}],[\"方式3\",{\"1\":{\"66\":1}}],[\"方式2\",{\"1\":{\"66\":2}}],[\"方式1\",{\"1\":{\"66\":2}}],[\"方法均无法增强\",{\"1\":{\"1480\":1}}],[\"方法均不能通过代理实现\",{\"1\":{\"1310\":1}}],[\"方法测试\",{\"1\":{\"1442\":1}}],[\"方法创建模型工厂\",{\"1\":{\"1390\":1}}],[\"方法创建绑定工厂\",{\"1\":{\"1382\":1}}],[\"方法创建具体的商品类的对象\",{\"1\":{\"43\":1}}],[\"方法反射优化\",{\"0\":{\"1311\":1}}],[\"方法重写可以增强逻辑\",{\"1\":{\"1310\":1}}],[\"方法上的目的是可以观察输出\",{\"1\":{\"1294\":1}}],[\"方法上添加了synchronized关键字\",{\"1\":{\"66\":1}}],[\"方法进行基于类型的查找\",{\"1\":{\"1267\":1}}],[\"方法进行等待\",{\"1\":{\"593\":1}}],[\"方法有重载方法\",{\"1\":{\"1152\":1}}],[\"方法发送消息\",{\"1\":{\"1023\":1}}],[\"方法关闭\",{\"1\":{\"901\":1}}],[\"方法就会返回这些事件交给\",{\"1\":{\"867\":1}}],[\"方法就会阻塞\",{\"1\":{\"741\":1}}],[\"方法拷贝数据\",{\"1\":{\"855\":1}}],[\"方法调用链中下一个环绕通知\",{\"1\":{\"1346\":1}}],[\"方法调用后\",{\"1\":{\"854\":1}}],[\"方法调用了\",{\"1\":{\"88\":1}}],[\"方法会将接收到的数据存入\",{\"1\":{\"848\":1}}],[\"方法会间接地调用\",{\"1\":{\"816\":1}}],[\"方法会让\",{\"1\":{\"803\":1}}],[\"方法并不能保证一次将\",{\"1\":{\"815\":1}}],[\"方法将文件内容和元数据\",{\"1\":{\"819\":1}}],[\"方法将\",{\"1\":{\"803\":1}}],[\"方法将数据写入并刷出\",{\"1\":{\"752\":1}}],[\"方法将数据写入\",{\"1\":{\"752\":1}}],[\"方法为\",{\"1\":{\"801\":1}}],[\"方法等待\",{\"1\":{\"785\":1}}],[\"方法计数加\",{\"1\":{\"775\":1}}],[\"方法计数减\",{\"1\":{\"775\":1}}],[\"方法签名\",{\"1\":{\"772\":1}}],[\"方法列表\",{\"1\":{\"772\":1}}],[\"方法参考如下\",{\"1\":{\"768\":1}}],[\"方法参数封装为\",{\"1\":{\"1267\":1}}],[\"方法参数的信息\",{\"1\":{\"1267\":1}}],[\"方法参数值数组\",{\"1\":{\"733\":1}}],[\"方法参数类型数组\",{\"1\":{\"733\":1}}],[\"方法参数说明\",{\"1\":{\"59\":1}}],[\"方法异步处理结果\",{\"1\":{\"753\":1}}],[\"方法可以让异步操作同步以外\",{\"1\":{\"753\":1}}],[\"方法执行就返回了\",{\"1\":{\"753\":1}}],[\"方法执行结果为true\",{\"1\":{\"69\":1}}],[\"方法添加处理器\",{\"1\":{\"752\":1}}],[\"方法是同步等待连接建立完成\",{\"1\":{\"753\":1}}],[\"方法是异步非阻塞的\",{\"1\":{\"753\":1}}],[\"方法是异步等待\",{\"1\":{\"752\":1}}],[\"方法是抽象方法\",{\"1\":{\"88\":1}}],[\"方法作用是同步等待\",{\"1\":{\"752\":1}}],[\"方法判断一个线程是否属于此\",{\"1\":{\"746\":1}}],[\"方法处理\",{\"1\":{\"746\":1}}],[\"方法即使没有时间发生\",{\"1\":{\"742\":1}}],[\"方法的目的类似\",{\"1\":{\"1294\":1}}],[\"方法的源码解析\",{\"1\":{\"1152\":1}}],[\"方法的返回值即为要导入的配置类名\",{\"1\":{\"1465\":1}}],[\"方法的返回值\",{\"1\":{\"843\":1}}],[\"方法的返回值代表有多少\",{\"1\":{\"832\":1}}],[\"方法的效果\",{\"1\":{\"742\":1}}],[\"方法的区别是什么呢\",{\"0\":{\"575\":1}}],[\"方法无谓阻塞\",{\"1\":{\"741\":1}}],[\"方法不会阻塞\",{\"1\":{\"741\":1}}],[\"方法见下\",{\"1\":{\"741\":1}}],[\"方法时\",{\"1\":{\"740\":1,\"1294\":1,\"1321\":1}}],[\"方法返回类型\",{\"1\":{\"733\":1}}],[\"方法4\",{\"0\":{\"699\":1},\"1\":{\"1129\":1}}],[\"方法3\",{\"0\":{\"698\":1},\"1\":{\"832\":1,\"1129\":1}}],[\"方法2\",{\"0\":{\"697\":1},\"1\":{\"779\":1,\"832\":1,\"1129\":1}}],[\"方法1\",{\"0\":{\"696\":1},\"1\":{\"779\":1,\"832\":1,\"1129\":1}}],[\"方法区\",{\"1\":{\"628\":1}}],[\"方法和\",{\"0\":{\"575\":1},\"1\":{\"1382\":1,\"1390\":1}}],[\"方法之后的状态\",{\"1\":{\"538\":1}}],[\"方法中\",{\"1\":{\"1137\":1}}],[\"方法中首次创建\",{\"1\":{\"775\":1}}],[\"方法中会\",{\"1\":{\"765\":1}}],[\"方法中定义的局部变量是否线程安全\",{\"0\":{\"627\":1}}],[\"方法中实现函数的业务逻辑\",{\"1\":{\"344\":1}}],[\"方法中又调用了invocationhandler接口的子实现类对象的invoke方法\",{\"1\":{\"59\":1}}],[\"方法二\",{\"1\":{\"180\":1}}],[\"方法一\",{\"1\":{\"180\":1}}],[\"方法后\",{\"1\":{\"69\":1,\"855\":2}}],[\"方法被调用时才会被加载\",{\"1\":{\"66\":1}}],[\"方法获取文件的大小\",{\"1\":{\"818\":1}}],[\"方法获取索引\",{\"1\":{\"803\":1}}],[\"方法获取集合中下一个\",{\"1\":{\"746\":1}}],[\"方法获取singleton类的对象的时候才创建singleton类的对象\",{\"1\":{\"66\":1}}],[\"方法获取形状类型的对象\",{\"1\":{\"23\":1}}],[\"方法来打开希望读取的文件\",{\"1\":{\"902\":1}}],[\"方法来处理下一个\",{\"1\":{\"859\":2}}],[\"方法来获取\",{\"1\":{\"753\":1}}],[\"方法来绑定其中一个\",{\"1\":{\"746\":1}}],[\"方法来看看自己属于哪个\",{\"1\":{\"746\":1}}],[\"方法来排序\",{\"1\":{\"603\":1}}],[\"方法来说\",{\"1\":{\"66\":1}}],[\"方法来实现浅克隆\",{\"1\":{\"51\":1}}],[\"方法来复制新的对象\",{\"1\":{\"50\":1}}],[\"方法\",{\"1\":{\"50\":2,\"59\":3,\"69\":2,\"88\":3,\"536\":1,\"538\":1,\"590\":1,\"599\":2,\"632\":1,\"737\":1,\"741\":1,\"743\":1,\"747\":1,\"753\":1,\"780\":1,\"798\":1,\"802\":2,\"803\":2,\"813\":1,\"816\":1,\"840\":1,\"854\":1,\"855\":1,\"901\":1,\"902\":2,\"1132\":1,\"1137\":1,\"1141\":1,\"1382\":2,\"1390\":2,\"1410\":2,\"1437\":1,\"1438\":4,\"1444\":1,\"1480\":2,\"1505\":3}}],[\"方法使用的是工厂模式\",{\"1\":{\"43\":2}}],[\"本组映射器和适配器\",{\"0\":{\"1419\":1,\"1423\":1,\"1427\":1}}],[\"本例共用同一个\",{\"1\":{\"1339\":1}}],[\"本例中的个人页面\",{\"1\":{\"1166\":1}}],[\"本节\",{\"1\":{\"1167\":1}}],[\"本节要介绍的抽象工厂模式将考虑多等级产品的生产\",{\"1\":{\"36\":1}}],[\"本来应该去查询数据库\",{\"1\":{\"1126\":1}}],[\"本机已用空间与本机总容量之比\",{\"1\":{\"873\":1}}],[\"本身当作\",{\"1\":{\"1421\":1}}],[\"本身并不具备\",{\"1\":{\"854\":1}}],[\"本身也是分布式的\",{\"1\":{\"526\":1}}],[\"本身数据量并不大\",{\"1\":{\"444\":1}}],[\"本文摘录自阿里巴巴java开发手册mysql数据库篇\",{\"1\":{\"479\":1}}],[\"本次登陆日期的第三天\",{\"1\":{\"400\":1}}],[\"本次登陆日期的第二天\",{\"1\":{\"400\":2}}],[\"本次登陆以后的第三天\",{\"1\":{\"399\":1}}],[\"本次登陆以后的第二天\",{\"1\":{\"399\":1}}],[\"本质是一个单线程执行器\",{\"1\":{\"746\":1}}],[\"本质是因为\",{\"1\":{\"694\":1}}],[\"本质上是根据成员变量或方法参数的类型进行装配\",{\"1\":{\"1489\":1}}],[\"本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理\",{\"1\":{\"680\":1}}],[\"本质上其实是\",{\"1\":{\"1037\":1}}],[\"本质上和get一样\",{\"1\":{\"1004\":1}}],[\"本质上并没有区别\",{\"1\":{\"497\":1}}],[\"本质\",{\"1\":{\"259\":1}}],[\"本轮将所有扫描过的帧访问位设为0\",{\"1\":{\"191\":1}}],[\"本轮扫描不修改任何标志位\",{\"1\":{\"191\":2}}],[\"本地缓存与redis中的缓存并发使用\",{\"1\":{\"1115\":1}}],[\"本地缓存\",{\"1\":{\"1113\":1}}],[\"本地用于高并发\",{\"1\":{\"1113\":1}}],[\"本地测试不走网卡\",{\"1\":{\"694\":1}}],[\"本地回环地址的\",{\"1\":{\"694\":1}}],[\"本地模式采用外部数据库来存储元数据\",{\"1\":{\"243\":1}}],[\"本地模式\",{\"0\":{\"243\":1,\"444\":1},\"1\":{\"241\":2,\"243\":2,\"963\":1}}],[\"本地仓库中\",{\"1\":{\"101\":1}}],[\"本地仓库位置\",{\"1\":{\"92\":1}}],[\"本地\",{\"1\":{\"101\":1}}],[\"本地服务通过网络请求远程服务\",{\"1\":{\"63\":1}}],[\"8到12步\",{\"1\":{\"1445\":1}}],[\"81\",{\"1\":{\"1179\":1}}],[\"81214953\",{\"1\":{\"145\":1}}],[\"876小时=52\",{\"1\":{\"882\":1}}],[\"871000000\",{\"1\":{\"337\":1}}],[\"8k\",{\"1\":{\"841\":2}}],[\"8b\",{\"1\":{\"697\":10,\"699\":1,\"748\":2}}],[\"8b+8b\",{\"1\":{\"487\":1}}],[\"80mb\",{\"1\":{\"979\":1}}],[\"80\",{\"1\":{\"759\":1,\"768\":1}}],[\"80b\",{\"1\":{\"697\":1}}],[\"8080\",{\"1\":{\"692\":8,\"693\":8,\"696\":1,\"702\":2,\"711\":1,\"723\":1,\"725\":1,\"733\":2,\"735\":1,\"737\":1,\"740\":1,\"748\":21,\"753\":6,\"754\":1,\"766\":2,\"784\":1,\"785\":1,\"794\":2,\"826\":2,\"827\":1,\"834\":2,\"836\":4,\"840\":2,\"843\":2,\"846\":1,\"859\":1,\"1292\":1,\"1438\":1,\"1449\":1}}],[\"80h\",{\"1\":{\"676\":1}}],[\"8时将serial+cms\",{\"1\":{\"638\":1}}],[\"8之后在解决哈希冲突时有了较大的变化\",{\"1\":{\"605\":1}}],[\"8之前hashmap底层采用的是数组和链表\",{\"1\":{\"605\":1}}],[\"8之前链表采用头插法\",{\"1\":{\"605\":1}}],[\"8之前的hashmap\",{\"1\":{\"515\":1}}],[\"8采用了尾插法\",{\"1\":{\"605\":1}}],[\"8可以用default关键字在接口中定义默认方法\",{\"1\":{\"595\":1}}],[\"8加入\",{\"1\":{\"590\":1}}],[\"8而言\",{\"1\":{\"579\":1}}],[\"8个字节\",{\"1\":{\"487\":1}}],[\"8编码\",{\"1\":{\"482\":1}}],[\"8=\",{\"1\":{\"369\":1}}],[\"8888\",{\"1\":{\"726\":2,\"795\":2}}],[\"888\",{\"1\":{\"256\":5}}],[\"82660381\",{\"1\":{\"145\":1}}],[\"826065030944870400\",{\"1\":{\"132\":1}}],[\"8\",{\"0\":{\"160\":1,\"182\":1,\"201\":1,\"309\":1,\"343\":1,\"775\":1,\"891\":1,\"892\":1,\"1030\":1,\"1031\":1,\"1036\":1,\"1039\":1,\"1043\":1,\"1068\":1,\"1082\":1,\"1107\":1,\"1126\":1,\"1138\":1,\"1147\":1,\"1163\":1,\"1164\":1,\"1165\":1,\"1166\":1,\"1167\":1,\"1168\":1,\"1211\":1,\"1290\":1},\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"163\":1,\"331\":3,\"480\":1,\"579\":1,\"606\":1,\"620\":1,\"648\":2,\"658\":1,\"663\":1,\"692\":2,\"693\":3,\"696\":1,\"697\":15,\"698\":11,\"699\":11,\"713\":1,\"714\":1,\"717\":1,\"723\":4,\"740\":1,\"748\":6,\"755\":3,\"772\":3,\"773\":1,\"774\":4,\"776\":6,\"779\":5,\"780\":3,\"785\":2,\"796\":1,\"799\":1,\"805\":5,\"807\":3,\"808\":2,\"820\":1,\"822\":2,\"836\":2,\"848\":2,\"857\":1,\"875\":2,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"979\":2,\"1046\":2,\"1070\":4,\"1082\":1,\"1107\":1,\"1111\":1,\"1129\":1,\"1174\":2,\"1176\":1,\"1205\":1,\"1206\":1,\"1215\":2,\"1219\":1,\"1220\":2,\"1236\":1,\"1243\":1,\"1244\":1,\"1292\":1,\"1296\":1,\"1300\":1,\"1416\":1,\"1462\":2}}],[\"8<\",{\"1\":{\"92\":5,\"99\":2,\"101\":1,\"102\":4,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"957\":3,\"1022\":2,\"1219\":1}}],[\"8的时候\",{\"1\":{\"61\":1}}],[\"8逐步对jdk动态代理优化之后\",{\"1\":{\"61\":1}}],[\"7<\",{\"1\":{\"1219\":1}}],[\"76\",{\"1\":{\"808\":1}}],[\"76802514\",{\"1\":{\"145\":1}}],[\"724\",{\"1\":{\"822\":1}}],[\"72\",{\"1\":{\"807\":1,\"808\":1,\"836\":1}}],[\"745\",{\"1\":{\"762\":1,\"765\":2}}],[\"74\",{\"1\":{\"762\":1,\"765\":2,\"807\":2}}],[\"70\",{\"1\":{\"758\":1}}],[\"777\",{\"1\":{\"919\":2,\"920\":1}}],[\"7769948160\",{\"1\":{\"820\":1}}],[\"77\",{\"1\":{\"748\":4,\"807\":1,\"836\":1}}],[\"73\",{\"1\":{\"748\":4,\"765\":2}}],[\"7a\",{\"1\":{\"748\":2}}],[\"7b\",{\"1\":{\"698\":2}}],[\"7种经典的垃圾回收器\",{\"0\":{\"638\":1}}],[\"7开始支持\",{\"1\":{\"612\":1}}],[\"7中\",{\"1\":{\"607\":1}}],[\"7的死链问题\",{\"0\":{\"607\":1}}],[\"75\",{\"1\":{\"606\":1,\"748\":2,\"808\":1}}],[\"7取消了循环\",{\"1\":{\"600\":1}}],[\"7而言\",{\"1\":{\"579\":1}}],[\"7版本开始\",{\"1\":{\"420\":1}}],[\"7991651743003\",{\"1\":{\"117\":1}}],[\"7比cglib代理效率低一点\",{\"1\":{\"61\":1}}],[\"7\",{\"0\":{\"159\":1,\"181\":1,\"200\":1,\"308\":1,\"318\":1,\"326\":1,\"342\":1,\"365\":1,\"731\":1,\"774\":1,\"890\":1,\"1027\":1,\"1028\":1,\"1029\":1,\"1067\":1,\"1081\":1,\"1103\":1,\"1104\":1,\"1105\":1,\"1106\":1,\"1125\":1,\"1137\":1,\"1146\":1,\"1158\":1,\"1159\":1,\"1160\":1,\"1161\":1,\"1162\":1,\"1210\":1,\"1286\":1},\"1\":{\"61\":1,\"163\":1,\"279\":1,\"363\":2,\"567\":1,\"620\":1,\"690\":2,\"692\":2,\"693\":3,\"696\":1,\"697\":11,\"698\":11,\"699\":11,\"713\":1,\"714\":1,\"717\":1,\"718\":1,\"723\":2,\"740\":2,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":6,\"779\":5,\"780\":3,\"785\":2,\"796\":1,\"799\":1,\"805\":2,\"807\":3,\"808\":2,\"836\":2,\"848\":1,\"857\":1,\"875\":2,\"1022\":3,\"1062\":1,\"1081\":1,\"1099\":1,\"1101\":1,\"1107\":5,\"1111\":1,\"1129\":1,\"1137\":13,\"1191\":1,\"1206\":1,\"1213\":2,\"1445\":1}}],[\"6分钟\",{\"1\":{\"882\":2}}],[\"6f\",{\"1\":{\"807\":2,\"808\":1,\"836\":2,\"848\":1}}],[\"6c\",{\"1\":{\"748\":2,\"836\":3,\"848\":2}}],[\"6e\",{\"1\":{\"748\":6,\"807\":1}}],[\"6b\",{\"1\":{\"699\":1,\"748\":2}}],[\"65536\",{\"1\":{\"799\":1}}],[\"65535\",{\"1\":{\"694\":1}}],[\"65\",{\"1\":{\"698\":20,\"699\":30,\"807\":3,\"808\":1,\"836\":1,\"848\":1}}],[\"6a\",{\"1\":{\"697\":8,\"698\":22,\"699\":18}}],[\"6844903785744056333\",{\"1\":{\"1179\":1}}],[\"68\",{\"1\":{\"697\":2,\"698\":8,\"699\":4,\"748\":2,\"807\":1,\"836\":1,\"848\":1}}],[\"67\",{\"1\":{\"697\":6,\"698\":14,\"699\":4,\"748\":4}}],[\"6379\",{\"1\":{\"710\":1,\"1150\":1,\"1196\":1,\"1199\":1,\"1213\":1,\"1215\":1,\"1216\":1,\"1220\":1}}],[\"6379>\",{\"1\":{\"519\":4,\"1205\":24,\"1206\":25,\"1208\":18,\"1209\":5,\"1210\":16}}],[\"63641\",{\"1\":{\"698\":15}}],[\"63\",{\"1\":{\"697\":4,\"698\":6,\"699\":12}}],[\"62\",{\"1\":{\"697\":2,\"698\":6,\"699\":18}}],[\"61\",{\"1\":{\"697\":8,\"698\":2,\"699\":18,\"748\":6,\"857\":1,\"1021\":1}}],[\"6442450941\",{\"1\":{\"820\":1}}],[\"64kib\",{\"1\":{\"799\":1}}],[\"64\",{\"1\":{\"680\":1,\"697\":2,\"698\":4,\"699\":16,\"826\":1,\"836\":1}}],[\"64位机器上就是32\",{\"1\":{\"680\":1}}],[\"64位机默认是2048个\",{\"1\":{\"680\":1}}],[\"6之前采用的是双向循环链表\",{\"1\":{\"600\":1}}],[\"6之前比使用java反射效率要高\",{\"1\":{\"61\":1}}],[\"6中新特性\",{\"1\":{\"495\":1}}],[\"6622fc65\",{\"1\":{\"1294\":2}}],[\"66259338\",{\"1\":{\"126\":1}}],[\"6666\",{\"1\":{\"615\":1}}],[\"66\",{\"1\":{\"285\":1,\"339\":1,\"615\":6,\"697\":8,\"698\":4,\"699\":26,\"808\":2}}],[\"69\",{\"1\":{\"265\":1,\"697\":10,\"698\":14,\"699\":28,\"748\":4,\"808\":1}}],[\"600\",{\"1\":{\"1174\":1}}],[\"60378\",{\"1\":{\"836\":1}}],[\"60367\",{\"1\":{\"836\":1}}],[\"60f82f98\",{\"1\":{\"746\":3}}],[\"60b\",{\"1\":{\"698\":1}}],[\"60l\",{\"1\":{\"574\":1}}],[\"60\",{\"1\":{\"256\":1}}],[\"6<\",{\"1\":{\"112\":1,\"1022\":1,\"1150\":1}}],[\"6和jdk1\",{\"1\":{\"61\":1}}],[\"6\",{\"0\":{\"102\":1,\"158\":1,\"180\":1,\"199\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"307\":1,\"317\":1,\"319\":1,\"320\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":2,\"326\":1,\"341\":1,\"362\":1,\"405\":1,\"406\":1,\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"462\":1,\"463\":1,\"467\":1,\"730\":1,\"738\":1,\"773\":1,\"887\":1,\"888\":1,\"889\":1,\"1026\":1,\"1066\":1,\"1080\":1,\"1102\":1,\"1124\":1,\"1136\":1,\"1145\":1,\"1154\":1,\"1155\":1,\"1156\":1,\"1157\":1,\"1197\":1,\"1209\":1,\"1281\":1},\"1\":{\"61\":1,\"110\":14,\"163\":1,\"279\":1,\"331\":3,\"363\":3,\"516\":2,\"541\":1,\"620\":1,\"690\":1,\"692\":2,\"693\":3,\"696\":1,\"697\":11,\"698\":11,\"699\":11,\"713\":1,\"714\":1,\"717\":1,\"718\":1,\"723\":2,\"740\":1,\"748\":6,\"766\":7,\"772\":2,\"773\":2,\"774\":3,\"776\":6,\"779\":5,\"780\":4,\"784\":2,\"785\":3,\"796\":1,\"799\":1,\"805\":2,\"807\":3,\"808\":2,\"836\":2,\"848\":1,\"856\":1,\"857\":1,\"875\":6,\"973\":1,\"985\":2,\"986\":2,\"1046\":12,\"1062\":1,\"1080\":1,\"1099\":1,\"1100\":1,\"1107\":1,\"1111\":1,\"1128\":5,\"1129\":6,\"1134\":4,\"1137\":3,\"1155\":1,\"1157\":2,\"1168\":1,\"1170\":3,\"1172\":4,\"1176\":1,\"1193\":4,\"1196\":4,\"1197\":2,\"1205\":1,\"1208\":2,\"1209\":3,\"1449\":1}}],[\"设定当类路径下包含某个jar包才会对注解的类进行实例化操作\",{\"1\":{\"1525\":1}}],[\"设定一个期限\",{\"1\":{\"1008\":1}}],[\"设备分配改进\",{\"1\":{\"213\":1}}],[\"设备分配的步骤\",{\"1\":{\"213\":1}}],[\"设备分配管理中的数据结构\",{\"1\":{\"213\":1}}],[\"设备分配中的安全性\",{\"1\":{\"213\":1}}],[\"设备分配时应考虑的因素\",{\"1\":{\"213\":1}}],[\"设备保护\",{\"1\":{\"211\":1}}],[\"设备驱动程序\",{\"1\":{\"210\":1,\"211\":1}}],[\"设备的分配算法\",{\"1\":{\"213\":1}}],[\"设备的分配与回收\",{\"0\":{\"213\":1},\"1\":{\"210\":1}}],[\"设备的固有属性\",{\"1\":{\"213\":1}}],[\"设备的保护\",{\"1\":{\"210\":1}}],[\"设备被看做是一种特殊的文件\",{\"1\":{\"210\":1,\"211\":1}}],[\"设备独立性软件\",{\"1\":{\"210\":2,\"211\":1}}],[\"设备管理\",{\"1\":{\"154\":1}}],[\"设磁盘转速为r\",{\"1\":{\"204\":1}}],[\"设置监听端口\",{\"1\":{\"1449\":1}}],[\"设置默认的数据源或者数据源组\",{\"1\":{\"1236\":1}}],[\"设置默认的acl权限\",{\"1\":{\"926\":1}}],[\"设置value的序列化\",{\"1\":{\"1222\":1}}],[\"设置key的序列化\",{\"1\":{\"1222\":1}}],[\"设置连接工厂\",{\"1\":{\"1222\":1}}],[\"设置密码\",{\"1\":{\"1213\":1}}],[\"设置名称\",{\"1\":{\"1206\":1}}],[\"设置为1\",{\"1\":{\"1196\":1}}],[\"设置后访问redis必须输入密码\",{\"1\":{\"1196\":1}}],[\"设置有效期\",{\"1\":{\"1151\":2}}],[\"设置redis能够使用的最大内存\",{\"1\":{\"1196\":1}}],[\"设置redis中的秒杀库存\",{\"1\":{\"1156\":1}}],[\"设置redis缓存时添加过期时间\",{\"1\":{\"1122\":1}}],[\"设置reducer\",{\"1\":{\"986\":1}}],[\"设置状态码\",{\"1\":{\"1111\":1}}],[\"设置token有效期\",{\"1\":{\"1107\":1}}],[\"设置查询条件\",{\"1\":{\"1089\":1}}],[\"设置查询分页\",{\"1\":{\"1089\":2}}],[\"设置消息在mq中保存10天\",{\"1\":{\"1008\":1}}],[\"设置当前作业的输入文件路径\",{\"1\":{\"986\":1}}],[\"设置当前位置时\",{\"1\":{\"817\":1}}],[\"设置当前位置\",{\"1\":{\"817\":1}}],[\"设置输入组件\",{\"1\":{\"985\":1}}],[\"设置程序最终输出的key\",{\"1\":{\"985\":1,\"986\":1}}],[\"设置本次mr程序的驱动类\",{\"1\":{\"985\":1,\"986\":1}}],[\"设置这个的原因就是在溢写的时候依然能往内存中输出数据\",{\"1\":{\"979\":1}}],[\"设置分组规则\",{\"1\":{\"974\":1}}],[\"设置作业之间的依赖关系\",{\"1\":{\"991\":1}}],[\"设置作业reducer阶段输出key\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"设置作业mapper阶段输出key\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"设置作业mapper\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"设置作业驱动类\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"设置map输出的key\",{\"1\":{\"986\":1}}],[\"设置mapper\",{\"1\":{\"985\":1,\"986\":1}}],[\"设置mapreduce最终数据输出压缩为块压缩\",{\"1\":{\"433\":1}}],[\"设置mapreduce最终数据输出压缩方式\",{\"1\":{\"433\":1}}],[\"设置mapreduce中map输出数据的压缩方式\",{\"1\":{\"433\":1}}],[\"设置mr程序的mapper类\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"设置mr程序运行的主类\",{\"1\":{\"962\":2,\"988\":1,\"991\":2}}],[\"设置加密区密钥\",{\"1\":{\"934\":1}}],[\"设置偏差为5\",{\"1\":{\"878\":1}}],[\"设置负载均衡的带宽\",{\"1\":{\"878\":1}}],[\"设置node4\",{\"1\":{\"878\":1}}],[\"设置ipaddr与hostname之间的映射\",{\"1\":{\"878\":1}}],[\"设置ipaddr\",{\"1\":{\"878\":1}}],[\"设置策略仅影响新创建的文件\",{\"1\":{\"875\":1}}],[\"设置平衡数据传输带宽\",{\"1\":{\"873\":1}}],[\"设置回调\",{\"1\":{\"761\":1}}],[\"设置回调函数\",{\"1\":{\"60\":1}}],[\"设置失败结果\",{\"1\":{\"756\":1}}],[\"设置成功结果\",{\"1\":{\"756\":1}}],[\"设置选项\",{\"1\":{\"743\":1}}],[\"设置其是否完成\",{\"1\":{\"740\":1}}],[\"设置属性\",{\"1\":{\"701\":1}}],[\"设置太大\",{\"1\":{\"694\":1}}],[\"设置对象的对象头\",{\"1\":{\"630\":2}}],[\"设置自己的head节点\",{\"1\":{\"591\":1}}],[\"设置了多个累加单元\",{\"1\":{\"579\":1}}],[\"设置了过期时间的key被没有设置过期时间的相同key覆盖了\",{\"1\":{\"519\":1}}],[\"设置多个累加单元\",{\"1\":{\"564\":1}}],[\"设置多级就绪队列\",{\"1\":{\"167\":1}}],[\"设置线控器线程\",{\"1\":{\"536\":1}}],[\"设置hive中底层mapreduce读取数据的输入类\",{\"1\":{\"436\":1}}],[\"设置还原点\",{\"1\":{\"178\":1}}],[\"设置同步信号量s\",{\"1\":{\"172\":1}}],[\"设置互斥信号量\",{\"1\":{\"172\":1}}],[\"设置包含的资源类型\",{\"1\":{\"102\":1}}],[\"设置资源所在目录\",{\"1\":{\"102\":1}}],[\"设置要打包的资源位置\",{\"1\":{\"102\":1}}],[\"设置父类的字节码对象\",{\"1\":{\"60\":1}}],[\"设计应用的横切关注点\",{\"1\":{\"1510\":1}}],[\"设计key的具体细节\",{\"0\":{\"1105\":1}}],[\"设计key的结构\",{\"0\":{\"1104\":1}}],[\"设计时要充分考虑别让\",{\"1\":{\"846\":1}}],[\"设计不同类型的结构体\",{\"1\":{\"663\":1}}],[\"设计了\",{\"1\":{\"661\":1}}],[\"设计思想\",{\"1\":{\"181\":1}}],[\"设计也更加抽象\",{\"1\":{\"86\":1}}],[\"设计一个登录请求消息和登录响应消息\",{\"1\":{\"713\":1}}],[\"设计一个系统时知道了算法所需的关键步骤\",{\"1\":{\"83\":1}}],[\"设计一个咖啡类\",{\"1\":{\"25\":1}}],[\"设计一个咖啡店点餐系统\",{\"1\":{\"25\":1}}],[\"设计者充分的利用了枚举的这个特性来实现单例模式\",{\"1\":{\"66\":1}}],[\"设计模式\",{\"0\":{\"21\":1}}],[\"因而keyout为单词text\",{\"1\":{\"961\":1}}],[\"因而该算法无法实现\",{\"1\":{\"690\":1}}],[\"因争夺所资源而造成的一种相互等待的现象\",{\"1\":{\"513\":1}}],[\"因等待某一事件而暂时不能运行\",{\"1\":{\"160\":1}}],[\"因为此时用的还是内嵌\",{\"1\":{\"1442\":1}}],[\"因为此时会让查询的性能从并行变成了串行\",{\"1\":{\"1126\":1}}],[\"因为内嵌了\",{\"1\":{\"1411\":1}}],[\"因为目前的\",{\"1\":{\"1300\":1}}],[\"因为sortedset的可排序特性\",{\"1\":{\"1211\":1}}],[\"因为也是一个hash表\",{\"1\":{\"1210\":1}}],[\"因为之前配置了密码\",{\"1\":{\"1196\":1}}],[\"因为要判断该用户是否已经统计过了\",{\"1\":{\"1179\":1}}],[\"因为要一个隔着一个的读\",{\"1\":{\"205\":1}}],[\"因为我们的数据会随时发生变化\",{\"1\":{\"1167\":1}}],[\"因为我们的数据是不能重复的\",{\"1\":{\"1161\":1}}],[\"因为普通的人他的粉丝关注量比较小\",{\"1\":{\"1166\":1}}],[\"因为赵六在读信息时\",{\"1\":{\"1166\":1}}],[\"因为没有人再去调用renewexpiration这个方法\",{\"1\":{\"1152\":1}}],[\"因为没有使用synchronized\",{\"1\":{\"561\":1}}],[\"因为锁的失效时间是30s\",{\"1\":{\"1152\":1}}],[\"因为锁能实现互斥性\",{\"1\":{\"1126\":1}}],[\"因为你调用的方法\",{\"1\":{\"1137\":1}}],[\"因为现在redis中存储的数据的value需要带上过期时间\",{\"1\":{\"1128\":1}}],[\"因为仅仅只需要加一把锁而已\",{\"1\":{\"1126\":1}}],[\"因为速度快\",{\"1\":{\"1114\":1}}],[\"因为第一个拦截器有了threadlocal的数据\",{\"1\":{\"1110\":1}}],[\"因为早期版本的客户端对象已经不再推荐使用\",{\"1\":{\"1071\":1}}],[\"因为搜索可以在所有的副本上并行运行\",{\"1\":{\"1067\":1}}],[\"因为有sql注入的风险\",{\"1\":{\"1230\":1}}],[\"因为有副本relicas的存在\",{\"1\":{\"1054\":1}}],[\"因为有冗余副本存储或者ec编码技术\",{\"1\":{\"883\":1}}],[\"因为key值一样\",{\"1\":{\"1034\":1}}],[\"因为消息队列是低延迟\",{\"1\":{\"1009\":1}}],[\"因为生成的\",{\"1\":{\"998\":1}}],[\"因为在启动时就完成所有初始化\",{\"1\":{\"1501\":1}}],[\"因为在mapper阶段已经完成了数据的关联操作\",{\"1\":{\"990\":1}}],[\"因为在第一个连接条件中使用了b中的key1列\",{\"1\":{\"326\":1}}],[\"因为分布式缓存只支持在yarn模式下运行\",{\"1\":{\"989\":1}}],[\"因为分隔符本身如果用于传输\",{\"1\":{\"709\":1}}],[\"因为最终的文件只有一个\",{\"1\":{\"979\":1}}],[\"因为mapreduce框中的shuffle过程要求对key必须能排序\",{\"1\":{\"956\":1}}],[\"因为hdfs中文件没有x执行权限的概念\",{\"1\":{\"919\":1}}],[\"因为hive只能控制元数据\",{\"1\":{\"296\":1}}],[\"因为实际数据存储在datanode中\",{\"1\":{\"903\":1}}],[\"因为namenode已经知道文件由哪些块组成\",{\"1\":{\"901\":1}}],[\"因为数据以管道的方式\",{\"1\":{\"898\":1}}],[\"因为数据页对应着索引树的节点\",{\"1\":{\"486\":1}}],[\"因为容器不是物理隔离的\",{\"1\":{\"847\":1}}],[\"因为客户端断开了\",{\"1\":{\"840\":1}}],[\"因为进行了数据的内存复制操作\",{\"1\":{\"779\":1}}],[\"因为进程在一段时间内可能只需要访问某几个特定的页面\",{\"1\":{\"186\":1}}],[\"因为底层都是同一块内存\",{\"1\":{\"776\":1}}],[\"因为节点3\",{\"1\":{\"766\":1}}],[\"因为只会把key写入数据库\",{\"1\":{\"986\":1}}],[\"因为只会将key对应的内容写入数据库\",{\"1\":{\"986\":1}}],[\"因为只有一个reducetask\",{\"1\":{\"965\":1}}],[\"因为只有一个\",{\"1\":{\"740\":1}}],[\"因为只要存在lastupdated缓存文件\",{\"1\":{\"101\":1}}],[\"因为是\",{\"1\":{\"740\":1}}],[\"因为是对于底层的操作\",{\"1\":{\"565\":1}}],[\"因为接收方的缓冲区大小是有限的\",{\"1\":{\"696\":1}}],[\"因为epoll内核中实现是根据每个fd上的callback函数来实现的\",{\"1\":{\"680\":1}}],[\"因为exists的实现\",{\"1\":{\"496\":1}}],[\"因为他们需要在读写事件就绪后自己负责进行读写\",{\"1\":{\"680\":1}}],[\"因为这个命令在key过多的情况下\",{\"1\":{\"1205\":1}}],[\"因为这个原因\",{\"1\":{\"1067\":1}}],[\"因为这里我们的程序中并没有手动使用任何线程池\",{\"1\":{\"1155\":1}}],[\"因为这里需要使用两个system\",{\"1\":{\"679\":1}}],[\"因为这样不仅优化了网络传输数据量\",{\"1\":{\"970\":1}}],[\"因为这部分内存不受\",{\"1\":{\"769\":1}}],[\"因为这些节点长度值小于\",{\"1\":{\"666\":1}}],[\"因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证\",{\"1\":{\"663\":1}}],[\"因为刚才的扩展空间\",{\"1\":{\"666\":1}}],[\"因为先前的对应位置已设置为\",{\"1\":{\"659\":1}}],[\"因为先执行distinct的时候\",{\"1\":{\"351\":1}}],[\"因为java不能直接操作unix\",{\"1\":{\"872\":1}}],[\"因为java的使用场景很多\",{\"1\":{\"638\":1}}],[\"因为jdk动态代理要求必须定义接口\",{\"1\":{\"60\":1}}],[\"因为随着硬件发展\",{\"1\":{\"637\":1}}],[\"因为线程和上下文切换的消耗\",{\"1\":{\"634\":1}}],[\"因为cpu需要不停的切换各个线程\",{\"1\":{\"625\":1}}],[\"因为cglib原理是动态生成被代理类的子类\",{\"1\":{\"61\":1}}],[\"因为它们有网络通信需求\",{\"1\":{\"791\":1}}],[\"因为它们较小且更具体\",{\"1\":{\"223\":1}}],[\"因为它有独立的读写指针\",{\"1\":{\"776\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"588\":1}}],[\"因为aqs中队列满足fifo的特性\",{\"1\":{\"588\":1}}],[\"因为子类只要实现这几个方法中的一部分就可以实现一个同步器了\",{\"1\":{\"585\":1}}],[\"因为当这个类初始化好了之后\",{\"1\":{\"1157\":1}}],[\"因为当threadlocal对象使用完之后\",{\"1\":{\"577\":1}}],[\"因为当p1进程想访问资源\",{\"1\":{\"169\":1}}],[\"因为volatile只能保证可见性并不能保证原子性\",{\"1\":{\"560\":1}}],[\"因为其他资源被别的线程所使用\",{\"1\":{\"551\":1}}],[\"因为一个线程需要等待另一个线程的执行结果\",{\"1\":{\"547\":1}}],[\"因为异常表中当在6\",{\"1\":{\"541\":1}}],[\"因为不用代理\",{\"1\":{\"1298\":1}}],[\"因为不会删除过期key\",{\"1\":{\"529\":1}}],[\"因为不能同时访问硬盘资源\",{\"1\":{\"155\":1}}],[\"因为where可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据\",{\"1\":{\"504\":1}}],[\"因为主键采用的索引是聚簇索引\",{\"1\":{\"497\":1}}],[\"因为\",{\"1\":{\"493\":1,\"648\":1,\"663\":1,\"666\":1,\"741\":2,\"755\":1,\"766\":1,\"775\":1,\"837\":1,\"841\":1,\"1152\":1,\"1176\":1}}],[\"因为每次调用时都会对连接进行线性遍历\",{\"1\":{\"680\":1}}],[\"因为每次修改的数据位置随机\",{\"1\":{\"506\":1}}],[\"因为每增加一张表就相当于增加了一次嵌套的循环\",{\"1\":{\"493\":1}}],[\"因为每个小文件会产生一条元数据信息\",{\"1\":{\"435\":1}}],[\"因为无法进行预发布\",{\"1\":{\"480\":1}}],[\"因为都是对id处理\",{\"1\":{\"452\":1}}],[\"因为如果你采用我刚说的方式\",{\"1\":{\"1155\":1}}],[\"因为如果锁的粒度太大\",{\"1\":{\"1137\":1}}],[\"因为如果有where子句的话\",{\"1\":{\"325\":1}}],[\"因为如果同类资源的数量大于1\",{\"1\":{\"175\":1}}],[\"因为from子句中的每个表都必须有一个名称\",{\"1\":{\"316\":1}}],[\"因为聚合函数的本质就是多进一出\",{\"1\":{\"306\":1}}],[\"因为就是基于该字段分组的\",{\"1\":{\"306\":1}}],[\"因为元数据信息没有删除\",{\"1\":{\"281\":1}}],[\"因为默认就是增加分区\",{\"1\":{\"281\":1}}],[\"因为可以先计算出在哪一个桶文件中\",{\"1\":{\"263\":1}}],[\"因为可能需要重新分配所有的编号\",{\"1\":{\"176\":1}}],[\"因为很多数据在内存中都是连续存放的\",{\"1\":{\"189\":1}}],[\"因为程序中存在着大量的循环\",{\"1\":{\"189\":1}}],[\"因为需要对换的速度\",{\"1\":{\"181\":1}}],[\"因为地址已经写死\",{\"1\":{\"179\":1}}],[\"因为开关中断只是相对一个处理机来说的\",{\"1\":{\"170\":1}}],[\"因为innodb支持事务\",{\"1\":{\"497\":1}}],[\"因为i\",{\"1\":{\"167\":1}}],[\"因为小尺度每个grid\",{\"1\":{\"138\":1}}],[\"因为成分对象的内部细节是新对象看不见的\",{\"1\":{\"77\":1}}],[\"因为继承会将父类的实现细节暴露给子类\",{\"1\":{\"77\":1}}],[\"因为抽象灵活性好\",{\"1\":{\"72\":1}}],[\"因为枚举类型是线程安全的\",{\"1\":{\"66\":1}}],[\"因此成员变量\",{\"1\":{\"1310\":1}}],[\"因此代理与目标之间是子父关系\",{\"1\":{\"1307\":1}}],[\"因此代理与目标之间是平级兄弟关系\",{\"1\":{\"1305\":1}}],[\"因此没有广泛流行\",{\"1\":{\"1298\":1}}],[\"因此要创建其中的\",{\"1\":{\"1285\":1}}],[\"因此很多资料还在讲解它较旧的实现\",{\"1\":{\"1245\":1}}],[\"因此出现错误\",{\"1\":{\"1230\":1}}],[\"因此springdataredis就提供了redistemplate的子类\",{\"1\":{\"1223\":1}}],[\"因此具备与hashset类似的特征\",{\"1\":{\"1210\":1}}],[\"因此具有可重入锁的特性\",{\"1\":{\"579\":1}}],[\"因此首先需要安装redis所需要的gcc依赖\",{\"1\":{\"1192\":1}}],[\"因此课程中我们会基于linux系统来安装redis\",{\"1\":{\"1191\":1}}],[\"因此最大上限是\",{\"1\":{\"1174\":1}}],[\"因此最佳置换算法是无法实现的\",{\"1\":{\"191\":1}}],[\"因此我们推荐大家使用jedis连接池代替jedis的直连方式\",{\"1\":{\"1214\":1}}],[\"因此我们后期会直接以springdataredis来学习\",{\"1\":{\"1212\":1}}],[\"因此我们需要提示其版本\",{\"1\":{\"1172\":1}}],[\"因此我们的笔记本电脑\",{\"1\":{\"4\":1}}],[\"因此采用timeline的模式\",{\"1\":{\"1166\":2}}],[\"因此才需要建立映射\",{\"1\":{\"1065\":1}}],[\"因此程序不需要进行reduce\",{\"1\":{\"990\":1}}],[\"因此程序没有了shuffle阶段和reduce阶段\",{\"1\":{\"990\":1}}],[\"因此为text和longwritable\",{\"1\":{\"961\":1}}],[\"因此为了提高网络利用率\",{\"1\":{\"694\":1}}],[\"因此为了补充损失的时间性能\",{\"1\":{\"683\":1}}],[\"因此keyout和valueout的数据类型分别为text和longwritable\",{\"1\":{\"959\":1}}],[\"因此仅需等待最小复制块即可成功返回\",{\"1\":{\"901\":1}}],[\"因此内存地址固定\",{\"1\":{\"855\":1}}],[\"因此又得从用户态切换至内核态\",{\"1\":{\"854\":1}}],[\"因此应当只在\",{\"1\":{\"844\":1}}],[\"因此需要通过\",{\"1\":{\"1196\":1}}],[\"因此需要追踪\",{\"1\":{\"843\":1}}],[\"因此需要设计大小可变的\",{\"1\":{\"841\":1}}],[\"因此需要为每个\",{\"1\":{\"841\":1}}],[\"因此需要将\",{\"1\":{\"840\":1}}],[\"因此需要采用扫描全表\",{\"1\":{\"497\":1}}],[\"因此不用担心赋值\",{\"1\":{\"1113\":1}}],[\"因此不适合长连接\",{\"1\":{\"826\":1}}],[\"因此不能采用传统的分页模式\",{\"1\":{\"1167\":1}}],[\"因此不能配合\",{\"1\":{\"831\":1}}],[\"因此不能追加\",{\"1\":{\"776\":1}}],[\"因此不能保存二进制数据\",{\"1\":{\"662\":1}}],[\"因此不能调用\",{\"1\":{\"574\":1}}],[\"因此无论读写\",{\"1\":{\"778\":1}}],[\"因此可以配置\",{\"1\":{\"1411\":1}}],[\"因此可以在任意目录下运行这些命令\",{\"1\":{\"1193\":1}}],[\"因此可以做如下优化\",{\"1\":{\"755\":1}}],[\"因此可以省略\",{\"1\":{\"113\":1}}],[\"因此执行到\",{\"1\":{\"753\":1}}],[\"因此包含了线程池中所有的方法\",{\"1\":{\"746\":1}}],[\"因此会触发多次\",{\"1\":{\"744\":1}}],[\"因此会产生饥饿现象\",{\"1\":{\"169\":1}}],[\"因此下面的\",{\"1\":{\"741\":1}}],[\"因此策略就可以定为\",{\"1\":{\"707\":1}}],[\"因此以太网\",{\"1\":{\"694\":1}}],[\"因此效率要比lt模式高\",{\"1\":{\"680\":1}}],[\"因此随着监视的文件描述符数量的增长\",{\"1\":{\"680\":1}}],[\"因此连锁更新一旦发生\",{\"1\":{\"667\":1}}],[\"因此原本\",{\"1\":{\"666\":1}}],[\"因此压缩列表不适合保存过多的元素\",{\"1\":{\"665\":1}}],[\"因此一般来说\",{\"1\":{\"630\":1}}],[\"因此一般只适用于易保存和恢复状态的资源\",{\"1\":{\"176\":1}}],[\"因此使用了一个原子布尔对象\",{\"1\":{\"741\":1}}],[\"因此使用单个线程可以监听多个客户端通道\",{\"1\":{\"612\":1}}],[\"因此使用sum\",{\"1\":{\"482\":1}}],[\"因此thread\",{\"1\":{\"591\":1}}],[\"因此也称之为非关系型数据库\",{\"1\":{\"1184\":1}}],[\"因此也是具有幂等性的\",{\"1\":{\"1004\":1}}],[\"因此也无需超时时间\",{\"1\":{\"574\":1}}],[\"因此也就不会发生两个同时访问临界区的情况\",{\"1\":{\"170\":1}}],[\"因此也就不会对原有功能引入风险\",{\"1\":{\"15\":1}}],[\"因此减少了\",{\"1\":{\"564\":1}}],[\"因此你可以有多个线程同时对一张表增删改查\",{\"1\":{\"510\":1}}],[\"因此在每个partition中数据是相对有序的\",{\"1\":{\"1035\":1}}],[\"因此在实际的网络环境中\",{\"1\":{\"680\":1}}],[\"因此在锁定数据较多的情况下使用表锁可以节省大量资源\",{\"1\":{\"506\":1}}],[\"因此在用户程序中\",{\"1\":{\"158\":1}}],[\"因此读写不冲突\",{\"1\":{\"503\":1}}],[\"因此当我们使用\",{\"1\":{\"493\":1}}],[\"因此其内部节点相对b树更小\",{\"1\":{\"488\":1}}],[\"因此其使用范围受到一定的限制\",{\"1\":{\"15\":1}}],[\"因此被转换为1个mr作业来执行\",{\"1\":{\"326\":2}}],[\"因此这也带来了更好的可管理性\",{\"1\":{\"244\":1}}],[\"因此这些属性变化时需要修改相应的目录项\",{\"1\":{\"196\":1}}],[\"因此这些碎片不能满足进程的需求\",{\"1\":{\"182\":1}}],[\"因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序\",{\"1\":{\"210\":1}}],[\"因此操作系统也无法优化延迟时间和传输时间\",{\"1\":{\"204\":1}}],[\"因此b字节的数据需要b\",{\"1\":{\"204\":1}}],[\"因此乘21​\",{\"1\":{\"204\":1}}],[\"因此300号块的数据需要复制到超级块中\",{\"1\":{\"198\":1}}],[\"因此文件的访问效率更高\",{\"1\":{\"197\":1}}],[\"因此文件区空间的管理采用离散分配方式\",{\"1\":{\"181\":1}}],[\"因此索引表可能会很大\",{\"1\":{\"195\":1}}],[\"因此i\",{\"1\":{\"192\":1}}],[\"因此经过第三轮\",{\"1\":{\"191\":1}}],[\"因此页面置换算法应该追求更少的缺页率\",{\"1\":{\"191\":1}}],[\"因此属于内中断\",{\"1\":{\"190\":1}}],[\"因此只有一个reducer\",{\"1\":{\"314\":1}}],[\"因此只有少量作业能运行\",{\"1\":{\"189\":1}}],[\"因此只有内核级线程才是处理机分配的单位\",{\"1\":{\"163\":1}}],[\"因此系统分区的大小和数目是可变的\",{\"1\":{\"182\":1}}],[\"因此装入到内存中的地址依旧是逻辑地址\",{\"1\":{\"179\":1}}],[\"因此该机制遵循了让权等待\",{\"1\":{\"171\":1}}],[\"因此新进程会抢占处理机\",{\"1\":{\"167\":1}}],[\"因此时间片不能太大\",{\"1\":{\"167\":1}}],[\"因此时间片rr属于抢占式算法\",{\"1\":{\"167\":1}}],[\"因此有一定的开销\",{\"1\":{\"167\":1}}],[\"因此过于频繁的进行进程调度\",{\"1\":{\"165\":1}}],[\"因此线程管理成本高\",{\"1\":{\"163\":1}}],[\"因此线程调度\",{\"1\":{\"163\":1}}],[\"因此各进程拥有的内存地址空间相互独立\",{\"1\":{\"162\":1}}],[\"因此cpu要从用户态转为核心态\",{\"1\":{\"157\":1}}],[\"因此\",{\"1\":{\"15\":1,\"45\":1,\"189\":1,\"191\":1,\"325\":1,\"326\":1,\"480\":1,\"485\":1,\"662\":2,\"663\":1,\"664\":1,\"667\":1,\"709\":1,\"740\":1,\"753\":1,\"854\":1,\"875\":2,\"949\":1,\"959\":1,\"1120\":1,\"1284\":1,\"1294\":1,\"1411\":1,\"1480\":1}}],[\"很有可能因为网络\",{\"1\":{\"1003\":1}}],[\"很久很久以前\",{\"1\":{\"709\":1}}],[\"很明显\",{\"1\":{\"662\":1}}],[\"很明显cbo引擎更加智能\",{\"1\":{\"457\":1}}],[\"很多起步依赖的命名都暗示了它们提供的某种或某类功能\",{\"1\":{\"1521\":1}}],[\"很多地方都有\",{\"1\":{\"1214\":1}}],[\"很多地方体现零拷贝\",{\"1\":{\"781\":1}}],[\"很多人关注他\",{\"1\":{\"1166\":1}}],[\"很多的一些软件都提供了jmx接口\",{\"1\":{\"1045\":1}}],[\"很多的stage之间是没有依赖关系的\",{\"1\":{\"446\":1}}],[\"很多时候消息队列不是一个永久性的存储\",{\"1\":{\"1008\":1}}],[\"很多时候major\",{\"1\":{\"628\":1}}],[\"很多业务中多有多个状态\",{\"1\":{\"1005\":1}}],[\"很可能在值比较时\",{\"1\":{\"480\":1}}],[\"很频繁\",{\"1\":{\"209\":1}}],[\"很方便实现信息的共享和保护\",{\"1\":{\"188\":1}}],[\"很显然如果实现safetydoor接口就违背了接口隔离原则\",{\"1\":{\"75\":1}}],[\"很显然jdk代理是无法使用了\",{\"1\":{\"60\":1}}],[\"很容易发生类爆炸情况\",{\"1\":{\"39\":1}}],[\"执行aftercompletion方法\",{\"1\":{\"1532\":1}}],[\"执行视图解析和视图渲染\",{\"1\":{\"1532\":1}}],[\"执行posthandler方法\",{\"1\":{\"1532\":1}}],[\"执行prehandle方法\",{\"1\":{\"1532\":1}}],[\"执行处理器逻辑\",{\"1\":{\"1532\":1}}],[\"执行环绕通知1\",{\"1\":{\"1340\":1}}],[\"执行环绕通知2\",{\"1\":{\"1340\":1}}],[\"执行目标方法\",{\"1\":{\"1340\":1}}],[\"执行下面的命令\",{\"1\":{\"1197\":1}}],[\"执行lua脚本\",{\"1\":{\"1157\":1}}],[\"执行业务\",{\"1\":{\"1150\":1}}],[\"执行完一个分线程就减少一个变量\",{\"1\":{\"1132\":1}}],[\"执行完每个指令之后\",{\"1\":{\"157\":1}}],[\"执行一些其他动作\",{\"1\":{\"1025\":1}}],[\"执行一个特权指令\",{\"1\":{\"157\":1}}],[\"执行溢写过程\",{\"1\":{\"979\":1}}],[\"执行用户重写的map函数\",{\"1\":{\"979\":1}}],[\"执行权限\",{\"0\":{\"918\":1},\"1\":{\"918\":1}}],[\"执行块的创建\",{\"1\":{\"903\":1}}],[\"执行复制的mapreduce只有mapper阶段\",{\"1\":{\"869\":1}}],[\"执行计算\",{\"1\":{\"757\":1,\"758\":1}}],[\"执行到\",{\"1\":{\"753\":4}}],[\"执行中如何换人\",{\"0\":{\"749\":1}}],[\"执行后就是\",{\"1\":{\"743\":1}}],[\"执行前增强\",{\"1\":{\"1340\":2}}],[\"执行前\",{\"1\":{\"743\":1}}],[\"执行前需要将该程序放到内存中\",{\"1\":{\"154\":1}}],[\"执行端口绑定\",{\"1\":{\"740\":1}}],[\"执行初始化器\",{\"1\":{\"743\":1}}],[\"执行初始化\",{\"1\":{\"740\":1}}],[\"执行初始化和注册\",{\"1\":{\"740\":1}}],[\"执行内核态代码\",{\"1\":{\"676\":1}}],[\"执行垃圾收集时\",{\"1\":{\"637\":1}}],[\"执行init方法\",{\"1\":{\"630\":1}}],[\"执行init方法进行初始化\",{\"1\":{\"630\":1}}],[\"执行实例化代码块\",{\"1\":{\"630\":1}}],[\"执行sql时\",{\"1\":{\"483\":1}}],[\"执行结果相同\",{\"1\":{\"325\":1}}],[\"执行结束就是delta文件夹\",{\"1\":{\"292\":1}}],[\"执行外部查询\",{\"1\":{\"317\":1}}],[\"执行子查询\",{\"1\":{\"317\":1}}],[\"执行顺序为\",{\"1\":{\"1289\":1}}],[\"执行顺序\",{\"0\":{\"310\":1}}],[\"执行动态分区插入操作\",{\"1\":{\"289\":1}}],[\"执行动态分区插值\",{\"1\":{\"261\":1}}],[\"执行引擎\",{\"1\":{\"232\":1}}],[\"执行器\",{\"1\":{\"232\":1}}],[\"执行两个操作\",{\"1\":{\"172\":1}}],[\"执行只能一气呵成\",{\"1\":{\"171\":1}}],[\"执行过程中不允许中断\",{\"1\":{\"170\":1}}],[\"执行的方法\",{\"1\":{\"1505\":1}}],[\"执行的最基本命令\",{\"1\":{\"156\":1}}],[\"执行的是代理类\",{\"1\":{\"59\":1}}],[\"执行测试源码\",{\"1\":{\"95\":1}}],[\"执行\",{\"0\":{\"575\":1},\"1\":{\"69\":1,\"477\":1,\"740\":2,\"743\":1,\"784\":1,\"785\":1,\"1146\":1,\"1285\":1,\"1444\":2}}],[\"执行流程如下\",{\"1\":{\"59\":1}}],[\"执行真实对象\",{\"1\":{\"59\":1}}],[\"程序只需要和\",{\"1\":{\"1499\":1}}],[\"程序中\",{\"1\":{\"1290\":1}}],[\"程序中使用的绝对地址\",{\"1\":{\"179\":1}}],[\"程序不易崩溃\",{\"1\":{\"1140\":1}}],[\"程序不会对其中的数据做任何限制\",{\"1\":{\"663\":1}}],[\"程序退出\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"程序所需要的运算资源是yarn分配还是本机系统自己分配\",{\"1\":{\"963\":1}}],[\"程序在运行时\",{\"1\":{\"688\":1}}],[\"程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区\",{\"1\":{\"685\":1}}],[\"程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区\",{\"1\":{\"685\":1}}],[\"程序内部并不会判断缓冲区大小是否足够用\",{\"1\":{\"663\":1}}],[\"程序较为简单容易实现\",{\"1\":{\"612\":1}}],[\"程序切换到哪个channel是由\",{\"1\":{\"610\":1}}],[\"程序的用户态切换至内核态\",{\"1\":{\"854\":1,\"855\":2}}],[\"程序的工作线程被暂停的时间\",{\"1\":{\"637\":1}}],[\"程序的运行时间a\",{\"1\":{\"637\":1}}],[\"程序的原子性是指整个程序中的所有操作\",{\"1\":{\"556\":1}}],[\"程序的可移植性降低\",{\"1\":{\"73\":1}}],[\"程序会先加载365gb的数据\",{\"1\":{\"414\":1}}],[\"程序打成jar包\",{\"1\":{\"344\":1}}],[\"程序直接控制方式\",{\"1\":{\"209\":1}}],[\"程序按照自身的逻辑关系划分为若干个段\",{\"1\":{\"187\":1}}],[\"程序执行前需要先放到内存中才能被cpu处理\",{\"1\":{\"179\":1}}],[\"程序运行时产生的数据存储的位置\",{\"1\":{\"159\":1}}],[\"程序运行过程中动态生成的代理类\",{\"1\":{\"59\":1}}],[\"程序代码存放的位置\",{\"1\":{\"159\":1}}],[\"程序段和数据段组成的\",{\"1\":{\"159\":1}}],[\"程序段\",{\"1\":{\"159\":2}}],[\"程序\",{\"1\":{\"159\":1}}],[\"程序计数器\",{\"1\":{\"157\":1,\"165\":1}}],[\"程序接口\",{\"1\":{\"154\":1}}],[\"程序员可以将消息放入到队列中\",{\"1\":{\"1008\":1}}],[\"程序员一般只能和逻辑地址打交道\",{\"1\":{\"684\":1}}],[\"程序员编程时需要显示的给出段号\",{\"1\":{\"188\":1}}],[\"程序员常常会遇到这种情况\",{\"1\":{\"83\":1}}],[\"程序员要尽量根据6条原则来开发程序\",{\"1\":{\"71\":1}}],[\"程序媛教你一看就懂的适配器设计模式\",{\"1\":{\"3\":1}}],[\"下单\",{\"1\":{\"1156\":1}}],[\"下单是两个线程\",{\"1\":{\"1155\":1}}],[\"下单核心逻辑分析\",{\"1\":{\"1134\":1}}],[\"下单核心思路\",{\"1\":{\"1134\":1}}],[\"下单时需要判断两点\",{\"1\":{\"1134\":1}}],[\"下的所有\",{\"1\":{\"1038\":1}}],[\"下所有的\",{\"1\":{\"1037\":1}}],[\"下述场景禁止使用combiner\",{\"1\":{\"970\":1}}],[\"下来\",{\"1\":{\"719\":1}}],[\"下雨天\",{\"1\":{\"709\":1}}],[\"下雨天留客\",{\"1\":{\"709\":1}}],[\"下雨天留客天留我不留\",{\"1\":{\"709\":1}}],[\"下次查询时\",{\"1\":{\"1168\":1}}],[\"下次用户过来访问这个不存在的数据\",{\"1\":{\"1123\":1}}],[\"下次循环就会\",{\"1\":{\"742\":1}}],[\"下次循环计数重置\",{\"1\":{\"593\":1}}],[\"下次调用epoll\",{\"1\":{\"680\":1}}],[\"下次在操作\",{\"1\":{\"663\":1}}],[\"下一个\",{\"1\":{\"749\":1}}],[\"下一个要被读或者写的索引\",{\"1\":{\"610\":1}}],[\"下一步就是设置几个参数\",{\"1\":{\"60\":1}}],[\"下列a\",{\"1\":{\"325\":1}}],[\"下图对应的是\",{\"1\":{\"1499\":1}}],[\"下图表示写入了\",{\"1\":{\"798\":1}}],[\"下图就是\",{\"1\":{\"663\":1}}],[\"下图就是字符串\",{\"1\":{\"662\":1}}],[\"下图显示了\",{\"1\":{\"662\":1}}],[\"下图是旧的hash表\",{\"1\":{\"579\":1}}],[\"下图描述的是不同锁状态下mark\",{\"1\":{\"540\":1}}],[\"下图runnable中的阻塞状态应该去除\",{\"1\":{\"538\":1}}],[\"下图中\",{\"1\":{\"292\":1}}],[\"下图所示横轴是产品等级\",{\"1\":{\"36\":1}}],[\"下\",{\"1\":{\"243\":1,\"244\":1,\"833\":1}}],[\"下限地址\",{\"1\":{\"180\":1}}],[\"下限寄存器\",{\"1\":{\"180\":1}}],[\"下载的依赖项与实际需要的不一致\",{\"1\":{\"101\":1}}],[\"下载依赖时出现网络故障或仓库服务器宕机等原因\",{\"1\":{\"101\":1}}],[\"下添加jdk编译版本\",{\"1\":{\"92\":1}}],[\"下添加中央仓库镜像\",{\"1\":{\"92\":1}}],[\"下锅的酱料是蒜蓉\",{\"1\":{\"85\":1}}],[\"下锅的酱料是辣椒\",{\"1\":{\"85\":1}}],[\"下锅的蔬菜是菜心\",{\"1\":{\"85\":1}}],[\"下锅的蔬菜是包菜\",{\"1\":{\"85\":1}}],[\"下面方法如果在俩个操作之间服务宕机了\",{\"1\":{\"1141\":1}}],[\"下面的\",{\"1\":{\"741\":1,\"1151\":1}}],[\"下面一种协议较为常用\",{\"1\":{\"709\":1}}],[\"下面我们再一起学习下几个需要子类实现的方法\",{\"1\":{\"585\":1}}],[\"下面两点只是纯理论说法\",{\"1\":{\"576\":1}}],[\"下面才是真正的创建新的string对象\",{\"1\":{\"566\":1}}],[\"下面\",{\"1\":{\"107\":1}}],[\"下面看一个例子来理解合成复用原则\",{\"1\":{\"77\":1}}],[\"下面看一个例子来理解迪米特法则\",{\"1\":{\"76\":1}}],[\"下面看一个例子来理解接口隔离原则\",{\"1\":{\"75\":1}}],[\"下面看一个例子来理解依赖倒转原则\",{\"1\":{\"74\":1}}],[\"下面以\",{\"1\":{\"72\":1}}],[\"下面是为了解决序列化反序列化破解单例模式\",{\"1\":{\"69\":1}}],[\"下面是摘取的重点代码\",{\"1\":{\"59\":1}}],[\"诊断工具\",{\"1\":{\"59\":1}}],[\"接着同一时间去访问数据库\",{\"1\":{\"1126\":1}}],[\"接着需要将全局的offset转换成segment的局部offset\",{\"1\":{\"1052\":1}}],[\"接着发送下一条\",{\"1\":{\"1043\":2}}],[\"接着切换到应用程序线程\",{\"1\":{\"634\":1}}],[\"接着在堆中划分一块内存给新对象\",{\"1\":{\"630\":1}}],[\"接着统计每个小文件中出现频数最高的100个词\",{\"1\":{\"477\":1}}],[\"接下来勾选\",{\"1\":{\"1441\":1}}],[\"接下来会\",{\"1\":{\"1438\":1}}],[\"接下来会有一个条件分支\",{\"1\":{\"1152\":1}}],[\"接下来41位存储毫秒级时间戳\",{\"1\":{\"998\":1}}],[\"接下来要向网卡写数据\",{\"1\":{\"854\":1}}],[\"接下来服务器端输出\",{\"1\":{\"848\":1}}],[\"接下来的处理也移交至\",{\"1\":{\"743\":1}}],[\"接下来我们来看看共同关注如何实现\",{\"1\":{\"1165\":1}}],[\"接下来我们来回一下我们释放锁的逻辑\",{\"1\":{\"1146\":1}}],[\"接下来我们一起分析一下当前的这个\",{\"1\":{\"1151\":1}}],[\"接下来我们一起看看\",{\"1\":{\"662\":1}}],[\"接下来我们再来看下粘性分配策略\",{\"1\":{\"1042\":1}}],[\"接下来我们使用动态代理实现上面案例\",{\"1\":{\"59\":1}}],[\"接下来thread\",{\"1\":{\"591\":1}}],[\"接下来看另外一种解法\",{\"1\":{\"477\":1}}],[\"接收用户的作业提交\",{\"1\":{\"944\":1}}],[\"接收缓冲区\",{\"1\":{\"850\":1}}],[\"接收缓冲区大小\",{\"1\":{\"731\":1}}],[\"接收客户端发送的数据\",{\"1\":{\"826\":1,\"827\":1}}],[\"接收结果的线程\",{\"1\":{\"759\":1}}],[\"接收结果\",{\"1\":{\"737\":1,\"758\":1}}],[\"接收到处理后的数据\",{\"1\":{\"718\":1}}],[\"接收到数据之后会自动将数据绑定到java对象上去\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"接收到数据\",{\"1\":{\"717\":1}}],[\"接收到一个数据\",{\"1\":{\"717\":1,\"718\":1}}],[\"接收响应消息\",{\"1\":{\"702\":1}}],[\"接收方发给发送方的一种传输类控制字符\",{\"1\":{\"899\":1}}],[\"接收方也会维护一个窗口\",{\"1\":{\"694\":1}}],[\"接收方\",{\"1\":{\"694\":2}}],[\"接收一个collector接口的实现\",{\"1\":{\"621\":1}}],[\"接收一个的函数作为参数\",{\"1\":{\"617\":1}}],[\"接收一个函数作为参数\",{\"1\":{\"617\":1}}],[\"接收lambda\",{\"1\":{\"617\":1}}],[\"接收\",{\"1\":{\"616\":1,\"694\":2}}],[\"接收新任务\",{\"1\":{\"571\":1}}],[\"接收消息\",{\"1\":{\"162\":1}}],[\"接收调度的基本单位\",{\"1\":{\"159\":1}}],[\"接口回调\",{\"1\":{\"1472\":1}}],[\"接口只是作为\",{\"1\":{\"1455\":1}}],[\"接口就可以被管理呢\",{\"1\":{\"1455\":1}}],[\"接口时为何要提供\",{\"1\":{\"1366\":1}}],[\"接口来进行初始化\",{\"1\":{\"1289\":1}}],[\"接口及\",{\"0\":{\"1282\":1}}],[\"接口被\",{\"1\":{\"1280\":1}}],[\"接口与加了\",{\"1\":{\"1260\":1}}],[\"接口的销毁方法\",{\"1\":{\"1289\":1}}],[\"接口的初始化方法\",{\"1\":{\"1289\":1}}],[\"接口的优先级最高\",{\"1\":{\"1260\":1}}],[\"接口的实现\",{\"1\":{\"1245\":1}}],[\"接口的功能\",{\"1\":{\"1240\":1}}],[\"接口的驱动\",{\"1\":{\"100\":1}}],[\"接口提供了一种\",{\"1\":{\"1284\":2}}],[\"接口提供两个方法write和readfields\",{\"1\":{\"956\":1}}],[\"接口提供遍历\",{\"1\":{\"746\":1}}],[\"接口中声明抽象方法\",{\"1\":{\"614\":1}}],[\"接口中的成员变量只能是public\",{\"1\":{\"595\":1}}],[\"接口主要用于对类的行为进行约束\",{\"1\":{\"595\":1}}],[\"接口和抽象类有什么共同点和区别\",{\"0\":{\"595\":1}}],[\"接口即可\",{\"1\":{\"100\":1}}],[\"接口隔离原则\",{\"0\":{\"75\":1}}],[\"接口是上面的类图中的抽象原型类\",{\"1\":{\"51\":1}}],[\"接口类图如下\",{\"1\":{\"50\":1}}],[\"接口\",{\"0\":{\"1278\":1,\"1281\":1,\"1282\":1},\"1\":{\"5\":1,\"13\":1,\"75\":3,\"574\":1,\"723\":1,\"775\":1,\"1240\":2,\"1252\":1,\"1270\":1,\"1322\":2,\"1366\":1,\"1421\":1,\"1425\":1,\"1437\":2,\"1455\":1,\"1466\":1,\"1493\":1}}],[\"坐车到火车站\",{\"1\":{\"58\":1}}],[\"控制有哪些错误信息\",{\"1\":{\"1416\":1}}],[\"控制器\",{\"1\":{\"1528\":1}}],[\"控制器方法返回值\",{\"1\":{\"1441\":1}}],[\"控制器方法会被封装为\",{\"1\":{\"1438\":1}}],[\"控制器方法执行流程\",{\"0\":{\"1383\":1}}],[\"控制器方法调用时\",{\"1\":{\"1382\":1,\"1390\":1}}],[\"控制器方法被封装为\",{\"1\":{\"1362\":1}}],[\"控制器私有范围\",{\"1\":{\"1376\":1}}],[\"控制器对象\",{\"1\":{\"1355\":1}}],[\"控制锁粒度\",{\"1\":{\"1137\":1}}],[\"控制那些字段序列化出去\",{\"1\":{\"972\":1}}],[\"控制\",{\"1\":{\"731\":1}}],[\"控制在1000个之内\",{\"1\":{\"482\":1}}],[\"控制寄存器\",{\"1\":{\"208\":1}}],[\"控制对一个对象的访问\",{\"1\":{\"63\":1}}],[\"控制或扩展真实主题的功能\",{\"1\":{\"57\":1}}],[\"控制调用先后次序\",{\"1\":{\"14\":1}}],[\"真正执行转换\",{\"1\":{\"1370\":1}}],[\"真正执行connect是nioeventloopgroup中的线程\",{\"1\":{\"753\":1}}],[\"真个是不亦乐乎\",{\"1\":{\"709\":1}}],[\"真实项目中\",{\"1\":{\"1473\":1}}],[\"真实对象中的方法的method实例\",{\"1\":{\"60\":1}}],[\"真实对象所实现的接口\",{\"1\":{\"59\":1}}],[\"真实主题\",{\"1\":{\"57\":1}}],[\"真皮车座\",{\"1\":{\"14\":1}}],[\"真皮等材质\",{\"1\":{\"14\":1}}],[\"访问加密区域秘钥\",{\"1\":{\"933\":1}}],[\"访问服务的client\",{\"1\":{\"923\":1}}],[\"访问内存的有效时间为\",{\"1\":{\"683\":1}}],[\"访问内存的有效时间\",{\"1\":{\"683\":1}}],[\"访问次数最少\",{\"1\":{\"522\":1}}],[\"访问页面\",{\"1\":{\"359\":1}}],[\"访问页目录表\",{\"1\":{\"186\":1}}],[\"访问时间\",{\"1\":{\"359\":1}}],[\"访问控制列表\",{\"1\":{\"925\":1}}],[\"访问控制\",{\"1\":{\"201\":1}}],[\"访问位\",{\"1\":{\"191\":1}}],[\"访问目标单元\",{\"1\":{\"186\":1}}],[\"访问二级页表\",{\"1\":{\"186\":1}}],[\"访问速度比内存快很多的高速缓冲存储器\",{\"1\":{\"185\":1}}],[\"访问临界资源的那段代码\",{\"1\":{\"168\":1}}],[\"访问对象不适合或者不能直接引用目标对象\",{\"1\":{\"56\":1}}],[\"访问类\",{\"1\":{\"50\":1,\"65\":1}}],[\"uglide\",{\"1\":{\"1200\":1}}],[\"ugo相关命令\",{\"0\":{\"920\":1}}],[\"ugo权限管理\",{\"0\":{\"917\":1}}],[\"u14\",{\"1\":{\"1176\":1}}],[\"u+x\",{\"1\":{\"920\":1}}],[\"umask\",{\"1\":{\"919\":2}}],[\"umask权限掩码\",{\"0\":{\"919\":1}}],[\"ui界面访问或者hadoop\",{\"1\":{\"928\":1}}],[\"ui的目录页面手动输入\",{\"1\":{\"914\":1}}],[\"ui页面直接查看快照信息\",{\"1\":{\"914\":1}}],[\"uint32\",{\"1\":{\"663\":3}}],[\"uint16\",{\"1\":{\"663\":3}}],[\"u\",{\"1\":{\"746\":1,\"808\":1,\"920\":1,\"1113\":1,\"1176\":1,\"1196\":2}}],[\"ulimit\",{\"0\":{\"727\":1}}],[\"ultralytics\",{\"1\":{\"146\":1}}],[\"ultralytics公司\",{\"1\":{\"146\":1}}],[\"utc\",{\"1\":{\"1132\":1}}],[\"util\",{\"1\":{\"578\":1,\"603\":1,\"648\":2,\"741\":2,\"744\":1,\"756\":1,\"762\":5,\"765\":16,\"775\":1,\"999\":2}}],[\"utf\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"723\":2,\"805\":3,\"848\":1,\"1219\":1,\"1244\":1,\"1462\":1}}],[\"uuid的数据量相对有些大\",{\"1\":{\"1005\":1}}],[\"uuid的特点\",{\"1\":{\"502\":1}}],[\"uuid如下图所示\",{\"1\":{\"502\":1}}],[\"uuid\",{\"1\":{\"494\":1,\"997\":2,\"1107\":1,\"1144\":1}}],[\"uk即unique\",{\"1\":{\"480\":1}}],[\"uv统计数量\",{\"1\":{\"1180\":1}}],[\"uv统计\",{\"0\":{\"1180\":1}}],[\"uv统计在服务端做会比较麻烦\",{\"1\":{\"1179\":1}}],[\"uv\",{\"0\":{\"1178\":1,\"1179\":1},\"1\":{\"355\":1,\"1179\":1}}],[\"ucase\",{\"1\":{\"336\":3}}],[\"uploadimage\",{\"1\":{\"1159\":1}}],[\"uploadcontroller\",{\"1\":{\"1159\":1}}],[\"upload\",{\"1\":{\"1100\":1,\"1159\":3}}],[\"up\",{\"1\":{\"799\":1,\"1525\":1,\"1526\":1,\"1531\":1}}],[\"upper\",{\"1\":{\"336\":3}}],[\"updatebyid\",{\"1\":{\"1122\":1}}],[\"updatesave\",{\"1\":{\"1089\":1}}],[\"updateresponse\",{\"1\":{\"1073\":1}}],[\"updaterequest\",{\"1\":{\"1073\":2}}],[\"updatelastexecutiontime\",{\"1\":{\"741\":1}}],[\"updateandget\",{\"1\":{\"562\":1}}],[\"update特性\",{\"1\":{\"292\":1,\"293\":1}}],[\"update语句采用了split\",{\"1\":{\"292\":1}}],[\"update\",{\"0\":{\"299\":1},\"1\":{\"47\":4,\"268\":1,\"270\":1,\"293\":1,\"298\":2,\"408\":1,\"409\":2,\"493\":2,\"673\":1,\"869\":1,\"1073\":1,\"1122\":1,\"1134\":2,\"1135\":2,\"1136\":4,\"1137\":6,\"1152\":1,\"1157\":2,\"1161\":6,\"1162\":4}}],[\"udpclient\",{\"1\":{\"848\":1}}],[\"udpserver\",{\"1\":{\"848\":1}}],[\"udp\",{\"0\":{\"848\":1},\"1\":{\"848\":1}}],[\"udtf函数的调用方式\",{\"1\":{\"378\":1}}],[\"udtf函数对于很多场景下有使用限制\",{\"1\":{\"378\":1}}],[\"udtf之explode函数\",{\"0\":{\"346\":1}}],[\"udtf三类\",{\"1\":{\"334\":1}}],[\"udtf\",{\"1\":{\"334\":1}}],[\"udaf之聚合函数\",{\"0\":{\"350\":1}}],[\"udaf\",{\"1\":{\"334\":2}}],[\"udf实现手机号加密\",{\"0\":{\"344\":1}}],[\"udf分类标准可以扩大到hive的所有函数中\",{\"1\":{\"334\":1}}],[\"udf\",{\"1\":{\"334\":2,\"344\":2}}],[\"ufd\",{\"1\":{\"196\":1}}],[\"usr\",{\"1\":{\"876\":4,\"1193\":2,\"1196\":2,\"1197\":2}}],[\"us\",{\"1\":{\"280\":6}}],[\"usage\",{\"1\":{\"869\":1}}],[\"usa\",{\"1\":{\"265\":1,\"266\":4,\"271\":12,\"302\":4,\"303\":5,\"307\":3,\"310\":1,\"369\":2}}],[\"using\",{\"1\":{\"117\":1,\"457\":1,\"481\":1,\"646\":1,\"669\":1,\"1164\":1,\"1174\":1}}],[\"usessl=false\",{\"1\":{\"1236\":1}}],[\"usesingleserver\",{\"1\":{\"1150\":1}}],[\"useunicode=true\",{\"1\":{\"986\":1,\"1046\":1}}],[\"usecontainersupport\",{\"1\":{\"847\":1}}],[\"used\",{\"1\":{\"271\":1,\"522\":4,\"874\":2}}],[\"userregisterrequest对象\",{\"1\":{\"1525\":1}}],[\"userregisterrequest\",{\"1\":{\"1525\":4,\"1526\":4,\"1531\":4}}],[\"user>\",{\"1\":{\"1236\":1}}],[\"user进行拼接\",{\"1\":{\"1232\":1}}],[\"user表\",{\"1\":{\"1230\":1}}],[\"user表的路径为\",{\"1\":{\"235\":1}}],[\"user4\",{\"1\":{\"1208\":1}}],[\"user相关的key\",{\"1\":{\"1207\":1}}],[\"usercontroller\",{\"1\":{\"1165\":1,\"1175\":1,\"1176\":1}}],[\"usermapper\",{\"1\":{\"1230\":1,\"1234\":1}}],[\"usermap\",{\"1\":{\"1107\":2,\"1111\":3}}],[\"userdtos\",{\"1\":{\"1162\":2,\"1165\":2}}],[\"userdto\",{\"1\":{\"1101\":4,\"1107\":4,\"1111\":4,\"1159\":1,\"1161\":1,\"1162\":2,\"1165\":5,\"1167\":1}}],[\"userholder\",{\"1\":{\"1100\":1,\"1101\":2,\"1111\":3,\"1134\":1,\"1137\":4,\"1142\":1,\"1150\":1,\"1156\":1,\"1157\":1,\"1159\":1,\"1161\":2,\"1162\":2,\"1164\":2,\"1165\":2,\"1167\":1,\"1168\":1,\"1175\":1,\"1176\":1}}],[\"user3\",{\"1\":{\"1073\":2}}],[\"user2\",{\"1\":{\"1073\":2}}],[\"user1\",{\"1\":{\"1073\":2,\"1223\":3}}],[\"userjson\",{\"1\":{\"1073\":2}}],[\"user代理用户\",{\"0\":{\"927\":1}}],[\"usereventtriggered\",{\"1\":{\"707\":2}}],[\"username=root\",{\"1\":{\"1046\":2}}],[\"username\",{\"1\":{\"701\":6,\"702\":10,\"703\":3,\"909\":2,\"1230\":3,\"1236\":2,\"1525\":2}}],[\"userid的过滤可以走bloom\",{\"1\":{\"437\":1}}],[\"userid\",{\"1\":{\"400\":9,\"402\":3,\"407\":1,\"408\":1,\"409\":6,\"423\":1,\"437\":2,\"458\":2,\"1134\":2,\"1137\":15,\"1142\":3,\"1150\":4,\"1155\":1,\"1156\":7,\"1157\":7,\"1161\":6,\"1162\":6,\"1164\":3,\"1165\":8,\"1167\":2,\"1168\":2,\"1175\":2,\"1176\":2,\"1230\":3}}],[\"userinfo\",{\"1\":{\"272\":3}}],[\"user|role\",{\"1\":{\"278\":1}}],[\"user\",{\"0\":{\"114\":1},\"1\":{\"92\":1,\"234\":2,\"235\":2,\"236\":2,\"237\":5,\"254\":1,\"262\":7,\"266\":1,\"272\":1,\"278\":1,\"280\":7,\"281\":5,\"285\":1,\"334\":4,\"343\":2,\"423\":5,\"501\":1,\"821\":1,\"909\":2,\"917\":1,\"920\":5,\"926\":3,\"936\":1,\"1072\":3,\"1073\":17,\"1075\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1099\":6,\"1100\":7,\"1101\":5,\"1107\":8,\"1111\":2,\"1113\":1,\"1137\":3,\"1157\":1,\"1159\":2,\"1160\":4,\"1161\":3,\"1162\":5,\"1164\":1,\"1165\":9,\"1167\":5,\"1175\":1,\"1176\":1,\"1180\":1,\"1197\":1,\"1207\":2,\"1208\":18,\"1213\":3,\"1223\":8,\"1224\":3,\"1230\":24,\"1232\":1,\"1234\":4,\"1235\":6,\"1236\":1}}],[\"userserviceimpl\",{\"1\":{\"1175\":1,\"1176\":1,\"1236\":1}}],[\"userserviceimpl代码\",{\"1\":{\"1107\":1}}],[\"userservicefactory\",{\"1\":{\"702\":1,\"703\":1}}],[\"userservice\",{\"1\":{\"701\":1,\"1160\":1,\"1162\":1,\"1165\":2,\"1175\":1,\"1176\":1,\"1236\":1,\"1525\":1}}],[\"users\",{\"1\":{\"54\":2,\"68\":2,\"1209\":5,\"1234\":1}}],[\"use\",{\"1\":{\"92\":1,\"278\":2,\"458\":1,\"579\":1,\"968\":1}}],[\"url=jdbc\",{\"1\":{\"1046\":2}}],[\"url和parse\",{\"1\":{\"376\":1}}],[\"url2\",{\"1\":{\"359\":1}}],[\"url1\",{\"1\":{\"359\":1}}],[\"url解析函数\",{\"0\":{\"376\":1},\"1\":{\"336\":2}}],[\"url\",{\"0\":{\"377\":1,\"378\":1},\"1\":{\"336\":4,\"359\":4,\"365\":10,\"374\":1,\"376\":2,\"377\":5,\"378\":15,\"660\":1,\"1236\":2,\"1438\":1,\"1447\":1}}],[\"url>\",{\"1\":{\"92\":1}}],[\"uri<\",{\"1\":{\"936\":3}}],[\"uri\",{\"1\":{\"711\":1,\"989\":5,\"990\":1}}],[\"uris\",{\"1\":{\"243\":1,\"244\":1}}],[\"uriencoding>\",{\"1\":{\"102\":1}}],[\"unnamed\",{\"1\":{\"1243\":1,\"1292\":1,\"1296\":1,\"1313\":2,\"1317\":1}}],[\"unx\",{\"1\":{\"876\":1}}],[\"unpooled\",{\"0\":{\"780\":1},\"1\":{\"780\":3}}],[\"unpooleddirectbytebuf\",{\"1\":{\"775\":1}}],[\"unpooledheapbytebuf\",{\"1\":{\"775\":1}}],[\"unpooled|pooled\",{\"1\":{\"770\":1}}],[\"unpark接下来的thread\",{\"1\":{\"591\":1}}],[\"unparksuccessor\",{\"1\":{\"585\":1}}],[\"unpark可以先unpark\",{\"1\":{\"549\":1}}],[\"unpark是以线程为单位来\",{\"1\":{\"549\":1}}],[\"unpark\",{\"1\":{\"549\":1,\"554\":2,\"555\":3}}],[\"unpaired\",{\"1\":{\"117\":1}}],[\"unexpected\",{\"1\":{\"741\":1}}],[\"uncheckedbooleansupplier\",{\"1\":{\"744\":2}}],[\"unchecked\",{\"1\":{\"740\":1}}],[\"unbind\",{\"1\":{\"701\":1,\"705\":2}}],[\"unbounded\",{\"1\":{\"361\":4}}],[\"unlockwrite\",{\"1\":{\"590\":2}}],[\"unlockread\",{\"1\":{\"590\":2}}],[\"unlock\",{\"1\":{\"554\":2,\"555\":2,\"1127\":2,\"1128\":1,\"1129\":3,\"1142\":3,\"1144\":1,\"1147\":7,\"1150\":2,\"1157\":1}}],[\"undo\",{\"1\":{\"499\":1,\"506\":1}}],[\"understanding\",{\"1\":{\"120\":1,\"127\":1}}],[\"undeclaredthrowableexception\",{\"1\":{\"59\":5,\"1309\":2}}],[\"unit\",{\"1\":{\"572\":2,\"694\":1,\"1129\":3,\"1152\":2,\"1197\":1}}],[\"uni\",{\"1\":{\"351\":1}}],[\"unix系统上的用户和用户组信息存储在\",{\"1\":{\"924\":1}}],[\"unix系统的登录用户名来进行认证\",{\"1\":{\"922\":1}}],[\"unix系统的ugo模型类似\",{\"1\":{\"917\":1}}],[\"unix\",{\"1\":{\"337\":8,\"852\":1,\"872\":1}}],[\"unixtime\",{\"1\":{\"337\":4}}],[\"unix时间戳转日期函数\",{\"1\":{\"337\":2}}],[\"unionfind\",{\"1\":{\"671\":2}}],[\"union\",{\"1\":{\"315\":4,\"316\":1,\"318\":2,\"353\":3,\"354\":3,\"386\":2,\"388\":2,\"409\":1,\"470\":1}}],[\"union联合查询\",{\"0\":{\"315\":1}}],[\"union联合体\",{\"1\":{\"248\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"585\":5}}],[\"unsafe对象不能直接调用\",{\"1\":{\"565\":1}}],[\"unsafe对象提供了非常底层的\",{\"1\":{\"565\":1}}],[\"unsafe并不是表示线程不安全\",{\"1\":{\"565\":1}}],[\"unsafe\",{\"0\":{\"565\":1},\"1\":{\"565\":5,\"742\":7,\"743\":1}}],[\"unsigned\",{\"1\":{\"480\":4,\"663\":2,\"1164\":2,\"1174\":3,\"1176\":1}}],[\"unsetpolicy\",{\"1\":{\"875\":1}}],[\"unset\",{\"1\":{\"279\":1}}],[\"unshared\",{\"1\":{\"69\":3}}],[\"unarchive\",{\"1\":{\"258\":1}}],[\"奖状的案例中citation类的name属性修改为student类型的属性\",{\"1\":{\"54\":1}}],[\"奖状类\",{\"1\":{\"52\":1,\"54\":1}}],[\"奖状出来\",{\"1\":{\"52\":1}}],[\"奖状除了获奖人姓名不同\",{\"1\":{\"52\":1}}],[\"奖状\",{\"1\":{\"52\":1,\"54\":1}}],[\"三个原始数据\",{\"1\":{\"875\":1}}],[\"三个尺度的特征\",{\"1\":{\"138\":1}}],[\"三大组件\",{\"0\":{\"860\":1,\"944\":1}}],[\"三次握手\",{\"1\":{\"652\":1}}],[\"三者总体的表现会随着技术进步而越来越好\",{\"1\":{\"637\":1}}],[\"三者的主要区别在于底层数据结构不同\",{\"1\":{\"604\":1}}],[\"三是增加binlog存储\",{\"1\":{\"483\":1}}],[\"三种\",{\"1\":{\"1317\":1}}],[\"三种配置方式\",{\"0\":{\"241\":1}}],[\"三种装入方式\",{\"1\":{\"180\":1}}],[\"三种硬件实现方式\",{\"1\":{\"170\":1}}],[\"三种代理的对比\",{\"0\":{\"61\":1}}],[\"三明治\",{\"1\":{\"147\":1}}],[\"三\",{\"0\":{\"96\":1}}],[\"三好学生\",{\"1\":{\"52\":3,\"54\":1}}],[\"三星\",{\"1\":{\"17\":1}}],[\"三星屏幕\",{\"1\":{\"17\":1}}],[\"案例分析\",{\"1\":{\"1213\":1}}],[\"案例3\",{\"0\":{\"403\":1}}],[\"案例2\",{\"0\":{\"401\":1}}],[\"案例1\",{\"0\":{\"399\":1}}],[\"案例需求\",{\"1\":{\"351\":1}}],[\"案例实现\",{\"0\":{\"85\":1}}],[\"案例\",{\"0\":{\"52\":1,\"344\":1,\"348\":1},\"1\":{\"104\":1,\"186\":1,\"265\":1,\"288\":1,\"289\":1,\"313\":1,\"988\":1,\"990\":1,\"1210\":1}}],[\"测试方法\",{\"1\":{\"1309\":1}}],[\"测试代码\",{\"0\":{\"1221\":1}}],[\"测试思路\",{\"1\":{\"1180\":1}}],[\"测试百万数据的统计\",{\"0\":{\"1180\":1}}],[\"测试逻辑\",{\"1\":{\"1147\":1}}],[\"测试消费每条拉取的数据量\",{\"1\":{\"1021\":1}}],[\"测试生产每秒传输的数据量\",{\"1\":{\"1021\":1}}],[\"测试步骤\",{\"1\":{\"1019\":1}}],[\"测试kafka集群是否启动成功\",{\"1\":{\"1012\":1}}],[\"测试过程\",{\"0\":{\"142\":1}}],[\"测试阶段而言是需要的\",{\"1\":{\"100\":1}}],[\"测试依赖范围\",{\"1\":{\"100\":1}}],[\"测试环境准备\",{\"0\":{\"329\":1}}],[\"测试环境\",{\"1\":{\"100\":1}}],[\"测试\",{\"0\":{\"1442\":1},\"1\":{\"91\":2,\"100\":1,\"713\":1,\"1213\":1,\"1294\":1}}],[\"测试访问类\",{\"1\":{\"51\":1,\"52\":1,\"59\":1}}],[\"测试类用来组装电脑\",{\"1\":{\"74\":1}}],[\"测试类\",{\"1\":{\"6\":1,\"7\":1,\"14\":1,\"54\":1,\"58\":1,\"59\":1,\"60\":1,\"74\":1,\"1132\":1}}],[\"浅克隆\",{\"1\":{\"51\":1}}],[\"用逗号分隔\",{\"1\":{\"1464\":1}}],[\"用以下命令即可获取\",{\"1\":{\"1440\":1}}],[\"用了适配器模式把\",{\"1\":{\"1370\":1}}],[\"用了以上手段声明了\",{\"1\":{\"1289\":1}}],[\"用编号处理方法对应关系比较省内存\",{\"1\":{\"1321\":1}}],[\"用静态工厂方法代替实例工厂方法\",{\"1\":{\"1285\":1}}],[\"用内置依赖注入和初始化取代扩展依赖注入和初始化\",{\"1\":{\"1285\":1}}],[\"用构造还是工厂创建\",{\"1\":{\"1248\":1}}],[\"用事件方式\",{\"1\":{\"1243\":1}}],[\"用小\",{\"1\":{\"1151\":1}}],[\"用多占用一点空间\",{\"1\":{\"1104\":1}}],[\"用数学语言表达就是f\",{\"1\":{\"1002\":1}}],[\"用bufferedreader获取分布式缓存中的文件内容\",{\"1\":{\"989\":1}}],[\"用不好\",{\"1\":{\"970\":1}}],[\"用不到时调出内存\",{\"1\":{\"181\":1}}],[\"用作hdfs客户端与密钥库之间的代理\",{\"1\":{\"933\":1}}],[\"用作唯一标识\",{\"1\":{\"293\":1}}],[\"用时\",{\"1\":{\"820\":2}}],[\"用的这种\",{\"1\":{\"1321\":1}}],[\"用的始终是第一次依赖注入的\",{\"1\":{\"1294\":1}}],[\"用的好提高程序性能\",{\"1\":{\"970\":1}}],[\"用的\",{\"1\":{\"784\":1}}],[\"用一字节\",{\"1\":{\"772\":1}}],[\"用一个整数型变量作为信号量\",{\"1\":{\"171\":1}}],[\"用一个已经创建的实例作为原型\",{\"1\":{\"49\":1}}],[\"用在目录上设置\",{\"1\":{\"920\":1}}],[\"用在客户端建立连接时\",{\"1\":{\"725\":1}}],[\"用在compute以及computeifabsent时\",{\"1\":{\"579\":1}}],[\"用cpu的计算\",{\"1\":{\"688\":1}}],[\"用compareto\",{\"1\":{\"603\":1}}],[\"用select的优势在于它可以同时处理多个connection\",{\"1\":{\"679\":1}}],[\"用equals来比较\",{\"1\":{\"579\":1}}],[\"用exists\",{\"1\":{\"496\":1}}],[\"用explain的结果\",{\"1\":{\"481\":1}}],[\"用fordwardingnode作为旧table\",{\"1\":{\"579\":1}}],[\"用or会导致索引失效\",{\"1\":{\"505\":1}}],[\"用主键来对应\",{\"1\":{\"480\":1}}],[\"用法\",{\"1\":{\"458\":1}}],[\"用delta保存事务操作的记录增量数据\",{\"1\":{\"292\":1}}],[\"用hdfs文件作为原始数据\",{\"1\":{\"292\":1}}],[\"用磁带完成\",{\"1\":{\"212\":1}}],[\"用\",{\"1\":{\"191\":1,\"843\":1,\"947\":1,\"1174\":1,\"1321\":1,\"1366\":1,\"1411\":1,\"1455\":2}}],[\"用二进制表示逻辑地址\",{\"1\":{\"184\":1}}],[\"用死锁检测算法化简资源分配图之后\",{\"1\":{\"178\":1}}],[\"用某种调度算法来确定满足i\",{\"1\":{\"211\":1}}],[\"用某种算法确定一个好的顺序来处理各个i\",{\"1\":{\"211\":1}}],[\"用某种数据结构来保存资源的请求和分配信息\",{\"1\":{\"178\":1}}],[\"用某种方法阻止系统进入不安全的状态\",{\"1\":{\"175\":1}}],[\"用信号量机制实现进程互斥\",{\"0\":{\"172\":1}}],[\"用记录型数据结构表示信号量\",{\"1\":{\"171\":1}}],[\"用优先级区分紧急程度\",{\"1\":{\"167\":1}}],[\"用于读取request请求的body部分\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"用于获取查询参数\",{\"1\":{\"1525\":1}}],[\"用于获取路径参数\",{\"1\":{\"1525\":1}}],[\"用于声明扫描策略\",{\"1\":{\"1503\":1}}],[\"用于操作数据库\",{\"1\":{\"1499\":1}}],[\"用于确定非常大的集合的基数\",{\"1\":{\"1179\":1}}],[\"用于线程池处理的任务\",{\"1\":{\"1157\":1}}],[\"用于数据库操作的回调函数\",{\"1\":{\"1129\":1}}],[\"用于数据迁移\",{\"1\":{\"869\":1}}],[\"用于处理缓存击穿问题\",{\"1\":{\"1129\":1}}],[\"用于处理缓\",{\"1\":{\"1129\":1}}],[\"用于redis等缓存\",{\"1\":{\"1113\":1}}],[\"用于添加资源\",{\"1\":{\"1004\":1}}],[\"用于更新资源\",{\"1\":{\"1004\":1}}],[\"用于删除资源\",{\"1\":{\"1004\":1}}],[\"用于保存订单数据和商品数据\",{\"1\":{\"988\":1}}],[\"用于保存100个出现频率最多的单词\",{\"1\":{\"478\":1}}],[\"用于统计合法数据\",{\"1\":{\"986\":1}}],[\"用于统计窗口内往下第n行值\",{\"1\":{\"365\":1}}],[\"用于统计窗口内往上第n行值\",{\"1\":{\"365\":1}}],[\"用于封装查询结果\",{\"1\":{\"985\":1}}],[\"用于封装每个县的确诊病例数和死亡病例数\",{\"1\":{\"972\":1}}],[\"用于对象的属性赋值\",{\"1\":{\"972\":1}}],[\"用于从字节流中读取字段重构对象\",{\"1\":{\"956\":1}}],[\"用于从当前数据中基于当前行的数据向后取偏移值\",{\"1\":{\"399\":1}}],[\"用于把对象指定的字段写出去\",{\"1\":{\"956\":1}}],[\"用于设置在hdfs中新建的文件和目录的默认权限\",{\"1\":{\"919\":1}}],[\"用于请求namenode挑选出适合存储数据副本的一组datanode\",{\"1\":{\"901\":1}}],[\"用于此目录下文件的擦除编码策略\",{\"1\":{\"875\":1}}],[\"用于平衡datanode中的数据在磁盘之间分布不均匀问题\",{\"1\":{\"874\":1}}],[\"用于快速开发可维护\",{\"1\":{\"789\":1}}],[\"用于通知发布者需要数据和通知发布者不再接受数据\",{\"1\":{\"719\":1}}],[\"用于stream中元素做汇总的方法\",{\"1\":{\"621\":1}}],[\"用于一个线程等待另一个线程的执行结果\",{\"1\":{\"547\":1}}],[\"用于优化轻量级锁重入\",{\"1\":{\"544\":1}}],[\"用于优化重量级锁\",{\"1\":{\"543\":1}}],[\"用于停止监控器线程\",{\"1\":{\"536\":1}}],[\"用于监控线程状态\",{\"1\":{\"536\":1}}],[\"用于实现并发读\",{\"1\":{\"589\":1}}],[\"用于实现允许其他非hive的系统\",{\"1\":{\"474\":1}}],[\"用于实现json字符串的解析\",{\"1\":{\"396\":1}}],[\"用于提前运行一个mapreduce程序将表或者分区的信息构建一些元数据\",{\"1\":{\"458\":1}}],[\"用于将小文件合并以后\",{\"1\":{\"436\":1}}],[\"用于将多个select语句的结果合并成一个结果集\",{\"1\":{\"315\":1}}],[\"用于降低hadoop数据存储空间和加速hive查询速度\",{\"1\":{\"430\":1}}],[\"用于存放消息的组件\",{\"1\":{\"1008\":1}}],[\"用于存放操作系统的相关数据\",{\"1\":{\"182\":1}}],[\"用于存储所有数据在不同时间上的所有状态\",{\"1\":{\"405\":1}}],[\"用于解析json字符串\",{\"1\":{\"395\":1}}],[\"用于解决udtf函数的一些查询限制的问题\",{\"1\":{\"349\":1}}],[\"用于指定每个窗口中\",{\"1\":{\"358\":1}}],[\"用于指定每个分组内的数据排序规则\",{\"1\":{\"358\":1}}],[\"用于指定分组\",{\"1\":{\"358\":1}}],[\"用于指定某些功能\",{\"1\":{\"247\":1}}],[\"用于判断字符串是否匹配正则表达式\",{\"1\":{\"330\":1}}],[\"用于测试运算符\",{\"1\":{\"329\":1}}],[\"用于排序\",{\"1\":{\"313\":1}}],[\"用于分组\",{\"1\":{\"313\":1}}],[\"用于全局排序\",{\"1\":{\"312\":1}}],[\"用于访问和分析存储在hadoop文件中的大型数据集\",{\"1\":{\"229\":1}}],[\"用于暂存从输出井传来的数据\",{\"1\":{\"212\":1}}],[\"用于收容用户进程输出的数据\",{\"1\":{\"212\":1}}],[\"用于收容i\",{\"1\":{\"212\":1}}],[\"用于进程调度\",{\"1\":{\"167\":1}}],[\"用于进程调度时候称为\",{\"1\":{\"167\":1}}],[\"用于作业\",{\"1\":{\"167\":6}}],[\"用于加载代理类\",{\"1\":{\"59\":1}}],[\"用原语实现进程控制\",{\"1\":{\"161\":1}}],[\"用原型模式生成\",{\"1\":{\"52\":1}}],[\"用来执行事务的提交\",{\"1\":{\"1456\":1}}],[\"用来创建\",{\"1\":{\"1455\":1}}],[\"用来创建代理\",{\"1\":{\"1325\":1}}],[\"用来创建代理对象\",{\"1\":{\"59\":1}}],[\"用来存储中间\",{\"1\":{\"1362\":1}}],[\"用来存放文件及目录的基本信息\",{\"1\":{\"913\":1}}],[\"用来存放当前访问的若干页表项\",{\"1\":{\"185\":1}}],[\"用来解析\",{\"1\":{\"1442\":1,\"1461\":1}}],[\"用来解放\",{\"1\":{\"854\":1}}],[\"用来解决数据复制阶段的阻塞问题\",{\"1\":{\"856\":1}}],[\"用来解决\",{\"1\":{\"663\":1}}],[\"用来解决程序大小超过物理内存总和的问题\",{\"1\":{\"181\":1}}],[\"用来与客户端之间通信\",{\"1\":{\"826\":1,\"827\":1}}],[\"用来获取某个\",{\"1\":{\"1267\":1}}],[\"用来获取\",{\"1\":{\"821\":1}}],[\"用来处理\",{\"1\":{\"752\":1,\"766\":1}}],[\"用来缓存消息\",{\"1\":{\"743\":1}}],[\"用来接收结果的\",{\"1\":{\"738\":1}}],[\"用来分配\",{\"1\":{\"730\":1,\"744\":1}}],[\"用来在第一时间判定是否是无效数据包\",{\"1\":{\"712\":1}}],[\"用来触发特殊事件\",{\"1\":{\"707\":2}}],[\"用来判断是不是\",{\"1\":{\"707\":2}}],[\"用来记录一个页面自上次被访问以来所经历的时间t\",{\"1\":{\"690\":1}}],[\"用来选择淘汰哪一页的规则叫做页面置换算法\",{\"1\":{\"690\":1}}],[\"用来保存实际数据\",{\"1\":{\"663\":1}}],[\"用来保证变更表结构操作的安全性\",{\"1\":{\"510\":1}}],[\"用来表示文件路径\",{\"1\":{\"821\":1}}],[\"用来表示不同类型的\",{\"1\":{\"663\":1}}],[\"用来表示系统中某种资源的数量\",{\"1\":{\"171\":1}}],[\"用来进行线程协作\",{\"1\":{\"593\":1}}],[\"用来进行线程同步协作\",{\"1\":{\"592\":1}}],[\"用来限制能同时访问共享资源的线程上限\",{\"1\":{\"591\":1}}],[\"用来占位\",{\"1\":{\"579\":1}}],[\"用来统计查询计数\",{\"1\":{\"304\":1}}],[\"用来过滤查询\",{\"1\":{\"304\":1}}],[\"用来支持如指示存储位置\",{\"1\":{\"238\":1}}],[\"用来描述或判定客体性质\",{\"1\":{\"459\":1}}],[\"用来描述数据\",{\"1\":{\"233\":1}}],[\"用来描述进程的各种信息\",{\"1\":{\"159\":1}}],[\"用程序状态字寄存器\",{\"1\":{\"156\":1}}],[\"用户发送请求至前端控制器dispatcherservlet\",{\"1\":{\"1530\":1}}],[\"用户多次打开页面\",{\"1\":{\"1179\":1}}],[\"用户每访问网站的一个页面\",{\"1\":{\"1179\":1}}],[\"用户一次签到\",{\"1\":{\"1174\":1}}],[\"用户签到\",{\"0\":{\"1173\":1,\"1174\":1,\"1175\":1,\"1176\":1}}],[\"用户粘度很高\",{\"1\":{\"1166\":1}}],[\"用户不感兴趣的内容\",{\"1\":{\"1166\":1}}],[\"用户不一定感兴趣\",{\"1\":{\"1166\":1}}],[\"用户未登录\",{\"1\":{\"1162\":1}}],[\"用户已经购买过一次\",{\"1\":{\"1137\":3}}],[\"用户已经购买过了\",{\"1\":{\"1137\":3,\"1157\":2}}],[\"用户id\",{\"1\":{\"1134\":1,\"1137\":3,\"1142\":1,\"1150\":1,\"1156\":1,\"1157\":1,\"1164\":1,\"1174\":1}}],[\"用户或者说商业对手很容易猜测出来我们的一些敏感信息\",{\"1\":{\"1131\":1}}],[\"用户请求的数据在缓存中和数据库中都不存在\",{\"1\":{\"1124\":1}}],[\"用户使用缓存中的过时数据\",{\"1\":{\"1120\":1}}],[\"用户评价都是致命的\",{\"1\":{\"1113\":1}}],[\"用户去登录会去校验用户提交的手机号和验证码\",{\"1\":{\"1106\":1}}],[\"用户通过socket像互相传递数据\",{\"1\":{\"1100\":1}}],[\"用户在请求时候\",{\"1\":{\"1098\":1}}],[\"用户在提交手机号后\",{\"1\":{\"1098\":1}}],[\"用户将验证码和手机号进行输入\",{\"1\":{\"1098\":1}}],[\"用户程序等\",{\"1\":{\"953\":1}}],[\"用户程序独占整个用户区空间\",{\"1\":{\"182\":1}}],[\"用户向yarn中提交应用程序\",{\"1\":{\"953\":1}}],[\"用户队列权限等\",{\"1\":{\"949\":1}}],[\"用户提交的每个应用程序均包含一个am\",{\"1\":{\"944\":1}}],[\"用户提交请求到首次产生响应所用时间\",{\"1\":{\"166\":1}}],[\"用户标识号\",{\"1\":{\"924\":1}}],[\"用户名为\",{\"1\":{\"927\":1}}],[\"用户名或密码不正确\",{\"1\":{\"702\":1,\"703\":1}}],[\"用户名\",{\"1\":{\"701\":2,\"924\":1}}],[\"用户管理接口\",{\"1\":{\"701\":1}}],[\"用户栈切换到内核栈\",{\"1\":{\"676\":1}}],[\"用户栈等\",{\"1\":{\"676\":2}}],[\"用户进程发起read操作之后\",{\"1\":{\"679\":1}}],[\"用户进程判断结果是一个error时\",{\"1\":{\"679\":1}}],[\"用户进程才解除block的状态\",{\"1\":{\"679\":1}}],[\"用户进程主动切换到内核态的方式\",{\"1\":{\"676\":1}}],[\"用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作\",{\"1\":{\"171\":1}}],[\"用户空间和内核空间\",{\"0\":{\"676\":1}}],[\"用户会收到一个警告信息\",{\"1\":{\"640\":1}}],[\"用户下下次登陆时间\",{\"1\":{\"399\":1}}],[\"用户下次登陆时间\",{\"1\":{\"399\":1}}],[\"用户定义函数\",{\"1\":{\"334\":1}}],[\"用户可随时通过\",{\"1\":{\"953\":1}}],[\"用户可选择性的控制指定的物化视图查询重写机制\",{\"1\":{\"276\":1}}],[\"用户可以在任何java应用程序中使用这些代理和服务实现管理\",{\"1\":{\"1045\":1}}],[\"用户可以参考该文件\",{\"1\":{\"875\":1}}],[\"用户可以对文件执行哪些操作\",{\"1\":{\"201\":1}}],[\"用户可以请求显示目录的内容\",{\"1\":{\"196\":1}}],[\"用户可以通过使用形象的图形界面进行操作\",{\"1\":{\"154\":1}}],[\"用户可以根据自己的喜爱更换自己的输入法的皮肤\",{\"1\":{\"72\":1}}],[\"用户编程时只需提供逻辑设备名\",{\"1\":{\"213\":1}}],[\"用户编程时必须使用\",{\"1\":{\"213\":1}}],[\"用户编程麻烦\",{\"1\":{\"176\":1}}],[\"用户层系统\",{\"1\":{\"210\":1}}],[\"用户区用于存放用户进程的相关数据\",{\"1\":{\"182\":1}}],[\"用户级线程的切换在用户空间即可完成\",{\"1\":{\"163\":1}}],[\"用户级线程中\",{\"1\":{\"163\":1}}],[\"用户级线程\",{\"1\":{\"163\":1}}],[\"用户态与内核态的切换次数没有减少\",{\"1\":{\"855\":1}}],[\"用户态与内核态的切换发生了\",{\"1\":{\"854\":1}}],[\"用户态进程通过系统调用向操作系统申请资源完成工作\",{\"1\":{\"676\":1}}],[\"用户态和内核态\",{\"0\":{\"676\":1}}],[\"用户态\",{\"1\":{\"156\":1,\"157\":2}}],[\"用户接口\",{\"1\":{\"154\":1,\"232\":1}}],[\"用户注册\",{\"1\":{\"110\":1}}],[\"用户服务\",{\"1\":{\"110\":1}}],[\"用户有了机箱肯定是想按照自己的喜好\",{\"1\":{\"74\":1}}],[\"用户窗体可以根据需要选择或者增加新的主题\",{\"1\":{\"72\":1}}],[\"用户只需要知道具体工厂的名称就可得到所要的产品\",{\"1\":{\"35\":1}}],[\"用户只需要指定复杂对象的类型就可以得到该对象\",{\"1\":{\"12\":1}}],[\"<resultmap\",{\"1\":{\"1230\":2}}],[\"<resource>\",{\"1\":{\"102\":1}}],[\"<resources>\",{\"1\":{\"102\":1}}],[\"<relativepath\",{\"1\":{\"1219\":1}}],[\"<r\",{\"1\":{\"1129\":3}}],[\"<r>\",{\"1\":{\"1129\":2}}],[\"<font\",{\"1\":{\"1083\":1}}],[\"<final>false<\",{\"1\":{\"919\":1,\"926\":1}}],[\"<finalname>定义打包名称<\",{\"1\":{\"102\":1}}],[\"<filter>\",{\"1\":{\"344\":1}}],[\"<filters>\",{\"1\":{\"344\":1}}],[\"<classpathprefix>lib\",{\"1\":{\"957\":1}}],[\"<commons\",{\"1\":{\"112\":1}}],[\"<configuration>\",{\"1\":{\"102\":2,\"344\":1,\"936\":1,\"957\":2,\"1022\":1,\"1219\":1}}],[\"<code>runtime<\",{\"1\":{\"70\":2}}],[\"<日期>\",{\"1\":{\"909\":1}}],[\"<文件>\",{\"1\":{\"875\":1}}],[\"<value>simple<\",{\"1\":{\"936\":1}}],[\"<value>kms\",{\"1\":{\"936\":4}}],[\"<value>jceks\",{\"1\":{\"936\":1}}],[\"<value>group1\",{\"1\":{\"927\":1}}],[\"<value>host1\",{\"1\":{\"927\":1}}],[\"<value>022<\",{\"1\":{\"919\":1}}],[\"<value>0<\",{\"1\":{\"910\":1}}],[\"<value>1440<\",{\"1\":{\"910\":1}}],[\"<value>\",{\"1\":{\"872\":1,\"879\":1,\"927\":2}}],[\"<value>true<\",{\"1\":{\"872\":1,\"926\":1}}],[\"<version>0\",{\"1\":{\"1219\":1}}],[\"<version>7\",{\"1\":{\"1070\":2}}],[\"<version>5\",{\"1\":{\"957\":1,\"985\":1,\"1022\":1,\"1213\":1}}],[\"<version>4\",{\"1\":{\"783\":1,\"1070\":1,\"1087\":1}}],[\"<version>3\",{\"1\":{\"112\":1,\"344\":2,\"957\":5,\"985\":1,\"1022\":1,\"1150\":1,\"1213\":1}}],[\"<version>6\",{\"1\":{\"107\":5,\"1172\":1}}],[\"<version>$\",{\"1\":{\"99\":1,\"112\":4,\"1236\":2}}],[\"<version>1\",{\"1\":{\"98\":1,\"99\":1,\"101\":1,\"104\":1,\"105\":1,\"107\":3,\"108\":1,\"112\":1,\"113\":1,\"114\":2,\"115\":2,\"1022\":3,\"1466\":1}}],[\"<version>2\",{\"1\":{\"60\":1,\"102\":1,\"104\":1,\"344\":1,\"957\":1,\"1022\":1,\"1070\":3,\"1172\":1,\"1219\":1}}],[\"<name>redis\",{\"1\":{\"1219\":1}}],[\"<name>hadoop\",{\"1\":{\"927\":4,\"936\":4}}],[\"<name>fs\",{\"1\":{\"910\":2,\"919\":1}}],[\"<name>dfs\",{\"1\":{\"872\":2,\"879\":1,\"926\":1,\"936\":2}}],[\"<name>aliyun\",{\"1\":{\"92\":1}}],[\"<target\",{\"1\":{\"869\":1}}],[\"<target>1\",{\"1\":{\"102\":1,\"957\":1,\"1022\":1}}],[\"<t>\",{\"1\":{\"723\":6,\"733\":1,\"737\":1,\"1129\":2}}],[\"<h3>服务器内部错误<\",{\"1\":{\"1416\":1}}],[\"<hello\",{\"1\":{\"961\":2}}],[\"<hadoop\",{\"1\":{\"960\":1,\"961\":3}}],[\"<h1>hello\",{\"1\":{\"711\":1}}],[\"<hdfs\",{\"1\":{\"255\":1}}],[\"<<<<<<<<<<<销毁之前执行\",{\"1\":{\"1505\":1}}],[\"<<<<<<<<<<<\",{\"1\":{\"1505\":5}}],[\"<<\",{\"1\":{\"646\":2,\"669\":5,\"799\":5,\"999\":6,\"1132\":1}}],[\"<=\",{\"1\":{\"579\":1,\"646\":3,\"648\":2,\"649\":3,\"698\":1,\"699\":1,\"742\":1,\"744\":1,\"799\":4,\"834\":1,\"836\":1,\"999\":1,\"1134\":1,\"1142\":1,\"1150\":1,\"1156\":1,\"1172\":1}}],[\"<>\",{\"1\":{\"491\":1}}],[\"<window\",{\"1\":{\"358\":2}}],[\"<goal>shade<\",{\"1\":{\"344\":1}}],[\"<goals>\",{\"1\":{\"344\":1}}],[\"<groupid>redis\",{\"1\":{\"1213\":1}}],[\"<groupid>mysql<\",{\"1\":{\"957\":1,\"985\":1}}],[\"<groupid>io\",{\"1\":{\"783\":1,\"1172\":2}}],[\"<groupid>org\",{\"1\":{\"102\":2,\"107\":10,\"112\":3,\"113\":2,\"344\":3,\"957\":6,\"985\":1,\"1022\":7,\"1070\":7,\"1087\":6,\"1137\":1,\"1150\":1,\"1172\":3,\"1213\":1,\"1219\":7,\"1442\":1,\"1473\":1}}],[\"<groupid>junit<\",{\"1\":{\"99\":1,\"1070\":1,\"1087\":1}}],[\"<groupid>log4j<\",{\"1\":{\"99\":1,\"1022\":1}}],[\"<groupid>cn\",{\"1\":{\"1022\":1}}],[\"<groupid>commons\",{\"1\":{\"105\":1,\"112\":1,\"113\":1}}],[\"<groupid>com\",{\"1\":{\"98\":1,\"101\":1,\"104\":2,\"105\":1,\"107\":3,\"108\":1,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"1070\":1,\"1219\":2,\"1236\":2,\"1466\":1}}],[\"<groupid>cglib<\",{\"1\":{\"60\":1}}],[\"<key\",{\"1\":{\"250\":2}}],[\"<exclude>\",{\"1\":{\"1219\":1}}],[\"<exclude>meta\",{\"1\":{\"344\":3}}],[\"<excludes>\",{\"1\":{\"344\":1,\"1219\":1}}],[\"<exclusion>\",{\"1\":{\"105\":1,\"1172\":2}}],[\"<exclusions>\",{\"1\":{\"105\":1,\"1172\":1}}],[\"<execution>\",{\"1\":{\"344\":1}}],[\"<executions>\",{\"1\":{\"344\":1}}],[\"<encoding>utf\",{\"1\":{\"102\":1,\"957\":1}}],[\"<optional>true<\",{\"1\":{\"104\":1,\"1022\":1,\"1087\":1,\"1219\":1,\"1473\":1}}],[\"<uriencoding>utf\",{\"1\":{\"102\":1}}],[\"<url>http\",{\"1\":{\"92\":1}}],[\"<select\",{\"1\":{\"1230\":3}}],[\"<server>tomcat7<\",{\"1\":{\"102\":1}}],[\"<source>hdfs\",{\"1\":{\"926\":1}}],[\"<source>core\",{\"1\":{\"919\":1}}],[\"<source>1\",{\"1\":{\"102\":1,\"957\":1,\"1022\":1}}],[\"<stdio\",{\"1\":{\"663\":2}}],[\"<spring\",{\"1\":{\"112\":1}}],[\"<scope>provided<\",{\"1\":{\"1442\":1}}],[\"<scope>test<\",{\"1\":{\"112\":1,\"113\":1,\"1022\":1,\"1070\":1,\"1087\":1,\"1213\":1,\"1219\":1}}],[\"<scope>compile<\",{\"1\":{\"105\":1}}],[\"<scope>runtime<\",{\"1\":{\"99\":1,\"1087\":1}}],[\"<id\",{\"1\":{\"1230\":6}}],[\"<id>\",{\"1\":{\"1129\":2}}],[\"<id>jdk\",{\"1\":{\"92\":1}}],[\"<id>alimaven<\",{\"1\":{\"92\":1}}],[\"<init>\",{\"1\":{\"567\":1}}],[\"<include>\",{\"1\":{\"102\":1}}],[\"<includes>\",{\"1\":{\"102\":1}}],[\"<isnotnull>表示不为null值时执行\",{\"1\":{\"483\":1}}],[\"<isnotempty>表示不为空且不为null时执行\",{\"1\":{\"483\":1}}],[\"<isequal>中的comparevalue是与属性值对比的常量\",{\"1\":{\"483\":1}}],[\"<description>demo\",{\"1\":{\"1219\":1}}],[\"<dependencymanagement>\",{\"1\":{\"107\":1,\"112\":1}}],[\"<dependency>\",{\"1\":{\"60\":1,\"99\":2,\"101\":1,\"104\":2,\"105\":1,\"107\":10,\"112\":4,\"113\":4,\"114\":1,\"115\":1,\"344\":2,\"783\":1,\"957\":5,\"985\":2,\"1022\":8,\"1070\":9,\"1087\":7,\"1137\":1,\"1150\":1,\"1172\":3,\"1213\":2,\"1219\":5,\"1236\":2,\"1442\":1,\"1466\":1,\"1473\":1}}],[\"<dependencies>\",{\"1\":{\"99\":2,\"107\":2,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"344\":1,\"957\":1,\"1022\":1,\"1070\":1,\"1087\":1,\"1219\":1}}],[\"<directory>src\",{\"1\":{\"102\":1}}],[\"<build>\",{\"1\":{\"102\":3,\"112\":1,\"344\":1,\"957\":1,\"1022\":1,\"1219\":1}}],[\"<java\",{\"1\":{\"1219\":1}}],[\"<jackson\",{\"1\":{\"112\":1}}],[\"<junit\",{\"1\":{\"99\":1,\"112\":1}}],[\"<jdk>1\",{\"1\":{\"92\":1}}],[\"<policy>是可\",{\"1\":{\"875\":1}}],[\"<policy>\",{\"1\":{\"875\":1}}],[\"<policyname>\",{\"1\":{\"875\":4}}],[\"<port>8090<\",{\"1\":{\"102\":1}}],[\"<phase>package<\",{\"1\":{\"344\":1}}],[\"<parent>\",{\"1\":{\"107\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"<packaging>pom<\",{\"1\":{\"107\":1,\"108\":1,\"112\":1}}],[\"<packaging>jar<\",{\"1\":{\"113\":1,\"114\":1,\"115\":1}}],[\"<packaging>jar\",{\"1\":{\"98\":1}}],[\"<path>\",{\"1\":{\"102\":1,\"875\":1}}],[\"<plugin>\",{\"1\":{\"102\":2,\"112\":1,\"344\":1,\"957\":2,\"1022\":1,\"1219\":1}}],[\"<plugins>\",{\"1\":{\"102\":1,\"112\":1,\"344\":1,\"957\":1,\"1022\":1,\"1219\":1}}],[\"<property>\",{\"1\":{\"872\":2,\"879\":1,\"910\":2,\"919\":1,\"926\":1,\"927\":4,\"936\":6}}],[\"<properties>\",{\"1\":{\"92\":1,\"99\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"<project>\",{\"1\":{\"108\":1}}],[\"<project\",{\"1\":{\"99\":2,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"1219\":1}}],[\"<profile>\",{\"1\":{\"92\":1}}],[\"<mybatisplus\",{\"1\":{\"1236\":1}}],[\"<mainclass>com\",{\"1\":{\"957\":1}}],[\"<manifest>\",{\"1\":{\"957\":1}}],[\"<maven\",{\"1\":{\"92\":3,\"112\":2,\"113\":2,\"114\":2,\"115\":2}}],[\"<module>order\",{\"1\":{\"115\":1}}],[\"<module>user\",{\"1\":{\"115\":1}}],[\"<module>common\",{\"1\":{\"115\":1}}],[\"<module>child\",{\"1\":{\"108\":2}}],[\"<modules>\",{\"1\":{\"108\":1,\"115\":1}}],[\"<modelversion>4\",{\"1\":{\"98\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"<mirrorof>central<\",{\"1\":{\"92\":1}}],[\"<mirror>\",{\"1\":{\"92\":1}}],[\"<association\",{\"1\":{\"1230\":2}}],[\"<addclasspath>true<\",{\"1\":{\"957\":1}}],[\"<archive>\",{\"1\":{\"957\":1}}],[\"<arg>\",{\"1\":{\"869\":3}}],[\"<artifact>\",{\"1\":{\"344\":1}}],[\"<artifactid>tomcat\",{\"1\":{\"1442\":1}}],[\"<artifactid>tomcat7\",{\"1\":{\"102\":1}}],[\"<artifactid>dynamic\",{\"1\":{\"1236\":1}}],[\"<artifactid>druid<\",{\"1\":{\"101\":1,\"104\":1,\"1466\":1}}],[\"<artifactid>redis\",{\"1\":{\"1219\":1}}],[\"<artifactid>redisson<\",{\"1\":{\"1150\":1}}],[\"<artifactid>lettuce\",{\"1\":{\"1172\":2}}],[\"<artifactid>log4j\",{\"1\":{\"1070\":2}}],[\"<artifactid>log4j<\",{\"1\":{\"99\":1,\"1022\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"1022\":1,\"1070\":1,\"1087\":1,\"1219\":2}}],[\"<artifactid>aspectjweaver<\",{\"1\":{\"1137\":1}}],[\"<artifactid>elasticsearch\",{\"1\":{\"1070\":1}}],[\"<artifactid>elasticsearch<\",{\"1\":{\"1070\":1}}],[\"<artifactid>slf4j\",{\"1\":{\"1022\":1}}],[\"<artifactid>spring\",{\"1\":{\"107\":10,\"112\":1,\"113\":1,\"1022\":2,\"1070\":2,\"1087\":5,\"1172\":3,\"1219\":4,\"1473\":1}}],[\"<artifactid>kafka\",{\"1\":{\"1022\":1}}],[\"<artifactid>netty\",{\"1\":{\"783\":1}}],[\"<artifactid>hutool\",{\"1\":{\"1022\":1}}],[\"<artifactid>hadoop\",{\"1\":{\"344\":1,\"957\":4,\"985\":1}}],[\"<artifactid>hive\",{\"1\":{\"344\":1}}],[\"<artifactid>order\",{\"1\":{\"115\":1}}],[\"<artifactid>user\",{\"1\":{\"114\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"1236\":1}}],[\"<artifactid>mysql\",{\"1\":{\"957\":1,\"985\":1}}],[\"<artifactid>micro\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"<artifactid>maven\",{\"1\":{\"102\":1,\"112\":1,\"344\":1,\"957\":2,\"1022\":1}}],[\"<artifactid>parent\",{\"1\":{\"108\":1}}],[\"<artifactid>pro04\",{\"1\":{\"107\":1}}],[\"<artifactid>pro03\",{\"1\":{\"107\":2}}],[\"<artifactid>pro01\",{\"1\":{\"105\":1}}],[\"<artifactid>project<\",{\"1\":{\"98\":1}}],[\"<artifactid>common\",{\"1\":{\"113\":1,\"114\":1,\"115\":1}}],[\"<artifactid>commons\",{\"1\":{\"105\":1,\"112\":1,\"113\":1,\"1022\":1,\"1219\":1}}],[\"<artifactid>cglib<\",{\"1\":{\"60\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"1213\":1}}],[\"<artifactid>junit\",{\"1\":{\"112\":1,\"113\":1,\"1213\":1}}],[\"<artifactid>junit<\",{\"1\":{\"99\":1,\"1070\":1,\"1087\":1}}],[\"<artifactid>jackson\",{\"1\":{\"104\":1,\"112\":1,\"113\":1,\"1070\":1,\"1219\":1}}],[\"<activebydefault>true<\",{\"1\":{\"92\":1}}],[\"<activation>\",{\"1\":{\"92\":1}}],[\"<localrepository>d\",{\"1\":{\"92\":1}}],[\"<localrepository>\",{\"1\":{\"92\":1}}],[\"<\",{\"1\":{\"47\":2,\"60\":1,\"81\":4,\"88\":3,\"92\":9,\"98\":5,\"99\":13,\"101\":1,\"102\":18,\"104\":3,\"105\":6,\"107\":26,\"108\":2,\"112\":24,\"113\":14,\"114\":8,\"115\":9,\"344\":14,\"358\":4,\"363\":1,\"404\":1,\"409\":1,\"437\":3,\"555\":6,\"566\":2,\"567\":1,\"579\":3,\"585\":2,\"592\":2,\"593\":2,\"645\":5,\"648\":4,\"649\":3,\"668\":3,\"669\":4,\"673\":2,\"692\":1,\"693\":1,\"696\":1,\"697\":2,\"698\":1,\"699\":1,\"711\":1,\"716\":3,\"723\":1,\"743\":2,\"744\":2,\"783\":1,\"795\":2,\"799\":14,\"809\":1,\"840\":2,\"843\":1,\"846\":1,\"872\":2,\"875\":2,\"879\":1,\"910\":4,\"919\":1,\"926\":1,\"927\":7,\"936\":8,\"957\":15,\"974\":1,\"985\":2,\"988\":2,\"999\":5,\"1022\":18,\"1023\":1,\"1025\":1,\"1070\":10,\"1083\":1,\"1087\":8,\"1132\":2,\"1135\":1,\"1137\":2,\"1150\":1,\"1172\":6,\"1180\":1,\"1213\":4,\"1219\":20,\"1230\":9,\"1236\":6,\"1442\":1,\"1466\":1,\"1473\":1}}],[\"0号库\",{\"1\":{\"1202\":1}}],[\"0号盘面是在1号盘面上面的\",{\"1\":{\"205\":1}}],[\"0则可以在任意ip访问\",{\"1\":{\"1196\":1}}],[\"0起\",{\"1\":{\"883\":1}}],[\"0对nasm和yasm有版本要求\",{\"1\":{\"876\":1}}],[\"0e\",{\"1\":{\"692\":10,\"693\":10,\"699\":1}}],[\"0c\",{\"1\":{\"692\":10,\"693\":10}}],[\"0b\",{\"1\":{\"692\":10,\"693\":10}}],[\"0a\",{\"1\":{\"692\":10,\"693\":10,\"698\":10,\"779\":3,\"780\":1}}],[\"0x01\",{\"1\":{\"1523\":2}}],[\"0x0f\",{\"1\":{\"799\":2}}],[\"0x250\",{\"1\":{\"772\":2}}],[\"0x251562d5\",{\"1\":{\"748\":6}}],[\"0x2e1884dd\",{\"1\":{\"753\":2}}],[\"0x7f\",{\"1\":{\"799\":1}}],[\"0x749124ba\",{\"1\":{\"753\":2}}],[\"0x744f2b47\",{\"1\":{\"699\":14}}],[\"0x79a26af9\",{\"1\":{\"748\":6}}],[\"0x94b2a840\",{\"1\":{\"748\":6}}],[\"0x94132411\",{\"1\":{\"692\":5}}],[\"0xdff439d3\",{\"1\":{\"699\":2}}],[\"0xd739f137\",{\"1\":{\"697\":14}}],[\"0xf\",{\"1\":{\"799\":1}}],[\"0xf0f347b8\",{\"1\":{\"699\":5}}],[\"0xffffffffl\",{\"1\":{\"799\":2}}],[\"0xff\",{\"1\":{\"665\":1,\"713\":1,\"714\":1,\"723\":1,\"799\":1}}],[\"0xa4b3be43\",{\"1\":{\"698\":12}}],[\"0xe3d9713f\",{\"1\":{\"697\":2}}],[\"0x3c2ef3c2\",{\"1\":{\"697\":5}}],[\"0x1f\",{\"1\":{\"799\":1}}],[\"0x1282d755\",{\"1\":{\"698\":5}}],[\"0x1719abf7\",{\"1\":{\"693\":7}}],[\"0x100000000l\",{\"1\":{\"799\":2}}],[\"0x10\",{\"1\":{\"506\":2}}],[\"0x4d6c6a84\",{\"1\":{\"693\":2}}],[\"0x81e0fda5\",{\"1\":{\"692\":2}}],[\"0d\",{\"1\":{\"620\":1,\"692\":10,\"693\":10,\"699\":1,\"857\":1}}],[\"0竞争成功\",{\"1\":{\"591\":1}}],[\"0和thread\",{\"1\":{\"591\":1}}],[\"0f下雨天留客06天留09我不留\",{\"1\":{\"709\":1}}],[\"0f\",{\"1\":{\"579\":1,\"692\":10,\"693\":10,\"699\":1}}],[\"0lin\",{\"1\":{\"662\":1}}],[\"0l\",{\"1\":{\"574\":2}}],[\"0之前的一个bug\",{\"1\":{\"529\":1}}],[\"0之后\",{\"1\":{\"522\":1}}],[\"0之后支持\",{\"1\":{\"271\":1}}],[\"0以前的版本要实现集群一般时借助哨兵sentinel工具来监控master节点的状态\",{\"1\":{\"526\":1}}],[\"0引入的多线程指的是网络i\",{\"1\":{\"516\":1}}],[\"0可以更换时间低位和时间高位的存储方式\",{\"1\":{\"502\":1}}],[\"0才解决\",{\"1\":{\"501\":1}}],[\"0表示未删除\",{\"1\":{\"480\":1}}],[\"0表示否\",{\"1\":{\"480\":1}}],[\"0版本引入的新特性\",{\"1\":{\"1525\":1}}],[\"0版本之前的单线程指的是其网络i\",{\"1\":{\"516\":1}}],[\"0版本之前的控制属性\",{\"1\":{\"448\":1}}],[\"0版本开始由以下参数控制\",{\"1\":{\"448\":1}}],[\"0不再支持\",{\"1\":{\"420\":1}}],[\"04\",{\"1\":{\"337\":8,\"359\":2,\"692\":10,\"693\":10,\"764\":3,\"772\":2,\"773\":1,\"776\":4,\"779\":3,\"780\":2,\"999\":2}}],[\"022=755\",{\"1\":{\"919\":2}}],[\"02\",{\"1\":{\"337\":1,\"359\":1,\"692\":10,\"693\":10,\"699\":2,\"772\":4,\"773\":1,\"776\":4,\"779\":3,\"780\":2,\"876\":1,\"1301\":1}}],[\"02767\",{\"1\":{\"144\":1}}],[\"07\",{\"1\":{\"337\":9,\"692\":10,\"693\":10,\"697\":21,\"762\":2,\"779\":3,\"780\":1,\"974\":1}}],[\"07004\",{\"1\":{\"131\":1}}],[\"06\",{\"1\":{\"337\":1,\"692\":10,\"693\":10,\"697\":2,\"699\":1,\"748\":2,\"773\":1,\"774\":3,\"779\":3,\"780\":2}}],[\"00代表true\",{\"1\":{\"772\":1}}],[\"000\",{\"1\":{\"571\":1,\"820\":1}}],[\"000001\",{\"1\":{\"495\":1}}],[\"00000文件\",{\"1\":{\"293\":1}}],[\"00000文件则是写入的数据内容\",{\"1\":{\"293\":1}}],[\"0000000000000000000000000000000000000000000000000000111111111111\",{\"1\":{\"999\":1}}],[\"0000000000000000000000000000000000000000000000000000000000011111\",{\"1\":{\"999\":2}}],[\"000000\",{\"1\":{\"285\":2}}],[\"00表示轻量级锁\",{\"1\":{\"540\":1}}],[\"00\",{\"1\":{\"359\":1,\"365\":6,\"437\":8,\"692\":10,\"693\":10,\"697\":131,\"772\":7,\"773\":6,\"774\":15,\"817\":1,\"1132\":3}}],[\"001隔开\",{\"1\":{\"290\":1}}],[\"001\",{\"1\":{\"252\":1,\"571\":1}}],[\"09\",{\"1\":{\"280\":3,\"337\":2,\"692\":10,\"693\":10,\"699\":3,\"748\":1,\"779\":3,\"780\":1}}],[\"08\",{\"1\":{\"280\":9,\"337\":1,\"692\":17,\"693\":19,\"698\":19,\"699\":1,\"762\":1,\"779\":3,\"780\":1,\"999\":2}}],[\"08589340b276ee29a357f080ed4012b\",{\"1\":{\"185\":1}}],[\"0丢弃了index索引的语法支持\",{\"1\":{\"274\":1}}],[\"0开始\",{\"1\":{\"474\":1}}],[\"0开始尝试引入物化视图\",{\"1\":{\"274\":1}}],[\"0开始不再需要\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"0开始已经不需要\",{\"1\":{\"266\":1}}],[\"0123\",{\"1\":{\"840\":1}}],[\"0123456789abcdef3333\",{\"1\":{\"840\":2}}],[\"0123456789abcdef\",{\"1\":{\"799\":1,\"840\":1}}],[\"01背包\",{\"0\":{\"648\":1}}],[\"011\",{\"1\":{\"571\":1}}],[\"010\",{\"1\":{\"571\":1}}],[\"01009\",{\"1\":{\"265\":1}}],[\"01007\",{\"1\":{\"265\":1}}],[\"01005\",{\"1\":{\"265\":1}}],[\"01003\",{\"1\":{\"265\":1}}],[\"01001\",{\"1\":{\"265\":1}}],[\"01\",{\"1\":{\"265\":5,\"307\":3,\"310\":1,\"337\":4,\"365\":4,\"649\":1,\"692\":10,\"693\":10,\"772\":3,\"773\":1,\"779\":3,\"780\":2,\"972\":1,\"974\":1,\"1299\":1}}],[\"05\",{\"1\":{\"120\":1,\"127\":1,\"337\":1,\"692\":10,\"693\":10,\"748\":2,\"772\":1,\"773\":1,\"774\":2,\"776\":2,\"779\":3,\"780\":2}}],[\"03\",{\"1\":{\"120\":1,\"127\":1,\"337\":2,\"352\":2,\"692\":10,\"693\":10,\"748\":2,\"772\":2,\"773\":1,\"776\":6,\"779\":3,\"780\":2,\"796\":17}}],[\"0<\",{\"1\":{\"98\":2,\"104\":1,\"108\":1,\"112\":3,\"113\":1,\"114\":1,\"115\":1,\"1022\":1,\"1070\":2,\"1213\":2,\"1219\":1}}],[\"0\",{\"0\":{\"285\":1,\"874\":1,\"875\":1},\"1\":{\"47\":2,\"59\":4,\"70\":1,\"81\":12,\"88\":5,\"98\":2,\"105\":11,\"107\":8,\"108\":1,\"110\":8,\"112\":10,\"113\":9,\"114\":10,\"115\":10,\"169\":1,\"191\":6,\"237\":1,\"256\":3,\"283\":1,\"285\":2,\"290\":2,\"293\":1,\"309\":1,\"336\":1,\"337\":1,\"340\":2,\"351\":4,\"353\":2,\"354\":1,\"374\":2,\"382\":3,\"400\":3,\"482\":2,\"519\":8,\"522\":1,\"541\":2,\"555\":6,\"562\":16,\"564\":2,\"566\":3,\"567\":4,\"574\":1,\"579\":10,\"585\":3,\"588\":1,\"592\":2,\"593\":2,\"598\":1,\"620\":1,\"645\":3,\"646\":3,\"648\":10,\"649\":12,\"658\":1,\"659\":1,\"662\":12,\"663\":6,\"667\":1,\"668\":9,\"669\":6,\"673\":3,\"690\":2,\"692\":33,\"693\":40,\"696\":2,\"697\":50,\"698\":44,\"699\":51,\"702\":1,\"707\":4,\"713\":6,\"714\":3,\"718\":2,\"723\":6,\"725\":3,\"740\":4,\"741\":1,\"742\":9,\"743\":5,\"744\":3,\"748\":79,\"751\":1,\"753\":16,\"759\":1,\"766\":2,\"768\":4,\"771\":1,\"772\":4,\"773\":2,\"774\":3,\"775\":2,\"776\":8,\"779\":5,\"780\":2,\"785\":2,\"794\":2,\"795\":2,\"796\":1,\"799\":14,\"803\":1,\"805\":2,\"807\":3,\"808\":2,\"809\":2,\"820\":4,\"822\":2,\"826\":1,\"827\":4,\"834\":1,\"836\":19,\"839\":1,\"840\":5,\"843\":2,\"846\":3,\"848\":1,\"857\":2,\"876\":14,\"883\":1,\"960\":1,\"962\":5,\"972\":4,\"973\":3,\"974\":4,\"979\":1,\"985\":3,\"986\":3,\"988\":10,\"990\":2,\"999\":6,\"1023\":1,\"1025\":1,\"1042\":1,\"1043\":1,\"1046\":1,\"1077\":1,\"1089\":4,\"1100\":1,\"1132\":2,\"1134\":1,\"1136\":2,\"1137\":7,\"1142\":1,\"1146\":1,\"1150\":1,\"1151\":5,\"1155\":4,\"1156\":3,\"1157\":6,\"1162\":2,\"1164\":1,\"1168\":3,\"1174\":3,\"1175\":1,\"1176\":12,\"1177\":3,\"1179\":1,\"1180\":2,\"1196\":11,\"1199\":4,\"1202\":1,\"1205\":53,\"1206\":53,\"1208\":37,\"1209\":10,\"1210\":34,\"1213\":2,\"1215\":1,\"1216\":3,\"1219\":9,\"1220\":1,\"1300\":1,\"1309\":2,\"1321\":2,\"1447\":1,\"1464\":1,\"1482\":1,\"1499\":1,\"1526\":1}}],[\">则只会执行select\",{\"1\":{\"1230\":1}}],[\"><\",{\"1\":{\"1230\":6}}],[\">不符合\",{\"1\":{\"973\":1}}],[\">符合\",{\"1\":{\"973\":1}}],[\">默认分区规则符合你的业务需求么\",{\"1\":{\"973\":1}}],[\">默认分区规则是什么\",{\"1\":{\"973\":1}}],[\">默认只有1个\",{\"1\":{\"973\":1}}],[\">当有多个reducetask\",{\"1\":{\"973\":1}}],[\">可以设置\",{\"1\":{\"973\":1}}],[\">2\",{\"1\":{\"973\":1}}],[\">reducetask有多个\",{\"1\":{\"973\":1}}],[\">rm\",{\"1\":{\"942\":3}}],[\">>>=\",{\"1\":{\"1176\":1}}],[\">>>\",{\"1\":{\"799\":3}}],[\">>\",{\"1\":{\"645\":1,\"669\":2,\"1449\":1,\"1451\":1}}],[\">=\",{\"1\":{\"340\":2,\"579\":3,\"645\":1,\"648\":3,\"649\":1,\"718\":1,\"740\":1,\"742\":2,\"799\":1,\"1317\":1}}],[\">order\",{\"1\":{\"310\":1}}],[\">10000\",{\"1\":{\"307\":1}}],[\">6000\",{\"1\":{\"260\":1}}],[\">f\",{\"1\":{\"105\":2}}],[\">x\",{\"1\":{\"105\":4}}],[\">e\",{\"1\":{\"105\":2}}],[\">d\",{\"1\":{\"105\":1}}],[\">container\",{\"1\":{\"942\":1}}],[\">c\",{\"1\":{\"105\":1}}],[\">a\",{\"1\":{\"104\":1}}],[\">b\",{\"1\":{\"104\":1,\"105\":1}}],[\">\",{\"1\":{\"47\":1,\"59\":1,\"88\":1,\"92\":4,\"98\":5,\"99\":7,\"102\":6,\"104\":1,\"105\":3,\"107\":12,\"112\":10,\"113\":7,\"114\":4,\"115\":4,\"163\":2,\"179\":1,\"209\":10,\"307\":1,\"310\":5,\"332\":4,\"358\":4,\"437\":3,\"551\":2,\"562\":4,\"566\":1,\"579\":2,\"593\":6,\"614\":7,\"616\":2,\"617\":1,\"619\":1,\"621\":1,\"645\":1,\"669\":12,\"673\":1,\"702\":1,\"716\":3,\"717\":1,\"718\":1,\"723\":1,\"725\":1,\"733\":5,\"735\":1,\"737\":4,\"740\":9,\"742\":2,\"743\":7,\"744\":1,\"750\":1,\"751\":1,\"754\":1,\"759\":1,\"760\":1,\"761\":2,\"762\":1,\"763\":1,\"764\":2,\"765\":2,\"766\":8,\"794\":2,\"795\":4,\"820\":1,\"823\":1,\"827\":1,\"846\":1,\"875\":2,\"876\":1,\"910\":2,\"927\":1,\"934\":2,\"936\":1,\"960\":1,\"961\":2,\"974\":1,\"976\":1,\"986\":1,\"991\":3,\"999\":2,\"1022\":5,\"1024\":1,\"1025\":1,\"1035\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":2,\"1084\":1,\"1085\":1,\"1107\":1,\"1128\":1,\"1129\":1,\"1132\":1,\"1136\":1,\"1137\":5,\"1151\":1,\"1152\":2,\"1157\":2,\"1161\":1,\"1162\":1,\"1164\":1,\"1165\":1,\"1168\":1,\"1172\":1,\"1213\":2,\"1219\":7,\"1230\":9,\"1232\":1,\"1236\":2,\"1243\":1,\"1244\":1,\"1257\":2,\"1285\":1,\"1292\":1,\"1296\":1,\"1304\":1,\"1306\":1,\"1317\":1,\"1413\":1,\"1416\":1,\"1420\":1,\"1424\":1,\"1482\":3,\"1505\":1,\"1525\":1}}],[\"globalexceptionhandler\",{\"1\":{\"1526\":2}}],[\"globaleventexecutor\",{\"1\":{\"740\":1}}],[\"globalsession\",{\"1\":{\"1290\":1}}],[\"gt\",{\"1\":{\"1136\":1,\"1137\":2,\"1157\":1}}],[\"gte\",{\"1\":{\"1081\":1}}],[\"gt从而得到一个码字\",{\"1\":{\"875\":1}}],[\"gid\",{\"1\":{\"924\":1}}],[\"github上的大神编写了redis的图形化桌面客户端\",{\"1\":{\"1200\":1}}],[\"github\",{\"1\":{\"117\":1,\"120\":2,\"121\":2,\"124\":1,\"125\":3,\"127\":2,\"128\":4,\"131\":2,\"133\":2,\"144\":1,\"145\":1,\"146\":4,\"1046\":1,\"1200\":2}}],[\"gz\",{\"1\":{\"876\":1,\"1046\":3,\"1193\":1}}],[\"gson\",{\"1\":{\"723\":3}}],[\"gsend\",{\"1\":{\"702\":2}}],[\"gquit\",{\"1\":{\"702\":2}}],[\"gjoin\",{\"1\":{\"702\":2}}],[\"gmembers\",{\"1\":{\"702\":2}}],[\"gmt\",{\"1\":{\"480\":4}}],[\"gg\",{\"1\":{\"699\":1}}],[\"ggggg|\",{\"1\":{\"698\":1}}],[\"g1\",{\"1\":{\"638\":3}}],[\"g1回收器讲下回收过程gc是什么\",{\"1\":{\"633\":1}}],[\"gcc\",{\"1\":{\"1192\":1}}],[\"gcreate\",{\"1\":{\"702\":2}}],[\"gc这三个gc有什么不同呢\",{\"1\":{\"639\":1}}],[\"gc组合\",{\"1\":{\"638\":1}}],[\"gc机制\",{\"1\":{\"633\":1}}],[\"gc原理\",{\"1\":{\"633\":1}}],[\"gc的两种判定方法\",{\"1\":{\"633\":1}}],[\"gc算法有哪些\",{\"1\":{\"633\":1}}],[\"gc大厂面试题\",{\"0\":{\"633\":1}}],[\"gc分代年龄\",{\"1\":{\"631\":1}}],[\"gc混淆使用\",{\"1\":{\"628\":1}}],[\"gc会有这种行为\",{\"1\":{\"628\":1}}],[\"gc会有单独收集老年代的行为\",{\"1\":{\"628\":1}}],[\"gc会和full\",{\"1\":{\"628\":1}}],[\"gc\",{\"0\":{\"628\":3,\"635\":1},\"1\":{\"628\":8,\"633\":3,\"635\":3,\"639\":5,\"769\":1,\"770\":1,\"775\":2,\"1055\":1}}],[\"g\",{\"1\":{\"368\":2,\"482\":4,\"776\":1,\"920\":1,\"1366\":1,\"1440\":1}}],[\"goals>\",{\"1\":{\"344\":1}}],[\"goal>\",{\"1\":{\"344\":1}}],[\"goodsinfo\",{\"1\":{\"990\":1}}],[\"goodsid\",{\"1\":{\"985\":11,\"986\":1}}],[\"goodsmap\",{\"1\":{\"990\":3}}],[\"goodssize\",{\"1\":{\"988\":2}}],[\"goodssn\",{\"1\":{\"985\":10,\"986\":1}}],[\"goodslist\",{\"1\":{\"988\":5}}],[\"goods\",{\"1\":{\"985\":2,\"986\":1,\"988\":4,\"989\":1,\"990\":3}}],[\"goodsname\",{\"1\":{\"985\":10,\"986\":1}}],[\"goodsbean>\",{\"1\":{\"986\":2}}],[\"goodsbean\",{\"1\":{\"985\":6,\"986\":9}}],[\"goodfeli\",{\"1\":{\"128\":1}}],[\"goodfellow和图灵奖得主youshua\",{\"1\":{\"124\":1}}],[\"google\",{\"1\":{\"133\":1,\"1023\":1}}],[\"guard\",{\"1\":{\"740\":1}}],[\"guide哥\",{\"1\":{\"1525\":1}}],[\"gui\",{\"1\":{\"154\":1}}],[\"guu\",{\"1\":{\"81\":2}}],[\"gathering\",{\"0\":{\"808\":1}}],[\"gap\",{\"1\":{\"511\":2}}],[\"gaugan2\",{\"1\":{\"125\":1}}],[\"gaugan\",{\"1\":{\"125\":1}}],[\"gan的推导及keras手把手实现\",{\"1\":{\"128\":1}}],[\"ganlab\",{\"1\":{\"125\":1}}],[\"gan广泛应用于图像生成\",{\"1\":{\"124\":1}}],[\"gan近年来成为人工智能和深度学习的热门研究领域\",{\"1\":{\"124\":1}}],[\"gan\",{\"0\":{\"122\":1},\"1\":{\"120\":1,\"127\":1,\"128\":1}}],[\"gan动物园\",{\"1\":{\"120\":1,\"127\":1}}],[\"gavp\",{\"0\":{\"98\":1}}],[\"games\",{\"1\":{\"81\":4}}],[\"gamecount++\",{\"1\":{\"81\":3}}],[\"gamecount\",{\"1\":{\"81\":2}}],[\"gbk\",{\"1\":{\"70\":1}}],[\"grid\",{\"1\":{\"1149\":1}}],[\"grpc\",{\"1\":{\"791\":1}}],[\"green\",{\"1\":{\"395\":1,\"405\":1}}],[\"granting\",{\"1\":{\"923\":2}}],[\"graph要求数据库保存一下两种信息\",{\"1\":{\"513\":1}}],[\"graph\",{\"1\":{\"513\":1}}],[\"graphobserver\",{\"1\":{\"47\":7}}],[\"gradle\",{\"1\":{\"94\":1}}],[\"group2<\",{\"1\":{\"927\":1}}],[\"group文件中\",{\"1\":{\"924\":1}}],[\"group1\",{\"1\":{\"920\":1}}],[\"groupquitresponsemessage\",{\"1\":{\"723\":3}}],[\"groupquitrequestmessagehandler\",{\"1\":{\"704\":1}}],[\"groupquitrequestmessage\",{\"1\":{\"702\":1,\"704\":1,\"723\":3}}],[\"groupmembersresponsemessage\",{\"1\":{\"704\":1,\"723\":3}}],[\"groupmembersrequestmessagehandler\",{\"1\":{\"704\":1}}],[\"groupmembersrequestmessage\",{\"1\":{\"702\":1,\"704\":1,\"723\":3}}],[\"groupjoinresponsemessage\",{\"1\":{\"704\":4,\"723\":3}}],[\"groupjoinrequestmessagehandler\",{\"1\":{\"704\":1}}],[\"groupjoinrequestmessage\",{\"1\":{\"702\":1,\"704\":1,\"723\":3}}],[\"groupname\",{\"1\":{\"704\":6}}],[\"groupchatresponsemessage\",{\"1\":{\"704\":1,\"723\":3}}],[\"groupchatrequestmessagehandler\",{\"1\":{\"704\":1}}],[\"groupchatrequestmessage\",{\"1\":{\"702\":1,\"704\":1,\"723\":3}}],[\"groupcreateresponsemessage\",{\"1\":{\"704\":3,\"723\":3}}],[\"groupcreaterequestmessagehandler\",{\"1\":{\"704\":1}}],[\"groupcreaterequestmessage\",{\"1\":{\"702\":1,\"704\":1,\"723\":3}}],[\"groupby\",{\"1\":{\"466\":1}}],[\"groupingby\",{\"1\":{\"621\":1,\"1171\":1}}],[\"grouping\",{\"0\":{\"353\":1},\"1\":{\"352\":2,\"353\":12,\"354\":7,\"355\":4}}],[\"groupid>\",{\"1\":{\"60\":1,\"98\":1,\"99\":2,\"101\":1,\"102\":2,\"104\":2,\"105\":2,\"107\":13,\"108\":1,\"112\":6,\"113\":5,\"114\":2,\"115\":2,\"344\":3,\"783\":1,\"957\":7,\"985\":2,\"1022\":9,\"1070\":9,\"1087\":7,\"1137\":1,\"1150\":1,\"1172\":5,\"1213\":2,\"1219\":9,\"1236\":2,\"1442\":1,\"1466\":1,\"1473\":1}}],[\"group<\",{\"1\":{\"98\":1}}],[\"group\",{\"0\":{\"306\":1,\"463\":1,\"924\":1},\"1\":{\"98\":2,\"276\":3,\"300\":1,\"306\":1,\"307\":3,\"310\":2,\"349\":1,\"351\":2,\"353\":7,\"354\":4,\"355\":2,\"357\":1,\"360\":1,\"382\":1,\"385\":1,\"437\":6,\"452\":1,\"466\":1,\"493\":2,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"701\":4,\"702\":10,\"704\":9,\"710\":1,\"711\":1,\"725\":4,\"733\":5,\"735\":4,\"737\":4,\"740\":1,\"746\":6,\"748\":5,\"753\":4,\"754\":4,\"758\":2,\"766\":2,\"784\":1,\"785\":1,\"794\":5,\"875\":1,\"917\":1,\"924\":2,\"1024\":2,\"1026\":1,\"1037\":1,\"1038\":2,\"1205\":2,\"1206\":1}}],[\"groups<\",{\"1\":{\"927\":2}}],[\"groupsessionfactory\",{\"1\":{\"704\":5}}],[\"groupsession\",{\"1\":{\"701\":1,\"704\":4}}],[\"groups\",{\"1\":{\"92\":1,\"437\":1}}],[\"ge\",{\"1\":{\"1235\":2}}],[\"georeference\",{\"1\":{\"1172\":1}}],[\"georesults<redisgeocommands\",{\"1\":{\"1172\":1}}],[\"georadius\",{\"1\":{\"1170\":1}}],[\"geosearchcommandargs\",{\"1\":{\"1172\":1}}],[\"geosearchstore\",{\"1\":{\"1170\":1}}],[\"geosearch\",{\"1\":{\"1170\":2,\"1172\":2}}],[\"geopos\",{\"1\":{\"1170\":1}}],[\"geohash\",{\"1\":{\"1170\":1}}],[\"geodist\",{\"1\":{\"1170\":1}}],[\"geoadd\",{\"1\":{\"1170\":1,\"1171\":1}}],[\"geolocation<>\",{\"1\":{\"1171\":1}}],[\"geolocation<string>>>\",{\"1\":{\"1172\":1}}],[\"geolocation<string>>\",{\"1\":{\"1171\":1,\"1172\":1}}],[\"geolocation\",{\"1\":{\"1170\":1}}],[\"geo\",{\"0\":{\"1170\":1,\"1171\":1},\"1\":{\"1170\":2,\"1171\":5,\"1172\":1}}],[\"genkey\",{\"1\":{\"936\":1}}],[\"genericapplicationlistener\",{\"1\":{\"1497\":2}}],[\"genericapplicationcontext\",{\"1\":{\"1244\":2}}],[\"genericconverter\",{\"1\":{\"1368\":1}}],[\"genericjackson2jsonredisserializer\",{\"1\":{\"1222\":2}}],[\"generic\",{\"1\":{\"1205\":2}}],[\"genericfuturelistener<future<\",{\"1\":{\"758\":1}}],[\"generate\",{\"1\":{\"799\":5}}],[\"generating\",{\"1\":{\"334\":1}}],[\"generative\",{\"1\":{\"120\":1,\"124\":1,\"127\":1,\"128\":1,\"133\":1}}],[\"generator生成的代码中\",{\"1\":{\"483\":1}}],[\"generator\",{\"1\":{\"47\":9,\"875\":1}}],[\"gender\",{\"1\":{\"351\":1,\"374\":1,\"407\":1,\"408\":1,\"409\":3}}],[\"getklassrelatedteachers\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"getkey\",{\"1\":{\"740\":1,\"743\":1,\"1171\":1}}],[\"getwriter\",{\"1\":{\"1416\":1,\"1420\":1}}],[\"getjedis\",{\"1\":{\"1213\":1,\"1215\":1,\"1216\":1}}],[\"gety\",{\"1\":{\"1171\":1}}],[\"getx\",{\"1\":{\"1171\":1}}],[\"getvoucherid\",{\"1\":{\"1157\":2}}],[\"getvalue\",{\"1\":{\"614\":3,\"740\":1,\"743\":1,\"1168\":1,\"1171\":1,\"1172\":1}}],[\"getentryname\",{\"1\":{\"1152\":2}}],[\"getendtime\",{\"1\":{\"1133\":1,\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1156\":1}}],[\"getexpiretime\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"getexceptionvalue\",{\"1\":{\"738\":1}}],[\"geticon\",{\"1\":{\"1160\":1}}],[\"getid\",{\"1\":{\"1122\":1,\"1133\":4,\"1134\":1,\"1137\":4,\"1142\":2,\"1144\":2,\"1147\":1,\"1150\":1,\"1152\":1,\"1156\":3,\"1157\":1,\"1159\":2,\"1161\":3,\"1162\":3,\"1164\":2,\"1165\":3,\"1167\":4,\"1168\":1,\"1171\":1,\"1172\":1,\"1175\":1,\"1176\":1}}],[\"getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"1343\":1,\"1350\":1}}],[\"getinterfacename\",{\"1\":{\"734\":1}}],[\"getinterfaces\",{\"1\":{\"59\":2}}],[\"getintvolatile\",{\"1\":{\"1135\":1}}],[\"getindexresponse\",{\"1\":{\"1072\":1}}],[\"getindexrequest\",{\"1\":{\"1072\":2}}],[\"getinputsplit\",{\"1\":{\"988\":1}}],[\"getinputstream\",{\"1\":{\"70\":1,\"795\":2,\"839\":1}}],[\"getinstance\",{\"1\":{\"22\":4,\"66\":8,\"68\":3,\"69\":2,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2,\"1071\":1,\"1072\":3,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"getheader\",{\"1\":{\"1111\":1}}],[\"gethits\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"gethand\",{\"1\":{\"81\":3}}],[\"getharddisk\",{\"1\":{\"74\":2}}],[\"getdayofmonth\",{\"1\":{\"1175\":1,\"1176\":1}}],[\"getdata\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"getdistance\",{\"1\":{\"1172\":1}}],[\"getdouble\",{\"1\":{\"985\":2}}],[\"getdeath\",{\"1\":{\"972\":1}}],[\"getdeclaredfield\",{\"1\":{\"565\":1}}],[\"getdeclaredconstructor\",{\"1\":{\"68\":1}}],[\"getf\",{\"1\":{\"1294\":3}}],[\"getfollowuserid\",{\"1\":{\"1164\":2,\"1165\":1}}],[\"getfirstthreadid\",{\"1\":{\"1152\":1}}],[\"getfacl\",{\"1\":{\"926\":1}}],[\"getfrom\",{\"1\":{\"703\":1,\"704\":1}}],[\"getframe\",{\"1\":{\"14\":2}}],[\"getlockwatchdogtimeout\",{\"1\":{\"1152\":2}}],[\"getlock\",{\"1\":{\"1150\":2,\"1157\":1}}],[\"getlocaladdress\",{\"1\":{\"840\":1}}],[\"getlong\",{\"1\":{\"985\":2}}],[\"getlogger\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"1285\":1,\"1294\":2}}],[\"getunsignedbyte\",{\"1\":{\"799\":5}}],[\"getuserandrole\",{\"1\":{\"1230\":3}}],[\"getuserid\",{\"1\":{\"1157\":2,\"1160\":1,\"1164\":2,\"1165\":1,\"1167\":1}}],[\"getuser\",{\"1\":{\"1101\":1,\"1111\":1,\"1134\":1,\"1137\":4,\"1142\":1,\"1150\":1,\"1156\":1,\"1157\":1,\"1159\":1,\"1161\":2,\"1162\":2,\"1164\":2,\"1165\":2,\"1167\":1,\"1168\":1,\"1175\":1,\"1176\":1}}],[\"getuserservice\",{\"1\":{\"702\":1,\"703\":1}}],[\"getusername\",{\"1\":{\"702\":1,\"703\":1,\"704\":2}}],[\"getbeansoftype\",{\"1\":{\"1429\":1,\"1451\":1}}],[\"getbean\",{\"1\":{\"1240\":1,\"1243\":1,\"1257\":2,\"1290\":1,\"1294\":1}}],[\"getbegintime\",{\"1\":{\"1133\":1,\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1156\":1}}],[\"getbit\",{\"1\":{\"1174\":1}}],[\"getbacklog\",{\"1\":{\"740\":2}}],[\"getbyid\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1160\":2,\"1161\":1,\"1165\":1}}],[\"getbyidwithredis\",{\"1\":{\"1122\":1,\"1129\":1}}],[\"getbyint\",{\"1\":{\"723\":1}}],[\"getbytes\",{\"1\":{\"710\":12,\"711\":1,\"723\":1,\"748\":2,\"766\":3,\"809\":2,\"834\":1,\"839\":3}}],[\"getoriginalfilename\",{\"1\":{\"1159\":1}}],[\"getoption\",{\"1\":{\"740\":1}}],[\"getoutputstream\",{\"1\":{\"726\":1,\"795\":2,\"834\":1,\"839\":1,\"854\":1}}],[\"gettypeid\",{\"1\":{\"1171\":1}}],[\"getter\",{\"1\":{\"733\":1,\"1525\":1}}],[\"getto\",{\"1\":{\"703\":1}}],[\"getgroupsession\",{\"1\":{\"704\":5}}],[\"getgroupname\",{\"1\":{\"704\":9}}],[\"getphone\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"getpolicy\",{\"1\":{\"875\":1}}],[\"getpath\",{\"1\":{\"988\":1}}],[\"getpartition\",{\"1\":{\"968\":1,\"973\":1}}],[\"getparametervalue\",{\"1\":{\"734\":1}}],[\"getparametertypes\",{\"1\":{\"734\":1,\"737\":1}}],[\"getpassword\",{\"1\":{\"702\":1,\"703\":1}}],[\"getprime\",{\"1\":{\"646\":2}}],[\"getproxy\",{\"1\":{\"1322\":1}}],[\"getproxyservice\",{\"1\":{\"737\":2}}],[\"getproxyobject\",{\"1\":{\"59\":4,\"60\":2}}],[\"getproperty\",{\"1\":{\"42\":1,\"723\":2,\"733\":1}}],[\"get和post的区别\",{\"0\":{\"651\":1}}],[\"get流程\",{\"1\":{\"579\":1}}],[\"get到了forwardingnode\",{\"1\":{\"579\":1}}],[\"get弱一致性\",{\"1\":{\"578\":1}}],[\"getapplicationcontext\",{\"1\":{\"1451\":1}}],[\"getabsolutepath\",{\"1\":{\"1449\":1}}],[\"getaliases\",{\"1\":{\"1072\":1}}],[\"getallocator\",{\"1\":{\"744\":1}}],[\"getattribute\",{\"1\":{\"701\":1,\"1099\":1,\"1100\":1}}],[\"getage\",{\"1\":{\"614\":4,\"616\":1,\"618\":1,\"619\":1,\"1234\":1,\"1235\":3}}],[\"getandset\",{\"1\":{\"741\":1}}],[\"getandaccumulate\",{\"1\":{\"562\":2}}],[\"getandadd\",{\"1\":{\"562\":1}}],[\"getandupdate\",{\"1\":{\"562\":2}}],[\"getanddecrement\",{\"1\":{\"562\":1}}],[\"getandincrement\",{\"1\":{\"562\":1,\"846\":1}}],[\"getaddress\",{\"1\":{\"54\":1,\"740\":1}}],[\"getrole\",{\"1\":{\"1230\":2}}],[\"getrecords\",{\"1\":{\"1161\":1,\"1165\":1,\"1172\":1}}],[\"getresource\",{\"1\":{\"1215\":1,\"1435\":1}}],[\"getresourceasstream\",{\"1\":{\"42\":1,\"723\":1,\"733\":1}}],[\"getresponse\",{\"1\":{\"1073\":1}}],[\"getrequestdata\",{\"1\":{\"1232\":1}}],[\"getrequest\",{\"1\":{\"1073\":2}}],[\"getremoteaddress\",{\"1\":{\"846\":2,\"859\":3}}],[\"getreturnvalue\",{\"1\":{\"738\":1}}],[\"getreturntype\",{\"1\":{\"737\":1}}],[\"getruntime\",{\"1\":{\"70\":2,\"635\":1,\"846\":1,\"847\":1}}],[\"getnickname\",{\"1\":{\"1160\":1}}],[\"getnow\",{\"1\":{\"737\":1,\"756\":1,\"758\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":2,\"764\":1}}],[\"getnumber\",{\"1\":{\"47\":4}}],[\"getname\",{\"1\":{\"34\":2,\"52\":1,\"54\":2,\"76\":7,\"614\":2,\"621\":3,\"737\":2,\"822\":1,\"859\":3,\"988\":1,\"1035\":1,\"1152\":1,\"1172\":1,\"1234\":1,\"1235\":3}}],[\"get\",{\"0\":{\"395\":1},\"1\":{\"42\":1,\"74\":2,\"336\":3,\"373\":1,\"393\":1,\"395\":4,\"477\":1,\"515\":1,\"565\":1,\"579\":1,\"614\":1,\"619\":1,\"621\":2,\"651\":1,\"671\":3,\"702\":1,\"710\":3,\"723\":1,\"733\":1,\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":1,\"760\":1,\"762\":4,\"763\":1,\"774\":1,\"796\":1,\"797\":1,\"799\":1,\"803\":4,\"809\":1,\"821\":5,\"822\":12,\"823\":3,\"840\":2,\"857\":1,\"870\":1,\"960\":1,\"972\":2,\"973\":3,\"974\":3,\"985\":1,\"986\":2,\"988\":4,\"990\":2,\"1004\":1,\"1023\":2,\"1072\":1,\"1073\":1,\"1089\":1,\"1101\":1,\"1107\":1,\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":3,\"1144\":1,\"1146\":3,\"1152\":2,\"1156\":2,\"1172\":1,\"1176\":4,\"1206\":8,\"1213\":1,\"1221\":1,\"1223\":2,\"1232\":2,\"1424\":1}}],[\"getcfg\",{\"1\":{\"1152\":2}}],[\"getcode\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"getcounter\",{\"1\":{\"983\":1,\"986\":2}}],[\"getconnectionmanager\",{\"1\":{\"1152\":4}}],[\"getconnecttimeoutmillis\",{\"1\":{\"725\":1}}],[\"getconf\",{\"1\":{\"962\":1,\"988\":1}}],[\"getcontent\",{\"1\":{\"703\":1,\"704\":1,\"1172\":2}}],[\"getcases\",{\"1\":{\"972\":1,\"974\":1}}],[\"getchannel\",{\"1\":{\"701\":1,\"703\":1,\"737\":3,\"796\":1,\"807\":1,\"808\":1,\"813\":1,\"820\":4}}],[\"getclass\",{\"1\":{\"59\":4,\"60\":1,\"711\":1,\"734\":1,\"780\":1,\"805\":1,\"1294\":2}}],[\"getclassloader\",{\"1\":{\"42\":1,\"59\":2,\"737\":1,\"1304\":1}}],[\"getcpu\",{\"1\":{\"17\":1,\"74\":2}}],[\"getmapping\",{\"1\":{\"1116\":1,\"1161\":1,\"1162\":1,\"1164\":1,\"1165\":2,\"1168\":1,\"1172\":1,\"1176\":1,\"1525\":1,\"1531\":1}}],[\"getmappings\",{\"1\":{\"1072\":1}}],[\"getmainboard\",{\"1\":{\"17\":1}}],[\"getmemberschannel\",{\"1\":{\"701\":1,\"704\":2}}],[\"getmembers\",{\"1\":{\"701\":1,\"704\":2}}],[\"getmemory\",{\"1\":{\"17\":1,\"74\":2}}],[\"getmessageclass\",{\"1\":{\"723\":2}}],[\"getmessagetype\",{\"1\":{\"713\":1,\"714\":1,\"723\":2,\"733\":2}}],[\"getmessage\",{\"1\":{\"59\":2,\"705\":1,\"1023\":1,\"1024\":1,\"1025\":2,\"1244\":3,\"1309\":1,\"1526\":1}}],[\"getmethodname\",{\"1\":{\"734\":1}}],[\"getmethod\",{\"1\":{\"59\":5,\"734\":1,\"1309\":2}}],[\"getsignature\",{\"1\":{\"1317\":2}}],[\"getsimplename\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"getscore\",{\"1\":{\"1168\":1}}],[\"getscreen\",{\"1\":{\"17\":1}}],[\"getsourceasstring\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"getsuccessfuljoblist\",{\"1\":{\"991\":1}}],[\"getsum\",{\"1\":{\"81\":2,\"620\":1}}],[\"getsplits\",{\"1\":{\"965\":1}}],[\"getsettings\",{\"1\":{\"1072\":1}}],[\"getservice\",{\"1\":{\"733\":1,\"734\":1}}],[\"getserverport\",{\"1\":{\"723\":1}}],[\"getserializeralgorithm\",{\"1\":{\"723\":3}}],[\"getsequenceid\",{\"1\":{\"713\":1,\"714\":1,\"723\":1,\"734\":1,\"738\":1}}],[\"getsession\",{\"1\":{\"703\":2,\"705\":2,\"1100\":1}}],[\"getseat\",{\"1\":{\"14\":2}}],[\"getsalary\",{\"1\":{\"620\":2,\"621\":2}}],[\"getstock\",{\"1\":{\"1133\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1142\":1,\"1150\":1,\"1156\":2}}],[\"getstring\",{\"1\":{\"985\":2}}],[\"getstate\",{\"1\":{\"974\":3}}],[\"getstatus\",{\"1\":{\"619\":1,\"621\":1}}],[\"getstatic\",{\"1\":{\"560\":1}}],[\"getstu\",{\"1\":{\"54\":3}}],[\"getshape\",{\"1\":{\"23\":2}}],[\"名\",{\"1\":{\"1274\":1,\"1280\":1}}],[\"名为root的超级用户只能从host1和host2连接来模拟属于group1和group2的用户\",{\"1\":{\"927\":1}}],[\"名称筛选\",{\"1\":{\"1489\":1}}],[\"名称\",{\"1\":{\"756\":1,\"913\":1}}],[\"名称基本一成不变\",{\"1\":{\"480\":1}}],[\"名称为bean\",{\"1\":{\"42\":1}}],[\"名字前面加\",{\"1\":{\"1472\":1}}],[\"名字取得不好\",{\"1\":{\"1444\":1}}],[\"名字叫redis\",{\"1\":{\"1196\":1}}],[\"名字\",{\"1\":{\"47\":1,\"81\":1,\"1025\":1}}],[\"示例2\",{\"0\":{\"718\":1}}],[\"示例1\",{\"0\":{\"717\":1}}],[\"示例如下\",{\"1\":{\"614\":2}}],[\"示例\",{\"0\":{\"47\":1,\"81\":1,\"347\":1,\"357\":1,\"460\":1},\"1\":{\"395\":1,\"396\":1,\"495\":1}}],[\"会替换掉原有对象\",{\"1\":{\"1505\":1}}],[\"会替换掉原本的\",{\"1\":{\"1254\":1}}],[\"会把它包装为\",{\"1\":{\"1497\":1}}],[\"会创建代理对象装配\",{\"1\":{\"1489\":1}}],[\"会创建新的cell来累加计数\",{\"1\":{\"579\":1}}],[\"会遍历包下所有\",{\"1\":{\"1476\":1}}],[\"会认为创建\",{\"1\":{\"1472\":1}}],[\"会解析\",{\"1\":{\"1456\":1}}],[\"会解析为多个stage\",{\"1\":{\"446\":1}}],[\"会忽略掉非\",{\"1\":{\"1455\":1}}],[\"会注册\",{\"1\":{\"1455\":1}}],[\"会利用\",{\"1\":{\"1438\":1}}],[\"会利用系统提供的发送缓冲区\",{\"1\":{\"850\":1}}],[\"会设置\",{\"1\":{\"1394\":1}}],[\"会综合利用本类的\",{\"1\":{\"1382\":1,\"1390\":1}}],[\"会以类为单位\",{\"1\":{\"1382\":1,\"1390\":1,\"1410\":1}}],[\"会包含局部变量表\",{\"1\":{\"1366\":1}}],[\"会准备\",{\"1\":{\"1355\":1}}],[\"会收集所有\",{\"1\":{\"1355\":1}}],[\"会借助\",{\"1\":{\"1322\":1}}],[\"会动态生成两个类\",{\"1\":{\"1321\":1}}],[\"会用到\",{\"1\":{\"1370\":1}}],[\"会用\",{\"1\":{\"1310\":1,\"1313\":1}}],[\"会用基于hdfs客户端所在的linux\",{\"1\":{\"922\":1}}],[\"会跳过依赖注入阶段\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"会跳到19行执行异常处理部分\",{\"1\":{\"541\":1}}],[\"会销毁所有单例对象\",{\"1\":{\"1252\":1}}],[\"会被当成字符串来处理\",{\"1\":{\"1230\":1}}],[\"会被解析成\",{\"1\":{\"1230\":1}}],[\"会带来额外的内存开销\",{\"1\":{\"1223\":1}}],[\"会进入redis\",{\"1\":{\"1199\":1}}],[\"会进行串行操作\",{\"1\":{\"1155\":1}}],[\"会进行如下操作\",{\"1\":{\"659\":2}}],[\"会进行不同的处理\",{\"1\":{\"157\":1}}],[\"会出现一系列的商家\",{\"1\":{\"1171\":1}}],[\"会出现线程安全问题\",{\"1\":{\"66\":1}}],[\"会访问到\",{\"1\":{\"1155\":1}}],[\"会访问我们像tomcat注册的端口\",{\"1\":{\"1100\":1}}],[\"会有大量的磁盘io\",{\"1\":{\"1189\":1}}],[\"会有一个版本号\",{\"1\":{\"1135\":1}}],[\"会有较大的开销\",{\"1\":{\"191\":1}}],[\"会构筑多级缓存来使系统运行速度进一步提升\",{\"1\":{\"1115\":1}}],[\"会去校验是否比之前的版本大1\",{\"1\":{\"1135\":1}}],[\"会去携带着token进行访问\",{\"1\":{\"1106\":1}}],[\"会去获取要观察的对象的最新状态\",{\"1\":{\"46\":1}}],[\"会校验手机号是否合法\",{\"1\":{\"1098\":1}}],[\"会为具有一组共同字段的文档定义一个类型\",{\"1\":{\"1062\":1}}],[\"会为每个任务分配一个\",{\"1\":{\"948\":1}}],[\"会不断地从leader中同步副本\",{\"1\":{\"1054\":1}}],[\"会不方便实现\",{\"1\":{\"189\":1}}],[\"会选择使用mysql集群\",{\"1\":{\"1094\":1}}],[\"会选择先从索引中查询id\",{\"1\":{\"455\":1}}],[\"会选举一个follower重新成为分区的leader\",{\"1\":{\"1048\":1}}],[\"会尽量分配分区的leader在不同的broker中\",{\"1\":{\"1048\":1}}],[\"会打散分布在不同的partition中\",{\"1\":{\"1035\":1}}],[\"会打印\",{\"1\":{\"766\":1}}],[\"会成为新的\",{\"1\":{\"1026\":1}}],[\"会先对其进行分区处理\",{\"1\":{\"979\":1}}],[\"会阻塞整个会话窗口\",{\"1\":{\"1195\":1}}],[\"会阻塞直到\",{\"1\":{\"867\":1}}],[\"会阻塞线程池中所有线程\",{\"1\":{\"826\":1}}],[\"会参与拷贝\",{\"1\":{\"854\":2,\"855\":1}}],[\"会切换至操作系统内核态来完成真正数据读取\",{\"1\":{\"851\":1}}],[\"会拿到物理\",{\"1\":{\"847\":1}}],[\"会每次可写均会触发\",{\"1\":{\"843\":1}}],[\"会取消注册在\",{\"1\":{\"838\":1}}],[\"会取消下一次的\",{\"1\":{\"742\":1}}],[\"会返回\",{\"1\":{\"827\":2}}],[\"会返回左边表的记录\",{\"1\":{\"324\":1}}],[\"会抛异常\",{\"1\":{\"822\":4}}],[\"会抛出\",{\"1\":{\"725\":1}}],[\"会输出\",{\"1\":{\"821\":1}}],[\"会追加内容\",{\"1\":{\"817\":1}}],[\"会从cookie中携带者jsessionid到后台\",{\"1\":{\"1098\":1}}],[\"会从\",{\"1\":{\"814\":1}}],[\"会变成其它类型对象\",{\"1\":{\"787\":1}}],[\"会始终为\",{\"1\":{\"779\":1}}],[\"会报\",{\"1\":{\"776\":1}}],[\"会报错\",{\"1\":{\"773\":1}}],[\"会负责释放未处理消息\",{\"1\":{\"775\":1}}],[\"会继续向上传播\",{\"1\":{\"765\":1}}],[\"会再用\",{\"1\":{\"762\":1}}],[\"会再次相应应用程序并通知此事件\",{\"1\":{\"680\":1}}],[\"会回调\",{\"1\":{\"753\":1}}],[\"会本次的\",{\"1\":{\"742\":1}}],[\"会唤醒当前在执行\",{\"1\":{\"742\":1}}],[\"会匹配\",{\"1\":{\"741\":1}}],[\"会执行一次\",{\"1\":{\"741\":1}}],[\"会执行到下面的\",{\"1\":{\"741\":1}}],[\"会启动\",{\"1\":{\"740\":1}}],[\"会启动一个mr对物化视图进行构建\",{\"1\":{\"276\":1}}],[\"会由\",{\"1\":{\"740\":1}}],[\"会由操作系统唤醒阻塞的线程\",{\"1\":{\"538\":1}}],[\"会触发右侧的请求\",{\"1\":{\"1134\":1}}],[\"会触发多次读取事件\",{\"1\":{\"833\":1}}],[\"会触发\",{\"1\":{\"710\":1,\"828\":1,\"833\":2}}],[\"会触发一个\",{\"1\":{\"707\":2}}],[\"会话结束时销毁\",{\"1\":{\"1290\":1}}],[\"会话绑定用户\",{\"1\":{\"701\":1}}],[\"会话管理接口\",{\"1\":{\"701\":1}}],[\"会造成粘包\",{\"1\":{\"694\":1}}],[\"会造成严重的资源浪费\",{\"1\":{\"176\":1}}],[\"会向cpu发出相应的中断信号\",{\"1\":{\"676\":1}}],[\"会分配\",{\"1\":{\"663\":1}}],[\"会优先检查未使用空间是否足够\",{\"1\":{\"663\":1}}],[\"会优先选择\",{\"1\":{\"105\":1}}],[\"会显式触发full\",{\"1\":{\"635\":1}}],[\"会做什么事情\",{\"1\":{\"633\":1}}],[\"会存在线程安全问题\",{\"1\":{\"627\":1}}],[\"会连同t3一起唤醒\",{\"1\":{\"583\":1}}],[\"会放入无界队列排队\",{\"1\":{\"574\":1}}],[\"会生成新的\",{\"1\":{\"566\":1}}],[\"会在第\",{\"1\":{\"1438\":1}}],[\"会在\",{\"1\":{\"1252\":1,\"1489\":1}}],[\"会在mapper的初始化方法setup中读取分布式缓存文件加载的程序的内存中\",{\"1\":{\"990\":1}}],[\"会在没有数据可读时让线程暂停\",{\"1\":{\"826\":1}}],[\"会在没有连接建立时让线程暂停\",{\"1\":{\"826\":1}}],[\"会在连接建立时被调用\",{\"1\":{\"753\":1}}],[\"会在连接\",{\"1\":{\"710\":1}}],[\"会在打断后清为false\",{\"1\":{\"534\":1}}],[\"会在每个stripe中\",{\"1\":{\"437\":1}}],[\"会首先写入buffer\",{\"1\":{\"506\":1}}],[\"会将数据写入内存\",{\"1\":{\"979\":1}}],[\"会将数据缓存\",{\"1\":{\"819\":1}}],[\"会将数据切分发送\",{\"1\":{\"694\":1}}],[\"会将底层内存数据进行深拷贝\",{\"1\":{\"778\":1}}],[\"会将counter置为1\",{\"1\":{\"549\":1}}],[\"会将读取到的数据中的事务id与trx\",{\"1\":{\"503\":1}}],[\"会将100字符串转换为100整数值\",{\"1\":{\"248\":1}}],[\"会通过getsplits方法对输入目录中文件进行逻辑规划得到splits\",{\"1\":{\"979\":1}}],[\"会通过数据库自身的锁机制来实现\",{\"1\":{\"507\":1}}],[\"会通过查询数据字典将\",{\"1\":{\"498\":1}}],[\"会通知给观察者\",{\"1\":{\"45\":1}}],[\"会置入字段名和属性值\",{\"1\":{\"483\":3}}],[\"会统计值为null的行\",{\"1\":{\"482\":2}}],[\"会翻开第11章对应的那一页吗\",{\"1\":{\"481\":1}}],[\"会列出运行查询划分的stage阶段以及之间的依赖关系\",{\"1\":{\"442\":1}}],[\"会根据min\",{\"1\":{\"437\":1}}],[\"会使得垃圾回收的总成本上升\",{\"1\":{\"634\":1}}],[\"会使用\",{\"1\":{\"665\":2}}],[\"会使用不同空间大小的\",{\"1\":{\"665\":1}}],[\"会使用key\",{\"1\":{\"497\":1}}],[\"会使用表的最后一级目录作为底层处理数据的输入\",{\"1\":{\"413\":1}}],[\"会使整个系统的效率降低\",{\"1\":{\"165\":1}}],[\"会编译期间会自动设置只启动一个reduce\",{\"1\":{\"351\":1}}],[\"会转换为两个mr作业\",{\"1\":{\"326\":1}}],[\"会检查where子句或join中的on子句中是否有分区字段\",{\"1\":{\"305\":1}}],[\"会导致只能在本地访问\",{\"1\":{\"1196\":1}}],[\"会导致每个线程进来都会锁住\",{\"1\":{\"1137\":1}}],[\"会导致并发性问题\",{\"1\":{\"1136\":1}}],[\"会导致内存重新分配\",{\"1\":{\"667\":1}}],[\"会导致线程上下文切换\",{\"1\":{\"538\":1}}],[\"会导致索引失效而转向全表扫描\",{\"1\":{\"505\":1}}],[\"会导致大量磁盘和网络的io损耗\",{\"1\":{\"413\":1}}],[\"会导致大的空闲区迅速被用完\",{\"1\":{\"183\":1}}],[\"会导致缺页频繁\",{\"1\":{\"192\":1}}],[\"会导致资源浪费\",{\"1\":{\"176\":1}}],[\"会产生磁盘碎片\",{\"1\":{\"197\":1}}],[\"会产生外部碎片\",{\"1\":{\"188\":1}}],[\"会产生很多的外部碎片\",{\"1\":{\"183\":1}}],[\"会产生内部碎片\",{\"1\":{\"182\":1}}],[\"会留下越来越多的又小又难利用的内存块\",{\"1\":{\"183\":1}}],[\"会\",{\"1\":{\"167\":3,\"766\":1}}],[\"会引起进程切换\",{\"1\":{\"163\":1}}],[\"会发现其中已经自动聚合了子工程\",{\"1\":{\"115\":1}}],[\"会按照\",{\"1\":{\"694\":1}}],[\"会按照自己的原则\",{\"1\":{\"105\":1}}],[\"会按照坐标保存到指定位置\",{\"1\":{\"95\":1}}],[\"会自动触发淘汰机制\",{\"1\":{\"1119\":1}}],[\"会自动调用oncompletion方法\",{\"1\":{\"1025\":1}}],[\"会自动将扩大\",{\"1\":{\"663\":1}}],[\"会自动转移到slave\",{\"1\":{\"526\":1}}],[\"会自动把b\",{\"1\":{\"104\":1}}],[\"会自动打包编译到classes文件夹下\",{\"1\":{\"102\":1}}],[\"此实现会与当前线程绑定\",{\"1\":{\"1455\":1}}],[\"此接口并没有传递任何的参数\",{\"1\":{\"1175\":1}}],[\"此逻辑就是续约逻辑\",{\"1\":{\"1152\":1}}],[\"此方法可以延迟真实\",{\"1\":{\"1489\":1}}],[\"此方法可以延迟\",{\"1\":{\"1489\":1}}],[\"此方法可以保证加锁和增加过期时间具有原子性\",{\"1\":{\"1142\":1}}],[\"此方法\",{\"1\":{\"1152\":1}}],[\"此方法会被调用\",{\"1\":{\"1152\":1}}],[\"此方案的优点在于组映射服务十分稳定\",{\"1\":{\"924\":1}}],[\"此影响可以忽略\",{\"1\":{\"995\":1}}],[\"此案例中把商品数据进行分布式缓存\",{\"1\":{\"990\":1}}],[\"此业务是统计单词个数\",{\"1\":{\"961\":1}}],[\"此策略可以使3x复制方案目录与纠删码目录交错\",{\"1\":{\"875\":1}}],[\"此后\",{\"1\":{\"709\":1}}],[\"此种操作就可以用token的机制实现防止重复提交\",{\"1\":{\"1005\":1}}],[\"此种方式容易出现sql注入\",{\"1\":{\"483\":1}}],[\"此种模式下\",{\"1\":{\"242\":1}}],[\"此场景下\",{\"1\":{\"351\":1}}],[\"此层存放未经过处理的原始数据至数据仓库系统\",{\"1\":{\"225\":1}}],[\"此次读\",{\"1\":{\"204\":1}}],[\"此指令不允许用户程序使用\",{\"1\":{\"156\":1}}],[\"此处返回的是成功删除的key\",{\"1\":{\"1205\":1}}],[\"此处选择的linux版本为centos\",{\"1\":{\"1191\":1}}],[\"此处要维护\",{\"1\":{\"1186\":1}}],[\"此处是分区裁剪\",{\"1\":{\"307\":1}}],[\"此处的同时往往是宏观上的\",{\"1\":{\"155\":1}}],[\"此处会问java对象的创建过程\",{\"1\":{\"66\":1}}],[\"此时用的是外置\",{\"1\":{\"1442\":1}}],[\"此时又分两种情况\",{\"1\":{\"1411\":1}}],[\"此时走\",{\"1\":{\"1394\":2}}],[\"此时需找到默认视图名\",{\"1\":{\"1394\":2}}],[\"此时需要进行\",{\"1\":{\"1042\":1}}],[\"此时我们再来看一看存储的数据\",{\"1\":{\"1223\":1}}],[\"此时我们去写命令\",{\"1\":{\"1153\":1}}],[\"此时如果使用id作为key\",{\"1\":{\"1207\":1}}],[\"此时已经没有了\",{\"1\":{\"1177\":1}}],[\"此时这个11放到最顶上\",{\"1\":{\"1167\":1}}],[\"此时这个timetask\",{\"1\":{\"1152\":1}}],[\"此时t3时刻来拿第二页\",{\"1\":{\"1167\":1}}],[\"此时t3\",{\"1\":{\"1167\":1}}],[\"此时系统会从他关注的人群中\",{\"1\":{\"1166\":1}}],[\"此时的是多线程\",{\"1\":{\"1157\":1}}],[\"此时的复杂度就是\",{\"1\":{\"665\":1}}],[\"此时才是加锁成功\",{\"1\":{\"1153\":1}}],[\"此时锁信息就已经丢掉了\",{\"1\":{\"1153\":1}}],[\"此时主机宕机\",{\"1\":{\"1153\":1}}],[\"此时第二个线程能够正确释放锁\",{\"1\":{\"1144\":1}}],[\"此时第一个线程由于锁的value值并非是自己\",{\"1\":{\"1144\":1}}],[\"此时第一个分组已有100个块\",{\"1\":{\"198\":1}}],[\"此时进入到锁内部\",{\"1\":{\"1144\":1}}],[\"此时进入核心态\",{\"1\":{\"157\":1}}],[\"此时await就不再阻塞\",{\"1\":{\"1132\":1}}],[\"此时要么你去修改原来的实体类\",{\"1\":{\"1128\":1}}],[\"此时线程1反应过来\",{\"1\":{\"1143\":1}}],[\"此时线程1去获得互斥锁\",{\"1\":{\"1126\":1}}],[\"此时线程2执行\",{\"1\":{\"1135\":1}}],[\"此时线程2过来\",{\"1\":{\"1121\":1,\"1135\":1}}],[\"此时只要线程1走完这个逻辑\",{\"1\":{\"1126\":1}}],[\"此时会主动的把张三写的内容发送到他的粉丝收件箱中去\",{\"1\":{\"1166\":1}}],[\"此时会请求\",{\"1\":{\"1155\":1}}],[\"此时会访问到数据库\",{\"1\":{\"1123\":1}}],[\"此时会帮忙扩容\",{\"1\":{\"579\":1}}],[\"此时他写入缓存\",{\"1\":{\"1121\":1}}],[\"此时监听线程会从tomcat的线程池中取出一个线程执行用户请求\",{\"1\":{\"1100\":1}}],[\"此时也需要发生再均衡\",{\"1\":{\"1037\":1}}],[\"此时再次调用支付\",{\"1\":{\"1003\":1}}],[\"此时在\",{\"1\":{\"910\":1}}],[\"此时buf没有被释放\",{\"1\":{\"776\":1}}],[\"此时os将利用请求调页\",{\"1\":{\"688\":1}}],[\"此时i是一个静态变量\",{\"1\":{\"560\":1}}],[\"此时就能找到这个用户截止这天的所有签到记录\",{\"1\":{\"1176\":1}}],[\"此时就能够从缓存中拿到数据了\",{\"1\":{\"1126\":1}}],[\"此时就将新值去替换\",{\"1\":{\"1135\":1}}],[\"此时就会把本应该属于线程2的锁进行删除\",{\"1\":{\"1143\":1}}],[\"此时就会出现库存的超卖问题\",{\"1\":{\"1135\":1}}],[\"此时就会有一致性问题存在\",{\"1\":{\"1120\":1}}],[\"此时就会导致以下结果\",{\"1\":{\"530\":1}}],[\"此时就可能会导致缓存中的数据过多\",{\"1\":{\"1119\":1}}],[\"此时就可以利用建造者模式进行重构\",{\"1\":{\"17\":1}}],[\"此时就需要对压缩列表的空间重分配操作\",{\"1\":{\"666\":1}}],[\"此时缺页的进程阻塞\",{\"1\":{\"190\":1}}],[\"此时不得不采取覆盖技术来解决\",{\"1\":{\"182\":1}}],[\"此时可以换出一些进程\",{\"1\":{\"181\":1}}],[\"此时一定没有发生死锁\",{\"1\":{\"178\":1}}],[\"此时请求进程被阻塞\",{\"1\":{\"175\":1}}],[\"此时读进程的read\",{\"1\":{\"162\":1}}],[\"此时cpu只能执行非特权指令\",{\"1\":{\"156\":1}}],[\"此时\",{\"1\":{\"115\":1,\"530\":1,\"666\":1,\"1025\":1,\"1152\":1,\"1167\":1}}],[\"此时映射文件就不会被打包\",{\"1\":{\"102\":1}}],[\"此外也支持用户通过xml文件定义自己的ec策略\",{\"1\":{\"875\":1}}],[\"此外还支持一次添加多个分区\",{\"1\":{\"280\":1}}],[\"此外\",{\"1\":{\"46\":1,\"506\":1}}],[\"观察\",{\"1\":{\"1293\":1,\"1466\":1}}],[\"观察结果\",{\"1\":{\"1019\":1}}],[\"观察对象\",{\"1\":{\"46\":1}}],[\"观察者\",{\"1\":{\"45\":1,\"46\":1}}],[\"观察者模式\",{\"0\":{\"44\":1}}],[\"可将handlermapping看作路由控制器\",{\"1\":{\"1530\":1}}],[\"可将操作系统保留的空闲物理块分配给缺页进程\",{\"1\":{\"192\":1}}],[\"可根据是否满足指定的条件来决定是否进行bean的实例化及装配\",{\"1\":{\"1525\":1}}],[\"可根据自身情况做调整\",{\"1\":{\"1001\":1}}],[\"可作为请求的统一入口\",{\"1\":{\"1438\":1}}],[\"可排序\",{\"1\":{\"1211\":1}}],[\"可重入\",{\"1\":{\"1150\":1}}],[\"可重入锁原理\",{\"0\":{\"1151\":1}}],[\"可重入锁的意义在于防止死锁\",{\"1\":{\"1149\":1}}],[\"可重入锁\",{\"1\":{\"1135\":1}}],[\"可重入是通过不断通过cas操作将state的值+1实现的\",{\"1\":{\"582\":1}}],[\"可执行权限\",{\"1\":{\"1046\":1}}],[\"可用雪花算法服务上线时间戳的值\",{\"1\":{\"999\":1}}],[\"可用于允许来自任何主机或任何用户的模拟\",{\"1\":{\"927\":1}}],[\"可用于元数据的修复\",{\"1\":{\"281\":1}}],[\"可用于进程调度\",{\"1\":{\"167\":1}}],[\"可用于作业调度也可用于进程调度\",{\"1\":{\"167\":1}}],[\"可运行完成并正常退出的应用程序\",{\"1\":{\"951\":1}}],[\"可运行状态\",{\"1\":{\"538\":2}}],[\"可配合\",{\"1\":{\"850\":1}}],[\"可读性差\",{\"1\":{\"1222\":1}}],[\"可读写事件的监控\",{\"1\":{\"828\":1}}],[\"可读或可接入事件\",{\"1\":{\"742\":1}}],[\"可写\",{\"1\":{\"828\":1,\"833\":1}}],[\"可写事件\",{\"1\":{\"742\":1}}],[\"可写或者except\",{\"1\":{\"680\":1}}],[\"可是后来也就想通了\",{\"1\":{\"709\":1}}],[\"可采用离散分配的方式\",{\"1\":{\"683\":1}}],[\"可采用上述二者组合的方式\",{\"1\":{\"163\":1}}],[\"可在子类中被重新定义\",{\"1\":{\"595\":1}}],[\"可在相关联的表中冗余存储类目名称\",{\"1\":{\"480\":1}}],[\"可水平扩展\",{\"1\":{\"527\":1}}],[\"可靠性不高\",{\"1\":{\"501\":1}}],[\"可选\",{\"1\":{\"259\":1,\"264\":1,\"365\":2}}],[\"可选操作\",{\"1\":{\"112\":1}}],[\"可同时分配给多个进程使用\",{\"1\":{\"213\":2}}],[\"可变参数\",{\"1\":{\"396\":1}}],[\"可变长记录\",{\"1\":{\"195\":1}}],[\"可变分配\",{\"1\":{\"192\":2}}],[\"可变分区分配\",{\"1\":{\"182\":1}}],[\"可修改的代码不能实现共享\",{\"1\":{\"187\":1}}],[\"可换出低优先级的进程\",{\"1\":{\"181\":1}}],[\"可优先换出阻塞进程\",{\"1\":{\"181\":1}}],[\"可灵活地的调整对各种作业\",{\"1\":{\"167\":1}}],[\"可\",{\"1\":{\"167\":1}}],[\"可能起到反作用\",{\"1\":{\"1166\":1}}],[\"可能出现误删别人锁的问题\",{\"1\":{\"1147\":1}}],[\"可能出现服务器时钟回拨问题\",{\"1\":{\"999\":2}}],[\"可能是生产者一个程序\",{\"1\":{\"1010\":1}}],[\"可能是秒级\",{\"1\":{\"951\":1}}],[\"可能造成短期的不一致\",{\"1\":{\"1123\":1}}],[\"可能造成内存泄漏\",{\"1\":{\"801\":1}}],[\"可能造成数据拥堵\",{\"1\":{\"351\":1}}],[\"可能有性能问题\",{\"1\":{\"680\":1}}],[\"可能延迟还更大\",{\"1\":{\"679\":1}}],[\"可能导致队列中的线程长期处于饥饿状态\",{\"1\":{\"588\":1}}],[\"可能导致小文件大小超过10m\",{\"1\":{\"477\":1}}],[\"可能需要中序遍历\",{\"1\":{\"488\":1}}],[\"可能产生多次缺页中断\",{\"1\":{\"190\":1}}],[\"可能产生饥饿现象\",{\"1\":{\"167\":1}}],[\"可能所有的分区都不能满足\",{\"1\":{\"182\":1}}],[\"可能使长作业\",{\"1\":{\"167\":1}}],[\"可能会导致当前方法事务还没有提交\",{\"1\":{\"1137\":1}}],[\"可能会导致后续元素的\",{\"1\":{\"666\":1}}],[\"可能会有数据丢失\",{\"1\":{\"1053\":1}}],[\"可能会有很多在master里没过期的数据其实已经过期了\",{\"1\":{\"530\":1}}],[\"可能会数据丢失\",{\"1\":{\"1043\":1}}],[\"可能会遇到如下的几个问题\",{\"1\":{\"1003\":1}}],[\"可能会直接将原始的数据破坏掉\",{\"1\":{\"912\":1}}],[\"可能会好奇为什么最后一个字符是\",{\"1\":{\"662\":1}}],[\"可能会出现延迟\",{\"1\":{\"1102\":1}}],[\"可能会出现饥饿现象\",{\"1\":{\"553\":1}}],[\"可能会出现空指针问题\",{\"1\":{\"66\":1}}],[\"可能会发生依赖项下载错误的情况\",{\"1\":{\"101\":1}}],[\"可见性\",{\"1\":{\"556\":1,\"1140\":1}}],[\"可见\",{\"1\":{\"44\":1,\"78\":1}}],[\"可以拓展一下sso单点登录来讲项目\",{\"1\":{\"1532\":1}}],[\"可以与云计算天然集成\",{\"1\":{\"1520\":1}}],[\"可以极大地提高开发\",{\"1\":{\"1520\":1}}],[\"可以快速构建项目\",{\"1\":{\"1520\":1}}],[\"可以有多种源用来加载\",{\"1\":{\"1446\":1}}],[\"可以注册多个\",{\"1\":{\"1369\":1}}],[\"可以拿到参数名\",{\"1\":{\"1366\":1}}],[\"可以生成调试信息\",{\"1\":{\"1366\":1}}],[\"可以生成参数表\",{\"1\":{\"1366\":1}}],[\"可以生成212=4096个不重复\",{\"1\":{\"998\":1}}],[\"可以省略目标对象\",{\"1\":{\"1317\":1}}],[\"可以解析控制器的\",{\"1\":{\"1376\":1}}],[\"可以解析\",{\"1\":{\"1270\":2}}],[\"可以完成依赖注入\",{\"1\":{\"1267\":1}}],[\"可以针对单个字段做crud\",{\"1\":{\"1208\":1}}],[\"可以做自增\",{\"1\":{\"1206\":2}}],[\"可以查看一个命令的具体用法\",{\"1\":{\"1205\":1}}],[\"可以查看到不同的命令\",{\"1\":{\"1204\":1}}],[\"可以查看更加详细的使用说明\",{\"1\":{\"328\":1}}],[\"可以保存海量数据\",{\"1\":{\"1189\":1}}],[\"可以保证数据库表中每一行数据的唯一性\",{\"1\":{\"485\":1}}],[\"可以进行范围查询\",{\"1\":{\"1167\":1}}],[\"可以进行数据读写操作\",{\"1\":{\"785\":1}}],[\"可以实现分页查询\",{\"1\":{\"1167\":1}}],[\"可以实现基于lua直接绕开tomcat访问redis\",{\"1\":{\"1094\":1}}],[\"可以对主流开发框架的无配置集成\",{\"1\":{\"1520\":1}}],[\"可以对构造方法\",{\"1\":{\"1300\":1}}],[\"可以对用户进行关注和取消关注功能\",{\"1\":{\"1164\":1}}],[\"可以对多个项目进行顺序控制\",{\"1\":{\"108\":1}}],[\"可以点赞\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"可以依赖于我们接下来要学习redission啦\",{\"1\":{\"1147\":1}}],[\"可以利用线程池进行异步发事件优化\",{\"1\":{\"1497\":1}}],[\"可以利用execute方法去执行lua脚本\",{\"1\":{\"1147\":1}}],[\"可以利用该机制将数据缓存在某个线程内部\",{\"1\":{\"577\":1}}],[\"可以作为参数传递\",{\"1\":{\"1146\":1}}],[\"可以分为tomcat本地缓存\",{\"1\":{\"1115\":1}}],[\"可以分为表锁\",{\"1\":{\"509\":1}}],[\"可以被放置到集群中的任何节点上\",{\"1\":{\"1066\":1}}],[\"可以定义任意多的索引\",{\"1\":{\"1061\":1}}],[\"可以限制producer\",{\"1\":{\"1056\":1}}],[\"可以选择0\",{\"1\":{\"1043\":1}}],[\"可以选择雪花算法生成全局唯一id\",{\"1\":{\"1005\":1}}],[\"可以最大限度保证所有消息平均分配到一个分区\",{\"1\":{\"1032\":1}}],[\"可以包含多个分区\",{\"1\":{\"1026\":1}}],[\"可以包含多个\",{\"1\":{\"1026\":1}}],[\"可以很方便地使用带有回调函数来发送消息\",{\"1\":{\"1025\":1}}],[\"可以应对大量并发\",{\"1\":{\"1009\":1}}],[\"可以订制并设置到job上\",{\"1\":{\"979\":1}}],[\"可以自定义属性\",{\"1\":{\"1232\":1}}],[\"可以自己设置策略方式\",{\"1\":{\"1119\":1}}],[\"可以自己制定reducetask的个数\",{\"1\":{\"968\":1}}],[\"可以自动扩容\",{\"1\":{\"781\":1}}],[\"可以自动地将hql生成为抽象语法树\",{\"1\":{\"442\":1}}],[\"可以自动的判断是否是小文件\",{\"1\":{\"435\":1}}],[\"可以自动化构建\",{\"1\":{\"91\":1}}],[\"可以临时的为用户针对要操作的数据来创建一个snapshot\",{\"1\":{\"912\":1}}],[\"可以并行处理块组中的多个内部块\",{\"1\":{\"875\":1}}],[\"可以任意丢两个\",{\"1\":{\"875\":1}}],[\"可以接受读数据请求\",{\"1\":{\"870\":1}}],[\"可以从\",{\"1\":{\"861\":1}}],[\"可以从json字符串中返回指定的某个对象列的值\",{\"1\":{\"395\":1}}],[\"可以去执行其它\",{\"1\":{\"827\":1}}],[\"可以发现即使不写入数据\",{\"1\":{\"795\":1}}],[\"可以简单理解为\",{\"1\":{\"784\":1}}],[\"可以重用池中\",{\"1\":{\"781\":1}}],[\"可以循环调用\",{\"1\":{\"775\":1}}],[\"可以主动创建\",{\"1\":{\"759\":1}}],[\"可以同步等待任务结束得到结果\",{\"1\":{\"756\":1}}],[\"可以同时作为入站和出站处理器\",{\"1\":{\"707\":2}}],[\"可以计算一下\",{\"1\":{\"755\":1}}],[\"可以提高遍历性能\",{\"1\":{\"742\":1}}],[\"可以调用\",{\"1\":{\"803\":1,\"819\":1}}],[\"可以调用空参\",{\"1\":{\"629\":1}}],[\"可以调节发布者发布数据的速率\",{\"1\":{\"719\":1}}],[\"可以继承\",{\"1\":{\"714\":1}}],[\"可以继续操作\",{\"1\":{\"662\":1}}],[\"可以继续遍历第二个文件\",{\"1\":{\"477\":1}}],[\"可以支持协议的升级\",{\"1\":{\"712\":1}}],[\"可以访问受保护的内存空间\",{\"1\":{\"676\":1}}],[\"可以看做是一个value为null的hashmap\",{\"1\":{\"1210\":1}}],[\"可以看做是一个双向链表结构\",{\"1\":{\"1209\":1}}],[\"可以看得出\",{\"1\":{\"663\":1}}],[\"可以看到中间环节较多\",{\"1\":{\"854\":1}}],[\"可以看到两个工人轮流处理\",{\"1\":{\"748\":1}}],[\"可以看到接收的消息被分为两节\",{\"1\":{\"693\":1}}],[\"可以看到一次就接收了\",{\"1\":{\"692\":1}}],[\"可以看到\",{\"1\":{\"663\":1,\"748\":1,\"766\":1,\"855\":1,\"857\":1,\"1240\":1}}],[\"可以看到调用了无参的抽象的\",{\"1\":{\"88\":1}}],[\"可以算出剩余可用的空间大小\",{\"1\":{\"663\":1}}],[\"可以容纳多个topic\",{\"1\":{\"1026\":1}}],[\"可以容纳\",{\"1\":{\"662\":1}}],[\"可以更轻松地使用内存块\",{\"1\":{\"610\":1}}],[\"可以更加精细地控制产品的创建过程\",{\"1\":{\"15\":1}}],[\"可以传入一个int型整数n\",{\"1\":{\"591\":1}}],[\"可以传递\",{\"1\":{\"104\":1}}],[\"可以强转后调用\",{\"1\":{\"574\":1}}],[\"可以无限创建\",{\"1\":{\"574\":1}}],[\"可以放任意数量的任务\",{\"1\":{\"574\":1}}],[\"可以放到不相邻的页框中\",{\"1\":{\"184\":1}}],[\"可以想到重试必然频繁发生\",{\"1\":{\"561\":1}}],[\"可以由自己编写\",{\"1\":{\"1333\":1}}],[\"可以由此扩展\",{\"1\":{\"712\":1}}],[\"可以由cpu调度使用\",{\"1\":{\"538\":1}}],[\"可以由操作系统协助\",{\"1\":{\"176\":1}}],[\"可以采用日志重演操作记录\",{\"1\":{\"882\":1}}],[\"可以采用线程池技术来减少线程数和线程上下文切换\",{\"1\":{\"826\":1}}],[\"可以采用了\",{\"1\":{\"663\":1}}],[\"可以采用一下几种方式\",{\"1\":{\"505\":1}}],[\"可以采用覆盖技术扩充内存\",{\"1\":{\"182\":1}}],[\"可以增加联合索引的使用率\",{\"1\":{\"493\":1}}],[\"可以加速表和表之间的连接\",{\"1\":{\"485\":1}}],[\"可以大大加快查询速度\",{\"1\":{\"485\":1}}],[\"可以用\",{\"1\":{\"1525\":1}}],[\"可以用uuid表示\",{\"1\":{\"1144\":1}}],[\"可以用此对之前redis用户注册部分进行改进\",{\"1\":{\"1009\":1}}],[\"可以用gt逆矩阵乘以码字向量来恢复出丢失的数据块\",{\"1\":{\"875\":1}}],[\"可以用hadoop\",{\"1\":{\"872\":1}}],[\"可以用来包装\",{\"1\":{\"780\":1}}],[\"可以用来关闭\",{\"1\":{\"752\":1}}],[\"可以用来执行定时任务\",{\"1\":{\"751\":1}}],[\"可以用来执行耗时较长的任务\",{\"1\":{\"750\":1}}],[\"可以用来判断空间是否满足修改需求\",{\"1\":{\"663\":1}}],[\"可以用一个线程处理若干个客户端连接\",{\"1\":{\"610\":1}}],[\"可以用一个信号量来表示当前系统中某种资源的数量\",{\"1\":{\"171\":1}}],[\"可以用新遍历到的词替换堆顶的词\",{\"1\":{\"477\":1}}],[\"可以得到500个小文件\",{\"1\":{\"477\":1}}],[\"可以直接检索数据返回\",{\"1\":{\"455\":1}}],[\"可以直接访问这些对象的方法\",{\"1\":{\"76\":1}}],[\"可以直接访问\",{\"1\":{\"64\":1}}],[\"可以尽量放在同一个mapreduce中实现\",{\"1\":{\"453\":1}}],[\"可以了解一条hql语句在底层是如何实现数据的查询及处理的过程\",{\"1\":{\"440\":1}}],[\"可以根据xml配置\",{\"1\":{\"1530\":1}}],[\"可以根据这个offset找到segment段\",{\"1\":{\"1052\":1}}],[\"可以根据\",{\"1\":{\"723\":1}}],[\"可以根据槽位定位算法定位到目标节点\",{\"1\":{\"528\":1}}],[\"可以根据索引提前对数据进行过滤\",{\"1\":{\"437\":1}}],[\"可以根据情况做出适当的增加或减少\",{\"1\":{\"192\":1}}],[\"可以指定日志文件名\",{\"1\":{\"1196\":1}}],[\"可以指定具体的快照名\",{\"1\":{\"914\":1}}],[\"可以指定构建索引\",{\"1\":{\"437\":1}}],[\"可以指定依赖生效范围\",{\"1\":{\"99\":1}}],[\"可以降低存储空间\",{\"1\":{\"426\":1}}],[\"可以基于score属性对元素排序\",{\"1\":{\"1211\":1}}],[\"可以基于字段的索引快速的实现查询\",{\"1\":{\"420\":1}}],[\"可以基本保持软件架构的稳定\",{\"1\":{\"72\":1}}],[\"可以写个java程序来清洗数据即可\",{\"1\":{\"373\":1}}],[\"可以先去重\",{\"1\":{\"351\":1}}],[\"可以理解为当前有几个follower是存活的\",{\"1\":{\"1049\":1}}],[\"可以理解为是一个容器对象\",{\"1\":{\"610\":1}}],[\"可以理解为一个标记位\",{\"1\":{\"549\":1}}],[\"可以理解为一种可供应用程序调用的特殊函数\",{\"1\":{\"158\":1}}],[\"可以理解为行级别的共享锁和排他锁\",{\"1\":{\"511\":1}}],[\"可以理解为把from语句中查询到的看成一张表\",{\"1\":{\"316\":1}}],[\"可以手动指定为desc\",{\"1\":{\"312\":1}}],[\"可以下载下来直接查看\",{\"1\":{\"293\":1}}],[\"可以本地存储在hive\",{\"1\":{\"274\":1}}],[\"可以认为数据集市是数据仓库的子集\",{\"1\":{\"223\":1}}],[\"可以让事务在遇到非运行时异常时也会回滚\",{\"1\":{\"1516\":1}}],[\"可以让客户端和服务端进行双向通信\",{\"1\":{\"1499\":1}}],[\"可以让redis开机自启\",{\"1\":{\"1197\":1}}],[\"可以让a打开文件得到一个文件描述符\",{\"1\":{\"872\":1}}],[\"可以让链表可以快速的插入\",{\"1\":{\"518\":1}}],[\"可以让多个用户共享的适用同一个文件\",{\"1\":{\"200\":1}}],[\"可以让进程尝试让对方先使用临界区\",{\"1\":{\"169\":1}}],[\"可以为每道工序指定不同的工人\",{\"1\":{\"787\":1}}],[\"可以为表中的字段单独构建索引\",{\"1\":{\"420\":1}}],[\"可以为文件分配离散的磁盘块\",{\"1\":{\"197\":1}}],[\"可以为其定义一个抽象类\",{\"1\":{\"72\":1}}],[\"可以使用69年\",{\"1\":{\"1131\":1}}],[\"可以使用消息队列作为临时存储\",{\"1\":{\"1009\":1}}],[\"可以使用数字\",{\"1\":{\"920\":1}}],[\"可以使用下面的代码来创建池化基于堆的\",{\"1\":{\"769\":1}}],[\"可以使用hash值的大小来确定加锁的先后\",{\"1\":{\"551\":1}}],[\"可以使用hashmap来实现\",{\"1\":{\"477\":1}}],[\"可以使用\",{\"1\":{\"493\":1,\"801\":1,\"855\":1}}],[\"可以使用如下方式来避免sum的npe问题\",{\"1\":{\"482\":2}}],[\"可以使用count\",{\"1\":{\"481\":1}}],[\"可以使用coalesce函数解决\",{\"1\":{\"351\":1}}],[\"可以使用分治策略\",{\"1\":{\"477\":1}}],[\"可以使用一个mapreduce的shuffle既可以做分组也可以排序\",{\"1\":{\"452\":1}}],[\"可以使用多个reducetask来跑数据\",{\"1\":{\"351\":1}}],[\"可以使用add\",{\"1\":{\"343\":1}}],[\"可以使用all来指定不删除\",{\"1\":{\"315\":1}}],[\"可以使用parse\",{\"1\":{\"336\":1}}],[\"可以使用set设置当前session生效\",{\"1\":{\"268\":1}}],[\"可以使用几个基本操作完成更加复杂的操作\",{\"1\":{\"194\":1}}],[\"可以使用原型模式快捷的创建对象\",{\"1\":{\"53\":1}}],[\"可以使用原型模式复制多个\",{\"1\":{\"52\":1}}],[\"可以满足不同大小的进程的需求\",{\"1\":{\"182\":1}}],[\"可以动态申请内存分配\",{\"1\":{\"179\":1}}],[\"可以是键值型\",{\"1\":{\"1185\":1}}],[\"可以是字符串\",{\"1\":{\"1182\":1}}],[\"可以是\",{\"1\":{\"723\":1}}],[\"可以是下面分类中的任意一个\",{\"1\":{\"358\":1}}],[\"可以是一个整数\",{\"1\":{\"171\":1}}],[\"可以是接口或者抽象类\",{\"1\":{\"13\":1}}],[\"可以允许一个请求进入临界区的进程立即进入临界区\",{\"1\":{\"168\":1}}],[\"可以适当提升其优先级\",{\"1\":{\"167\":1}}],[\"可以适当提升优先级\",{\"1\":{\"167\":1}}],[\"可以适当降低其优先级\",{\"1\":{\"167\":1}}],[\"可以优先处理紧急的\",{\"1\":{\"165\":1}}],[\"可以说进程是由pcb\",{\"1\":{\"159\":1}}],[\"可以执行特权和非特权指令\",{\"1\":{\"156\":1}}],[\"可以把版本号去掉\",{\"1\":{\"107\":1}}],[\"可以把指挥者类和抽象建造者进行结合\",{\"1\":{\"14\":1}}],[\"可以设置虚拟路径\",{\"1\":{\"1447\":1}}],[\"可以设置一个初值为1的信号量\",{\"1\":{\"171\":1}}],[\"可以设置\",{\"1\":{\"100\":1}}],[\"可以确保每一个构建过程都遵循同样的规则和最佳实践\",{\"1\":{\"91\":1}}],[\"可以管理项目的编译\",{\"1\":{\"91\":1}}],[\"可以管理项目的依赖\",{\"1\":{\"91\":1}}],[\"可以延迟到子类中实现\",{\"1\":{\"83\":1}}],[\"可以在这里做手脚\",{\"1\":{\"1411\":1}}],[\"可以在一个消费组中包含多个消费者\",{\"1\":{\"1024\":1}}],[\"可以在一个命令中构建和发布多个相关的项目\",{\"1\":{\"108\":1}}],[\"可以在前端拦截一部分\",{\"1\":{\"1005\":1}}],[\"可以在\",{\"1\":{\"774\":1}}],[\"可以在hive中开启关联优化\",{\"1\":{\"453\":1}}],[\"可以在编译或者汇编的时候给出\",{\"1\":{\"179\":1}}],[\"可以在资源分配之前预先判断这次分配会不会导致系统进入不安全状态\",{\"1\":{\"177\":1}}],[\"可以在父项目中管理公共依赖项和插件\",{\"1\":{\"108\":1}}],[\"可以在父类中实现\",{\"1\":{\"83\":1}}],[\"可以在类的成员位置声明抽象\",{\"1\":{\"77\":1}}],[\"可以方便地根据棋手的选择切换ai例程的水平\",{\"1\":{\"79\":1}}],[\"可以将对象之间的耦合度降低\",{\"1\":{\"1528\":1}}],[\"可以将通过\",{\"1\":{\"1293\":1}}],[\"可以将leader分配到优先的leader对应的broker\",{\"1\":{\"1050\":1}}],[\"可以将一些比较耗时的操作放在其他系统中\",{\"1\":{\"1009\":1}}],[\"可以将雪花算法作为一个单独的服务进行部署\",{\"1\":{\"998\":1}}],[\"可以将普通作业包装成受控作业\",{\"1\":{\"991\":1}}],[\"可以将job指定的文件\",{\"1\":{\"989\":1}}],[\"可以将namenode\",{\"1\":{\"878\":1}}],[\"可以将数据填充至多个\",{\"1\":{\"807\":1}}],[\"可以将多个\",{\"1\":{\"779\":1,\"808\":1}}],[\"可以将多个子项目组织在一起\",{\"1\":{\"108\":1}}],[\"可以将流中元素反复结合起来\",{\"1\":{\"620\":1}}],[\"可以将两张表的数据构建为桶表\",{\"1\":{\"469\":1}}],[\"可以将查询结果视为in和not\",{\"1\":{\"317\":1}}],[\"可以将存储在hadoop文件中的结构化\",{\"1\":{\"229\":1}}],[\"可以将程序中很快会用到的部分装入内存\",{\"1\":{\"189\":1}}],[\"可以将优先级分为静态优先级和动态优先级两种\",{\"1\":{\"167\":1}}],[\"可以将暂时不能运行的进程调至外存等待\",{\"1\":{\"164\":1}}],[\"可以将已有对象纳入新对象中\",{\"1\":{\"77\":1}}],[\"可以将防火\",{\"1\":{\"75\":1}}],[\"可以给不同的用户提供不同级别的使用权限\",{\"1\":{\"63\":1}}],[\"可以通过后台代码直接获取即可\",{\"1\":{\"1175\":1}}],[\"可以通过requestparam\",{\"1\":{\"1168\":1}}],[\"可以通过这个\",{\"1\":{\"1155\":1}}],[\"可以通过acl\",{\"1\":{\"925\":1}}],[\"可以通过select命令来选择数据库\",{\"1\":{\"1202\":1}}],[\"可以通过set\",{\"1\":{\"313\":1}}],[\"可以通过snapshot来进行相关的恢复操作\",{\"1\":{\"912\":1}}],[\"可以通过hdfs\",{\"1\":{\"875\":1}}],[\"可以通过剩余的数据块和校验块计算出丢失的数据块\",{\"1\":{\"875\":1}}],[\"可以通过下面三种方法来监听是否有事件发生\",{\"1\":{\"832\":1}}],[\"可以通过下面的系统环境变量来设置\",{\"1\":{\"770\":1}}],[\"可以通过下面源码查看默认大小\",{\"1\":{\"726\":1}}],[\"可以通过修改宏定义甚至重新编译内核的方式提升这一限制\",{\"1\":{\"680\":1}}],[\"可以通过遍历fdset\",{\"1\":{\"680\":1}}],[\"可以通过设置socket使其变为non\",{\"1\":{\"679\":1}}],[\"可以通过表头三个字段的长度直接定位\",{\"1\":{\"665\":1}}],[\"可以通过线程池进行改善\",{\"1\":{\"609\":1}}],[\"可以通过一次cas同时更改两个属性的值\",{\"1\":{\"571\":1}}],[\"可以通过\",{\"1\":{\"562\":1,\"663\":1,\"726\":1,\"1026\":1,\"1248\":1,\"1376\":1,\"1453\":1,\"1504\":1}}],[\"可以通过指定多个参数来解析json返回多列的值\",{\"1\":{\"396\":1}}],[\"可以通过语法streamtable提示指定要流式传输的表\",{\"1\":{\"326\":1}}],[\"可以通过where子句限制数据访问\",{\"1\":{\"272\":1}}],[\"可以通过location语法来更改数据在hdfs上的存储路径\",{\"1\":{\"255\":1}}],[\"可以通过紧凑\",{\"1\":{\"182\":1}}],[\"可以通过第三方转发该调用\",{\"1\":{\"76\":1}}],[\"可以通过聚合\",{\"1\":{\"73\":1}}],[\"可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合\",{\"1\":{\"42\":1}}],[\"可以通过参数直接获取对象\",{\"1\":{\"29\":1}}],[\"可以创建并管理各种类的对象\",{\"1\":{\"1502\":1}}],[\"可以创建多个对象\",{\"1\":{\"68\":1}}],[\"可以创建多个不同等级的产品\",{\"1\":{\"38\":1}}],[\"可以创建一个抽象类adapter\",{\"1\":{\"7\":1}}],[\"另有\",{\"1\":{\"746\":1}}],[\"另一部分是高级的\",{\"1\":{\"1333\":1}}],[\"另一端为server\",{\"1\":{\"949\":1}}],[\"另一种调用方法\",{\"1\":{\"1306\":1}}],[\"另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致\",{\"1\":{\"1003\":1}}],[\"另一种思路是用多个数组组成\",{\"1\":{\"841\":1}}],[\"另一种思路是按分隔符拆分\",{\"1\":{\"840\":1}}],[\"另一种解读\",{\"1\":{\"709\":1}}],[\"另一条线是继承自\",{\"1\":{\"746\":1}}],[\"另一方面\",{\"1\":{\"504\":1,\"946\":1,\"1510\":1}}],[\"另一个产品目录的索引\",{\"1\":{\"1061\":1}}],[\"另一个微服务可以从消息队列中把消息取出来进行处理\",{\"1\":{\"1009\":1}}],[\"另一个线程去真正建立连接\",{\"1\":{\"755\":1}}],[\"另一个等待的事务就能继续运行\",{\"1\":{\"513\":1}}],[\"另一个为\",{\"1\":{\"493\":1}}],[\"另一个访问该临界资源的进程必须等待\",{\"1\":{\"168\":1}}],[\"另一些计算机则采用i\",{\"1\":{\"208\":1}}],[\"另外两个是通过代理实现的\",{\"1\":{\"1508\":1}}],[\"另外要注意的是\",{\"1\":{\"1245\":1}}],[\"另外如果发送的数据大于\",{\"1\":{\"833\":1}}],[\"另外源码部分\",{\"1\":{\"725\":1}}],[\"另外地址转换也就是将逻辑地址转换为相应物理地址等功能也是操作系统内存管理做的事情\",{\"1\":{\"682\":1}}],[\"另外使用事务的地方需要考虑各方面的回滚方案\",{\"1\":{\"483\":1}}],[\"另外\",{\"1\":{\"167\":1,\"481\":1,\"662\":1,\"665\":1,\"1264\":1,\"1321\":1,\"1515\":1}}],[\"另\",{\"1\":{\"43\":1}}],[\"令狐冲\",{\"1\":{\"43\":1}}],[\"目前最新的\",{\"1\":{\"1499\":1}}],[\"目前现在都是前后端分离的项目\",{\"1\":{\"1229\":1}}],[\"目前的代码仅支持\",{\"1\":{\"723\":1}}],[\"目前的jdk版本采用什么回收算法\",{\"1\":{\"633\":1}}],[\"目前只有g1\",{\"1\":{\"628\":1}}],[\"目前\",{\"1\":{\"628\":1,\"1290\":1}}],[\"目前来说为了方便起见\",{\"1\":{\"474\":1}}],[\"目前版本的hive使用union时\",{\"1\":{\"315\":1}}],[\"目前仅支持对物化视图的drop和show操作\",{\"1\":{\"276\":1}}],[\"目的是为了查询时实现自动反序列化\",{\"1\":{\"1222\":1}}],[\"目的是为了让故障对业务的影响最小\",{\"1\":{\"882\":1}}],[\"目的是为了防止一些实现比较差的hashcode方法\",{\"1\":{\"605\":1}}],[\"目的是为了加强记忆方便查询\",{\"1\":{\"479\":1}}],[\"目的是按照每批1024行读取数据\",{\"1\":{\"438\":1}}],[\"目的是减少扫描的次数\",{\"1\":{\"288\":1}}],[\"目的是用于序列化和反序列化\",{\"1\":{\"249\":1}}],[\"目的就是只需要执行一次\",{\"1\":{\"42\":1}}],[\"目态\",{\"1\":{\"156\":1}}],[\"目录和一个\",{\"1\":{\"1441\":1}}],[\"目录下\",{\"1\":{\"1244\":1}}],[\"目录下的\",{\"1\":{\"1046\":1}}],[\"目录可以提高查询速度\",{\"1\":{\"1061\":1}}],[\"目录可以是完整的uri\",{\"1\":{\"290\":1}}],[\"目录中\",{\"1\":{\"1046\":1}}],[\"目录名称\",{\"1\":{\"1013\":1}}],[\"目录的acl权限都是之前设置的default\",{\"1\":{\"926\":1}}],[\"目录的方法\",{\"1\":{\"259\":1}}],[\"目录禁用快照功能\",{\"1\":{\"914\":1}}],[\"目录开启快照功能\",{\"1\":{\"914\":1}}],[\"目录上还支持默认的replication方案\",{\"1\":{\"875\":1}}],[\"目录浏览一下就好\",{\"1\":{\"481\":1}}],[\"目录结构分析\",{\"0\":{\"1013\":1}}],[\"目录结构\",{\"1\":{\"196\":4}}],[\"目录\",{\"1\":{\"89\":1,\"919\":1,\"1006\":1,\"1090\":1,\"1181\":1,\"1193\":1}}],[\"目标方法执行结束\",{\"1\":{\"1340\":1}}],[\"目标类target\",{\"1\":{\"1309\":1}}],[\"目标接口foo\",{\"1\":{\"1309\":1}}],[\"目标对象\",{\"1\":{\"1304\":1,\"1306\":1}}],[\"目标文件是否存在\",{\"1\":{\"901\":1}}],[\"目标端不存在的文件数据\",{\"1\":{\"869\":1}}],[\"目标端多出来的文件\",{\"1\":{\"869\":1}}],[\"目标模块中的指令就是内存中的绝对地址\",{\"1\":{\"179\":1}}],[\"目标\",{\"0\":{\"783\":1},\"1\":{\"5\":1,\"154\":2}}],[\"静态资源处理\",{\"1\":{\"1437\":1}}],[\"静态资源\",{\"1\":{\"1437\":1}}],[\"静态资源解析优化\",{\"0\":{\"1431\":1}}],[\"静态通知调用\",{\"0\":{\"1340\":1}}],[\"静态方法\",{\"1\":{\"1310\":1}}],[\"静态方法等实现增强\",{\"1\":{\"1300\":1}}],[\"静态数据加载\",{\"1\":{\"284\":1}}],[\"静态加载方式\",{\"1\":{\"262\":1}}],[\"静态分区的属性值由用户加载数据时手动指定\",{\"1\":{\"261\":1}}],[\"静态分区加载\",{\"1\":{\"261\":1}}],[\"静态分区\",{\"1\":{\"259\":1,\"261\":1}}],[\"静态分配\",{\"1\":{\"213\":1}}],[\"静态分配和动态分配\",{\"1\":{\"213\":1}}],[\"静态链接\",{\"1\":{\"179\":1}}],[\"静态重定位\",{\"1\":{\"179\":1}}],[\"静态属性\",{\"1\":{\"70\":1}}],[\"静态属性由于被\",{\"1\":{\"66\":1}}],[\"静态内部类单例模式是一种优秀的单例模式\",{\"1\":{\"66\":1}}],[\"静态内部类单例模式中实例由内部类创建\",{\"1\":{\"66\":1}}],[\"静态内部类的初始化时机\",{\"1\":{\"66\":1}}],[\"静态内部类方式\",{\"1\":{\"66\":2}}],[\"静态代码块\",{\"1\":{\"1215\":1}}],[\"静态代码块方式\",{\"1\":{\"66\":1}}],[\"静态代理模式除了所有实现类需要实现这个方法外\",{\"1\":{\"61\":1}}],[\"静态代理\",{\"0\":{\"58\":1}}],[\"静态代理代理类在编译期就生成\",{\"1\":{\"56\":1}}],[\"静态变量还是局部变量\",{\"1\":{\"560\":1}}],[\"静态变量创建类的对象\",{\"1\":{\"66\":1}}],[\"静态变量方式\",{\"1\":{\"66\":1}}],[\"静态成员变量用来存储创建的对象\",{\"1\":{\"42\":1}}],[\"静态工厂\",{\"1\":{\"30\":1}}],[\"hl2\",{\"1\":{\"1180\":2}}],[\"hll\",{\"1\":{\"1179\":1}}],[\"hyperloglog\",{\"0\":{\"1179\":1},\"1\":{\"1179\":1}}],[\"hmget\",{\"1\":{\"1208\":2}}],[\"hmdianpingapplicationtests\",{\"1\":{\"1171\":1}}],[\"hmset和hmget\",{\"1\":{\"1208\":1}}],[\"hmset\",{\"1\":{\"515\":1,\"1208\":3}}],[\"hutool<\",{\"1\":{\"1022\":1}}],[\"hutool\",{\"1\":{\"1022\":1}}],[\"h6\",{\"1\":{\"766\":3}}],[\"h5\",{\"1\":{\"766\":2}}],[\"h3>\",{\"1\":{\"1416\":1}}],[\"h3\",{\"1\":{\"766\":3}}],[\"h4\",{\"1\":{\"766\":2}}],[\"h2\",{\"1\":{\"766\":3}}],[\"h1\",{\"1\":{\"766\":3}}],[\"h1>\",{\"1\":{\"711\":1}}],[\"h>\",{\"1\":{\"646\":1,\"663\":2,\"669\":1}}],[\"hkeys和hvals\",{\"1\":{\"1208\":1}}],[\"hkeys\",{\"1\":{\"515\":1,\"1208\":2}}],[\"hgetall\",{\"1\":{\"515\":1,\"1208\":5,\"1213\":1}}],[\"hget\",{\"1\":{\"515\":1,\"1208\":3}}],[\"hset和hget\",{\"1\":{\"1208\":1}}],[\"hsetnx\",{\"1\":{\"1208\":4}}],[\"hset\",{\"1\":{\"515\":1,\"1151\":1,\"1208\":4,\"1213\":2}}],[\"hcatalog\",{\"1\":{\"397\":1}}],[\"hhhh\",{\"1\":{\"698\":1}}],[\"hh\",{\"1\":{\"337\":3,\"699\":1}}],[\"hp\",{\"1\":{\"260\":2,\"261\":1,\"281\":1}}],[\"hql中使用函数\",{\"1\":{\"344\":1}}],[\"hql\",{\"1\":{\"229\":1,\"232\":1}}],[\"hrrn\",{\"1\":{\"167\":1}}],[\"hibernate\",{\"1\":{\"1499\":1}}],[\"hikaridatasource\",{\"1\":{\"1454\":1}}],[\"hikari\",{\"1\":{\"1454\":1}}],[\"hi=你好\",{\"1\":{\"1244\":1}}],[\"hi=こんにちは\",{\"1\":{\"1244\":1}}],[\"hi=hello\",{\"1\":{\"1244\":1}}],[\"hincrby\",{\"1\":{\"1151\":2,\"1208\":4}}],[\"hindupuravinash\",{\"1\":{\"120\":1,\"127\":1}}],[\"hit\",{\"1\":{\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2}}],[\"hits\",{\"1\":{\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2}}],[\"highlighter\",{\"1\":{\"1083\":1}}],[\"highlightbuilder\",{\"1\":{\"1083\":7}}],[\"high\",{\"1\":{\"789\":1,\"1070\":1}}],[\"highest\",{\"1\":{\"167\":1}}],[\"hiredate\",{\"1\":{\"404\":1}}],[\"hi\",{\"1\":{\"336\":4,\"1244\":3}}],[\"hive实现join时\",{\"1\":{\"447\":1}}],[\"hive同样支持join的语法\",{\"1\":{\"447\":1}}],[\"hive在实现hql计算运行时\",{\"1\":{\"446\":1}}],[\"hive在执行查询计划时\",{\"1\":{\"413\":1}}],[\"hive为了解决这个问题\",{\"1\":{\"444\":1}}],[\"hive使用antlr解析生成器\",{\"1\":{\"442\":1}}],[\"hive压缩实际上说的就是mapreduce的压缩\",{\"1\":{\"432\":1}}],[\"hive底层运行mapreduce程序时\",{\"1\":{\"432\":1}}],[\"hive底层是通过mapreduce来实现的\",{\"1\":{\"418\":1}}],[\"hive也支持这种格式\",{\"1\":{\"428\":1}}],[\"hive构建索引的过程是通过一个mapreduce程序来实现的\",{\"1\":{\"424\":1}}],[\"hive索引可以建立在表中的某些列上\",{\"1\":{\"420\":1}}],[\"hive不支持主键或者外键索引\",{\"1\":{\"420\":1}}],[\"hive不会帮你添加\",{\"1\":{\"280\":1}}],[\"hive还内置了很多serde类\",{\"1\":{\"374\":1}}],[\"hive默认的优化器在解析一些聚合统计类的处理时\",{\"1\":{\"455\":1}}],[\"hive默认序列化类是lazysimpleserde\",{\"1\":{\"371\":1}}],[\"hive默认分隔符\",{\"1\":{\"252\":1}}],[\"hive根据y的大小\",{\"1\":{\"369\":1}}],[\"hive根据hive\",{\"1\":{\"243\":1}}],[\"hive专门提供了语法lateral\",{\"1\":{\"348\":1}}],[\"hive<\",{\"1\":{\"344\":1}}],[\"hive>add\",{\"1\":{\"344\":1}}],[\"hive调用java方法\",{\"1\":{\"343\":1}}],[\"hive内置函数\",{\"0\":{\"335\":1}}],[\"hive内置运算符\",{\"0\":{\"328\":1}}],[\"hive函数可以分成两大类\",{\"1\":{\"334\":1}}],[\"hive函数概述及分类标准\",{\"0\":{\"334\":1}}],[\"hive逻辑运算符\",{\"1\":{\"332\":1}}],[\"hive中谓词下推后\",{\"1\":{\"459\":1}}],[\"hive中支持rbo与cbo这两种引擎\",{\"1\":{\"457\":1}}],[\"hive中小表的大小限制\",{\"1\":{\"448\":1}}],[\"hive中默认自动开启了mapjoin\",{\"1\":{\"448\":1}}],[\"hive中也提供一种输入类combinehiveinputformat\",{\"1\":{\"436\":1}}],[\"hive中也同样提供了索引的设计\",{\"1\":{\"420\":1}}],[\"hive中提供了一个特殊的机制\",{\"1\":{\"435\":1}}],[\"hive中会自动创建一张索引表\",{\"1\":{\"421\":1}}],[\"hive中join的问题\",{\"1\":{\"418\":1}}],[\"hive中为了简化对于json文件的处理\",{\"1\":{\"397\":1}}],[\"hive中为了实现对url的解析\",{\"1\":{\"376\":1}}],[\"hive中多字节分隔符处理\",{\"0\":{\"371\":1}}],[\"hive中算术运算符\",{\"1\":{\"331\":1}}],[\"hive中关系运算符\",{\"1\":{\"330\":1}}],[\"hive中的压缩就是使用了hadoop中的压缩实现的\",{\"1\":{\"432\":1}}],[\"hive中的索引\",{\"0\":{\"420\":1}}],[\"hive中的json处理方式\",{\"0\":{\"393\":1}}],[\"hive中的视图\",{\"1\":{\"270\":1}}],[\"hive中的表的数据在hdfs上的存储路径为\",{\"1\":{\"235\":1}}],[\"hive中的表所对应的数据通常是存储在hdfs中\",{\"1\":{\"235\":1}}],[\"hive中的数据可以在粒度级别上分为三类\",{\"1\":{\"233\":1}}],[\"hive中的thrift服务器允许外部客户端通过网络与hive进行交互\",{\"1\":{\"232\":1}}],[\"hive事务表的部分知识见下面链接\",{\"1\":{\"291\":1}}],[\"hive执行insert本质上是通过mr程序来实现的\",{\"1\":{\"286\":1}}],[\"hive会默认选择用第一种方案来实现\",{\"1\":{\"453\":1}}],[\"hive会使用两个mapreduce来完成这两个操作\",{\"1\":{\"452\":1}}],[\"hive会自动判断是否满足map\",{\"1\":{\"449\":1}}],[\"hive会加载整张表或分区\",{\"1\":{\"422\":1}}],[\"hive会为写事务\",{\"1\":{\"293\":1}}],[\"hive会根据最后一个字段进行自动分区\",{\"1\":{\"285\":1}}],[\"hive会尝试隐式转换\",{\"1\":{\"248\":1}}],[\"hiveserver2所在机器\",{\"1\":{\"283\":1}}],[\"hive将每个表的分区列表信息存储在其metastore中\",{\"1\":{\"281\":1}}],[\"hive把物化视图当成一张\",{\"1\":{\"275\":1}}],[\"hive从3\",{\"1\":{\"274\":1}}],[\"hive引入物化视图的目的就是为了优化数据查询访问的效率\",{\"1\":{\"274\":1}}],[\"hive的默认查询执行引擎一次处理一行\",{\"1\":{\"438\":1}}],[\"hive的存储本质还是hdfs\",{\"1\":{\"435\":1}}],[\"hive的文件是存储在hdfs上的\",{\"1\":{\"292\":1}}],[\"hive的物化视图还提供了物化视图存储选择机制\",{\"1\":{\"274\":1}}],[\"hive的数据都是存储在hdfs上的\",{\"1\":{\"234\":1}}],[\"hive3新特性\",{\"0\":{\"471\":1}}],[\"hive3\",{\"0\":{\"285\":1,\"411\":1},\"1\":{\"274\":1}}],[\"hive是否支持并发\",{\"1\":{\"276\":1,\"297\":1,\"298\":1}}],[\"hive是否支持高并发\",{\"1\":{\"268\":1}}],[\"hive是一款建立在hadoop之上的开源数据仓库系统\",{\"1\":{\"229\":1}}],[\"hive2\",{\"1\":{\"266\":1}}],[\"hivedata\",{\"1\":{\"261\":6,\"262\":3,\"280\":1,\"285\":1,\"287\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2}}],[\"hive支持compact和bitmap类型\",{\"1\":{\"423\":1}}],[\"hive支持多重分区\",{\"1\":{\"259\":1}}],[\"hive支持根据指定的字段对表进行分区\",{\"1\":{\"259\":1}}],[\"hive管理范围\",{\"1\":{\"258\":1}}],[\"hive表数据优化\",{\"0\":{\"425\":1}}],[\"hive表设计优化\",{\"0\":{\"412\":1}}],[\"hive表默认存储路径是由$\",{\"1\":{\"254\":1}}],[\"hive表与关系数据库中的表相同\",{\"1\":{\"235\":1}}],[\"hive数据存储路径\",{\"0\":{\"253\":1}}],[\"hive数据类型详解\",{\"0\":{\"248\":1}}],[\"hiveignorekeytextoutputformat\",{\"1\":{\"250\":1}}],[\"hive写文件机制\",{\"1\":{\"250\":1}}],[\"hive读取文件机制\",{\"1\":{\"250\":1}}],[\"hive读写文件流程\",{\"0\":{\"250\":1}}],[\"hive读写文件机制\",{\"0\":{\"249\":1}}],[\"hive建表完整语法树\",{\"0\":{\"247\":1},\"1\":{\"247\":1}}],[\"hive作为一个数据仓库\",{\"1\":{\"234\":1}}],[\"hive本身并不直接处理数据文件\",{\"1\":{\"232\":1}}],[\"hive架构\",{\"1\":{\"231\":1}}],[\"hive由facebook实现并开源\",{\"1\":{\"229\":1}}],[\"hive核心是将hql转换为mapreduce程序\",{\"1\":{\"229\":1}}],[\"hive\",{\"0\":{\"218\":1,\"229\":1,\"230\":1,\"233\":1,\"238\":1,\"239\":1,\"240\":1,\"245\":1,\"246\":1,\"257\":1,\"258\":1,\"259\":1,\"263\":1,\"267\":1,\"269\":1,\"277\":1,\"282\":1,\"283\":1,\"286\":1,\"291\":1,\"295\":1,\"299\":1,\"300\":1,\"301\":1,\"311\":1,\"319\":1,\"326\":1,\"327\":1,\"333\":1,\"345\":1,\"349\":1,\"370\":1,\"411\":1,\"472\":1,\"473\":1,\"1537\":1},\"1\":{\"232\":1,\"234\":2,\"235\":2,\"236\":1,\"237\":2,\"239\":1,\"244\":3,\"248\":1,\"254\":3,\"261\":2,\"266\":2,\"268\":7,\"271\":1,\"276\":8,\"280\":1,\"281\":5,\"285\":1,\"289\":2,\"290\":5,\"296\":1,\"297\":7,\"298\":7,\"302\":1,\"336\":1,\"344\":1,\"374\":2,\"397\":1,\"430\":1,\"433\":2,\"435\":4,\"436\":2,\"437\":1,\"438\":2,\"444\":3,\"446\":2,\"447\":1,\"448\":3,\"450\":5,\"453\":1,\"457\":3,\"459\":1,\"464\":1,\"466\":1,\"470\":4}}],[\"history\",{\"1\":{\"81\":7}}],[\"hdp\",{\"1\":{\"876\":2}}],[\"hdfs<\",{\"1\":{\"957\":1}}],[\"hdfs透明加密\",{\"0\":{\"928\":1}}],[\"hdfs会通过调用外部的\",{\"1\":{\"924\":1}}],[\"hdfs会为在current回收站目录下的文件创建检查点\",{\"1\":{\"909\":1}}],[\"hdfs中用户所属组的确认工作需要通过外部的用户组映射\",{\"1\":{\"924\":1}}],[\"hdfs中的目录\",{\"1\":{\"875\":1}}],[\"hdfs中的文件时移动操作\",{\"1\":{\"283\":1}}],[\"hdfs在获取用户名后还需要获取该用户所在的组\",{\"1\":{\"924\":1}}],[\"hdfs项目本身并没有用户身份认证\",{\"1\":{\"921\":1}}],[\"hdfs用户身份认证\",{\"0\":{\"921\":1}}],[\"hdfs也提供了umask掩码\",{\"1\":{\"919\":1}}],[\"hdfs也集成了一套权限管理系统\",{\"1\":{\"916\":1}}],[\"hdfs文件权限也细分为\",{\"1\":{\"918\":1}}],[\"hdfs文件权限与linux\",{\"1\":{\"917\":1}}],[\"hdfs权限管理\",{\"0\":{\"915\":1}}],[\"hdfs快照不是数据的简单拷贝\",{\"1\":{\"913\":1}}],[\"hdfs提供了一个命令行工具来完成这个工作\",{\"1\":{\"910\":1}}],[\"hdfs小文件解决方案\",{\"0\":{\"906\":1}}],[\"hdfs集群角色职责\",{\"0\":{\"903\":1}}],[\"hdfs集群滚动降级\",{\"0\":{\"891\":1}}],[\"hdfs集群滚动升级\",{\"0\":{\"890\":1}}],[\"hdfs读数据流程\",{\"0\":{\"902\":1}}],[\"hdfs读写流程\",{\"0\":{\"896\":1}}],[\"hdfs客户端创建filesystem对象实例distributedfilesystem\",{\"1\":{\"901\":1,\"902\":1}}],[\"hdfs写数据流程\",{\"0\":{\"897\":1}}],[\"hdfs架构剖析\",{\"0\":{\"894\":1}}],[\"hdfs的单点故障问题指的是namenode单点故障\",{\"1\":{\"883\":1}}],[\"hdfs动态节点管理\",{\"0\":{\"877\":1}}],[\"hdfs无法维持机架容错能力\",{\"1\":{\"875\":1}}],[\"hdfs体系结构进行的调整\",{\"1\":{\"875\":1}}],[\"hdfs整体已用空间与hdfs集群总容量的比\",{\"1\":{\"873\":1}}],[\"hdfs高阶优化方案\",{\"0\":{\"871\":1}}],[\"hdfs自动离开安全模式\",{\"1\":{\"870\":1}}],[\"hdfs分布式拷贝工具\",{\"1\":{\"869\":1}}],[\"hdfs是不利于小文件存储的\",{\"1\":{\"435\":1}}],[\"hdfs\",{\"0\":{\"868\":1,\"873\":1,\"874\":1,\"881\":1,\"884\":1,\"887\":1,\"893\":1,\"895\":1,\"907\":1,\"908\":1,\"911\":1,\"924\":1,\"927\":1,\"937\":1,\"1551\":1},\"1\":{\"232\":1,\"250\":2,\"278\":1,\"315\":2,\"316\":1,\"317\":2,\"870\":6,\"872\":3,\"873\":4,\"874\":1,\"875\":1,\"878\":3,\"879\":3,\"903\":1,\"911\":1,\"914\":7,\"936\":4}}],[\"hd\",{\"1\":{\"117\":1}}],[\"how\",{\"1\":{\"809\":1}}],[\"hour\",{\"1\":{\"337\":3}}],[\"host2<\",{\"1\":{\"927\":1}}],[\"hosts<\",{\"1\":{\"927\":2}}],[\"hosts指向文件\",{\"1\":{\"880\":1}}],[\"hosts参数指定\",{\"1\":{\"880\":1}}],[\"hosts\",{\"1\":{\"878\":1,\"879\":3,\"880\":2}}],[\"hosts映射\",{\"1\":{\"878\":1}}],[\"hostname=node1\",{\"1\":{\"963\":1}}],[\"hostname\",{\"1\":{\"878\":1}}],[\"host\",{\"1\":{\"336\":1,\"377\":1,\"378\":8,\"1088\":3,\"1220\":1}}],[\"hotspot有这么多的垃圾回收器\",{\"1\":{\"639\":1}}],[\"hot\",{\"1\":{\"256\":1,\"1100\":1}}],[\"home环境配置\",{\"1\":{\"1046\":1}}],[\"home=\",{\"1\":{\"936\":1,\"1012\":1,\"1046\":2}}],[\"home\",{\"1\":{\"92\":1,\"254\":1,\"936\":2,\"1012\":2,\"1045\":1,\"1046\":3}}],[\"hook\",{\"1\":{\"84\":1}}],[\"http方法\",{\"1\":{\"1530\":1}}],[\"httpencodingautoconfiguration\",{\"0\":{\"1462\":1}}],[\"http11nio2protocol\",{\"1\":{\"1449\":1}}],[\"httpmessageconverter\",{\"1\":{\"1438\":1}}],[\"httpheaders\",{\"1\":{\"1394\":1}}],[\"httphost\",{\"1\":{\"1071\":1,\"1088\":1}}],[\"http的幂等性\",{\"0\":{\"1004\":1}}],[\"httpcontent\",{\"1\":{\"711\":1}}],[\"httpresponsestatus\",{\"1\":{\"711\":1}}],[\"httprequesthandler\",{\"1\":{\"1437\":1}}],[\"httprequesthandleradapter\",{\"0\":{\"1426\":1},\"1\":{\"1429\":3,\"1430\":1,\"1437\":1}}],[\"httprequest\",{\"1\":{\"711\":2}}],[\"http\",{\"0\":{\"711\":1},\"1\":{\"112\":4,\"113\":4,\"114\":4,\"115\":4,\"125\":1,\"128\":1,\"132\":1,\"336\":1,\"377\":6,\"651\":1,\"840\":2,\"841\":1,\"936\":4,\"1009\":1,\"1071\":1,\"1089\":2,\"1219\":3,\"1292\":1,\"1438\":1}}],[\"httpservletresponse\",{\"1\":{\"1100\":1,\"1111\":3,\"1416\":1}}],[\"httpservletrequest\",{\"1\":{\"1100\":1,\"1111\":3,\"1362\":1,\"1416\":1}}],[\"httpservercodec\",{\"1\":{\"711\":1}}],[\"httpsession\",{\"1\":{\"1099\":2,\"1100\":1,\"1107\":1}}],[\"https\",{\"1\":{\"91\":1,\"99\":1,\"104\":1,\"112\":1,\"117\":4,\"118\":1,\"119\":1,\"120\":3,\"121\":2,\"124\":3,\"125\":10,\"126\":2,\"127\":3,\"128\":3,\"131\":5,\"132\":2,\"133\":2,\"144\":4,\"145\":8,\"146\":4,\"197\":1,\"543\":1,\"544\":1,\"545\":1,\"549\":1,\"1046\":1,\"1146\":1,\"1179\":1,\"1190\":1,\"1200\":2,\"1204\":1,\"1212\":1,\"1217\":1,\"1219\":1,\"1440\":2}}],[\"html\",{\"1\":{\"91\":1,\"124\":1,\"841\":1,\"1146\":1,\"1411\":2,\"1416\":2,\"1435\":1,\"1436\":3,\"1447\":2}}],[\"hvals\",{\"1\":{\"1208\":2}}],[\"hvals等\",{\"1\":{\"515\":1}}],[\"hv\",{\"1\":{\"81\":2}}],[\"ha中它们是拥有着同一个namespace\",{\"1\":{\"889\":1}}],[\"ha解决方案之一\",{\"1\":{\"884\":1}}],[\"ha解决方案\",{\"0\":{\"884\":1}}],[\"ha系统设计核心问题\",{\"1\":{\"882\":1}}],[\"ha高可用\",{\"0\":{\"881\":1}}],[\"have\",{\"1\":{\"799\":1}}],[\"having子句中如果使用了分组字段作为过滤条件\",{\"1\":{\"504\":1}}],[\"having子句中不能使用除了分组字段和聚合函数之外的其他字段\",{\"1\":{\"504\":1}}],[\"having是一个过滤声明\",{\"1\":{\"504\":1}}],[\"having是在分组后对数据进行过滤\",{\"1\":{\"308\":1}}],[\"having后面可以使用聚合函数\",{\"1\":{\"308\":1}}],[\"having和where的区别\",{\"0\":{\"308\":1}}],[\"having直接引用结果过滤\",{\"1\":{\"307\":1}}],[\"having\",{\"0\":{\"307\":1},\"1\":{\"307\":2,\"310\":2}}],[\"hadoo\",{\"1\":{\"330\":2}}],[\"hadoop会根据依赖的关系\",{\"1\":{\"991\":1}}],[\"hadoop提供了dbinputformat和dboutputformat两个类\",{\"1\":{\"984\":1}}],[\"hadoop数据类型\",{\"1\":{\"956\":1}}],[\"hadoop没有提供对象比较功能\",{\"1\":{\"956\":1}}],[\"hadoop通过writable接口实现的序列化机制\",{\"1\":{\"956\":1}}],[\"hadoop密钥管理服务\",{\"1\":{\"933\":1}}],[\"hadoop目录下\",{\"1\":{\"910\":1}}],[\"hadoop集群无法访问\",{\"1\":{\"903\":1}}],[\"hadoop对于fencing提供了两种实现\",{\"1\":{\"885\":1}}],[\"hadoop配置\",{\"1\":{\"878\":1}}],[\"hadoop上检查是否启用isa\",{\"1\":{\"876\":1}}],[\"hadoop纠删码算法启用isa\",{\"0\":{\"876\":1}}],[\"hadoop群集上已经启用了disk\",{\"1\":{\"874\":1}}],[\"hadoop中的安全模式safe\",{\"1\":{\"870\":1}}],[\"hadoop中支持的压缩算法\",{\"1\":{\"432\":1}}],[\"hadoop3中已不再支持该选项\",{\"1\":{\"445\":1}}],[\"hadoop3之前的配置\",{\"1\":{\"445\":1}}],[\"hadoop3不再支持\",{\"1\":{\"445\":1}}],[\"hadoop默认会为每个task启动一个jvm来运行\",{\"1\":{\"445\":1}}],[\"hadoop<\",{\"1\":{\"344\":1,\"957\":4,\"985\":1}}],[\"hadoop\",{\"0\":{\"956\":1,\"1552\":1},\"1\":{\"268\":1,\"276\":1,\"281\":5,\"296\":1,\"297\":1,\"298\":1,\"374\":2,\"433\":2,\"436\":1,\"791\":1,\"869\":1,\"872\":2,\"875\":2,\"876\":4,\"878\":3,\"879\":2,\"906\":1,\"910\":5,\"920\":5,\"926\":6,\"936\":10,\"962\":1,\"1046\":1}}],[\"hanmeimei\",{\"1\":{\"1208\":1}}],[\"hangzhou\",{\"1\":{\"262\":1}}],[\"hana\",{\"1\":{\"81\":10}}],[\"handvalue\",{\"1\":{\"81\":21}}],[\"hand\",{\"1\":{\"81\":22}}],[\"handlevoucherorder\",{\"1\":{\"1157\":2}}],[\"handleloopexception\",{\"1\":{\"741\":3}}],[\"handlerexecutionchain\",{\"1\":{\"1438\":1}}],[\"handlerexceptionresolver\",{\"1\":{\"1438\":1,\"1459\":1}}],[\"handlereadexception\",{\"1\":{\"744\":1}}],[\"handlerfunction\",{\"1\":{\"1425\":1,\"1437\":2}}],[\"handlerfunctionadapter\",{\"0\":{\"1422\":1},\"1\":{\"1424\":3,\"1425\":1,\"1437\":1}}],[\"handlermethodreturnvaluehandlercomposite\",{\"1\":{\"1381\":1,\"1384\":1}}],[\"handlermethodreturnvaluehandler\",{\"1\":{\"1355\":1,\"1438\":1}}],[\"handlermethodargumentresolvercomposite\",{\"1\":{\"1381\":1,\"1384\":1}}],[\"handlermethodargumentresolver\",{\"1\":{\"1355\":1,\"1438\":1}}],[\"handlermethod\",{\"1\":{\"1355\":3,\"1362\":1,\"1384\":1,\"1438\":3}}],[\"handlermapping\",{\"1\":{\"1355\":1,\"1429\":3,\"1437\":1,\"1438\":1,\"1459\":1}}],[\"handleradapter将controller执行结果modelandview返回给dispatcherservlet\",{\"1\":{\"1530\":1}}],[\"handleradapter经过适配调用具体的处理器\",{\"1\":{\"1530\":1}}],[\"handleradapter是一个适配器\",{\"1\":{\"1530\":1}}],[\"handleradapter是spring\",{\"1\":{\"1530\":1}}],[\"handleradapter\",{\"1\":{\"1355\":1,\"1381\":2,\"1389\":1,\"1401\":1,\"1437\":1,\"1438\":1,\"1459\":1}}],[\"handlerinterceptor\",{\"1\":{\"1100\":1,\"1111\":2}}],[\"handler2\",{\"1\":{\"748\":1,\"1429\":1}}],[\"handler1\",{\"1\":{\"748\":1,\"1429\":1,\"1432\":1}}],[\"handler\",{\"0\":{\"734\":1,\"736\":1,\"738\":1,\"749\":1,\"766\":1},\"1\":{\"572\":2,\"692\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":6,\"703\":3,\"710\":1,\"714\":1,\"725\":1,\"733\":9,\"735\":5,\"737\":5,\"740\":5,\"743\":3,\"744\":2,\"748\":2,\"749\":3,\"753\":4,\"754\":1,\"766\":2,\"775\":1,\"785\":3,\"787\":5,\"794\":1,\"1100\":1,\"1111\":3,\"1421\":2,\"1425\":2,\"1429\":6,\"1430\":2,\"1432\":4,\"1436\":2,\"1437\":1,\"1530\":2}}],[\"handlers存储在其他系统\",{\"1\":{\"274\":1}}],[\"handles\",{\"1\":{\"69\":1}}],[\"handle\",{\"1\":{\"69\":1,\"743\":1,\"744\":1,\"1438\":1}}],[\"harddisk\",{\"1\":{\"74\":15}}],[\"haslock\",{\"1\":{\"1127\":2}}],[\"has\",{\"1\":{\"799\":1}}],[\"hasremaining\",{\"1\":{\"796\":1,\"815\":1,\"843\":2,\"859\":1}}],[\"hasreadresolvemethod\",{\"1\":{\"69\":2}}],[\"hasscheduledtasks\",{\"1\":{\"742\":1}}],[\"hastasks\",{\"1\":{\"741\":1,\"742\":2}}],[\"hash结构操作\",{\"0\":{\"1224\":1}}],[\"hash结构可以将对象中的每个字段独立存储\",{\"1\":{\"1208\":1}}],[\"hash结构效率高\",{\"0\":{\"491\":1}}],[\"hash类型的常见命令\",{\"1\":{\"1208\":1}}],[\"hash类型\",{\"1\":{\"1208\":1}}],[\"hash命令\",{\"0\":{\"1208\":1}}],[\"hash后再以reduce\",{\"1\":{\"979\":1}}],[\"hashpartitioner\",{\"1\":{\"973\":1}}],[\"hashpartitioner<k2\",{\"1\":{\"968\":1}}],[\"hash的规则决定在扩容后需要对已有元素进行重新hash\",{\"1\":{\"605\":1}}],[\"hash判断当前元素的存放位置\",{\"1\":{\"605\":1}}],[\"hashset<>\",{\"1\":{\"702\":1}}],[\"hashset<string>\",{\"1\":{\"621\":1}}],[\"hashset用于不需要保证元素插入和取出顺序的场景\",{\"1\":{\"604\":1}}],[\"hashset底层采用的时哈希表\",{\"1\":{\"604\":1}}],[\"hashset\",{\"0\":{\"604\":1},\"1\":{\"604\":1,\"621\":1,\"742\":1}}],[\"hashset就不会让其加入操作成功\",{\"1\":{\"596\":1}}],[\"hashset会假设对象没有重复出现\",{\"1\":{\"596\":1}}],[\"hashset首先会根据对象的hashcode值来判断对象加入的位置\",{\"1\":{\"596\":1}}],[\"hash为负数表示该bin在扩容中或是treebin\",{\"1\":{\"579\":1}}],[\"hash表就会加倍扩容\",{\"1\":{\"606\":1}}],[\"hash表数组的大小\",{\"1\":{\"606\":1}}],[\"hash表\",{\"1\":{\"579\":2,\"1211\":1}}],[\"hash值是将联合索引键合并起来一起计算的\",{\"1\":{\"491\":1}}],[\"hash索引数据存储是没有顺序的\",{\"1\":{\"491\":1}}],[\"hash索引仅能满足\",{\"1\":{\"491\":1}}],[\"hashtable\",{\"1\":{\"483\":3,\"1149\":1}}],[\"hashfunc\",{\"1\":{\"237\":1}}],[\"hash\",{\"1\":{\"124\":1,\"313\":1,\"342\":2,\"343\":2,\"477\":1,\"494\":1,\"515\":1,\"528\":1,\"579\":10,\"664\":1,\"1034\":1,\"1151\":1}}],[\"hashcode是为了获取对象的哈希码\",{\"1\":{\"596\":1}}],[\"hashcode\",{\"1\":{\"59\":2,\"579\":2,\"968\":2,\"1041\":1}}],[\"hashmap<>\",{\"1\":{\"671\":1,\"723\":1,\"990\":1,\"1107\":1,\"1172\":1}}],[\"hashmap<string\",{\"1\":{\"483\":1,\"973\":2}}],[\"hashmap为什么会发生死链\",{\"1\":{\"607\":1}}],[\"hashmap在jdk\",{\"0\":{\"607\":1}}],[\"hashmap的扩容机制\",{\"0\":{\"606\":1}}],[\"hashmap的底层实现\",{\"0\":{\"605\":1}}],[\"hashmap通过key的hashcode经过扰动函数后得到hash值\",{\"1\":{\"605\":1}}],[\"hashmap\",{\"1\":{\"42\":1,\"1113\":2}}],[\"hasnext\",{\"1\":{\"43\":1,\"743\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":2,\"846\":2}}],[\"h\",{\"1\":{\"59\":10,\"81\":7,\"336\":1,\"579\":5,\"585\":4,\"668\":1,\"692\":4,\"693\":6,\"697\":19,\"698\":16,\"699\":18,\"748\":18,\"776\":1,\"1199\":1,\"1309\":6}}],[\"heima<\",{\"1\":{\"1219\":1}}],[\"heima\",{\"1\":{\"1207\":5,\"1208\":19}}],[\"heimasafetydoor\",{\"1\":{\"75\":2}}],[\"hex\",{\"1\":{\"799\":4}}],[\"hexpadding\",{\"1\":{\"799\":5}}],[\"hexdump\",{\"1\":{\"799\":8}}],[\"hexists\",{\"1\":{\"515\":1,\"1151\":2}}],[\"hessian\",{\"1\":{\"712\":1}}],[\"help\",{\"1\":{\"1205\":2,\"1206\":1}}],[\"helptransfer\",{\"1\":{\"579\":1}}],[\"hell\",{\"1\":{\"839\":1}}],[\"helloservlet\",{\"1\":{\"1449\":4}}],[\"helloservice\",{\"1\":{\"734\":2,\"735\":1,\"737\":2}}],[\"helloserviceimpl\",{\"1\":{\"733\":1}}],[\"helloservice=cn\",{\"1\":{\"733\":1}}],[\"helloword\",{\"1\":{\"796\":1,\"807\":1,\"808\":1,\"820\":2,\"822\":9,\"854\":1}}],[\"helloworldclient\",{\"1\":{\"692\":2,\"696\":2,\"697\":4,\"698\":4,\"699\":4}}],[\"helloworldserver\",{\"1\":{\"692\":6,\"693\":3,\"697\":3,\"698\":1,\"699\":3}}],[\"helloworld\",{\"1\":{\"668\":1}}],[\"hello\",{\"0\":{\"782\":1},\"1\":{\"6\":2,\"341\":1,\"668\":4,\"753\":3,\"766\":1,\"783\":1,\"785\":1,\"809\":3,\"839\":1,\"840\":1,\"848\":1,\"859\":1,\"1438\":3,\"1441\":4,\"1449\":1}}],[\"hero\",{\"1\":{\"256\":1,\"260\":4,\"261\":10,\"281\":9}}],[\"heartbeat\",{\"1\":{\"903\":1}}],[\"heapbytebuffer\",{\"1\":{\"855\":1,\"861\":1}}],[\"heapbuffer\",{\"1\":{\"769\":1}}],[\"heapcharbuffer\",{\"1\":{\"805\":1}}],[\"heading\",{\"1\":{\"1179\":1}}],[\"header\",{\"1\":{\"799\":1}}],[\"headers\",{\"1\":{\"711\":1}}],[\"headcontext\",{\"1\":{\"740\":1,\"743\":1,\"775\":1}}],[\"head\",{\"0\":{\"138\":1},\"1\":{\"585\":1,\"695\":2,\"740\":2,\"743\":2,\"766\":1,\"1004\":1}}],[\"heatoil\",{\"1\":{\"85\":2}}],[\"hefeijoe\",{\"1\":{\"22\":1}}],[\"为的是让其它配置优先解析\",{\"1\":{\"1465\":1}}],[\"为简洁均省略了包名\",{\"1\":{\"1464\":1}}],[\"为导入器类名\",{\"1\":{\"1464\":1}}],[\"为用户持续的提供\",{\"1\":{\"1166\":1}}],[\"为org\",{\"1\":{\"1040\":1,\"1041\":1}}],[\"为任务设置好运行环境\",{\"1\":{\"953\":1}}],[\"为该应用程序分配第一个container\",{\"1\":{\"953\":1}}],[\"为该字段建立bloomfilter的数据结构\",{\"1\":{\"437\":1}}],[\"为它申请资源\",{\"1\":{\"952\":1}}],[\"为hdfs客户端解密edek\",{\"1\":{\"933\":1}}],[\"为node1用户对于vingkin添加rwx权限\",{\"1\":{\"926\":1}}],[\"为特定的用户或组设置不同的权限\",{\"1\":{\"925\":1}}],[\"为未复制的块管理块复制\",{\"1\":{\"888\":1}}],[\"为何要取消💡\",{\"0\":{\"844\":1}}],[\"为何要\",{\"0\":{\"837\":1}}],[\"为何说一般查找行记录\",{\"0\":{\"487\":1}}],[\"为啥方法叫\",{\"1\":{\"784\":1}}],[\"为现象明显\",{\"1\":{\"693\":1}}],[\"为4g\",{\"1\":{\"676\":1}}],[\"为对象分配内存\",{\"1\":{\"630\":2}}],[\"为下次读写做准备\",{\"1\":{\"610\":1}}],[\"为下一次扩容的阈值大小\",{\"1\":{\"579\":1}}],[\"为3\",{\"1\":{\"591\":1}}],[\"为例\",{\"1\":{\"566\":1,\"839\":1}}],[\"为参数1值\",{\"1\":{\"562\":1}}],[\"为参数1\",{\"1\":{\"562\":1}}],[\"为\",{\"1\":{\"562\":4,\"579\":2,\"740\":2,\"741\":2,\"743\":1,\"948\":1,\"1171\":1,\"1252\":1,\"1370\":3,\"1394\":3,\"1438\":1}}],[\"为1则继续运行并将counter置为0\",{\"1\":{\"549\":1}}],[\"为0则进入cond阻塞\",{\"1\":{\"549\":1}}],[\"为什么我们记得过去\",{\"1\":{\"1525\":1}}],[\"为什么spring还要使用jdk动态代理\",{\"0\":{\"1512\":1}}],[\"为什么stampedlock可以提升并发度的性能\",{\"1\":{\"590\":1}}],[\"为什么有这么麻烦的一套东西呢\",{\"1\":{\"1321\":1}}],[\"为什么采用set集合\",{\"1\":{\"1161\":1}}],[\"为什么需要幂等性\",{\"0\":{\"1003\":1}}],[\"为什么需要协议\",{\"0\":{\"709\":1}}],[\"为什么datanode之间采用pipeline线性传输\",{\"1\":{\"898\":1}}],[\"为什么\",{\"1\":{\"839\":1}}],[\"为什么不在一个线程中去执行建立连接\",{\"1\":{\"755\":1}}],[\"为什么用户态与内核态的转换开销大\",{\"1\":{\"676\":1}}],[\"为什么用pc寄存器记录当前线程的执行地址呢\",{\"1\":{\"625\":1}}],[\"为什么它比直接将buffer\",{\"1\":{\"506\":1}}],[\"为什么b+树比b树更适合做索引\",{\"0\":{\"488\":1}}],[\"为什么索引使用b+树\",{\"0\":{\"487\":1}}],[\"为什么要使用缓存\",{\"0\":{\"1114\":1}}],[\"为什么要使用单例模式详解\",{\"1\":{\"64\":1}}],[\"为什么要有虚拟地址空间呢\",{\"0\":{\"685\":1}}],[\"为什么要有很多收集器\",{\"1\":{\"638\":1}}],[\"为什么要有gc\",{\"1\":{\"633\":1}}],[\"为什么要停顿两次\",{\"1\":{\"633\":1}}],[\"为什么要保证主从节点机器时钟一致\",{\"1\":{\"530\":1}}],[\"为什么要引入管程\",{\"1\":{\"173\":1}}],[\"为表中的userid构建索引\",{\"1\":{\"423\":1}}],[\"为每个线程分配一块tlab\",{\"1\":{\"630\":1}}],[\"为每行分配一个从1开始的序列号\",{\"1\":{\"363\":2}}],[\"为每行分配一个从1开始的唯一序列号\",{\"1\":{\"363\":1}}],[\"为每一个页面设置一个访问位\",{\"1\":{\"191\":1}}],[\"为描述数据的数据\",{\"1\":{\"238\":1}}],[\"为shell命令行\",{\"1\":{\"232\":1}}],[\"为单位\",{\"1\":{\"201\":1,\"209\":1,\"694\":1}}],[\"为其分配很大的连续空间会很不方便\",{\"1\":{\"188\":1}}],[\"为离散分配的页表再建立一张页表\",{\"1\":{\"186\":1}}],[\"为防止恶意操作\",{\"1\":{\"85\":1}}],[\"为良好的代码设计和可维护性\",{\"1\":{\"63\":1}}],[\"为了减少内存的消耗\",{\"1\":{\"1223\":1}}],[\"为了减少io\",{\"0\":{\"486\":1}}],[\"为了在反序列化时知道对象的类型\",{\"1\":{\"1223\":1}}],[\"为了完成这件事我们在\",{\"1\":{\"1155\":1}}],[\"为了增加id的安全性\",{\"1\":{\"1131\":1}}],[\"为了解决这个问题\",{\"1\":{\"1066\":1,\"1153\":1}}],[\"为了解决此问题\",{\"1\":{\"694\":1}}],[\"为了确保消费者消费的数据是一致的\",{\"1\":{\"1043\":1}}],[\"为了实现生产者的幂等性\",{\"1\":{\"1029\":1}}],[\"为了实现本地到远程的通信\",{\"1\":{\"63\":1}}],[\"为了方便\",{\"1\":{\"984\":1}}],[\"为了方便操作系统管理\",{\"1\":{\"159\":1}}],[\"为了和tgs区分\",{\"1\":{\"923\":1}}],[\"为了适应异构的工作负载\",{\"1\":{\"875\":1}}],[\"为了支持纠删码\",{\"1\":{\"875\":1}}],[\"为了支持更多序列化算法\",{\"1\":{\"723\":1}}],[\"为了简化起见\",{\"1\":{\"733\":1}}],[\"为了双工通信\",{\"1\":{\"712\":1}}],[\"为了节省内存而采用的\",{\"1\":{\"665\":1}}],[\"为了节约内存而开发的\",{\"1\":{\"665\":1}}],[\"为了兼容部分\",{\"1\":{\"663\":1}}],[\"为了防止插入幻影记录而提出的\",{\"1\":{\"511\":1}}],[\"为了防止低优先级进程发生饥饿\",{\"1\":{\"181\":1}}],[\"为了使row\",{\"1\":{\"437\":1}}],[\"为了加快读取orc文件中的数据内容\",{\"1\":{\"437\":1}}],[\"为了避免查询时全表扫描数据\",{\"1\":{\"259\":1}}],[\"为了能够知道进程的每一个页面在内存中的存放位置\",{\"1\":{\"184\":1}}],[\"为了能够进行有效的管理\",{\"1\":{\"159\":1}}],[\"为了能对系统死锁进行检测需要满足的条件\",{\"1\":{\"178\":1}}],[\"为了保证该进程能正常运行\",{\"1\":{\"690\":1}}],[\"为了保证用户进程不能直接操作系统内核\",{\"1\":{\"676\":1}}],[\"为了保证进程间的安全通信\",{\"1\":{\"162\":1}}],[\"为了保证安全\",{\"1\":{\"162\":1}}],[\"为了保证系统能够安全运行\",{\"1\":{\"156\":1}}],[\"为了提高redis的可用性\",{\"1\":{\"1153\":1}}],[\"为了提高内存的空间性能\",{\"1\":{\"683\":1}}],[\"为了提高mapreduce的性能\",{\"1\":{\"447\":1}}],[\"为了提高数据的查询效率\",{\"1\":{\"420\":1}}],[\"为了提高cpu的利用率\",{\"1\":{\"160\":1}}],[\"为了提高软件系统的可维护性和可复用性\",{\"1\":{\"71\":1}}],[\"为了对各个进程进行管理\",{\"1\":{\"160\":1}}],[\"为了演示方便\",{\"1\":{\"42\":1}}],[\"为jdk的动态代理提供了很好的补充\",{\"1\":{\"60\":1}}],[\"为此目的\",{\"1\":{\"1067\":1}}],[\"为此引入线程来增加并发度\",{\"1\":{\"163\":1}}],[\"为此\",{\"1\":{\"46\":1,\"506\":1,\"882\":2}}],[\"为原始类定义一个代理类\",{\"1\":{\"10\":1}}],[\"第六阶段\",{\"1\":{\"965\":1}}],[\"第五阶段\",{\"1\":{\"965\":1}}],[\"第五步\",{\"1\":{\"85\":2}}],[\"第8步\",{\"1\":{\"953\":1}}],[\"第7步\",{\"1\":{\"953\":1}}],[\"第6步\",{\"1\":{\"953\":1}}],[\"第5步\",{\"1\":{\"953\":1}}],[\"第4步\",{\"1\":{\"953\":1}}],[\"第3步\",{\"1\":{\"953\":1}}],[\"第2步\",{\"1\":{\"953\":1}}],[\"第2面供我们充电\",{\"1\":{\"4\":1}}],[\"第1步\",{\"1\":{\"953\":1}}],[\"第\",{\"1\":{\"726\":2,\"1023\":1,\"1313\":1}}],[\"第四阶段\",{\"1\":{\"965\":1}}],[\"第四轮扫描一定会有一个帧被选中\",{\"1\":{\"191\":1}}],[\"第四轮\",{\"1\":{\"191\":1}}],[\"第四步\",{\"1\":{\"85\":2}}],[\"第三方的配置类\",{\"1\":{\"1466\":1}}],[\"第三方\",{\"1\":{\"1447\":1}}],[\"第三种情况就mmp了\",{\"1\":{\"1003\":1}}],[\"第三阶段是对排序后的键值对调用reduce方法\",{\"1\":{\"966\":1}}],[\"第三阶段\",{\"1\":{\"965\":1}}],[\"第三块副本\",{\"1\":{\"900\":1}}],[\"第三个参数为默认值\",{\"1\":{\"365\":2}}],[\"第三轮\",{\"1\":{\"191\":1}}],[\"第三次握手\",{\"1\":{\"726\":1}}],[\"第三次\",{\"1\":{\"186\":1,\"748\":2}}],[\"第三步\",{\"1\":{\"85\":2,\"477\":1}}],[\"第二种是通过\",{\"1\":{\"1298\":1}}],[\"第二种解决方案\",{\"1\":{\"1177\":1}}],[\"第二种merge方式一直在运行\",{\"1\":{\"980\":1}}],[\"第二页这个时候拿数据\",{\"1\":{\"1167\":1}}],[\"第二阶段\",{\"1\":{\"965\":1,\"966\":1}}],[\"第二块副本相同机架不同机器\",{\"1\":{\"900\":1}}],[\"第二块副本\",{\"1\":{\"900\":1}}],[\"第二版\",{\"0\":{\"737\":1,\"738\":1}}],[\"第二张牌倒下\",{\"1\":{\"666\":1}}],[\"第二方面\",{\"1\":{\"506\":1}}],[\"第二行数据\",{\"1\":{\"351\":1}}],[\"第二个难点是由于我们校验和\",{\"1\":{\"1155\":1}}],[\"第二个线程删除锁时\",{\"1\":{\"1147\":1}}],[\"第二个线程\",{\"1\":{\"1144\":1}}],[\"第二个作业job\",{\"1\":{\"991\":1}}],[\"第二个阶段是由\",{\"1\":{\"952\":1}}],[\"第二个datanode存储数据包并且发送给第三个\",{\"1\":{\"901\":1}}],[\"第二个mapreduce将上一步聚合的结果再按照业务\",{\"1\":{\"466\":1}}],[\"第二个mapreduce对第一个mapreduce的结果做order\",{\"1\":{\"452\":1}}],[\"第二个select是将修改的数据的endtime修改为新数据starttime的starttime\",{\"1\":{\"409\":1}}],[\"第二个参数\",{\"1\":{\"395\":1}}],[\"第二个参数为往下第n行\",{\"1\":{\"365\":1}}],[\"第二个参数为往上第n行\",{\"1\":{\"365\":1}}],[\"第二个参数n表示返回的行数\",{\"1\":{\"309\":1}}],[\"第二个字段是获取总冠军的年份\",{\"1\":{\"348\":1}}],[\"第二轮\",{\"1\":{\"191\":1}}],[\"第二轮扫描一定会有访问位为0的页面\",{\"1\":{\"191\":1}}],[\"第二次触发了\",{\"1\":{\"837\":1}}],[\"第二次握手\",{\"1\":{\"726\":1}}],[\"第二次\",{\"1\":{\"186\":1,\"693\":1,\"748\":2}}],[\"第二原则\",{\"1\":{\"105\":1}}],[\"第二步\",{\"1\":{\"42\":1,\"85\":2,\"477\":1,\"478\":1,\"1172\":1}}],[\"第一种是通过\",{\"1\":{\"1298\":1}}],[\"第一种解决方案\",{\"1\":{\"1177\":1}}],[\"第一阶段\",{\"1\":{\"965\":1,\"966\":1}}],[\"第一块副本\",{\"1\":{\"900\":1}}],[\"第一版\",{\"0\":{\"736\":1}}],[\"第一张牌倒下了\",{\"1\":{\"666\":1}}],[\"第一方面\",{\"1\":{\"506\":1}}],[\"第一行到当前行\",{\"1\":{\"361\":1}}],[\"第一个难点是我们怎么在\",{\"1\":{\"1155\":1}}],[\"第一个线程进来\",{\"1\":{\"1147\":1}}],[\"第一个线程进入时\",{\"1\":{\"1141\":1}}],[\"第一个线程持有锁后\",{\"1\":{\"1144\":1}}],[\"第一个做的job\",{\"1\":{\"991\":1}}],[\"第一个阶段是启动\",{\"1\":{\"952\":1}}],[\"第一个数据节点保存数据之后再将块复制到第二个数据节点\",{\"1\":{\"898\":1}}],[\"第一个select是union所有新增数据\",{\"1\":{\"409\":1}}],[\"第一个值\",{\"1\":{\"365\":1}}],[\"第一个参数\",{\"1\":{\"395\":1,\"396\":1}}],[\"第一个参数为列名\",{\"1\":{\"365\":2}}],[\"第一个参数m表示相对第一行的偏移量\",{\"1\":{\"309\":1}}],[\"第一个字段表示球队名称\",{\"1\":{\"348\":1}}],[\"第一个mapreduce自动进行随机分布到reducer中\",{\"1\":{\"466\":1}}],[\"第一个mapreduce做group\",{\"1\":{\"452\":1}}],[\"第一个map\",{\"1\":{\"326\":1}}],[\"第一个读取singleton对象\",{\"1\":{\"68\":1}}],[\"第一轮\",{\"1\":{\"191\":1}}],[\"第一原则\",{\"1\":{\"105\":1}}],[\"第一次超时之后\",{\"1\":{\"1003\":1}}],[\"第一次减库存超时\",{\"1\":{\"1003\":1}}],[\"第一次调用服务超时\",{\"1\":{\"1003\":1}}],[\"第一次触发了\",{\"1\":{\"837\":1}}],[\"第一次握手\",{\"1\":{\"726\":1}}],[\"第一次读的时候会获取version的取值\",{\"1\":{\"507\":1}}],[\"第一次\",{\"1\":{\"186\":1,\"693\":1,\"748\":2}}],[\"第一次排\",{\"1\":{\"183\":1}}],[\"第一次加载singleton类时不会去初始化instance\",{\"1\":{\"66\":1}}],[\"第一次判断\",{\"1\":{\"66\":2}}],[\"第一步\",{\"1\":{\"42\":1,\"85\":1,\"477\":1,\"478\":1,\"1172\":1}}],[\"美式甜点工厂\",{\"1\":{\"39\":1}}],[\"美式咖啡和抹茶慕斯是同一产品族\",{\"1\":{\"39\":1}}],[\"美式咖啡是一个产品等级\",{\"1\":{\"39\":1}}],[\"美式咖啡\",{\"1\":{\"25\":1}}],[\"提取数据\",{\"1\":{\"972\":1}}],[\"提取正则匹配到的指定组内容\",{\"1\":{\"336\":1}}],[\"提示\",{\"1\":{\"1181\":1}}],[\"提示💡\",{\"0\":{\"787\":1}}],[\"提示cms未来将会被废弃\",{\"1\":{\"640\":1}}],[\"提交offset\",{\"1\":{\"1051\":1}}],[\"提交作业并等待执行完成\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"提交作业\",{\"1\":{\"962\":1}}],[\"提交job作业\",{\"1\":{\"962\":1}}],[\"提交任务\",{\"1\":{\"757\":1}}],[\"提交任务代码\",{\"1\":{\"741\":1}}],[\"提交首个任务\",{\"1\":{\"741\":1}}],[\"提交到yarn运行返回会导致性能较差的问题\",{\"1\":{\"444\":1}}],[\"提交到集群时\",{\"1\":{\"444\":1}}],[\"提出了快表的概念\",{\"1\":{\"683\":1}}],[\"提出了多级页表的概念\",{\"1\":{\"683\":1}}],[\"提出图像转译的通用框架\",{\"1\":{\"130\":1}}],[\"提到这个问题得区分i是成员变量\",{\"1\":{\"560\":1}}],[\"提前动作\",{\"1\":{\"934\":1}}],[\"提前过滤\",{\"0\":{\"468\":1}}],[\"提前执行过滤\",{\"1\":{\"459\":1}}],[\"提升redis的i\",{\"1\":{\"517\":1}}],[\"提升的效率会更明显\",{\"1\":{\"493\":1}}],[\"提升性能\",{\"1\":{\"470\":1}}],[\"提升整体性能\",{\"1\":{\"459\":1}}],[\"提升了像过滤\",{\"1\":{\"438\":1}}],[\"提升了并发度\",{\"1\":{\"163\":1}}],[\"提高安全性\",{\"1\":{\"1147\":1}}],[\"提高文件读取性能\",{\"1\":{\"989\":1}}],[\"提高集群性能\",{\"1\":{\"889\":1}}],[\"提高的是吞吐量\",{\"1\":{\"755\":1}}],[\"提高垃圾收集的性能\",{\"1\":{\"638\":1}}],[\"提高线程的可管理性\",{\"1\":{\"570\":1}}],[\"提高响应速度\",{\"1\":{\"570\":1}}],[\"提高了性能\",{\"1\":{\"450\":1}}],[\"提高了查询效率\",{\"1\":{\"276\":1}}],[\"提高性能\",{\"1\":{\"446\":1,\"1321\":1}}],[\"提高查询性能\",{\"1\":{\"426\":1}}],[\"提高hive表指定列的查询速度\",{\"1\":{\"422\":1}}],[\"提高数据的查询效率\",{\"1\":{\"420\":1}}],[\"提高程序的性能\",{\"1\":{\"415\":1}}],[\"提高代码复用性\",{\"1\":{\"86\":1}}],[\"提高模块的相对独立性\",{\"1\":{\"76\":1}}],[\"提拉米苏\",{\"1\":{\"39\":1}}],[\"提拉米苏工厂\",{\"1\":{\"39\":1}}],[\"提供运行时的应用监控\",{\"1\":{\"1520\":1}}],[\"提供完整的ioc服务支持\",{\"1\":{\"1501\":1}}],[\"提供对\",{\"1\":{\"1499\":4}}],[\"提供对事务的支持\",{\"1\":{\"1499\":1}}],[\"提供\",{\"1\":{\"1457\":1,\"1458\":2}}],[\"提供增强功能\",{\"1\":{\"1298\":1}}],[\"提供exactly\",{\"1\":{\"1053\":1}}],[\"提供服务的server\",{\"1\":{\"923\":1}}],[\"提供支持\",{\"1\":{\"856\":1}}],[\"提供两个实现\",{\"1\":{\"723\":1}}],[\"提供异步能力\",{\"1\":{\"712\":1}}],[\"提供不同的垃圾收集器\",{\"1\":{\"638\":1}}],[\"提供本地计算模式\",{\"1\":{\"444\":1}}],[\"提供一些扩展逻辑\",{\"1\":{\"1252\":1}}],[\"提供一些额外的信息\",{\"1\":{\"441\":1}}],[\"提供一个配置文件\",{\"1\":{\"1464\":1}}],[\"提供一个接口writablecomparable\",{\"1\":{\"956\":1}}],[\"提供一个员工表视图\",{\"1\":{\"272\":1}}],[\"提供的基本功能\",{\"1\":{\"1240\":1}}],[\"提供的一个对atomiclong改进后的一个类\",{\"1\":{\"1136\":1}}],[\"提供的\",{\"1\":{\"100\":1,\"741\":1,\"1172\":1,\"1454\":4,\"1459\":1,\"1460\":1}}],[\"提供了对\",{\"1\":{\"1499\":1}}],[\"提供了对数据库访问的抽象\",{\"1\":{\"1499\":1}}],[\"提供了对不同redis客户端的整合\",{\"1\":{\"1217\":1}}],[\"提供了面向切面编程的实现\",{\"1\":{\"1499\":1}}],[\"提供了两种另外的\",{\"1\":{\"1298\":1}}],[\"提供了多种初始化手段\",{\"1\":{\"1289\":1}}],[\"提供了多种join方案来实现\",{\"1\":{\"447\":1}}],[\"提供了redistemplate统一api来操作redis\",{\"1\":{\"1217\":1}}],[\"提供了分布式锁的多种多样的功能\",{\"1\":{\"1149\":1}}],[\"提供了主从集群\",{\"1\":{\"1149\":1}}],[\"提供了高可用性\",{\"1\":{\"1067\":1}}],[\"提供了非池化的\",{\"1\":{\"780\":1}}],[\"提供了\",{\"1\":{\"746\":2}}],[\"提供了与真实主题相同的接口\",{\"1\":{\"57\":1}}],[\"提供了创建产品的接口\",{\"1\":{\"33\":1,\"38\":1}}],[\"提供了创建产品的方法\",{\"1\":{\"27\":1}}],[\"提供产品的实例\",{\"1\":{\"13\":1}}],[\"抹茶慕斯也是一个产品等级\",{\"1\":{\"39\":1}}],[\"抹茶慕斯工厂\",{\"1\":{\"39\":1}}],[\"抹茶慕斯类\",{\"1\":{\"39\":1}}],[\"抹茶慕斯等\",{\"1\":{\"39\":1}}],[\"需要利用\",{\"1\":{\"1489\":2}}],[\"需要利用逻辑过期解决缓存击穿问题将逻辑进行封装\",{\"1\":{\"1129\":1}}],[\"需要利用逻辑过期解决缓存击穿问题\",{\"1\":{\"1129\":1}}],[\"需要获取\",{\"1\":{\"1489\":1}}],[\"需要获取数组元素类型\",{\"1\":{\"1489\":1}}],[\"需要根据\",{\"1\":{\"1489\":2}}],[\"需要的组件\",{\"1\":{\"1355\":1}}],[\"需要调用\",{\"1\":{\"1290\":1}}],[\"需要额外设置才能解析\",{\"1\":{\"1248\":1}}],[\"需要手动收集\",{\"1\":{\"1430\":1}}],[\"需要手动添加\",{\"1\":{\"1248\":1}}],[\"需要手动调用方法来初始化单例\",{\"1\":{\"1248\":1}}],[\"需要手动调用\",{\"1\":{\"1248\":1}}],[\"需要存储用户\",{\"1\":{\"1207\":1}}],[\"需要重点考虑一个事情\",{\"1\":{\"1177\":1}}],[\"需要重新消费之前正在处理的分区\",{\"1\":{\"1042\":1}}],[\"需要重新获取读锁\",{\"1\":{\"590\":1}}],[\"需要首先进入到这个页面\",{\"1\":{\"1165\":1}}],[\"需要是唯一的\",{\"1\":{\"1162\":1}}],[\"需要修改\",{\"1\":{\"1159\":1}}],[\"需要缓存重建\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"需要拦截\",{\"1\":{\"1111\":1}}],[\"需要尽快处理\",{\"1\":{\"1055\":1}}],[\"需要到该目录中去查看异常信息\",{\"1\":{\"1013\":1}}],[\"需要实例化一个线程来让它启动\",{\"1\":{\"991\":1}}],[\"需要实现序列化接口writable和数据库操作接口dbwritable\",{\"1\":{\"985\":1}}],[\"需要实现的功能\",{\"1\":{\"154\":1}}],[\"需要实现的功能和目标\",{\"1\":{\"154\":2}}],[\"需要涉及跨机器跨网络通信\",{\"1\":{\"949\":1}}],[\"需要w权限才能创建或删除文件或目录\",{\"1\":{\"918\":1}}],[\"需要r权限才能列出目录的内容\",{\"1\":{\"918\":1}}],[\"需要r权限才能读取文件\",{\"1\":{\"918\":1}}],[\"需要读取的文件就是datanode数据目录中的某个文件\",{\"1\":{\"872\":1}}],[\"需要结合服务器的设计演化来理解它的用途\",{\"1\":{\"862\":1}}],[\"需要再次\",{\"1\":{\"859\":1}}],[\"需要再次调用\",{\"1\":{\"859\":2}}],[\"需要扩容\",{\"1\":{\"840\":1}}],[\"需要提前分配\",{\"1\":{\"840\":1}}],[\"需要我们自己编码删除\",{\"1\":{\"837\":1}}],[\"需要多线程支持\",{\"1\":{\"826\":1}}],[\"需要释放\",{\"1\":{\"794\":3}}],[\"需要自己构建协议\",{\"1\":{\"792\":1}}],[\"需要更复杂的规则来回收内存\",{\"1\":{\"775\":1}}],[\"需要特殊的方法来回收内存\",{\"1\":{\"775\":1}}],[\"需要分两种情况来看\",{\"1\":{\"740\":1}}],[\"需要从协议的字节中得到是哪种序列化算法\",{\"1\":{\"723\":1}}],[\"需要用redis命令来调用脚本\",{\"1\":{\"1146\":1}}],[\"需要用\",{\"1\":{\"822\":1,\"1482\":1}}],[\"需要用它来发布响应\",{\"1\":{\"718\":1}}],[\"需要用它来给发布者响应\",{\"1\":{\"717\":1}}],[\"需要用到时调入内存\",{\"1\":{\"181\":1}}],[\"需要时再调入\",{\"1\":{\"683\":1}}],[\"需要时可在缓冲区中前后移动\",{\"1\":{\"610\":1}}],[\"需要维护一个用来存放大量fd的数据结构\",{\"1\":{\"680\":1}}],[\"需要通过遍历的方式来统计字符串长度\",{\"1\":{\"663\":1}}],[\"需要通过子类来决定父类算法中某个步骤是否执行\",{\"1\":{\"87\":1}}],[\"需要造成系统长时间的停顿\",{\"1\":{\"634\":1}}],[\"需要具体分析是老年代回收还是整堆回收\",{\"1\":{\"628\":1}}],[\"需要创建大量的线程来处理连接\",{\"1\":{\"609\":1}}],[\"需要进行加读锁\",{\"1\":{\"590\":1}}],[\"需要进行对应的修改\",{\"1\":{\"483\":1}}],[\"需要子类实现的方法\",{\"1\":{\"585\":1}}],[\"需要子类实现\",{\"1\":{\"585\":6}}],[\"需要考虑线程安全问题\",{\"1\":{\"539\":1}}],[\"需要把旧节点的数据迁移一部分到新节点\",{\"1\":{\"527\":1}}],[\"需要大部分的哨兵都同意才行\",{\"1\":{\"526\":1}}],[\"需要对这80mb空间内的key做排序\",{\"1\":{\"979\":1}}],[\"需要对写加锁\",{\"1\":{\"578\":1}}],[\"需要对数据根据某个权重进行排序的场景\",{\"1\":{\"515\":1}}],[\"需要对目录进行哪些操作\",{\"1\":{\"196\":1}}],[\"需要等待当前事务提交或回滚后释放锁\",{\"1\":{\"506\":1}}],[\"需要先在业务层中向线程变量存入province属性\",{\"1\":{\"1232\":1}}],[\"需要先指定10位的机器码\",{\"1\":{\"998\":1}}],[\"需要先获得相应的锁\",{\"1\":{\"506\":1}}],[\"需要先将其他资源分配到位\",{\"1\":{\"160\":1}}],[\"需要哪些字段必须明确写明\",{\"1\":{\"483\":1}}],[\"需要仔细评估in后边的集合元素数量\",{\"1\":{\"482\":1}}],[\"需要join的字段\",{\"1\":{\"481\":1}}],[\"需要及时更新字段注释\",{\"1\":{\"480\":1}}],[\"需要占用内存空间存放小的数据文件\",{\"1\":{\"448\":1}}],[\"需要占用很多个连续的页框\",{\"1\":{\"186\":1}}],[\"需要申请资源\",{\"1\":{\"444\":1}}],[\"需要搭配lateral\",{\"1\":{\"396\":1}}],[\"需要较长的计算时间\",{\"1\":{\"314\":1}}],[\"需要使用orc\",{\"1\":{\"293\":1}}],[\"需要使用特权指令\",{\"1\":{\"157\":1}}],[\"需要注意的是对于innodb引擎来说\",{\"1\":{\"508\":1}}],[\"需要注意的是\",{\"1\":{\"264\":1,\"511\":1,\"948\":1,\"1525\":1}}],[\"需要配置的参数如下\",{\"1\":{\"963\":1}}],[\"需要配置参数开启事务使用\",{\"1\":{\"296\":1}}],[\"需要配置参数开启使用\",{\"1\":{\"267\":1}}],[\"需要配置hive\",{\"1\":{\"244\":1}}],[\"需要配件cpu\",{\"1\":{\"74\":1}}],[\"需要将统计过的用户信息保存\",{\"1\":{\"1179\":1}}],[\"需要将数据放入到set集合中\",{\"1\":{\"1165\":1}}],[\"需要将json反序列化成对象\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"需要将传入的正文数据还原成\",{\"1\":{\"723\":1}}],[\"需要将\",{\"1\":{\"723\":1}}],[\"需要将每个节点设置成集群模式\",{\"1\":{\"527\":1}}],[\"需要将order\",{\"1\":{\"315\":1}}],[\"需要将子句放在括住select的括号内\",{\"1\":{\"315\":1}}],[\"需要将超级块中的数据复制到新回收的块中\",{\"1\":{\"198\":1}}],[\"需要将一整块的空闲分区合并\",{\"1\":{\"182\":1}}],[\"需要100个空闲块\",{\"1\":{\"198\":1}}],[\"需要换出页面时选择队头页面即可\",{\"1\":{\"191\":1}}],[\"需要新增一个空闲分区\",{\"1\":{\"182\":1}}],[\"需要常驻内存的段放入固定区\",{\"1\":{\"181\":1}}],[\"需要\",{\"1\":{\"179\":1,\"1317\":1,\"1384\":2}}],[\"需要在job中将reducetask的个数设置为0\",{\"1\":{\"990\":1}}],[\"需要在namenode启动前配置\",{\"1\":{\"879\":1}}],[\"需要在当下的集群中停止某些机器上datanode的服务\",{\"1\":{\"879\":1}}],[\"需要在原有集群基础上动态添加新的datanode节点\",{\"1\":{\"878\":1}}],[\"需要在数据库服务器端生成\",{\"1\":{\"501\":1}}],[\"需要在目录中删除相应的目录项\",{\"1\":{\"196\":1}}],[\"需要在其所属的目录中增加一个目录项\",{\"1\":{\"196\":1}}],[\"需要在内核态\",{\"1\":{\"170\":1}}],[\"需要在b中使用a类的方法\",{\"1\":{\"73\":1}}],[\"需要p0进程先访问才行\",{\"1\":{\"169\":1}}],[\"需要协调他们工作的次序\",{\"1\":{\"168\":1}}],[\"需要切换到核心态\",{\"1\":{\"163\":1}}],[\"需要切换进程的运行环境\",{\"1\":{\"163\":1}}],[\"需要经过长期摸索和反复调试\",{\"1\":{\"107\":1}}],[\"需要去火车站买票\",{\"1\":{\"58\":1}}],[\"需要定义提拉米苏类\",{\"1\":{\"39\":1}}],[\"需求分析\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"需求也会因为commit所释放的资源而减少\",{\"1\":{\"499\":1}}],[\"需求案例\",{\"1\":{\"110\":1}}],[\"需求\",{\"0\":{\"381\":1,\"384\":1,\"387\":1,\"390\":1},\"1\":{\"25\":1,\"344\":1,\"360\":4,\"361\":2,\"363\":1,\"364\":1,\"367\":1,\"401\":1,\"403\":1,\"455\":1,\"983\":1,\"991\":1,\"1025\":1,\"1128\":1,\"1137\":1,\"1144\":1,\"1156\":1,\"1161\":1,\"1164\":1,\"1165\":1,\"1167\":1,\"1168\":1,\"1175\":1,\"1176\":1}}],[\"且开启的事务互相独立\",{\"1\":{\"1514\":1}}],[\"且\",{\"1\":{\"1325\":1}}],[\"且需要学习新的\",{\"1\":{\"1298\":1}}],[\"且实现起来麻烦\",{\"1\":{\"1126\":1}}],[\"且实现简单\",{\"1\":{\"1126\":1}}],[\"且只能串行执行性能肯定受到影响\",{\"1\":{\"1126\":1}}],[\"且只是偶尔写的并发场景\",{\"1\":{\"578\":1}}],[\"且在未来版本中会被删除\",{\"1\":{\"1071\":1}}],[\"且client总是主动连接\",{\"1\":{\"949\":1}}],[\"且该任务只能使用该\",{\"1\":{\"948\":1}}],[\"且周期性地向所有namenode发送心跳和块报告\",{\"1\":{\"889\":1}}],[\"且当一个线程独占时\",{\"1\":{\"582\":1}}],[\"且是静默丢弃\",{\"1\":{\"573\":1}}],[\"且集群配置非常简单\",{\"1\":{\"527\":1}}],[\"且单个主节点内存也不宜设的过大\",{\"1\":{\"526\":1}}],[\"且处于性能考虑\",{\"1\":{\"506\":1}}],[\"且使用的系统和事务日志资源少\",{\"1\":{\"482\":1}}],[\"且扩大了表示范围\",{\"1\":{\"480\":1}}],[\"且这些块读入内存后在\",{\"1\":{\"209\":1}}],[\"且这些寄存器都要有相应的地址\",{\"1\":{\"208\":1}}],[\"且为线性相关\",{\"1\":{\"204\":1}}],[\"且顶级索引表未调入内存\",{\"1\":{\"197\":1}}],[\"且修改过的页面\",{\"1\":{\"191\":1}}],[\"且被修改过\",{\"1\":{\"191\":1}}],[\"且与ground\",{\"1\":{\"139\":1}}],[\"且所有产品的接口相同\",{\"1\":{\"41\":1}}],[\"且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构\",{\"1\":{\"37\":1}}],[\"且要求程序员了解现有组件库中的相关组件的内部结构\",{\"1\":{\"4\":1}}],[\"纵轴是产品族\",{\"1\":{\"36\":1}}],[\"的理念让你的项目快速的运行起来\",{\"1\":{\"1520\":1}}],[\"的理解\",{\"0\":{\"635\":1}}],[\"的理解和使用即可\",{\"1\":{\"91\":1}}],[\"的帮助\",{\"1\":{\"1499\":1}}],[\"的处理\",{\"1\":{\"1489\":2}}],[\"的处理器\",{\"1\":{\"784\":1,\"785\":1}}],[\"的职责\",{\"1\":{\"1472\":1}}],[\"的导入会在最后执行\",{\"1\":{\"1465\":1}}],[\"的各项组件\",{\"1\":{\"1459\":1}}],[\"的本质是向容器中添加了\",{\"1\":{\"1453\":1}}],[\"的有独立的示例\",{\"1\":{\"1444\":1}}],[\"的骨架\",{\"1\":{\"1440\":1}}],[\"的适配调用\",{\"1\":{\"1437\":1}}],[\"的适配使用的是inputstreamreader\",{\"1\":{\"9\":1}}],[\"的视图\",{\"1\":{\"1416\":1}}],[\"的响应\",{\"1\":{\"1411\":1}}],[\"的错误页处理手段\",{\"1\":{\"1414\":1}}],[\"的错误页面\",{\"1\":{\"1411\":1}}],[\"的错误处理\",{\"1\":{\"1411\":2}}],[\"的顺序\",{\"1\":{\"1398\":1}}],[\"的顺序执行的\",{\"1\":{\"766\":1}}],[\"的顺序执行\",{\"1\":{\"169\":1}}],[\"的解析结果都会缓存来避免重复解析\",{\"1\":{\"1382\":1,\"1390\":1,\"1410\":1}}],[\"的转换器\",{\"1\":{\"1376\":2}}],[\"的转换优先级\",{\"1\":{\"1376\":1}}],[\"的属性执行绑定\",{\"1\":{\"1370\":1}}],[\"的属性赋值\",{\"1\":{\"1370\":2}}],[\"的编程技巧在实现拦截器\",{\"1\":{\"1346\":1}}],[\"的后增强\",{\"1\":{\"1340\":2}}],[\"的一项体现\",{\"1\":{\"1485\":1}}],[\"的一堆方法\",{\"1\":{\"1321\":1}}],[\"的一个属性来配置\",{\"1\":{\"1455\":1}}],[\"的一个重要成员变量就是\",{\"1\":{\"1243\":1}}],[\"的一个state变量来记录重入的状态的\",{\"1\":{\"1151\":1}}],[\"的获取\",{\"1\":{\"1297\":1,\"1489\":2}}],[\"的四种解决方法\",{\"1\":{\"1297\":1}}],[\"的销毁\",{\"1\":{\"1293\":1}}],[\"的销毁时机\",{\"1\":{\"1293\":1}}],[\"的初始化阶段完成的\",{\"1\":{\"1453\":1}}],[\"的初始化手段\",{\"1\":{\"1284\":1}}],[\"的初始化的前后\",{\"1\":{\"1252\":1}}],[\"的名字匹配\",{\"1\":{\"1437\":1}}],[\"的名字会被当作映射路径\",{\"1\":{\"1421\":1}}],[\"的名字作为视图名\",{\"1\":{\"1416\":1}}],[\"的名字找到\",{\"1\":{\"1411\":1}}],[\"的名字\",{\"1\":{\"1284\":1}}],[\"的名字固定为\",{\"1\":{\"1244\":1}}],[\"的注入手段\",{\"1\":{\"1284\":1}}],[\"的注册\",{\"1\":{\"843\":1}}],[\"的诡异做法\",{\"1\":{\"1280\":1}}],[\"的成员变量\",{\"1\":{\"1267\":1}}],[\"的成员变量填充值\",{\"1\":{\"1252\":1}}],[\"的生命周期\",{\"0\":{\"1252\":1}}],[\"的生命周期的各种功能\",{\"1\":{\"1243\":1}}],[\"的例子\",{\"1\":{\"1248\":1}}],[\"的创建方法\",{\"1\":{\"1251\":1}}],[\"的创建过程提供增强\",{\"1\":{\"1248\":1}}],[\"的创建蓝图\",{\"1\":{\"1248\":1}}],[\"的发展历史较为悠久\",{\"1\":{\"1245\":1}}],[\"的用法和扩展点\",{\"1\":{\"1376\":1}}],[\"的用法\",{\"1\":{\"1243\":1}}],[\"的核心容器\",{\"1\":{\"1243\":1}}],[\"的父接口\",{\"1\":{\"1243\":1}}],[\"的子接口\",{\"1\":{\"1240\":1}}],[\"的子类\",{\"1\":{\"766\":2}}],[\"的部分\",{\"1\":{\"1230\":1}}],[\"的关系\",{\"1\":{\"1186\":1}}],[\"的关闭\",{\"1\":{\"752\":1}}],[\"的订单与商品\",{\"1\":{\"1186\":1}}],[\"的误差\",{\"1\":{\"1179\":1}}],[\"的哪一位\",{\"1\":{\"1177\":1}}],[\"的存储空间\",{\"1\":{\"1177\":1}}],[\"的存在\",{\"1\":{\"775\":1}}],[\"的结果做位运算\",{\"1\":{\"1174\":1}}],[\"的结构就把上面这些问题解决了\",{\"1\":{\"662\":1}}],[\"的bit位的数量\",{\"1\":{\"1174\":1}}],[\"的bit值\",{\"1\":{\"1174\":1}}],[\"的简写形式\",{\"1\":{\"1170\":1}}],[\"的体验\",{\"1\":{\"1166\":1}}],[\"的体现之一\",{\"1\":{\"776\":1,\"777\":1,\"779\":1}}],[\"的源码解析以及其看门狗原理\",{\"1\":{\"1152\":1}}],[\"的分布式锁\",{\"1\":{\"1150\":1}}],[\"的基础上实现的java驻内存数据网格\",{\"1\":{\"1149\":1}}],[\"的setnx\",{\"1\":{\"1141\":1}}],[\"的serializer将对象转换成字节序列\",{\"1\":{\"250\":1}}],[\"的条件了\",{\"1\":{\"1135\":1}}],[\"的缓存\",{\"1\":{\"1124\":1,\"1127\":1,\"1129\":1}}],[\"的不良影响\",{\"0\":{\"1038\":1}}],[\"的个数发生变化\",{\"1\":{\"1037\":1}}],[\"的每个分区的机制\",{\"1\":{\"1037\":1}}],[\"的容错\",{\"1\":{\"1026\":1}}],[\"的服务器地址\",{\"1\":{\"1023\":1}}],[\"的服务器端实现\",{\"1\":{\"784\":1}}],[\"的网站帮助文件\",{\"1\":{\"1013\":1}}],[\"的所有io资源\",{\"1\":{\"1056\":1}}],[\"的所有日志文件\",{\"1\":{\"1013\":1}}],[\"的所有配置文件\",{\"1\":{\"1013\":1}}],[\"的所有执行脚本都在这里\",{\"1\":{\"1013\":1}}],[\"的安装包上传到虚拟机\",{\"1\":{\"1012\":1}}],[\"的系统\",{\"1\":{\"998\":1}}],[\"的自增原子性来生成唯一\",{\"1\":{\"997\":1}}],[\"的全局唯一性\",{\"1\":{\"997\":1}}],[\"的命令\",{\"1\":{\"953\":1}}],[\"的使用状态等信息\",{\"1\":{\"949\":1}}],[\"的缩写形式\",{\"1\":{\"949\":1}}],[\"的运行状态\",{\"1\":{\"946\":1}}],[\"的密匙\",{\"1\":{\"934\":1}}],[\"的叫做密钥库\",{\"1\":{\"932\":1}}],[\"的超级用户代表用户vingkin提交作业并访问hdfs\",{\"1\":{\"927\":1}}],[\"的profile文件拷贝到node4\",{\"1\":{\"878\":1}}],[\"的读能力\",{\"1\":{\"854\":1}}],[\"的力量被白白浪费\",{\"1\":{\"846\":1}}],[\"的话\",{\"1\":{\"841\":1}}],[\"的联系\",{\"1\":{\"840\":1}}],[\"的作用\",{\"0\":{\"1396\":1},\"1\":{\"1333\":1,\"1398\":1,\"1446\":1}}],[\"的作用就是配合一个线程来管理多个\",{\"1\":{\"867\":1}}],[\"的作用💡\",{\"0\":{\"838\":1}}],[\"的作者\",{\"0\":{\"790\":1}}],[\"的可写事件\",{\"1\":{\"828\":1,\"843\":1}}],[\"的非阻塞模式\",{\"1\":{\"828\":1}}],[\"的数字计数器\",{\"1\":{\"1176\":1}}],[\"的数字即可\",{\"1\":{\"1176\":1}}],[\"的数目\",{\"1\":{\"822\":1}}],[\"的数据写入\",{\"1\":{\"861\":1}}],[\"的数据填充至\",{\"1\":{\"808\":1}}],[\"的数据达到\",{\"1\":{\"694\":1}}],[\"的数据类型都是\",{\"1\":{\"663\":1}}],[\"的数据\",{\"1\":{\"663\":1,\"707\":1}}],[\"的数据结构\",{\"1\":{\"663\":1}}],[\"的数据结构来表示字符串\",{\"1\":{\"661\":1}}],[\"的线程安全⚠️\",{\"0\":{\"806\":1}}],[\"的线程来调用\",{\"1\":{\"749\":1}}],[\"的位置\",{\"1\":{\"804\":1}}],[\"的双向信号传输\",{\"1\":{\"795\":1}}],[\"的开发迭代更迅速\",{\"1\":{\"792\":1}}],[\"的优势\",{\"0\":{\"792\":1}}],[\"的地位\",{\"0\":{\"791\":1}}],[\"的重要贡献者\",{\"1\":{\"790\":1}}],[\"的规划\",{\"1\":{\"787\":1}}],[\"的待处理任务\",{\"1\":{\"787\":1}}],[\"的加工\",{\"1\":{\"787\":1}}],[\"的客户端实现\",{\"1\":{\"785\":1}}],[\"的业务处理器\",{\"1\":{\"784\":1}}],[\"的限制\",{\"1\":{\"777\":1}}],[\"的内容\",{\"1\":{\"803\":1}}],[\"的内容发生了更改\",{\"1\":{\"776\":1}}],[\"的内存\",{\"1\":{\"776\":1}}],[\"的整数倍\",{\"1\":{\"773\":1}}],[\"的逆序执行的\",{\"1\":{\"766\":1}}],[\"的失败结果而不会抛出\",{\"1\":{\"765\":1}}],[\"的功能\",{\"1\":{\"756\":1,\"1243\":1,\"1245\":1}}],[\"的主要作用\",{\"1\":{\"752\":1}}],[\"的事件\",{\"1\":{\"829\":1}}],[\"的事件循环是否与当前的事件循环是同一个线程\",{\"1\":{\"749\":1}}],[\"的事件注册\",{\"1\":{\"740\":1,\"743\":1}}],[\"的能力\",{\"1\":{\"746\":1}}],[\"的逻辑是如果预期读取字节与实际读取字节相等\",{\"1\":{\"744\":1}}],[\"的逻辑如下\",{\"1\":{\"741\":1}}],[\"的实现是一个\",{\"1\":{\"766\":1}}],[\"的实现\",{\"1\":{\"744\":1,\"1455\":1,\"1499\":1}}],[\"的置换功能\",{\"1\":{\"688\":1}}],[\"的两级存储器的结构\",{\"1\":{\"687\":1}}],[\"的连接\",{\"1\":{\"680\":1}}],[\"的就绪通知方式\",{\"1\":{\"680\":1}}],[\"的问题\",{\"1\":{\"667\":2}}],[\"的扩展功能\",{\"1\":{\"1264\":1,\"1271\":1}}],[\"的扩展\",{\"1\":{\"666\":2}}],[\"的前置节点\",{\"1\":{\"666\":1}}],[\"的前提下\",{\"1\":{\"104\":1}}],[\"的长度就大于等于\",{\"1\":{\"666\":1}}],[\"的长度\",{\"1\":{\"665\":1,\"695\":1}}],[\"的构造方法或者工厂方法来创建\",{\"1\":{\"1252\":1}}],[\"的构造方法创建了一个新字符串\",{\"1\":{\"566\":1}}],[\"的构成如下\",{\"1\":{\"665\":1}}],[\"的人提出了一种来检索元素是否在给定大集合中的数据结构\",{\"1\":{\"658\":1}}],[\"的空间大小\",{\"1\":{\"663\":3}}],[\"的空间扩展至执行修改所需的大小\",{\"1\":{\"663\":1}}],[\"的空间\",{\"1\":{\"658\":1}}],[\"的老哥于\",{\"1\":{\"658\":1}}],[\"的元素\",{\"1\":{\"643\":1}}],[\"的变化\",{\"0\":{\"640\":1}}],[\"的调用过程\",{\"1\":{\"1362\":1}}],[\"的调用也会\",{\"1\":{\"766\":1}}],[\"的调用\",{\"1\":{\"635\":1}}],[\"的相应类型的缓存数据\",{\"1\":{\"598\":1}}],[\"的头节点\",{\"1\":{\"579\":1}}],[\"的高效方案\",{\"1\":{\"997\":1}}],[\"的高\",{\"1\":{\"571\":1}}],[\"的当前值\",{\"1\":{\"562\":4}}],[\"的字节码指令\",{\"1\":{\"560\":1}}],[\"的细分\",{\"1\":{\"538\":1}}],[\"的算法\",{\"1\":{\"518\":1}}],[\"的函数才能知道插入的子增值\",{\"1\":{\"501\":1}}],[\"的复杂度\",{\"1\":{\"497\":2}}],[\"的索引\",{\"1\":{\"493\":1}}],[\"的操作命令有\",{\"1\":{\"1174\":1}}],[\"的操作\",{\"1\":{\"493\":1}}],[\"的列\",{\"1\":{\"493\":1}}],[\"的返回结果为null\",{\"1\":{\"482\":1}}],[\"的返回结果为0\",{\"1\":{\"482\":1}}],[\"的区别\",{\"0\":{\"546\":1,\"1241\":1},\"1\":{\"575\":1}}],[\"的区别是什么\",{\"1\":{\"95\":1}}],[\"的区分度来确定\",{\"1\":{\"481\":1,\"493\":1}}],[\"的方式扫描所有标注了\",{\"1\":{\"1455\":1}}],[\"的方式调用的\",{\"1\":{\"1137\":1}}],[\"的方式分配内存\",{\"1\":{\"663\":1}}],[\"的方式处理数据\",{\"1\":{\"612\":1}}],[\"的方式来进行死锁检测\",{\"1\":{\"513\":1}}],[\"的方式来指定path\",{\"1\":{\"395\":1}}],[\"的方法的返回值是\",{\"1\":{\"840\":1}}],[\"的方法\",{\"1\":{\"46\":1,\"1293\":1,\"1317\":1}}],[\"的情况下\",{\"1\":{\"1135\":1}}],[\"的情况\",{\"1\":{\"353\":1,\"567\":1,\"648\":2,\"1230\":1,\"1285\":2}}],[\"的时间\",{\"1\":{\"1476\":1}}],[\"的时间占总时间的比例\",{\"1\":{\"166\":1}}],[\"的时候\",{\"1\":{\"1042\":1}}],[\"的时候会被忽略\",{\"1\":{\"351\":1}}],[\"的时刻调用await\",{\"1\":{\"593\":1}}],[\"的同义词\",{\"1\":{\"330\":1}}],[\"的deserializer\",{\"1\":{\"250\":1}}],[\"的信息\",{\"1\":{\"238\":1}}],[\"的值在三次握手时通知对方自己\",{\"1\":{\"694\":1}}],[\"的值为\",{\"1\":{\"694\":1}}],[\"的值\",{\"1\":{\"237\":1,\"694\":1,\"1174\":1,\"1264\":1,\"1482\":1,\"1485\":1}}],[\"的值将表划分为不同分区\",{\"1\":{\"236\":1}}],[\"的过程中所有的消费者都将停止工作\",{\"1\":{\"1038\":1}}],[\"的过程\",{\"1\":{\"228\":1}}],[\"的帧用于替换\",{\"1\":{\"191\":4}}],[\"的形式表示各页面的状态\",{\"1\":{\"191\":1}}],[\"的技术来解决\",{\"1\":{\"182\":1}}],[\"的什么位置保存被换出的进程\",{\"1\":{\"181\":1}}],[\"的支持\",{\"1\":{\"179\":1,\"1170\":1,\"1499\":2}}],[\"的组成\",{\"1\":{\"159\":1}}],[\"的标志位设置为用户态\",{\"1\":{\"157\":1}}],[\"的项目中\",{\"1\":{\"107\":1}}],[\"的\",{\"1\":{\"100\":1,\"493\":1,\"562\":1,\"661\":1,\"662\":1,\"663\":7,\"666\":1,\"694\":1,\"741\":1,\"746\":1,\"756\":2,\"772\":2,\"776\":1,\"787\":1,\"802\":1,\"803\":1,\"816\":2,\"827\":1,\"840\":1,\"841\":1,\"854\":1,\"867\":1,\"946\":1,\"949\":1,\"1025\":1,\"1040\":1,\"1041\":1,\"1172\":1,\"1175\":1,\"1300\":1,\"1310\":1,\"1313\":1,\"1321\":1,\"1333\":3,\"1343\":1,\"1350\":1,\"1398\":1,\"1416\":1,\"1438\":1,\"1472\":1,\"1482\":1,\"1489\":1,\"1506\":1}}],[\"的配置导入合并到当前\",{\"1\":{\"100\":1}}],[\"的依赖范围一致\",{\"1\":{\"100\":1}}],[\"的依赖管理是\",{\"1\":{\"97\":1}}],[\"的依赖管理能够帮助开发人员自动解决软件包依赖问题\",{\"1\":{\"97\":1}}],[\"的插件机制也使得开发者可以对构建过程进行扩展和定制\",{\"1\":{\"91\":1}}],[\"的类都是\",{\"1\":{\"1245\":1}}],[\"的类\",{\"1\":{\"81\":1}}],[\"的皮肤是输入法背景图片\",{\"1\":{\"72\":1}}],[\"的皮肤设计\",{\"1\":{\"72\":1}}],[\"的皮肤为例介绍开闭原则的应用\",{\"1\":{\"72\":1}}],[\"的产品\",{\"1\":{\"36\":1}}],[\"种类型的主要区别就在于\",{\"1\":{\"663\":1}}],[\"种类型\",{\"1\":{\"663\":2}}],[\"种类等具有标识意义的字段\",{\"1\":{\"259\":1}}],[\"种类\",{\"1\":{\"36\":1}}],[\"能突破一些技术上的限制\",{\"1\":{\"1298\":1}}],[\"能干点啥\",{\"1\":{\"1243\":1}}],[\"能通过它获取各种来源的配置信息\",{\"1\":{\"1240\":1}}],[\"能搜索的数据必须索引\",{\"1\":{\"1061\":1}}],[\"能打开的fd的上限远大于1024\",{\"1\":{\"680\":1}}],[\"能选多少件就选多少件\",{\"1\":{\"649\":1}}],[\"能否根据关键字实现随机查找\",{\"1\":{\"195\":1}}],[\"能否找到第i个记录对应的地址即能否实现随机存储\",{\"1\":{\"195\":1}}],[\"能让我们轻松地以不同的算法去解决同一个问题\",{\"1\":{\"79\":1}}],[\"能够获得关联的切面集合与目标\",{\"1\":{\"1322\":1}}],[\"能够掌握更多的知识\",{\"1\":{\"1152\":1}}],[\"能够及时打印出异常信息\",{\"1\":{\"1025\":1}}],[\"能够及时地被其他线程看到\",{\"1\":{\"556\":1}}],[\"能够减少访问磁盘的次数\",{\"1\":{\"989\":1}}],[\"能够容忍的业务中断时间越少\",{\"1\":{\"882\":1}}],[\"能够保证\",{\"1\":{\"828\":1}}],[\"能够保证在多线程的情况下线程安全也不会有性能问题\",{\"1\":{\"66\":1}}],[\"能够通知程序进行相应的读写操作\",{\"1\":{\"680\":1}}],[\"能够跟踪和记录了缓冲区的状态变化情况\",{\"1\":{\"610\":1}}],[\"能够实现最优的\",{\"1\":{\"576\":1}}],[\"能够实现校验手机号格式\",{\"1\":{\"344\":1}}],[\"能够建立索引的种类分为主键索引\",{\"1\":{\"481\":1}}],[\"能够对输入数据进行非空判断\",{\"1\":{\"344\":1}}],[\"能够从物理内存中找到各个逻辑段的存放位置\",{\"1\":{\"187\":1}}],[\"能够自动解析项目的依赖关系\",{\"1\":{\"97\":1}}],[\"能够整体地替换算法\",{\"1\":{\"79\":1}}],[\"能够飞翔\",{\"1\":{\"19\":1}}],[\"能生产多等级\",{\"1\":{\"36\":1}}],[\"同名\",{\"1\":{\"756\":1}}],[\"同上\",{\"1\":{\"680\":2,\"1023\":1}}],[\"同样test\",{\"1\":{\"923\":1}}],[\"同样\",{\"1\":{\"901\":1,\"1113\":1}}],[\"同样代表了\",{\"1\":{\"821\":1}}],[\"同样有两种办法\",{\"1\":{\"803\":1}}],[\"同样可以向它提交普通任务\",{\"1\":{\"750\":1}}],[\"同样为离散分配的页表在建立一张页表\",{\"1\":{\"683\":1}}],[\"同样加以编号\",{\"1\":{\"683\":1}}],[\"同样地\",{\"1\":{\"683\":1}}],[\"同样包含\",{\"1\":{\"663\":1}}],[\"同样在这条指令之后也会加入写屏障\",{\"1\":{\"567\":1}}],[\"同样是上面的案例\",{\"1\":{\"60\":1}}],[\"同组内所行求和\",{\"1\":{\"360\":1}}],[\"同理\",{\"1\":{\"210\":1}}],[\"同\",{\"1\":{\"175\":1,\"785\":1}}],[\"同步数据\",{\"1\":{\"1048\":1}}],[\"同步配置文件\",{\"1\":{\"936\":1}}],[\"同步集群\",{\"1\":{\"910\":1}}],[\"同步意味着\",{\"1\":{\"856\":1}}],[\"同步多路复用\",{\"1\":{\"851\":1}}],[\"同步非阻塞\",{\"1\":{\"851\":1}}],[\"同步处理任务失败\",{\"1\":{\"762\":1,\"763\":1}}],[\"同步处理任务成功\",{\"1\":{\"760\":1}}],[\"同步处理关闭\",{\"1\":{\"754\":1}}],[\"同步方式处理关闭\",{\"1\":{\"754\":1}}],[\"同步阻塞\",{\"1\":{\"609\":1,\"851\":1}}],[\"同步\",{\"0\":{\"172\":1},\"1\":{\"593\":1,\"851\":1}}],[\"同步也称为直接制约关系\",{\"1\":{\"168\":1}}],[\"同学们在拷贝代码的时候\",{\"1\":{\"1205\":1}}],[\"同学们在操作时\",{\"1\":{\"1159\":1}}],[\"同学们可以自行往下翻一点点\",{\"1\":{\"1152\":1}}],[\"同学们注意他的value\",{\"1\":{\"1104\":1}}],[\"同学\",{\"1\":{\"52\":1,\"54\":1}}],[\"同一个http\",{\"1\":{\"1504\":1}}],[\"同一个用户只能点赞一次\",{\"1\":{\"1161\":1}}],[\"同一毫秒内的最新序号\",{\"1\":{\"999\":1}}],[\"同一毫秒时间戳下\",{\"1\":{\"998\":1}}],[\"同一毫秒时间戳时\",{\"1\":{\"998\":1}}],[\"同一分片多个节点间的数据不保持强一致性\",{\"1\":{\"527\":1}}],[\"同一分区的数据存储在同一个文件夹下\",{\"1\":{\"259\":1}}],[\"同一组数据组成一个新的kv键值对\",{\"1\":{\"961\":1}}],[\"同一组内累计求和\",{\"1\":{\"360\":1}}],[\"同一组所有行求和\",{\"1\":{\"360\":1}}],[\"同一组中必相同\",{\"1\":{\"306\":1}}],[\"同一查询中对current\",{\"1\":{\"337\":1}}],[\"同一查询中可以连接2个以上的表\",{\"1\":{\"326\":1}}],[\"同一进程中的线程切换\",{\"1\":{\"163\":1}}],[\"同一进程中的线程间通信甚至无需系统干预\",{\"1\":{\"163\":1}}],[\"同一进程的不同线程间可以共享进程的资源\",{\"1\":{\"163\":1}}],[\"同一学校的\",{\"1\":{\"52\":1}}],[\"同一品牌的产品产自同一个工厂\",{\"1\":{\"36\":1}}],[\"同具体工厂之间是多对一的关系\",{\"1\":{\"38\":1}}],[\"同种类产品称为同等级产品\",{\"1\":{\"36\":1}}],[\"同时加了\",{\"1\":{\"1376\":1}}],[\"同时绑定相同的店家类型\",{\"1\":{\"1171\":1}}],[\"同时当取消关注时\",{\"1\":{\"1165\":1}}],[\"同时还能保证原子性\",{\"1\":{\"1147\":1}}],[\"同时增加了用于异步响应式处理的\",{\"1\":{\"1499\":1}}],[\"同时增加过期时间\",{\"1\":{\"1142\":1}}],[\"同时增加访问的性能\",{\"1\":{\"1094\":1}}],[\"同时为了确保他线程安全\",{\"1\":{\"1137\":1}}],[\"同时为了进一步降低mysql的压力\",{\"1\":{\"1094\":1}}],[\"同时的去执行数据库代码\",{\"1\":{\"1126\":1}}],[\"同时刷新令牌\",{\"1\":{\"1110\":1}}],[\"同时刷新登录token令牌的存活时间\",{\"1\":{\"1109\":1}}],[\"同时将验证码进行保存\",{\"1\":{\"1098\":1}}],[\"同时将c的值通过reducer流式传输\",{\"1\":{\"326\":1}}],[\"同时使用redis集群使得redis对外提供更好的服务\",{\"1\":{\"1094\":1}}],[\"同时nginx在部署了前端项目后\",{\"1\":{\"1094\":1}}],[\"同时运行生产者\",{\"1\":{\"1019\":1}}],[\"同时把这个id返回给客户端\",{\"1\":{\"1005\":1}}],[\"同时把暂时不运行的页面换出到外存上\",{\"1\":{\"689\":1}}],[\"同时会在服务器上生成大量的用户组\",{\"1\":{\"924\":1}}],[\"同时会初始化它关联的\",{\"1\":{\"740\":1}}],[\"同时其操作被记录下来留待审计\",{\"1\":{\"916\":1}}],[\"同时支持阻塞\",{\"1\":{\"850\":1}}],[\"同时维护了一个\",{\"1\":{\"746\":1}}],[\"同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态\",{\"1\":{\"680\":1}}],[\"同时解决压缩列表的\",{\"1\":{\"667\":1}}],[\"同时对老年代和新生代进行回收\",{\"1\":{\"635\":1}}],[\"同时抛弃阻塞队列中的任务\",{\"1\":{\"571\":1}}],[\"同时处理任务队列中的任务\",{\"1\":{\"571\":1}}],[\"同时只能由一个线程执行i++\",{\"1\":{\"560\":1}}],[\"同时触发成绩表中的student\",{\"1\":{\"482\":1}}],[\"同时在reducer中流式传输b的值\",{\"1\":{\"326\":1}}],[\"同时记录基础数据的历史变化\",{\"1\":{\"225\":1}}],[\"同时共享方式\",{\"1\":{\"155\":1}}],[\"同时简化它们的构建和部署过程\",{\"1\":{\"108\":1}}],[\"同时\",{\"1\":{\"91\":1,\"94\":1,\"493\":1,\"1135\":1,\"1223\":1,\"1501\":1}}],[\"同时确保只有单个对象被创建\",{\"1\":{\"64\":1}}],[\"同时也会把这些信息丢到异步\",{\"1\":{\"1155\":1}}],[\"同时也会与其他已经加入的对象的hashcode值进行比较\",{\"1\":{\"596\":1}}],[\"同时也控制了锁的粒度\",{\"1\":{\"1137\":1}}],[\"同时也能起到流量控制的作用\",{\"1\":{\"694\":1}}],[\"同时也提供了手动解决的冲突的方式\",{\"1\":{\"105\":1}}],[\"同时也对sell方法进行了增强\",{\"1\":{\"58\":1}}],[\"同时也增加了系统具体类的依赖\",{\"1\":{\"23\":1}}],[\"同时又去申请其他资源\",{\"1\":{\"551\":1}}],[\"同时又解决了线程安全问题\",{\"1\":{\"66\":1}}],[\"同时又产生了新的耦合\",{\"1\":{\"28\":1}}],[\"同时又继承现有组件库中已经存在的组件\",{\"1\":{\"6\":1}}],[\"传输速度\",{\"1\":{\"1019\":1}}],[\"传输数据\",{\"0\":{\"820\":1}}],[\"传输问题\",{\"1\":{\"792\":1}}],[\"传输时间ts​=r1​∗nb​=rnb​\",{\"1\":{\"204\":1}}],[\"传输时间ts​\",{\"1\":{\"204\":1}}],[\"传播给每个\",{\"1\":{\"787\":1}}],[\"传入的是布尔变量\",{\"1\":{\"563\":1}}],[\"传入的是整型变量\",{\"1\":{\"563\":1}}],[\"传入为pojo类\",{\"1\":{\"483\":1}}],[\"传统关系型数据库能满足事务acid的原则\",{\"1\":{\"1188\":1}}],[\"传统关系型数据库会基于sql语句做查询\",{\"1\":{\"1187\":1}}],[\"传统关系型数据库是结构化数据\",{\"1\":{\"1185\":1}}],[\"传统数据库的表与表之间往往存在关联\",{\"1\":{\"1186\":1}}],[\"传统了分页在\",{\"1\":{\"1167\":1}}],[\"传统的\",{\"1\":{\"854\":1}}],[\"传统的进程是程序执行流的最小单位\",{\"1\":{\"163\":1}}],[\"传统\",{\"0\":{\"854\":1},\"1\":{\"1245\":2}}],[\"传统异步编程的写法\",{\"1\":{\"716\":1}}],[\"传统存储管理方式的问题\",{\"1\":{\"189\":1}}],[\"传统进程间并发\",{\"1\":{\"163\":1}}],[\"传统进程中\",{\"1\":{\"163\":2}}],[\"传递给下一个\",{\"1\":{\"775\":1}}],[\"传递的依赖已经存在\",{\"1\":{\"104\":1}}],[\"传递的原则\",{\"1\":{\"104\":1}}],[\"传递了四个参数\",{\"1\":{\"17\":1}}],[\"传智播客只培养计算机软件专业的学生等\",{\"1\":{\"36\":1}}],[\"电玩小子\",{\"1\":{\"256\":1}}],[\"电吹风\",{\"1\":{\"147\":1}}],[\"电视\",{\"1\":{\"147\":1}}],[\"电视机厂只生产电视机\",{\"1\":{\"36\":1}}],[\"电动汽车等\",{\"1\":{\"77\":1}}],[\"电脑\",{\"1\":{\"74\":2}}],[\"电脑类\",{\"1\":{\"6\":1}}],[\"前初始化这些都是\",{\"1\":{\"1472\":1}}],[\"前缀的配置项进行定制配置\",{\"1\":{\"1455\":1}}],[\"前缀的\",{\"1\":{\"1446\":1}}],[\"前缀树\",{\"0\":{\"668\":1}}],[\"前置通知会被转换为原始的\",{\"1\":{\"1339\":1}}],[\"前两者采用函数式方法获取列名\",{\"1\":{\"1235\":1}}],[\"前两种能接受\",{\"1\":{\"1003\":1}}],[\"前言\",{\"1\":{\"1113\":1}}],[\"前\",{\"1\":{\"1040\":1,\"1313\":1}}],[\"前后两次检查点的创建时间间隔\",{\"1\":{\"910\":1}}],[\"前先做个标记\",{\"1\":{\"774\":1}}],[\"前一个节点的长度\",{\"1\":{\"665\":1}}],[\"前一个节点\",{\"1\":{\"665\":1}}],[\"前端传来不定条件mybatis\",{\"0\":{\"1234\":1}}],[\"前端传过来的参数都是json格式的\",{\"1\":{\"1229\":1}}],[\"前端已实现\",{\"1\":{\"1161\":1}}],[\"前端可以通过返回的订单\",{\"1\":{\"1155\":1}}],[\"前端\",{\"1\":{\"651\":1}}],[\"前面的代码只有一个选择器\",{\"1\":{\"846\":1}}],[\"前面提到\",{\"1\":{\"666\":1}}],[\"前面提到的原子性\",{\"1\":{\"506\":1}}],[\"前面介绍的工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"36\":1}}],[\"前者配置了\",{\"1\":{\"1456\":1}}],[\"前者现在时表示主动创建\",{\"1\":{\"480\":1}}],[\"前者类之间的耦合度比后者高\",{\"1\":{\"4\":1}}],[\"前提是这个field不存在\",{\"1\":{\"1208\":1}}],[\"前提是这个key不存在\",{\"1\":{\"1206\":1}}],[\"前提是其记录对于右边的表满足on语句中的判定条件\",{\"1\":{\"324\":1}}],[\"前提是对join的字段进行分桶\",{\"1\":{\"263\":1}}],[\"前驱关系\",{\"0\":{\"172\":1}}],[\"前台进程优先级高于后台进程\",{\"1\":{\"167\":1}}],[\"前三个是基本状态\",{\"1\":{\"160\":1}}],[\"每与一次\",{\"1\":{\"1176\":1}}],[\"每得到一个非\",{\"1\":{\"1176\":1}}],[\"每签到一次需要使用\",{\"1\":{\"1174\":1}}],[\"每天使用一个key\",{\"1\":{\"1132\":1}}],[\"每台服务器中都有完整的一份session数据\",{\"1\":{\"1102\":1}}],[\"每台机器所有的出口宽带都用于以最快的速度传输数据\",{\"1\":{\"898\":1}}],[\"每隔多少秒提交一次offset\",{\"1\":{\"1051\":1}}],[\"每隔一段时间就检查这段时间内是否接收到客户端数据\",{\"1\":{\"707\":1}}],[\"每隔一段时间抽取一批key执行删除过期key操作\",{\"1\":{\"520\":1}}],[\"每秒可生成百万个不重复\",{\"1\":{\"1000\":1}}],[\"每读取解析出来的一个<key\",{\"1\":{\"965\":1}}],[\"每位工人有任务队列\",{\"1\":{\"787\":1}}],[\"每发送一个段就需要进行一次确认应答\",{\"1\":{\"694\":1}}],[\"每段可定义一组相对完整的信息\",{\"1\":{\"683\":1}}],[\"每段从0开始编程\",{\"1\":{\"187\":1}}],[\"每份数据分片会存储在多个互为主从的多节点上\",{\"1\":{\"527\":1}}],[\"每行数据的隐藏列中包含了指向undo\",{\"1\":{\"503\":1}}],[\"每种存储引擎的索引都不一定完全相同\",{\"1\":{\"485\":1}}],[\"每一次http请求\",{\"1\":{\"1504\":1}}],[\"每一张表都有严格的约束信息\",{\"1\":{\"1185\":1}}],[\"每一份就称之为分片\",{\"1\":{\"1066\":1}}],[\"每一行调用一次map方法进行业务处理\",{\"1\":{\"959\":1}}],[\"每一行返回一个kv键值对\",{\"1\":{\"959\":1}}],[\"每一行数据就是一个json数据\",{\"1\":{\"395\":1}}],[\"每一条消息分为\",{\"1\":{\"695\":1}}],[\"每一条消息采用分隔符\",{\"1\":{\"695\":1}}],[\"每一条消息采用固定长度\",{\"1\":{\"695\":1}}],[\"每一个kafka的节点都需要修改broker\",{\"1\":{\"1012\":1}}],[\"每一个切片由一个maptask处理\",{\"1\":{\"965\":1}}],[\"每一个索引还要占一定的物理空间\",{\"1\":{\"485\":1}}],[\"每一个表也必然有一个与之对应\",{\"1\":{\"483\":1}}],[\"每一个合并的文件的大小\",{\"1\":{\"435\":1}}],[\"每一个\",{\"1\":{\"107\":1}}],[\"每组内再根据该字段进行正序排序\",{\"1\":{\"313\":1}}],[\"每启动一次hive服务\",{\"1\":{\"243\":1}}],[\"每跨越一个磁道耗时为m\",{\"1\":{\"204\":1}}],[\"每五位就与01001进行异或操作\",{\"1\":{\"201\":1}}],[\"每条记录又由若干个数据项组成\",{\"1\":{\"195\":1}}],[\"每当要访问的页面不在内存时\",{\"1\":{\"190\":1}}],[\"每当有进程加入的时候\",{\"1\":{\"167\":1}}],[\"每次请求都会创建一个新的bean实例\",{\"1\":{\"1504\":1}}],[\"每次请求用到此\",{\"1\":{\"1290\":1}}],[\"每次使用时创建\",{\"1\":{\"1290\":1,\"1504\":1}}],[\"每次签到就到对应的位上把数字从\",{\"1\":{\"1175\":1}}],[\"每次查询完成后\",{\"1\":{\"1168\":1}}],[\"每次查找从上次使用地址的下一个开始\",{\"1\":{\"183\":1}}],[\"每次操作数据会对版本号+1\",{\"1\":{\"1135\":1}}],[\"每次更新数据库都更新缓存\",{\"1\":{\"1121\":1}}],[\"每次都随机地将消息分配到每个分区\",{\"1\":{\"1033\":1}}],[\"每次都选最大的分区\",{\"1\":{\"183\":1}}],[\"每次都选最小的分区\",{\"1\":{\"183\":1}}],[\"每次重启都会重新分配\",{\"1\":{\"1029\":1}}],[\"每次生成\",{\"1\":{\"1000\":1}}],[\"每次溢写会在磁盘上生成一个临时文件\",{\"1\":{\"979\":1}}],[\"每次一个字节\",{\"1\":{\"774\":1}}],[\"每次\",{\"1\":{\"634\":1}}],[\"每次add操作都会对比add后的长度值与数组原有的长度值\",{\"1\":{\"601\":1}}],[\"每次只允许一个线程独占\",{\"1\":{\"582\":1}}],[\"每次只需要对其中一天的数据进行处理\",{\"1\":{\"414\":1}}],[\"每次hive中原始数据表的数据发生更新时\",{\"1\":{\"424\":1}}],[\"每次结果都一样\",{\"1\":{\"368\":1}}],[\"每次执行都不一样\",{\"1\":{\"338\":1}}],[\"每次执行一次事务操作都会有这样的一个delta增量文件夹\",{\"1\":{\"292\":1}}],[\"每次中断只能传输一个字\",{\"1\":{\"209\":1}}],[\"每次i\",{\"1\":{\"209\":1}}],[\"每次读写缓冲区数据都会改变该值\",{\"1\":{\"610\":1}}],[\"每次读操作都会生成一个readview所以会出现不可重复读的情况\",{\"1\":{\"503\":1}}],[\"每次读\",{\"1\":{\"209\":3}}],[\"每次淘汰的页面是最近最久未使用的页面\",{\"1\":{\"191\":1}}],[\"每次选择淘汰的页面是最早进入内存的页面\",{\"1\":{\"191\":1}}],[\"每次选择淘汰的页面将是以后永不使用\",{\"1\":{\"191\":1}}],[\"每次分配内存时从上次查找结束的位置开始查找空闲分区\",{\"1\":{\"183\":1}}],[\"每次分配内存时顺序查找空闲分区链或空闲分区表\",{\"1\":{\"183\":3}}],[\"每次从低地址开始查找\",{\"1\":{\"183\":1}}],[\"每次仅允许一个进程在管程内执行某个内部过程\",{\"1\":{\"173\":1}}],[\"每次调度时选中最短的作业\",{\"1\":{\"167\":1}}],[\"每次增加一个产品时\",{\"1\":{\"23\":1}}],[\"每个环绕通知内部继续调用\",{\"1\":{\"1346\":1}}],[\"每个会话用到此\",{\"1\":{\"1290\":1}}],[\"每个后处理器各自增强什么功能\",{\"1\":{\"1264\":1}}],[\"每个命令具备原子性\",{\"1\":{\"1190\":1}}],[\"每个店铺都可以发布优惠券\",{\"1\":{\"1131\":1,\"1133\":1}}],[\"每个tomcat都有一个属于自己的jvm\",{\"1\":{\"1138\":1}}],[\"每个tomcat中都有一份属于自己的session\",{\"1\":{\"1102\":1}}],[\"每个thread对象\",{\"1\":{\"577\":1}}],[\"每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的\",{\"1\":{\"1100\":1}}],[\"每个用户进程对应m个内核级线程\",{\"1\":{\"163\":1}}],[\"每个索引就有了主分片\",{\"1\":{\"1067\":1}}],[\"每个索引可以被分成多个分片\",{\"1\":{\"1067\":1}}],[\"每个producer在初始化时\",{\"1\":{\"1029\":1}}],[\"每个任务的运行都是独立的\",{\"1\":{\"991\":1}}],[\"每个逻辑切片最终对应启动一个maptask\",{\"1\":{\"976\":1}}],[\"每个州按cases倒序分成一组\",{\"1\":{\"974\":1}}],[\"每个州state的确诊案例数最多的县是哪一个\",{\"1\":{\"974\":1}}],[\"每个州state累计确诊案例数\",{\"1\":{\"972\":1}}],[\"每个文件和目录都与一个拥有者和一个组相关联\",{\"1\":{\"917\":1}}],[\"每个文件占一个目录项\",{\"1\":{\"196\":1}}],[\"每个datanode要向集群中所有的namenode注册\",{\"1\":{\"889\":1}}],[\"每个机架所容纳的块数不超过ec奇偶校验块的数\",{\"1\":{\"875\":1}}],[\"每个块组包含一定数量的内部块\",{\"1\":{\"875\":1}}],[\"每个块只包含一个进程\",{\"1\":{\"683\":1}}],[\"每个病人花费\",{\"1\":{\"755\":1}}],[\"每个\",{\"1\":{\"746\":1,\"766\":1,\"775\":2,\"779\":1,\"841\":1,\"843\":1,\"1026\":1}}],[\"每个消息是\",{\"1\":{\"692\":1}}],[\"每个红色节点的两个子节点都是黑色\",{\"1\":{\"656\":1}}],[\"每个叶子节点都是黑色的空节点\",{\"1\":{\"656\":1}}],[\"每个channel对应一个buffer\",{\"1\":{\"610\":1}}],[\"每个请求都需要创建独立的线程\",{\"1\":{\"609\":1}}],[\"每个线程操作自己的一份数据\",{\"1\":{\"1100\":1}}],[\"每个线程配一个选择器\",{\"1\":{\"846\":1}}],[\"每个线程先分配一块tlab\",{\"1\":{\"630\":1}}],[\"每个线程执行到某个需要\",{\"1\":{\"593\":1}}],[\"每个线程需要用共享变量时必须先把共享变量从主存load到自己的工作内存\",{\"1\":{\"560\":1}}],[\"每个线程都有自己的工作内存\",{\"1\":{\"560\":1}}],[\"每个线程都有一个线程id\",{\"1\":{\"163\":1}}],[\"每个线程都会和一个park对象关联起来\",{\"1\":{\"549\":1}}],[\"每个java对象都可以关联一个monitor对象\",{\"1\":{\"541\":1}}],[\"每个节点的地位都是一样的\",{\"1\":{\"1153\":1}}],[\"每个节点的标识\",{\"1\":{\"1012\":1}}],[\"每个节点加载环境变量\",{\"1\":{\"1012\":1}}],[\"每个节点负责其中一部分槽位\",{\"1\":{\"528\":1}}],[\"每个节点均衡存储一定哈希槽\",{\"1\":{\"527\":1}}],[\"每个redis节点都要开放两个端口号\",{\"1\":{\"527\":1}}],[\"每个reducer做部分聚合操作\",{\"1\":{\"466\":1}}],[\"每个小文件的大小为2m左右\",{\"1\":{\"477\":1}}],[\"每个词的大小不超过16byte\",{\"1\":{\"476\":1}}],[\"每个stripe中包含了每个column的min\",{\"1\":{\"437\":1}}],[\"每个分片本身也是一个功能完善并且独立的\",{\"1\":{\"1066\":1}}],[\"每个分组你可以把它叫做窗口\",{\"1\":{\"358\":1}}],[\"每个分区多个副本中的\",{\"1\":{\"1026\":1}}],[\"每个分区多个副本的\",{\"1\":{\"1026\":1}}],[\"每个分区就是一个页框\",{\"1\":{\"184\":1}}],[\"每个分区的起始部分和末尾部分分别设置前向指针和后向指针\",{\"1\":{\"182\":1}}],[\"每个组内局部排序\",{\"1\":{\"314\":1}}],[\"每个事务的delta文件夹下\",{\"1\":{\"293\":1}}],[\"每个数据库下面有各自的表组成\",{\"1\":{\"234\":1}}],[\"每个企业根据自己的业务需求可以分成不同的层次\",{\"1\":{\"224\":1}}],[\"每个设备也会有对应的fcb\",{\"1\":{\"211\":1}}],[\"每个字在i\",{\"1\":{\"209\":1}}],[\"每个字的读\",{\"1\":{\"209\":1}}],[\"每个字的大小为16个二进制位\",{\"1\":{\"179\":1}}],[\"每个控制\",{\"1\":{\"208\":1}}],[\"每个磁道可存n字节的数据\",{\"1\":{\"204\":1}}],[\"每个磁盘上的字节数为n\",{\"1\":{\"204\":1}}],[\"每个盘块中都存有指向下一个盘块的指针\",{\"1\":{\"197\":1}}],[\"每个记录对应一个索引表项\",{\"1\":{\"195\":1}}],[\"每个段定义了一组逻辑信息\",{\"1\":{\"683\":1}}],[\"每个段表项的长度相等\",{\"1\":{\"188\":1}}],[\"每个段表项由段号\",{\"1\":{\"188\":1}}],[\"每个段对应一个段表项\",{\"1\":{\"187\":1,\"188\":1}}],[\"每个段在内存中占据连续空间\",{\"1\":{\"187\":1}}],[\"每个段都有一个段名\",{\"1\":{\"187\":1}}],[\"每个页和段中的内存是连续的\",{\"1\":{\"683\":1}}],[\"每个页表项长度相等\",{\"1\":{\"188\":1}}],[\"每个页表项由页号\",{\"1\":{\"188\":1}}],[\"每个页面对应一个页表项\",{\"1\":{\"188\":1}}],[\"每个页面也有一个编号\",{\"1\":{\"184\":1}}],[\"每个页框有一个编号\",{\"1\":{\"184\":1}}],[\"每个空闲分区都用相同的概率被使用\",{\"1\":{\"183\":1}}],[\"每个空闲分区对应一个表项\",{\"1\":{\"182\":1}}],[\"每个表项对应一个分区\",{\"1\":{\"182\":1}}],[\"每个单元对应一个存储单元\",{\"1\":{\"179\":1}}],[\"每个进程在进入临界区之前先检查当前有没有别的进程进入临界区\",{\"1\":{\"169\":1}}],[\"每个进程访问临界资源的权限只能被另一个进程赋予\",{\"1\":{\"169\":1}}],[\"每个进程配置一个pcb\",{\"1\":{\"159\":1}}],[\"每个作业\",{\"1\":{\"167\":1}}],[\"每个作业只调入一次\",{\"1\":{\"164\":1}}],[\"每个特征的grid\",{\"1\":{\"138\":1}}],[\"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类\",{\"1\":{\"35\":1}}],[\"要是问bean的线程安全问题需要考虑单例bean还是多例bean\",{\"1\":{\"1506\":1}}],[\"要是按照工厂方法模式\",{\"1\":{\"39\":1}}],[\"要实现\",{\"1\":{\"1425\":1}}],[\"要区分本章节提到的\",{\"1\":{\"1325\":1}}],[\"要注入的对象\",{\"1\":{\"1294\":1}}],[\"要维护关系要么靠代码中的业务逻辑\",{\"1\":{\"1186\":1}}],[\"要生产消息到kafka\",{\"1\":{\"1015\":1}}],[\"要支持百万连接就要\",{\"1\":{\"841\":1}}],[\"要从\",{\"1\":{\"836\":1,\"840\":1,\"854\":1,\"855\":2}}],[\"要点\",{\"1\":{\"755\":1}}],[\"要解绑会话\",{\"1\":{\"701\":1}}],[\"要解决双重检查锁模式带来空指针异常的问题\",{\"1\":{\"66\":1}}],[\"要绑定会话\",{\"1\":{\"701\":1}}],[\"要了解这一点\",{\"1\":{\"661\":1}}],[\"要创建链表头节点\",{\"1\":{\"579\":1}}],[\"要创建table\",{\"1\":{\"579\":1}}],[\"要创建的复杂对象\",{\"1\":{\"13\":1}}],[\"要保证该局部变量是\",{\"1\":{\"562\":1}}],[\"要遵循\",{\"1\":{\"505\":1}}],[\"要尽量采用二级索引\",{\"1\":{\"497\":1}}],[\"要尽量避免小文件的生成\",{\"1\":{\"435\":1}}],[\"要先select\",{\"1\":{\"482\":1}}],[\"要么靠数据之间的耦合\",{\"1\":{\"1186\":1}}],[\"要么你\",{\"1\":{\"1128\":1}}],[\"要么取消\",{\"1\":{\"835\":1,\"840\":1}}],[\"要么处理\",{\"1\":{\"835\":1}}],[\"要么全部失败\",{\"1\":{\"556\":1}}],[\"要么全部完成\",{\"1\":{\"556\":1}}],[\"要么对超过特定阈值的页数进行sql改写\",{\"1\":{\"481\":1}}],[\"要么控制返回的总页数\",{\"1\":{\"481\":1}}],[\"要么是重复下单\",{\"1\":{\"1157\":1}}],[\"要么是输出\",{\"1\":{\"861\":1}}],[\"要么是输入\",{\"1\":{\"861\":1}}],[\"要么是输入流要么是输出流\",{\"1\":{\"610\":1}}],[\"要么是被聚合函数引用的字段\",{\"1\":{\"306\":1}}],[\"要么是group\",{\"1\":{\"306\":1}}],[\"要使用矢量化查询执行\",{\"1\":{\"438\":1}}],[\"要花费一定时间\",{\"1\":{\"201\":1}}],[\"要找到第i个记录\",{\"1\":{\"195\":1}}],[\"要等p1释放资源\",{\"1\":{\"178\":1}}],[\"要为每一对前驱关系各设置一个同步变量\",{\"1\":{\"172\":1}}],[\"要求实现\",{\"1\":{\"1421\":1}}],[\"要求同一个优惠券\",{\"1\":{\"1137\":1}}],[\"要求我们输出的key必须是dbwritable的实现\",{\"1\":{\"986\":1}}],[\"要求它启动任务\",{\"1\":{\"953\":1}}],[\"要求它在这个\",{\"1\":{\"953\":1}}],[\"要求nm启动或者停止\",{\"1\":{\"949\":1}}],[\"要求必须将作业装入一个连续的内存区域中\",{\"1\":{\"689\":1}}],[\"要求在resultmap中进行字段与属性之间的映射\",{\"1\":{\"483\":1}}],[\"要求是ref级别\",{\"1\":{\"481\":1}}],[\"要求返回出现频率最高的100个词\",{\"1\":{\"476\":1}}],[\"要求\",{\"1\":{\"450\":2}}],[\"要求严格\",{\"1\":{\"420\":1}}],[\"要求服务时间相同时\",{\"1\":{\"167\":1}}],[\"要求服务时间短的优先\",{\"1\":{\"167\":1}}],[\"要求服务时间\",{\"1\":{\"167\":2}}],[\"要求子类必须实现\",{\"1\":{\"88\":1}}],[\"要求子类必须重写\",{\"1\":{\"88\":1}}],[\"要视频\",{\"1\":{\"163\":1}}],[\"要做的无非三类事情\",{\"1\":{\"161\":1}}],[\"要增加产品类时也要相应地增加工厂类\",{\"1\":{\"34\":1}}],[\"咖啡店类\",{\"1\":{\"34\":1}}],[\"咖啡店具有点咖啡的功能\",{\"1\":{\"25\":1}}],[\"咖啡具体类\",{\"1\":{\"34\":1}}],[\"咖啡抽象类\",{\"1\":{\"34\":1}}],[\"概念\",{\"0\":{\"32\":1,\"37\":1,\"716\":1},\"1\":{\"104\":1}}],[\"概述\",{\"0\":{\"4\":1,\"12\":1,\"25\":1,\"45\":1,\"49\":1,\"56\":1,\"79\":1,\"83\":1,\"432\":1}}],[\"完善为\",{\"1\":{\"1438\":1}}],[\"完善点赞功能\",{\"1\":{\"1161\":1}}],[\"完整\",{\"1\":{\"1156\":1}}],[\"完整的自举程序放在磁盘的启动块\",{\"1\":{\"206\":1}}],[\"完全懵逼的状态\",{\"1\":{\"1003\":1}}],[\"完全抛弃了\",{\"1\":{\"791\":1}}],[\"完全背包和01背包相比就是每件物品数量无限\",{\"1\":{\"649\":1}}],[\"完全背包\",{\"0\":{\"649\":1},\"1\":{\"649\":1}}],[\"完全遵循开闭原则\",{\"1\":{\"31\":1}}],[\"完成用户注册与发送短信之间的解耦\",{\"1\":{\"1243\":1}}],[\"完成抢单业务\",{\"1\":{\"1157\":1}}],[\"完成库存余量\",{\"1\":{\"1157\":1}}],[\"完成秒杀资格判断\",{\"0\":{\"1156\":1}}],[\"完成不停的续约\",{\"1\":{\"1152\":1}}],[\"完成整体刷新功能\",{\"1\":{\"1110\":1}}],[\"完成请求和响应\",{\"1\":{\"1100\":1}}],[\"完成拼接\",{\"1\":{\"990\":1}}],[\"完成文件\",{\"1\":{\"854\":1}}],[\"完成对多个\",{\"1\":{\"828\":1}}],[\"完成收发\",{\"1\":{\"713\":1}}],[\"完成扩容操作\",{\"1\":{\"601\":1}}],[\"完成多次insert操作\",{\"1\":{\"288\":1}}],[\"完成\",{\"1\":{\"232\":1,\"1038\":1}}],[\"完成之后需要cpu介入\",{\"1\":{\"209\":2}}],[\"完成一次读\",{\"1\":{\"209\":3}}],[\"完成初始化\",{\"1\":{\"206\":1}}],[\"完成的\",{\"1\":{\"206\":1}}],[\"完成各程序并发执行\",{\"1\":{\"159\":1}}],[\"完成具体产品的创建\",{\"1\":{\"33\":1,\"38\":1}}],[\"完成复杂产品的各个部件的具体创建方法\",{\"1\":{\"13\":1}}],[\"违背了忙则等待的原则\",{\"1\":{\"169\":1}}],[\"违背了\",{\"1\":{\"29\":1}}],[\"违反了开闭原则\",{\"1\":{\"28\":1}}],[\"把跨应用的多个模块功能抽象出来\",{\"1\":{\"1510\":1}}],[\"把它当做视图名\",{\"1\":{\"1394\":1}}],[\"把它们都列出来\",{\"1\":{\"1245\":1}}],[\"把类型\",{\"1\":{\"1368\":1}}],[\"把其它类型转为\",{\"1\":{\"1368\":1}}],[\"把每一个\",{\"1\":{\"1174\":1}}],[\"把每个分组内的数据分为3桶\",{\"1\":{\"364\":1}}],[\"把店铺分组\",{\"1\":{\"1171\":1}}],[\"把这几个条件传入后台\",{\"1\":{\"1171\":1}}],[\"把这条完整消息存入新的\",{\"1\":{\"840\":1}}],[\"把他关注人的信息全部都进行拉取\",{\"1\":{\"1166\":1}}],[\"把他发送到各台机器上\",{\"1\":{\"448\":1}}],[\"把用户从redis的set集合移除\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"把用于链接文件各个物理块的指针显示的存放在一张表中\",{\"1\":{\"197\":1}}],[\"把当前这把锁续约成30s\",{\"1\":{\"1152\":1}}],[\"把第二个拦截器做的事情放入到第一个拦截器中\",{\"1\":{\"1110\":1}}],[\"把第一个文件中出现频率最高的100个词构造成小顶堆\",{\"1\":{\"477\":1}}],[\"把读取的分布式缓存内容添加到集合中\",{\"1\":{\"990\":1}}],[\"把属于同一笔订单的不同商品聚集在一起\",{\"1\":{\"988\":1}}],[\"把reducetask的个数设置为0\",{\"1\":{\"985\":1,\"986\":1}}],[\"把分散的数据合并成一个大的数据后\",{\"1\":{\"980\":1}}],[\"把规划文件提交到任务准备区\",{\"1\":{\"976\":1}}],[\"把复制到reducer本地数据\",{\"1\":{\"966\":1}}],[\"把输入目录下文件按照一定的标准逐个进行逻辑切片\",{\"1\":{\"965\":1}}],[\"把所有文件当成整体来处理\",{\"1\":{\"962\":1}}],[\"把多出来的内容写入新的数组\",{\"1\":{\"841\":1}}],[\"把\",{\"1\":{\"787\":4,\"843\":1,\"1368\":1,\"1369\":1,\"1443\":1}}],[\"把要调用的代码封装为一个任务对象\",{\"1\":{\"749\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"630\":1}}],[\"把对象的创建和业务逻辑层分开\",{\"1\":{\"29\":1}}],[\"把count加上volatile也不能解决这个问题\",{\"1\":{\"560\":1}}],[\"把slave提升为新的master\",{\"1\":{\"530\":1}}],[\"把数据改回去\",{\"1\":{\"506\":1}}],[\"把数据文件上传到对应的分区文件夹\",{\"1\":{\"281\":1}}],[\"把一个大文件分解成多个小文件\",{\"1\":{\"477\":1}}],[\"把month和day调换顺序\",{\"1\":{\"355\":1}}],[\"把满足规则的进行\",{\"1\":{\"344\":1}}],[\"把内存分为一个个相等的小分区\",{\"1\":{\"184\":1}}],[\"把已占的内存挪位\",{\"1\":{\"182\":1}}],[\"把外存中某些已具备运行条件的进程换入内存\",{\"1\":{\"181\":1}}],[\"把只能互斥使用的资源改造为允许共享使用\",{\"1\":{\"176\":1}}],[\"把版本号去掉就表示子工程中这个依赖的版本由父工程决定\",{\"1\":{\"107\":1}}],[\"把更基础的方法和成员写到base类\",{\"1\":{\"73\":1}}],[\"把适配者接口转换成目标接口\",{\"1\":{\"5\":1}}],[\"rfuture<boolean>\",{\"1\":{\"1152\":1}}],[\"rfuture<long>\",{\"1\":{\"1152\":1}}],[\"rlock\",{\"1\":{\"1150\":2,\"1157\":1}}],[\"rlike\",{\"1\":{\"330\":4}}],[\"rjout\",{\"1\":{\"991\":2}}],[\"rs\",{\"1\":{\"985\":7}}],[\"rs表示编码器算法reed\",{\"1\":{\"875\":1}}],[\"rsa<\",{\"1\":{\"344\":1}}],[\"rwx\",{\"1\":{\"926\":2}}],[\"rw\",{\"1\":{\"796\":1,\"807\":1,\"808\":1,\"919\":1}}],[\"r>\",{\"1\":{\"716\":1,\"1129\":3}}],[\"rcvbuf\",{\"0\":{\"729\":1,\"731\":1},\"1\":{\"693\":2,\"729\":1}}],[\"rt\",{\"1\":{\"624\":1}}],[\"rtrim\",{\"1\":{\"336\":3}}],[\"rpc是远程过程调用\",{\"1\":{\"949\":1}}],[\"rpcclientmanager\",{\"1\":{\"737\":1}}],[\"rpcclient\",{\"1\":{\"733\":1,\"735\":1}}],[\"rpcserver\",{\"1\":{\"733\":1}}],[\"rpcresponsemessagehandler\",{\"1\":{\"733\":2,\"735\":2,\"736\":1,\"737\":3,\"738\":1}}],[\"rpcresponsemessage\",{\"1\":{\"733\":2,\"734\":2,\"736\":1,\"738\":1}}],[\"rpcrequestmessagehandler\",{\"1\":{\"733\":2,\"734\":1}}],[\"rpcrequestmessage\",{\"1\":{\"733\":3,\"734\":1,\"735\":1,\"737\":2}}],[\"rpc\",{\"0\":{\"732\":1},\"1\":{\"733\":13,\"735\":2,\"737\":2,\"791\":2,\"949\":5,\"953\":3}}],[\"rpop\",{\"1\":{\"515\":1,\"1209\":2}}],[\"rpush\",{\"1\":{\"515\":1,\"1209\":2}}],[\"rpad\",{\"1\":{\"336\":3}}],[\"rdcconfig\",{\"1\":{\"480\":1}}],[\"rdc\",{\"1\":{\"480\":1}}],[\"rdbms\",{\"1\":{\"221\":1}}],[\"rule\",{\"1\":{\"456\":1}}],[\"run方法运行过程中还涉及启动时长统计\",{\"1\":{\"1522\":1}}],[\"runoob\",{\"1\":{\"1146\":1}}],[\"runalltasks\",{\"1\":{\"741\":4}}],[\"runner\",{\"1\":{\"1444\":1}}],[\"runnable\",{\"1\":{\"538\":1,\"554\":6,\"555\":6,\"725\":1,\"740\":4,\"741\":2,\"743\":1,\"749\":1,\"846\":3,\"1132\":1,\"1157\":1}}],[\"running\",{\"1\":{\"160\":1,\"571\":1,\"751\":5}}],[\"run是一个线程的具体执行内容\",{\"1\":{\"532\":1}}],[\"run\",{\"1\":{\"74\":5,\"536\":1,\"554\":6,\"555\":6,\"725\":1,\"740\":4,\"741\":6,\"743\":1,\"746\":1,\"749\":1,\"762\":5,\"765\":13,\"846\":3,\"962\":2,\"988\":2,\"1152\":1,\"1157\":1,\"1442\":1,\"1444\":1}}],[\"runtimedemo\",{\"1\":{\"70\":1}}],[\"runtime\",{\"1\":{\"70\":13,\"100\":1,\"846\":1,\"847\":1,\"1525\":1}}],[\"runtime类就是使用的单例设计模式\",{\"1\":{\"70\":1}}],[\"runtime类\",{\"0\":{\"70\":1}}],[\"runtimeexception\",{\"1\":{\"28\":1,\"47\":2,\"59\":4,\"69\":1,\"717\":1,\"718\":1,\"723\":2,\"737\":1,\"762\":5,\"763\":4,\"764\":4,\"999\":1,\"1071\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1159\":1,\"1309\":2}}],[\"rbo\",{\"0\":{\"456\":1}}],[\"rn\",{\"1\":{\"364\":2,\"365\":4,\"404\":2}}],[\"rn3\",{\"1\":{\"363\":1}}],[\"rn2\",{\"1\":{\"363\":1,\"364\":1}}],[\"rn1\",{\"1\":{\"363\":1}}],[\"right\",{\"0\":{\"322\":1},\"1\":{\"322\":4,\"326\":1,\"579\":1,\"669\":6,\"673\":2}}],[\"rm\",{\"1\":{\"281\":1,\"910\":1,\"944\":1,\"946\":1,\"947\":1,\"948\":2,\"949\":5}}],[\"r\",{\"1\":{\"204\":2,\"281\":1,\"614\":2,\"645\":5,\"692\":6,\"693\":7,\"697\":19,\"698\":18,\"699\":19,\"748\":18,\"753\":2,\"808\":1,\"854\":1,\"878\":1,\"910\":2,\"918\":1,\"919\":2,\"920\":6,\"1035\":3,\"1129\":21,\"1157\":3,\"1168\":5}}],[\"route\",{\"1\":{\"1424\":1}}],[\"routerfunction<serverresponse>\",{\"1\":{\"1424\":1}}],[\"routerfunctionmapping\",{\"0\":{\"1422\":1},\"1\":{\"1424\":3,\"1425\":1,\"1437\":1}}],[\"roundrobin\",{\"1\":{\"1042\":1}}],[\"roundrobinassignor\",{\"1\":{\"1041\":2}}],[\"roundrobin轮询策略\",{\"0\":{\"1041\":1}}],[\"round\",{\"1\":{\"167\":1,\"338\":6}}],[\"ro\",{\"1\":{\"1174\":1}}],[\"rose\",{\"1\":{\"1146\":2,\"1206\":2}}],[\"rocketmq\",{\"1\":{\"791\":1,\"1008\":1}}],[\"rollbackfor\",{\"0\":{\"1516\":1}}],[\"rollup是cube的子集\",{\"1\":{\"352\":1}}],[\"rollup\",{\"0\":{\"355\":1},\"1\":{\"352\":1,\"355\":2}}],[\"rolemapper\",{\"1\":{\"1230\":2}}],[\"rolename\",{\"1\":{\"1230\":1}}],[\"roleid\",{\"1\":{\"1230\":1}}],[\"role表\",{\"1\":{\"1230\":1}}],[\"role=tanke\",{\"1\":{\"281\":2}}],[\"role=sheshou\",{\"1\":{\"281\":3}}],[\"role=\",{\"1\":{\"260\":1}}],[\"role\",{\"1\":{\"260\":3,\"261\":13,\"278\":1,\"281\":3,\"1230\":19}}],[\"rootlogger=info\",{\"1\":{\"1022\":1}}],[\"rooty\",{\"1\":{\"671\":3}}],[\"rootx\",{\"1\":{\"671\":3}}],[\"roots有哪些\",{\"1\":{\"633\":1}}],[\"root\",{\"1\":{\"261\":6,\"262\":3,\"280\":1,\"285\":1,\"287\":1,\"290\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"668\":21,\"669\":14,\"671\":7,\"878\":2,\"879\":2,\"910\":2,\"927\":5,\"985\":1,\"986\":1,\"1236\":1}}],[\"rowendindex\",{\"1\":{\"799\":6}}],[\"row++\",{\"1\":{\"799\":1}}],[\"rowprefixes\",{\"1\":{\"799\":5}}],[\"row2col2\",{\"1\":{\"385\":2}}],[\"row2col1\",{\"1\":{\"382\":2}}],[\"rowstartindex\",{\"1\":{\"799\":12}}],[\"rows\",{\"1\":{\"300\":1,\"361\":2,\"368\":1,\"768\":2,\"799\":1}}],[\"rowid\",{\"1\":{\"293\":1}}],[\"row\",{\"0\":{\"363\":1},\"1\":{\"250\":2,\"251\":1,\"252\":1,\"256\":1,\"260\":1,\"261\":1,\"262\":1,\"266\":1,\"281\":1,\"285\":1,\"287\":1,\"290\":4,\"293\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"358\":1,\"359\":2,\"361\":4,\"363\":3,\"365\":4,\"374\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"397\":1,\"400\":1,\"402\":1,\"403\":2,\"404\":2,\"407\":1,\"408\":1,\"409\":1,\"437\":3,\"799\":10,\"1164\":1,\"1174\":1}}],[\"robin\",{\"1\":{\"167\":1}}],[\"rr通过mvcc快照读的思想就已经解决了幻读的问题\",{\"1\":{\"503\":1}}],[\"rr解决了脏读\",{\"1\":{\"503\":1}}],[\"rr\",{\"1\":{\"167\":1}}],[\"radomcondition\",{\"1\":{\"1234\":1}}],[\"rabbitmq\",{\"1\":{\"1008\":1}}],[\"ram\",{\"1\":{\"903\":1}}],[\"rapid\",{\"1\":{\"789\":1}}],[\"rank\",{\"1\":{\"363\":4,\"403\":4}}],[\"rand\",{\"1\":{\"338\":5,\"367\":3,\"369\":2,\"465\":1}}],[\"randomuuid\",{\"1\":{\"1107\":1,\"1144\":1}}],[\"randomutil\",{\"1\":{\"1099\":1}}],[\"randomnumbers\",{\"1\":{\"1099\":1}}],[\"randomnumbergenerator\",{\"1\":{\"47\":3}}],[\"randomaccessfile\",{\"1\":{\"796\":2,\"807\":2,\"808\":2,\"813\":3,\"816\":1,\"854\":2}}],[\"randomkey随机拿出一个key后\",{\"1\":{\"529\":1}}],[\"random或者allkeys\",{\"1\":{\"521\":1}}],[\"random\",{\"1\":{\"47\":4,\"81\":10,\"522\":2,\"692\":2,\"697\":2,\"698\":2,\"699\":2,\"1035\":2}}],[\"rangequery\",{\"1\":{\"1081\":5}}],[\"rangequerybuilder\",{\"1\":{\"1081\":1}}],[\"rangeassignor\",{\"1\":{\"1040\":1}}],[\"range\",{\"0\":{\"1040\":1},\"1\":{\"260\":1,\"261\":1,\"281\":1,\"480\":1,\"481\":2,\"1040\":2,\"1042\":1,\"1162\":1}}],[\"rate\",{\"1\":{\"256\":2}}],[\"ratio\",{\"1\":{\"167\":1}}],[\"r2\",{\"1\":{\"51\":2,\"175\":1}}],[\"r1​\",{\"1\":{\"204\":1}}],[\"r1\",{\"1\":{\"51\":3,\"602\":1,\"1424\":3}}],[\"reload\",{\"1\":{\"1197\":1}}],[\"releases\",{\"1\":{\"1200\":1}}],[\"releaseshared\",{\"1\":{\"585\":1}}],[\"release<\",{\"1\":{\"1172\":1}}],[\"release\",{\"0\":{\"775\":1},\"1\":{\"585\":1,\"713\":1,\"744\":1,\"775\":16,\"776\":3}}],[\"requires\",{\"1\":{\"1514\":1}}],[\"requirepass\",{\"1\":{\"1196\":1}}],[\"required\",{\"1\":{\"1172\":2,\"1514\":3,\"1525\":1,\"1531\":1}}],[\"requestpredicate\",{\"1\":{\"1425\":1,\"1437\":1}}],[\"requestparam和\",{\"1\":{\"1525\":1}}],[\"requestparam\",{\"1\":{\"1159\":1,\"1165\":2,\"1168\":3,\"1172\":4,\"1362\":4,\"1525\":3,\"1531\":2}}],[\"requesthandled\",{\"1\":{\"1394\":3}}],[\"requestheader\",{\"1\":{\"1362\":1}}],[\"requestdatahelper\",{\"1\":{\"1232\":1}}],[\"requestmappinginfo\",{\"1\":{\"1355\":1}}],[\"requestmappinghandleradapter\",{\"0\":{\"1352\":1},\"1\":{\"1352\":1,\"1355\":1,\"1362\":1,\"1381\":1,\"1382\":2,\"1390\":2,\"1437\":1,\"1438\":1}}],[\"requestmappinghandlermapping\",{\"0\":{\"1352\":1},\"1\":{\"1352\":1,\"1355\":1,\"1437\":1,\"1438\":1}}],[\"requestmapping\",{\"1\":{\"1159\":2,\"1352\":1,\"1355\":1,\"1398\":1,\"1411\":1,\"1437\":2,\"1438\":1,\"1441\":1,\"1531\":1}}],[\"requestbody来接受数据的话\",{\"1\":{\"1525\":1}}],[\"requestbody注解\",{\"1\":{\"1229\":1}}],[\"requestbody是对json格式的入参进行处理\",{\"1\":{\"1229\":1}}],[\"requestbody\",{\"0\":{\"1229\":1},\"1\":{\"1133\":2,\"1159\":1,\"1362\":1,\"1438\":1,\"1525\":3,\"1526\":1,\"1531\":2}}],[\"requestoptions\",{\"1\":{\"1072\":3,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"request方法\",{\"1\":{\"719\":1}}],[\"request\",{\"0\":{\"1291\":1},\"1\":{\"716\":1,\"717\":2,\"718\":4,\"733\":3,\"1072\":6,\"1073\":17,\"1075\":4,\"1076\":3,\"1077\":4,\"1078\":4,\"1079\":4,\"1080\":4,\"1081\":4,\"1082\":4,\"1083\":4,\"1084\":4,\"1085\":4,\"1100\":2,\"1111\":4,\"1290\":1,\"1398\":1,\"1411\":1,\"1416\":1,\"1420\":1,\"1424\":1,\"1504\":1}}],[\"render\",{\"1\":{\"1416\":1}}],[\"renewal\",{\"1\":{\"1152\":2}}],[\"renewexpirationasync\",{\"1\":{\"1152\":1}}],[\"renewexpiration\",{\"1\":{\"1152\":2}}],[\"renamesnapshot\",{\"1\":{\"914\":1}}],[\"rename\",{\"1\":{\"279\":1,\"280\":1}}],[\"rebalance触发的时机有\",{\"1\":{\"1037\":1}}],[\"rebalance\",{\"0\":{\"1036\":1,\"1037\":1,\"1038\":1},\"1\":{\"1037\":1,\"1038\":4,\"1042\":5}}],[\"rebuildselector0\",{\"1\":{\"741\":1}}],[\"rebuild\",{\"1\":{\"276\":1,\"423\":2,\"742\":2,\"1128\":2,\"1129\":2}}],[\"reed\",{\"1\":{\"875\":1}}],[\"reentrantreadwritelock是一种读写锁\",{\"1\":{\"589\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"589\":1},\"1\":{\"581\":1}}],[\"reentrantlock的非公平体现在\",{\"1\":{\"588\":1}}],[\"reentrantlock的公平锁和非公平锁\",{\"0\":{\"588\":1}}],[\"reentrantlock与synchronized的区别\",{\"0\":{\"587\":1}}],[\"reentrantlock是基于lock接口和aqs抽象类实现的可重入锁\",{\"1\":{\"586\":1}}],[\"reentrantlock\",{\"0\":{\"586\":1},\"1\":{\"554\":2,\"555\":8}}],[\"rewind\",{\"1\":{\"803\":1,\"804\":1}}],[\"rewrite\",{\"1\":{\"276\":2}}],[\"rewriting=true\",{\"1\":{\"276\":1}}],[\"re\",{\"1\":{\"740\":1}}],[\"revision\",{\"1\":{\"876\":1}}],[\"revd\",{\"1\":{\"726\":1}}],[\"reverserangebyscorewithscores\",{\"1\":{\"1168\":1}}],[\"reverse\",{\"1\":{\"336\":3}}],[\"retentionpolicy\",{\"1\":{\"1525\":1}}],[\"retention\",{\"1\":{\"1525\":1}}],[\"retain\",{\"0\":{\"775\":1},\"1\":{\"713\":1,\"775\":1,\"776\":2}}],[\"retu\",{\"1\":{\"567\":1}}],[\"returnvaluehandlers\",{\"1\":{\"1381\":1}}],[\"returnvalue\",{\"1\":{\"733\":1,\"738\":2}}],[\"returntype\",{\"1\":{\"733\":4}}],[\"returns\",{\"1\":{\"70\":1,\"742\":1}}],[\"return\",{\"1\":{\"6\":4,\"7\":1,\"9\":2,\"14\":6,\"17\":11,\"22\":4,\"23\":5,\"28\":1,\"30\":1,\"34\":4,\"39\":4,\"42\":1,\"47\":1,\"51\":1,\"52\":2,\"54\":4,\"59\":9,\"60\":2,\"66\":7,\"68\":5,\"69\":7,\"70\":2,\"73\":4,\"74\":7,\"76\":3,\"81\":12,\"88\":4,\"344\":1,\"566\":1,\"574\":3,\"579\":7,\"585\":4,\"590\":2,\"614\":3,\"617\":1,\"645\":1,\"646\":1,\"649\":2,\"663\":2,\"668\":8,\"669\":4,\"671\":2,\"673\":3,\"701\":9,\"702\":2,\"723\":11,\"733\":3,\"737\":5,\"740\":11,\"741\":1,\"742\":1,\"743\":2,\"744\":2,\"757\":1,\"758\":1,\"766\":1,\"775\":2,\"799\":2,\"822\":5,\"846\":1,\"859\":1,\"962\":1,\"968\":1,\"972\":1,\"973\":3,\"974\":5,\"985\":1,\"988\":1,\"999\":4,\"1023\":1,\"1024\":1,\"1035\":1,\"1071\":1,\"1088\":1,\"1099\":5,\"1100\":2,\"1101\":1,\"1107\":3,\"1111\":5,\"1116\":1,\"1122\":5,\"1124\":4,\"1127\":6,\"1128\":3,\"1129\":17,\"1132\":1,\"1133\":2,\"1134\":5,\"1135\":3,\"1137\":14,\"1142\":7,\"1144\":1,\"1146\":3,\"1150\":6,\"1151\":6,\"1152\":8,\"1156\":5,\"1157\":5,\"1159\":2,\"1160\":2,\"1161\":5,\"1162\":5,\"1164\":4,\"1165\":6,\"1167\":2,\"1168\":3,\"1172\":5,\"1175\":2,\"1176\":4,\"1215\":1,\"1222\":1,\"1232\":4,\"1244\":1,\"1257\":1,\"1285\":1,\"1294\":1,\"1304\":1,\"1306\":1,\"1309\":3,\"1317\":1,\"1413\":2,\"1416\":3,\"1420\":4,\"1424\":3,\"1429\":4,\"1432\":1,\"1435\":2,\"1441\":1,\"1464\":3,\"1466\":2,\"1505\":6,\"1525\":1,\"1526\":2,\"1531\":1}}],[\"registrationbean\",{\"1\":{\"1451\":2}}],[\"registry\",{\"1\":{\"1100\":3}}],[\"registerbeandefinition\",{\"1\":{\"1248\":1}}],[\"registerbean\",{\"1\":{\"1244\":1}}],[\"register0\",{\"1\":{\"740\":4,\"743\":4}}],[\"register\",{\"1\":{\"740\":4,\"743\":4,\"746\":1,\"831\":1,\"834\":1,\"836\":2,\"840\":2,\"843\":3,\"846\":6}}],[\"registered\",{\"1\":{\"692\":1,\"693\":1,\"697\":2,\"698\":1,\"699\":2,\"740\":2,\"743\":1,\"748\":3}}],[\"regfuture\",{\"1\":{\"740\":15}}],[\"regexutils\",{\"1\":{\"1099\":2,\"1107\":1}}],[\"regexserde\",{\"1\":{\"374\":3}}],[\"regexserde正则加载\",{\"0\":{\"374\":1}}],[\"regex\",{\"1\":{\"336\":1,\"344\":2,\"374\":2}}],[\"regexp\",{\"1\":{\"330\":2,\"336\":8}}],[\"rehashing过程很复杂\",{\"1\":{\"606\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"572\":1}}],[\"reids集群模式下数据hash分片算法\",{\"0\":{\"528\":1}}],[\"red\",{\"1\":{\"1083\":1}}],[\"redis依赖\",{\"1\":{\"1219\":1,\"1221\":1}}],[\"redis没有类似mysql中的table的概念\",{\"1\":{\"1207\":1}}],[\"redis命令\",{\"0\":{\"1206\":1,\"1207\":1,\"1208\":1,\"1209\":1,\"1210\":1,\"1211\":1}}],[\"redis命令行客户端\",{\"0\":{\"1199\":1}}],[\"redis为了方便我们学习\",{\"1\":{\"1204\":1}}],[\"redis数据结构介绍\",{\"0\":{\"1204\":1}}],[\"redis数据本身就是共享的\",{\"1\":{\"1102\":1}}],[\"redis常见命令\",{\"0\":{\"1203\":1}}],[\"redis常见数据结构以及使用场景\",{\"0\":{\"515\":1}}],[\"redis默认有16个仓库\",{\"1\":{\"1202\":1}}],[\"redisdemoapplicationtests\",{\"1\":{\"1221\":1}}],[\"redisdesktopmanager\",{\"1\":{\"1200\":2}}],[\"redisdata\",{\"1\":{\"1128\":9,\"1129\":9}}],[\"redisdata<>\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"redisdata<shop>\",{\"1\":{\"1128\":1}}],[\"redisdata<t>\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"redis安装完成后就自带了命令行客户端\",{\"1\":{\"1199\":1}}],[\"redis桌面客户端\",{\"0\":{\"1198\":1}}],[\"redis是一个key\",{\"1\":{\"1204\":1}}],[\"redis是一种键值型的nosql数据库\",{\"1\":{\"1182\":1}}],[\"redis是基于c语言编写的\",{\"1\":{\"1192\":1}}],[\"redis诞生于2009年全称是remote\",{\"1\":{\"1190\":1}}],[\"redis简单介绍\",{\"0\":{\"1182\":1}}],[\"redis系列整理学习自黑马程序员redis相关课程\",{\"1\":{\"1181\":1}}],[\"redis<\",{\"1\":{\"1172\":3,\"1219\":1}}],[\"redisgeocommands\",{\"1\":{\"1171\":1,\"1172\":1}}],[\"redislock\",{\"1\":{\"1157\":3}}],[\"redisconnectionfactory\",{\"1\":{\"1222\":1}}],[\"redisconfig\",{\"1\":{\"1222\":1}}],[\"redisconstants\",{\"1\":{\"1122\":4,\"1124\":5,\"1127\":8,\"1128\":4,\"1129\":7,\"1156\":1,\"1161\":1,\"1172\":1}}],[\"rediscommands\",{\"1\":{\"1152\":2}}],[\"redisstringtests\",{\"1\":{\"1223\":1,\"1224\":1}}],[\"redisserializer\",{\"1\":{\"1222\":2}}],[\"redission会将多个锁添加到一个集合中\",{\"1\":{\"1153\":1}}],[\"redission提出来了mutilock锁\",{\"1\":{\"1153\":1}}],[\"redission锁的mutilock原理\",{\"0\":{\"1153\":1}}],[\"redissionclient\",{\"1\":{\"1150\":1}}],[\"redissonclient\",{\"1\":{\"1150\":7,\"1157\":1}}],[\"redissonconfig\",{\"1\":{\"1150\":1}}],[\"redisson<\",{\"1\":{\"1150\":1}}],[\"redisson\",{\"0\":{\"1148\":1,\"1149\":1,\"1150\":1,\"1151\":1,\"1152\":1},\"1\":{\"1149\":3,\"1150\":3,\"1151\":1,\"1212\":1}}],[\"redis提供了lua脚本功能\",{\"1\":{\"1146\":1}}],[\"redis分布式锁误删情况说明\",{\"0\":{\"1143\":1}}],[\"redis分布式锁的实现核心思路\",{\"0\":{\"1141\":1}}],[\"redis作为分布式锁是非常常见的一种使用方式\",{\"1\":{\"1140\":1}}],[\"redisidworker\",{\"1\":{\"1132\":3,\"1134\":1,\"1137\":3,\"1156\":1,\"1157\":2}}],[\"redis实现全局唯一id\",{\"0\":{\"1132\":1}}],[\"redis的java客户端\",{\"0\":{\"1212\":1,\"1217\":1}}],[\"redis的sortedset是一个可排序的set集合\",{\"1\":{\"1211\":1}}],[\"redis的set结构与java中的hashset类似\",{\"1\":{\"1210\":1}}],[\"redis的key允许有多个单词形成层级结构\",{\"1\":{\"1207\":1}}],[\"redis的其它常见配置\",{\"1\":{\"1196\":1}}],[\"redis的启动方式有很多种\",{\"1\":{\"1194\":1}}],[\"redis的官方网站地址\",{\"1\":{\"1190\":1}}],[\"redis的value中\",{\"1\":{\"1126\":1}}],[\"redis的内存淘汰机制使用了allkeys\",{\"1\":{\"521\":1}}],[\"redistemplate的两种序列化实践方案\",{\"1\":{\"1223\":1}}],[\"redistemplate<>\",{\"1\":{\"1222\":1}}],[\"redistemplate<string\",{\"1\":{\"1221\":1,\"1222\":2}}],[\"redistemplate可以接收任意object作为值写入redis\",{\"1\":{\"1222\":1}}],[\"redistemplate\",{\"1\":{\"1122\":3,\"1124\":3,\"1127\":5,\"1128\":2,\"1129\":11,\"1142\":3,\"1144\":3,\"1147\":1,\"1150\":1,\"1156\":2,\"1157\":1,\"1161\":4,\"1162\":4,\"1165\":3,\"1168\":1,\"1171\":1,\"1172\":1,\"1175\":1,\"1176\":1,\"1180\":2,\"1221\":3,\"1222\":1}}],[\"redis会以层级结构来进行存储\",{\"1\":{\"1207\":1}}],[\"redis会将超时的数据进行删除\",{\"1\":{\"1119\":1}}],[\"redis会返回转向指令\",{\"1\":{\"527\":1}}],[\"redis自动进行\",{\"1\":{\"1119\":1}}],[\"redis中的list类型与java中的linkedlist类似\",{\"1\":{\"1209\":1}}],[\"redis中的hll是基于string结构实现的\",{\"1\":{\"1179\":1}}],[\"redis中\",{\"1\":{\"1107\":1}}],[\"redis中数据大量过期\",{\"1\":{\"530\":1}}],[\"redis代替session的业务流程\",{\"0\":{\"1103\":1}}],[\"redis里面有一个randomkey命令可以从redis中随机取出一个key\",{\"1\":{\"529\":1}}],[\"redis执行命令出现死循环bug\",{\"0\":{\"529\":1}}],[\"redis集群的性能和高可用性均优于之前版本的哨兵模式\",{\"1\":{\"527\":1}}],[\"redis集群不需要sentine哨兵也能完成节点移出和故障转移的功能\",{\"1\":{\"527\":1}}],[\"redis集群是由多个主从节点群组成的分布式服务器群\",{\"1\":{\"527\":1}}],[\"redis主从的部署架构\",{\"1\":{\"526\":1}}],[\"redis高可用方案\",{\"0\":{\"524\":1}}],[\"redis内存淘汰机制\",{\"0\":{\"522\":1}}],[\"redis底层数据是如何用跳表来存储的\",{\"0\":{\"518\":1}}],[\"redis单线程为什么还快\",{\"0\":{\"517\":1}}],[\"redis到底是单线程还是多线程\",{\"0\":{\"516\":1}}],[\"redis\",{\"0\":{\"514\":1,\"519\":1,\"521\":1,\"710\":1,\"1090\":1,\"1156\":1,\"1181\":1,\"1205\":1,\"1561\":1},\"1\":{\"516\":2,\"528\":1,\"530\":1,\"661\":5,\"662\":2,\"663\":8,\"664\":2,\"665\":2,\"667\":3,\"997\":1,\"1140\":2,\"1141\":1,\"1146\":7,\"1149\":2,\"1150\":1,\"1151\":10,\"1155\":7,\"1156\":5,\"1157\":1,\"1170\":1,\"1171\":7,\"1172\":1,\"1174\":1,\"1175\":1,\"1177\":2,\"1190\":1,\"1193\":5,\"1195\":1,\"1196\":9,\"1197\":9,\"1199\":2,\"1204\":1,\"1212\":1,\"1217\":1,\"1220\":1},\"2\":{\"1225\":1,\"1226\":1}}],[\"redo\",{\"1\":{\"499\":1,\"506\":2}}],[\"reduce端join最大的问题是整个join的工作是在reduce阶段完成的\",{\"1\":{\"988\":1}}],[\"reduce处理的结果会调用默认输出组件textoutputformat写入到指定的目录文件中\",{\"1\":{\"980\":1}}],[\"reduce进程启动一些数据copy线程\",{\"1\":{\"980\":1}}],[\"reducetask工作机制详解\",{\"0\":{\"980\":1}}],[\"reducetask并行度机制\",{\"0\":{\"977\":1}}],[\"reducetask会主动从maptask复制拉取其输出的键值对\",{\"1\":{\"966\":1}}],[\"reducetask个数的改变还会导致输出结果文件不再是一个整体\",{\"1\":{\"968\":1}}],[\"reducetask个数的改变导致了数据分区的产生\",{\"1\":{\"968\":1}}],[\"reducetask个数\",{\"1\":{\"313\":1}}],[\"reduce方法基于分组调用\",{\"1\":{\"961\":1}}],[\"reducer<nullwritable\",{\"1\":{\"986\":2}}],[\"reducer<covidtop1bean\",{\"1\":{\"974\":2}}],[\"reducer<text\",{\"1\":{\"960\":2,\"972\":2,\"973\":2,\"988\":4}}],[\"reducer类\",{\"1\":{\"962\":3,\"972\":1,\"973\":1,\"974\":1,\"988\":1,\"991\":2}}],[\"reducer的keyin和valuein对应着mapper的keyout和valueout\",{\"1\":{\"961\":1}}],[\"reducer的四个泛型很好确定\",{\"1\":{\"961\":1}}],[\"reducer的四个泛型分别为\",{\"1\":{\"961\":1}}],[\"reduce阶段执行过程\",{\"0\":{\"966\":1}}],[\"reduce阶段的处理类\",{\"1\":{\"960\":1}}],[\"reduce阶段\",{\"0\":{\"960\":1}}],[\"reduce\",{\"0\":{\"449\":1,\"988\":1},\"1\":{\"438\":1,\"444\":1,\"620\":4,\"960\":1,\"972\":1,\"973\":1,\"974\":1,\"986\":1,\"988\":2,\"991\":2}}],[\"reducejoinsortreducer\",{\"1\":{\"988\":2,\"991\":1}}],[\"reducejoinsortmapper\",{\"1\":{\"988\":2,\"991\":1}}],[\"reducejoinsort\",{\"1\":{\"988\":5,\"991\":4}}],[\"reducejoindriver\",{\"1\":{\"988\":1,\"991\":2}}],[\"reducejoinreducer\",{\"1\":{\"988\":2,\"991\":1}}],[\"reducejoinmapper\",{\"1\":{\"988\":2,\"991\":1}}],[\"reducejoin\",{\"1\":{\"418\":1}}],[\"reduce作业中\",{\"1\":{\"326\":1}}],[\"reduce作业将a与b联接在一起\",{\"1\":{\"326\":1}}],[\"reduces\",{\"1\":{\"313\":1}}],[\"reduces=n来手动设定reducetask的个数\",{\"1\":{\"313\":1}}],[\"receive\",{\"1\":{\"848\":2}}],[\"recently\",{\"1\":{\"522\":2}}],[\"recvbufallochandle\",{\"1\":{\"743\":1,\"744\":1}}],[\"recvbytebufallocator\",{\"1\":{\"743\":1,\"744\":1}}],[\"recvfrom\",{\"1\":{\"679\":1}}],[\"record数据大小\",{\"1\":{\"1021\":1}}],[\"records\",{\"1\":{\"1021\":4,\"1024\":2,\"1161\":3,\"1165\":2}}],[\"recordreader读取一行数据\",{\"1\":{\"979\":1}}],[\"record\",{\"1\":{\"511\":2,\"1021\":2,\"1024\":5,\"1025\":2}}],[\"recursive=true\",{\"1\":{\"470\":1}}],[\"rectangle\",{\"1\":{\"23\":5}}],[\"refresh\",{\"1\":{\"1244\":1,\"1444\":1}}],[\"refreshtokeninterceptor\",{\"1\":{\"1100\":1,\"1111\":3}}],[\"refreshnodes等待节点迁移数据后退役\",{\"1\":{\"879\":1}}],[\"ref\",{\"1\":{\"481\":1}}],[\"referencecountutil\",{\"1\":{\"775\":2}}],[\"referencecounted\",{\"1\":{\"775\":3}}],[\"reference\",{\"1\":{\"300\":1}}],[\"reflect=all\",{\"1\":{\"1313\":2}}],[\"reflect\",{\"1\":{\"59\":4,\"343\":2}}],[\"remainder\",{\"1\":{\"799\":5}}],[\"remaining\",{\"1\":{\"167\":1}}],[\"remote=\",{\"1\":{\"836\":2}}],[\"remoteaddress\",{\"1\":{\"725\":2}}],[\"remote\",{\"1\":{\"63\":1,\"244\":1,\"949\":1}}],[\"removeuser\",{\"1\":{\"1101\":1,\"1111\":1}}],[\"removepolicy\",{\"1\":{\"875\":1}}],[\"removereadop\",{\"1\":{\"743\":1,\"744\":1}}],[\"removegroup\",{\"1\":{\"701\":1}}],[\"removemember\",{\"1\":{\"701\":1,\"704\":1}}],[\"remove改变集合元素的操作之中\",{\"1\":{\"579\":1}}],[\"remove=true\",{\"1\":{\"470\":1}}],[\"remove\",{\"0\":{\"837\":1},\"1\":{\"47\":1,\"738\":1,\"740\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":2,\"846\":2,\"1101\":1,\"1161\":1,\"1162\":1,\"1164\":1,\"1165\":2}}],[\"resolvabledependencies\",{\"1\":{\"1482\":1,\"1489\":2}}],[\"resolveargument\",{\"1\":{\"1362\":1}}],[\"resource既可以按类型注入也可以指定bean名称注入\",{\"1\":{\"1503\":1}}],[\"resourcehttprequesthandler\",{\"1\":{\"1429\":7,\"1430\":1,\"1432\":3}}],[\"resourcehttprequesthandler>\",{\"1\":{\"1429\":1}}],[\"resources这些注解的功能\",{\"1\":{\"1502\":1}}],[\"resources\",{\"1\":{\"1244\":1,\"1441\":1,\"1443\":1}}],[\"resources>\",{\"1\":{\"102\":1}}],[\"resourcebundlemessagesource\",{\"1\":{\"1244\":2}}],[\"resource\",{\"1\":{\"1023\":1,\"1100\":1,\"1150\":2,\"1159\":1,\"1240\":1,\"1243\":1,\"1248\":2,\"1254\":1,\"1257\":2,\"1264\":1,\"1435\":3,\"1503\":1,\"1505\":1}}],[\"resourcetracker\",{\"1\":{\"949\":1}}],[\"resourcemanageradministrationprotocol\",{\"1\":{\"949\":1}}],[\"resourcemanager主要由两个组件构成\",{\"1\":{\"945\":1}}],[\"resourcemanager\",{\"0\":{\"945\":1},\"1\":{\"944\":1,\"953\":4,\"963\":1}}],[\"resource中确保关闭\",{\"1\":{\"717\":1,\"718\":1}}],[\"resource>\",{\"1\":{\"102\":1}}],[\"reschedule\",{\"1\":{\"1152\":1}}],[\"res\",{\"1\":{\"1152\":2}}],[\"restart\",{\"1\":{\"1197\":1}}],[\"restcontroller是\",{\"1\":{\"1525\":1}}],[\"restcontroller\",{\"1\":{\"1159\":2,\"1525\":1}}],[\"restclientbuilder\",{\"1\":{\"1088\":1}}],[\"restclient\",{\"1\":{\"1071\":1,\"1088\":1}}],[\"resthighlevelclient\",{\"1\":{\"1071\":3,\"1072\":3,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1088\":2}}],[\"rest\",{\"1\":{\"1070\":1,\"1071\":1}}],[\"restrict|cascade\",{\"1\":{\"278\":1}}],[\"resizable\",{\"1\":{\"841\":1}}],[\"resetreaderindex\",{\"1\":{\"774\":1}}],[\"reset\",{\"0\":{\"804\":1},\"1\":{\"743\":1,\"744\":1,\"774\":1,\"804\":1}}],[\"reservationnode<k\",{\"1\":{\"579\":1}}],[\"research\",{\"1\":{\"133\":1}}],[\"responsebody的合集\",{\"1\":{\"1525\":1}}],[\"responsebodyadvice\",{\"0\":{\"1399\":1,\"1400\":1},\"1\":{\"1401\":1,\"1402\":1}}],[\"responsebody\",{\"1\":{\"1394\":1,\"1398\":1,\"1438\":1,\"1526\":1}}],[\"responseentity\",{\"1\":{\"1394\":1,\"1525\":2,\"1526\":2,\"1531\":2}}],[\"response\",{\"1\":{\"167\":1,\"702\":2,\"711\":4,\"733\":3,\"734\":5,\"794\":4,\"1072\":8,\"1073\":4,\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2,\"1100\":2,\"1111\":4,\"1416\":3,\"1420\":2}}],[\"respectmaybemoredata\",{\"1\":{\"744\":2}}],[\"respect\",{\"1\":{\"70\":1}}],[\"resulttype=\",{\"1\":{\"1230\":1}}],[\"resultmap=\",{\"1\":{\"1230\":2}}],[\"resultmap>\",{\"1\":{\"1230\":2}}],[\"results\",{\"1\":{\"1172\":3}}],[\"resultset\",{\"1\":{\"985\":1}}],[\"resultflag\",{\"1\":{\"962\":2,\"972\":2,\"973\":2,\"974\":2}}],[\"resultclass=\",{\"1\":{\"483\":3}}],[\"result\",{\"1\":{\"59\":4,\"60\":2,\"81\":2,\"763\":2,\"764\":2,\"857\":2,\"859\":3,\"974\":3,\"1099\":7,\"1107\":4,\"1116\":1,\"1122\":7,\"1129\":3,\"1133\":4,\"1134\":6,\"1135\":2,\"1137\":15,\"1142\":5,\"1150\":5,\"1156\":7,\"1157\":5,\"1159\":4,\"1160\":3,\"1161\":8,\"1162\":6,\"1164\":6,\"1165\":10,\"1167\":3,\"1168\":4,\"1172\":9,\"1175\":3,\"1176\":8,\"1213\":3,\"1304\":2,\"1306\":3,\"1309\":4,\"1317\":4}}],[\"replicas\",{\"0\":{\"1067\":1},\"1\":{\"1049\":2}}],[\"replica\",{\"1\":{\"1026\":1}}],[\"replicate和\",{\"1\":{\"875\":1}}],[\"replicate在目录上应用默认的replication方案\",{\"1\":{\"875\":1}}],[\"replicate\",{\"1\":{\"875\":1}}],[\"replication始终处于启用状态\",{\"1\":{\"875\":1}}],[\"replication\",{\"1\":{\"870\":3,\"901\":1,\"1020\":1}}],[\"replaceall\",{\"1\":{\"344\":1,\"373\":1}}],[\"replace\",{\"1\":{\"279\":1,\"336\":3,\"566\":1,\"822\":1,\"823\":1}}],[\"repeat\",{\"1\":{\"336\":3}}],[\"repair\",{\"1\":{\"280\":1,\"281\":2}}],[\"reporting\",{\"1\":{\"99\":2}}],[\"repo<\",{\"1\":{\"92\":1}}],[\"repository用于声明dao层的bean\",{\"1\":{\"1503\":1}}],[\"repository<\",{\"1\":{\"92\":1}}],[\"repository\",{\"1\":{\"92\":2,\"1089\":1,\"1219\":1,\"1503\":1}}],[\"rep\",{\"1\":{\"69\":1,\"336\":1}}],[\"reached\",{\"1\":{\"775\":1}}],[\"reactivestreamdemo2\",{\"1\":{\"718\":1}}],[\"reactivestreamdemo\",{\"1\":{\"717\":1}}],[\"reactive\",{\"0\":{\"1546\":1},\"1\":{\"716\":2,\"1245\":1}}],[\"reactor模式是基于同步io\",{\"1\":{\"611\":1}}],[\"reactor和proactor\",{\"1\":{\"611\":3}}],[\"real\",{\"1\":{\"57\":1}}],[\"realizetype\",{\"1\":{\"51\":8}}],[\"readvalue\",{\"1\":{\"1223\":1}}],[\"readview\",{\"1\":{\"503\":1}}],[\"readdbdriver\",{\"1\":{\"985\":4}}],[\"readdbmapper\",{\"1\":{\"985\":3}}],[\"readdouble\",{\"1\":{\"985\":2}}],[\"readutf\",{\"1\":{\"974\":2,\"985\":2}}],[\"readfields\",{\"1\":{\"972\":1,\"974\":1,\"985\":2}}],[\"readfields叫做反序列化方法\",{\"1\":{\"956\":1}}],[\"readfds和exceptfds\",{\"1\":{\"680\":1}}],[\"readhandler\",{\"1\":{\"859\":4}}],[\"reads分散读\",{\"0\":{\"807\":1}}],[\"readsd\",{\"1\":{\"6\":7,\"7\":3}}],[\"readlong\",{\"1\":{\"972\":2,\"974\":1,\"985\":2}}],[\"readlock\",{\"1\":{\"590\":2}}],[\"readline\",{\"1\":{\"795\":2,\"990\":1}}],[\"readcomplete\",{\"1\":{\"743\":1,\"744\":1}}],[\"readbuf\",{\"1\":{\"743\":6}}],[\"readbytes\",{\"1\":{\"713\":1,\"714\":1,\"723\":2,\"748\":1,\"802\":1,\"814\":1}}],[\"readbyte\",{\"1\":{\"713\":4,\"714\":4,\"723\":4,\"774\":4,\"776\":2}}],[\"readpending\",{\"1\":{\"740\":1,\"743\":3,\"744\":3}}],[\"readifisautoread\",{\"1\":{\"740\":1,\"743\":1}}],[\"readinterestop\",{\"1\":{\"740\":3,\"743\":2}}],[\"readint\",{\"1\":{\"713\":3,\"714\":3,\"723\":3,\"774\":1}}],[\"readablebytes\",{\"1\":{\"713\":1,\"748\":1,\"768\":1,\"779\":2}}],[\"read之后\",{\"1\":{\"679\":1}}],[\"readtime\",{\"1\":{\"590\":1}}],[\"readtf\",{\"1\":{\"6\":3,\"7\":1}}],[\"readyops\",{\"1\":{\"742\":6}}],[\"ready\",{\"1\":{\"160\":1,\"1444\":1}}],[\"readordinaryobject\",{\"1\":{\"69\":2}}],[\"readobject0\",{\"1\":{\"69\":2}}],[\"readobjectfromfile\",{\"1\":{\"68\":3}}],[\"readobject\",{\"1\":{\"54\":1,\"68\":1,\"69\":1,\"713\":1,\"714\":1,\"723\":2}}],[\"readresolve\",{\"1\":{\"69\":3}}],[\"readerindex\",{\"1\":{\"768\":1}}],[\"reader\",{\"1\":{\"9\":1,\"707\":2,\"795\":4}}],[\"read\",{\"0\":{\"744\":1,\"836\":1},\"1\":{\"6\":3,\"7\":1,\"9\":4,\"69\":1,\"70\":1,\"88\":11,\"503\":1,\"590\":1,\"692\":2,\"693\":4,\"697\":11,\"698\":11,\"699\":11,\"725\":1,\"726\":2,\"740\":4,\"742\":4,\"743\":10,\"744\":7,\"748\":12,\"768\":2,\"772\":2,\"773\":1,\"774\":5,\"775\":1,\"776\":2,\"796\":1,\"797\":1,\"799\":1,\"802\":2,\"807\":1,\"814\":1,\"826\":4,\"827\":7,\"831\":1,\"833\":1,\"834\":1,\"836\":4,\"837\":1,\"839\":4,\"840\":8,\"843\":4,\"846\":5,\"851\":2,\"854\":2,\"857\":6,\"858\":1,\"859\":7,\"872\":2,\"1120\":1}}],[\"现有数据的任何转换都必须在hive之外进行\",{\"1\":{\"279\":1}}],[\"现有一台电脑只能读取sd卡\",{\"1\":{\"6\":1}}],[\"现象分析\",{\"0\":{\"694\":1}}],[\"现象\",{\"1\":{\"167\":1,\"192\":1,\"694\":2}}],[\"现通过模板方法模式来用代码模拟\",{\"1\":{\"85\":1}}],[\"现在\",{\"1\":{\"1197\":1}}],[\"现在站在收件人这端来看\",{\"1\":{\"1166\":1}}],[\"现在我们去下单时\",{\"1\":{\"1157\":1}}],[\"现在以主从为例\",{\"1\":{\"1153\":1}}],[\"现在企业级开发中基本都使用redis或者zookeeper作为分布式锁\",{\"1\":{\"1140\":1}}],[\"现在第一个微服务可以将消息放入到消息队列中\",{\"1\":{\"1009\":1}}],[\"现在的情况是\",{\"1\":{\"1152\":1}}],[\"现在的问题是这个主键其实并没有那么短\",{\"1\":{\"1177\":1}}],[\"现在的问题还是和之前一样\",{\"1\":{\"1137\":1}}],[\"现在的问题在于\",{\"1\":{\"1137\":1}}],[\"现在的方案是\",{\"1\":{\"1127\":1}}],[\"现在的逻辑中\",{\"1\":{\"1124\":1}}],[\"现在的服务基本是分布式\",{\"1\":{\"997\":1}}],[\"现在的操作系统都是采用虚拟存储器\",{\"1\":{\"676\":1}}],[\"现在都是多核\",{\"1\":{\"846\":1}}],[\"现在要求你编写程序\",{\"1\":{\"809\":1}}],[\"现在需要一个新的\",{\"1\":{\"779\":1}}],[\"现在把它拆开来看\",{\"1\":{\"753\":1}}],[\"现在假设一个压缩列表中有多个连续的\",{\"1\":{\"666\":1}}],[\"现在不使用了\",{\"1\":{\"181\":1}}],[\"现在使用\",{\"1\":{\"179\":1}}],[\"现在使用简单工厂对上面案例进行改进\",{\"1\":{\"28\":1}}],[\"现在如果我们还需要再创建一个传智品牌的安全门\",{\"1\":{\"75\":1}}],[\"现要组装一台电脑\",{\"1\":{\"74\":1}}],[\"现咖啡店业务发生改变\",{\"1\":{\"39\":1}}],[\"反而会因为频繁上下文切换导致性能降低\",{\"1\":{\"826\":1}}],[\"反而有所增加\",{\"1\":{\"755\":1}}],[\"反而效率会受影响\",{\"1\":{\"561\":1}}],[\"反而比较像是一种编程习惯\",{\"1\":{\"26\":1}}],[\"反过来\",{\"1\":{\"483\":1}}],[\"反例\",{\"1\":{\"480\":1,\"481\":2}}],[\"反引号不在解释为其他含义\",{\"1\":{\"302\":1}}],[\"反序列化的顺序与序列化一致\",{\"1\":{\"972\":1}}],[\"反序列化错误\",{\"1\":{\"723\":1}}],[\"反序列化方法\",{\"1\":{\"723\":1,\"972\":1}}],[\"反序列化\",{\"1\":{\"723\":1,\"956\":1}}],[\"反序列化机制\",{\"1\":{\"723\":1}}],[\"反序列化时\",{\"1\":{\"723\":1}}],[\"反序列化主要用在消息正文的转换上\",{\"1\":{\"723\":1}}],[\"反序列化是字节码转换为对象的过程\",{\"1\":{\"249\":1}}],[\"反序列方式破坏单例模式的解决方法\",{\"1\":{\"69\":1}}],[\"反之则没有签到\",{\"1\":{\"1175\":1}}],[\"反之则是线程不安全的\",{\"1\":{\"627\":1}}],[\"反之\",{\"1\":{\"248\":1,\"1512\":1}}],[\"反之不可用\",{\"1\":{\"6\":1}}],[\"反复的申请和释放资源会增加系统的开销\",{\"1\":{\"176\":1}}],[\"反射时就可以拿到参数名\",{\"1\":{\"1366\":1}}],[\"反射的知识\",{\"1\":{\"1310\":1}}],[\"反射的方式\",{\"1\":{\"629\":2}}],[\"反射函数\",{\"1\":{\"343\":1}}],[\"反射破解单例模式需要添加的代码\",{\"1\":{\"69\":1}}],[\"反射方式破解单例的解决方法\",{\"1\":{\"69\":1}}],[\"反射\",{\"1\":{\"68\":1,\"1243\":1}}],[\"不满足则不管理\",{\"1\":{\"1466\":1}}],[\"不满足让权等待\",{\"1\":{\"170\":2,\"171\":1}}],[\"不走第\",{\"1\":{\"1438\":1}}],[\"不增强\",{\"1\":{\"1321\":3}}],[\"不到万不得已不要使用\",{\"1\":{\"1230\":1}}],[\"不指定commond时\",{\"1\":{\"1199\":1}}],[\"不指定表示内部表\",{\"1\":{\"258\":1}}],[\"不记录日志\",{\"1\":{\"1196\":1}}],[\"不够优雅\",{\"1\":{\"1186\":1}}],[\"不做内容筛选\",{\"1\":{\"1166\":1}}],[\"不做处理\",{\"1\":{\"775\":1}}],[\"不就死锁了吗\",{\"1\":{\"1149\":1}}],[\"不让线程进行\",{\"1\":{\"1140\":1}}],[\"不足则无法下单\",{\"1\":{\"1134\":1}}],[\"不查询数据库\",{\"1\":{\"1128\":1}}],[\"不为\",{\"1\":{\"1438\":1}}],[\"不为0\",{\"1\":{\"1157\":1}}],[\"不为null且存在\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":1}}],[\"不为真\",{\"1\":{\"340\":1}}],[\"不一致\",{\"1\":{\"1099\":1,\"1107\":1,\"1146\":1}}],[\"不一定需要采取内存保护\",{\"1\":{\"182\":1}}],[\"不一定能做到真正的短作业优先\",{\"1\":{\"167\":1}}],[\"不分词\",{\"1\":{\"1089\":1}}],[\"不管有没有成功\",{\"1\":{\"1053\":1}}],[\"不管是否写入成功\",{\"1\":{\"1043\":1}}],[\"不管是上面那种实现方式\",{\"1\":{\"689\":1}}],[\"不管是string还是其他的数据类型\",{\"1\":{\"523\":1}}],[\"不管是不是自己的目标更新字段\",{\"1\":{\"483\":1}}],[\"不依赖第三方库或者中间件\",{\"1\":{\"1000\":1}}],[\"不影响往缓冲区写map结果的线程\",{\"1\":{\"979\":1}}],[\"不易受外部服务的影响\",{\"1\":{\"924\":1}}],[\"不易统一管理\",{\"1\":{\"107\":1}}],[\"不防止坏人做坏事\",{\"1\":{\"922\":1}}],[\"不利用\",{\"1\":{\"855\":1}}],[\"不受gc影响\",{\"1\":{\"801\":1}}],[\"不受影响\",{\"1\":{\"776\":1}}],[\"不返回\",{\"1\":{\"783\":1}}],[\"不必再执行\",{\"1\":{\"742\":1}}],[\"不断从阻塞队列中获取信息\",{\"1\":{\"1156\":1}}],[\"不断发起这样的请求\",{\"1\":{\"1124\":1}}],[\"不断看有没有新任务\",{\"1\":{\"741\":1}}],[\"不断地轮询所负责的所有socket\",{\"1\":{\"679\":1}}],[\"不用临时拉取\",{\"1\":{\"1166\":1}}],[\"不用主动去寻找\",{\"1\":{\"1166\":1}}],[\"不用\",{\"1\":{\"726\":1}}],[\"不用维护多个线程\",{\"1\":{\"610\":1}}],[\"不保存状态时\",{\"1\":{\"714\":1}}],[\"不得不冗余的将这两个商品保存在张三的订单文档中\",{\"1\":{\"1186\":1}}],[\"不得束修金\",{\"1\":{\"709\":1}}],[\"不得使用外键与级联\",{\"1\":{\"482\":1}}],[\"不论使快表还是多级页表实际上都利用到了程序的局部性原理\",{\"1\":{\"683\":1}}],[\"不考虑第\",{\"1\":{\"649\":2}}],[\"不考虑重复\",{\"1\":{\"363\":1}}],[\"不存在则新建\",{\"1\":{\"1106\":1}}],[\"不存在\",{\"1\":{\"1099\":1,\"1100\":1,\"1107\":1,\"1122\":1,\"1124\":1,\"1128\":1,\"1129\":3,\"1151\":1,\"1206\":1}}],[\"不存在返回\",{\"1\":{\"668\":1}}],[\"不存在线程安全问题\",{\"1\":{\"630\":1}}],[\"不存在的数据\",{\"1\":{\"1177\":1}}],[\"不存在的梗图\",{\"1\":{\"125\":1}}],[\"不存在的花瓶\",{\"1\":{\"125\":1}}],[\"不存在的人脸\",{\"1\":{\"125\":1}}],[\"不规整\",{\"1\":{\"630\":1}}],[\"不调用任何构造器\",{\"1\":{\"629\":1}}],[\"不相同就通过拉链表解决冲突\",{\"1\":{\"605\":1}}],[\"不相关子查询\",{\"1\":{\"317\":2}}],[\"不设置的情况下\",{\"1\":{\"601\":1}}],[\"不总是处于繁忙状态\",{\"1\":{\"576\":1}}],[\"不接受新任务\",{\"1\":{\"571\":1}}],[\"不怕别的线程来修复共享变量\",{\"1\":{\"561\":1}}],[\"不关心数据该如何处理\",{\"1\":{\"548\":1}}],[\"不加入monitor的阻塞队列entrylist中\",{\"1\":{\"542\":1}}],[\"不加synchronized的对象不会关联监视器\",{\"1\":{\"541\":1}}],[\"不遵从上述规则\",{\"1\":{\"541\":1}}],[\"不包含记录本身\",{\"1\":{\"511\":1}}],[\"不这么做的话\",{\"1\":{\"510\":1}}],[\"不兼容\",{\"1\":{\"508\":3,\"510\":3}}],[\"不采用数据库本身的锁机制\",{\"1\":{\"507\":1}}],[\"不允许重复下单\",{\"1\":{\"1142\":1,\"1150\":1,\"1157\":1}}],[\"不允许再执行降级和回滚\",{\"1\":{\"892\":1}}],[\"不允许hdfs客户端进行任何修改文件的操作\",{\"1\":{\"870\":1}}],[\"不允许直接拿hashmap与hashtable作为查询结果集的输出\",{\"1\":{\"483\":1}}],[\"不允许从非acid会话读取\",{\"1\":{\"267\":1}}],[\"不适合插入\",{\"1\":{\"995\":1}}],[\"不适合查询\",{\"1\":{\"995\":1}}],[\"不适合分布式\",{\"1\":{\"482\":1}}],[\"不适用于生产环境\",{\"1\":{\"242\":1}}],[\"不适用于用户进程\",{\"1\":{\"170\":1}}],[\"不适用在多处理机\",{\"1\":{\"170\":1}}],[\"不要求目标实现接口\",{\"1\":{\"1307\":1}}],[\"不要等待特定百分比的块\",{\"1\":{\"870\":1}}],[\"不要定义冗余或重复的索引\",{\"1\":{\"494\":1}}],[\"不要更新无改动的字段\",{\"1\":{\"483\":1}}],[\"不要写一个大而全的数据更新接口\",{\"1\":{\"483\":1}}],[\"不要使用\",{\"1\":{\"498\":1}}],[\"不要使用$\",{\"1\":{\"483\":1}}],[\"不要使用count\",{\"1\":{\"482\":1}}],[\"不要用resultclass当返回参数\",{\"1\":{\"483\":1}}],[\"不要以为唯一索引影响了insert速度\",{\"1\":{\"481\":1,\"493\":1}}],[\"不要对实现进行编程\",{\"1\":{\"74\":1}}],[\"不但节约数据库表空间\",{\"1\":{\"480\":1}}],[\"不是字符串\",{\"1\":{\"1482\":1}}],[\"不是相对broker\",{\"1\":{\"1048\":1}}],[\"不是立刻写入磁盘\",{\"1\":{\"819\":1}}],[\"不是我们想象的\",{\"1\":{\"775\":1}}],[\"不是\",{\"1\":{\"749\":1}}],[\"不是读取数据\",{\"1\":{\"740\":1}}],[\"不是轮询的方式\",{\"1\":{\"680\":1}}],[\"不是完整收集整个java堆的垃圾收集\",{\"1\":{\"628\":1}}],[\"不是varchar超长字段\",{\"1\":{\"480\":1}}],[\"不是频繁修改的字段\",{\"1\":{\"480\":1}}],[\"不预先分配存储空间\",{\"1\":{\"480\":1}}],[\"不应该表示实体数量\",{\"1\":{\"480\":1}}],[\"不合并\",{\"1\":{\"470\":1}}],[\"不留下空位\",{\"1\":{\"403\":1}}],[\"不去重不排序\",{\"1\":{\"386\":1}}],[\"不推荐使用keys\",{\"1\":{\"1205\":1}}],[\"不推荐使用\",{\"1\":{\"375\":1,\"483\":1,\"1195\":1}}],[\"不挤占后续位置\",{\"1\":{\"363\":1}}],[\"不处理边界的问题⚠️\",{\"0\":{\"839\":1}}],[\"不处理\",{\"1\":{\"344\":1,\"522\":1}}],[\"不在同一毫秒内\",{\"1\":{\"999\":1}}],[\"不在线\",{\"1\":{\"703\":1}}],[\"不在索引列上做任何操作\",{\"1\":{\"505\":1}}],[\"不在\",{\"1\":{\"332\":1}}],[\"不建议使用无序的值作为索引\",{\"1\":{\"494\":1}}],[\"不建议使用\",{\"1\":{\"325\":1}}],[\"不进垃圾桶\",{\"1\":{\"280\":1}}],[\"不进入抢锁阶段\",{\"1\":{\"66\":2}}],[\"不缓冲记录\",{\"1\":{\"270\":1}}],[\"不实际存储数据\",{\"1\":{\"270\":1}}],[\"不支持本地运行\",{\"1\":{\"990\":1}}],[\"不支持动态的离线数据\",{\"1\":{\"955\":1}}],[\"不支持可重入\",{\"1\":{\"590\":1}}],[\"不支持条件变量\",{\"1\":{\"590\":1}}],[\"不支持\",{\"1\":{\"258\":3}}],[\"不支持随机访问\",{\"1\":{\"197\":1}}],[\"不忙碌则将通道分配个进程\",{\"1\":{\"213\":1}}],[\"不忙碌则将控制器分配给进程\",{\"1\":{\"213\":1}}],[\"不忙碌则将设备分配给进程\",{\"1\":{\"213\":1}}],[\"不再同步的副本\",{\"1\":{\"1049\":1}}],[\"不再赘述\",{\"1\":{\"855\":1}}],[\"不再需要经过cpu\",{\"1\":{\"209\":1}}],[\"不再指向原有对象地址\",{\"1\":{\"51\":1}}],[\"不久后该数据很可能再次被访问\",{\"1\":{\"189\":1}}],[\"不方便编程\",{\"1\":{\"213\":1}}],[\"不方便文件拓展\",{\"1\":{\"197\":1}}],[\"不方便实现信息的共享和保护\",{\"1\":{\"188\":1}}],[\"不方便增加新设备\",{\"1\":{\"176\":1}}],[\"不占存储空间\",{\"1\":{\"187\":1}}],[\"不常用的段放在覆盖区\",{\"1\":{\"181\":1}}],[\"不常用的段在需要时调入内存\",{\"1\":{\"181\":1}}],[\"不过使用\",{\"1\":{\"1525\":1}}],[\"不过需要容器这边主动调用\",{\"1\":{\"1252\":1}}],[\"不过\",{\"1\":{\"1222\":1,\"1321\":1,\"1506\":1}}],[\"不过这个前缀不是随便加的\",{\"1\":{\"1207\":1}}],[\"不过根据字符串的格式不同\",{\"1\":{\"1206\":1}}],[\"不过value的类型多种多样\",{\"1\":{\"1204\":1}}],[\"不过该仓库提供的是redisdesktopmanager的源码\",{\"1\":{\"1200\":1}}],[\"不过对于uv统计来说\",{\"1\":{\"1179\":1}}],[\"不过可以把结果存储到一个指定的key\",{\"1\":{\"1170\":1}}],[\"不过调用了\",{\"1\":{\"816\":1}}],[\"不过join\",{\"1\":{\"547\":1}}],[\"不过当索引列的重复值过多\",{\"1\":{\"491\":1}}],[\"不过操作系统会负责检测出死锁的产生\",{\"1\":{\"175\":1}}],[\"不过不推荐\",{\"1\":{\"105\":1}}],[\"不剥夺条件\",{\"1\":{\"175\":1}}],[\"不可重试\",{\"1\":{\"1149\":1}}],[\"不可重复读和幻读的问题\",{\"1\":{\"503\":1}}],[\"不可点击等方式\",{\"1\":{\"1005\":1}}],[\"不可能三角\",{\"1\":{\"637\":1}}],[\"不可能滞留在中间某个环节\",{\"1\":{\"556\":1}}],[\"不可变类\",{\"0\":{\"566\":1}}],[\"不可抢占条件\",{\"1\":{\"551\":1}}],[\"不可以大编号资源的进程逆向申请小编号的资源\",{\"1\":{\"176\":1}}],[\"不可中断\",{\"1\":{\"171\":1}}],[\"不可预知的速度向前推进\",{\"1\":{\"159\":1,\"168\":1}}],[\"不区分任务的紧急程度\",{\"1\":{\"167\":1}}],[\"不公平\",{\"1\":{\"167\":1}}],[\"不透明就是能看见\",{\"1\":{\"163\":1}}],[\"不同\",{\"1\":{\"1499\":1}}],[\"不同互联网公司也有自己内部的实现方案\",{\"1\":{\"997\":1}}],[\"不同数据集的数据经过shuffle\",{\"1\":{\"988\":1}}],[\"不同于\",{\"1\":{\"948\":1}}],[\"不同于第一块副本的不同机架\",{\"1\":{\"900\":1}}],[\"不同点\",{\"1\":{\"892\":1}}],[\"不同占有者组织之间对于namenode是隔离的\",{\"1\":{\"889\":1}}],[\"不同任务分别在不同的线程中执行\",{\"1\":{\"716\":1}}],[\"不同进程使用的虚拟地址彼此隔离\",{\"1\":{\"685\":1}}],[\"不同进程中的线程切换\",{\"1\":{\"163\":1}}],[\"不同i\",{\"1\":{\"679\":1}}],[\"不同在于concurrenthashmap有大数组和小数组\",{\"1\":{\"579\":1}}],[\"不同分区对应着不同的文件夹\",{\"1\":{\"259\":1}}],[\"不同用户对各个文件的访问权限是不一样的\",{\"1\":{\"210\":1}}],[\"不同的浏览器\",{\"1\":{\"1504\":1}}],[\"不同的http\",{\"1\":{\"1504\":1}}],[\"不同的数据库都有自己独立的\",{\"1\":{\"1499\":1}}],[\"不同的版本\",{\"1\":{\"1062\":1}}],[\"不同的链路设备的\",{\"1\":{\"694\":1}}],[\"不同的字符串可能哈希出来的位置相同\",{\"1\":{\"659\":1}}],[\"不同的用户对各个文件有不同的访问权限\",{\"1\":{\"211\":1}}],[\"不同的i\",{\"1\":{\"210\":1}}],[\"不同的装配顺序也可以做出不同的对象\",{\"1\":{\"12\":1}}],[\"不同的构建器\",{\"1\":{\"12\":1}}],[\"不仅仅是sql\",{\"1\":{\"1184\":1}}],[\"不仅有\",{\"1\":{\"756\":1}}],[\"不仅可以利用\",{\"1\":{\"664\":1}}],[\"不仅可以保存文本数据\",{\"1\":{\"663\":1}}],[\"不仅可以保存字符串\",{\"1\":{\"663\":1}}],[\"不仅会为\",{\"1\":{\"663\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"570\":1}}],[\"不仅是进程之间可以并发\",{\"1\":{\"163\":1}}],[\"不仅要生产咖啡还要生产甜点\",{\"1\":{\"39\":1}}],[\"不会匹配到\",{\"1\":{\"1438\":1}}],[\"不会在初始化时收集映射信息\",{\"1\":{\"1430\":1}}],[\"不会走\",{\"1\":{\"1411\":1}}],[\"不会包含局部变量表\",{\"1\":{\"1366\":1}}],[\"不会调用\",{\"1\":{\"1300\":1}}],[\"不会自动销毁\",{\"1\":{\"1290\":1}}],[\"不会自动缓冲数据\",{\"1\":{\"850\":1}}],[\"不会有缺失\",{\"1\":{\"1166\":1}}],[\"不会有碎片问题\",{\"1\":{\"197\":2}}],[\"不会导致数据丢失\",{\"1\":{\"1054\":1}}],[\"不会被传递到外面使用\",{\"1\":{\"934\":1}}],[\"不会被换出内存\",{\"1\":{\"181\":1}}],[\"不会让线程吊死在一个\",{\"1\":{\"867\":1}}],[\"不会使用\",{\"1\":{\"854\":1,\"855\":4}}],[\"不会阻塞\",{\"1\":{\"832\":1}}],[\"不会阻止数据的并发读\",{\"1\":{\"294\":1}}],[\"不会产生冗余数据\",{\"1\":{\"995\":1}}],[\"不会产生内存复制\",{\"1\":{\"779\":1}}],[\"不会产生外部碎片\",{\"1\":{\"188\":1}}],[\"不会抛异常\",{\"1\":{\"756\":1,\"763\":1}}],[\"不会再次相应应用程序并通知此事件\",{\"1\":{\"680\":1}}],[\"不会再转换为其他状态\",{\"1\":{\"538\":1}}],[\"不会随着fd数目的增加使得效率降低\",{\"1\":{\"680\":1}}],[\"不会发生缓冲区溢出\",{\"1\":{\"663\":1}}],[\"不会发生死锁\",{\"1\":{\"213\":1}}],[\"不会保持线程阻塞\",{\"1\":{\"610\":1}}],[\"不会存在后面的指令跑到前面的指令之前来执行\",{\"1\":{\"559\":1}}],[\"不会将读屏障之后的代码排在读屏障之前\",{\"1\":{\"557\":1}}],[\"不会将写屏障之前的代码排在写屏障之后\",{\"1\":{\"557\":1,\"567\":1}}],[\"不会将打断标记设置为true\",{\"1\":{\"536\":1}}],[\"不会统计此列为null值的行\",{\"1\":{\"482\":2}}],[\"不会引起进程切换\",{\"1\":{\"163\":1}}],[\"不会\",{\"1\":{\"161\":1,\"167\":2}}],[\"不能直接根据\",{\"1\":{\"1489\":1}}],[\"不能直接打开\",{\"1\":{\"813\":1}}],[\"不能用\",{\"1\":{\"1480\":1}}],[\"不能用images来查询\",{\"1\":{\"1089\":1}}],[\"不能写死在代理内部\",{\"1\":{\"1310\":1}}],[\"不能采用原始方案来做\",{\"1\":{\"1167\":1}}],[\"不能改变\",{\"1\":{\"1113\":1}}],[\"不能同时指定它们\",{\"1\":{\"875\":1}}],[\"不能太大\",{\"1\":{\"841\":1}}],[\"不能被多个\",{\"1\":{\"841\":1}}],[\"不能被修改且必须有初始值\",{\"1\":{\"595\":1}}],[\"不能被修改的代码称为纯代码或可重入代码\",{\"1\":{\"187\":1}}],[\"不能置之不理\",{\"1\":{\"840\":1}}],[\"不能什么都不做\",{\"1\":{\"835\":1}}],[\"不能一次创建多级目录\",{\"1\":{\"822\":1}}],[\"不能区分成功失败\",{\"1\":{\"756\":1}}],[\"不能在这里善后\",{\"1\":{\"754\":1}}],[\"不能继承\",{\"1\":{\"714\":1}}],[\"不能保存过多的元素\",{\"1\":{\"664\":1}}],[\"不能保存像图片\",{\"1\":{\"662\":1}}],[\"不能保证原子性\",{\"1\":{\"558\":1}}],[\"不能保证高可用\",{\"1\":{\"525\":1}}],[\"不能对缓冲区超过limit的位置进行读写操作\",{\"1\":{\"610\":1}}],[\"不能修改\",{\"1\":{\"566\":1,\"574\":1}}],[\"不能感知到这种从a改为b又改回a的情况\",{\"1\":{\"563\":1}}],[\"不能解决指令交错的问题\",{\"1\":{\"558\":1}}],[\"不能与group\",{\"1\":{\"378\":1}}],[\"不能嵌套调用\",{\"1\":{\"378\":1}}],[\"不能只查询一张表但是又想返回分别属于两张表的字段\",{\"1\":{\"348\":1}}],[\"不能重复下单\",{\"1\":{\"1156\":1,\"1157\":1}}],[\"不能重复\",{\"1\":{\"259\":1,\"1012\":1}}],[\"不能全部装入内存\",{\"1\":{\"189\":1}}],[\"不能由其他进程强行夺走\",{\"1\":{\"175\":1}}],[\"不能传递\",{\"1\":{\"104\":1}}],[\"不能去修改原有的代码\",{\"1\":{\"72\":1}}],[\"不跟\",{\"1\":{\"76\":1}}],[\"不运行此中操作\",{\"1\":{\"69\":1}}],[\"不需要目标对象实例\",{\"1\":{\"1306\":1}}],[\"不需要坐标查询\",{\"1\":{\"1172\":1}}],[\"不需要我们用户再去推送信息\",{\"1\":{\"1166\":1}}],[\"不需要添加路径\",{\"1\":{\"990\":1}}],[\"不需要停机\",{\"1\":{\"892\":1}}],[\"不需要像\",{\"1\":{\"781\":1}}],[\"不需要用\",{\"1\":{\"663\":1}}],[\"不需要产生结果和消费结果的线程一一对应\",{\"1\":{\"548\":1}}],[\"不需要显示使用\",{\"1\":{\"510\":1}}],[\"不需要reducer\",{\"1\":{\"326\":1}}],[\"不需要再单独计算一次了\",{\"1\":{\"307\":1}}],[\"不需要再系统中存储\",{\"1\":{\"201\":1}}],[\"不需要额外起metastore服务\",{\"1\":{\"242\":1}}],[\"不需要返回值\",{\"1\":{\"170\":1}}],[\"不需要切换到核心态\",{\"1\":{\"163\":1}}],[\"不需要切换进程环境\",{\"1\":{\"163\":1}}],[\"不需要记忆复杂的指令\",{\"1\":{\"154\":1}}],[\"不需要写version\",{\"1\":{\"105\":1}}],[\"不需要实例化该类的对象\",{\"1\":{\"64\":1}}],[\"不需要修改其他的类\",{\"1\":{\"39\":1}}],[\"不需要修改工厂类的代码了\",{\"1\":{\"34\":1}}],[\"不属于gof的23种经典设计模式\",{\"1\":{\"25\":1}}],[\"所管理\",{\"1\":{\"1455\":1}}],[\"所对应的\",{\"1\":{\"1177\":1}}],[\"所需要的资源有限\",{\"1\":{\"1501\":1}}],[\"所需要的所有\",{\"1\":{\"1013\":1}}],[\"所需要的依赖以及maven打包插件\",{\"1\":{\"957\":1}}],[\"所需依赖会传递到当前工程\",{\"1\":{\"114\":1,\"115\":1}}],[\"所在组等\",{\"1\":{\"913\":1}}],[\"所在线程\",{\"1\":{\"833\":1}}],[\"所访问的页面的页面序号为\",{\"1\":{\"690\":1}}],[\"所要花费的总时间\",{\"1\":{\"683\":1}}],[\"所组成\",{\"1\":{\"187\":1}}],[\"所谓动态通知\",{\"1\":{\"1350\":1}}],[\"所谓静态通知\",{\"1\":{\"1343\":1}}],[\"所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用\",{\"1\":{\"1002\":1}}],[\"所谓分组就是纯粹的前后两个key比较\",{\"1\":{\"980\":1}}],[\"所谓运行模式是指mapreduce程序是单机运行还是分布式运行\",{\"1\":{\"963\":1}}],[\"所谓加密区域其实就是一个目录\",{\"1\":{\"930\":1}}],[\"所谓加载是指\",{\"1\":{\"283\":1}}],[\"所谓的误差率就是指当发生哈希冲突的时候\",{\"1\":{\"1177\":1}}],[\"所谓的同一个分区指的是数据由同一个reducetask来处理\",{\"1\":{\"973\":1}}],[\"所谓的平衡指的是每个datanode的利用率\",{\"1\":{\"873\":1}}],[\"所谓的\",{\"1\":{\"855\":1}}],[\"所谓扰动函数指的就是hashmap中的hash方法\",{\"1\":{\"605\":1}}],[\"所谓readview\",{\"1\":{\"503\":1}}],[\"所谓窗口聚合函数指的是sum\",{\"1\":{\"360\":1}}],[\"所谓安全序列\",{\"1\":{\"177\":1}}],[\"所谓最短\",{\"1\":{\"167\":1}}],[\"所谓创建进程就是创建pcb\",{\"1\":{\"159\":1}}],[\"所有单例初始化完成后\",{\"1\":{\"1493\":1}}],[\"所有接口当做\",{\"1\":{\"1455\":1}}],[\"所有点赞的人\",{\"1\":{\"1162\":1}}],[\"所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能\",{\"1\":{\"1140\":1}}],[\"所有所有的数据将都分配到一个分区中\",{\"1\":{\"1034\":1}}],[\"所有内容\",{\"1\":{\"777\":1}}],[\"所有\",{\"1\":{\"766\":1}}],[\"所有异常然后设置为\",{\"1\":{\"765\":1}}],[\"所有select负责的socket\",{\"1\":{\"679\":1}}],[\"所有位置均为\",{\"1\":{\"659\":1}}],[\"所有属性设置默认值\",{\"1\":{\"630\":1}}],[\"所有线程都运行完了进行汇总\",{\"1\":{\"592\":1}}],[\"所有线程\",{\"1\":{\"582\":1}}],[\"所有创建的线程都是救急线程\",{\"1\":{\"574\":1}}],[\"所有修改先写入日志\",{\"1\":{\"506\":1}}],[\"所有二级索引都引用主键索引\",{\"1\":{\"489\":1}}],[\"所有关键字查询的路径长度相同\",{\"1\":{\"488\":1}}],[\"所有行求和\",{\"1\":{\"360\":1}}],[\"所有行进行统计\",{\"1\":{\"351\":2}}],[\"所有用户所有访问加起来\",{\"1\":{\"360\":1}}],[\"所有年龄\",{\"1\":{\"351\":1}}],[\"所有函数可以分成udf\",{\"1\":{\"334\":1}}],[\"所有合并都是在后台完成的\",{\"1\":{\"294\":1}}],[\"所有语言操作都是自动提交的\",{\"1\":{\"267\":1,\"296\":1}}],[\"所有淘汰一个页面最多进行四轮扫描\",{\"1\":{\"191\":1}}],[\"所有的拦截器都需要实现handlerinterceptor接口\",{\"1\":{\"1532\":1}}],[\"所有的排名默认都是升序\",{\"1\":{\"1211\":1}}],[\"所有的锁都加锁成功\",{\"1\":{\"1153\":1}}],[\"所有的消费者都属于某个消费者组\",{\"1\":{\"1026\":1}}],[\"所有的字符存储与表示\",{\"1\":{\"482\":1}}],[\"所有的线程管理工作都是由应用程序负责\",{\"1\":{\"163\":1}}],[\"所有的工厂类都需要进行修改\",{\"1\":{\"40\":1}}],[\"所有涉及到子类的功能都有可能产生故障\",{\"1\":{\"73\":1}}],[\"所有代理类也需要实现此方法\",{\"1\":{\"61\":1}}],[\"所有new对象的地方都需要修改一遍\",{\"1\":{\"25\":1}}],[\"所以很多时候我们就用di来替代它\",{\"1\":{\"1500\":1}}],[\"所以很容易知道此值已经存在\",{\"1\":{\"659\":1}}],[\"所以处理异常的职责就又回到了\",{\"1\":{\"1411\":1}}],[\"所以即使不报错\",{\"1\":{\"1229\":1}}],[\"所以操作成功\",{\"1\":{\"1206\":1}}],[\"所以lisi的操作失败\",{\"1\":{\"1206\":1}}],[\"所以只成功删除3个\",{\"1\":{\"1205\":1}}],[\"所以只允许在核心态下执行特权指令\",{\"1\":{\"161\":1}}],[\"所以衡量同一个网站的访问量\",{\"1\":{\"1179\":1}}],[\"所以feed流的分页\",{\"1\":{\"1167\":1}}],[\"所以数据的角标也在变化\",{\"1\":{\"1167\":1}}],[\"所以数据一致\",{\"1\":{\"1126\":1}}],[\"所以等他们上线时\",{\"1\":{\"1166\":1}}],[\"所以等到时间之后自然就释放了\",{\"1\":{\"1152\":1}}],[\"所以才会出现这个问题\",{\"1\":{\"1161\":1}}],[\"所以笔者在这里给大家分析\",{\"1\":{\"1152\":1}}],[\"所以采用分布式锁的情况下\",{\"1\":{\"1140\":1}}],[\"所以利用这么一个类\",{\"1\":{\"1136\":1}}],[\"所以没有问题\",{\"1\":{\"1135\":1}}],[\"所以没有额外的内存消耗\",{\"1\":{\"1126\":1}}],[\"所以像第二种卷\",{\"1\":{\"1133\":1}}],[\"所以他们的id是不能一样的\",{\"1\":{\"1131\":1}}],[\"所以线程3和线程4可以实现互斥\",{\"1\":{\"1138\":1}}],[\"所以线程3无法获得锁\",{\"1\":{\"1126\":1}}],[\"所以线程2无法执行成功\",{\"1\":{\"1135\":1}}],[\"所以线程2\",{\"1\":{\"1135\":1}}],[\"所以线程不会陷入阻塞\",{\"1\":{\"561\":1}}],[\"所以为了适应当下的情况\",{\"1\":{\"1115\":1}}],[\"所以企业会大量运用到缓存技术\",{\"1\":{\"1114\":1}}],[\"所以企业非常重视缓存技术\",{\"1\":{\"1113\":1}}],[\"所以其引用\",{\"1\":{\"1113\":1}}],[\"所以随着类的加载而被加载到内存之中\",{\"1\":{\"1113\":1}}],[\"所以随着fd的增加会造成遍历速度慢的\",{\"1\":{\"680\":1}}],[\"所以咱们后来采用的方案都是基于redis来完成\",{\"1\":{\"1102\":1}}],[\"所以此时其他线程都会失败\",{\"1\":{\"1136\":1}}],[\"所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可\",{\"1\":{\"1110\":1}}],[\"所以此时令牌刷新的动作实际上就不会执行\",{\"1\":{\"1109\":1}}],[\"所以此时\",{\"1\":{\"1102\":1}}],[\"所以nginx是整个项目中重要的一环\",{\"1\":{\"1094\":1}}],[\"所以基本上很少会使用随机策略\",{\"1\":{\"1033\":1}}],[\"所以幂等性只能保证的是在单分区单会话内不重复\",{\"1\":{\"1029\":1}}],[\"所以后端幂等性很重要\",{\"1\":{\"1005\":1}}],[\"所以整个缓冲区有个溢写的比例spill\",{\"1\":{\"979\":1}}],[\"所以整个项目中使用的框架版本需要统一\",{\"1\":{\"107\":1}}],[\"所以理论上最后一个块的split\",{\"1\":{\"976\":1}}],[\"所以永远让split\",{\"1\":{\"976\":1}}],[\"所以和java中的comparable接口合并\",{\"1\":{\"956\":1}}],[\"所以和饿汉式的方式1基本上一样\",{\"1\":{\"66\":1}}],[\"所以是可以任意领取\",{\"1\":{\"1133\":1}}],[\"所以是\",{\"1\":{\"919\":1}}],[\"所以用户感觉起来它一直在读取一个连续的流\",{\"1\":{\"902\":1}}],[\"所以最后要执行\",{\"1\":{\"858\":1}}],[\"所以常被用作讲述标点符号的重要性\",{\"1\":{\"709\":1}}],[\"所以两者都是离散分配内存的方式\",{\"1\":{\"683\":1}}],[\"所以也同样实现了离散分配\",{\"1\":{\"683\":1}}],[\"所以可重入锁他的主要意义是防止死锁\",{\"1\":{\"1149\":1}}],[\"所以可以通过这种方式来做到线程隔离\",{\"1\":{\"1100\":1}}],[\"所以可以通过以下几种方案来解决group\",{\"1\":{\"463\":1}}],[\"所以可存储包含\",{\"1\":{\"663\":1}}],[\"所以复杂度只有\",{\"1\":{\"663\":1}}],[\"所以使用await可以让main线程阻塞\",{\"1\":{\"1132\":1}}],[\"所以使用\",{\"1\":{\"663\":1}}],[\"所以\",{\"1\":{\"662\":1,\"663\":2,\"666\":1,\"679\":1,\"689\":1,\"934\":1,\"1054\":1,\"1501\":2,\"1512\":1}}],[\"所以我们把这种松散结构的数据库\",{\"1\":{\"1182\":1}}],[\"所以我们只是单纯的把这两个值作为一个参考值\",{\"1\":{\"1179\":1}}],[\"所以我们如何解决呢\",{\"1\":{\"1177\":1}}],[\"所以我们可以使用\",{\"1\":{\"1177\":1}}],[\"所以我们可以使用string结构\",{\"1\":{\"1105\":1}}],[\"所以我们可以按照商户类型做分组\",{\"1\":{\"1171\":1}}],[\"所以我们无法根据\",{\"1\":{\"1171\":1}}],[\"所以我们选择将当前方法整体包裹起来\",{\"1\":{\"1137\":1}}],[\"所以我们选择的只是对具体应用最合适的收集器\",{\"1\":{\"638\":1}}],[\"所以我们需要异步程序执行\",{\"1\":{\"1155\":1}}],[\"所以我们需要使用intern\",{\"1\":{\"1137\":1}}],[\"所以我们需要使用悲观锁操作\",{\"1\":{\"1137\":1}}],[\"所以我们需要去控制锁的粒度\",{\"1\":{\"1137\":1}}],[\"所以我们需要增加缓存\",{\"1\":{\"1116\":1}}],[\"所以我们还是需要加锁\",{\"1\":{\"1137\":1}}],[\"所以我们应当使用set或者是sortedset\",{\"1\":{\"1162\":1}}],[\"所以我们应当采用的是课程中\",{\"1\":{\"1155\":1}}],[\"所以我们应当增加一层逻辑\",{\"1\":{\"1137\":1}}],[\"所以我们应当在返回用户信息之前\",{\"1\":{\"1101\":1}}],[\"所以我们的乐观锁需要变一下\",{\"1\":{\"1136\":1}}],[\"所以我们此时需要使用到countdownlatch\",{\"1\":{\"1132\":1}}],[\"所以我们在这个地方存储他的\",{\"1\":{\"1171\":1}}],[\"所以我们在后台生成一个随机串token\",{\"1\":{\"1105\":1}}],[\"所以我们在高并发场景下\",{\"1\":{\"1094\":1}}],[\"所以我们没必让每个线程必须持有锁才能调用该方法\",{\"1\":{\"66\":1}}],[\"所以就需要针对不同的场景\",{\"1\":{\"638\":1}}],[\"所以就需要一个插座转换器\",{\"1\":{\"4\":1}}],[\"所以单例程序中\",{\"1\":{\"636\":1}}],[\"所以能减少系统的停顿时间\",{\"1\":{\"634\":1}}],[\"所以指定一个合适的\",{\"1\":{\"606\":1}}],[\"所以归结于同步模式\",{\"1\":{\"547\":1}}],[\"所以一定要保证主从节点的机器时钟一致性\",{\"1\":{\"530\":1}}],[\"所以redis会对部分数据进行更新\",{\"1\":{\"1119\":1}}],[\"所以redis采用两者结合的方式进行过期数据删除\",{\"1\":{\"520\":1}}],[\"所以redis仍然是并发安全的\",{\"1\":{\"516\":1}}],[\"所以不能对final修饰的类进行代理\",{\"1\":{\"1511\":1}}],[\"所以不能释放锁\",{\"1\":{\"1144\":1}}],[\"所以不能在这里善后\",{\"1\":{\"754\":1}}],[\"所以不过多阐述\",{\"1\":{\"1140\":1}}],[\"所以不会对用户进程产生任何block\",{\"1\":{\"679\":1}}],[\"所以不会出现可重复读\",{\"1\":{\"503\":1}}],[\"所以不需要定义成抽象方法\",{\"1\":{\"585\":1}}],[\"所以不计入等待时间\",{\"1\":{\"166\":1}}],[\"所以无法像myisam一样\",{\"1\":{\"497\":1}}],[\"所以会先在联合索引中通过lastname进行过滤\",{\"1\":{\"495\":1}}],[\"所以任何关键字的查找必须走一条从根节点到叶子节点的路\",{\"1\":{\"488\":1}}],[\"所以字段名称需要慎重考虑\",{\"1\":{\"480\":1}}],[\"所以了解就行\",{\"1\":{\"472\":1}}],[\"所以hadoop中支持的压缩在hive中都可以直接使用\",{\"1\":{\"432\":1}}],[\"所以hive设计时考虑到为了避免各种编码及数据错乱的问题\",{\"1\":{\"427\":1}}],[\"所以并不是总能生效\",{\"1\":{\"420\":1}}],[\"所以遇到多字符或者数据字段中包含了分隔符\",{\"1\":{\"371\":1}}],[\"所以现在没有内置函数和用户定义函数之分\",{\"1\":{\"334\":1}}],[\"所以根据学号\",{\"1\":{\"313\":1}}],[\"所以delta文件中的operation是0\",{\"1\":{\"293\":1}}],[\"所以如果采用以上方案\",{\"1\":{\"1177\":1}}],[\"所以如果传入了参数\",{\"1\":{\"1152\":1}}],[\"所以如果返回是\",{\"1\":{\"1152\":1}}],[\"所以如果通过insert来逐条插入\",{\"1\":{\"286\":1}}],[\"所以如果有接口使用jdk动态代理\",{\"1\":{\"61\":1}}],[\"所以算法性能较差\",{\"1\":{\"191\":1}}],[\"所以对换区空间的管理主要追求换入换出速度\",{\"1\":{\"181\":1}}],[\"所以p2进入阻塞的状态\",{\"1\":{\"178\":1}}],[\"所以中级调度发生的频率比高级调度高\",{\"1\":{\"164\":1}}],[\"所以内核级线程的切换必须要在核心态下完成\",{\"1\":{\"163\":1}}],[\"所以打包方式必须是\",{\"1\":{\"107\":1}}],[\"所以在controller层实体类型的参数前需要加上\",{\"1\":{\"1229\":1}}],[\"所以在笔记中并不会详细的去解释这些lua表达式的含义\",{\"1\":{\"1147\":1}}],[\"所以在每个用户去访问我们的工程时\",{\"1\":{\"1100\":1}}],[\"所以在活跃的socket较少的情况下\",{\"1\":{\"680\":1}}],[\"所以在成员变量为\",{\"1\":{\"663\":1}}],[\"所以在去重的时候也会快很多\",{\"1\":{\"493\":1}}],[\"所以在使用hive时\",{\"1\":{\"457\":1}}],[\"所以在使用hive进行处理分析时\",{\"1\":{\"435\":1}}],[\"所以在此处重点看的方法是带三个参数的方法\",{\"1\":{\"88\":1}}],[\"所以在运\",{\"1\":{\"77\":1}}],[\"所以直接实现\",{\"1\":{\"85\":2}}],[\"所以这样做没有压力\",{\"1\":{\"1166\":1}}],[\"所以这个时候\",{\"1\":{\"1162\":1}}],[\"所以这个地方\",{\"1\":{\"1137\":1}}],[\"所以这个方案他是存在问题的\",{\"1\":{\"1109\":1}}],[\"所以这个案例可以使用抽象工厂模式实现\",{\"1\":{\"39\":1}}],[\"所以这里我们采用高级\",{\"1\":{\"1071\":1}}],[\"所以这种复用又称为\",{\"1\":{\"77\":2}}],[\"所以适合使用迪米特法则\",{\"1\":{\"76\":1}}],[\"所以许多日常事务由经纪人负责处理\",{\"1\":{\"76\":1}}],[\"所以它在整个模型中会多次使用\",{\"1\":{\"979\":1}}],[\"所以它们通常更易于管理和维护\",{\"1\":{\"223\":1}}],[\"所以它是满足开闭原则的\",{\"1\":{\"72\":1}}],[\"所以它通常在以下场合使用\",{\"1\":{\"16\":1}}],[\"所以返回的是同一个对象\",{\"1\":{\"69\":1}}],[\"所以需要在一定条件下将缓冲区中的数据临时写入磁盘\",{\"1\":{\"979\":1}}],[\"所以需要安装hadoop的native包libhadoop\",{\"1\":{\"872\":1}}],[\"所以需要两圈\",{\"1\":{\"205\":1}}],[\"所以需要这样的\",{\"1\":{\"104\":1}}],[\"所以需要引入jar包的坐标\",{\"1\":{\"60\":1}}],[\"所以需要实现selltickets接口\",{\"1\":{\"58\":1,\"59\":1}}],[\"所以说\",{\"1\":{\"25\":1,\"667\":1,\"679\":1}}],[\"所以应用相对较少些\",{\"1\":{\"4\":1}}],[\"就为\",{\"1\":{\"1438\":1}}],[\"就问恶心不\",{\"1\":{\"1411\":1}}],[\"就调用目标方法\",{\"1\":{\"1346\":1}}],[\"就把通知的增强功能\",{\"1\":{\"1298\":1}}],[\"就把签到结果向右移动一位\",{\"1\":{\"1176\":1}}],[\"就用到了工厂设计模式\",{\"1\":{\"1215\":1}}],[\"就在我们之前解压的redis安装包下\",{\"1\":{\"1196\":1}}],[\"就表明说明这一天已经签到了\",{\"1\":{\"1175\":1}}],[\"就拿到了5\",{\"1\":{\"1167\":1}}],[\"就拿到了这把锁\",{\"1\":{\"1143\":1}}],[\"就保证了加锁的可靠性\",{\"1\":{\"1153\":1}}],[\"就保留原来的值\",{\"1\":{\"409\":1}}],[\"就触发了\",{\"1\":{\"1152\":1}}],[\"就好像是网吧上网\",{\"1\":{\"1147\":1}}],[\"就好比截取了原始\",{\"1\":{\"777\":1}}],[\"就意味着我们是一定可以下单完成的\",{\"1\":{\"1155\":1}}],[\"就意味着没有人在中间修改过库存\",{\"1\":{\"1136\":1}}],[\"就意味着需要操作系统介入\",{\"1\":{\"157\":1}}],[\"就得限制数量\",{\"1\":{\"1133\":1}}],[\"就得配置为\",{\"1\":{\"1043\":1}}],[\"就得知道接着从哪条指令开始继续执行\",{\"1\":{\"625\":1}}],[\"就有可能会在partition中保存多条一模一样的消息\",{\"1\":{\"1027\":1}}],[\"就有两阶段策略\",{\"1\":{\"843\":1}}],[\"就启动内存到磁盘的merge\",{\"1\":{\"980\":1}}],[\"就处理该目录所有的文件\",{\"1\":{\"962\":1}}],[\"就对fsdatainputstream调用close\",{\"1\":{\"902\":1}}],[\"就取消\",{\"1\":{\"843\":1}}],[\"就能统计出来他连续签到的次数了\",{\"1\":{\"1176\":1}}],[\"就能拿到所有的数据了\",{\"1\":{\"1176\":1}}],[\"就能回到\",{\"1\":{\"804\":1}}],[\"就能大幅提升效率\",{\"1\":{\"493\":1}}],[\"就要使用与之对应的事务管理器\",{\"1\":{\"1515\":1}}],[\"就要负责到底\",{\"1\":{\"787\":1}}],[\"就要停止操作\",{\"1\":{\"662\":1}}],[\"就没用了\",{\"1\":{\"775\":1}}],[\"就没有这么高效了\",{\"1\":{\"665\":1}}],[\"就没有内存分区可以用了\",{\"1\":{\"183\":1}}],[\"就失去了传递性\",{\"1\":{\"775\":1}}],[\"就属于废弃部分了\",{\"1\":{\"774\":1}}],[\"就一条消息\",{\"1\":{\"743\":1}}],[\"就一定不会发生死锁\",{\"1\":{\"177\":1}}],[\"就这么一直耗着\",{\"1\":{\"707\":1}}],[\"就成功返回\",{\"1\":{\"623\":1}}],[\"就判断该元素与要存入的hash以及key是否相同\",{\"1\":{\"605\":1}}],[\"就闲下来了\",{\"1\":{\"576\":1}}],[\"就以\",{\"1\":{\"566\":1}}],[\"就以二级分区表为例\",{\"1\":{\"285\":1}}],[\"就算是堆内存\",{\"1\":{\"770\":1}}],[\"就算改了也没关系\",{\"1\":{\"561\":1}}],[\"就算保证其他线程的可见性\",{\"1\":{\"560\":1}}],[\"就获得了锁\",{\"1\":{\"542\":1}}],[\"就相当于main线程运行了一个普通的run方法\",{\"1\":{\"532\":1}}],[\"就代表存在死锁\",{\"1\":{\"513\":1}}],[\"就需要\",{\"1\":{\"493\":1}}],[\"就需要再定义新的类\",{\"1\":{\"77\":1}}],[\"就必须以orc格式存储数据\",{\"1\":{\"438\":1}}],[\"就必须在需要的地方明确配置依赖才可以\",{\"1\":{\"104\":1}}],[\"就像自行车\",{\"1\":{\"1113\":1}}],[\"就像删除了索引\",{\"1\":{\"883\":1}}],[\"就像多米诺牌的效应一样\",{\"1\":{\"666\":1}}],[\"就像runnable\",{\"1\":{\"575\":1}}],[\"就像真实表的列一样\",{\"1\":{\"316\":1}}],[\"就像将相同大小的作业本摞起来\",{\"1\":{\"137\":1}}],[\"就只有一个这样的文件\",{\"1\":{\"293\":1}}],[\"就选择该页换出\",{\"1\":{\"191\":1}}],[\"就可能存在哈希冲突\",{\"1\":{\"1123\":1}}],[\"就可能会导致partition的leader分布不均匀\",{\"1\":{\"1050\":1}}],[\"就可能会撑爆内存\",{\"1\":{\"979\":1}}],[\"就可能会产生fail\",{\"1\":{\"602\":1}}],[\"就可能发生死锁\",{\"1\":{\"177\":1}}],[\"就可以像使用普通的bean一样\",{\"1\":{\"1525\":1}}],[\"就可以完成依赖框架的自动配置\",{\"1\":{\"1524\":1}}],[\"就可以在请求到达时\",{\"1\":{\"1355\":1}}],[\"就可以再联动调用目标方法\",{\"1\":{\"1310\":1}}],[\"就可以利用\",{\"1\":{\"1267\":1}}],[\"就可以通过工厂来获得\",{\"1\":{\"1216\":1}}],[\"就可以执行static的操作完成对\",{\"1\":{\"1215\":1}}],[\"就可以获得当前月的签到总天数了\",{\"1\":{\"1176\":1}}],[\"就可以直接锁定使用sortedset啦\",{\"1\":{\"1162\":1}}],[\"就可以避免session共享的问题了\",{\"1\":{\"1102\":1}}],[\"就可以实现滚动分页了\",{\"1\":{\"1167\":1}}],[\"就可以实现session的共享了\",{\"1\":{\"1102\":1}}],[\"就可以实现bucket与bucket的join\",{\"1\":{\"418\":1}}],[\"就可以从\",{\"1\":{\"1052\":1}}],[\"就可以找到集群中数据分布倾斜的节点和机器上数据分步倾斜的磁盘\",{\"1\":{\"874\":1}}],[\"就可以方便获取消息大小\",{\"1\":{\"840\":1}}],[\"就可以监控多个\",{\"1\":{\"829\":1}}],[\"就可以安全地在多线程下被共享\",{\"1\":{\"714\":1}}],[\"就可以由程序内部判断缓冲区大小是否足够用\",{\"1\":{\"663\":1}}],[\"就可以使用json函数来实现处理\",{\"1\":{\"395\":1}}],[\"就可以解决分隔符问题\",{\"1\":{\"374\":1}}],[\"就可以有多个客户端同时连接\",{\"1\":{\"240\":1}}],[\"就可以让程序开始执行\",{\"1\":{\"189\":1}}],[\"就可以暂停换出\",{\"1\":{\"181\":1}}],[\"就说明内存紧张\",{\"1\":{\"181\":1}}],[\"就不用再去临时拉取了\",{\"1\":{\"1166\":1}}],[\"就不用进行页面置换\",{\"1\":{\"191\":1}}],[\"就不再阻塞\",{\"1\":{\"1132\":1}}],[\"就不会被接收方弄错意思了\",{\"1\":{\"709\":1}}],[\"就不会被其他线程所打断\",{\"1\":{\"556\":1}}],[\"就不需要执行i\",{\"1\":{\"191\":1}}],[\"就不能装入该作业\",{\"1\":{\"179\":1}}],[\"就不允许写\",{\"1\":{\"162\":1}}],[\"就不允许读\",{\"1\":{\"162\":1}}],[\"就称为row\",{\"1\":{\"437\":1}}],[\"就称为饿死\",{\"1\":{\"167\":1}}],[\"就称这个图是可完全简化的\",{\"1\":{\"178\":1}}],[\"就绪状态有机会被任务调度器调用\",{\"1\":{\"533\":1}}],[\"就绪状态\",{\"1\":{\"533\":1,\"538\":1}}],[\"就绪队列改变时就需要调度\",{\"1\":{\"167\":1}}],[\"就绪态\",{\"1\":{\"160\":1}}],[\"就从管道中被抛弃\",{\"1\":{\"162\":1}}],[\"就是根据一些特定条件来控制实例化的行为\",{\"1\":{\"1525\":1}}],[\"就是不借助默认的序列化器\",{\"1\":{\"1223\":1}}],[\"就是修改\",{\"1\":{\"1206\":1}}],[\"就是误差率\",{\"1\":{\"1177\":1}}],[\"就是连续签到天数\",{\"1\":{\"1176\":1}}],[\"就是小时候\",{\"1\":{\"1174\":1}}],[\"就是一条记录\",{\"1\":{\"1174\":1}}],[\"就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了\",{\"1\":{\"1126\":1}}],[\"就是一个简单的key\",{\"1\":{\"1105\":1}}],[\"就是一个broker上存在一个topic下不同partition的leader\",{\"1\":{\"1050\":1}}],[\"就是一个创建新进程的系统调用\",{\"1\":{\"676\":1}}],[\"就是一个指令序列\",{\"1\":{\"159\":1}}],[\"就是在\",{\"1\":{\"1171\":1}}],[\"就是在有竞争时\",{\"1\":{\"564\":1}}],[\"就是我们在保存完探店笔记后\",{\"1\":{\"1167\":1}}],[\"就是6\",{\"1\":{\"1167\":1}}],[\"就是咱们的sortedset\",{\"1\":{\"1162\":1}}],[\"就是当前线程标示\",{\"1\":{\"1146\":1}}],[\"就是当一个类构造器需要传入很多参数时\",{\"1\":{\"17\":1}}],[\"就是锁的key\",{\"1\":{\"1146\":1}}],[\"就是cas\",{\"1\":{\"1135\":1}}],[\"就是数据交换的缓冲区\",{\"1\":{\"1113\":1}}],[\"就是数据存放在内存中的实际位置\",{\"1\":{\"179\":1}}],[\"就是说虽然每个tomcat上都有不同的session\",{\"1\":{\"1102\":1}}],[\"就是以字符串方式发送\",{\"1\":{\"1023\":1}}],[\"就是请求方调用了你的服务\",{\"1\":{\"1003\":1}}],[\"就是非法数据\",{\"1\":{\"986\":1}}],[\"就是将对象的控制权交由spring框架来管理\",{\"1\":{\"1500\":1}}],[\"就是将来事件发生后\",{\"1\":{\"840\":1}}],[\"就是将某些进程挂起\",{\"1\":{\"181\":1}}],[\"就是流水线上的各道工序\",{\"1\":{\"766\":1}}],[\"就是\",{\"1\":{\"766\":1,\"1170\":1,\"1525\":1}}],[\"就是上面的\",{\"1\":{\"761\":1}}],[\"就是通过这样的机制\",{\"1\":{\"719\":1}}],[\"就是通过字符数组中的每一个字符\",{\"1\":{\"662\":1}}],[\"就是尽可能地保持压缩列表节省内存的优势\",{\"1\":{\"667\":1}}],[\"就是它被设计成一种内存紧凑型的数据结构\",{\"1\":{\"664\":1}}],[\"就是因为加载的是rt\",{\"1\":{\"624\":1}}],[\"就是页框号\",{\"1\":{\"184\":1}}],[\"就是内部碎片\",{\"1\":{\"182\":1}}],[\"就是为用户进程分配的必须是一个连续的内存空间\",{\"1\":{\"182\":1}}],[\"就是决定将哪个处于挂起状态的进程重新调入内存\",{\"1\":{\"181\":1}}],[\"就是指系统按照这种序列分配资源\",{\"1\":{\"177\":1}}],[\"就是服务时间最短\",{\"1\":{\"167\":1}}],[\"就是撤销进程实体中的pcb\",{\"1\":{\"159\":1}}],[\"就是让cpu能够识别\",{\"1\":{\"156\":1}}],[\"就是靠artifactid来区分的\",{\"1\":{\"98\":1}}],[\"就返回这个方法的值\",{\"1\":{\"69\":1}}],[\"就会写很多分数据到粉丝那边去\",{\"1\":{\"1166\":1}}],[\"就会去从对列中去拿信息\",{\"1\":{\"1157\":1}}],[\"就会\",{\"1\":{\"1151\":1}}],[\"就会出现死锁问题\",{\"1\":{\"1149\":1}}],[\"就会生成订单并保存到tb\",{\"1\":{\"1131\":1}}],[\"就会只保留最新的一个版本\",{\"1\":{\"1056\":1}}],[\"就会产生类似多线程数据安全问题\",{\"1\":{\"1120\":1}}],[\"就会产生数据积压\",{\"1\":{\"1055\":1}}],[\"就会产生将stu1对象中name属性值改为\",{\"1\":{\"54\":1}}],[\"就会造成消息在partition中一直存在得不到消费\",{\"1\":{\"1055\":1}}],[\"就会造成半包\",{\"1\":{\"694\":1}}],[\"就会发现epoll的效率大大高于select\",{\"1\":{\"680\":1}}],[\"就会发生缓冲区溢出将可能会造成程序运行终止\",{\"1\":{\"662\":1}}],[\"就会直接使用\",{\"1\":{\"663\":1}}],[\"就会自动将\",{\"1\":{\"663\":1}}],[\"就会自动将json文件中的每一列进行解析\",{\"1\":{\"397\":1}}],[\"就会导致空指针异常\",{\"1\":{\"837\":1}}],[\"就会导致压缩列表占用的内存空间要多次重新分配\",{\"1\":{\"667\":1}}],[\"就会导致缓冲区溢出\",{\"1\":{\"662\":1}}],[\"就会导致数据的丢失\",{\"1\":{\"506\":1}}],[\"就会停止遍历\",{\"1\":{\"662\":1}}],[\"就会使用到selector\",{\"1\":{\"610\":1}}],[\"就会重新散列到其他位置\",{\"1\":{\"596\":1}}],[\"就会进入entrylist\",{\"1\":{\"541\":1}}],[\"就会将数据分散在不同的partition中存储\",{\"1\":{\"1035\":1}}],[\"就会将相关的\",{\"1\":{\"837\":1}}],[\"就会将monitor的所有者owner置为thread\",{\"1\":{\"541\":1}}],[\"就会将产生数据倾斜的数据单独使用map\",{\"1\":{\"470\":1}}],[\"就会开始大量清理过期key\",{\"1\":{\"530\":1}}],[\"就会在更大一级的空间加上意向排他锁\",{\"1\":{\"510\":1}}],[\"就会在更大一级的空间加上意向共享锁\",{\"1\":{\"510\":1}}],[\"就会释放\",{\"1\":{\"445\":1}}],[\"就会固定搭配lateral\",{\"1\":{\"349\":1}}],[\"就会仅访问符合条件的分区\",{\"1\":{\"305\":1}}],[\"就会一直驻留在内存中\",{\"1\":{\"189\":1}}],[\"就会饥饿\",{\"1\":{\"167\":1}}],[\"就会对整个继承体系造成破坏\",{\"1\":{\"73\":1}}],[\"就会对该对象耦合严重\",{\"1\":{\"25\":1}}],[\"就变成此对象的客户\",{\"1\":{\"28\":1}}],[\"ls\",{\"1\":{\"1210\":5}}],[\"lssnapshottabledir\",{\"1\":{\"914\":1}}],[\"l3级的缓存\",{\"1\":{\"1115\":1}}],[\"l2\",{\"1\":{\"1115\":1}}],[\"lz4\",{\"1\":{\"876\":1}}],[\"l加速库\",{\"0\":{\"876\":1}}],[\"l代表英特尔智能存储加速库\",{\"1\":{\"875\":1}}],[\"ld�\",{\"1\":{\"839\":1}}],[\"lte\",{\"1\":{\"1081\":1}}],[\"ltv\",{\"1\":{\"840\":1}}],[\"lt模式\",{\"1\":{\"680\":1}}],[\"lt模式是默认模式\",{\"1\":{\"680\":1}}],[\"lt和et的区别如下\",{\"1\":{\"680\":1}}],[\"lt\",{\"1\":{\"680\":1}}],[\"ltrim\",{\"1\":{\"336\":3}}],[\"lucy\",{\"1\":{\"1208\":4}}],[\"lua能保证他不能删除他的锁\",{\"1\":{\"1147\":1}}],[\"lua脚本本身并不需要大家花费太多时间去研究\",{\"1\":{\"1147\":1}}],[\"lua脚本解决多条命令原子性问题\",{\"0\":{\"1146\":1}}],[\"lua\",{\"1\":{\"1146\":2,\"1147\":2,\"1149\":1,\"1151\":2,\"1155\":1,\"1156\":4,\"1157\":1}}],[\"lua是一种编程语言\",{\"1\":{\"1146\":1}}],[\"lu\",{\"1\":{\"663\":2}}],[\"l\",{\"1\":{\"645\":5,\"669\":1,\"692\":10,\"693\":14,\"697\":36,\"698\":31,\"699\":36,\"748\":36,\"753\":2,\"875\":2,\"876\":9}}],[\"lfu可能更好点\",{\"1\":{\"522\":1}}],[\"lfu\",{\"1\":{\"521\":1,\"522\":2,\"690\":1}}],[\"ll\",{\"1\":{\"876\":1}}],[\"llen等\",{\"1\":{\"515\":1}}],[\"llap更新\",{\"0\":{\"473\":1}}],[\"lrange\",{\"1\":{\"515\":1,\"1209\":3}}],[\"lru置换算法是选择最近最久未使用的页面予以淘汰\",{\"1\":{\"690\":1}}],[\"lru或者allkeys\",{\"1\":{\"521\":1}}],[\"lru\",{\"1\":{\"191\":2,\"522\":2,\"690\":1}}],[\"lpop和rpop\",{\"1\":{\"1209\":1}}],[\"lpop\",{\"1\":{\"515\":1,\"1209\":2}}],[\"lpush和rpush\",{\"1\":{\"1209\":1}}],[\"lpush\",{\"1\":{\"515\":1,\"1209\":2}}],[\"lpad\",{\"1\":{\"336\":4}}],[\"lv\",{\"1\":{\"391\":2}}],[\"lcase\",{\"1\":{\"336\":3}}],[\"lifecyclebean\",{\"1\":{\"1505\":6}}],[\"lifecycleexception\",{\"1\":{\"1449\":1}}],[\"lilei\",{\"1\":{\"1208\":5}}],[\"libs\",{\"1\":{\"1013\":1}}],[\"libsnappy\",{\"1\":{\"876\":1}}],[\"libcrypto\",{\"1\":{\"876\":1}}],[\"libbz2\",{\"1\":{\"876\":1}}],[\"libz\",{\"1\":{\"876\":1}}],[\"libhadoop\",{\"1\":{\"876\":1}}],[\"libraryproperties\",{\"1\":{\"1525\":3}}],[\"library\",{\"1\":{\"876\":1,\"1525\":2}}],[\"libisal\",{\"1\":{\"876\":4}}],[\"lib64\",{\"1\":{\"876\":7}}],[\"libdir=\",{\"1\":{\"876\":1}}],[\"lib\",{\"1\":{\"872\":2,\"876\":2}}],[\"little\",{\"1\":{\"772\":1}}],[\"lisi\",{\"1\":{\"737\":1,\"748\":6,\"1073\":1,\"1206\":3,\"1210\":5}}],[\"list的常见命令有\",{\"1\":{\"1209\":1}}],[\"list命令\",{\"0\":{\"1209\":1}}],[\"list=xdn10\",{\"1\":{\"1046\":1}}],[\"list=localhost\",{\"1\":{\"1046\":1}}],[\"listcodecs\",{\"1\":{\"875\":1}}],[\"listpolicies\",{\"1\":{\"875\":1}}],[\"listpack\",{\"1\":{\"667\":1}}],[\"listener\",{\"1\":{\"1447\":1}}],[\"listeners=plaintext\",{\"1\":{\"1018\":1}}],[\"listeners\",{\"1\":{\"1018\":1}}],[\"listen\",{\"1\":{\"726\":1}}],[\"list删除元素\",{\"1\":{\"602\":1}}],[\"list删除元素问题\",{\"0\":{\"602\":1}}],[\"list移除元素\",{\"1\":{\"602\":1}}],[\"list<teacher>\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"list<book>\",{\"1\":{\"1525\":1}}],[\"list<beanpostprocessor>\",{\"1\":{\"1257\":1}}],[\"list<blog>\",{\"1\":{\"1161\":1,\"1165\":1,\"1168\":1}}],[\"list<user>\",{\"1\":{\"1234\":1}}],[\"list<userdto>\",{\"1\":{\"1162\":1,\"1165\":1}}],[\"list<georesult<redisgeocommands\",{\"1\":{\"1172\":1}}],[\"list<redisgeocommands\",{\"1\":{\"1171\":1}}],[\"list<\",{\"1\":{\"1168\":1}}],[\"list<follow>\",{\"1\":{\"1167\":1}}],[\"list<long>\",{\"1\":{\"1162\":1,\"1165\":1,\"1168\":1,\"1172\":1,\"1176\":1}}],[\"list<product>\",{\"1\":{\"1089\":1}}],[\"list<shop>>\",{\"1\":{\"1171\":2}}],[\"list<shop>\",{\"1\":{\"1171\":2,\"1172\":1}}],[\"list<socketchannel>\",{\"1\":{\"826\":1,\"827\":1}}],[\"list<string>\",{\"1\":{\"43\":1,\"617\":1,\"621\":1,\"988\":2}}],[\"list<object>\",{\"1\":{\"713\":1,\"714\":2,\"723\":2}}],[\"list<observer>\",{\"1\":{\"47\":1}}],[\"list<channel>\",{\"1\":{\"701\":1,\"704\":2}}],[\"list<character>\",{\"1\":{\"617\":1}}],[\"list<integer>\",{\"1\":{\"620\":1}}],[\"list<employee>>\",{\"1\":{\"621\":1}}],[\"list<employee>\",{\"1\":{\"615\":1}}],[\"list\",{\"1\":{\"43\":5,\"300\":5,\"383\":1,\"385\":1,\"515\":1,\"617\":6,\"620\":2,\"658\":1,\"664\":1,\"925\":1,\"1012\":1,\"1015\":1,\"1016\":1,\"1162\":1,\"1165\":1,\"1167\":1,\"1168\":2,\"1171\":3,\"1172\":6,\"1177\":9,\"1205\":1,\"1429\":2,\"1432\":2}}],[\"link\",{\"1\":{\"968\":1}}],[\"linkedhashset用于保证元素的插入和取出满足fifo场景\",{\"1\":{\"604\":1}}],[\"linkedhashset底层采用的是链表和哈希表\",{\"1\":{\"604\":1}}],[\"linkedhashset和treeset都是set接口的实现类\",{\"1\":{\"604\":1}}],[\"linkedhashset和treeset三者的异同\",{\"0\":{\"604\":1}}],[\"linkedlist采用的是双向链表\",{\"1\":{\"600\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"574\":2}}],[\"linkedblockingqueue\",{\"1\":{\"572\":1}}],[\"linode指索引节点\",{\"1\":{\"913\":1}}],[\"linux\",{\"1\":{\"726\":1,\"833\":1,\"855\":2,\"856\":1,\"924\":1,\"1440\":1}}],[\"linux下的asynchronous\",{\"1\":{\"679\":1}}],[\"linux系统产生了下面五种网络模式的方案\",{\"1\":{\"679\":1}}],[\"linux这样的操作系统\",{\"1\":{\"677\":1}}],[\"linebasedframedecoder\",{\"1\":{\"698\":1}}],[\"lines\",{\"1\":{\"252\":1,\"290\":1}}],[\"line\",{\"1\":{\"221\":2,\"232\":1,\"373\":2,\"710\":13,\"754\":3,\"775\":1,\"794\":3,\"958\":2,\"983\":2,\"990\":3}}],[\"likeblog\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"liked\",{\"1\":{\"1161\":9,\"1162\":7}}],[\"likes\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"like以通配符开头\",{\"1\":{\"505\":1}}],[\"like比较\",{\"1\":{\"330\":1}}],[\"like\",{\"1\":{\"318\":1,\"330\":6,\"495\":2,\"1230\":2,\"1234\":1,\"1235\":2}}],[\"limit\",{\"0\":{\"309\":1},\"1\":{\"271\":3,\"290\":1,\"300\":1,\"309\":1,\"315\":2,\"317\":1,\"340\":2,\"367\":2,\"481\":1,\"610\":1,\"616\":2,\"798\":3,\"799\":7,\"809\":4,\"840\":3,\"1168\":1,\"1172\":1}}],[\"lework\",{\"1\":{\"1200\":1}}],[\"less\",{\"1\":{\"799\":1}}],[\"level\",{\"1\":{\"480\":1,\"680\":2,\"1070\":1,\"1088\":1}}],[\"level3\",{\"1\":{\"480\":1}}],[\"leviopku\",{\"1\":{\"145\":1}}],[\"leasetime\",{\"1\":{\"1152\":5}}],[\"least\",{\"1\":{\"522\":4,\"579\":1,\"1053\":1,\"1054\":1}}],[\"leave\",{\"1\":{\"870\":1}}],[\"leak\",{\"1\":{\"740\":1}}],[\"leader是负责读的\",{\"1\":{\"1051\":1}}],[\"leader是负责写的\",{\"1\":{\"1051\":1}}],[\"leader是通过isr来进行快速选举\",{\"1\":{\"1050\":1}}],[\"leader的负载均衡\",{\"1\":{\"1050\":1}}],[\"leader选举\",{\"0\":{\"1050\":1}}],[\"leader职责\",{\"1\":{\"1048\":1}}],[\"leader和follower\",{\"0\":{\"1048\":1}}],[\"leader\",{\"1\":{\"1026\":7,\"1048\":1,\"1050\":2}}],[\"lead\",{\"1\":{\"365\":5,\"399\":1,\"400\":3}}],[\"learning\",{\"1\":{\"125\":1}}],[\"left\",{\"0\":{\"321\":1,\"324\":1},\"1\":{\"321\":4,\"324\":3,\"409\":1,\"481\":1,\"493\":1,\"579\":1,\"669\":6,\"673\":2,\"820\":13,\"1230\":1}}],[\"len小的二级索引进行扫描\",{\"1\":{\"497\":1}}],[\"len\",{\"1\":{\"88\":6,\"336\":2,\"663\":11,\"669\":2,\"748\":1,\"796\":3}}],[\"lengthfieldbasedframedecoder\",{\"1\":{\"699\":1,\"713\":1,\"714\":1,\"723\":1}}],[\"length\",{\"1\":{\"9\":2,\"88\":2,\"336\":3,\"344\":1,\"482\":2,\"566\":2,\"579\":2,\"668\":6,\"673\":3,\"699\":3,\"711\":2,\"713\":5,\"714\":5,\"723\":6,\"768\":3,\"799\":17,\"840\":4,\"846\":2,\"854\":1,\"855\":1,\"972\":2,\"974\":1,\"986\":1}}],[\"lettuce\",{\"1\":{\"1220\":1}}],[\"lettuce和jedis\",{\"1\":{\"1217\":1}}],[\"lettuce<\",{\"1\":{\"1172\":2}}],[\"let\",{\"1\":{\"70\":1}}],[\"low\",{\"1\":{\"867\":1}}],[\"lowbit\",{\"1\":{\"673\":3}}],[\"lower\",{\"1\":{\"336\":3}}],[\"longitude\",{\"1\":{\"1170\":1}}],[\"longvalue\",{\"1\":{\"1168\":1}}],[\"long>\",{\"1\":{\"1089\":1}}],[\"longbuffer\",{\"1\":{\"610\":1,\"861\":1}}],[\"long这四种包装类默认创建了数值\",{\"1\":{\"598\":1}}],[\"long\",{\"1\":{\"564\":1,\"572\":1,\"579\":4,\"590\":5,\"716\":1,\"741\":2,\"742\":4,\"772\":2,\"799\":2,\"817\":2,\"820\":4,\"823\":2,\"832\":1,\"956\":1,\"960\":1,\"972\":8,\"974\":4,\"985\":4,\"986\":2,\"998\":1,\"999\":22,\"1024\":1,\"1025\":1,\"1089\":1,\"1116\":1,\"1122\":2,\"1124\":1,\"1127\":1,\"1128\":3,\"1129\":6,\"1132\":8,\"1134\":3,\"1137\":10,\"1142\":5,\"1144\":1,\"1147\":1,\"1150\":2,\"1152\":5,\"1156\":5,\"1157\":7,\"1160\":1,\"1161\":5,\"1162\":6,\"1164\":5,\"1165\":7,\"1167\":1,\"1168\":7,\"1171\":1,\"1172\":1,\"1175\":1,\"1176\":2,\"1180\":1,\"1230\":1,\"1321\":3,\"1525\":1,\"1531\":1}}],[\"longaccumulator\",{\"1\":{\"562\":1}}],[\"longadder来进行优化\",{\"1\":{\"1136\":1}}],[\"longadder原理\",{\"0\":{\"564\":1}}],[\"longadder\",{\"1\":{\"562\":1,\"1136\":1}}],[\"longwritable>\",{\"1\":{\"958\":2,\"960\":2,\"983\":1}}],[\"longwritable\",{\"1\":{\"373\":1,\"956\":1,\"958\":3,\"959\":2,\"960\":5,\"962\":4,\"972\":1,\"973\":1,\"974\":1,\"983\":1,\"985\":4,\"986\":1,\"988\":2,\"990\":1}}],[\"lockkey\",{\"1\":{\"1128\":3,\"1129\":6}}],[\"locksupport\",{\"1\":{\"554\":2,\"555\":4}}],[\"locks\",{\"1\":{\"511\":5}}],[\"lock\",{\"1\":{\"508\":2,\"541\":2,\"554\":13,\"555\":10,\"579\":1,\"590\":12,\"737\":2,\"1127\":3,\"1128\":2,\"1129\":3,\"1141\":3,\"1142\":4,\"1149\":1,\"1150\":8,\"1151\":1,\"1152\":5,\"1157\":2,\"1212\":1}}],[\"lockmgr\",{\"1\":{\"268\":1,\"276\":1,\"296\":1,\"297\":1,\"298\":1}}],[\"locations\",{\"1\":{\"1171\":3}}],[\"location>\",{\"1\":{\"255\":1}}],[\"location\",{\"1\":{\"255\":1,\"278\":1,\"279\":2,\"280\":5,\"1525\":2}}],[\"locale\",{\"1\":{\"1244\":3}}],[\"localdatetime\",{\"1\":{\"1128\":4,\"1129\":3,\"1132\":2,\"1134\":2,\"1137\":2,\"1142\":2,\"1150\":2,\"1175\":2,\"1176\":2}}],[\"local=\",{\"1\":{\"836\":2}}],[\"localread\",{\"1\":{\"743\":5}}],[\"localrepository>\",{\"1\":{\"92\":2}}],[\"localrepository\",{\"1\":{\"92\":1}}],[\"localaddress\",{\"1\":{\"725\":1,\"740\":12}}],[\"localhost\",{\"1\":{\"696\":1,\"702\":1,\"710\":1,\"726\":1,\"733\":1,\"735\":1,\"737\":1,\"748\":1,\"754\":1,\"795\":1,\"826\":1,\"834\":1,\"839\":1,\"840\":1,\"843\":1,\"848\":1,\"985\":1,\"986\":1,\"1012\":1,\"1015\":2,\"1016\":1,\"1017\":1,\"1020\":1,\"1046\":1,\"1071\":1,\"1088\":1,\"1236\":2,\"1292\":1,\"1438\":1,\"1447\":1}}],[\"local\",{\"1\":{\"92\":2,\"243\":1,\"261\":7,\"262\":3,\"280\":1,\"283\":2,\"285\":1,\"287\":1,\"290\":4,\"315\":2,\"316\":2,\"317\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"444\":3,\"963\":1,\"1146\":1,\"1151\":1,\"1156\":5,\"1193\":2,\"1196\":2,\"1197\":2}}],[\"lookup\",{\"1\":{\"799\":5,\"1219\":1}}],[\"lookupexception\",{\"1\":{\"69\":1}}],[\"look调度算法\",{\"1\":{\"204\":2}}],[\"logfile\",{\"1\":{\"1196\":1}}],[\"log数据文件\",{\"1\":{\"1052\":1}}],[\"log=$\",{\"1\":{\"936\":1}}],[\"log编辑日志\",{\"1\":{\"905\":1}}],[\"log到至少半数的jn中\",{\"1\":{\"886\":1}}],[\"logs\",{\"1\":{\"872\":1,\"936\":1,\"1013\":1}}],[\"loglevel\",{\"1\":{\"692\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"711\":1,\"733\":2,\"735\":1,\"737\":1,\"748\":1,\"754\":1}}],[\"log中只包含真正需要写入的部分\",{\"1\":{\"506\":1}}],[\"log中的数据\",{\"1\":{\"506\":1}}],[\"log中的信息将数据回滚到修改之前的样子\",{\"1\":{\"506\":1}}],[\"log是追加操作\",{\"1\":{\"506\":1}}],[\"log也需要在事务提交时将日志写入磁盘\",{\"1\":{\"506\":1}}],[\"log也会指向更早版本的undo\",{\"1\":{\"503\":1}}],[\"log采用wal\",{\"1\":{\"506\":1}}],[\"log进行刷盘\",{\"1\":{\"506\":1}}],[\"log记录这次操作\",{\"1\":{\"506\":1}}],[\"log被引入来解决这个问题\",{\"1\":{\"506\":1}}],[\"log属于逻辑日志\",{\"1\":{\"506\":1}}],[\"log的共享以达到数据同步的目的\",{\"1\":{\"884\":1}}],[\"log的内容做与之前相反的工作\",{\"1\":{\"506\":1}}],[\"log的指针\",{\"1\":{\"503\":1}}],[\"log的指针等\",{\"1\":{\"503\":1}}],[\"log的版本链\",{\"1\":{\"503\":1}}],[\"log\",{\"1\":{\"499\":1,\"503\":1,\"506\":2,\"554\":6,\"555\":6,\"593\":6,\"692\":11,\"696\":4,\"697\":4,\"698\":4,\"699\":4,\"702\":3,\"705\":2,\"707\":2,\"710\":1,\"711\":3,\"713\":2,\"714\":2,\"723\":2,\"725\":1,\"733\":2,\"735\":2,\"736\":1,\"737\":1,\"738\":1,\"748\":3,\"750\":2,\"751\":2,\"753\":4,\"754\":5,\"757\":3,\"758\":4,\"759\":3,\"760\":4,\"761\":3,\"762\":3,\"763\":4,\"764\":3,\"766\":6,\"768\":3,\"772\":2,\"773\":1,\"774\":3,\"776\":7,\"796\":2,\"826\":4,\"827\":2,\"834\":2,\"836\":2,\"840\":4,\"846\":3,\"857\":4,\"886\":2,\"1012\":2,\"1023\":2,\"1024\":6,\"1025\":3,\"1056\":2,\"1072\":5,\"1089\":2,\"1099\":1,\"1152\":1,\"1157\":4,\"1159\":1,\"1180\":1,\"1196\":1,\"1285\":4,\"1294\":6,\"1505\":6}}],[\"log2n\",{\"1\":{\"491\":1}}],[\"logininterceptor\",{\"1\":{\"1100\":2,\"1111\":2}}],[\"loginform\",{\"1\":{\"1099\":3,\"1107\":3}}],[\"loginformdto\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"loginresponsemessage\",{\"1\":{\"702\":6,\"703\":3,\"723\":3}}],[\"loginrequestmessagehandler\",{\"1\":{\"703\":1}}],[\"loginrequestmessage\",{\"1\":{\"702\":3,\"703\":1,\"713\":2,\"723\":3}}],[\"logindate\",{\"1\":{\"458\":1}}],[\"logintime\",{\"1\":{\"400\":13}}],[\"login\",{\"1\":{\"400\":4,\"423\":10,\"458\":3,\"701\":1,\"702\":9,\"703\":3,\"1099\":1,\"1100\":1,\"1107\":4,\"1111\":2}}],[\"loggerfactory\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"1285\":1,\"1294\":2}}],[\"logger\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"740\":1,\"741\":1,\"743\":1,\"775\":1,\"1285\":1,\"1294\":2}}],[\"logged\",{\"1\":{\"343\":1}}],[\"logginghandler\",{\"1\":{\"692\":5,\"693\":6,\"696\":1,\"697\":19,\"698\":17,\"699\":19,\"702\":4,\"710\":1,\"711\":1,\"713\":1,\"725\":1,\"733\":4,\"735\":2,\"737\":2,\"748\":20,\"754\":1}}],[\"logging\",{\"1\":{\"506\":1,\"702\":4,\"733\":4,\"735\":2,\"737\":2,\"743\":1,\"1070\":2,\"1088\":1}}],[\"logging<\",{\"1\":{\"105\":2}}],[\"log4j<\",{\"1\":{\"1070\":2}}],[\"log4j12<\",{\"1\":{\"1022\":1}}],[\"log4j\",{\"1\":{\"100\":1,\"1022\":7}}],[\"lose\",{\"1\":{\"81\":7}}],[\"losecount++\",{\"1\":{\"81\":1}}],[\"losecount\",{\"1\":{\"81\":2}}],[\"loading\",{\"1\":{\"1230\":1}}],[\"loadshopdata\",{\"1\":{\"1171\":1}}],[\"loaded\",{\"1\":{\"876\":1}}],[\"loader\",{\"1\":{\"59\":1,\"737\":2}}],[\"loadfactorynames\",{\"1\":{\"1464\":1}}],[\"loadfactor\",{\"1\":{\"579\":3}}],[\"load语法规则\",{\"1\":{\"283\":1}}],[\"load加载数据基本操作\",{\"1\":{\"284\":1,\"289\":1}}],[\"load加载数据\",{\"0\":{\"283\":1}}],[\"load\",{\"1\":{\"42\":1,\"261\":7,\"262\":3,\"271\":1,\"280\":1,\"283\":2,\"285\":1,\"287\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"606\":3,\"723\":1,\"733\":1}}],[\"lazy\",{\"1\":{\"1230\":1,\"1264\":1,\"1290\":1,\"1294\":3,\"1297\":1,\"1482\":1,\"1489\":1}}],[\"lazysimpleserde是hive默认的序列化类\",{\"1\":{\"252\":1}}],[\"lazysimpleserde分隔符指定\",{\"0\":{\"252\":1}}],[\"layout\",{\"1\":{\"1022\":1}}],[\"layout=org\",{\"1\":{\"1022\":1}}],[\"lambdaquery\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"lambdaquerywrapper<user>\",{\"1\":{\"1235\":1}}],[\"lambdaquerywrapper<>\",{\"1\":{\"1164\":1,\"1165\":1,\"1235\":1}}],[\"lambdaquerywrapper<follow>\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"lambda$main$1\",{\"1\":{\"765\":1}}],[\"lambda$main$0\",{\"1\":{\"762\":1,\"765\":1}}],[\"lambda针对函数式接口进行简化编程\",{\"1\":{\"614\":1}}],[\"lambda\",{\"0\":{\"614\":1},\"1\":{\"562\":2,\"616\":1}}],[\"lag\",{\"1\":{\"358\":1,\"365\":5}}],[\"latitude\",{\"1\":{\"1170\":1}}],[\"latch\",{\"1\":{\"1132\":3}}],[\"latency\",{\"1\":{\"1021\":1}}],[\"lateral\",{\"0\":{\"349\":1},\"1\":{\"348\":1,\"349\":3,\"378\":2,\"391\":1,\"396\":1}}],[\"later\",{\"1\":{\"283\":1}}],[\"latte=com\",{\"1\":{\"42\":1}}],[\"latte\",{\"1\":{\"28\":1,\"30\":1,\"34\":1}}],[\"lattecoffeefactory\",{\"1\":{\"34\":1}}],[\"lattecoffee\",{\"1\":{\"25\":1,\"28\":1,\"30\":1,\"34\":2,\"39\":1,\"42\":1}}],[\"lastid\",{\"1\":{\"1168\":2}}],[\"lasttimemillis\",{\"1\":{\"999\":9}}],[\"lastbytesread\",{\"1\":{\"744\":3}}],[\"last1\",{\"1\":{\"365\":1}}],[\"last\",{\"1\":{\"342\":4,\"365\":6,\"495\":1,\"799\":1,\"1162\":1,\"1168\":1,\"1172\":1}}],[\"lastname因为\",{\"1\":{\"495\":1}}],[\"lastname\",{\"1\":{\"272\":4,\"495\":1}}],[\"lastupdated\",{\"1\":{\"101\":1}}],[\"lab和test\",{\"1\":{\"923\":1}}],[\"lab和dev\",{\"1\":{\"923\":1}}],[\"lab这个根域\",{\"1\":{\"923\":1}}],[\"lab的子域\",{\"1\":{\"923\":1}}],[\"lab均为yunying\",{\"1\":{\"923\":1}}],[\"lab为其他两个域的根域\",{\"1\":{\"923\":1}}],[\"lab视频讲解\",{\"1\":{\"125\":1}}],[\"lab\",{\"1\":{\"125\":1}}],[\"lang=all\",{\"1\":{\"1243\":1,\"1292\":1,\"1296\":1,\"1317\":1}}],[\"lang\",{\"1\":{\"59\":8,\"343\":2,\"567\":1,\"603\":1,\"623\":1,\"624\":1,\"762\":4,\"763\":2,\"764\":2,\"765\":2,\"775\":2,\"1313\":1}}],[\"eq\",{\"1\":{\"1099\":1,\"1107\":1,\"1134\":1,\"1135\":1,\"1136\":3,\"1137\":9,\"1157\":3,\"1161\":3,\"1162\":2,\"1164\":4,\"1165\":3,\"1167\":1,\"1172\":1,\"1234\":1}}],[\"equals与==作用一样\",{\"1\":{\"597\":1}}],[\"equals方法如果没有被重写\",{\"1\":{\"597\":1}}],[\"equals和hashcode都是object类中的方法\",{\"1\":{\"596\":1}}],[\"equals和hashcode\",{\"0\":{\"596\":1}}],[\"equals\",{\"1\":{\"28\":2,\"30\":2,\"59\":2,\"579\":3,\"619\":1,\"740\":1,\"754\":1,\"794\":1,\"983\":1,\"1099\":1,\"1107\":1,\"1142\":1,\"1144\":2,\"1161\":1,\"1505\":6}}],[\"equalsignorecase\",{\"1\":{\"23\":3}}],[\"epoch\",{\"1\":{\"999\":2}}],[\"epoll通过内核空间和用户空间共享一块内存来实现\",{\"1\":{\"680\":1}}],[\"epoll实现通过epoll\",{\"1\":{\"680\":1}}],[\"epoll工作在et模式的时候\",{\"1\":{\"680\":1}}],[\"epoll对文件描述符的操作有两种模式\",{\"1\":{\"680\":1}}],[\"epoll使用\",{\"1\":{\"680\":1}}],[\"epoll使用一个文件描述符管理多个描述符\",{\"1\":{\"680\":1}}],[\"epoll支持水平触发和边缘触发\",{\"1\":{\"680\":1}}],[\"epoll更加灵活\",{\"1\":{\"680\":1}}],[\"epoll是select和poll的增强版本\",{\"1\":{\"680\":1}}],[\"epoll本质上都是同步io\",{\"1\":{\"680\":1}}],[\"epoll的效率就会远远高于select和poll\",{\"1\":{\"680\":1}}],[\"epoll的优点\",{\"1\":{\"680\":1}}],[\"epoll的优势并不是对于单个连接能处理得更快\",{\"1\":{\"679\":1}}],[\"epoll的web\",{\"1\":{\"679\":1}}],[\"epoll的好处就在于单个process就可以同时处理多个网络的io\",{\"1\":{\"679\":1}}],[\"epoll等概念啦\",{\"1\":{\"675\":1}}],[\"epoll\",{\"1\":{\"517\":1,\"680\":3,\"792\":1}}],[\"ezk\",{\"1\":{\"936\":2}}],[\"ez\",{\"1\":{\"933\":1,\"934\":2}}],[\"ez密钥存储在hdfs外部的密钥库中\",{\"1\":{\"931\":1}}],[\"ez密钥\",{\"1\":{\"931\":1}}],[\"ec命令\",{\"1\":{\"875\":1}}],[\"ec编码部署方式\",{\"1\":{\"875\":1}}],[\"ec\",{\"1\":{\"875\":4}}],[\"ecworker\",{\"1\":{\"875\":1}}],[\"ec架构\",{\"1\":{\"875\":1}}],[\"echo\",{\"1\":{\"794\":1}}],[\"e5\",{\"1\":{\"805\":2}}],[\"eager\",{\"1\":{\"1230\":1}}],[\"eagle\",{\"0\":{\"1044\":1,\"1046\":1},\"1\":{\"1046\":28}}],[\"eat=a×λ+\",{\"1\":{\"683\":1}}],[\"eat=t+t=2t\",{\"1\":{\"683\":1}}],[\"eat\",{\"1\":{\"683\":1}}],[\"each\",{\"1\":{\"442\":1,\"799\":1}}],[\"effective\",{\"1\":{\"683\":1}}],[\"etc\",{\"1\":{\"878\":5,\"879\":1,\"910\":1,\"924\":4,\"936\":3,\"1012\":2,\"1046\":2,\"1197\":1}}],[\"et模式在很大程度上减少了epoll事件被重复触发的次数\",{\"1\":{\"680\":1}}],[\"et模式\",{\"1\":{\"680\":1}}],[\"etl\",{\"0\":{\"228\":1},\"1\":{\"228\":1}}],[\"edek的加密和解密完全在kms上进行\",{\"1\":{\"935\":1}}],[\"edek+ez\",{\"1\":{\"934\":1}}],[\"edek存储在namenode上\",{\"1\":{\"933\":1}}],[\"edek\",{\"1\":{\"931\":1}}],[\"edits\",{\"1\":{\"905\":1}}],[\"edge\",{\"1\":{\"680\":2}}],[\"edu\",{\"1\":{\"119\":1}}],[\"e4\",{\"1\":{\"666\":1,\"805\":2}}],[\"e3\",{\"1\":{\"666\":2}}],[\"ek\",{\"1\":{\"579\":11}}],[\"eh\",{\"1\":{\"579\":3}}],[\"es\",{\"1\":{\"1132\":1}}],[\"esspringbootapplicationtests\",{\"1\":{\"1089\":1}}],[\"esspringboot\",{\"1\":{\"1088\":1}}],[\"estestclient\",{\"1\":{\"1071\":2,\"1072\":6,\"1073\":8,\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2}}],[\"established\",{\"1\":{\"726\":2}}],[\"estimated\",{\"1\":{\"579\":1}}],[\"escaped\",{\"1\":{\"290\":1}}],[\"eval\",{\"1\":{\"1152\":2}}],[\"evaluate\",{\"1\":{\"344\":2}}],[\"evt\",{\"1\":{\"707\":4}}],[\"eviction\",{\"1\":{\"522\":1}}],[\"eventlistener\",{\"1\":{\"1493\":1}}],[\"eventloops\",{\"1\":{\"846\":1}}],[\"eventlooptest2\",{\"1\":{\"750\":2,\"751\":5}}],[\"eventlooptest\",{\"1\":{\"748\":12}}],[\"eventloopgroup\",{\"1\":{\"740\":1,\"746\":3,\"747\":1,\"748\":2}}],[\"eventloop\",{\"0\":{\"746\":1},\"1\":{\"725\":1,\"737\":1,\"740\":8,\"741\":3,\"742\":5,\"743\":7,\"746\":11,\"758\":3,\"759\":4,\"787\":1,\"846\":2}}],[\"eventpublishingrunlistener\",{\"1\":{\"1446\":1}}],[\"eventexecutors\",{\"1\":{\"760\":3,\"761\":3,\"762\":3,\"763\":3,\"764\":3,\"765\":4}}],[\"eventexecutor\",{\"1\":{\"746\":1,\"749\":1}}],[\"eventexecutorgroup\",{\"1\":{\"746\":1}}],[\"event\",{\"1\":{\"610\":1,\"679\":1,\"707\":4,\"741\":1,\"789\":1}}],[\"even\",{\"1\":{\"81\":4}}],[\"e2\",{\"1\":{\"290\":1,\"614\":4,\"666\":3}}],[\"e1\",{\"1\":{\"290\":2,\"614\":4,\"666\":7}}],[\"embed\",{\"1\":{\"1442\":1}}],[\"embed<\",{\"1\":{\"1442\":1}}],[\"embeddeddatabase\",{\"1\":{\"1454\":1}}],[\"embeddedvalueresolveraware\",{\"1\":{\"1284\":1}}],[\"embeddedchannel\",{\"1\":{\"713\":2}}],[\"embedded\",{\"1\":{\"242\":1}}],[\"emptyset\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"emptylist\",{\"1\":{\"1156\":1,\"1157\":1,\"1162\":1,\"1172\":2}}],[\"empty\",{\"1\":{\"579\":1,\"669\":1,\"701\":1,\"1205\":1}}],[\"empno\",{\"1\":{\"404\":2}}],[\"emp\",{\"1\":{\"404\":2}}],[\"employees\",{\"1\":{\"614\":1,\"615\":1,\"616\":1,\"618\":1,\"619\":2,\"620\":2,\"621\":6}}],[\"employee\",{\"1\":{\"272\":2,\"320\":6,\"321\":4,\"322\":4,\"323\":4,\"324\":4,\"325\":8,\"357\":5,\"615\":6,\"618\":1,\"619\":1,\"620\":2,\"621\":9}}],[\"email\",{\"1\":{\"321\":2,\"322\":2,\"1525\":1}}],[\"ergou\",{\"1\":{\"1210\":2}}],[\"erasure\",{\"0\":{\"875\":1},\"1\":{\"875\":1}}],[\"eriklindernoren\",{\"1\":{\"128\":1}}],[\"errormvcautoconfiguration\",{\"0\":{\"1460\":1}}],[\"errorproperties\",{\"1\":{\"1416\":5}}],[\"errorpage\",{\"1\":{\"1413\":1}}],[\"errorpageregistrar\",{\"1\":{\"1413\":3}}],[\"errorpageregistrarbeanpostprocessor\",{\"1\":{\"1411\":1,\"1413\":3}}],[\"errorattributes\",{\"1\":{\"1416\":1}}],[\"errorviewresolver\",{\"1\":{\"1411\":1}}],[\"error\",{\"1\":{\"59\":4,\"692\":4,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"702\":4,\"710\":2,\"711\":2,\"733\":4,\"735\":4,\"737\":2,\"762\":4,\"763\":3,\"764\":3,\"1023\":1,\"1024\":1,\"1025\":2,\"1152\":1,\"1157\":4,\"1309\":2,\"1411\":5,\"1413\":1,\"1416\":2}}],[\"eeeeeeeeeee|\",{\"1\":{\"699\":1}}],[\"eee|\",{\"1\":{\"698\":1}}],[\"ee\",{\"1\":{\"88\":1,\"1152\":3}}],[\"english\",{\"1\":{\"1244\":1}}],[\"engine=innodb\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"environmentpostprocessor\",{\"1\":{\"1446\":1}}],[\"environmentpostprocessorapplicationlistener\",{\"1\":{\"1444\":1}}],[\"environment\",{\"1\":{\"1240\":1,\"1243\":1,\"1444\":2}}],[\"env\",{\"1\":{\"936\":3,\"1444\":1}}],[\"ens33\",{\"1\":{\"878\":1}}],[\"ensureopen\",{\"1\":{\"740\":2,\"743\":1}}],[\"ent\",{\"1\":{\"1152\":3}}],[\"enter\",{\"1\":{\"870\":1}}],[\"entries\",{\"1\":{\"1111\":1,\"1224\":4}}],[\"entrance\",{\"1\":{\"740\":1}}],[\"entryset\",{\"1\":{\"740\":3,\"1171\":1}}],[\"entry<long\",{\"1\":{\"1171\":1}}],[\"entry<channeloption<\",{\"1\":{\"740\":1}}],[\"entry<attributekey<\",{\"1\":{\"740\":2,\"743\":1}}],[\"entry<k\",{\"1\":{\"579\":1}}],[\"entry\",{\"1\":{\"665\":1,\"1171\":3}}],[\"entry对象就不会被回收\",{\"1\":{\"577\":1}}],[\"enableautoconfiguration注解的组成部分\",{\"1\":{\"1525\":1}}],[\"enableautoconfiguration注解开启自动配置\",{\"1\":{\"1524\":1}}],[\"enableautoconfiguration的关键功能就是通过\",{\"1\":{\"1525\":1}}],[\"enableautoconfiguration\",{\"1\":{\"1525\":4}}],[\"enableasync\",{\"1\":{\"1243\":1}}],[\"enableaspectjautoproxy\",{\"1\":{\"1137\":1,\"1453\":3}}],[\"enabletransactionmanagement\",{\"1\":{\"1456\":2}}],[\"enable\",{\"1\":{\"1024\":1,\"1028\":2,\"1197\":1,\"1465\":1}}],[\"enablepolicy\",{\"1\":{\"875\":2}}],[\"enable=true\",{\"1\":{\"457\":1}}],[\"enabled=true来手动开启\",{\"1\":{\"1230\":1}}],[\"enabled<\",{\"1\":{\"926\":1}}],[\"enabled参数值\",{\"1\":{\"874\":1}}],[\"enabled\",{\"1\":{\"438\":2,\"1525\":1}}],[\"enable|disable\",{\"1\":{\"276\":1}}],[\"ename\",{\"1\":{\"404\":2}}],[\"end的部分\",{\"1\":{\"1172\":1}}],[\"endian\",{\"1\":{\"772\":3}}],[\"endindex\",{\"1\":{\"566\":5}}],[\"endswith\",{\"1\":{\"733\":1,\"822\":1}}],[\"endl\",{\"1\":{\"646\":1,\"669\":1}}],[\"endtime\",{\"1\":{\"407\":1,\"408\":1,\"409\":5}}],[\"end\",{\"1\":{\"340\":4,\"351\":2,\"380\":2,\"382\":3,\"820\":2,\"823\":2,\"1132\":2,\"1146\":1,\"1151\":4,\"1156\":2,\"1172\":2,\"1209\":1}}],[\"enforce\",{\"1\":{\"266\":1,\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"en\",{\"1\":{\"133\":1,\"1244\":1}}],[\"encodedresourceresolver\",{\"1\":{\"1432\":1}}],[\"encode\",{\"1\":{\"713\":3,\"714\":1,\"723\":1,\"805\":2,\"840\":3,\"843\":1,\"848\":1,\"859\":1}}],[\"encoding\",{\"1\":{\"665\":6,\"1462\":1}}],[\"encoding=\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"encoding>\",{\"1\":{\"102\":1,\"957\":1}}],[\"encrypted\",{\"1\":{\"934\":1}}],[\"encryption\",{\"1\":{\"931\":2,\"936\":2}}],[\"encryptphonum\",{\"1\":{\"344\":5}}],[\"encrypt\",{\"1\":{\"344\":2}}],[\"enclosing\",{\"1\":{\"69\":1}}],[\"enum\",{\"1\":{\"66\":1,\"723\":1}}],[\"enhancer\",{\"1\":{\"60\":6,\"1306\":1}}],[\"elasticsearchresttemplate\",{\"1\":{\"1089\":3}}],[\"elasticsearchrepository<product\",{\"1\":{\"1089\":1}}],[\"elasticsearchclient\",{\"1\":{\"1088\":1}}],[\"elasticsearchconfig\",{\"1\":{\"1088\":1}}],[\"elasticsearch<\",{\"1\":{\"1070\":1,\"1087\":1}}],[\"elasticsearch中的每个索引被分片1个主分片和1个复制\",{\"1\":{\"1067\":1}}],[\"elasticsearch允许你创建分片的一份或多份拷贝\",{\"1\":{\"1067\":1}}],[\"elasticsearch提供了将索引划分成多份的能力\",{\"1\":{\"1066\":1}}],[\"elasticsearch\",{\"0\":{\"1057\":1,\"1059\":1,\"1560\":1},\"1\":{\"791\":1,\"1070\":1,\"1088\":2}}],[\"elt\",{\"0\":{\"228\":1},\"1\":{\"228\":1}}],[\"elementtype\",{\"1\":{\"1525\":1}}],[\"element\",{\"1\":{\"1209\":2}}],[\"election\",{\"1\":{\"1050\":2}}],[\"ele\",{\"1\":{\"43\":2}}],[\"else\",{\"1\":{\"23\":2,\"28\":2,\"30\":1,\"70\":1,\"81\":6,\"88\":2,\"340\":4,\"344\":2,\"351\":2,\"380\":2,\"382\":3,\"579\":5,\"648\":1,\"669\":1,\"702\":1,\"703\":2,\"704\":3,\"711\":1,\"723\":2,\"737\":1,\"738\":1,\"740\":6,\"741\":1,\"742\":2,\"743\":2,\"749\":1,\"799\":2,\"823\":1,\"836\":2,\"840\":2,\"843\":2,\"846\":1,\"974\":2,\"986\":1,\"988\":1,\"999\":1,\"1025\":1,\"1151\":1,\"1161\":1,\"1162\":1,\"1164\":1,\"1165\":1,\"1168\":1,\"1467\":1}}],[\"e\",{\"1\":{\"42\":2,\"47\":4,\"125\":1,\"133\":1,\"320\":21,\"321\":14,\"322\":14,\"323\":14,\"324\":7,\"340\":1,\"382\":2,\"388\":1,\"536\":2,\"551\":4,\"554\":4,\"555\":8,\"579\":19,\"593\":8,\"692\":5,\"693\":2,\"696\":2,\"697\":13,\"698\":13,\"699\":13,\"702\":6,\"710\":2,\"711\":2,\"717\":2,\"718\":2,\"723\":6,\"725\":2,\"726\":2,\"733\":6,\"734\":3,\"735\":2,\"737\":2,\"740\":3,\"741\":2,\"742\":1,\"743\":3,\"748\":6,\"759\":3,\"760\":2,\"761\":2,\"762\":5,\"763\":5,\"764\":5,\"765\":4,\"772\":2,\"773\":1,\"774\":3,\"776\":8,\"779\":4,\"780\":2,\"795\":8,\"796\":2,\"799\":1,\"805\":2,\"807\":5,\"808\":10,\"820\":4,\"823\":2,\"834\":4,\"836\":4,\"840\":2,\"846\":8,\"848\":5,\"857\":3,\"859\":6,\"1023\":2,\"1024\":2,\"1025\":2,\"1071\":2,\"1127\":2,\"1128\":2,\"1129\":4,\"1152\":6,\"1157\":2,\"1159\":2,\"1294\":13,\"1309\":10,\"1526\":3}}],[\"exe文件\",{\"1\":{\"1201\":1}}],[\"execstart=\",{\"1\":{\"1197\":1}}],[\"executor\",{\"1\":{\"741\":2,\"749\":4,\"1128\":2,\"1129\":2,\"1157\":2}}],[\"executorservice\",{\"1\":{\"574\":4,\"593\":8,\"757\":1,\"1128\":1,\"1129\":1,\"1157\":1}}],[\"executors\",{\"1\":{\"574\":3,\"593\":2,\"757\":1,\"1128\":1,\"1129\":1,\"1157\":1}}],[\"executors创建的线程池\",{\"0\":{\"574\":1}}],[\"executionexception\",{\"1\":{\"762\":2}}],[\"execution\",{\"1\":{\"438\":2}}],[\"executions>\",{\"1\":{\"344\":1}}],[\"execution>\",{\"1\":{\"344\":1}}],[\"execute\",{\"0\":{\"575\":1},\"1\":{\"47\":3,\"740\":4,\"741\":4,\"743\":1,\"749\":1,\"750\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"1147\":1,\"1156\":1,\"1157\":1}}],[\"exec<\",{\"1\":{\"344\":1}}],[\"exec\",{\"1\":{\"70\":1,\"261\":2,\"268\":1,\"276\":1,\"289\":2,\"297\":1,\"298\":1,\"433\":2,\"444\":3,\"446\":2}}],[\"ex保证故障时锁依然能释放\",{\"1\":{\"1147\":1}}],[\"ex获取锁\",{\"1\":{\"1147\":1}}],[\"ex是设置超时时间\",{\"1\":{\"1141\":1}}],[\"exactly\",{\"1\":{\"1053\":1,\"1054\":1}}],[\"example<\",{\"1\":{\"108\":1}}],[\"exit\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1}}],[\"exist\",{\"1\":{\"1161\":1,\"1206\":1}}],[\"existing\",{\"1\":{\"822\":1}}],[\"exists和in的区分\",{\"0\":{\"496\":1}}],[\"exists子查询\",{\"1\":{\"317\":1}}],[\"exists\",{\"1\":{\"256\":1,\"260\":1,\"261\":1,\"276\":1,\"278\":2,\"280\":3,\"285\":1,\"286\":1,\"317\":1,\"332\":3,\"397\":1,\"496\":1,\"515\":1,\"822\":1,\"972\":1,\"973\":1,\"974\":1,\"988\":1,\"1151\":1,\"1205\":7}}],[\"ex\",{\"1\":{\"519\":1,\"1111\":1,\"1141\":1}}],[\"extra列会出现\",{\"1\":{\"481\":1}}],[\"extract\",{\"1\":{\"336\":3}}],[\"extensions\",{\"1\":{\"1045\":1}}],[\"extension\",{\"1\":{\"290\":1,\"870\":1}}],[\"extended\",{\"1\":{\"276\":1,\"278\":2,\"328\":1,\"441\":1}}],[\"extends\",{\"1\":{\"6\":1,\"14\":2,\"34\":1,\"47\":1,\"59\":2,\"73\":2,\"85\":2,\"344\":1,\"373\":1,\"579\":4,\"703\":2,\"704\":5,\"705\":1,\"713\":1,\"714\":1,\"716\":1,\"718\":1,\"723\":4,\"726\":1,\"733\":2,\"734\":1,\"736\":1,\"738\":1,\"756\":2,\"956\":1,\"958\":1,\"960\":1,\"962\":1,\"972\":2,\"973\":3,\"974\":3,\"985\":1,\"986\":2,\"988\":5,\"990\":1,\"1088\":1,\"1089\":1,\"1236\":1}}],[\"external\",{\"1\":{\"258\":1}}],[\"expiration\",{\"1\":{\"1152\":3}}],[\"expirationentry\",{\"1\":{\"1152\":2}}],[\"expiretime\",{\"1\":{\"1128\":3,\"1129\":11}}],[\"expire\",{\"1\":{\"1107\":1,\"1111\":1,\"1141\":1,\"1151\":1,\"1205\":3}}],[\"expireseconds\",{\"1\":{\"1128\":2}}],[\"expires\",{\"1\":{\"522\":1}}],[\"exposeproxy\",{\"1\":{\"1137\":1}}],[\"export\",{\"1\":{\"244\":2,\"290\":3,\"878\":1,\"879\":1,\"910\":1,\"936\":8,\"1012\":8,\"1045\":1,\"1046\":11}}],[\"expunge\",{\"1\":{\"910\":1}}],[\"expected\",{\"1\":{\"799\":1}}],[\"explode函数的使用\",{\"1\":{\"389\":1}}],[\"explode函数属于udtf表生成函数\",{\"1\":{\"348\":1}}],[\"explode执行返回的结果可以理解为一张虚拟的表\",{\"1\":{\"348\":1}}],[\"explode\",{\"1\":{\"347\":2,\"348\":2,\"349\":2,\"391\":1}}],[\"explode接收map\",{\"1\":{\"346\":1}}],[\"explain表的结果\",{\"1\":{\"481\":1}}],[\"explain会解析hql语句\",{\"1\":{\"440\":1}}],[\"explain命令可以帮助用户了解一条hql语句在底层的实现过程\",{\"1\":{\"440\":1}}],[\"explain查询计划\",{\"0\":{\"440\":1}}],[\"explain\",{\"1\":{\"276\":1,\"441\":1}}],[\"expression窗口表达式给我们提供了一种控制行范围的能力\",{\"1\":{\"361\":1}}],[\"expression>\",{\"1\":{\"358\":2}}],[\"expressions\",{\"0\":{\"318\":1},\"1\":{\"318\":1}}],[\"expression<\",{\"1\":{\"107\":2}}],[\"expr中\",{\"1\":{\"306\":1}}],[\"expr中的字段\",{\"1\":{\"306\":1}}],[\"expr\",{\"0\":{\"302\":1},\"1\":{\"300\":2}}],[\"exc\",{\"1\":{\"822\":2,\"857\":1,\"859\":6}}],[\"exclusive\",{\"1\":{\"585\":1}}],[\"exclusions>\",{\"1\":{\"105\":1,\"1172\":1}}],[\"exclusion>\",{\"1\":{\"105\":1,\"1172\":2}}],[\"excludename\",{\"1\":{\"1525\":1}}],[\"excludepathpatterns\",{\"1\":{\"1100\":1}}],[\"exclude指向文件\",{\"1\":{\"880\":1}}],[\"exclude参数指定\",{\"1\":{\"880\":1}}],[\"exclude\",{\"1\":{\"879\":1,\"1079\":2,\"1525\":1}}],[\"excludes\",{\"1\":{\"879\":1}}],[\"excludes文件中的节点就是被禁止的节点\",{\"1\":{\"879\":1}}],[\"excludes<\",{\"1\":{\"879\":1}}],[\"excludes>\",{\"1\":{\"344\":1,\"1219\":1}}],[\"exclude<\",{\"1\":{\"879\":1}}],[\"exclude属性\",{\"1\":{\"879\":1}}],[\"exclude>\",{\"1\":{\"344\":3,\"1219\":1}}],[\"exception分为运行时异常和非运行时异常\",{\"1\":{\"1516\":1}}],[\"exceptionhandler注解\",{\"1\":{\"1526\":1}}],[\"exceptionhandler\",{\"0\":{\"1407\":1,\"1408\":1},\"1\":{\"1410\":3,\"1411\":2,\"1438\":1,\"1526\":1}}],[\"exceptionhandlerexceptionresolver\",{\"0\":{\"1404\":1},\"1\":{\"1410\":2,\"1438\":1}}],[\"exceptionvalue\",{\"1\":{\"733\":1,\"738\":3}}],[\"exceptionininitializererror\",{\"1\":{\"723\":1,\"733\":1}}],[\"exceptioncaught\",{\"1\":{\"705\":1,\"740\":1}}],[\"exception\",{\"0\":{\"1516\":1},\"1\":{\"42\":1,\"54\":1,\"68\":4,\"692\":5,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"702\":6,\"703\":2,\"704\":5,\"705\":2,\"707\":2,\"710\":1,\"711\":3,\"713\":2,\"714\":2,\"723\":2,\"725\":1,\"733\":4,\"734\":1,\"735\":2,\"736\":1,\"737\":2,\"738\":2,\"740\":6,\"741\":1,\"743\":7,\"748\":4,\"753\":1,\"754\":2,\"757\":1,\"758\":2,\"759\":1,\"762\":1,\"765\":2,\"766\":7,\"794\":1,\"848\":1,\"962\":3,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":2,\"1023\":1,\"1024\":1,\"1025\":5,\"1100\":1,\"1111\":4,\"1128\":1,\"1129\":1,\"1150\":1,\"1152\":1,\"1157\":1,\"1309\":1,\"1416\":1,\"1526\":2}}],[\"d3\",{\"1\":{\"875\":1}}],[\"d0\",{\"1\":{\"875\":1}}],[\"dn\",{\"1\":{\"872\":1}}],[\"dns解析\",{\"1\":{\"652\":1}}],[\"dfsinputstream将关闭与datanode的连接\",{\"1\":{\"902\":1}}],[\"dfsoutputstream也维护着一个内部数据包队列来等待datanode的收到确认回执\",{\"1\":{\"901\":1}}],[\"dfsoutputstream有一个内部类做datastreamer\",{\"1\":{\"901\":1}}],[\"dfsoutputstream将数据分成一个个数据包\",{\"1\":{\"901\":1}}],[\"dfsadmin\",{\"1\":{\"870\":3,\"873\":2,\"878\":1,\"879\":1,\"914\":2}}],[\"dfs\",{\"1\":{\"870\":6,\"872\":2,\"879\":1,\"880\":2,\"903\":1,\"910\":2,\"914\":3}}],[\"d2\",{\"1\":{\"822\":1}}],[\"d1\",{\"1\":{\"822\":3,\"875\":1}}],[\"duration\",{\"1\":{\"1024\":1}}],[\"dump\",{\"1\":{\"799\":31}}],[\"dubbo\",{\"1\":{\"791\":1}}],[\"duplicate\",{\"0\":{\"777\":1},\"1\":{\"781\":1}}],[\"dual\",{\"1\":{\"329\":5,\"330\":10,\"331\":6,\"332\":6,\"339\":2}}],[\"dp\",{\"1\":{\"649\":14}}],[\"ds\",{\"1\":{\"1236\":2}}],[\"dss\",{\"1\":{\"620\":2}}],[\"ds<\",{\"1\":{\"460\":2}}],[\"ds>=\",{\"1\":{\"460\":2}}],[\"dsa<\",{\"1\":{\"344\":1}}],[\"d\",{\"1\":{\"338\":1,\"340\":1,\"344\":4,\"382\":2,\"388\":1,\"692\":1,\"693\":2,\"697\":12,\"698\":11,\"699\":11,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":8,\"779\":4,\"780\":2,\"796\":1,\"799\":5,\"805\":2,\"807\":3,\"808\":7,\"821\":10,\"822\":1,\"823\":2,\"836\":2,\"848\":1,\"857\":1,\"991\":4,\"999\":4,\"1440\":1}}],[\"dddd|\",{\"1\":{\"699\":1}}],[\"ddd\",{\"1\":{\"617\":1}}],[\"dd\",{\"1\":{\"337\":3,\"698\":1,\"1132\":1}}],[\"ddl操作\",{\"0\":{\"279\":1,\"280\":1}}],[\"ddl建表基础语法\",{\"0\":{\"246\":1}}],[\"ddl\",{\"0\":{\"245\":1,\"257\":1,\"277\":1,\"278\":1}}],[\"d+\",{\"1\":{\"336\":3}}],[\"d+$\",{\"1\":{\"330\":2}}],[\"dql\",{\"0\":{\"282\":1,\"300\":1}}],[\"dml\",{\"0\":{\"282\":1,\"283\":1,\"286\":1,\"299\":1}}],[\"dma将数据读入内核缓冲区\",{\"1\":{\"855\":2}}],[\"dma\",{\"1\":{\"854\":4,\"855\":2}}],[\"dma控制器\",{\"1\":{\"209\":1}}],[\"dma方式\",{\"1\":{\"209\":1}}],[\"dt=\",{\"1\":{\"280\":6}}],[\"dbcp2\",{\"1\":{\"1454\":1}}],[\"dbconfiguration\",{\"1\":{\"985\":1,\"986\":1}}],[\"dbrollback\",{\"1\":{\"1129\":3}}],[\"dbfallback\",{\"1\":{\"1129\":6}}],[\"dboutputformat接受<key\",{\"1\":{\"986\":1}}],[\"dboutputformat\",{\"1\":{\"986\":3}}],[\"dbinputformat\",{\"1\":{\"985\":2}}],[\"dbinputformat类用于从sql表读取数据\",{\"1\":{\"985\":1}}],[\"dbwritable\",{\"1\":{\"985\":1}}],[\"dbproperties\",{\"1\":{\"278\":2}}],[\"dbtxnmanager才能使用acid表\",{\"1\":{\"296\":1}}],[\"dbtxnmanager\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"db\",{\"1\":{\"234\":1,\"235\":2,\"236\":1,\"237\":2,\"266\":1,\"276\":4,\"278\":1,\"280\":1,\"281\":5,\"285\":1,\"522\":1,\"1046\":2,\"1177\":1}}],[\"dwd\",{\"1\":{\"226\":1}}],[\"dwb\",{\"1\":{\"226\":1}}],[\"dws\",{\"1\":{\"226\":1}}],[\"dw层\",{\"0\":{\"226\":1}}],[\"dw\",{\"1\":{\"219\":1,\"224\":1,\"407\":1,\"409\":1,\"410\":1}}],[\"does\",{\"1\":{\"1206\":1}}],[\"domain\",{\"1\":{\"872\":7}}],[\"docbase\",{\"1\":{\"1447\":1,\"1449\":4}}],[\"docdelete\",{\"1\":{\"1089\":1}}],[\"documented\",{\"1\":{\"1525\":1}}],[\"document\",{\"0\":{\"1063\":1},\"1\":{\"1089\":2}}],[\"doc\",{\"1\":{\"1062\":1,\"1073\":1}}],[\"docker\",{\"1\":{\"847\":1}}],[\"docsave\",{\"1\":{\"1089\":1}}],[\"docs\",{\"1\":{\"133\":1,\"1013\":1,\"1212\":1}}],[\"dostartthread\",{\"1\":{\"741\":3}}],[\"dobeginread\",{\"1\":{\"740\":2,\"743\":2}}],[\"dobind0\",{\"1\":{\"740\":9}}],[\"dobind\",{\"1\":{\"740\":5}}],[\"doresolvedependency\",{\"1\":{\"1267\":1}}],[\"doreadbytes\",{\"1\":{\"744\":1}}],[\"doreadmessages\",{\"1\":{\"743\":2}}],[\"doregister\",{\"1\":{\"740\":1,\"743\":1}}],[\"doreleaseshared\",{\"1\":{\"585\":1}}],[\"do\",{\"1\":{\"590\":3,\"645\":2,\"743\":1,\"744\":1,\"796\":1,\"857\":2,\"1135\":1}}],[\"doacquiresharedinterruptibly\",{\"1\":{\"585\":1}}],[\"doacquireshared\",{\"1\":{\"585\":1}}],[\"doacquireinterruptibly\",{\"1\":{\"585\":1}}],[\"doublewritable\",{\"1\":{\"956\":1}}],[\"doublesummarystatistics\",{\"1\":{\"620\":1}}],[\"doublebuffer\",{\"1\":{\"610\":1,\"861\":1}}],[\"doubleaccumulator\",{\"1\":{\"562\":1}}],[\"doubleadder\",{\"1\":{\"562\":1}}],[\"double\",{\"1\":{\"248\":2,\"256\":1,\"338\":1,\"397\":1,\"404\":2,\"620\":2,\"621\":2,\"772\":2,\"956\":1,\"985\":4,\"986\":2,\"1089\":2,\"1126\":1,\"1162\":2,\"1172\":4}}],[\"don\",{\"1\":{\"70\":1}}],[\"dg∗​\",{\"1\":{\"122\":1}}],[\"dao层是data\",{\"1\":{\"1529\":1}}],[\"dao层是做什么的\",{\"0\":{\"1529\":1}}],[\"dao\",{\"1\":{\"1230\":1}}],[\"dao中\",{\"1\":{\"1100\":1}}],[\"daemonize\",{\"1\":{\"1196\":1}}],[\"daemon\",{\"1\":{\"878\":1,\"879\":1,\"936\":1,\"1197\":1}}],[\"dayofmonth\",{\"1\":{\"1175\":2,\"1176\":3}}],[\"day\",{\"1\":{\"337\":3,\"352\":1,\"353\":21,\"354\":6,\"355\":4}}],[\"day=20200827\",{\"1\":{\"236\":1}}],[\"day=20200826\",{\"1\":{\"236\":1}}],[\"day=20200825\",{\"1\":{\"236\":1}}],[\"da层\",{\"0\":{\"227\":1}}],[\"da\",{\"1\":{\"224\":1}}],[\"darknet\",{\"0\":{\"136\":1},\"1\":{\"144\":2}}],[\"dall\",{\"1\":{\"125\":1}}],[\"dalle\",{\"1\":{\"125\":1}}],[\"danieltakeshi\",{\"1\":{\"120\":1,\"127\":1}}],[\"datetimeformatter\",{\"1\":{\"1132\":1,\"1175\":1,\"1176\":1}}],[\"datediff\",{\"1\":{\"337\":3}}],[\"date\",{\"1\":{\"265\":1,\"271\":2,\"307\":3,\"337\":13,\"400\":3,\"409\":1,\"726\":3,\"753\":2,\"785\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"1132\":2,\"1174\":1}}],[\"dateforamt类中的getinstance\",{\"1\":{\"43\":1}}],[\"datasourcetransactionmanager\",{\"1\":{\"1456\":2}}],[\"datasourcetransactionmanagerautoconfiguration\",{\"1\":{\"1456\":1}}],[\"datasourceautoconfiguration\",{\"0\":{\"1454\":1},\"1\":{\"1454\":1}}],[\"datasource1\",{\"1\":{\"1236\":1}}],[\"datasource\",{\"1\":{\"1236\":8,\"1454\":2,\"1466\":1}}],[\"datastream请求分配数据块\",{\"1\":{\"901\":1}}],[\"datastreamer将数据包流式传输到pipeline的第一个datanode\",{\"1\":{\"901\":1}}],[\"data<\",{\"1\":{\"1172\":2}}],[\"datacenterid值必须大于0并且小于\",{\"1\":{\"999\":1}}],[\"datacenterid位需要左移的位数\",{\"1\":{\"999\":1}}],[\"datacenterid占用5个比特位\",{\"1\":{\"999\":1}}],[\"datacenterid占用的位数\",{\"1\":{\"999\":1}}],[\"datacenterid\",{\"1\":{\"998\":1,\"999\":8}}],[\"datainput\",{\"1\":{\"972\":1,\"974\":1,\"985\":1}}],[\"dataoutput\",{\"1\":{\"972\":1,\"974\":1,\"985\":1}}],[\"datanode所在机器通常配置有大量的硬盘空间\",{\"1\":{\"903\":1}}],[\"datanode会定期向namenode进行自己持有的数据块信息汇报\",{\"1\":{\"903\":1}}],[\"datanode会定期\",{\"1\":{\"903\":1}}],[\"datanode启动时\",{\"1\":{\"903\":1}}],[\"datanode负责将实际数据存储在hdfs中\",{\"1\":{\"903\":1}}],[\"datanode负载均衡服务\",{\"1\":{\"878\":1,\"879\":1}}],[\"datanode职责\",{\"1\":{\"903\":1}}],[\"datanode通过在本地文件系统上存储块并提供读\",{\"1\":{\"888\":1}}],[\"datanode\",{\"1\":{\"878\":1,\"879\":1,\"901\":1}}],[\"datanode运行一个附加的erasurecodingworker\",{\"1\":{\"875\":1}}],[\"datanode扩展\",{\"1\":{\"875\":1}}],[\"datanodes\",{\"1\":{\"870\":1}}],[\"datagramchannel\",{\"1\":{\"610\":1,\"848\":4,\"861\":1}}],[\"database|schema\",{\"0\":{\"278\":1},\"1\":{\"278\":4}}],[\"database\",{\"0\":{\"1541\":1},\"1\":{\"276\":1,\"278\":9,\"302\":1,\"343\":1}}],[\"databasename\",{\"1\":{\"235\":1}}],[\"databases\",{\"0\":{\"234\":1},\"1\":{\"1196\":1}}],[\"databind会依赖传递core\",{\"1\":{\"112\":1}}],[\"databind<\",{\"1\":{\"104\":1,\"112\":1,\"113\":1,\"1070\":1,\"1219\":1}}],[\"databind\",{\"1\":{\"104\":1,\"113\":1}}],[\"data\",{\"0\":{\"225\":1,\"226\":1},\"1\":{\"74\":4,\"104\":1,\"219\":1,\"223\":2,\"238\":2,\"248\":2,\"261\":7,\"262\":3,\"265\":1,\"266\":1,\"279\":2,\"280\":1,\"283\":2,\"285\":1,\"287\":1,\"296\":1,\"310\":1,\"329\":1,\"340\":1,\"342\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"397\":1,\"437\":1,\"590\":4,\"665\":1,\"723\":1,\"733\":2,\"766\":1,\"796\":2,\"820\":2,\"821\":6,\"822\":4,\"854\":1,\"874\":6,\"901\":1,\"931\":1,\"999\":8,\"1012\":1,\"1087\":1,\"1088\":1,\"1089\":1,\"1128\":2,\"1149\":1,\"1168\":1,\"1172\":3,\"1217\":1,\"1219\":1,\"1221\":1,\"1461\":1,\"1499\":1,\"1525\":2}}],[\"druiddatasource\",{\"1\":{\"1466\":1}}],[\"druid\",{\"1\":{\"1466\":3}}],[\"druid连接池\",{\"1\":{\"91\":1}}],[\"driver=com\",{\"1\":{\"1046\":1}}],[\"driver=org\",{\"1\":{\"1046\":1}}],[\"driver\",{\"1\":{\"985\":1,\"986\":1,\"1046\":1,\"1236\":4}}],[\"driver阶段\",{\"0\":{\"962\":1}}],[\"driver驱动程序\",{\"1\":{\"232\":1}}],[\"driven\",{\"1\":{\"679\":2,\"789\":1}}],[\"drops\",{\"1\":{\"276\":1}}],[\"drop\",{\"1\":{\"271\":1,\"276\":3,\"278\":2,\"280\":4,\"281\":2,\"397\":1,\"423\":1}}],[\"draw\",{\"1\":{\"23\":7}}],[\"dynamicinterceptionadvice\",{\"1\":{\"1350\":1}}],[\"dynamictablenameinnerinterceptor\",{\"1\":{\"1232\":5}}],[\"dynamictable\",{\"1\":{\"1232\":1}}],[\"dynamic\",{\"0\":{\"289\":1},\"1\":{\"59\":3,\"261\":5,\"268\":1,\"276\":1,\"289\":2,\"297\":1,\"298\":1,\"661\":1,\"1236\":1}}],[\"di主要有两种注入方式\",{\"1\":{\"1500\":1}}],[\"diginautowired\",{\"1\":{\"1266\":1}}],[\"digits\",{\"1\":{\"799\":3}}],[\"digitobserver\",{\"1\":{\"47\":7}}],[\"dictionary\",{\"1\":{\"1190\":1}}],[\"diff\",{\"1\":{\"869\":1}}],[\"different\",{\"1\":{\"442\":1}}],[\"dio\",{\"1\":{\"770\":1}}],[\"div\",{\"1\":{\"331\":3}}],[\"disposablebean\",{\"1\":{\"1289\":1}}],[\"dispatcherservlet根据view进行渲染视图\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet将modelandview传给viewreslover视图解析器\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet调用handleradapter处理器适配器\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet收到请求调用handllermapping处理器映射器\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet就用这个view对象对modelandview中的模型数据进行视图渲染\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet借由viewresolver完成逻辑视图名到真实视图对象的解析工作\",{\"1\":{\"1530\":1}}],[\"dispatcherservlet接收到这个请求后\",{\"1\":{\"1530\":1}}],[\"dispatcherservletregistrationbean\",{\"1\":{\"1458\":1}}],[\"dispatcherservletautoconfiguration\",{\"0\":{\"1458\":1},\"1\":{\"1438\":1}}],[\"dispatcherservlet\",{\"0\":{\"1353\":1},\"1\":{\"1251\":1,\"1355\":2,\"1438\":8,\"1451\":1,\"1458\":1,\"1459\":1}}],[\"disallowsnapshot\",{\"1\":{\"914\":1}}],[\"disablepolicy\",{\"1\":{\"875\":1}}],[\"disable\",{\"1\":{\"276\":1,\"878\":1}}],[\"disk\",{\"0\":{\"874\":1},\"1\":{\"874\":4}}],[\"disconnect\",{\"1\":{\"692\":1}}],[\"discarded\",{\"1\":{\"775\":1}}],[\"discardoldestpolicy弃老策略\",{\"1\":{\"573\":1}}],[\"discardpolicy丢弃策略\",{\"1\":{\"573\":1}}],[\"distancemap\",{\"1\":{\"1172\":3}}],[\"distance>\",{\"1\":{\"1172\":1}}],[\"distance\",{\"1\":{\"1172\":6}}],[\"distribution\",{\"1\":{\"923\":1}}],[\"distributedcache能够缓存应用程序所需的各种文件\",{\"1\":{\"989\":1}}],[\"distributedcache是mapreduce框架提供的一种机制\",{\"1\":{\"989\":1}}],[\"distributedfilesystem将fsdatainputstream输入流返回到客户端以供其读取数据\",{\"1\":{\"902\":1}}],[\"distributedfilesystem使用rpc调用namenode来确定文件中前几个块的块位置\",{\"1\":{\"902\":1}}],[\"distributedfilesystem联系namenode告知其文件写入完成\",{\"1\":{\"901\":1}}],[\"distributed\",{\"0\":{\"1556\":1},\"1\":{\"448\":1}}],[\"distribute\",{\"0\":{\"314\":1},\"1\":{\"300\":1,\"313\":3,\"314\":1,\"315\":3,\"367\":1,\"437\":2,\"450\":1,\"465\":2}}],[\"distcp\",{\"0\":{\"869\":1},\"1\":{\"869\":2}}],[\"distinct删除重复的行\",{\"1\":{\"303\":1}}],[\"distinct\",{\"0\":{\"303\":1,\"463\":1},\"1\":{\"300\":1,\"303\":3,\"315\":2,\"316\":1,\"351\":2,\"353\":7,\"354\":5,\"355\":2,\"400\":2,\"463\":1,\"481\":1,\"482\":2,\"493\":3,\"616\":2}}],[\"dir数据存储目录需要配置\",{\"1\":{\"1012\":1}}],[\"dirs=\",{\"1\":{\"1012\":1}}],[\"dircount\",{\"1\":{\"822\":3}}],[\"directfieldaccess\",{\"1\":{\"1370\":1}}],[\"directfieldaccessor\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"direction\",{\"1\":{\"1089\":1}}],[\"directbytebuffer\",{\"1\":{\"855\":1,\"861\":1}}],[\"directbytebuf\",{\"1\":{\"855\":4}}],[\"directbuffer\",{\"1\":{\"769\":1}}],[\"directly\",{\"1\":{\"740\":1}}],[\"direct\",{\"1\":{\"731\":1,\"854\":1}}],[\"directorynotemptyexception\",{\"1\":{\"822\":1}}],[\"directory2\",{\"1\":{\"290\":1}}],[\"directory1\",{\"1\":{\"290\":2}}],[\"directory\",{\"1\":{\"290\":6}}],[\"directory导出数据\",{\"0\":{\"290\":1}}],[\"directory>\",{\"1\":{\"102\":1}}],[\"director是指挥者\",{\"1\":{\"14\":1}}],[\"director\",{\"1\":{\"13\":1,\"14\":8}}],[\"dir属性指定\",{\"1\":{\"254\":1}}],[\"dir\",{\"1\":{\"235\":1,\"470\":1,\"821\":1,\"822\":6,\"1159\":2,\"1196\":1}}],[\"dir指定的数据存储目录\",{\"1\":{\"878\":1}}],[\"dir指定\",{\"1\":{\"234\":1}}],[\"dim\",{\"1\":{\"226\":1}}],[\"determine\",{\"1\":{\"1205\":1}}],[\"details\",{\"1\":{\"145\":4,\"543\":1,\"544\":1,\"545\":1,\"549\":1}}],[\"dek的加解密只在kms内存进行\",{\"1\":{\"934\":1}}],[\"dek是加解密一个文件的密匙\",{\"1\":{\"934\":1}}],[\"dek会使用其各自的加密区域的ez密钥进行加密\",{\"1\":{\"931\":1}}],[\"dek\",{\"1\":{\"931\":1,\"934\":3}}],[\"devtools<\",{\"1\":{\"1087\":1}}],[\"development\",{\"1\":{\"789\":1}}],[\"devicetype\",{\"1\":{\"395\":2,\"396\":5,\"397\":1}}],[\"device\",{\"1\":{\"395\":2,\"396\":5,\"397\":1}}],[\"deallocate\",{\"1\":{\"775\":1}}],[\"deaths\",{\"1\":{\"265\":2,\"266\":1,\"271\":3,\"302\":1,\"307\":5,\"310\":1,\"972\":8}}],[\"debugread\",{\"1\":{\"799\":1,\"826\":1,\"827\":1}}],[\"debugall\",{\"1\":{\"799\":1,\"809\":1,\"840\":1,\"846\":1}}],[\"debug\",{\"1\":{\"554\":6,\"555\":6,\"593\":6,\"692\":15,\"693\":9,\"696\":3,\"697\":26,\"698\":22,\"699\":26,\"702\":3,\"705\":2,\"707\":2,\"711\":3,\"713\":2,\"714\":2,\"723\":2,\"725\":1,\"726\":1,\"733\":2,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"748\":34,\"750\":4,\"751\":7,\"753\":4,\"754\":6,\"757\":3,\"758\":4,\"759\":3,\"760\":8,\"761\":6,\"762\":6,\"763\":8,\"764\":6,\"766\":6,\"775\":1,\"796\":19,\"805\":2,\"807\":3,\"808\":2,\"826\":4,\"827\":2,\"834\":2,\"836\":9,\"840\":4,\"846\":3,\"848\":1,\"857\":8,\"1088\":1,\"1099\":1,\"1159\":1,\"1243\":1,\"1285\":3,\"1505\":6}}],[\"decode\",{\"1\":{\"713\":2,\"714\":1,\"723\":1,\"805\":1,\"859\":1}}],[\"decrementandget\",{\"1\":{\"562\":1}}],[\"decr\",{\"1\":{\"515\":1,\"1206\":1}}],[\"decision\",{\"1\":{\"219\":1}}],[\"density对具体的卷实施操作\",{\"1\":{\"874\":1}}],[\"density确定哪个节点不平衡\",{\"1\":{\"874\":1}}],[\"density\",{\"1\":{\"874\":1}}],[\"density和node\",{\"1\":{\"874\":1}}],[\"density值表示该机器节点具有较好的扩展性\",{\"1\":{\"874\":1}}],[\"density卷\",{\"1\":{\"874\":1}}],[\"dense\",{\"1\":{\"363\":2,\"403\":2}}],[\"denominator\",{\"1\":{\"369\":1}}],[\"deg\",{\"1\":{\"357\":2}}],[\"definition\",{\"1\":{\"1248\":4,\"1476\":1}}],[\"defined\",{\"1\":{\"334\":4}}],[\"defensive\",{\"1\":{\"566\":1}}],[\"defense\",{\"1\":{\"260\":1,\"261\":1,\"281\":1}}],[\"deferredimportselector\",{\"1\":{\"1464\":1,\"1465\":2}}],[\"deferred\",{\"1\":{\"423\":1}}],[\"def\",{\"1\":{\"336\":1,\"694\":2}}],[\"defaulterrorattributes\",{\"1\":{\"1411\":1,\"1416\":1}}],[\"defaulteventloop\",{\"1\":{\"746\":5,\"760\":3,\"761\":4,\"762\":5,\"763\":3,\"764\":4,\"765\":6}}],[\"defaulteventloopgroup\",{\"1\":{\"746\":4,\"748\":7}}],[\"defaultlistablebeanfactory\",{\"0\":{\"1246\":1},\"1\":{\"1245\":2,\"1290\":1}}],[\"defaultredisscript<>\",{\"1\":{\"1147\":1,\"1156\":1}}],[\"defaultredisscript<long>\",{\"1\":{\"1147\":1,\"1156\":1}}],[\"defaultpromisetest\",{\"1\":{\"765\":4}}],[\"defaultpromisetest2\",{\"1\":{\"760\":4,\"761\":3,\"762\":7,\"763\":4,\"764\":3}}],[\"defaultpromise\",{\"1\":{\"765\":10}}],[\"defaultpromise<integer>\",{\"1\":{\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1}}],[\"defaultpromise<>\",{\"1\":{\"737\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1}}],[\"defaultpromise<object>\",{\"1\":{\"737\":1}}],[\"defaultmaxmessagesrecvbytebufallocator\",{\"1\":{\"744\":1}}],[\"defaultchannelpipeline\",{\"1\":{\"740\":1,\"743\":1,\"775\":1}}],[\"defaultchannelpromise\",{\"1\":{\"740\":1}}],[\"defaultchannelconfig\",{\"1\":{\"726\":1}}],[\"defaultcharset\",{\"1\":{\"710\":1,\"748\":2,\"766\":1,\"794\":2,\"840\":3,\"843\":1,\"859\":2}}],[\"defaultserversocketchannelconfig\",{\"1\":{\"726\":1}}],[\"defaultspecificskin和heimaspecificskin\",{\"1\":{\"72\":1}}],[\"defaultbuffersize\",{\"1\":{\"719\":1}}],[\"defaultfullhttpresponse\",{\"1\":{\"711\":2}}],[\"defaultvalue\",{\"1\":{\"399\":2,\"1165\":1,\"1168\":1,\"1172\":1,\"1362\":1}}],[\"default\",{\"1\":{\"92\":1,\"278\":1,\"290\":1,\"340\":1,\"365\":2,\"423\":2,\"444\":2,\"713\":1,\"741\":1,\"748\":2,\"768\":1,\"769\":2,\"776\":2,\"779\":4,\"780\":2,\"870\":1,\"875\":1,\"919\":1,\"926\":1,\"963\":1,\"1072\":3,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1164\":2,\"1172\":4,\"1174\":2,\"1525\":2}}],[\"delegate\",{\"1\":{\"1370\":1}}],[\"deletion\",{\"1\":{\"1056\":1}}],[\"deleteonexit\",{\"1\":{\"1449\":1}}],[\"deleteobserver\",{\"1\":{\"47\":1}}],[\"deletebyid\",{\"1\":{\"1089\":1}}],[\"deleteindex\",{\"1\":{\"1089\":2}}],[\"deleteindexrequest\",{\"1\":{\"1072\":2}}],[\"delete结尾\",{\"1\":{\"1056\":1}}],[\"deletesnapshot\",{\"1\":{\"914\":1}}],[\"deleted\",{\"1\":{\"480\":1}}],[\"delete等\",{\"1\":{\"293\":1}}],[\"delete目录的前缀是delete\",{\"1\":{\"292\":1}}],[\"delete\",{\"0\":{\"299\":1},\"1\":{\"270\":1,\"293\":1,\"298\":1,\"482\":2,\"493\":2,\"822\":4,\"869\":1,\"972\":1,\"973\":1,\"974\":1,\"988\":1,\"1004\":1,\"1072\":1,\"1122\":1,\"1127\":1,\"1129\":1,\"1142\":1,\"1144\":1,\"1205\":1,\"1230\":3}}],[\"delete操作\",{\"1\":{\"268\":1,\"298\":1}}],[\"delaynanos\",{\"1\":{\"742\":1}}],[\"delayed等\",{\"1\":{\"480\":1}}],[\"del\",{\"1\":{\"523\":1,\"1141\":1,\"1146\":1,\"1151\":1,\"1205\":6}}],[\"delta文件详解\",{\"0\":{\"293\":1}}],[\"delta\",{\"1\":{\"292\":1,\"293\":3}}],[\"delim\",{\"1\":{\"279\":1}}],[\"delimited\",{\"1\":{\"252\":1,\"256\":1,\"260\":1,\"261\":1,\"262\":1,\"266\":1,\"281\":1,\"285\":1,\"287\":1,\"290\":2,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1}}],[\"delimited|serde\",{\"1\":{\"251\":1}}],[\"derby和metastore都会启动\",{\"1\":{\"242\":1}}],[\"derby\",{\"1\":{\"241\":1}}],[\"derby中\",{\"1\":{\"232\":1}}],[\"deoldify\",{\"1\":{\"125\":1}}],[\"deepai\",{\"1\":{\"125\":1}}],[\"deptno\",{\"1\":{\"404\":3}}],[\"dept作为分区字段值\",{\"1\":{\"289\":1}}],[\"dept\",{\"1\":{\"276\":1,\"280\":1,\"287\":1,\"289\":1,\"340\":1,\"351\":1,\"357\":5}}],[\"depth\",{\"1\":{\"69\":1}}],[\"department\",{\"1\":{\"272\":2}}],[\"depencies>中\",{\"1\":{\"105\":1}}],[\"dependencies=web\",{\"1\":{\"1440\":1}}],[\"dependencies\",{\"1\":{\"442\":1}}],[\"dependencies标签下引入开发需要的jar包\",{\"1\":{\"102\":1}}],[\"dependencies>\",{\"1\":{\"99\":2,\"107\":2,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"344\":1,\"957\":1,\"1022\":1,\"1070\":1,\"1087\":1,\"1219\":1}}],[\"dependencydescriptor\",{\"1\":{\"1267\":2}}],[\"dependencymanagement>\",{\"1\":{\"107\":1,\"112\":1}}],[\"dependencymanagement\",{\"1\":{\"100\":3}}],[\"dependency\",{\"1\":{\"100\":1,\"441\":1}}],[\"dependency>\",{\"1\":{\"60\":1,\"99\":2,\"101\":1,\"104\":2,\"105\":1,\"107\":10,\"112\":4,\"113\":4,\"114\":1,\"115\":1,\"344\":2,\"783\":1,\"957\":5,\"985\":2,\"1022\":8,\"1070\":9,\"1087\":7,\"1137\":1,\"1150\":1,\"1172\":3,\"1213\":2,\"1219\":5,\"1236\":2,\"1442\":1,\"1466\":1,\"1473\":1}}],[\"deploy\",{\"1\":{\"95\":1}}],[\"designmode\",{\"0\":{\"1533\":1}}],[\"deserialization\",{\"1\":{\"956\":1}}],[\"deserialize\",{\"1\":{\"723\":4}}],[\"deserializer\",{\"1\":{\"250\":1,\"1024\":2}}],[\"deserializer的简称\",{\"1\":{\"249\":1}}],[\"destructionawarebeanpostprocessor\",{\"1\":{\"1505\":1}}],[\"destroybean\",{\"1\":{\"1290\":1}}],[\"destroymethod\",{\"1\":{\"1289\":1}}],[\"dest\",{\"1\":{\"662\":3}}],[\"descriptor\",{\"1\":{\"677\":1}}],[\"description>\",{\"1\":{\"1219\":1}}],[\"description=redis\",{\"1\":{\"1197\":1}}],[\"description\",{\"1\":{\"442\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"1525\":4}}],[\"describe\",{\"1\":{\"276\":1,\"278\":2,\"279\":1,\"328\":2}}],[\"desc\",{\"1\":{\"69\":6,\"265\":1,\"278\":1,\"310\":1,\"313\":1,\"315\":1,\"348\":1,\"349\":2,\"351\":1,\"358\":1,\"363\":4,\"364\":1,\"404\":1,\"423\":1,\"452\":1,\"458\":1,\"1089\":1}}],[\"desktop\",{\"1\":{\"54\":2,\"68\":2}}],[\"dessert\",{\"1\":{\"39\":3}}],[\"dessertfactory\",{\"1\":{\"39\":3}}],[\"demo6\",{\"1\":{\"1299\":1,\"1301\":1}}],[\"demo<\",{\"1\":{\"1219\":2}}],[\"demo\",{\"1\":{\"43\":1,\"1294\":5}}],[\"jms\",{\"1\":{\"1499\":1}}],[\"jmx\",{\"0\":{\"1045\":1},\"1\":{\"1045\":3}}],[\"jks<\",{\"1\":{\"936\":1}}],[\"jn进程也会同时记录edits\",{\"1\":{\"886\":1}}],[\"jn\",{\"0\":{\"886\":1},\"1\":{\"884\":1,\"886\":1}}],[\"jnoobj​⋅\",{\"1\":{\"140\":1}}],[\"jedispoolconfig\",{\"1\":{\"1215\":2}}],[\"jedispool\",{\"1\":{\"1215\":5}}],[\"jedisconnectionfacotry\",{\"1\":{\"1215\":2,\"1216\":1}}],[\"jedisconnectionfactory\",{\"1\":{\"1213\":1}}],[\"jedis本身是线程不安全的\",{\"1\":{\"1214\":1}}],[\"jedis连接池\",{\"0\":{\"1214\":1}}],[\"jedis快速入门\",{\"0\":{\"1213\":1}}],[\"jedis和lettuce\",{\"1\":{\"1212\":1}}],[\"jedis\",{\"0\":{\"1212\":1},\"1\":{\"1213\":15,\"1215\":1,\"1216\":6}}],[\"jenkov\",{\"1\":{\"841\":1}}],[\"jemalloc\",{\"1\":{\"770\":1}}],[\"jep291\",{\"1\":{\"640\":1}}],[\"jep214\",{\"1\":{\"638\":1}}],[\"jep363\",{\"1\":{\"638\":1,\"640\":1}}],[\"jep366\",{\"1\":{\"638\":1}}],[\"jep173\",{\"1\":{\"638\":1}}],[\"jc\",{\"1\":{\"991\":7}}],[\"jctools\",{\"1\":{\"741\":1}}],[\"jconsole有死锁检测功能\",{\"1\":{\"551\":1}}],[\"jjjjjjjj|\",{\"1\":{\"699\":1}}],[\"jjjj\",{\"1\":{\"697\":1}}],[\"j−k∗v\",{\"1\":{\"649\":1}}],[\"j++\",{\"1\":{\"648\":1,\"649\":3,\"697\":1,\"698\":1,\"699\":1,\"799\":6,\"840\":1,\"988\":1}}],[\"jsp\",{\"1\":{\"1438\":1,\"1441\":4,\"1442\":1,\"1443\":2}}],[\"jstack\",{\"1\":{\"551\":1}}],[\"json格式的数据\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"jsonuser\",{\"1\":{\"1223\":2}}],[\"jsonutil\",{\"1\":{\"1122\":1,\"1124\":2,\"1127\":2,\"1128\":3,\"1129\":7}}],[\"jsonprocessingexception\",{\"1\":{\"1223\":1}}],[\"json序列化器会将类的class类型写入json结果中\",{\"1\":{\"1223\":1}}],[\"jsonredisserializer\",{\"1\":{\"1222\":3}}],[\"jsonobject\",{\"1\":{\"1128\":1}}],[\"jsonserde\",{\"1\":{\"397\":1}}],[\"jsonserde等\",{\"1\":{\"374\":1}}],[\"json函数\",{\"0\":{\"394\":1}}],[\"json数据处理\",{\"0\":{\"392\":1}}],[\"json解析函数\",{\"1\":{\"336\":2}}],[\"json\",{\"0\":{\"395\":1,\"396\":1,\"397\":1},\"1\":{\"336\":4,\"393\":3,\"395\":11,\"396\":7,\"397\":2,\"712\":1,\"713\":1,\"714\":1,\"723\":4,\"1073\":5,\"1129\":7,\"1217\":1,\"1223\":2,\"1438\":1,\"1444\":1,\"1462\":1}}],[\"json等处理\",{\"1\":{\"91\":1}}],[\"j\",{\"1\":{\"496\":4,\"645\":9,\"646\":4,\"648\":16,\"649\":18,\"697\":3,\"698\":2,\"699\":2,\"746\":1,\"776\":1,\"799\":16,\"840\":2,\"988\":3,\"1180\":4}}],[\"journal\",{\"0\":{\"886\":1},\"1\":{\"884\":1,\"886\":1}}],[\"join一样\",{\"1\":{\"990\":1}}],[\"join处理完之后\",{\"1\":{\"988\":1}}],[\"join操作\",{\"0\":{\"987\":1}}],[\"join操作时\",{\"1\":{\"467\":1}}],[\"joinmember\",{\"1\":{\"701\":1,\"704\":1}}],[\"join和future采用的就是该模式\",{\"1\":{\"547\":1}}],[\"join和reduce\",{\"1\":{\"470\":1}}],[\"join中产生数据倾斜的问题\",{\"1\":{\"470\":1}}],[\"join进行合并\",{\"1\":{\"470\":1}}],[\"join是指在mapper任务中加载特定数据集\",{\"1\":{\"990\":1}}],[\"join是hive中一种专门为了避免数据倾斜而设计的特殊的join过程\",{\"1\":{\"470\":1}}],[\"join是数据分析处理过程中必不可少的操作\",{\"1\":{\"447\":1}}],[\"join来实现\",{\"1\":{\"467\":1,\"470\":2}}],[\"join来实现join过程\",{\"1\":{\"448\":1}}],[\"join的两个程序\",{\"1\":{\"991\":1}}],[\"join的结果进行union合并\",{\"1\":{\"470\":1}}],[\"join的结果和reduce\",{\"1\":{\"470\":1}}],[\"join的需求\",{\"1\":{\"467\":1}}],[\"join的产生\",{\"1\":{\"467\":1}}],[\"join的底层是通过mapreduce来实现的\",{\"1\":{\"447\":1}}],[\"join=true\",{\"1\":{\"448\":1,\"450\":1}}],[\"join=join\",{\"1\":{\"320\":1}}],[\"join等\",{\"1\":{\"447\":1}}],[\"join优化\",{\"0\":{\"447\":1}}],[\"join语句等等\",{\"1\":{\"446\":1}}],[\"join字段\",{\"1\":{\"420\":1,\"450\":2}}],[\"join对关联键\",{\"1\":{\"420\":1}}],[\"join在where条件之前进行\",{\"1\":{\"326\":1}}],[\"join使用注意事项\",{\"0\":{\"326\":1}}],[\"join慎用\",{\"1\":{\"325\":1}}],[\"join之后只返回左表的结果\",{\"1\":{\"324\":1}}],[\"join时的倾斜\",{\"0\":{\"467\":1}}],[\"join时的最后一个表会通过reducer流式传输\",{\"1\":{\"326\":1}}],[\"join时以右表的全部数据为准\",{\"1\":{\"322\":1}}],[\"join时以左表的全部数据为准\",{\"1\":{\"321\":1}}],[\"join时可以提高mr程序效率\",{\"1\":{\"263\":1}}],[\"join\",{\"0\":{\"320\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":1,\"325\":1,\"448\":1,\"449\":1,\"450\":1,\"468\":1,\"469\":1,\"470\":1,\"988\":1,\"990\":1},\"1\":{\"320\":3,\"321\":4,\"322\":4,\"323\":3,\"324\":5,\"325\":4,\"326\":14,\"409\":1,\"447\":2,\"448\":1,\"449\":3,\"450\":3,\"460\":2,\"461\":4,\"467\":2,\"469\":2,\"493\":1,\"534\":1,\"547\":1,\"717\":1,\"718\":1,\"991\":4,\"1162\":1,\"1168\":1,\"1172\":1,\"1230\":1}}],[\"join连接操作\",{\"0\":{\"319\":1}}],[\"job2\",{\"1\":{\"991\":11}}],[\"job1\",{\"1\":{\"991\":11}}],[\"jobcontrol\",{\"1\":{\"991\":2}}],[\"jobcontrol类实现了线程runnable接口\",{\"1\":{\"991\":1}}],[\"jobcontrol类\",{\"1\":{\"991\":1}}],[\"jobconf\",{\"1\":{\"968\":1}}],[\"jobclient\",{\"1\":{\"949\":1}}],[\"job名字\",{\"1\":{\"962\":1}}],[\"jobmanager和\",{\"1\":{\"951\":1}}],[\"job数据量大的情况\",{\"1\":{\"445\":1}}],[\"job作业执行优化\",{\"0\":{\"439\":1}}],[\"job\",{\"1\":{\"167\":1,\"313\":2,\"404\":1,\"445\":1,\"962\":27,\"968\":2,\"970\":1,\"972\":13,\"973\":15,\"974\":14,\"976\":1,\"977\":1,\"985\":12,\"986\":15,\"988\":14,\"989\":3,\"990\":2,\"991\":5}}],[\"jobj​⋅\",{\"1\":{\"140\":2}}],[\"jpg\",{\"1\":{\"117\":1,\"1089\":2}}],[\"juc\",{\"1\":{\"562\":1,\"756\":1}}],[\"juejin\",{\"1\":{\"503\":1,\"1179\":1,\"1532\":1}}],[\"junyanz\",{\"1\":{\"117\":1,\"121\":1,\"131\":1}}],[\"junit\",{\"1\":{\"99\":2,\"100\":1,\"110\":1,\"112\":5,\"113\":1,\"1213\":1}}],[\"jupiter<\",{\"1\":{\"112\":1,\"113\":1,\"1213\":2}}],[\"jupiter\",{\"1\":{\"112\":3,\"113\":1}}],[\"jdbc\",{\"1\":{\"100\":3,\"232\":1,\"985\":2,\"986\":2,\"1046\":2,\"1236\":3,\"1454\":2,\"1456\":1,\"1499\":3}}],[\"jdkdynamicaopproxy\",{\"1\":{\"1325\":2}}],[\"jdkproxydemo\",{\"1\":{\"1304\":1}}],[\"jdk环境\",{\"1\":{\"878\":1}}],[\"jdk7\",{\"1\":{\"821\":1}}],[\"jdk7引入了asynchronous\",{\"1\":{\"611\":1}}],[\"jdk9新特性\",{\"1\":{\"640\":1}}],[\"jdk9废弃\",{\"1\":{\"638\":2}}],[\"jdk8新特性\",{\"0\":{\"613\":1}}],[\"jdk提供了四种实现\",{\"1\":{\"573\":1}}],[\"jdk中各种阻塞队列\",{\"1\":{\"548\":1}}],[\"jdk中\",{\"1\":{\"547\":1}}],[\"jdk中的实现类关系结构中可以看出\",{\"1\":{\"9\":1}}],[\"jdk>\",{\"1\":{\"92\":1}}],[\"jdk代理效率高于cglib代理\",{\"1\":{\"61\":1}}],[\"jdk代理效率高于cglib代理效率\",{\"1\":{\"61\":1}}],[\"jdk代理和cglib代理\",{\"1\":{\"61\":1}}],[\"jdk14新特性\",{\"1\":{\"640\":1}}],[\"jdk14中\",{\"1\":{\"638\":2}}],[\"jdk17\",{\"1\":{\"112\":1}}],[\"jdk1\",{\"1\":{\"61\":3,\"607\":1,\"612\":3,\"822\":2,\"1046\":1}}],[\"jdk\",{\"0\":{\"640\":1,\"757\":1,\"1304\":1,\"1308\":1,\"1309\":1,\"1322\":1},\"1\":{\"59\":3,\"100\":1,\"600\":2,\"605\":3,\"712\":1,\"713\":1,\"714\":1,\"723\":1,\"756\":3,\"847\":1,\"1046\":1,\"1243\":2,\"1292\":1,\"1296\":1,\"1305\":1,\"1306\":1,\"1309\":1,\"1313\":1,\"1317\":2,\"1325\":1,\"1340\":1}}],[\"jdk动态代理方式\",{\"1\":{\"59\":2}}],[\"jdk动态代理\",{\"0\":{\"59\":1}}],[\"jdk给出的自身实现\",{\"1\":{\"9\":1}}],[\"jdk源码解析\",{\"0\":{\"9\":1,\"43\":1,\"70\":1,\"88\":1}}],[\"jasper<\",{\"1\":{\"1442\":1}}],[\"jasper\",{\"1\":{\"1442\":1,\"1443\":1}}],[\"jad\",{\"1\":{\"1310\":1,\"1313\":1}}],[\"ja\",{\"1\":{\"1244\":1}}],[\"japanese\",{\"1\":{\"1244\":1}}],[\"jack\",{\"1\":{\"1146\":5,\"1206\":6,\"1207\":1,\"1213\":1}}],[\"jackson依赖\",{\"1\":{\"1219\":1}}],[\"jackson\",{\"1\":{\"104\":3,\"112\":4,\"113\":1,\"1070\":1,\"1219\":1}}],[\"jackson需要三个依赖\",{\"1\":{\"104\":1}}],[\"jantic\",{\"1\":{\"125\":1}}],[\"jar包等\",{\"1\":{\"989\":1}}],[\"jar包中的string类\",{\"1\":{\"624\":1}}],[\"jar包中java\",{\"1\":{\"624\":1}}],[\"jar添加进来\",{\"1\":{\"343\":1}}],[\"jar指的是普通的java项目打包方式\",{\"1\":{\"98\":1}}],[\"jar\",{\"1\":{\"98\":1,\"104\":1,\"107\":3,\"344\":2,\"822\":2,\"953\":1,\"957\":1,\"962\":2,\"1013\":1,\"1443\":1,\"1447\":1,\"1476\":1}}],[\"javaguide\",{\"1\":{\"1532\":1}}],[\"javaagent实现\",{\"1\":{\"1508\":1}}],[\"javatype=\",{\"1\":{\"1230\":1}}],[\"java代码\",{\"1\":{\"1147\":1}}],[\"java8\",{\"1\":{\"1136\":1}}],[\"javascript\",{\"1\":{\"1063\":1}}],[\"java数据类型\",{\"1\":{\"956\":1}}],[\"java堆内存\",{\"1\":{\"801\":1}}],[\"java堆区所占的内存大小\",{\"1\":{\"637\":1}}],[\"javaee\",{\"1\":{\"791\":1}}],[\"javachannel\",{\"1\":{\"740\":2}}],[\"javaversion\",{\"1\":{\"740\":1}}],[\"java虚拟机的堆内存设置不够\",{\"1\":{\"636\":1}}],[\"java对象的回收方式\",{\"1\":{\"633\":1}}],[\"java对象头详细信息在jvm中有描述\",{\"1\":{\"540\":1}}],[\"java的全类名加上对应的方法名\",{\"1\":{\"1230\":1}}],[\"java的垃圾回收器都有哪些\",{\"1\":{\"633\":1}}],[\"java的nio就是reactor\",{\"1\":{\"611\":1}}],[\"java的nio使用了非阻塞的i\",{\"1\":{\"610\":1}}],[\"java拥有四大内置函数式接口\",{\"1\":{\"614\":1}}],[\"java提供了一系列改进的i\",{\"1\":{\"610\":1}}],[\"java提供的动态代理相关类\",{\"1\":{\"59\":1}}],[\"java基础\",{\"0\":{\"594\":1}}],[\"java同步系列之aqs终篇改编\",{\"1\":{\"580\":1}}],[\"java进程才会结束\",{\"1\":{\"537\":1}}],[\"java并发\",{\"0\":{\"531\":1}}],[\"java编译插件\",{\"1\":{\"102\":1}}],[\"java<\",{\"1\":{\"102\":1,\"105\":1,\"957\":1,\"985\":1}}],[\"java下的某个包中\",{\"1\":{\"102\":1}}],[\"java中thread\",{\"1\":{\"538\":1}}],[\"java中优先级最大10\",{\"1\":{\"535\":1}}],[\"java中提供了一个动态代理类proxy\",{\"1\":{\"59\":1}}],[\"java中的fast\",{\"1\":{\"602\":1}}],[\"java中的代理按照代理类生成时机不同又分为静态代理和动态代理\",{\"1\":{\"56\":1}}],[\"java中的object类中提供了\",{\"1\":{\"51\":1}}],[\"java\",{\"0\":{\"1022\":1,\"1542\":1},\"1\":{\"23\":5,\"59\":10,\"64\":1,\"70\":4,\"91\":1,\"272\":1,\"343\":4,\"344\":1,\"538\":1,\"567\":1,\"595\":1,\"609\":1,\"610\":2,\"623\":1,\"633\":1,\"648\":2,\"723\":8,\"726\":1,\"740\":1,\"756\":1,\"762\":13,\"763\":2,\"764\":2,\"765\":22,\"775\":3,\"791\":1,\"795\":1,\"805\":1,\"822\":2,\"836\":2,\"841\":1,\"854\":4,\"855\":8,\"936\":1,\"958\":1,\"960\":1,\"962\":2,\"972\":4,\"973\":4,\"974\":5,\"985\":3,\"986\":3,\"988\":4,\"990\":2,\"991\":5,\"999\":2,\"1045\":1,\"1046\":3,\"1149\":1,\"1176\":1,\"1219\":1,\"1243\":2,\"1245\":1,\"1285\":3,\"1292\":2,\"1296\":2,\"1300\":2,\"1309\":2,\"1313\":3,\"1317\":2,\"1379\":1,\"1441\":1,\"1499\":2}}],[\"jvm会自动回退以默认gc方式启动jvm\",{\"1\":{\"640\":1}}],[\"jvm不会报错\",{\"1\":{\"640\":1}}],[\"jvm不会进行释放\",{\"1\":{\"445\":1}}],[\"jvm有哪三种垃圾回收器\",{\"1\":{\"633\":1}}],[\"jvm怎么回收内存\",{\"1\":{\"633\":1}}],[\"jvm在进行gc时\",{\"1\":{\"628\":1}}],[\"jvm的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令\",{\"1\":{\"625\":1}}],[\"jvm重用可以使得jvm实例在同一个job中重新使用n次\",{\"1\":{\"445\":1}}],[\"jvm重用\",{\"0\":{\"445\":1}}],[\"jvm\",{\"0\":{\"622\":1},\"1\":{\"66\":1,\"445\":1,\"633\":2,\"769\":1,\"775\":1,\"826\":2,\"847\":1,\"855\":3}}],[\"都将启用事务功能\",{\"1\":{\"1515\":1}}],[\"都将无法再获取互斥锁\",{\"1\":{\"582\":1}}],[\"都由它的实现类提供\",{\"1\":{\"1243\":1}}],[\"都没查到\",{\"1\":{\"1126\":1}}],[\"都操作缓存\",{\"1\":{\"1121\":1}}],[\"都拥有\",{\"1\":{\"1113\":1}}],[\"都认为对方状态是好的\",{\"1\":{\"882\":1}}],[\"都要使用到这个名字\",{\"1\":{\"1061\":1}}],[\"都要考虑到这两点\",{\"1\":{\"882\":1}}],[\"都要进入队列等待唤醒\",{\"1\":{\"588\":1}}],[\"都与原始\",{\"1\":{\"778\":1}}],[\"都实现了\",{\"1\":{\"775\":1,\"1322\":1}}],[\"都会产生一个新的bean\",{\"1\":{\"1504\":1}}],[\"都会有问题\",{\"1\":{\"1290\":1}}],[\"都会有一个加密区域秘钥\",{\"1\":{\"931\":1}}],[\"都会保存在自己的邮箱中\",{\"1\":{\"1166\":1}}],[\"都会同步给其他的tomcat服务器的session\",{\"1\":{\"1102\":1}}],[\"都会将用户信息保存到session中\",{\"1\":{\"1098\":1}}],[\"都会协调在一起共同参与\",{\"1\":{\"1038\":1}}],[\"都会分配一个唯一的pid\",{\"1\":{\"1029\":1}}],[\"都会触发\",{\"1\":{\"833\":1}}],[\"都会清除\",{\"1\":{\"804\":1}}],[\"都会跳过\",{\"1\":{\"741\":1}}],[\"都会一同结束\",{\"1\":{\"537\":1}}],[\"都毫无例外地建立在离散分配存储管理方式的基础上\",{\"1\":{\"689\":1}}],[\"都能保证数据的唯一性\",{\"1\":{\"604\":1}}],[\"都不能算是加锁成功\",{\"1\":{\"1153\":1}}],[\"都不能被实例化\",{\"1\":{\"595\":1}}],[\"都不存在订单\",{\"1\":{\"1137\":1}}],[\"都不允许出现任何大写字母\",{\"1\":{\"480\":1}}],[\"都返回\",{\"1\":{\"529\":1}}],[\"都进行update\",{\"1\":{\"483\":1}}],[\"都有可能会阻塞redis\",{\"1\":{\"523\":1}}],[\"都有两个文件\",{\"1\":{\"293\":1}}],[\"都有对应的缺省配置\",{\"1\":{\"102\":1}}],[\"都内置启动了一个metastore\",{\"1\":{\"243\":1}}],[\"都是推迟其它\",{\"1\":{\"1297\":1}}],[\"都是它来实现\",{\"1\":{\"1245\":1}}],[\"都是常用命令\",{\"1\":{\"1206\":1}}],[\"都是\",{\"1\":{\"1161\":1,\"1240\":1}}],[\"都是先从获得当前用户的线程\",{\"1\":{\"1100\":1}}],[\"都是为对方是故障的\",{\"1\":{\"882\":1}}],[\"都是触发出站处理器的执行\",{\"1\":{\"766\":1}}],[\"都是不安全的\",{\"1\":{\"663\":1}}],[\"都是以处理二进制的方式来处理\",{\"1\":{\"663\":1}}],[\"都是以块为单位进行的\",{\"1\":{\"197\":1}}],[\"都是基于node数组+链表+红黑树\",{\"1\":{\"579\":1}}],[\"都是java\",{\"1\":{\"538\":1}}],[\"都是thread类的方法\",{\"1\":{\"532\":1}}],[\"都是对结果进行count\",{\"1\":{\"497\":1}}],[\"都是进程无法顺利向前推进的现象\",{\"1\":{\"175\":1}}],[\"都是咖啡\",{\"1\":{\"39\":1}}],[\"都无法向前推进的现象\",{\"1\":{\"175\":1}}],[\"都可以写成活的\",{\"1\":{\"1362\":1}}],[\"都可以使用的指令\",{\"1\":{\"1205\":1}}],[\"都可以\",{\"1\":{\"697\":1}}],[\"都可以有默认的实现方法\",{\"1\":{\"595\":1}}],[\"都可以包含抽象方法\",{\"1\":{\"595\":1}}],[\"都可\",{\"1\":{\"167\":1}}],[\"都可称为wrapper模式\",{\"1\":{\"10\":1}}],[\"都必须通过系统调用的方式向操作系统提出服务请求\",{\"1\":{\"158\":1}}],[\"都需要有一个线程对当前端口号进行监听\",{\"1\":{\"1100\":1}}],[\"都需要一个\",{\"1\":{\"843\":1}}],[\"都需要记录可能被切分的消息\",{\"1\":{\"841\":1}}],[\"都需要内核的拷贝动作\",{\"1\":{\"680\":1}}],[\"都需要全程加锁\",{\"1\":{\"590\":1}}],[\"都需要经过cpu\",{\"1\":{\"209\":1}}],[\"都需要配置自己的依赖信息\",{\"1\":{\"107\":1}}],[\"都需要增加一个具体类和对象实现工厂\",{\"1\":{\"23\":1}}],[\"屏蔽产品的具体实现\",{\"1\":{\"23\":1}}],[\"3a6f2de3\",{\"1\":{\"1294\":1}}],[\"3l\",{\"1\":{\"1089\":1}}],[\"3计算\",{\"1\":{\"875\":1}}],[\"3中表示数据块和奇偶校验块的数量\",{\"1\":{\"875\":1}}],[\"3中引入的命令行工具\",{\"1\":{\"874\":1}}],[\"3副本存储的弊端\",{\"1\":{\"875\":1}}],[\"3parts\",{\"1\":{\"807\":2,\"808\":1}}],[\"35\",{\"0\":{\"1426\":1},\"1\":{\"751\":5}}],[\"35f983a6\",{\"1\":{\"746\":2}}],[\"3500\",{\"1\":{\"536\":1}}],[\"3s\",{\"1\":{\"707\":2}}],[\"36524=0\",{\"1\":{\"882\":1}}],[\"36\",{\"0\":{\"1438\":1},\"1\":{\"699\":2,\"748\":2,\"750\":1,\"765\":1}}],[\"3b\",{\"1\":{\"698\":2}}],[\"3在尝试不成功后再次进入park状态\",{\"1\":{\"591\":1}}],[\"3节点\",{\"1\":{\"591\":1}}],[\"3竞争失败\",{\"1\":{\"591\":1}}],[\"37\",{\"0\":{\"1440\":1},\"1\":{\"699\":21}}],[\"37989980\",{\"1\":{\"543\":1,\"544\":1,\"545\":1,\"549\":1}}],[\"37541097\",{\"1\":{\"145\":1}}],[\"3天\",{\"1\":{\"364\":1}}],[\"3个维度\",{\"1\":{\"352\":1}}],[\"32<\",{\"1\":{\"957\":1,\"985\":1}}],[\"320k\",{\"1\":{\"826\":1}}],[\"32位机默认是1024个\",{\"1\":{\"680\":1}}],[\"32bit\",{\"1\":{\"540\":3,\"1131\":1}}],[\"32\",{\"0\":{\"1411\":1},\"1\":{\"339\":1,\"663\":1,\"680\":1,\"809\":1,\"826\":1,\"848\":1,\"1094\":1,\"1132\":1}}],[\"3得出5\",{\"1\":{\"331\":1}}],[\"3306\",{\"1\":{\"985\":1,\"986\":1,\"1046\":1,\"1236\":1}}],[\"3333\",{\"1\":{\"615\":1}}],[\"33\",{\"0\":{\"1418\":1},\"1\":{\"285\":1,\"332\":2,\"339\":4,\"340\":2,\"347\":1,\"615\":2,\"648\":2}}],[\"3361d94ab3623353f7997137296d8eb\",{\"1\":{\"186\":1}}],[\"3dd975466ed41bb250ad2f71beec3fb\",{\"1\":{\"187\":1}}],[\"31bit\",{\"1\":{\"1131\":1}}],[\"31\",{\"0\":{\"1407\":1},\"1\":{\"409\":1,\"761\":2}}],[\"31修改为新数据starttime的starttime\",{\"1\":{\"409\":1}}],[\"31等最大值来表示最新状态\",{\"1\":{\"405\":1}}],[\"31fd5ca9ccd980db93b6088ea0e1d58\",{\"1\":{\"187\":1}}],[\"314\",{\"1\":{\"81\":1}}],[\"3474980866\",{\"1\":{\"820\":1}}],[\"34795071\",{\"1\":{\"145\":1}}],[\"34\",{\"0\":{\"1422\":1},\"1\":{\"748\":1,\"762\":1}}],[\"3493\",{\"1\":{\"81\":3}}],[\"30s\",{\"1\":{\"1147\":1}}],[\"300\",{\"1\":{\"725\":1,\"1132\":2}}],[\"3000000\",{\"1\":{\"843\":1}}],[\"3000\",{\"1\":{\"593\":1}}],[\"30\",{\"0\":{\"1403\":1},\"1\":{\"337\":8,\"352\":1,\"616\":1,\"726\":2,\"750\":2,\"761\":1,\"762\":1,\"765\":2,\"1073\":2,\"1076\":1,\"1081\":1}}],[\"3080\",{\"1\":{\"81\":2}}],[\"3079\",{\"1\":{\"81\":1}}],[\"3=\",{\"1\":{\"73\":2}}],[\"3999\",{\"1\":{\"1089\":1,\"1186\":1}}],[\"3933365481995287\",{\"1\":{\"437\":1}}],[\"39\",{\"0\":{\"1444\":1},\"1\":{\"47\":1,\"783\":1,\"796\":17,\"836\":3}}],[\"384\",{\"1\":{\"343\":1,\"765\":2}}],[\"38\",{\"0\":{\"1441\":1},\"1\":{\"47\":1,\"748\":6,\"750\":1,\"765\":2}}],[\"3\",{\"0\":{\"99\":1,\"151\":1,\"155\":1,\"177\":1,\"196\":1,\"223\":1,\"227\":1,\"236\":1,\"238\":1,\"239\":1,\"240\":1,\"244\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":2,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":2,\"272\":1,\"276\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":2,\"281\":2,\"289\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"298\":2,\"304\":1,\"314\":1,\"322\":1,\"331\":1,\"338\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":1,\"348\":1,\"349\":2,\"350\":1,\"351\":1,\"352\":1,\"356\":2,\"357\":2,\"358\":2,\"359\":3,\"360\":2,\"361\":2,\"362\":2,\"365\":2,\"366\":1,\"367\":1,\"368\":1,\"369\":2,\"374\":1,\"379\":1,\"380\":1,\"381\":1,\"382\":1,\"383\":1,\"384\":1,\"385\":1,\"386\":2,\"387\":2,\"388\":2,\"389\":1,\"390\":1,\"391\":1,\"397\":1,\"403\":1,\"404\":1,\"409\":1,\"419\":1,\"420\":1,\"421\":1,\"422\":2,\"423\":1,\"424\":1,\"429\":1,\"434\":1,\"435\":1,\"436\":1,\"437\":2,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"442\":1,\"443\":1,\"444\":1,\"445\":1,\"446\":2,\"447\":2,\"448\":2,\"449\":2,\"450\":3,\"451\":1,\"452\":1,\"453\":1,\"454\":2,\"459\":1,\"460\":1,\"461\":1,\"462\":1,\"463\":1,\"467\":1,\"474\":1,\"727\":1,\"735\":1,\"770\":1,\"871\":1,\"872\":1,\"873\":1,\"874\":3,\"875\":2,\"880\":1,\"884\":1,\"896\":1,\"897\":1,\"902\":1,\"903\":2,\"914\":1,\"915\":1,\"916\":1,\"917\":1,\"918\":1,\"919\":1,\"920\":2,\"921\":2,\"922\":2,\"923\":2,\"924\":1,\"925\":1,\"926\":1,\"949\":1,\"953\":1,\"963\":1,\"971\":1,\"972\":1,\"973\":1,\"974\":2,\"987\":1,\"988\":1,\"989\":1,\"990\":2,\"1010\":1,\"1014\":1,\"1015\":1,\"1016\":1,\"1017\":2,\"1018\":1,\"1025\":1,\"1039\":1,\"1063\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1077\":2,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":1,\"1095\":1,\"1099\":1,\"1106\":1,\"1111\":1,\"1119\":1,\"1120\":1,\"1121\":1,\"1130\":1,\"1131\":1,\"1132\":1,\"1133\":2,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":1,\"1142\":1,\"1151\":1,\"1157\":1,\"1161\":1,\"1166\":1,\"1172\":1,\"1176\":1,\"1187\":1,\"1191\":1,\"1192\":1,\"1193\":1,\"1194\":2,\"1195\":1,\"1196\":1,\"1197\":1,\"1201\":1,\"1203\":1,\"1204\":1,\"1205\":1,\"1206\":2,\"1207\":1,\"1208\":1,\"1209\":1,\"1210\":1,\"1211\":1,\"1221\":1,\"1223\":1,\"1252\":1},\"1\":{\"23\":1,\"73\":2,\"81\":5,\"92\":1,\"160\":1,\"161\":1,\"162\":2,\"163\":4,\"167\":1,\"168\":2,\"175\":3,\"176\":2,\"178\":1,\"179\":2,\"184\":1,\"186\":1,\"237\":1,\"256\":1,\"279\":1,\"280\":1,\"283\":1,\"289\":1,\"290\":1,\"298\":1,\"315\":1,\"322\":1,\"329\":1,\"331\":2,\"332\":3,\"338\":8,\"340\":2,\"344\":2,\"351\":1,\"353\":3,\"354\":1,\"361\":1,\"363\":5,\"364\":2,\"369\":1,\"404\":1,\"433\":2,\"437\":1,\"459\":1,\"474\":1,\"480\":1,\"481\":2,\"482\":1,\"493\":1,\"526\":1,\"541\":1,\"571\":1,\"593\":3,\"614\":1,\"620\":1,\"663\":2,\"667\":1,\"668\":1,\"692\":7,\"693\":10,\"696\":1,\"697\":25,\"698\":23,\"699\":25,\"707\":1,\"709\":1,\"710\":1,\"713\":2,\"714\":2,\"717\":2,\"718\":3,\"723\":3,\"726\":1,\"737\":1,\"740\":14,\"743\":1,\"748\":12,\"753\":2,\"755\":2,\"757\":1,\"759\":1,\"765\":2,\"766\":8,\"772\":3,\"773\":1,\"774\":4,\"776\":7,\"779\":5,\"780\":4,\"784\":2,\"785\":2,\"792\":2,\"796\":1,\"799\":2,\"805\":2,\"807\":5,\"808\":2,\"826\":1,\"827\":1,\"836\":2,\"840\":1,\"843\":1,\"848\":1,\"854\":1,\"855\":1,\"857\":1,\"875\":6,\"876\":4,\"878\":2,\"879\":1,\"910\":1,\"936\":4,\"968\":1,\"972\":1,\"973\":2,\"985\":2,\"986\":1,\"988\":2,\"991\":1,\"997\":1,\"1022\":1,\"1072\":4,\"1073\":1,\"1077\":1,\"1089\":2,\"1099\":3,\"1100\":1,\"1107\":2,\"1111\":1,\"1122\":1,\"1124\":1,\"1127\":2,\"1128\":3,\"1129\":5,\"1132\":1,\"1134\":2,\"1137\":4,\"1142\":1,\"1146\":1,\"1150\":1,\"1152\":1,\"1155\":1,\"1156\":10,\"1157\":3,\"1161\":3,\"1162\":4,\"1167\":1,\"1168\":1,\"1170\":1,\"1171\":5,\"1172\":3,\"1174\":1,\"1175\":1,\"1176\":1,\"1205\":2,\"1206\":1,\"1208\":16,\"1209\":3,\"1210\":6,\"1213\":2,\"1215\":1,\"1230\":2,\"1289\":1,\"1445\":1,\"1447\":1,\"1449\":1}}],[\"2l\",{\"1\":{\"1089\":2}}],[\"2g\",{\"1\":{\"820\":1}}],[\"2b8\",{\"1\":{\"1236\":1}}],[\"2b\",{\"1\":{\"698\":2,\"699\":2}}],[\"241\",{\"1\":{\"998\":1,\"1046\":1}}],[\"24\",{\"0\":{\"1380\":1},\"1\":{\"692\":7,\"693\":4,\"748\":2,\"809\":1}}],[\"244m\",{\"1\":{\"435\":1}}],[\"2字节\",{\"1\":{\"665\":1}}],[\"25\",{\"0\":{\"1383\":1},\"1\":{\"748\":3}}],[\"250～253\",{\"1\":{\"666\":2}}],[\"254\",{\"1\":{\"665\":2,\"666\":5}}],[\"256\",{\"1\":{\"343\":1,\"694\":3,\"719\":1,\"799\":6}}],[\"232\",{\"1\":{\"676\":1}}],[\"23\",{\"0\":{\"1367\":1},\"1\":{\"615\":1,\"693\":3}}],[\"2个方法\",{\"1\":{\"719\":1}}],[\"2个和第\",{\"1\":{\"614\":1}}],[\"2个bucket的数据\",{\"1\":{\"369\":2}}],[\"29=512\",{\"1\":{\"773\":1}}],[\"29\",{\"0\":{\"1399\":1},\"1\":{\"571\":1}}],[\"2执行完同步代码块的内容\",{\"1\":{\"541\":1}}],[\"2执行synchronized\",{\"1\":{\"541\":1}}],[\"2上锁的过程中\",{\"1\":{\"541\":1}}],[\"2=\",{\"1\":{\"369\":1}}],[\"2家族算法加密\",{\"1\":{\"343\":1}}],[\"2222\",{\"1\":{\"615\":2}}],[\"224\",{\"1\":{\"343\":2}}],[\"22\",{\"0\":{\"1363\":1},\"1\":{\"285\":1,\"332\":2,\"337\":1,\"339\":4,\"340\":1,\"343\":2,\"347\":1,\"748\":30,\"750\":2,\"751\":5,\"1174\":1,\"1208\":2}}],[\"2271\",{\"1\":{\"265\":1}}],[\"225\",{\"1\":{\"265\":1}}],[\"2288\",{\"1\":{\"256\":1}}],[\"28\",{\"0\":{\"1395\":1},\"1\":{\"265\":5,\"307\":3,\"310\":1,\"337\":1,\"726\":2,\"876\":6,\"972\":1,\"974\":1,\"1021\":1}}],[\"288\",{\"1\":{\"256\":5}}],[\"2r\",{\"1\":{\"204\":1}}],[\"2^12\",{\"1\":{\"999\":2}}],[\"2^10\",{\"1\":{\"179\":1}}],[\"2^n\",{\"1\":{\"773\":1}}],[\"2^32个地址才能一一标识\",{\"1\":{\"179\":1}}],[\"2^32\",{\"1\":{\"179\":1,\"1174\":1}}],[\"2^30\",{\"1\":{\"179\":3}}],[\"2^20\",{\"1\":{\"179\":1}}],[\"2181\",{\"1\":{\"1020\":1,\"1046\":4}}],[\"2147483647\",{\"1\":{\"820\":1}}],[\"210=1024\",{\"1\":{\"773\":1}}],[\"212\",{\"1\":{\"765\":2}}],[\"21\",{\"0\":{\"173\":1,\"214\":1,\"1359\":1},\"1\":{\"726\":4,\"836\":6,\"1207\":1,\"1208\":1,\"1213\":1,\"1223\":1,\"1224\":1}}],[\"2+\",{\"1\":{\"140\":3}}],[\"26\",{\"0\":{\"1387\":1},\"1\":{\"668\":1}}],[\"26∗26\",{\"1\":{\"138\":1}}],[\"260612034\",{\"1\":{\"132\":1}}],[\"268行附近\",{\"1\":{\"92\":1}}],[\"2757\",{\"1\":{\"1021\":1}}],[\"27\",{\"0\":{\"1391\":1},\"1\":{\"748\":3,\"762\":1,\"765\":1}}],[\"27159510\",{\"1\":{\"126\":1}}],[\"27行\",{\"1\":{\"88\":1}}],[\"2<\",{\"1\":{\"60\":1,\"102\":1,\"112\":2,\"344\":2,\"1022\":1,\"1070\":2,\"1172\":1}}],[\"20l\",{\"1\":{\"1128\":1}}],[\"20b\",{\"1\":{\"693\":1}}],[\"20之间\",{\"1\":{\"445\":1}}],[\"2004\",{\"1\":{\"792\":1}}],[\"200ms\",{\"1\":{\"694\":1}}],[\"2000\",{\"1\":{\"551\":1,\"748\":1,\"750\":1,\"751\":1}}],[\"2009\",{\"1\":{\"337\":8}}],[\"200\",{\"1\":{\"336\":2,\"340\":2,\"1127\":1,\"1223\":2}}],[\"2008\",{\"1\":{\"280\":6,\"792\":1}}],[\"2001\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"2020年初武汉爆发了新型冠状病毒\",{\"1\":{\"1525\":1}}],[\"2020\",{\"1\":{\"726\":4}}],[\"2022\",{\"1\":{\"648\":2,\"999\":1,\"1132\":1}}],[\"202203\",{\"1\":{\"1176\":1}}],[\"20220610221431032\",{\"1\":{\"214\":1}}],[\"20220610221353573\",{\"1\":{\"214\":1}}],[\"20220610220150678\",{\"1\":{\"214\":1}}],[\"20220610220013207\",{\"1\":{\"214\":1}}],[\"20220610215848171\",{\"1\":{\"214\":1}}],[\"20220610215815431\",{\"1\":{\"214\":1}}],[\"20220610215055371\",{\"1\":{\"214\":1}}],[\"20220610214717158\",{\"1\":{\"214\":1}}],[\"20220610214210814\",{\"1\":{\"214\":1}}],[\"20220610213728733\",{\"1\":{\"214\":1}}],[\"20220610213442230\",{\"1\":{\"214\":1}}],[\"20220610213119470\",{\"1\":{\"214\":1}}],[\"20220610212917960\",{\"1\":{\"214\":1}}],[\"20220610212527979\",{\"1\":{\"213\":1}}],[\"20220610212414867\",{\"1\":{\"213\":1}}],[\"20220609102817435\",{\"1\":{\"1212\":1}}],[\"20220609104330037\",{\"1\":{\"213\":1}}],[\"20220609104233122\",{\"1\":{\"213\":1}}],[\"20220609104134198\",{\"1\":{\"213\":1}}],[\"20220609103942129\",{\"1\":{\"213\":1}}],[\"20220609103645775\",{\"1\":{\"213\":1}}],[\"20220609103338474\",{\"1\":{\"213\":1}}],[\"20220609101958603\",{\"1\":{\"212\":1}}],[\"20220609101720564\",{\"1\":{\"212\":1}}],[\"20220609101627441\",{\"1\":{\"212\":1}}],[\"20220609100750640\",{\"1\":{\"212\":1}}],[\"20220609095722677\",{\"1\":{\"212\":1}}],[\"20220609095427515\",{\"1\":{\"212\":1}}],[\"20220609095039255\",{\"1\":{\"212\":1}}],[\"20220608154426249\",{\"1\":{\"211\":1}}],[\"20220608153523239\",{\"1\":{\"210\":1}}],[\"20220608152211751\",{\"1\":{\"210\":1}}],[\"20220608150637422\",{\"1\":{\"210\":1}}],[\"20220608150624784\",{\"1\":{\"210\":1}}],[\"20220608150454000\",{\"1\":{\"210\":1}}],[\"20220608145040522\",{\"1\":{\"210\":1}}],[\"20220608144448647\",{\"1\":{\"209\":1}}],[\"20220608144250495\",{\"1\":{\"209\":1}}],[\"20220608144106793\",{\"1\":{\"209\":1}}],[\"20220608140914035\",{\"1\":{\"209\":1}}],[\"20220608133444265\",{\"1\":{\"209\":1}}],[\"20220608132930223\",{\"1\":{\"209\":1}}],[\"20220608110604462\",{\"1\":{\"208\":1}}],[\"20220608110542490\",{\"1\":{\"208\":1}}],[\"20220608105835197\",{\"1\":{\"208\":1}}],[\"20220608105259812\",{\"1\":{\"208\":1}}],[\"20220608104719687\",{\"1\":{\"207\":1}}],[\"20220608104632049\",{\"1\":{\"207\":1}}],[\"20220608104500993\",{\"1\":{\"207\":1}}],[\"20220608104012756\",{\"1\":{\"207\":1}}],[\"20220608103332891\",{\"1\":{\"206\":1}}],[\"20220608103307481\",{\"1\":{\"206\":1}}],[\"20220607113400305\",{\"1\":{\"206\":1}}],[\"20220607112703160\",{\"1\":{\"205\":1}}],[\"20220607112458312\",{\"1\":{\"205\":1}}],[\"20220607112210165\",{\"1\":{\"205\":1}}],[\"20220531223412094\",{\"1\":{\"205\":1}}],[\"20220531223117841\",{\"1\":{\"205\":1}}],[\"20220531201414435\",{\"1\":{\"205\":1}}],[\"20220531200459574\",{\"1\":{\"205\":1}}],[\"20220531115101881\",{\"1\":{\"204\":1}}],[\"20220531115047482\",{\"1\":{\"204\":1}}],[\"20220531114848212\",{\"1\":{\"204\":1}}],[\"20220531114605608\",{\"1\":{\"204\":1}}],[\"20220531114050634\",{\"1\":{\"204\":1}}],[\"20220531113725569\",{\"1\":{\"204\":1}}],[\"20220530224610670\",{\"1\":{\"204\":1}}],[\"20220530220453740\",{\"1\":{\"203\":1}}],[\"20220530220421638\",{\"1\":{\"203\":1}}],[\"20220530220354717\",{\"1\":{\"203\":1}}],[\"20220530220243511\",{\"1\":{\"203\":1}}],[\"20220530214532180\",{\"1\":{\"203\":1}}],[\"20220530214006044\",{\"1\":{\"202\":1}}],[\"20220530213756966\",{\"1\":{\"202\":1}}],[\"20220530212817688\",{\"1\":{\"201\":1}}],[\"20220530212539209\",{\"1\":{\"201\":1}}],[\"20220530212222775\",{\"1\":{\"201\":1}}],[\"20220530210923203\",{\"1\":{\"201\":1}}],[\"20220530210706405\",{\"1\":{\"201\":1}}],[\"20220530210456044\",{\"1\":{\"200\":1}}],[\"20220530210336394\",{\"1\":{\"200\":1}}],[\"20220530210148637\",{\"1\":{\"200\":1}}],[\"20220530205956876\",{\"1\":{\"200\":1}}],[\"20220530205021424\",{\"1\":{\"199\":1}}],[\"20220530204953730\",{\"1\":{\"199\":1}}],[\"20220530204655334\",{\"1\":{\"199\":1}}],[\"20220530202718681\",{\"1\":{\"199\":1}}],[\"20220530202619445\",{\"1\":{\"199\":1}}],[\"20220530201818071\",{\"1\":{\"199\":1}}],[\"20220530201342594\",{\"1\":{\"199\":1}}],[\"20220530201101036\",{\"1\":{\"199\":1}}],[\"20220530195918540\",{\"1\":{\"198\":1}}],[\"20220530195708965\",{\"1\":{\"198\":1}}],[\"20220530195308743\",{\"1\":{\"198\":1}}],[\"20220530195251537\",{\"1\":{\"198\":1}}],[\"20220530194728231\",{\"1\":{\"198\":1}}],[\"20220530193750402\",{\"1\":{\"198\":1}}],[\"20220530193511600\",{\"1\":{\"198\":1}}],[\"20220530193310886\",{\"1\":{\"198\":1}}],[\"20220530145757007\",{\"1\":{\"198\":1}}],[\"20220530145536142\",{\"1\":{\"198\":1}}],[\"20220530145400964\",{\"1\":{\"198\":1}}],[\"20220530145112083\",{\"1\":{\"198\":1}}],[\"20220530144632343\",{\"1\":{\"198\":1}}],[\"20220530144020397\",{\"1\":{\"197\":1}}],[\"20220530143548528\",{\"1\":{\"197\":1}}],[\"20220529222421721\",{\"1\":{\"197\":1}}],[\"20220529215048681\",{\"1\":{\"197\":1}}],[\"20220529214611813\",{\"1\":{\"197\":1}}],[\"20220529213416885\",{\"1\":{\"197\":1}}],[\"20220529212901703\",{\"1\":{\"197\":1}}],[\"20220529212212817\",{\"1\":{\"197\":1}}],[\"20220529212115224\",{\"1\":{\"197\":1}}],[\"20220524142132631\",{\"1\":{\"197\":2}}],[\"20220524134541056\",{\"1\":{\"197\":1}}],[\"20220524134337470\",{\"1\":{\"197\":1}}],[\"20220524133535599\",{\"1\":{\"197\":1}}],[\"20220522214148310\",{\"1\":{\"196\":1}}],[\"20220522214100918\",{\"1\":{\"196\":1}}],[\"20220522213950345\",{\"1\":{\"196\":1}}],[\"20220522213646590\",{\"1\":{\"196\":1}}],[\"20220522204512602\",{\"1\":{\"196\":1}}],[\"20220522203842838\",{\"1\":{\"196\":1}}],[\"20220522203520109\",{\"1\":{\"196\":1}}],[\"20220522202312578\",{\"1\":{\"196\":1}}],[\"20220522144900273\",{\"1\":{\"196\":1}}],[\"20220522144708324\",{\"1\":{\"196\":1}}],[\"20220522143959739\",{\"1\":{\"196\":1}}],[\"20220522142638847\",{\"1\":{\"195\":1}}],[\"20220522142404913\",{\"1\":{\"195\":1}}],[\"20220522142220989\",{\"1\":{\"195\":1}}],[\"20220522141420657\",{\"1\":{\"195\":1}}],[\"20220522135220091\",{\"1\":{\"195\":1}}],[\"20220522134405761\",{\"1\":{\"195\":1}}],[\"20220522132423543\",{\"1\":{\"195\":1}}],[\"20220522131805969\",{\"1\":{\"195\":1}}],[\"20220522131645588\",{\"1\":{\"195\":1}}],[\"20220522125936141\",{\"1\":{\"195\":1}}],[\"20220522125526046\",{\"1\":{\"195\":1}}],[\"20220521221810990\",{\"1\":{\"194\":1}}],[\"20220521221245106\",{\"1\":{\"194\":1}}],[\"20220521220941143\",{\"1\":{\"194\":1}}],[\"20220521220755154\",{\"1\":{\"194\":1}}],[\"20220521203500688\",{\"1\":{\"192\":1}}],[\"20220521202834105\",{\"1\":{\"192\":1}}],[\"20220521200544645\",{\"1\":{\"192\":1}}],[\"20220521141844658\",{\"1\":{\"191\":1}}],[\"20220521133823507\",{\"1\":{\"191\":1}}],[\"20220521132954826\",{\"1\":{\"191\":1}}],[\"20220521131041972\",{\"1\":{\"191\":1}}],[\"20220521130218677\",{\"1\":{\"191\":1}}],[\"20220515204850109\",{\"1\":{\"190\":1}}],[\"20220515204309592\",{\"1\":{\"190\":1}}],[\"20220515160709826\",{\"1\":{\"190\":1}}],[\"20220515155622275\",{\"1\":{\"189\":1}}],[\"20220515155525114\",{\"1\":{\"189\":1}}],[\"20220513193835377\",{\"1\":{\"188\":1}}],[\"20220513154609606\",{\"1\":{\"188\":1}}],[\"20220513153925493\",{\"1\":{\"188\":1}}],[\"20220513152328116\",{\"1\":{\"188\":1}}],[\"20220518144241994\",{\"1\":{\"142\":1}}],[\"20220518144159747\",{\"1\":{\"141\":1}}],[\"20220518142711194\",{\"1\":{\"135\":1}}],[\"20220508143045462\",{\"1\":{\"183\":1}}],[\"20211211082225509\",{\"1\":{\"1196\":1}}],[\"20211211080339076\",{\"1\":{\"1193\":1}}],[\"20210722132212837\",{\"1\":{\"889\":1}}],[\"20210721173918912\",{\"1\":{\"885\":1}}],[\"20210721173527315\",{\"1\":{\"884\":1}}],[\"20210906174525863\",{\"1\":{\"348\":1}}],[\"2021\",{\"1\":{\"265\":5,\"307\":3,\"310\":1,\"337\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1}}],[\"2013\",{\"1\":{\"792\":1}}],[\"20190101\",{\"1\":{\"460\":2}}],[\"2015年orc项目被apache项目基金会提升为apache顶级项目\",{\"1\":{\"430\":1}}],[\"2015年5月从apache孵化器里毕业成为apache顶级项目\",{\"1\":{\"429\":1}}],[\"20181201\",{\"1\":{\"460\":2}}],[\"2018\",{\"1\":{\"352\":2,\"359\":2}}],[\"2012\",{\"1\":{\"337\":4}}],[\"20111207\",{\"1\":{\"337\":1}}],[\"2011\",{\"1\":{\"337\":1,\"820\":1}}],[\"2014\",{\"1\":{\"124\":2}}],[\"2017\",{\"1\":{\"117\":1,\"120\":1,\"127\":1,\"130\":1}}],[\"20\",{\"0\":{\"172\":1,\"213\":1,\"1352\":1},\"1\":{\"47\":1,\"191\":1,\"298\":1,\"351\":1,\"481\":1,\"493\":1,\"567\":2,\"648\":2,\"693\":1,\"694\":2,\"726\":4,\"748\":16,\"751\":1,\"755\":1,\"1073\":1,\"1164\":3,\"1174\":2,\"1186\":1,\"1208\":5}}],[\"2\",{\"0\":{\"92\":1,\"95\":1,\"98\":1,\"105\":1,\"108\":1,\"111\":1,\"150\":1,\"154\":1,\"176\":1,\"195\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":2,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"232\":2,\"233\":2,\"234\":2,\"235\":3,\"236\":2,\"237\":2,\"238\":1,\"239\":1,\"240\":2,\"241\":1,\"242\":1,\"243\":2,\"244\":1,\"248\":1,\"251\":1,\"255\":1,\"257\":1,\"258\":1,\"259\":2,\"260\":2,\"261\":3,\"262\":2,\"263\":1,\"264\":1,\"265\":2,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":2,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":1,\"279\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":2,\"289\":1,\"290\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":2,\"303\":1,\"311\":1,\"312\":1,\"313\":2,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"321\":1,\"330\":1,\"333\":1,\"334\":1,\"335\":2,\"336\":2,\"337\":3,\"338\":2,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"343\":2,\"344\":1,\"348\":1,\"350\":1,\"351\":1,\"352\":2,\"358\":1,\"368\":1,\"373\":1,\"376\":1,\"377\":1,\"378\":2,\"382\":1,\"383\":1,\"384\":1,\"385\":2,\"388\":1,\"391\":1,\"394\":1,\"395\":1,\"396\":2,\"401\":1,\"402\":1,\"408\":1,\"415\":1,\"416\":1,\"417\":1,\"418\":2,\"421\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":2,\"429\":1,\"430\":1,\"431\":2,\"432\":2,\"433\":3,\"434\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"442\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":1,\"449\":1,\"453\":1,\"461\":1,\"467\":1,\"473\":1,\"726\":1,\"734\":1,\"769\":1,\"870\":1,\"873\":1,\"879\":1,\"883\":1,\"889\":1,\"895\":1,\"902\":1,\"910\":1,\"911\":1,\"912\":1,\"913\":2,\"914\":1,\"917\":1,\"918\":1,\"919\":2,\"920\":1,\"923\":1,\"936\":1,\"942\":1,\"943\":1,\"944\":1,\"948\":2,\"952\":1,\"957\":1,\"966\":1,\"969\":1,\"970\":1,\"973\":1,\"977\":1,\"980\":1,\"984\":1,\"985\":1,\"986\":2,\"989\":1,\"1009\":1,\"1011\":1,\"1012\":1,\"1013\":2,\"1016\":1,\"1021\":1,\"1024\":1,\"1029\":1,\"1036\":1,\"1046\":1,\"1062\":1,\"1069\":1,\"1070\":1,\"1071\":2,\"1072\":1,\"1073\":1,\"1076\":1,\"1088\":1,\"1094\":1,\"1098\":1,\"1105\":1,\"1110\":1,\"1112\":1,\"1113\":1,\"1114\":1,\"1115\":2,\"1116\":2,\"1117\":2,\"1118\":2,\"1119\":1,\"1120\":1,\"1121\":2,\"1122\":1,\"1123\":1,\"1124\":1,\"1125\":1,\"1126\":1,\"1127\":1,\"1128\":1,\"1129\":1,\"1132\":1,\"1141\":1,\"1150\":1,\"1156\":1,\"1160\":1,\"1165\":1,\"1171\":1,\"1175\":1,\"1180\":1,\"1183\":1,\"1184\":1,\"1185\":1,\"1186\":2,\"1187\":1,\"1188\":1,\"1189\":1,\"1190\":2,\"1191\":1,\"1192\":1,\"1193\":2,\"1194\":1,\"1195\":1,\"1196\":1,\"1197\":1,\"1198\":1,\"1199\":1,\"1200\":2,\"1201\":1,\"1202\":1,\"1205\":1,\"1214\":1,\"1215\":1,\"1216\":2,\"1220\":1,\"1222\":1,\"1245\":1},\"1\":{\"23\":1,\"60\":1,\"81\":3,\"92\":1,\"99\":2,\"101\":1,\"104\":1,\"105\":3,\"110\":2,\"112\":1,\"125\":2,\"140\":1,\"160\":1,\"161\":1,\"162\":3,\"163\":4,\"165\":1,\"167\":1,\"168\":2,\"175\":3,\"176\":3,\"178\":1,\"179\":2,\"182\":1,\"184\":2,\"186\":1,\"192\":1,\"204\":1,\"237\":1,\"256\":1,\"268\":1,\"271\":3,\"276\":1,\"279\":1,\"280\":1,\"285\":1,\"289\":1,\"290\":2,\"293\":1,\"298\":1,\"313\":1,\"315\":1,\"317\":1,\"321\":1,\"329\":1,\"332\":5,\"336\":5,\"339\":1,\"340\":1,\"351\":4,\"353\":4,\"354\":1,\"359\":1,\"363\":3,\"365\":4,\"367\":2,\"369\":1,\"400\":2,\"433\":2,\"437\":1,\"448\":2,\"459\":1,\"480\":2,\"481\":2,\"482\":1,\"483\":1,\"541\":1,\"554\":3,\"555\":3,\"562\":7,\"567\":1,\"579\":1,\"591\":1,\"593\":5,\"614\":2,\"616\":1,\"646\":2,\"663\":5,\"667\":1,\"669\":5,\"690\":2,\"692\":2,\"693\":3,\"696\":1,\"697\":18,\"698\":18,\"699\":18,\"702\":3,\"710\":1,\"713\":3,\"714\":2,\"717\":2,\"718\":3,\"723\":4,\"726\":6,\"737\":1,\"740\":18,\"743\":1,\"746\":2,\"748\":25,\"750\":2,\"751\":5,\"753\":6,\"754\":1,\"755\":1,\"757\":2,\"759\":1,\"765\":2,\"766\":8,\"768\":1,\"772\":3,\"773\":1,\"774\":4,\"776\":8,\"779\":5,\"780\":4,\"784\":2,\"785\":2,\"792\":1,\"796\":1,\"799\":1,\"805\":2,\"807\":3,\"808\":2,\"823\":2,\"826\":1,\"827\":1,\"836\":2,\"840\":3,\"846\":1,\"848\":1,\"855\":3,\"856\":1,\"857\":3,\"876\":11,\"972\":3,\"973\":2,\"974\":2,\"985\":2,\"986\":1,\"988\":3,\"990\":1,\"991\":1,\"997\":1,\"999\":1,\"1012\":12,\"1022\":1,\"1072\":4,\"1073\":6,\"1076\":1,\"1077\":1,\"1099\":2,\"1100\":1,\"1102\":1,\"1105\":1,\"1107\":2,\"1111\":1,\"1122\":3,\"1124\":2,\"1127\":2,\"1128\":4,\"1129\":7,\"1132\":5,\"1134\":2,\"1137\":6,\"1138\":1,\"1142\":1,\"1146\":1,\"1150\":1,\"1151\":4,\"1152\":1,\"1155\":1,\"1156\":9,\"1157\":9,\"1160\":1,\"1161\":4,\"1162\":5,\"1165\":1,\"1167\":2,\"1168\":9,\"1170\":3,\"1171\":2,\"1172\":4,\"1174\":1,\"1175\":1,\"1176\":1,\"1186\":1,\"1193\":2,\"1196\":2,\"1197\":1,\"1205\":5,\"1206\":5,\"1208\":9,\"1209\":3,\"1210\":5,\"1213\":2,\"1215\":1,\"1216\":1,\"1230\":2,\"1321\":2,\"1338\":1,\"1445\":1,\"1449\":1}}],[\"1~3\",{\"1\":{\"1438\":1}}],[\"1~4\",{\"1\":{\"797\":1}}],[\"1还需要手动设置mybatis\",{\"1\":{\"1230\":1}}],[\"1天内同一个用户多次访问该网站\",{\"1\":{\"1179\":1}}],[\"1的记录\",{\"1\":{\"1167\":1}}],[\"1不指定\",{\"1\":{\"1021\":1}}],[\"1不满足的话\",{\"1\":{\"976\":1}}],[\"1><hello\",{\"1\":{\"961\":5}}],[\"1><hadoop\",{\"1\":{\"961\":6}}],[\"1>形式的键值对进行输出\",{\"1\":{\"959\":1}}],[\"1>\",{\"1\":{\"958\":1,\"961\":4,\"983\":1}}],[\"1<\",{\"1\":{\"957\":1,\"1022\":1,\"1236\":1}}],[\"1年\",{\"1\":{\"882\":1}}],[\"1tb\",{\"1\":{\"841\":1}}],[\"1s\",{\"1\":{\"742\":1}}],[\"1bit\",{\"1\":{\"1131\":1}}],[\"1b\",{\"1\":{\"698\":1}}],[\"1−a\",{\"1\":{\"683\":1}}],[\"1−pc​\",{\"1\":{\"140\":1}}],[\"1l\",{\"1\":{\"579\":1,\"999\":4,\"1128\":1}}],[\"1分钟后释放线程\",{\"1\":{\"574\":1}}],[\"1是之前获得过锁\",{\"1\":{\"541\":1}}],[\"1是不会出现的\",{\"1\":{\"293\":1}}],[\"1表示删除\",{\"1\":{\"480\":1}}],[\"1表示是\",{\"1\":{\"480\":1}}],[\"1表示核心态\",{\"1\":{\"156\":1}}],[\"1个完全拷贝\",{\"1\":{\"1067\":1}}],[\"1个bucket的数据\",{\"1\":{\"369\":1}}],[\"1个记录\",{\"1\":{\"195\":1}}],[\"1加密\",{\"1\":{\"343\":1}}],[\"1次读磁盘操作\",{\"1\":{\"197\":1}}],[\"1g内存的机器上可以打开10万左右的连接\",{\"1\":{\"680\":1}}],[\"1g的内存大约能监听10万个端口\",{\"1\":{\"680\":1}}],[\"1g\",{\"1\":{\"179\":1}}],[\"1mb\",{\"1\":{\"663\":3,\"841\":1}}],[\"1m\",{\"1\":{\"179\":1}}],[\"1k\",{\"1\":{\"179\":1,\"368\":1}}],[\"19病例统计\",{\"0\":{\"971\":1}}],[\"192\",{\"1\":{\"697\":37,\"698\":32,\"699\":37,\"1150\":1,\"1213\":1,\"1215\":1,\"1220\":1}}],[\"1920\",{\"1\":{\"265\":1}}],[\"1970\",{\"1\":{\"365\":2,\"658\":1}}],[\"19fda1f5ff23a13b9e546eba14effc6\",{\"1\":{\"187\":1}}],[\"19\",{\"0\":{\"171\":1,\"212\":1,\"1347\":1},\"1\":{\"748\":8,\"751\":1,\"973\":1}}],[\"18\",{\"0\":{\"170\":1,\"192\":1,\"211\":1,\"1340\":1},\"1\":{\"268\":1,\"298\":1,\"337\":1,\"338\":1,\"339\":4,\"347\":1,\"437\":2,\"698\":19,\"751\":1,\"763\":4,\"1073\":2}}],[\"1804\",{\"1\":{\"144\":1}}],[\"1级队头的进程分配时间片\",{\"1\":{\"167\":1}}],[\"1479\",{\"1\":{\"822\":1}}],[\"14b\",{\"1\":{\"699\":1}}],[\"1460\",{\"1\":{\"694\":1}}],[\"140b\",{\"1\":{\"693\":1}}],[\"140\",{\"1\":{\"693\":1}}],[\"14行是synchronized中执行的部分\",{\"1\":{\"541\":1}}],[\"1415926\",{\"1\":{\"338\":6}}],[\"14\",{\"0\":{\"166\":1,\"188\":1,\"207\":1,\"1318\":1},\"1\":{\"341\":2,\"359\":1,\"692\":1,\"693\":1,\"696\":1,\"698\":19,\"699\":23,\"723\":1,\"876\":1,\"962\":2,\"1206\":1,\"1300\":1}}],[\"143747206\",{\"1\":{\"145\":1}}],[\"13600527634\",{\"1\":{\"1223\":1}}],[\"133\",{\"1\":{\"822\":1}}],[\"1327497219\",{\"1\":{\"820\":1}}],[\"13b\",{\"1\":{\"699\":1}}],[\"13888888888\",{\"1\":{\"344\":2}}],[\"1314\",{\"1\":{\"256\":1}}],[\"1310712259\",{\"1\":{\"197\":1}}],[\"13\",{\"0\":{\"165\":1,\"187\":1,\"206\":1,\"780\":1,\"1314\":1},\"1\":{\"337\":2,\"692\":1,\"693\":1,\"696\":1,\"710\":1,\"723\":1,\"857\":3,\"1150\":1,\"1206\":1}}],[\"1只能一气呵成\",{\"1\":{\"161\":1}}],[\"1653054945211\",{\"1\":{\"1223\":1}}],[\"1653054744832\",{\"1\":{\"1223\":1}}],[\"1653054602930\",{\"1\":{\"1223\":1}}],[\"1652976773295\",{\"1\":{\"1217\":1}}],[\"1652943604992\",{\"1\":{\"1209\":1}}],[\"1652942027719\",{\"1\":{\"1208\":1}}],[\"1652941995945\",{\"1\":{\"1208\":1}}],[\"1652941883537\",{\"1\":{\"1207\":1}}],[\"1652941631682\",{\"1\":{\"1207\":1}}],[\"1652890121291\",{\"1\":{\"1206\":1}}],[\"1652887865189\",{\"1\":{\"1205\":1}}],[\"1652887748279\",{\"1\":{\"1204\":1}}],[\"1652887648826\",{\"1\":{\"1204\":1}}],[\"1652887393157\",{\"1\":{\"1204\":1}}],[\"1652882668159\",{\"1\":{\"1182\":1}}],[\"1640995200l\",{\"1\":{\"1132\":1}}],[\"1649059688068l\",{\"1\":{\"999\":1}}],[\"1649059688068\",{\"1\":{\"999\":1}}],[\"16<\",{\"1\":{\"1022\":1}}],[\"16年\",{\"1\":{\"792\":1}}],[\"168\",{\"1\":{\"697\":37,\"698\":32,\"699\":37,\"1150\":1,\"1213\":1,\"1215\":1,\"1220\":1}}],[\"1688\",{\"1\":{\"256\":2}}],[\"16000\",{\"1\":{\"936\":3}}],[\"160b\",{\"1\":{\"692\":1}}],[\"160\",{\"1\":{\"692\":1,\"693\":1}}],[\"160行附近\",{\"1\":{\"92\":1}}],[\"16行出现异常时\",{\"1\":{\"541\":1}}],[\"1634\",{\"1\":{\"876\":2}}],[\"163\",{\"1\":{\"775\":1,\"1525\":1}}],[\"16384\",{\"1\":{\"528\":1}}],[\"1630916306\",{\"1\":{\"337\":1}}],[\"1618238391\",{\"1\":{\"337\":1}}],[\"1611\",{\"1\":{\"131\":1}}],[\"16\",{\"0\":{\"168\":1,\"190\":1,\"209\":1,\"1326\":1},\"1\":{\"338\":1,\"663\":1,\"692\":1,\"698\":1,\"699\":1,\"740\":1,\"744\":1,\"748\":1,\"768\":1,\"773\":3,\"774\":3,\"799\":5,\"801\":2,\"823\":2,\"826\":1,\"827\":1,\"836\":6,\"840\":3,\"859\":2,\"972\":1,\"999\":1,\"1300\":1,\"1313\":1}}],[\"124143\",{\"1\":{\"1223\":1}}],[\"12+5+5\",{\"1\":{\"999\":1}}],[\"12+5\",{\"1\":{\"999\":1}}],[\"12l\",{\"1\":{\"999\":1}}],[\"122\",{\"1\":{\"875\":2}}],[\"122kb\",{\"1\":{\"658\":1}}],[\"123321\",{\"1\":{\"1150\":1,\"1196\":2,\"1199\":1,\"1213\":1,\"1215\":1,\"1220\":1}}],[\"123\",{\"1\":{\"713\":1}}],[\"1234567890abcd\",{\"1\":{\"796\":1}}],[\"123456aa\",{\"1\":{\"330\":1}}],[\"123456\",{\"1\":{\"330\":1,\"985\":1,\"986\":1,\"1236\":2,\"1525\":2}}],[\"125000\",{\"1\":{\"658\":2}}],[\"12king\",{\"1\":{\"602\":1}}],[\"1200\",{\"1\":{\"1142\":1}}],[\"120\",{\"1\":{\"519\":1}}],[\"127\",{\"1\":{\"519\":4,\"598\":2,\"692\":11,\"693\":14,\"725\":1,\"748\":36,\"753\":8,\"766\":1,\"785\":1,\"794\":1,\"802\":1,\"836\":4,\"1199\":1,\"1205\":24,\"1206\":25,\"1208\":18,\"1209\":5,\"1210\":16,\"1216\":1}}],[\"128x0\",{\"1\":{\"976\":1}}],[\"128\",{\"1\":{\"598\":1,\"694\":2,\"836\":1,\"846\":1,\"976\":1}}],[\"128mb\",{\"1\":{\"444\":1}}],[\"1284840958643646464\",{\"1\":{\"118\":1}}],[\"12\",{\"0\":{\"164\":1,\"186\":1,\"205\":1,\"779\":1,\"1308\":1},\"1\":{\"337\":2,\"339\":1,\"340\":1,\"341\":2,\"405\":1,\"409\":2,\"437\":2,\"692\":1,\"693\":1,\"696\":1,\"697\":23,\"713\":1,\"723\":1,\"755\":1,\"762\":3,\"763\":4,\"764\":3,\"773\":2,\"774\":3,\"799\":1,\"999\":1,\"1012\":6,\"1206\":1}}],[\"12<\",{\"1\":{\"99\":1,\"1070\":1,\"1087\":1}}],[\"15b\",{\"1\":{\"699\":1}}],[\"150\",{\"1\":{\"1150\":1,\"1213\":1,\"1215\":1,\"1220\":1}}],[\"1500ms\",{\"1\":{\"1153\":1}}],[\"1500\",{\"1\":{\"694\":2}}],[\"150岁之内\",{\"1\":{\"480\":1}}],[\"15m\",{\"1\":{\"435\":1}}],[\"15<\",{\"1\":{\"104\":1}}],[\"15\",{\"0\":{\"167\":1,\"189\":1,\"208\":1,\"1322\":1},\"1\":{\"81\":1,\"112\":1,\"692\":1,\"693\":1,\"696\":1,\"723\":1,\"751\":1,\"755\":1,\"768\":1,\"1206\":1}}],[\"11825\",{\"1\":{\"1021\":1}}],[\"1188\",{\"1\":{\"256\":1}}],[\"11b\",{\"1\":{\"698\":1}}],[\"111\",{\"1\":{\"571\":1}}],[\"111412907\",{\"1\":{\"545\":1,\"549\":1}}],[\"111408759\",{\"1\":{\"543\":1,\"544\":1}}],[\"11表示标记gc\",{\"1\":{\"540\":1}}],[\"119\",{\"1\":{\"519\":1}}],[\"11\",{\"0\":{\"163\":1,\"185\":1,\"204\":1,\"778\":1,\"1085\":1,\"1129\":1,\"1178\":1,\"1179\":1,\"1180\":1,\"1303\":1},\"1\":{\"73\":4,\"110\":1,\"112\":1,\"163\":1,\"285\":1,\"290\":1,\"332\":3,\"339\":5,\"340\":5,\"343\":2,\"344\":1,\"347\":1,\"493\":1,\"692\":1,\"693\":1,\"696\":1,\"723\":1,\"748\":1,\"760\":4,\"761\":3,\"762\":3,\"808\":1,\"809\":1,\"974\":1,\"1021\":1,\"1042\":1,\"1085\":1,\"1177\":1,\"1206\":4}}],[\"10~6\",{\"1\":{\"1167\":1}}],[\"10s之后去做参数一的事情\",{\"1\":{\"1152\":1}}],[\"10l\",{\"1\":{\"1128\":1}}],[\"104857600\",{\"1\":{\"873\":1,\"878\":1}}],[\"102\",{\"1\":{\"733\":1}}],[\"1024k表示条带化单元的大小\",{\"1\":{\"875\":1}}],[\"1024k策略\",{\"1\":{\"875\":2}}],[\"1024k\",{\"1\":{\"826\":1,\"875\":1}}],[\"1024\",{\"1\":{\"70\":2,\"658\":1,\"694\":1,\"698\":1,\"699\":1,\"713\":1,\"843\":2,\"1157\":2}}],[\"101\",{\"1\":{\"733\":1,\"1150\":1,\"1213\":1,\"1215\":1,\"1220\":1}}],[\"101表示偏向锁\",{\"1\":{\"540\":1}}],[\"10b\",{\"1\":{\"698\":1}}],[\"10301\",{\"1\":{\"876\":1}}],[\"103\",{\"1\":{\"697\":37,\"698\":32,\"699\":37}}],[\"10表示重量级锁\",{\"1\":{\"540\":1}}],[\"10的查询\",{\"1\":{\"422\":1}}],[\"106246355\",{\"1\":{\"145\":1}}],[\"10593\",{\"1\":{\"117\":1}}],[\"10<\",{\"1\":{\"107\":5}}],[\"10\",{\"0\":{\"162\":1,\"184\":1,\"203\":1,\"777\":1,\"1084\":1,\"1128\":1,\"1173\":1,\"1174\":1,\"1175\":1,\"1176\":1,\"1177\":1,\"1301\":1},\"1\":{\"104\":1,\"163\":1,\"294\":1,\"337\":2,\"338\":1,\"359\":2,\"555\":6,\"562\":4,\"567\":1,\"599\":1,\"692\":4,\"693\":4,\"696\":3,\"697\":1,\"698\":2,\"699\":22,\"710\":1,\"723\":1,\"755\":1,\"760\":4,\"761\":4,\"768\":3,\"769\":2,\"772\":2,\"773\":1,\"776\":2,\"779\":1,\"780\":1,\"796\":19,\"847\":1,\"855\":2,\"1084\":1,\"1127\":1,\"1128\":1,\"1129\":1,\"1141\":2,\"1150\":1,\"1172\":1,\"1174\":1,\"1176\":6,\"1177\":1,\"1186\":1,\"1205\":2,\"1206\":3}}],[\"1003\",{\"1\":{\"1073\":1}}],[\"1002\",{\"1\":{\"1073\":1}}],[\"1001\",{\"1\":{\"1073\":4}}],[\"1001~2000\",{\"1\":{\"694\":1}}],[\"100ms\",{\"1\":{\"1220\":1}}],[\"100mb\",{\"1\":{\"979\":1}}],[\"100m\",{\"1\":{\"873\":1,\"976\":1}}],[\"100w\",{\"1\":{\"658\":1}}],[\"100的值所在的位置\",{\"1\":{\"455\":1}}],[\"100的数据\",{\"1\":{\"455\":1}}],[\"10086\",{\"1\":{\"339\":4,\"347\":1,\"377\":1}}],[\"100\",{\"1\":{\"70\":1,\"198\":2,\"248\":1,\"336\":2,\"340\":3,\"455\":1,\"646\":1,\"713\":3,\"741\":3,\"742\":1,\"792\":1,\"795\":2,\"1023\":1,\"1025\":1,\"1132\":1,\"1309\":1}}],[\"1000∗60∗60∗24∗365\",{\"1\":{\"998\":1}}],[\"1000=10亿条数据\",{\"1\":{\"487\":1}}],[\"100005\",{\"1\":{\"645\":1}}],[\"1000000\",{\"1\":{\"999\":1,\"1180\":1}}],[\"1000000l\",{\"1\":{\"742\":1}}],[\"1000000bit\",{\"1\":{\"658\":1}}],[\"100000\",{\"1\":{\"481\":1}}],[\"10000\",{\"1\":{\"81\":3,\"307\":2,\"310\":1}}],[\"1000\",{\"1\":{\"47\":2,\"487\":1,\"536\":1,\"551\":1,\"593\":1,\"717\":2,\"718\":2,\"726\":1,\"757\":1,\"758\":1,\"759\":1,\"760\":1,\"761\":2,\"762\":1,\"763\":1,\"764\":1,\"820\":1,\"1021\":1,\"1023\":1,\"1024\":1,\"1035\":1,\"1174\":1,\"1180\":2,\"1215\":2}}],[\"17779\",{\"1\":{\"265\":1}}],[\"1776\",{\"1\":{\"256\":1}}],[\"1788\",{\"1\":{\"256\":1}}],[\"1703\",{\"1\":{\"117\":1}}],[\"17<\",{\"1\":{\"99\":1,\"1022\":1,\"1466\":1}}],[\"17\",{\"0\":{\"169\":1,\"191\":1,\"210\":1,\"1330\":1},\"1\":{\"47\":1,\"331\":2,\"337\":8,\"338\":1,\"751\":1,\"1208\":4,\"1313\":2}}],[\"1\",{\"0\":{\"91\":1,\"94\":1,\"97\":1,\"104\":1,\"107\":1,\"110\":1,\"149\":1,\"153\":1,\"175\":1,\"194\":1,\"219\":1,\"220\":2,\"221\":3,\"222\":2,\"223\":2,\"224\":1,\"225\":2,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":2,\"232\":1,\"234\":1,\"239\":1,\"242\":1,\"246\":1,\"247\":2,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"252\":1,\"253\":1,\"254\":2,\"255\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"268\":1,\"270\":1,\"274\":1,\"278\":1,\"281\":1,\"283\":1,\"284\":2,\"285\":1,\"287\":1,\"292\":1,\"293\":2,\"294\":1,\"296\":1,\"301\":1,\"302\":2,\"303\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":1,\"312\":1,\"320\":1,\"328\":1,\"329\":2,\"330\":1,\"331\":1,\"332\":1,\"334\":1,\"336\":1,\"346\":1,\"347\":2,\"348\":1,\"349\":1,\"351\":1,\"357\":1,\"367\":1,\"371\":1,\"372\":2,\"373\":1,\"374\":1,\"375\":1,\"377\":1,\"380\":1,\"381\":2,\"382\":1,\"384\":1,\"387\":1,\"390\":1,\"393\":1,\"395\":1,\"399\":1,\"400\":2,\"402\":1,\"404\":1,\"406\":1,\"407\":2,\"408\":1,\"409\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":3,\"415\":2,\"416\":1,\"417\":2,\"418\":1,\"419\":1,\"420\":2,\"421\":1,\"422\":1,\"423\":1,\"424\":1,\"426\":1,\"427\":2,\"428\":1,\"429\":1,\"430\":1,\"432\":1,\"435\":1,\"440\":1,\"441\":2,\"442\":1,\"444\":1,\"448\":1,\"452\":1,\"460\":1,\"463\":1,\"472\":1,\"497\":1,\"607\":1,\"725\":1,\"733\":1,\"768\":1,\"869\":1,\"872\":1,\"878\":1,\"882\":1,\"888\":1,\"892\":1,\"894\":1,\"897\":1,\"905\":1,\"908\":1,\"909\":2,\"910\":1,\"912\":1,\"916\":1,\"918\":1,\"922\":1,\"926\":1,\"929\":1,\"940\":1,\"941\":2,\"942\":1,\"944\":1,\"951\":1,\"955\":1,\"956\":2,\"965\":1,\"968\":1,\"970\":1,\"972\":1,\"976\":1,\"979\":1,\"982\":1,\"983\":2,\"985\":1,\"988\":1,\"994\":1,\"995\":2,\"1007\":1,\"1008\":2,\"1009\":1,\"1010\":1,\"1012\":1,\"1015\":1,\"1020\":1,\"1023\":1,\"1028\":1,\"1031\":1,\"1045\":1,\"1060\":1,\"1061\":2,\"1062\":1,\"1063\":1,\"1064\":1,\"1065\":1,\"1066\":1,\"1067\":1,\"1068\":1,\"1070\":1,\"1075\":1,\"1087\":1,\"1091\":1,\"1092\":2,\"1093\":3,\"1094\":2,\"1095\":2,\"1096\":2,\"1097\":2,\"1098\":1,\"1099\":1,\"1100\":1,\"1101\":1,\"1102\":1,\"1103\":1,\"1104\":2,\"1105\":1,\"1106\":1,\"1107\":1,\"1108\":1,\"1109\":2,\"1110\":1,\"1111\":1,\"1113\":1,\"1114\":2,\"1115\":1,\"1117\":1,\"1118\":1,\"1120\":1,\"1131\":1,\"1140\":1,\"1149\":1,\"1155\":1,\"1159\":1,\"1164\":1,\"1170\":1,\"1174\":1,\"1179\":1,\"1182\":1,\"1184\":1,\"1185\":2,\"1186\":1,\"1187\":1,\"1188\":1,\"1189\":1,\"1192\":1,\"1199\":1,\"1204\":1,\"1213\":1,\"1215\":1,\"1218\":1,\"1219\":2,\"1220\":1,\"1221\":1,\"1240\":1},\"1\":{\"23\":1,\"43\":1,\"81\":20,\"88\":4,\"92\":1,\"99\":1,\"105\":2,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"160\":1,\"161\":1,\"162\":3,\"163\":4,\"165\":1,\"167\":1,\"168\":2,\"175\":3,\"176\":2,\"178\":2,\"179\":2,\"182\":1,\"184\":2,\"186\":1,\"191\":4,\"192\":1,\"204\":3,\"237\":1,\"256\":1,\"268\":2,\"276\":1,\"278\":1,\"279\":1,\"280\":1,\"285\":2,\"289\":1,\"290\":1,\"293\":1,\"297\":1,\"298\":4,\"320\":1,\"329\":3,\"330\":10,\"332\":11,\"336\":2,\"337\":1,\"340\":2,\"344\":3,\"351\":9,\"353\":8,\"354\":1,\"363\":3,\"364\":1,\"365\":4,\"368\":1,\"369\":4,\"400\":4,\"409\":4,\"433\":2,\"437\":1,\"477\":1,\"480\":2,\"481\":2,\"482\":1,\"483\":1,\"497\":4,\"501\":1,\"519\":5,\"523\":1,\"554\":3,\"555\":3,\"560\":1,\"562\":6,\"564\":2,\"567\":2,\"574\":6,\"576\":1,\"579\":8,\"591\":1,\"593\":6,\"600\":2,\"605\":6,\"606\":2,\"614\":1,\"620\":1,\"645\":5,\"646\":2,\"648\":10,\"649\":7,\"658\":2,\"659\":9,\"663\":4,\"665\":4,\"666\":5,\"668\":6,\"669\":2,\"673\":4,\"690\":3,\"692\":19,\"693\":25,\"696\":1,\"697\":32,\"698\":19,\"699\":36,\"702\":7,\"713\":8,\"714\":7,\"717\":4,\"718\":7,\"723\":11,\"725\":1,\"726\":2,\"735\":1,\"737\":1,\"740\":14,\"742\":7,\"743\":2,\"744\":1,\"748\":64,\"750\":1,\"751\":5,\"753\":14,\"754\":1,\"757\":1,\"759\":2,\"760\":2,\"761\":4,\"762\":2,\"763\":2,\"764\":4,\"765\":2,\"766\":10,\"768\":1,\"770\":2,\"772\":3,\"773\":1,\"774\":4,\"775\":3,\"776\":7,\"779\":5,\"780\":4,\"783\":1,\"784\":2,\"785\":3,\"794\":1,\"796\":3,\"799\":4,\"805\":2,\"807\":3,\"808\":2,\"809\":2,\"814\":1,\"817\":1,\"821\":6,\"823\":2,\"826\":1,\"827\":1,\"836\":11,\"839\":1,\"840\":6,\"843\":2,\"846\":1,\"848\":1,\"855\":1,\"857\":2,\"859\":1,\"876\":7,\"878\":2,\"879\":1,\"882\":1,\"910\":2,\"936\":4,\"957\":5,\"958\":1,\"960\":3,\"961\":5,\"962\":7,\"972\":6,\"973\":5,\"974\":7,\"976\":2,\"983\":1,\"985\":5,\"986\":4,\"988\":10,\"990\":2,\"991\":1,\"999\":4,\"1012\":6,\"1019\":2,\"1020\":2,\"1021\":1,\"1023\":1,\"1026\":1,\"1043\":4,\"1046\":11,\"1054\":1,\"1072\":1,\"1073\":1,\"1075\":1,\"1089\":2,\"1099\":2,\"1100\":2,\"1102\":1,\"1105\":1,\"1107\":2,\"1111\":2,\"1122\":3,\"1124\":2,\"1127\":3,\"1128\":4,\"1129\":8,\"1132\":5,\"1134\":3,\"1135\":2,\"1136\":3,\"1137\":13,\"1138\":1,\"1142\":2,\"1146\":6,\"1150\":3,\"1151\":24,\"1152\":5,\"1155\":1,\"1156\":13,\"1157\":8,\"1160\":1,\"1161\":8,\"1162\":11,\"1165\":2,\"1167\":3,\"1168\":6,\"1171\":2,\"1172\":5,\"1174\":9,\"1175\":4,\"1176\":11,\"1177\":2,\"1186\":2,\"1196\":2,\"1199\":2,\"1205\":36,\"1206\":29,\"1207\":6,\"1208\":29,\"1209\":9,\"1210\":25,\"1213\":5,\"1215\":1,\"1216\":2,\"1219\":2,\"1230\":2,\"1300\":1,\"1321\":2,\"1335\":1,\"1345\":1,\"1394\":1,\"1445\":1,\"1449\":1,\"1466\":1,\"1482\":3,\"1526\":1}}],[\"意味着什么\",{\"1\":{\"1525\":1}}],[\"意味着数据分区\",{\"1\":{\"973\":1}}],[\"意味着可以链式调用\",{\"1\":{\"772\":1}}],[\"意味着不等连接建立\",{\"1\":{\"753\":1}}],[\"意味着系统中只有\",{\"1\":{\"200\":1}}],[\"意思就是内存可复用\",{\"1\":{\"979\":1}}],[\"意思就是随机一个数据块进行抽样\",{\"1\":{\"368\":1}}],[\"意思是没有复制\",{\"1\":{\"1067\":1}}],[\"意思是前面都按128m来逻辑划分\",{\"1\":{\"976\":1}}],[\"意思是指字符串的结束\",{\"1\":{\"662\":1}}],[\"意思是互斥锁可以降级为共享锁\",{\"1\":{\"582\":1}}],[\"意向排他锁\",{\"1\":{\"510\":4}}],[\"意向共享锁\",{\"1\":{\"510\":4}}],[\"意向锁\",{\"1\":{\"510\":1}}],[\"意大利风味甜点工厂\",{\"1\":{\"39\":1}}],[\"意图\",{\"1\":{\"23\":1}}],[\"意在通过一步一步地精确构造创建出一个复杂的对象\",{\"1\":{\"19\":1}}],[\"饿汉式\",{\"1\":{\"22\":1,\"66\":4}}],[\"|world\",{\"1\":{\"836\":1}}],[\"|wangwu\",{\"1\":{\"748\":2}}],[\"|five\",{\"1\":{\"808\":1}}],[\"|four\",{\"1\":{\"808\":1}}],[\"|ff\",{\"1\":{\"698\":1,\"699\":1}}],[\"|fffffffffffff\",{\"1\":{\"699\":1}}],[\"|ffff\",{\"1\":{\"697\":1}}],[\"|three\",{\"1\":{\"807\":1}}],[\"|two\",{\"1\":{\"807\":1}}],[\"|one\",{\"1\":{\"807\":1}}],[\"|lisi\",{\"1\":{\"748\":2}}],[\"|zhangsan\",{\"1\":{\"748\":2}}],[\"|j\",{\"1\":{\"699\":1}}],[\"|jjjjjjjjj\",{\"1\":{\"699\":1}}],[\"|jjjjjjjjjjj\",{\"1\":{\"698\":2}}],[\"|jjjj\",{\"1\":{\"697\":1}}],[\"|eeee\",{\"1\":{\"699\":1}}],[\"|eeeeeeeeeeeeeee\",{\"1\":{\"699\":1}}],[\"|eeeeeeeeee\",{\"1\":{\"698\":1}}],[\"|eeeeeee\",{\"1\":{\"698\":1}}],[\"|gg\",{\"1\":{\"698\":1,\"699\":1}}],[\"|ggggggg\",{\"1\":{\"698\":1}}],[\"|ggg\",{\"1\":{\"697\":2}}],[\"|a\",{\"1\":{\"698\":2,\"857\":1}}],[\"|aaaaaaaaa\",{\"1\":{\"699\":1}}],[\"|aaaa\",{\"1\":{\"697\":2}}],[\"|hello\",{\"1\":{\"836\":1,\"848\":1}}],[\"|hh\",{\"1\":{\"699\":1}}],[\"|hhhh\",{\"1\":{\"698\":1}}],[\"|h\",{\"1\":{\"697\":1}}],[\"|dddddddd\",{\"1\":{\"699\":1}}],[\"|dddd\",{\"1\":{\"699\":1}}],[\"|dd\",{\"1\":{\"698\":1}}],[\"|d\",{\"1\":{\"697\":1}}],[\"|bbbbbbbbb\",{\"1\":{\"699\":1}}],[\"|bbbb\",{\"1\":{\"699\":1}}],[\"|bbb\",{\"1\":{\"698\":1}}],[\"|b\",{\"1\":{\"697\":1}}],[\"|iiiiiiiiiiiiii\",{\"1\":{\"699\":1}}],[\"|iiiiiii\",{\"1\":{\"698\":1,\"699\":1}}],[\"|iiiii\",{\"1\":{\"697\":2}}],[\"|cccccc\",{\"1\":{\"699\":1}}],[\"|ccc\",{\"1\":{\"698\":1}}],[\"|cc\",{\"1\":{\"697\":2}}],[\"|00000090|\",{\"1\":{\"692\":1}}],[\"|00000080|\",{\"1\":{\"692\":1,\"693\":1}}],[\"|00000070|\",{\"1\":{\"692\":1,\"693\":1}}],[\"|00000060|\",{\"1\":{\"692\":1,\"693\":1,\"699\":1}}],[\"|00000050|\",{\"1\":{\"692\":1,\"693\":1,\"699\":1}}],[\"|00000040|\",{\"1\":{\"692\":1,\"693\":1,\"697\":1,\"699\":1}}],[\"|00000030|\",{\"1\":{\"692\":1,\"693\":1,\"697\":1,\"698\":1,\"699\":1}}],[\"|00000020|\",{\"1\":{\"692\":1,\"693\":1,\"697\":1,\"698\":1,\"699\":1}}],[\"|00000010|\",{\"1\":{\"692\":1,\"693\":2,\"697\":1,\"698\":1,\"699\":1}}],[\"|00000000|\",{\"1\":{\"692\":1,\"693\":2,\"697\":11,\"698\":11,\"699\":11,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":6,\"779\":4,\"780\":2,\"805\":2,\"807\":3,\"808\":2,\"836\":2,\"848\":1,\"857\":1}}],[\"||\",{\"1\":{\"88\":2,\"579\":7,\"668\":3,\"723\":1,\"740\":2,\"742\":5,\"743\":1,\"744\":1,\"799\":1,\"999\":2,\"1099\":1,\"1107\":1,\"1162\":1,\"1168\":1,\"1172\":1,\"1176\":1}}],[\"|\",{\"1\":{\"22\":1,\"59\":4,\"92\":3,\"247\":1,\"276\":1,\"300\":2,\"315\":2,\"331\":3,\"336\":2,\"348\":1,\"373\":3,\"374\":10,\"593\":4,\"661\":1,\"664\":1,\"692\":22,\"693\":26,\"697\":39,\"698\":34,\"699\":34,\"723\":1,\"733\":3,\"740\":1,\"742\":1,\"743\":1,\"748\":18,\"772\":10,\"773\":4,\"774\":12,\"776\":24,\"779\":16,\"780\":8,\"799\":12,\"805\":8,\"807\":9,\"808\":6,\"821\":4,\"836\":6,\"843\":1,\"848\":3,\"857\":3,\"988\":1,\"990\":2,\"999\":3,\"1132\":1,\"1230\":4,\"1309\":2,\"1441\":5,\"1532\":1}}],[\"只剩下一个了\",{\"1\":{\"1205\":1}}],[\"只记录1次\",{\"1\":{\"1179\":1}}],[\"只管把数据消费到\",{\"1\":{\"1053\":1}}],[\"只在kms内部使用\",{\"1\":{\"934\":1}}],[\"只做差异的记录\",{\"1\":{\"913\":1}}],[\"只拷贝相对于源端\",{\"1\":{\"869\":1}}],[\"只发生了一次用户态与内核态的切换\",{\"1\":{\"855\":1}}],[\"只发消息\",{\"1\":{\"735\":1}}],[\"只关注\",{\"1\":{\"840\":1}}],[\"只关心什么产品由什么工厂生产即可\",{\"1\":{\"20\":1}}],[\"只适合连接数少的场景\",{\"1\":{\"864\":1}}],[\"只适合短连接\",{\"1\":{\"826\":1}}],[\"只适用于操作系统内核进程\",{\"1\":{\"170\":1}}],[\"只作为两个线程间传递结果的容器\",{\"1\":{\"756\":1}}],[\"只负责\",{\"1\":{\"748\":4}}],[\"只负责保证对象各部分完整创建或按某种顺序创建\",{\"1\":{\"13\":1}}],[\"只为添加\",{\"1\":{\"740\":1}}],[\"只将当前需要的部分页表项调入内存\",{\"1\":{\"683\":1}}],[\"只不过这\",{\"1\":{\"1310\":1}}],[\"只不过写入前会把object序列化为字节形式\",{\"1\":{\"1222\":1}}],[\"只不过在没有元素时等待指定时间\",{\"1\":{\"1209\":1}}],[\"只不过process是被select这个函数block\",{\"1\":{\"679\":1}}],[\"只不过效率高一些\",{\"1\":{\"324\":1}}],[\"只依赖于第\",{\"1\":{\"648\":1}}],[\"只保留一天的数据再进行计算\",{\"1\":{\"414\":1}}],[\"只保存定义\",{\"1\":{\"270\":1}}],[\"只查询explode生成的虚拟表数据也没问题\",{\"1\":{\"348\":1}}],[\"只暴露来自特定部门的员工信息\",{\"1\":{\"272\":1}}],[\"只暴露给本地服务一个接口\",{\"1\":{\"63\":1}}],[\"只会将一些\",{\"1\":{\"855\":1}}],[\"只会删除元数据\",{\"1\":{\"258\":1}}],[\"只会产生少量的页内碎片\",{\"1\":{\"188\":1}}],[\"只读取对应分区的数据作为输入\",{\"1\":{\"415\":1}}],[\"只读\",{\"1\":{\"211\":1}}],[\"只支持顺序访问\",{\"1\":{\"197\":1}}],[\"只需等\",{\"1\":{\"775\":1}}],[\"只需检查页的访问位\",{\"1\":{\"191\":1}}],[\"只需要加入以下依赖即可\",{\"1\":{\"1473\":1}}],[\"只需要在service中将查询出来的role封装到user实体类中即可\",{\"1\":{\"1230\":1}}],[\"只需要拷贝对应的命令哦~\",{\"1\":{\"1205\":1}}],[\"只需要拿到我们关注用户的信息\",{\"1\":{\"1166\":1}}],[\"只需要知道如何调用\",{\"1\":{\"1147\":1}}],[\"只需要知道他有什么作用即可\",{\"1\":{\"1146\":1}}],[\"只需要将程序的一部分装入内存\",{\"1\":{\"689\":1}}],[\"只需要返回这个成员变量值就行\",{\"1\":{\"663\":1}}],[\"只需要对给定字符串再次进行相同的哈希计算\",{\"1\":{\"659\":1}}],[\"只需要连接metastore\",{\"1\":{\"240\":1}}],[\"只需要访问作业的一小部分数据即可正常运行\",{\"1\":{\"189\":1}}],[\"只需要让各个进程的段表项执行同一个段即可实现共享\",{\"1\":{\"187\":1}}],[\"只需要简单的命令操作即可\",{\"1\":{\"91\":1}}],[\"只需要根据需求重新派生一个实现类来扩展就可以了\",{\"1\":{\"72\":1}}],[\"只需要使用\",{\"1\":{\"66\":1}}],[\"只需要再加一个对应的工厂类即可\",{\"1\":{\"39\":1}}],[\"只是语义不同\",{\"1\":{\"1503\":1}}],[\"只是用\",{\"1\":{\"1465\":1}}],[\"只是说多个进程之间都能感知到变化的意思\",{\"1\":{\"1140\":1}}],[\"只是将原先\",{\"1\":{\"1042\":1}}],[\"只是获取资源\",{\"1\":{\"1004\":1}}],[\"只是下面两点需要注意\",{\"1\":{\"990\":1}}],[\"只是读写指针是独立的\",{\"1\":{\"777\":1}}],[\"只是\",{\"1\":{\"762\":1}}],[\"只是为了触发\",{\"1\":{\"740\":1,\"743\":1}}],[\"只是给出一个warning信息\",{\"1\":{\"640\":1}}],[\"只是老年代的垃圾收集\",{\"1\":{\"628\":1}}],[\"只是新生代的垃圾收集\",{\"1\":{\"628\":1}}],[\"只是统计行数\",{\"1\":{\"497\":1}}],[\"只是普通的table\",{\"1\":{\"276\":1}}],[\"只是在逻辑上进行了扩充\",{\"1\":{\"189\":1}}],[\"只是定义了与算法相关的接口\",{\"1\":{\"79\":1}}],[\"只允许进程主动放弃处理机\",{\"1\":{\"165\":1}}],[\"只能通过\",{\"1\":{\"1507\":1}}],[\"只能通过反射获得\",{\"1\":{\"565\":1}}],[\"只能处理发生在\",{\"1\":{\"1411\":1}}],[\"只能使用$\",{\"1\":{\"1230\":1}}],[\"只能实现基本的一致性\",{\"1\":{\"1188\":1}}],[\"只能一个人一个人的来访问数据库\",{\"1\":{\"1126\":1}}],[\"只能一气呵成\",{\"1\":{\"170\":1}}],[\"只能有一种type\",{\"1\":{\"1062\":1}}],[\"只能从分区leader去读写消息\",{\"1\":{\"1043\":1}}],[\"只能写\",{\"1\":{\"813\":1}}],[\"只能工作在阻塞模式下\",{\"1\":{\"812\":1}}],[\"只能同步等待任务结束\",{\"1\":{\"756\":1}}],[\"只能先发送前\",{\"1\":{\"694\":1}}],[\"只能逐个查找\",{\"1\":{\"665\":1}}],[\"只能调用空参的构造器\",{\"1\":{\"629\":1}}],[\"只能保证看到最新值\",{\"1\":{\"558\":1}}],[\"只能保证redis集群的高可用性\",{\"1\":{\"526\":1}}],[\"只能与tez配套使用\",{\"1\":{\"473\":1}}],[\"只能走reduce\",{\"1\":{\"467\":1}}],[\"只能走默认的reducejoin\",{\"1\":{\"418\":1}}],[\"只能挨个执行\",{\"1\":{\"446\":1}}],[\"只能正序\",{\"1\":{\"313\":1}}],[\"只能是采取另外的手段来完成\",{\"1\":{\"292\":1}}],[\"只能读\",{\"1\":{\"209\":1,\"813\":1}}],[\"只能用于单用户\",{\"1\":{\"182\":1}}],[\"只能主动释放\",{\"1\":{\"175\":1}}],[\"只能被管程中定义的过程访问\",{\"1\":{\"173\":1}}],[\"只能进程间并发\",{\"1\":{\"163\":1}}],[\"只能创建一个实例的类\",{\"1\":{\"65\":1}}],[\"只对外暴露了\",{\"1\":{\"574\":1}}],[\"只对编译\",{\"1\":{\"100\":1}}],[\"只对测试\",{\"1\":{\"100\":2}}],[\"只打包\",{\"1\":{\"95\":1}}],[\"只和你的直接朋友交谈\",{\"1\":{\"76\":1}}],[\"只有innodb支持事务\",{\"1\":{\"1517\":1}}],[\"只有遇见\",{\"1\":{\"1176\":1}}],[\"只有所有的服务器都写入成功\",{\"1\":{\"1153\":1}}],[\"只有所有玩家都加载到100\",{\"1\":{\"592\":1}}],[\"只有等到新开的线程2把重建数据构建完后\",{\"1\":{\"1126\":1}}],[\"只有目录内文件的所有者或者root才可以删除或移动该文件\",{\"1\":{\"920\":1}}],[\"只有启用的策略才适合与setpolicy命令一起使用\",{\"1\":{\"875\":1}}],[\"只有一开始\",{\"1\":{\"755\":1}}],[\"只有一个事务能执行写入\",{\"1\":{\"508\":1}}],[\"只有一个操作数\",{\"1\":{\"331\":1}}],[\"只有一个参数时相当于limit\",{\"1\":{\"309\":1}}],[\"只有落在窗口内的数据才能允许接收\",{\"1\":{\"694\":1}}],[\"只有活跃的socket才会主动调用callback\",{\"1\":{\"680\":1}}],[\"只有活跃可用的fd才会调用callback函数\",{\"1\":{\"680\":1}}],[\"只有cms\",{\"1\":{\"628\":1}}],[\"只有当客户端对象需要访问容器中的某个对象时\",{\"1\":{\"1501\":1}}],[\"只有当线程取任务时\",{\"1\":{\"574\":1}}],[\"只有当所有非守护线程执行完毕后\",{\"1\":{\"537\":1}}],[\"只有当进行大量调用的时候\",{\"1\":{\"61\":1}}],[\"只有在线的\",{\"1\":{\"701\":1}}],[\"只有在连接真正有读写事件发生时\",{\"1\":{\"610\":1}}],[\"只有在cpu比较忙的时候\",{\"1\":{\"535\":1}}],[\"只有在进程执行的过程中才能知道接下来会访问的是哪个页面\",{\"1\":{\"191\":1}}],[\"只有事务中的数据库操作都执行成功\",{\"1\":{\"506\":1}}],[\"只有某一个task一直在运行\",{\"1\":{\"462\":1}}],[\"只有maptask\",{\"1\":{\"435\":1}}],[\"只有进行连接的两个表中都存在与连接条件相匹配的数据才会被留下来\",{\"1\":{\"320\":1}}],[\"只有表结构\",{\"1\":{\"275\":1}}],[\"只有定义没有存储数据\",{\"1\":{\"275\":1}}],[\"只有被淘汰的页面被修改过时\",{\"1\":{\"191\":1}}],[\"只有对必须互斥使用的资源的争抢才会导致死锁\",{\"1\":{\"175\":1}}],[\"只有第一次读操作会生成readview\",{\"1\":{\"503\":1}}],[\"只有第一次调用getinstance\",{\"1\":{\"66\":1}}],[\"只有第k级队列为空时\",{\"1\":{\"167\":1}}],[\"只有调入的时机是由操作系统来确定\",{\"1\":{\"164\":1}}],[\"只有系统拥有并发性\",{\"1\":{\"155\":1}}],[\"只有测试\",{\"1\":{\"100\":1}}],[\"只有这些配置都有了\",{\"1\":{\"74\":1}}],[\"只有内部类的属性\",{\"1\":{\"66\":1}}],[\"只定义了trainstation\",{\"1\":{\"60\":1}}],[\"只要返回集合不空\",{\"1\":{\"1333\":1}}],[\"只要对应是1\",{\"1\":{\"1175\":1}}],[\"只要这种逻辑可以完成\",{\"1\":{\"1155\":1}}],[\"只要这个时间间隔小于服务器定义的空闲检测的时间间隔\",{\"1\":{\"707\":1}}],[\"只要大家使用的是同一把锁\",{\"1\":{\"1140\":1}}],[\"只要我扣减库存时的库存和之前我查询到的库存是一样的\",{\"1\":{\"1136\":1}}],[\"只要哈希思想\",{\"1\":{\"1123\":1}}],[\"只要线程不一样\",{\"1\":{\"1100\":1}}],[\"只要接口发生变化就会导致系统不可用\",{\"1\":{\"1009\":1}}],[\"只要getpartition返回的int一样\",{\"1\":{\"973\":1}}],[\"只要用户能正常登录就认证成功\",{\"1\":{\"922\":1}}],[\"只要向\",{\"1\":{\"844\":1}}],[\"只要调用\",{\"1\":{\"804\":1}}],[\"只要分别采用读线程和写线程即可\",{\"1\":{\"795\":1}}],[\"只要节点数量足够小\",{\"1\":{\"667\":1}}],[\"只要其中有一个是变量\",{\"1\":{\"632\":1}}],[\"只要成功地通过cas操作将state的值从0变为1就获取了锁\",{\"1\":{\"582\":1}}],[\"只要有一个节点拿不到\",{\"1\":{\"1153\":1}}],[\"只要有一个线程占有了共享锁\",{\"1\":{\"582\":1}}],[\"只要有其他线程\",{\"1\":{\"563\":1}}],[\"只要有可能\",{\"1\":{\"499\":1}}],[\"只要没有唯一索引\",{\"1\":{\"481\":1}}],[\"只要指定使用jsonserde解析表的文件\",{\"1\":{\"397\":1}}],[\"只要能找到一个安全序列\",{\"1\":{\"177\":1}}],[\"只要抽象不变\",{\"1\":{\"74\":1}}],[\"只要抽象的合理\",{\"1\":{\"72\":1}}],[\"只要扩展一个工厂类就可以\",{\"1\":{\"23\":1}}],[\"只要知道其名称就可以了\",{\"1\":{\"23\":1}}],[\"具备校验与获取校验结果功能\",{\"1\":{\"1370\":1}}],[\"具有幂等性\",{\"1\":{\"1004\":1}}],[\"具有更好的hash性\",{\"1\":{\"579\":1}}],[\"具有歧义\",{\"1\":{\"304\":1}}],[\"具有相同编号的磁道形成的圆柱\",{\"1\":{\"203\":1}}],[\"具有对换功能的操作系统中\",{\"1\":{\"181\":1}}],[\"具有不同分类维度的产品组合\",{\"1\":{\"20\":1}}],[\"具体类的样式可以通过阿里巴巴的arthas插件看到\",{\"1\":{\"1508\":1}}],[\"具体类的设计如下\",{\"1\":{\"25\":1}}],[\"具体异常信息会由\",{\"1\":{\"1411\":1}}],[\"具体命令\",{\"1\":{\"1210\":1}}],[\"具体场景说明\",{\"1\":{\"1171\":1}}],[\"具体步骤\",{\"1\":{\"1161\":1}}],[\"具体步骤就是模板代码\",{\"1\":{\"990\":1}}],[\"具体发布流程\",{\"1\":{\"1159\":1}}],[\"具体调用的逻辑就是去后台开启一个线程\",{\"1\":{\"1152\":1}}],[\"具体操作如下\",{\"1\":{\"1168\":1}}],[\"具体操作\",{\"1\":{\"1138\":1}}],[\"具体操作逻辑如下\",{\"1\":{\"1137\":1}}],[\"具体逻辑上文已经分析\",{\"1\":{\"1099\":1}}],[\"具体流程\",{\"1\":{\"1023\":1}}],[\"具体实现步骤\",{\"1\":{\"970\":1}}],[\"具体认证过程\",{\"1\":{\"923\":1}}],[\"具体是否启动可以去web页面查看\",{\"1\":{\"878\":1}}],[\"具体报错可以去logs里面查看\",{\"1\":{\"878\":1}}],[\"具体代码如下\",{\"1\":{\"1099\":1,\"1144\":1}}],[\"具体代码\",{\"1\":{\"775\":1}}],[\"具体池化还是非池化由\",{\"1\":{\"731\":1}}],[\"具体数目可以cat\",{\"1\":{\"680\":1}}],[\"具体数据\",{\"1\":{\"293\":1}}],[\"具体使用哪种方式得看内存是否规整\",{\"1\":{\"630\":1}}],[\"具体使用见前面ddl\",{\"1\":{\"426\":1}}],[\"具体个数要是需要测试得到\",{\"1\":{\"576\":1}}],[\"具体字段\",{\"0\":{\"497\":1},\"1\":{\"497\":1}}],[\"具体和表的存储引擎相关\",{\"1\":{\"485\":1}}],[\"具体见hadoop中的讲解\",{\"1\":{\"426\":1}}],[\"具体问题还不知道\",{\"1\":{\"353\":1}}],[\"具体看下面的例子\",{\"1\":{\"285\":1}}],[\"具体如何排列组合还是得看具体的项目\",{\"1\":{\"228\":1}}],[\"具体如何读取一个字节数据呢\",{\"1\":{\"88\":1}}],[\"具体细节只有设备厂家才知道\",{\"1\":{\"210\":1}}],[\"具体来说是由父工程的dependencymanagement来决定\",{\"1\":{\"107\":1}}],[\"具体子类\",{\"1\":{\"84\":1}}],[\"具体方法是\",{\"1\":{\"477\":1}}],[\"具体方法\",{\"1\":{\"84\":1}}],[\"具体原型复制成功\",{\"1\":{\"51\":1}}],[\"具体原型类\",{\"1\":{\"50\":1}}],[\"具体的关注代码\",{\"1\":{\"1165\":1}}],[\"具体的数据操作如下\",{\"1\":{\"961\":1}}],[\"具体的实现依赖于操作系统的任务调度器\",{\"1\":{\"533\":1}}],[\"具体的排序方式需要依据动态分配算法来确定\",{\"1\":{\"182\":1}}],[\"具体的策略\",{\"1\":{\"80\":1}}],[\"具体的原型对象创建完成\",{\"1\":{\"51\":1}}],[\"具体的原型类\",{\"1\":{\"51\":1}}],[\"具体的观察者\",{\"1\":{\"46\":1}}],[\"具体的观察对象\",{\"1\":{\"46\":1}}],[\"具体的代码如下\",{\"1\":{\"14\":1}}],[\"具体工厂\",{\"1\":{\"27\":1,\"33\":1,\"34\":1,\"38\":1,\"39\":1}}],[\"具体产品\",{\"1\":{\"27\":1,\"33\":1,\"38\":1}}],[\"具体建造者类\",{\"1\":{\"13\":1}}],[\"躯干等部分\",{\"1\":{\"19\":1}}],[\"脚本业务\",{\"1\":{\"1156\":1}}],[\"脚本\",{\"1\":{\"1156\":1}}],[\"脚本一共有3个参数\",{\"1\":{\"1151\":1}}],[\"脚\",{\"1\":{\"19\":1}}],[\"头判断需要生成哪种\",{\"1\":{\"1411\":1}}],[\"头有没有指定\",{\"1\":{\"1398\":1}}],[\"头占用\",{\"1\":{\"694\":2}}],[\"头后剩余能够作为数据传输的字节数\",{\"1\":{\"694\":1}}],[\"头和\",{\"1\":{\"694\":2}}],[\"头\",{\"1\":{\"19\":1,\"694\":1}}],[\"则结束所有流程\",{\"1\":{\"1532\":1}}],[\"则结果为1\",{\"1\":{\"331\":1}}],[\"则web容器将该请求转交给dispatcherservlet处理\",{\"1\":{\"1530\":1}}],[\"则加入该事务\",{\"1\":{\"1514\":2}}],[\"则等价于propagation\",{\"1\":{\"1514\":1}}],[\"则把当前事务挂起\",{\"1\":{\"1514\":2}}],[\"则把下单的逻辑保存到队列中去\",{\"1\":{\"1157\":1}}],[\"则新建一个事务\",{\"1\":{\"1514\":1}}],[\"则jdk动态代理更合适\",{\"1\":{\"1512\":1}}],[\"则按集合处理\",{\"1\":{\"1482\":1}}],[\"则以非事务方式继续运行\",{\"1\":{\"1514\":1}}],[\"则以自己配置的为准\",{\"1\":{\"1456\":1}}],[\"则以day维度进行层级聚合\",{\"1\":{\"355\":1}}],[\"则resulttype可以设置成map\",{\"1\":{\"1230\":1}}],[\"则rr退化为fcfs调度算法\",{\"1\":{\"167\":1}}],[\"则添加成功\",{\"1\":{\"1206\":1}}],[\"则记录多次pv\",{\"1\":{\"1179\":1}}],[\"则说明不是一次缓存穿透数据\",{\"1\":{\"1177\":1}}],[\"则这张表一年的数据量为\",{\"1\":{\"1174\":1}}],[\"则点赞按钮高亮显示\",{\"1\":{\"1161\":1}}],[\"则此时就无法生效\",{\"1\":{\"1177\":1}}],[\"则此时也会进行抢锁\",{\"1\":{\"1152\":1}}],[\"则此数据是共享数据\",{\"1\":{\"627\":1}}],[\"则重入次数\",{\"1\":{\"1151\":1}}],[\"则重新扫描\",{\"1\":{\"191\":3}}],[\"则重新放回该队列队尾\",{\"1\":{\"167\":1}}],[\"则删除锁\",{\"1\":{\"1146\":1}}],[\"则删除缓存\",{\"1\":{\"1144\":1}}],[\"则脚本如下\",{\"1\":{\"1146\":1}}],[\"则脚本是这样\",{\"1\":{\"1146\":1}}],[\"则判断当前这把锁是属于自己的\",{\"1\":{\"1143\":1}}],[\"则尝试设置一个值\",{\"1\":{\"1142\":1,\"1144\":1}}],[\"则代表着当前这哥们已经抢锁完毕\",{\"1\":{\"1152\":1}}],[\"则代表中间没有被人修改过\",{\"1\":{\"1135\":1}}],[\"则代表自增后的序列号超过了4095\",{\"1\":{\"999\":1}}],[\"则数据被修改过\",{\"1\":{\"1135\":1}}],[\"则扣减库存\",{\"1\":{\"1134\":1}}],[\"则在开启独立线程后直接返回之前的数据\",{\"1\":{\"1128\":1}}],[\"则在常量池中创建一份\",{\"1\":{\"632\":1}}],[\"则失眠并重试\",{\"1\":{\"1127\":1}}],[\"则插入成功\",{\"1\":{\"1127\":1}}],[\"则休眠\",{\"1\":{\"1127\":1}}],[\"则是修改\",{\"1\":{\"1208\":1}}],[\"则是新增\",{\"1\":{\"1208\":1}}],[\"则是\",{\"1\":{\"1174\":1}}],[\"则是之前写入的数据\",{\"1\":{\"1124\":1}}],[\"则是当一个事务中有多条写入语句时使用的\",{\"1\":{\"293\":1}}],[\"则查询数据库\",{\"1\":{\"1118\":1,\"1122\":1}}],[\"则直接放行\",{\"1\":{\"1177\":1}}],[\"则直接结束\",{\"1\":{\"1155\":1}}],[\"则直接返回redis中的数据\",{\"1\":{\"1128\":1}}],[\"则直接返回数据\",{\"1\":{\"1124\":1}}],[\"则直接返回\",{\"1\":{\"1118\":1,\"1123\":1,\"1146\":1,\"1177\":1}}],[\"则直接从缓存中返回\",{\"1\":{\"1117\":1}}],[\"则直接覆盖\",{\"1\":{\"869\":1}}],[\"则放行\",{\"1\":{\"1111\":1,\"1123\":1}}],[\"则根据手机号查询用户信息\",{\"1\":{\"1106\":1}}],[\"则他的value中只会存储他数据本身\",{\"1\":{\"1104\":1}}],[\"则创建一个事务作为当前事务的嵌套事务来运行\",{\"1\":{\"1514\":1}}],[\"则创建并获取锁\",{\"1\":{\"1151\":1}}],[\"则创建\",{\"1\":{\"1099\":1}}],[\"则后台根据手机号查询用户\",{\"1\":{\"1098\":1}}],[\"则后续提交的任务都会被丢弃\",{\"1\":{\"573\":1}}],[\"则无法通过校验\",{\"1\":{\"1098\":1}}],[\"则要推断使用\",{\"1\":{\"1505\":1}}],[\"则要么是库存不足\",{\"1\":{\"1157\":1}}],[\"则要求用户重新输入手机号\",{\"1\":{\"1098\":1}}],[\"则要将其写回外存\",{\"1\":{\"190\":1}}],[\"则使用轮询算法均衡地分配分区\",{\"1\":{\"1032\":1}}],[\"则序列号重新从0开始\",{\"1\":{\"999\":1}}],[\"则自增后的序列号超过了4095\",{\"1\":{\"999\":1}}],[\"则自动执行reduce\",{\"1\":{\"449\":1}}],[\"则还需要实现comparable接口\",{\"1\":{\"956\":1}}],[\"则还需再次访问内存中的页表\",{\"1\":{\"683\":1}}],[\"则表明这一位上的数据一定不存在\",{\"1\":{\"1177\":1}}],[\"则表明它\",{\"1\":{\"885\":1}}],[\"则表示需要创建代理\",{\"1\":{\"1333\":1}}],[\"则表示可以下单\",{\"1\":{\"1155\":1}}],[\"则表示他抢到了锁\",{\"1\":{\"1141\":1}}],[\"则表示获得到了锁\",{\"1\":{\"1140\":1}}],[\"则表示重复操作\",{\"1\":{\"1005\":1}}],[\"则表示退出安全模式之前\",{\"1\":{\"870\":1}}],[\"则整个集群不可用\",{\"1\":{\"883\":1}}],[\"则允许所有主机准入\",{\"1\":{\"880\":1}}],[\"则复制\",{\"1\":{\"876\":1}}],[\"则跳过\",{\"1\":{\"876\":1}}],[\"则跳过该stripe\",{\"1\":{\"437\":1}}],[\"则unsetpolicy是no\",{\"1\":{\"875\":1}}],[\"则用来缓冲读写数据\",{\"1\":{\"861\":1}}],[\"则用cas累加这个域\",{\"1\":{\"564\":1}}],[\"则影响\",{\"1\":{\"840\":1}}],[\"则扩容后\",{\"1\":{\"773\":2}}],[\"则选择下一个\",{\"1\":{\"773\":2}}],[\"则每次都得创建新的\",{\"1\":{\"770\":1}}],[\"则每个存储单元大小为1个字\",{\"1\":{\"179\":1}}],[\"则每个存储单元大小为1字节\",{\"1\":{\"179\":1}}],[\"则每个进程都能顺利完成\",{\"1\":{\"177\":1}}],[\"则仅会打印\",{\"1\":{\"766\":4}}],[\"则抛出异常\",{\"1\":{\"698\":1,\"1514\":1}}],[\"则抛出classnotfoundexception异常\",{\"1\":{\"630\":1}}],[\"则必须修改redis配置文件\",{\"1\":{\"1196\":1}}],[\"则必须事先为作业一次性地申请一个足以容纳整个作业的内存空间\",{\"1\":{\"689\":1}}],[\"则必是线程安全的\",{\"1\":{\"627\":1}}],[\"则挂起当前线程\",{\"1\":{\"680\":1}}],[\"则继续向下遍历\",{\"1\":{\"668\":2}}],[\"则都是\",{\"1\":{\"663\":1}}],[\"则进入到第三个条件\",{\"1\":{\"1152\":1}}],[\"则进一步判断库存是否足够\",{\"1\":{\"1134\":1,\"1137\":1}}],[\"则进一步向上委托\",{\"1\":{\"623\":1}}],[\"则进行封装\",{\"1\":{\"1482\":2}}],[\"则进行删除\",{\"1\":{\"1144\":1}}],[\"则进行操作成功\",{\"1\":{\"1135\":1}}],[\"则进行互斥锁的获取\",{\"1\":{\"1127\":1}}],[\"则进行拦截\",{\"1\":{\"1098\":1}}],[\"则进行延迟发送\",{\"1\":{\"694\":1}}],[\"则进行类加载\",{\"1\":{\"630\":1}}],[\"则进程进入下一级队列队尾\",{\"1\":{\"167\":1}}],[\"则当前线程会一直阻塞在read操作上\",{\"1\":{\"609\":1}}],[\"则当这个类需要修改时\",{\"1\":{\"73\":1}}],[\"则通过cas创建链表头节点\",{\"1\":{\"579\":1}}],[\"则线程不安全\",{\"1\":{\"539\":1}}],[\"则线程安全\",{\"1\":{\"539\":2}}],[\"则该变量属于临界资源\",{\"1\":{\"539\":1}}],[\"则打断标记\",{\"1\":{\"534\":1}}],[\"则有可能无限制的命中过期key\",{\"1\":{\"529\":1}}],[\"则有可能产生两次中断\",{\"1\":{\"190\":1}}],[\"则会把引导类范围内\",{\"1\":{\"1455\":1}}],[\"则会与原表名t\",{\"1\":{\"1232\":1}}],[\"则会再次去进行重试\",{\"1\":{\"1153\":1}}],[\"则会进去抢锁\",{\"1\":{\"1152\":1}}],[\"则会对cell和base的值进行递增\",{\"1\":{\"1136\":1}}],[\"则会对该节点注册监听\",{\"1\":{\"885\":1}}],[\"则会从mysql中加载最新的数据\",{\"1\":{\"1122\":1}}],[\"则会覆盖default的配置\",{\"1\":{\"963\":1}}],[\"则会导致内存泄露的产生\",{\"1\":{\"636\":1}}],[\"则会先删除这个key然后重新选取\",{\"1\":{\"529\":1}}],[\"则会做出主从切换\",{\"1\":{\"526\":1}}],[\"则从磁盘读取后放入buffer\",{\"1\":{\"506\":1}}],[\"则时间就是单调递增的了\",{\"1\":{\"502\":1}}],[\"则执行下一步\",{\"1\":{\"1532\":1}}],[\"则执行业务\",{\"1\":{\"1005\":1}}],[\"则执行\",{\"1\":{\"477\":2}}],[\"则优先分配较小编号的桶\",{\"1\":{\"364\":1}}],[\"则它是窗口函数\",{\"1\":{\"356\":1}}],[\"则所有组合情况是\",{\"1\":{\"352\":2}}],[\"则引发异常\",{\"1\":{\"340\":1}}],[\"则返回代理\",{\"1\":{\"1482\":1}}],[\"则返回blog不存在\",{\"1\":{\"1161\":1}}],[\"则返回\",{\"1\":{\"1152\":1}}],[\"则返回true\",{\"1\":{\"1142\":1,\"1144\":1}}],[\"则返回0\",{\"1\":{\"1127\":1}}],[\"则返回字符串在常量池中的地址\",{\"1\":{\"632\":1}}],[\"则返回一个空流\",{\"1\":{\"616\":1}}],[\"则返回对应的treenode\",{\"1\":{\"579\":1}}],[\"则返回null\",{\"1\":{\"340\":1}}],[\"则返回新new出来的对象\",{\"1\":{\"69\":1}}],[\"则hive将流式传输最右边的表\",{\"1\":{\"326\":2}}],[\"则hive将多个表上的联接转换为单个mr作业\",{\"1\":{\"326\":1}}],[\"则hive将使用hadoop配置变量fs\",{\"1\":{\"290\":1}}],[\"则hive会将数据写入本地文件系统上的目录\",{\"1\":{\"290\":1}}],[\"则除非用户alter\",{\"1\":{\"281\":1}}],[\"则视图将失败\",{\"1\":{\"270\":1}}],[\"则可以将对象序列化为json字符串后存储\",{\"1\":{\"1207\":1}}],[\"则可以将其作为仅map作业执行\",{\"1\":{\"326\":1}}],[\"则可以重用池中\",{\"1\":{\"770\":1}}],[\"则可以使用thrift\",{\"1\":{\"244\":1}}],[\"则可能会导致饥饿\",{\"1\":{\"167\":1}}],[\"则为用户创建账号信息\",{\"1\":{\"1098\":1}}],[\"则为true\",{\"1\":{\"332\":5}}],[\"则为null\",{\"1\":{\"293\":1,\"332\":2,\"365\":2}}],[\"则为本地模式\",{\"1\":{\"243\":1}}],[\"则为进程分配一个空闲块\",{\"1\":{\"190\":1}}],[\"则即使系统中还有同类型的设备\",{\"1\":{\"213\":1}}],[\"则程序无法运行\",{\"1\":{\"213\":1}}],[\"则平均所需的延迟时间$t\",{\"1\":{\"204\":1}}],[\"则访问一个数据块只需要k\",{\"1\":{\"197\":1}}],[\"则一个磁盘块只能存放256个索引项\",{\"1\":{\"197\":1}}],[\"则一个时间段内只有一个程序运行\",{\"1\":{\"155\":1}}],[\"则又是低效的\",{\"1\":{\"192\":1}}],[\"则将之前说的信息存入到到\",{\"1\":{\"1155\":1}}],[\"则将\",{\"1\":{\"1155\":1}}],[\"则将用户信息保存到threadlocal中\",{\"1\":{\"1098\":1}}],[\"则将序列号递增1\",{\"1\":{\"999\":1}}],[\"则将该值设置为fs\",{\"1\":{\"910\":1}}],[\"则将这些页面的访问依次置为0\",{\"1\":{\"191\":1}}],[\"则将它置为0\",{\"1\":{\"191\":1}}],[\"则末尾k位标识页内偏移量\",{\"1\":{\"184\":1}}],[\"则修改对应分区号\",{\"1\":{\"182\":1}}],[\"则c一直不执行\",{\"1\":{\"176\":1}}],[\"则系统不会进入死锁状态\",{\"1\":{\"176\":1}}],[\"则长进程一直无法获得处理机\",{\"1\":{\"175\":1}}],[\"则设置正在访问临界资源的标志\",{\"1\":{\"168\":1}}],[\"则由处理器通知操作系统将相应的页面或段调入到内存\",{\"1\":{\"689\":1}}],[\"则由页面置换算法选择一个页面淘汰\",{\"1\":{\"190\":1}}],[\"则由于新进程处于优先级更高的队列中\",{\"1\":{\"167\":1}}],[\"则由新进程抢占处理机\",{\"1\":{\"167\":1}}],[\"则i\",{\"1\":{\"167\":1}}],[\"则剥夺处理机\",{\"1\":{\"167\":1}}],[\"则立即暂停正在执行的\",{\"1\":{\"165\":1}}],[\"则需要向beanfactory添加一些后置处理器来解析这些注解\",{\"1\":{\"1502\":1}}],[\"则需要resultmap来手动指定映射关系\",{\"1\":{\"1230\":1}}],[\"则需要发送\",{\"1\":{\"694\":4}}],[\"则需要根据readview来确定\",{\"1\":{\"503\":1}}],[\"则需要设置两个管道\",{\"1\":{\"162\":1}}],[\"则需要保护被中断进程的cpu环境\",{\"1\":{\"157\":1}}],[\"则需要组装手\",{\"1\":{\"19\":1}}],[\"则共享性失去存在的意义\",{\"1\":{\"155\":1}}],[\"则\",{\"1\":{\"105\":1,\"204\":1,\"665\":1,\"1152\":1}}],[\"则a依赖于x\",{\"1\":{\"105\":1}}],[\"则不进行删除\",{\"1\":{\"1144\":1}}],[\"则不进行锁的删除\",{\"1\":{\"1143\":1}}],[\"则不再下单\",{\"1\":{\"1137\":1}}],[\"则不禁止任何主机加入\",{\"1\":{\"880\":1}}],[\"则不能退役成功\",{\"1\":{\"879\":1}}],[\"则不能传递\",{\"1\":{\"104\":1}}],[\"则不久后该数据可能再次被访问\",{\"1\":{\"687\":1}}],[\"则不久后该指令可能再次执行\",{\"1\":{\"687\":1}}],[\"则不会清空打断状态\",{\"1\":{\"534\":1}}],[\"则不允许\",{\"1\":{\"248\":1}}],[\"则不适合使用建造者模式\",{\"1\":{\"15\":1}}],[\"某一个产品的一个文档\",{\"1\":{\"1063\":1}}],[\"某个字段的数据类型\",{\"1\":{\"1065\":1}}],[\"某个字段在\",{\"1\":{\"493\":1}}],[\"某个节点崩溃\",{\"1\":{\"1050\":1}}],[\"某个事务正在进行就必须要取消了\",{\"1\":{\"1042\":1}}],[\"某个key包含了大量的数据\",{\"1\":{\"1034\":1}}],[\"某个\",{\"1\":{\"1026\":1}}],[\"某个对象的构建过程复杂的情况\",{\"1\":{\"12\":1}}],[\"某种程度上也保证了hive元数据的安全\",{\"1\":{\"240\":1}}],[\"某种程度上也可以提高开发效率\",{\"1\":{\"17\":1}}],[\"某些线程因为优先级太低\",{\"1\":{\"553\":1}}],[\"某些文件属性保存在目录中\",{\"1\":{\"196\":1}}],[\"某些死锁进程\",{\"1\":{\"178\":1}}],[\"某进程在执行的过程中一直跳不出某个循环的现象\",{\"1\":{\"175\":1}}],[\"某进程无法向前推进的现象\",{\"1\":{\"175\":1}}],[\"f$$enhancerbyspringcglib$$8b54f2bc\",{\"1\":{\"1294\":1}}],[\"f2\",{\"1\":{\"776\":4,\"1294\":2}}],[\"f1\",{\"1\":{\"776\":7,\"1294\":2}}],[\"ff\",{\"1\":{\"698\":1}}],[\"fffffffffff|\",{\"1\":{\"699\":1}}],[\"ffff\",{\"1\":{\"697\":1}}],[\"fd\",{\"1\":{\"740\":1}}],[\"fddi\",{\"1\":{\"694\":1}}],[\"fd剧增后带来的io效率问题\",{\"1\":{\"680\":1}}],[\"flink可以实现背压机制\",{\"1\":{\"1055\":1}}],[\"flink里面有对应的每种不同机制的保证\",{\"1\":{\"1053\":1}}],[\"flink\",{\"1\":{\"951\":1}}],[\"flip\",{\"1\":{\"796\":1,\"797\":1,\"798\":1,\"804\":1,\"807\":3,\"808\":2,\"809\":1,\"815\":1,\"826\":1,\"827\":1,\"836\":1,\"840\":2,\"846\":1,\"848\":1,\"857\":1,\"859\":1}}],[\"flux\",{\"1\":{\"791\":1}}],[\"flush\",{\"1\":{\"697\":2,\"698\":1,\"699\":1,\"775\":1,\"795\":2}}],[\"flag\",{\"1\":{\"1127\":2,\"1129\":2}}],[\"flags\",{\"1\":{\"663\":5}}],[\"flatmap\",{\"1\":{\"617\":2}}],[\"floor\",{\"1\":{\"338\":4}}],[\"floatwritable\",{\"1\":{\"956\":1}}],[\"floatbuffer\",{\"1\":{\"610\":1,\"861\":1}}],[\"float和double在存储的时候\",{\"1\":{\"480\":1}}],[\"float\",{\"1\":{\"248\":2,\"579\":1,\"772\":2,\"956\":1,\"1206\":1}}],[\"fh\",{\"1\":{\"579\":3}}],[\"fh是链表头结点的hash\",{\"1\":{\"579\":1}}],[\"f是链表头节点\",{\"1\":{\"579\":1}}],[\"feed\",{\"1\":{\"1167\":5,\"1168\":1}}],[\"feed流产品有两种常见模式\",{\"1\":{\"1166\":1}}],[\"feed流的实现有两种模式\",{\"1\":{\"1166\":1}}],[\"feed流实现方案\",{\"0\":{\"1166\":1}}],[\"federation体系中多个namenode之间相互独立且不需要互相协调\",{\"1\":{\"889\":1}}],[\"federation中文意思为联邦\",{\"1\":{\"889\":1}}],[\"federation联邦机制\",{\"0\":{\"887\":1}}],[\"fetchsource\",{\"1\":{\"1079\":1}}],[\"fetcher\",{\"1\":{\"980\":1}}],[\"fetch\",{\"1\":{\"457\":1}}],[\"female\",{\"1\":{\"340\":1}}],[\"font>\",{\"1\":{\"1083\":1}}],[\"follows\",{\"1\":{\"1165\":6,\"1167\":2}}],[\"followserviceimpl\",{\"1\":{\"1165\":2}}],[\"followservice\",{\"1\":{\"1164\":3,\"1167\":1}}],[\"followuserid\",{\"1\":{\"1164\":4}}],[\"follow\",{\"1\":{\"1164\":13,\"1165\":9,\"1167\":6,\"1168\":1}}],[\"followcontroller\",{\"1\":{\"1164\":1}}],[\"follow`\",{\"1\":{\"1164\":1}}],[\"follow表来标示\",{\"1\":{\"1164\":1}}],[\"followerid\",{\"1\":{\"1164\":5,\"1165\":7}}],[\"follower不能读写数据\",{\"1\":{\"1048\":1}}],[\"follower可以读取\",{\"1\":{\"1048\":1}}],[\"follower职责\",{\"1\":{\"1048\":1}}],[\"follower做的事情就是同步数据\",{\"1\":{\"1043\":1}}],[\"follower\",{\"1\":{\"1026\":3}}],[\"following\",{\"1\":{\"361\":2}}],[\"foo\",{\"1\":{\"920\":5,\"1304\":10,\"1306\":3,\"1309\":14}}],[\"forward\",{\"1\":{\"1436\":1}}],[\"forwardingnode出现在扩容时\",{\"1\":{\"579\":1}}],[\"forwardingnode的理解\",{\"1\":{\"579\":1}}],[\"forwardingnode<k\",{\"1\":{\"579\":1}}],[\"forceclose\",{\"1\":{\"743\":2}}],[\"forceflush\",{\"1\":{\"742\":1}}],[\"force\",{\"1\":{\"480\":1,\"819\":1}}],[\"form\",{\"0\":{\"316\":1},\"1\":{\"1461\":1}}],[\"formattingconversionservice\",{\"1\":{\"1368\":1}}],[\"formatterpropertyeditoradapter\",{\"1\":{\"1369\":1}}],[\"formatter\",{\"1\":{\"1368\":1,\"1370\":1}}],[\"formatted|extended|dependency|authorization|\",{\"1\":{\"441\":1}}],[\"formatted\",{\"1\":{\"276\":1,\"279\":1,\"441\":1,\"458\":1}}],[\"format=compact\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"format=org\",{\"1\":{\"436\":1}}],[\"format这一行所代表的是跟读写文件\",{\"1\":{\"251\":1}}],[\"format\",{\"1\":{\"251\":2,\"252\":1,\"256\":1,\"260\":1,\"261\":1,\"262\":1,\"266\":1,\"279\":1,\"280\":1,\"281\":1,\"285\":1,\"287\":1,\"290\":5,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"374\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"397\":1,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"999\":3,\"1132\":1,\"1175\":1,\"1176\":1}}],[\"foreach\",{\"1\":{\"47\":1,\"616\":1,\"617\":3,\"618\":1,\"621\":2,\"717\":1,\"718\":1,\"823\":1,\"1024\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":3,\"1161\":1,\"1172\":1}}],[\"forname\",{\"1\":{\"42\":1,\"59\":6,\"733\":2,\"734\":1,\"805\":1}}],[\"for\",{\"1\":{\"42\":1,\"47\":2,\"81\":2,\"88\":1,\"271\":1,\"279\":1,\"369\":1,\"442\":1,\"458\":1,\"496\":4,\"513\":2,\"555\":6,\"579\":3,\"593\":2,\"617\":1,\"645\":2,\"646\":3,\"648\":7,\"649\":6,\"668\":3,\"669\":4,\"673\":1,\"692\":1,\"693\":1,\"696\":1,\"697\":2,\"698\":2,\"699\":2,\"702\":3,\"704\":2,\"733\":1,\"740\":1,\"741\":1,\"742\":1,\"743\":2,\"746\":2,\"789\":1,\"795\":2,\"799\":18,\"809\":1,\"820\":1,\"826\":1,\"827\":1,\"840\":2,\"843\":1,\"846\":1,\"958\":1,\"960\":1,\"972\":1,\"973\":1,\"974\":1,\"983\":1,\"986\":1,\"988\":4,\"999\":2,\"1023\":1,\"1025\":1,\"1132\":2,\"1167\":1,\"1168\":2,\"1171\":2,\"1172\":1,\"1180\":1,\"1219\":1,\"1257\":1,\"1451\":1}}],[\"f\",{\"1\":{\"340\":1,\"579\":9,\"648\":15,\"692\":1,\"693\":2,\"697\":11,\"698\":11,\"699\":11,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":7,\"779\":4,\"780\":2,\"799\":1,\"805\":2,\"807\":3,\"808\":4,\"836\":2,\"848\":1,\"854\":2,\"857\":1,\"876\":1,\"1002\":1,\"1294\":39}}],[\"fsimage内存镜像文件\",{\"1\":{\"905\":1}}],[\"fsdatainputstream类是dfsinputstream类的包装\",{\"1\":{\"902\":1}}],[\"fsdataoutputstream是dfsoutputstream包装类\",{\"1\":{\"901\":1}}],[\"fs\",{\"1\":{\"281\":6,\"680\":1,\"910\":2,\"920\":5,\"926\":6,\"928\":1,\"936\":1,\"972\":3,\"973\":3,\"974\":3,\"988\":3}}],[\"fuzziness\",{\"1\":{\"1082\":2}}],[\"fuzzyquery\",{\"1\":{\"1082\":4}}],[\"fuzzyquerybuilder\",{\"1\":{\"1082\":1}}],[\"fuzhu\",{\"1\":{\"261\":1}}],[\"future<recordmetadata>\",{\"1\":{\"1023\":1}}],[\"future<\",{\"1\":{\"758\":1}}],[\"future<integer>\",{\"1\":{\"757\":1,\"758\":1}}],[\"future<v>\",{\"1\":{\"756\":3}}],[\"future\",{\"0\":{\"756\":1,\"757\":1,\"758\":1},\"1\":{\"725\":2,\"735\":1,\"737\":2,\"740\":2,\"743\":3,\"753\":2,\"754\":1,\"756\":10,\"757\":3,\"758\":5,\"761\":3,\"764\":1,\"766\":2,\"794\":1,\"1023\":3,\"1152\":2}}],[\"fullname\",{\"1\":{\"1525\":2}}],[\"fullrows\",{\"1\":{\"799\":4}}],[\"full\",{\"0\":{\"323\":1,\"628\":1},\"1\":{\"323\":3,\"461\":1,\"628\":2,\"1055\":1}}],[\"function<id\",{\"1\":{\"1129\":3}}],[\"function<\",{\"1\":{\"614\":1}}],[\"functionalinterface\",{\"1\":{\"614\":1}}],[\"function\",{\"1\":{\"328\":2,\"334\":3,\"344\":1,\"358\":1,\"621\":1}}],[\"functions\",{\"1\":{\"328\":1,\"334\":2,\"336\":1,\"337\":1,\"338\":1,\"339\":1,\"341\":1,\"342\":1,\"343\":1,\"356\":1}}],[\"func\",{\"1\":{\"313\":1}}],[\"func3\",{\"1\":{\"73\":2}}],[\"func2\",{\"1\":{\"73\":1}}],[\"func1\",{\"1\":{\"73\":5}}],[\"fc\",{\"1\":{\"986\":2}}],[\"fcb的改进\",{\"1\":{\"196\":1}}],[\"fcfs优点\",{\"1\":{\"167\":1}}],[\"fcfs\",{\"1\":{\"167\":1,\"204\":1}}],[\"f6fbed833a9af8b9e4df67b0c17c3fc\",{\"1\":{\"187\":1}}],[\"f7cd987ba102ecf12110ee6a4416034\",{\"1\":{\"186\":1}}],[\"free函数释放内存\",{\"1\":{\"682\":1}}],[\"frequently\",{\"1\":{\"522\":2}}],[\"front\",{\"1\":{\"669\":1}}],[\"fromcoordinate\",{\"1\":{\"1172\":1}}],[\"fromjson\",{\"1\":{\"723\":1}}],[\"from风格\",{\"1\":{\"318\":1}}],[\"from\",{\"0\":{\"288\":1},\"1\":{\"260\":2,\"261\":1,\"266\":1,\"271\":7,\"272\":2,\"276\":4,\"286\":4,\"287\":6,\"288\":1,\"289\":2,\"290\":6,\"298\":1,\"300\":1,\"302\":4,\"303\":6,\"307\":3,\"310\":2,\"313\":2,\"315\":6,\"316\":5,\"317\":4,\"318\":18,\"320\":3,\"321\":2,\"322\":2,\"323\":2,\"324\":2,\"325\":4,\"326\":7,\"329\":1,\"330\":10,\"331\":6,\"332\":8,\"337\":4,\"338\":1,\"339\":2,\"340\":2,\"348\":2,\"349\":2,\"351\":16,\"353\":7,\"354\":5,\"355\":2,\"357\":2,\"360\":4,\"361\":2,\"363\":3,\"364\":3,\"365\":4,\"367\":2,\"368\":3,\"369\":2,\"378\":3,\"382\":1,\"385\":1,\"388\":3,\"391\":1,\"395\":1,\"396\":2,\"400\":5,\"402\":1,\"404\":2,\"409\":2,\"410\":1,\"423\":1,\"437\":4,\"452\":1,\"455\":1,\"460\":3,\"465\":1,\"481\":2,\"482\":2,\"495\":1,\"496\":4,\"741\":1,\"820\":8,\"985\":2,\"1017\":1,\"1077\":1,\"1107\":1,\"1167\":1,\"1172\":4,\"1219\":1,\"1230\":13}}],[\"frac\",{\"0\":{\"362\":1,\"364\":1},\"1\":{\"204\":3}}],[\"framework\",{\"0\":{\"1562\":1},\"1\":{\"789\":1,\"963\":2,\"1332\":1,\"1335\":1,\"1338\":1,\"1342\":1,\"1345\":1,\"1349\":1,\"1499\":1}}],[\"frame\",{\"1\":{\"14\":5}}],[\"fry\",{\"1\":{\"85\":2}}],[\"friends\",{\"1\":{\"76\":1}}],[\"failover\",{\"0\":{\"885\":1}}],[\"failed\",{\"1\":{\"857\":2,\"859\":3,\"986\":1,\"1444\":1}}],[\"failedchannel\",{\"1\":{\"740\":1}}],[\"failure\",{\"1\":{\"638\":1,\"740\":1,\"762\":2,\"763\":2,\"764\":2,\"882\":1}}],[\"fail\",{\"1\":{\"602\":1,\"1099\":3,\"1107\":2,\"1122\":2,\"1129\":1,\"1134\":4,\"1135\":2,\"1137\":9,\"1142\":4,\"1150\":4,\"1156\":1,\"1157\":1,\"1160\":1,\"1161\":1,\"1167\":1}}],[\"fail机制\",{\"1\":{\"602\":1}}],[\"facade\",{\"1\":{\"1370\":1}}],[\"factories中的各种autoconfiguration类\",{\"1\":{\"1524\":1}}],[\"factories\",{\"1\":{\"1446\":1,\"1464\":2,\"1465\":1}}],[\"factor\",{\"1\":{\"606\":1,\"1020\":1}}],[\"factorybeanobjectcache\",{\"1\":{\"1472\":1}}],[\"factorybean\",{\"0\":{\"1469\":1,\"1470\":1},\"1\":{\"1472\":2}}],[\"factory\",{\"1\":{\"28\":1,\"33\":1,\"34\":5,\"38\":2,\"42\":4,\"59\":4,\"60\":2}}],[\"facebook\",{\"1\":{\"377\":6}}],[\"fastclass\",{\"1\":{\"1321\":1}}],[\"fastthreadlocal\",{\"1\":{\"792\":1}}],[\"fastthreadlocalrunnable\",{\"1\":{\"762\":2,\"765\":4}}],[\"fast事件\",{\"1\":{\"602\":1}}],[\"fast\",{\"1\":{\"602\":1}}],[\"fasterxml\",{\"1\":{\"104\":2,\"112\":1,\"113\":1,\"1070\":1,\"1219\":1}}],[\"fashi\",{\"1\":{\"261\":1}}],[\"father\",{\"1\":{\"671\":11}}],[\"fat\",{\"1\":{\"197\":1}}],[\"fans\",{\"1\":{\"76\":10}}],[\"false使用默认数据源\",{\"1\":{\"1236\":1}}],[\"false代表获取锁失败\",{\"1\":{\"1142\":1}}],[\"false\",{\"1\":{\"69\":1,\"81\":2,\"248\":28,\"332\":1,\"554\":2,\"555\":9,\"579\":1,\"585\":2,\"598\":1,\"701\":1,\"702\":2,\"703\":2,\"704\":1,\"728\":1,\"740\":4,\"741\":6,\"742\":2,\"743\":4,\"744\":3,\"772\":1,\"775\":1,\"827\":2,\"831\":1,\"834\":1,\"836\":2,\"840\":2,\"843\":3,\"846\":4,\"876\":1,\"1028\":1,\"1100\":1,\"1111\":2,\"1161\":1,\"1172\":2,\"1236\":1,\"1254\":1,\"1325\":1,\"1505\":2,\"1525\":1,\"1531\":1}}],[\"fixedlengthframedecoder\",{\"1\":{\"697\":1}}],[\"finishconnect\",{\"1\":{\"742\":1,\"843\":1}}],[\"finished\",{\"1\":{\"593\":2}}],[\"fin\",{\"1\":{\"694\":1}}],[\"findeligibleadvisors\",{\"1\":{\"1333\":2}}],[\"findbypageable\",{\"1\":{\"1089\":1}}],[\"findbyid\",{\"1\":{\"1089\":2}}],[\"findautowiringmetadata\",{\"1\":{\"1267\":1}}],[\"findall\",{\"1\":{\"1089\":3}}],[\"findany\",{\"1\":{\"619\":1}}],[\"findfirst\",{\"1\":{\"619\":2}}],[\"find\",{\"1\":{\"336\":3,\"579\":1,\"671\":5}}],[\"finalout\",{\"1\":{\"991\":1}}],[\"final>\",{\"1\":{\"919\":1,\"926\":1}}],[\"final<\",{\"1\":{\"783\":1}}],[\"final类型的\",{\"1\":{\"595\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"574\":2}}],[\"final原理\",{\"0\":{\"567\":1}}],[\"final的使用\",{\"1\":{\"566\":1}}],[\"finalname>\",{\"1\":{\"102\":1}}],[\"finally\",{\"1\":{\"69\":1,\"554\":2,\"555\":2,\"590\":2,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"725\":1,\"733\":2,\"735\":1,\"740\":1,\"741\":3,\"743\":1,\"744\":1,\"775\":3,\"1127\":1,\"1128\":1,\"1129\":2,\"1142\":1,\"1150\":2,\"1157\":1}}],[\"final\",{\"1\":{\"17\":1,\"47\":1,\"59\":7,\"66\":1,\"68\":1,\"69\":2,\"81\":5,\"85\":2,\"541\":1,\"551\":2,\"554\":1,\"555\":2,\"562\":2,\"566\":1,\"567\":2,\"579\":5,\"585\":6,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"718\":1,\"723\":17,\"725\":4,\"733\":2,\"737\":1,\"738\":1,\"740\":24,\"741\":3,\"742\":1,\"743\":8,\"744\":5,\"749\":2,\"799\":10,\"846\":1,\"859\":3,\"958\":1,\"990\":1,\"999\":10,\"1071\":1,\"1101\":1,\"1113\":3,\"1128\":1,\"1129\":2,\"1132\":2,\"1142\":1,\"1144\":1,\"1147\":1,\"1156\":1,\"1157\":1,\"1215\":1,\"1223\":1,\"1285\":1,\"1294\":2,\"1298\":1,\"1307\":1,\"1309\":1,\"1310\":1,\"1480\":1}}],[\"fieldvalue\",{\"1\":{\"1107\":2}}],[\"fieldname\",{\"1\":{\"1107\":1}}],[\"fieldtype\",{\"1\":{\"1089\":4}}],[\"field\",{\"0\":{\"1064\":1},\"1\":{\"279\":1,\"565\":1,\"567\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":4,\"1162\":2,\"1168\":1,\"1172\":1,\"1208\":2,\"1370\":2}}],[\"fields\",{\"1\":{\"252\":1,\"256\":1,\"260\":1,\"261\":1,\"262\":1,\"266\":1,\"281\":1,\"285\":1,\"287\":1,\"290\":2,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"972\":6,\"974\":5,\"986\":8,\"988\":14,\"990\":6}}],[\"fillbeanwithmap\",{\"1\":{\"1111\":1}}],[\"filtercharacters\",{\"1\":{\"617\":3}}],[\"filter=true\",{\"1\":{\"437\":1}}],[\"filter\",{\"1\":{\"437\":5,\"616\":2,\"658\":1,\"1411\":3,\"1447\":1,\"1462\":1}}],[\"filter>\",{\"1\":{\"344\":1}}],[\"filters>\",{\"1\":{\"344\":1}}],[\"filters\",{\"1\":{\"276\":1}}],[\"filename\",{\"1\":{\"988\":4,\"1159\":4}}],[\"file<\",{\"1\":{\"936\":1}}],[\"file序列化文件\",{\"1\":{\"906\":1}}],[\"filevisitresult\",{\"1\":{\"822\":5}}],[\"filecount\",{\"1\":{\"822\":6}}],[\"filechannel\",{\"0\":{\"811\":1,\"812\":1},\"1\":{\"610\":1,\"796\":2,\"807\":1,\"808\":1,\"812\":1,\"813\":2,\"820\":4,\"831\":1,\"861\":1}}],[\"filealreadyexistsexception\",{\"1\":{\"822\":2}}],[\"fileinputformat\",{\"1\":{\"470\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"fileinputstream\",{\"1\":{\"54\":1,\"68\":1,\"813\":2,\"816\":1,\"820\":2,\"990\":1}}],[\"fileoutputformat\",{\"1\":{\"433\":3,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"988\":1,\"991\":2}}],[\"fileoutputstream\",{\"1\":{\"54\":1,\"68\":1,\"813\":2,\"816\":1,\"820\":2}}],[\"fileformat\",{\"1\":{\"279\":1,\"280\":1}}],[\"filepath\",{\"1\":{\"261\":1,\"283\":2}}],[\"filesplit\",{\"1\":{\"988\":2}}],[\"filesystemxmlapplicationcontext\",{\"1\":{\"1245\":1}}],[\"filesystem\",{\"1\":{\"972\":2,\"973\":2,\"974\":2,\"988\":2}}],[\"filesystem封装了与文件系统操作的相关方法\",{\"1\":{\"901\":1,\"902\":1}}],[\"filesize=25m\",{\"1\":{\"448\":1}}],[\"files\",{\"0\":{\"822\":1},\"1\":{\"250\":2,\"822\":15,\"823\":5,\"1449\":1}}],[\"file\",{\"1\":{\"124\":1,\"279\":1,\"280\":1,\"290\":1,\"430\":1,\"677\":1,\"680\":1,\"796\":2,\"807\":2,\"808\":2,\"822\":9,\"854\":5,\"934\":2,\"936\":1,\"991\":4,\"1159\":2,\"1449\":1}}],[\"fips\",{\"1\":{\"265\":2,\"266\":1}}],[\"fifo\",{\"1\":{\"191\":2,\"690\":1}}],[\"firstregistration\",{\"1\":{\"740\":2,\"743\":2}}],[\"first`\",{\"1\":{\"495\":1}}],[\"first1\",{\"1\":{\"365\":1}}],[\"firstname\",{\"1\":{\"272\":4}}],[\"first\",{\"1\":{\"167\":4,\"278\":1,\"279\":3,\"342\":4,\"358\":1,\"365\":4,\"619\":2}}],[\"fireexceptioncaught\",{\"1\":{\"743\":1}}],[\"firechannelreadcomplete\",{\"1\":{\"743\":1,\"744\":1}}],[\"firechannelread\",{\"1\":{\"743\":1,\"744\":1,\"748\":1,\"766\":1,\"775\":3}}],[\"firechannelregistered\",{\"1\":{\"740\":1,\"743\":1}}],[\"firechannelactive\",{\"1\":{\"740\":3,\"743\":2}}],[\"fireproof\",{\"1\":{\"75\":7}}],[\"firewalld\",{\"1\":{\"878\":2}}],[\"firewall\",{\"1\":{\"63\":1}}],[\"fight\",{\"1\":{\"81\":3}}],[\"金士顿内存条\",{\"1\":{\"74\":1}}],[\"金士顿\",{\"1\":{\"17\":2}}],[\"即数据访问对象\",{\"1\":{\"1529\":1}}],[\"即数组中每个元素是字符串中的一个字符\",{\"1\":{\"662\":1}}],[\"即自动实例化正确的事务管理器\",{\"1\":{\"1515\":1}}],[\"即调用构造方法前\",{\"1\":{\"1505\":1}}],[\"即调用它们的销毁方法\",{\"1\":{\"1252\":1}}],[\"即指定了\",{\"1\":{\"1454\":1}}],[\"即会匹配到所有请求\",{\"1\":{\"1438\":1}}],[\"即只映射\",{\"1\":{\"1436\":1}}],[\"即所谓的\",{\"1\":{\"1411\":1}}],[\"即是\",{\"1\":{\"1384\":1}}],[\"即是哪个\",{\"1\":{\"1384\":1}}],[\"即是确认字符\",{\"1\":{\"899\":1}}],[\"即从\",{\"1\":{\"1362\":1}}],[\"即把之前的逻辑再操作一次\",{\"1\":{\"1135\":1}}],[\"即把分散的数据合并成一个大的数据\",{\"1\":{\"966\":1}}],[\"即消费者组是逻辑上的一个订阅者\",{\"1\":{\"1026\":1}}],[\"即对于同一台机器而言\",{\"1\":{\"998\":1}}],[\"即对事务a是否可见\",{\"1\":{\"503\":1}}],[\"即如何分配数据给各个reducetask\",{\"1\":{\"968\":1}}],[\"即重复步骤\",{\"1\":{\"953\":1}}],[\"即最终仲裁者\",{\"1\":{\"944\":1}}],[\"即最近最久未使用的页面\",{\"1\":{\"191\":1}}],[\"即哪个块位于哪个节点上\",{\"1\":{\"905\":1}}],[\"即不需要拷贝该文件\",{\"1\":{\"879\":1}}],[\"即不需要手动修改\",{\"1\":{\"663\":1}}],[\"即初始化器\",{\"1\":{\"743\":1}}],[\"即接收一个客户端连接\",{\"1\":{\"743\":1}}],[\"即首次调用\",{\"1\":{\"741\":1}}],[\"即滑动窗口\",{\"1\":{\"693\":1}}],[\"即选择最近最久未使用的页面进行淘汰\",{\"1\":{\"690\":1}}],[\"即选择在内存中驻留时间最久的页面进行淘汰\",{\"1\":{\"690\":1}}],[\"即可实现导入\",{\"1\":{\"1465\":1}}],[\"即可查看效果\",{\"1\":{\"1292\":1}}],[\"即可停止\",{\"1\":{\"1196\":1}}],[\"即可\",{\"1\":{\"827\":1,\"998\":1,\"1136\":1,\"1155\":1,\"1171\":1,\"1176\":1}}],[\"即可启动运行\",{\"1\":{\"689\":1}}],[\"即可以容纳的最大数据量\",{\"1\":{\"610\":1}}],[\"即程序在一段时间内所访问的地址可能集中在一定的范围内\",{\"1\":{\"687\":1}}],[\"即通过页号访问页表得到物理块号\",{\"1\":{\"683\":1}}],[\"即通过wrapper类二次封装原始类\",{\"1\":{\"10\":1}}],[\"即epoll使用mmap减少复制开销\",{\"1\":{\"680\":1}}],[\"即epoll最大的优点就在于他只管你\",{\"1\":{\"680\":1}}],[\"即新节点将成为\",{\"1\":{\"666\":1}}],[\"即为要导入的配置类\",{\"1\":{\"1464\":1}}],[\"即为视图完整路径\",{\"1\":{\"1441\":1}}],[\"即为字符串长度\",{\"1\":{\"662\":1}}],[\"即为级联更新\",{\"1\":{\"482\":1}}],[\"即提高了吞吐量\",{\"1\":{\"637\":1}}],[\"即4个字节大小\",{\"1\":{\"630\":1}}],[\"即aio\",{\"1\":{\"611\":1}}],[\"即客户端有连接请求时\",{\"1\":{\"609\":1}}],[\"即被加锁的内容要按照顺序被多个线程执行\",{\"1\":{\"559\":1}}],[\"即当两个事务互相等待时\",{\"1\":{\"513\":1}}],[\"即当前acid版本号是2\",{\"1\":{\"293\":1}}],[\"即btree和hash\",{\"1\":{\"485\":1}}],[\"即使没有连接建立\",{\"1\":{\"827\":1}}],[\"即使\",{\"1\":{\"804\":1}}],[\"即使调用了\",{\"1\":{\"775\":1}}],[\"即使发送一个字节\",{\"1\":{\"694\":1}}],[\"即使发生连锁更新\",{\"1\":{\"667\":1}}],[\"即使发生宕机等故障\",{\"1\":{\"506\":1}}],[\"即使一个变量的大小不到\",{\"1\":{\"663\":1}}],[\"即使部分哨兵节点挂掉了\",{\"1\":{\"526\":1}}],[\"即使是阻塞\",{\"1\":{\"795\":1}}],[\"即使是组合字段\",{\"1\":{\"493\":1}}],[\"即使是多个字段的组合\",{\"1\":{\"481\":1}}],[\"即使所有类属性名与数据库字段一一对应\",{\"1\":{\"483\":1}}],[\"即使双表join也要注意表索引\",{\"1\":{\"481\":1}}],[\"即使在应用层做了非常完善的校验控制\",{\"1\":{\"481\":1}}],[\"即使实现细节不断变动\",{\"1\":{\"74\":1}}],[\"即在\",{\"1\":{\"663\":1}}],[\"即在自旋的时候持锁的线程释放了锁\",{\"1\":{\"542\":1}}],[\"即在group\",{\"1\":{\"307\":1}}],[\"即在某进程开始访问临界区到结束访问为止都不允许被中断\",{\"1\":{\"170\":1}}],[\"即delta前缀\",{\"1\":{\"293\":1}}],[\"即先删除\",{\"1\":{\"292\":1,\"293\":1}}],[\"即宽表化处理\",{\"1\":{\"226\":1}}],[\"即寄存器独立编址\",{\"1\":{\"208\":1}}],[\"即引导块\",{\"1\":{\"206\":1}}],[\"即文件分配表\",{\"1\":{\"197\":1}}],[\"即随机访问\",{\"1\":{\"197\":1}}],[\"即每次读入一块\",{\"1\":{\"197\":1}}],[\"即读写可以同时进行\",{\"1\":{\"850\":1}}],[\"即读\",{\"1\":{\"197\":1}}],[\"即将页表项中的物理块号与页内偏移地址拼接成实际物理地址后访问实际物理地址所耗费的时间\",{\"1\":{\"683\":1}}],[\"即将进入terminated状态\",{\"1\":{\"571\":1}}],[\"即将进程再细分为很多的线程\",{\"1\":{\"163\":1}}],[\"即将逻辑地址a中的数据复制到逻辑地址b\",{\"1\":{\"190\":1}}],[\"即页号\",{\"1\":{\"184\":1}}],[\"即8个二进制位\",{\"1\":{\"179\":1}}],[\"即1b\",{\"1\":{\"179\":1}}],[\"即必须保证\",{\"1\":{\"172\":1}}],[\"即fcfs算法对长作业有利\",{\"1\":{\"167\":1}}],[\"即\",{\"1\":{\"165\":1,\"169\":1,\"192\":2,\"638\":1,\"772\":2,\"840\":1,\"854\":1,\"999\":1,\"1271\":1,\"1447\":2,\"1449\":1}}],[\"即用户级线程对用户不透明\",{\"1\":{\"163\":1}}],[\"即该\",{\"1\":{\"100\":1}}],[\"即负责实现具体的策略\",{\"1\":{\"80\":1}}],[\"即产品的构建过程和最终的表示是独立的\",{\"1\":{\"16\":1}}],[\"其处理流程是\",{\"1\":{\"1438\":1}}],[\"其wrapper方法中第一个参数为condition\",{\"1\":{\"1234\":1}}],[\"其value是一个无序字典\",{\"1\":{\"1208\":1}}],[\"其value是字符串\",{\"1\":{\"1206\":1}}],[\"其测量结果是概率性的\",{\"1\":{\"1179\":1}}],[\"其后果是\",{\"1\":{\"1120\":1}}],[\"其语义完全由你来定\",{\"1\":{\"1062\":1}}],[\"其本质就是reducer\",{\"1\":{\"970\":1}}],[\"其hadoop数据类型分别为longwritable和text\",{\"1\":{\"959\":1}}],[\"其间也不会使用\",{\"1\":{\"854\":1}}],[\"其各个方法均无法正常使用\",{\"1\":{\"775\":1}}],[\"其返回值都是\",{\"1\":{\"772\":1}}],[\"其它有路径的\",{\"1\":{\"1438\":1}}],[\"其它的排在最后\",{\"1\":{\"1260\":1}}],[\"其它参数会放入argv数组\",{\"1\":{\"1146\":1}}],[\"其它参数\",{\"1\":{\"1146\":1}}],[\"其它就是处理es里面数据的一些使用规则设置也叫做映射\",{\"1\":{\"1065\":1}}],[\"其它网络应用框架\",{\"1\":{\"792\":1}}],[\"其它实现还有\",{\"1\":{\"784\":1,\"785\":1}}],[\"其它\",{\"0\":{\"1468\":1},\"1\":{\"775\":1,\"801\":1,\"1293\":1}}],[\"其它两个都处于\",{\"1\":{\"726\":1}}],[\"其它代码不变\",{\"1\":{\"693\":1}}],[\"其大小通过\",{\"1\":{\"726\":1}}],[\"其大小是32个整数的大小\",{\"1\":{\"680\":1}}],[\"其演示图如下\",{\"1\":{\"690\":1}}],[\"其重要意义在于定义了一个连续的虚拟地址空间\",{\"1\":{\"688\":1}}],[\"其附近的存储单元也将被访问\",{\"1\":{\"687\":1}}],[\"其附近的存储单元也很有可能被访问\",{\"1\":{\"189\":1}}],[\"其目的是为了更好地满足用户的需求\",{\"1\":{\"683\":1}}],[\"其目的是降低类之间的耦合度\",{\"1\":{\"76\":1}}],[\"其效率也会线性下降\",{\"1\":{\"680\":1}}],[\"其效果与\",{\"1\":{\"100\":1}}],[\"其良好跨平台支持也是他的一个优点\",{\"1\":{\"680\":1}}],[\"其区别在于参数和返回值有所区别\",{\"1\":{\"614\":1}}],[\"其相关的类和接口在java\",{\"1\":{\"609\":1}}],[\"其结果就是永久的\",{\"1\":{\"506\":1}}],[\"其结果不被显示\",{\"1\":{\"317\":1}}],[\"其次看\",{\"1\":{\"1398\":1}}],[\"其次使用\",{\"1\":{\"1376\":1}}],[\"其次我们需要排序\",{\"1\":{\"1162\":1}}],[\"其次\",{\"1\":{\"493\":1,\"1466\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"77\":1}}],[\"其只支持使用单字节分隔符\",{\"1\":{\"371\":1}}],[\"其最大特点是\",{\"1\":{\"356\":1}}],[\"其数据来源于源表\",{\"1\":{\"348\":1}}],[\"其数据并不存储在底层的文件中\",{\"1\":{\"259\":1}}],[\"其余部分暂留在盘上\",{\"1\":{\"688\":1}}],[\"其余部分就是页号\",{\"1\":{\"184\":1}}],[\"其余的页表项仍然驻留在磁盘上\",{\"1\":{\"683\":1}}],[\"其余进行掩码处理\",{\"1\":{\"342\":1}}],[\"其字段数为表字段数+2\",{\"1\":{\"285\":1}}],[\"其原理类似于mapreduce中的分区\",{\"1\":{\"263\":1}}],[\"其访问位置为1\",{\"1\":{\"191\":1}}],[\"其响应比也会越来越大\",{\"1\":{\"167\":1}}],[\"其频率很高\",{\"1\":{\"164\":1}}],[\"其backbone如下图所示\",{\"1\":{\"136\":1}}],[\"其他详见\",{\"1\":{\"1523\":1}}],[\"其他数字都是\",{\"1\":{\"1176\":1}}],[\"其他人插入失败则表示无法获得到锁\",{\"1\":{\"1140\":1}}],[\"其他的人在处理时\",{\"1\":{\"1136\":1}}],[\"其他的线程只能返回之前的数据\",{\"1\":{\"1126\":1}}],[\"其他系统可以消费消息队列中的数据\",{\"1\":{\"1009\":1}}],[\"其他策略默认是禁用的\",{\"1\":{\"875\":1}}],[\"其他线程会执行\",{\"1\":{\"1147\":1}}],[\"其他线程才能走返回正确的数据\",{\"1\":{\"1126\":1}}],[\"其他线程就都能从缓存中加载这些数据了\",{\"1\":{\"1126\":1}}],[\"其他线程去异步处理数据库\",{\"1\":{\"1120\":1}}],[\"其他线程将signal这个队列中的元素\",{\"1\":{\"584\":1}}],[\"其他线程将无法再获取互斥锁及共享锁\",{\"1\":{\"582\":1}}],[\"其他线程来put\",{\"1\":{\"579\":1}}],[\"其他线程永远无法获取锁\",{\"1\":{\"536\":1}}],[\"其他线程可以使用interrupt方法打断正在睡眠的线程\",{\"1\":{\"533\":1}}],[\"其他事务如果需要修改数据\",{\"1\":{\"506\":1}}],[\"其他没有产生数据倾斜的数据由reduce\",{\"1\":{\"470\":1}}],[\"其他\",{\"1\":{\"351\":1}}],[\"其他杂项函数\",{\"0\":{\"343\":1},\"1\":{\"343\":1}}],[\"其他语法\",{\"0\":{\"277\":1}}],[\"其他依赖hive的软件都可以通过metastore访问hive\",{\"1\":{\"244\":1}}],[\"其他用户对探店笔记的评价\",{\"1\":{\"1159\":1}}],[\"其他用户无任何权限\",{\"1\":{\"925\":1}}],[\"其他用户组的用户\",{\"1\":{\"917\":1}}],[\"其他用户组\",{\"1\":{\"917\":1}}],[\"其他用户\",{\"1\":{\"201\":1}}],[\"其他用户也可以看到文件数据的变化\",{\"1\":{\"200\":1}}],[\"其他需要操作系统实现的文件管理功能\",{\"1\":{\"194\":1}}],[\"其他试图进入临界区的进程必须等待\",{\"1\":{\"168\":1}}],[\"其他条件全部具备\",{\"1\":{\"160\":1}}],[\"其他服务依赖此模块\",{\"1\":{\"110\":1}}],[\"其他都相同\",{\"1\":{\"52\":1}}],[\"其功能是将目标\",{\"1\":{\"100\":1}}],[\"其用于添加非\",{\"1\":{\"100\":1}}],[\"其在编译时只需\",{\"1\":{\"100\":1}}],[\"其子类可以进行覆盖也可以直接继承\",{\"1\":{\"84\":1}}],[\"其中被\",{\"1\":{\"1503\":1}}],[\"其中记录了序列化时对应的class名称\",{\"1\":{\"1222\":1}}],[\"其中记录了该段在内存中的起始位置\",{\"1\":{\"187\":1}}],[\"其中封装了各种对redis的操作\",{\"1\":{\"1217\":1}}],[\"其中对redis的集成模块就叫做springdataredis\",{\"1\":{\"1217\":1}}],[\"其中java客户端也包含很多\",{\"1\":{\"1212\":1}}],[\"其中常见的options有\",{\"1\":{\"1199\":1}}],[\"其中键值型\",{\"1\":{\"1182\":1}}],[\"其中大\",{\"1\":{\"1151\":1}}],[\"其中就包含了各种分布式锁的实现\",{\"1\":{\"1149\":1}}],[\"其中do\",{\"1\":{\"1135\":1}}],[\"其中dbinputformat负责从数据库中读取数据\",{\"1\":{\"984\":1}}],[\"其中v是dbwritable类型的\",{\"1\":{\"985\":1}}],[\"其中key必须具有扩展dbwritable的类型\",{\"1\":{\"986\":1}}],[\"其中key是词\",{\"1\":{\"477\":1}}],[\"其中k是longwritalbe类型的\",{\"1\":{\"985\":1}}],[\"其中包括applicationmaster程序\",{\"1\":{\"953\":1}}],[\"其中包含\",{\"1\":{\"284\":1}}],[\"其中newbandwidth是每个datanode在平衡操作期间可以使用的最大网络带宽量\",{\"1\":{\"873\":1}}],[\"其中n为被删除key的数量\",{\"1\":{\"523\":1}}],[\"其中队列使用了\",{\"1\":{\"741\":1}}],[\"其中确定具体消息类型\",{\"1\":{\"723\":1}}],[\"其中λ为访问快表所需时间\",{\"1\":{\"683\":1}}],[\"其中的commonds就是redis的操作命令\",{\"1\":{\"1199\":1}}],[\"其中的任意一个进入读就绪状态\",{\"1\":{\"679\":1}}],[\"其中的第一个将a与b连接起来\",{\"1\":{\"326\":1}}],[\"其中这多余的\",{\"1\":{\"663\":1}}],[\"其中serial\",{\"1\":{\"638\":1}}],[\"其中又分为\",{\"1\":{\"628\":1}}],[\"其中运用了设计模式中的模板方法\",{\"1\":{\"581\":1}}],[\"其中用到的原理和longadder差不多使用了cell\",{\"1\":{\"579\":1}}],[\"其中用户定义可以分成三类\",{\"1\":{\"334\":1}}],[\"其中函数中的操作能保证原子\",{\"1\":{\"562\":4}}],[\"其中后几位为001表示无锁\",{\"1\":{\"540\":1}}],[\"其中m为以上数据类型种元素的数量\",{\"1\":{\"523\":1}}],[\"其中mapjoin效率较高\",{\"1\":{\"418\":1}}],[\"其中一个事务进行回滚\",{\"1\":{\"513\":1}}],[\"其中无符号值可以避免误存负数\",{\"1\":{\"480\":1}}],[\"其中id必为主键\",{\"1\":{\"480\":1}}],[\"其中第三步\",{\"1\":{\"478\":1}}],[\"其中parse\",{\"1\":{\"376\":1}}],[\"其中pcb不会被调到外存\",{\"1\":{\"164\":1}}],[\"其中function\",{\"1\":{\"358\":1}}],[\"其中有两个参数tmp\",{\"1\":{\"261\":1}}],[\"其中local为可选字段\",{\"1\":{\"261\":1}}],[\"其中\",{\"1\":{\"232\":1,\"289\":1,\"292\":1,\"726\":1,\"753\":1,\"768\":1,\"784\":1,\"1029\":1,\"1193\":1,\"1355\":1,\"1522\":1}}],[\"其中association中的select对应rolemapper\",{\"1\":{\"1230\":1}}],[\"其中a\",{\"1\":{\"176\":1}}],[\"其中并发和共享是两个最基本的特征\",{\"1\":{\"155\":1}}],[\"其中与ground\",{\"1\":{\"139\":1}}],[\"其中在9个anchor中\",{\"1\":{\"138\":1}}],[\"其中小尺度特征\",{\"1\":{\"138\":1}}],[\"其中concat就是在上采样之后\",{\"1\":{\"137\":1}}],[\"其中取号\",{\"1\":{\"83\":1}}],[\"其中拿铁咖啡\",{\"1\":{\"39\":1}}],[\"其组合就很多\",{\"1\":{\"77\":1}}],[\"其组成部分相似\",{\"1\":{\"15\":1}}],[\"其含义是\",{\"1\":{\"76\":1}}],[\"其实并非将接口交给\",{\"1\":{\"1455\":1}}],[\"其实并没有用到栈的特性\",{\"1\":{\"690\":1}}],[\"其实主要就是补充了一些\",{\"1\":{\"1271\":1}}],[\"其实只需要到小卡片上看一看就知道了\",{\"1\":{\"1174\":1}}],[\"其实可以考虑小时候一个挺常见的方案\",{\"1\":{\"1174\":1}}],[\"其实我们又把他叫做feed流\",{\"1\":{\"1166\":1}}],[\"其实使用mysql作为分布式锁比较少见\",{\"1\":{\"1140\":1}}],[\"其实使用string就可以啦\",{\"1\":{\"1104\":1}}],[\"其实就不会有缓存击穿的问题\",{\"1\":{\"1126\":1}}],[\"其实就是说上面的\",{\"1\":{\"1502\":1}}],[\"其实就是负载均衡\",{\"1\":{\"1048\":1}}],[\"其实就是给网络传输的信息加上\",{\"1\":{\"709\":1}}],[\"其实就是前缀和\",{\"1\":{\"361\":1}}],[\"其实就是在初始化instance的时候才会出现线程安全问题\",{\"1\":{\"66\":1}}],[\"其实就是使用到了适配器模式\",{\"1\":{\"4\":1}}],[\"其实雪花算法每一部分占用的比特位数量并不是固定死的\",{\"1\":{\"1001\":1}}],[\"其实\",{\"1\":{\"839\":1}}],[\"其实这些认识都比较片面\",{\"1\":{\"755\":1}}],[\"其实这边就是事务表的相关操作没什么好说的\",{\"1\":{\"299\":1}}],[\"其实是从\",{\"1\":{\"1322\":1}}],[\"其实是this\",{\"1\":{\"1137\":1}}],[\"其实是由额外的线程执行的\",{\"1\":{\"516\":1}}],[\"其实是存在问题\",{\"1\":{\"66\":1}}],[\"其实现方式是在数据库取到statementname对应的sql语句的所有记录\",{\"1\":{\"483\":1}}],[\"其实得根据主键类型进行动态判断\",{\"1\":{\"480\":1}}],[\"其实还可以通过msck实现分区表数据的加载\",{\"1\":{\"261\":1}}],[\"其内部含有对真实主题的引用\",{\"1\":{\"57\":1}}],[\"其产品的各个部分经常面临着剧烈的变化\",{\"1\":{\"16\":1}}],[\"一并返回给dispatcherservlet\",{\"1\":{\"1530\":1}}],[\"一不留神就会用错\",{\"1\":{\"1472\":1}}],[\"一看当前这把锁不是属于自己\",{\"1\":{\"1143\":1}}],[\"一人一单判断\",{\"1\":{\"1157\":1}}],[\"一人一单逻辑\",{\"1\":{\"1137\":1}}],[\"一人一单\",{\"0\":{\"1137\":1},\"1\":{\"1156\":1}}],[\"一句话\",{\"1\":{\"1114\":1}}],[\"一致则删除锁\",{\"1\":{\"1147\":1}}],[\"一致\",{\"1\":{\"1099\":1,\"1107\":1,\"1146\":2}}],[\"一致性的实现也需要在应用层面进行保障\",{\"1\":{\"506\":1}}],[\"一致性是事务追求的最终目标\",{\"1\":{\"506\":1}}],[\"一致性是指事务将数据库从一种状态转变为另一种一致的状态\",{\"1\":{\"506\":1}}],[\"一致性实现原理\",{\"1\":{\"506\":1}}],[\"一致性\",{\"1\":{\"506\":1}}],[\"一样可以实现数据操作的负载均衡\",{\"1\":{\"1048\":1}}],[\"一样切换读写模式\",{\"1\":{\"781\":1}}],[\"一部分是低级的\",{\"1\":{\"1333\":1}}],[\"一部分数据丢失影响不大\",{\"1\":{\"1043\":1}}],[\"一部分为用户空间\",{\"1\":{\"676\":1}}],[\"一部分为内核空间\",{\"1\":{\"676\":1}}],[\"一类用于部署服务\",{\"1\":{\"951\":1}}],[\"一类直接运行数据处理程序\",{\"1\":{\"951\":1}}],[\"一方面\",{\"1\":{\"946\":1,\"1510\":1}}],[\"一台kafka\",{\"1\":{\"1026\":1}}],[\"一台机器上一个\",{\"1\":{\"944\":1}}],[\"一台手机有4gb内存\",{\"1\":{\"179\":1}}],[\"一开始\",{\"1\":{\"798\":1}}],[\"一开始需要树立正确的观念\",{\"1\":{\"787\":1}}],[\"一直向前传\",{\"1\":{\"775\":1}}],[\"一直持续到结尾\",{\"1\":{\"666\":1}}],[\"一条线是继承自\",{\"1\":{\"746\":1}}],[\"一条指令在执行期间\",{\"1\":{\"190\":1}}],[\"一位私塾先生到一家任教\",{\"1\":{\"709\":1}}],[\"一定要用\",{\"1\":{\"1300\":1}}],[\"一定要保证这笔订单是已支付的状态\",{\"1\":{\"1005\":1}}],[\"一定容量的内存和外存\",{\"1\":{\"689\":1}}],[\"一定没有歧义\",{\"1\":{\"306\":1}}],[\"一级页表\",{\"1\":{\"683\":1}}],[\"一些资料会提到\",{\"1\":{\"1252\":1}}],[\"一些比较耗时的操作\",{\"1\":{\"1055\":1}}],[\"一些检查\",{\"1\":{\"740\":1,\"743\":1}}],[\"一些涉及底层的程序编写往往会围绕着文件描述符展开\",{\"1\":{\"677\":1}}],[\"一些提供close的资源未关闭导致内存泄漏\",{\"1\":{\"636\":1}}],[\"一共五个数据\",{\"1\":{\"875\":1}}],[\"一共设计了\",{\"1\":{\"663\":2}}],[\"一共9个anchor\",{\"1\":{\"138\":1}}],[\"一款优秀的收集器通常最多同时满足其中的两项\",{\"1\":{\"637\":1}}],[\"一下都是基于jdk\",{\"1\":{\"579\":1}}],[\"一段时间申请不到锁的权限了\",{\"1\":{\"551\":1}}],[\"一种在类加载阶段实现\",{\"1\":{\"1508\":1}}],[\"一种在编译阶段实现\",{\"1\":{\"1508\":1}}],[\"一种数据可能会重复消费\",{\"1\":{\"1054\":1}}],[\"一种思路是首先分配一个较小的\",{\"1\":{\"841\":1}}],[\"一种思路是固定消息长度\",{\"1\":{\"840\":1}}],[\"一种解读\",{\"1\":{\"709\":1}}],[\"一种是整堆收集\",{\"1\":{\"628\":1}}],[\"一种是部分收集\",{\"1\":{\"628\":1}}],[\"一种资源只能被一个线程所使用\",{\"1\":{\"551\":1}}],[\"一种将多个group\",{\"1\":{\"352\":1}}],[\"一是易出错\",{\"1\":{\"483\":1}}],[\"一律不要使用\",{\"1\":{\"483\":1}}],[\"一切外键概念必须在应用层解决\",{\"1\":{\"482\":1}}],[\"一起执行提交\",{\"1\":{\"991\":1}}],[\"一起安装部署\",{\"1\":{\"474\":1}}],[\"一起使用\",{\"1\":{\"228\":1,\"549\":1,\"714\":1,\"723\":1,\"831\":1}}],[\"一系列的过程比较繁琐\",{\"1\":{\"444\":1}}],[\"一年就是365gb的数据\",{\"1\":{\"414\":1}}],[\"一进多出\",{\"1\":{\"334\":1}}],[\"一进一出\",{\"1\":{\"334\":1}}],[\"一元运算符\",{\"1\":{\"331\":1}}],[\"一次减少2个\",{\"1\":{\"1206\":1}}],[\"一次增加2\",{\"1\":{\"1206\":1}}],[\"一次可以提交\",{\"1\":{\"991\":1}}],[\"一次无法写完例子\",{\"0\":{\"843\":1}}],[\"一次只能穿2g\",{\"1\":{\"820\":1}}],[\"一次事件会触发一次\",{\"1\":{\"744\":1}}],[\"一次事件内会触发多次\",{\"1\":{\"744\":1}}],[\"一次性读入内存中的需要查找的关键字也就越多\",{\"1\":{\"488\":1}}],[\"一次性加载整个表的所有数据\",{\"1\":{\"286\":1}}],[\"一次扫描\",{\"1\":{\"288\":2}}],[\"一次磁盘读\",{\"1\":{\"204\":1}}],[\"一次调入若干个相邻的页面可能比一次调入一个页面更加高效\",{\"1\":{\"192\":1}}],[\"一份\",{\"1\":{\"200\":1}}],[\"一前一后\",{\"1\":{\"172\":1}}],[\"一对原语\",{\"1\":{\"171\":1}}],[\"一对一模型\",{\"1\":{\"163\":1}}],[\"一\",{\"0\":{\"90\":1},\"1\":{\"1168\":1}}],[\"一般使用prehandle方法\",{\"1\":{\"1532\":1}}],[\"一般使用自增的方式\",{\"1\":{\"997\":1}}],[\"一般用来声明配置类\",{\"1\":{\"1525\":1}}],[\"一般用于连接数较多且连接时长较长的应用\",{\"1\":{\"611\":1}}],[\"一般用于需要计数的场景\",{\"1\":{\"515\":1}}],[\"一般\",{\"1\":{\"1140\":2}}],[\"一般要满足下列特性\",{\"1\":{\"1131\":1}}],[\"一般从数据库中获取\",{\"1\":{\"1113\":1}}],[\"一般放在请求头上\",{\"1\":{\"1005\":1}}],[\"一般可以使用服务上线时间作为初始时间戳值\",{\"1\":{\"1001\":1}}],[\"一般来说\",{\"1\":{\"924\":1}}],[\"一般来说这个数目和系统内存关系很大\",{\"1\":{\"680\":1}}],[\"一般需要将\",{\"1\":{\"775\":1}}],[\"一般情况下\",{\"1\":{\"775\":1}}],[\"一般情况下抽象的变化概率很小\",{\"1\":{\"74\":1}}],[\"一般会调用\",{\"1\":{\"746\":1}}],[\"一般为\",{\"1\":{\"694\":1,\"744\":1}}],[\"一般为10g\",{\"1\":{\"526\":1}}],[\"一般作为衡量其他置换算法的方法\",{\"1\":{\"690\":1}}],[\"一般是16或32\",{\"1\":{\"1094\":1}}],[\"一般是创建该文件的用户\",{\"1\":{\"917\":1}}],[\"一般是读就绪或者写就绪\",{\"1\":{\"680\":1}}],[\"一般是数字\",{\"1\":{\"483\":1}}],[\"一般都可以使用分布查询来解决\",{\"1\":{\"1230\":1}}],[\"一般都设置成为non\",{\"1\":{\"679\":1}}],[\"一般都使用spark了\",{\"1\":{\"472\":1}}],[\"一般表的逐渐类型为int\",{\"1\":{\"487\":1}}],[\"一般对字符串类型数据\",{\"1\":{\"481\":1,\"493\":1}}],[\"一般以时间\",{\"1\":{\"415\":1}}],[\"一般只要使用udtf\",{\"1\":{\"349\":1}}],[\"一般不适用\",{\"1\":{\"574\":1}}],[\"一般不使用\",{\"1\":{\"525\":1}}],[\"一般不建议使用方法a和b\",{\"1\":{\"325\":1}}],[\"一般不推荐使用hive\",{\"1\":{\"419\":1}}],[\"一般不推荐使用\",{\"1\":{\"100\":1}}],[\"一般几十毫秒一次\",{\"1\":{\"164\":1}}],[\"一般模板方法都加上\",{\"1\":{\"85\":1}}],[\"一般钩子方法是用于判断的逻辑方法\",{\"1\":{\"84\":1}}],[\"一般产品类和建造者类是比较稳定的\",{\"1\":{\"15\":1}}],[\"一旦我们向redis采用这样的方式存储\",{\"1\":{\"1207\":1}}],[\"一旦复制了\",{\"1\":{\"1067\":1}}],[\"一旦客户端完成读取\",{\"1\":{\"902\":1}}],[\"一旦有了volume\",{\"1\":{\"874\":1}}],[\"一旦有了simplecoffeefactory\",{\"1\":{\"28\":1}}],[\"一旦\",{\"1\":{\"828\":1,\"953\":1}}],[\"一旦超时会退出\",{\"1\":{\"741\":1}}],[\"一旦基于某个文件扫描符就绪时\",{\"1\":{\"680\":1}}],[\"一旦该fd就绪\",{\"1\":{\"680\":1}}],[\"一旦某个描述符就绪\",{\"1\":{\"680\":1}}],[\"一旦kernel中的数据准备好了\",{\"1\":{\"679\":1}}],[\"一旦队列中添加了一个元素\",{\"1\":{\"584\":1}}],[\"一旦程序访问了某个存储单元\",{\"1\":{\"189\":1,\"687\":1}}],[\"一旦作业被装入内存\",{\"1\":{\"189\":1}}],[\"一旦初始化完成就不存在了\",{\"1\":{\"66\":1}}],[\"一整套一起换\",{\"1\":{\"41\":1}}],[\"一个请求方法只可以有一个\",{\"1\":{\"1525\":1}}],[\"一个错误处理搞得这么复杂\",{\"1\":{\"1411\":1}}],[\"一个受\",{\"1\":{\"1252\":1}}],[\"一个月则最多需要\",{\"1\":{\"1174\":1}}],[\"一个去创建订单等等\",{\"1\":{\"1155\":1}}],[\"一个执行判断扣减库存\",{\"1\":{\"1155\":1}}],[\"一个是不带参数\",{\"1\":{\"1152\":1}}],[\"一个是带参数\",{\"1\":{\"1152\":1}}],[\"一个是下菜心\",{\"1\":{\"85\":1}}],[\"一个人可以无限制的抢这个优惠卷\",{\"1\":{\"1137\":1}}],[\"一个字符不同也能匹配成功\",{\"1\":{\"1082\":1}}],[\"一个具有10亿文档数据的索引占据1tb的磁盘空间\",{\"1\":{\"1066\":1}}],[\"一个具体方法由一个抽象类或具体类声明并实现\",{\"1\":{\"84\":1}}],[\"一个文档是一个可被索引的基础信息单元\",{\"1\":{\"1063\":1}}],[\"一个文件夹表示一个分区\",{\"1\":{\"236\":1}}],[\"一个索引也可以被复制0次\",{\"1\":{\"1067\":1}}],[\"一个索引可以存储超出单个节点硬件限制的大量数据\",{\"1\":{\"1066\":1}}],[\"一个索引由一个名字来标识\",{\"1\":{\"1061\":1}}],[\"一个索引就是一个拥有几分相似特征的文档的集合\",{\"1\":{\"1061\":1}}],[\"一个索引表项4b\",{\"1\":{\"197\":1}}],[\"一个key可以对应多个不同版本的value\",{\"1\":{\"1056\":1}}],[\"一个broker\",{\"1\":{\"1054\":1}}],[\"一个分区只能由一个组内消费者消费\",{\"1\":{\"1026\":1}}],[\"一个分组调用一次\",{\"1\":{\"961\":1}}],[\"一个集群由多个broker\",{\"1\":{\"1026\":1}}],[\"一个组中的消费者是共同消费kafka中topic的数据\",{\"1\":{\"1024\":1}}],[\"一个消费者消费一个消息\",{\"1\":{\"1010\":1}}],[\"一个表中的主键\",{\"1\":{\"997\":1}}],[\"一个数组不够\",{\"1\":{\"841\":1}}],[\"一个线程执行查询优惠卷\",{\"1\":{\"1155\":1}}],[\"一个线程配合\",{\"1\":{\"829\":1}}],[\"一个线程\",{\"1\":{\"826\":2,\"851\":1}}],[\"一个线程对应一个selector\",{\"1\":{\"610\":1}}],[\"一个线程对volatile变量的修改对另一个线程可见\",{\"1\":{\"558\":1}}],[\"一个线程对共享变量值的修改\",{\"1\":{\"556\":1}}],[\"一个病人看完了\",{\"1\":{\"755\":1}}],[\"一个学年段亦告结束\",{\"1\":{\"709\":1}}],[\"一个段就是一个连续的物理地址空间\",{\"1\":{\"683\":1}}],[\"一个典型的读操作流程如上图所示\",{\"1\":{\"679\":1}}],[\"一个名叫\",{\"1\":{\"658\":1}}],[\"一个不够吗\",{\"1\":{\"638\":1}}],[\"一个对象从诞生到被回收所经历的时间\",{\"1\":{\"637\":1}}],[\"一个新的对象已经产生了\",{\"1\":{\"630\":1}}],[\"一个selector对应多个channel\",{\"1\":{\"610\":1}}],[\"一个类型是你的索引的一个逻辑上的分类\",{\"1\":{\"1062\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"595\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口上\",{\"1\":{\"75\":1}}],[\"一个操作一旦开始\",{\"1\":{\"556\":1}}],[\"一个操作时另一个不能够访问\",{\"1\":{\"162\":1}}],[\"一个锁对象对应着一个monitor\",{\"1\":{\"541\":1}}],[\"一个用于节点间通信\",{\"1\":{\"527\":1}}],[\"一个用于连接\",{\"1\":{\"527\":1}}],[\"一个用户只能下一单\",{\"1\":{\"1137\":1}}],[\"一个用户\",{\"1\":{\"927\":1}}],[\"一个用户进程会占用多个内核级线程\",{\"1\":{\"163\":1}}],[\"一个用户级线程映射到一个内核级线程\",{\"1\":{\"163\":1}}],[\"一个事务写时\",{\"1\":{\"506\":1}}],[\"一个事务读\",{\"1\":{\"506\":1}}],[\"一个页上一个小修改都要整页写入\",{\"1\":{\"506\":1}}],[\"一个单词一个单词的从文件中取出来\",{\"1\":{\"478\":1}}],[\"一个单核cpu同一时刻只能执行一个程序\",{\"1\":{\"155\":1}}],[\"一个orc文件包含一个或多个stripes\",{\"1\":{\"437\":1}}],[\"一个元素一行\",{\"1\":{\"346\":1}}],[\"一个或多个都行\",{\"1\":{\"336\":1}}],[\"一个参数n\",{\"1\":{\"309\":1}}],[\"一个自增的唯一id\",{\"1\":{\"293\":1}}],[\"一个时段只能分配一个进程\",{\"1\":{\"213\":1}}],[\"一个时间段内只允许一个进程使用的资源\",{\"1\":{\"168\":1}}],[\"一个i\",{\"1\":{\"208\":1}}],[\"一个磁盘只会建立一张文件分配表\",{\"1\":{\"197\":1}}],[\"一个作业装入内存时\",{\"1\":{\"179\":1}}],[\"一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存\",{\"1\":{\"685\":1}}],[\"一个进程对应一个页表\",{\"1\":{\"184\":1}}],[\"一个进程只有已经占有小编号的资源时\",{\"1\":{\"176\":1}}],[\"一个进程可能会多次调入\",{\"1\":{\"164\":1}}],[\"一个进程不能直接访问另一个进程的地址空间\",{\"1\":{\"162\":1}}],[\"一个系统中有很多个pcb\",{\"1\":{\"159\":1}}],[\"一个电脑供4g运行内存\",{\"1\":{\"155\":1}}],[\"一个物理上的实体变为若干个逻辑上的对应物\",{\"1\":{\"155\":1}}],[\"一个\",{\"1\":{\"107\":1,\"1026\":7}}],[\"一个项目就会出现相同的重复jar包\",{\"1\":{\"105\":1}}],[\"一个groupid下面可能多个项目\",{\"1\":{\"98\":1}}],[\"一个下包菜\",{\"1\":{\"85\":1}}],[\"一个抽象方法由抽象类声明\",{\"1\":{\"84\":1}}],[\"一个调用者想创建一个对象\",{\"1\":{\"23\":1}}],[\"一个产品家族是这样的一系列产品\",{\"1\":{\"20\":1}}],[\"一步一步创建一个复杂的对象\",{\"1\":{\"12\":1}}],[\"优惠卷是为了引流\",{\"1\":{\"1137\":1}}],[\"优惠卷秒杀\",{\"0\":{\"1130\":1}}],[\"优惠券库存不足\",{\"1\":{\"1156\":1}}],[\"优惠券id\",{\"1\":{\"1156\":1}}],[\"优惠券秒杀\",{\"0\":{\"1137\":1}}],[\"优惠券的库存\",{\"1\":{\"1133\":1}}],[\"优惠券的基本信息\",{\"1\":{\"1133\":1}}],[\"优惠金额\",{\"1\":{\"1133\":1}}],[\"优势💡\",{\"0\":{\"781\":1}}],[\"优雅关闭\",{\"1\":{\"747\":1}}],[\"优雅关闭💡\",{\"0\":{\"747\":1}}],[\"优化为非反射调用\",{\"1\":{\"1313\":1}}],[\"优化方案\",{\"0\":{\"1110\":1},\"1\":{\"1155\":1}}],[\"优化\",{\"0\":{\"855\":1}}],[\"优化重量级锁竞争\",{\"1\":{\"542\":1}}],[\"优化join\",{\"0\":{\"418\":1}}],[\"优化以及查询计划的生成\",{\"1\":{\"232\":1}}],[\"优化器介绍\",{\"0\":{\"454\":1}}],[\"优化器\",{\"0\":{\"451\":1},\"1\":{\"232\":1}}],[\"优化构建顺序\",{\"1\":{\"108\":1}}],[\"优先采用\",{\"1\":{\"1376\":1}}],[\"优先队列\",{\"1\":{\"572\":1}}],[\"优先级几乎没什么用\",{\"1\":{\"535\":1}}],[\"优先级较高的线程会获得更多的时间片\",{\"1\":{\"535\":1}}],[\"优先级高者优先\",{\"1\":{\"213\":1}}],[\"优先级调度算法\",{\"1\":{\"167\":1}}],[\"优先使用\",{\"1\":{\"962\":1}}],[\"优先使用map\",{\"1\":{\"467\":1}}],[\"优先使用最大的连续空闲区\",{\"1\":{\"183\":1}}],[\"优先使用更小的空闲区\",{\"1\":{\"183\":1}}],[\"优点有\",{\"1\":{\"770\":1}}],[\"优点是可以开启延迟加载\",{\"1\":{\"1230\":1}}],[\"优点是避免了拷贝引起的性能损耗\",{\"1\":{\"841\":1}}],[\"优点是消息连续容易处理\",{\"1\":{\"841\":1}}],[\"优点是既随机速度也很快\",{\"1\":{\"369\":1}}],[\"优点是速度快\",{\"1\":{\"368\":1}}],[\"优点\",{\"1\":{\"15\":1,\"23\":1,\"29\":1,\"35\":1,\"40\":1,\"62\":1,\"86\":1,\"163\":3,\"167\":4,\"170\":3,\"182\":2,\"188\":1,\"197\":3,\"201\":1,\"209\":3,\"485\":1,\"623\":1,\"779\":1,\"889\":1,\"1123\":2,\"1166\":4}}],[\"优缺点\",{\"0\":{\"15\":1,\"29\":1,\"35\":1,\"40\":1,\"62\":1,\"86\":1},\"1\":{\"167\":6,\"209\":3,\"633\":1,\"995\":1}}],[\"中国加油\",{\"1\":{\"1525\":1}}],[\"中引入的新的响应式框架\",{\"1\":{\"1499\":1}}],[\"中引用了外部的局部变量\",{\"1\":{\"562\":1}}],[\"中找有没有类型合适的对象注入\",{\"1\":{\"1482\":1}}],[\"中称为\",{\"1\":{\"1449\":1}}],[\"中默认顺序如上\",{\"1\":{\"1437\":1}}],[\"中获取\",{\"1\":{\"1362\":1}}],[\"中获取的\",{\"1\":{\"356\":1}}],[\"中用的的\",{\"1\":{\"1325\":1}}],[\"中方法与编号的对应关系\",{\"1\":{\"1321\":2}}],[\"中已废弃\",{\"1\":{\"1290\":1}}],[\"中非\",{\"1\":{\"1245\":1}}],[\"中值为\",{\"1\":{\"1174\":1}}],[\"中并没有存储\",{\"1\":{\"1171\":1}}],[\"中就一个\",{\"1\":{\"1171\":1}}],[\"中就有这个key\",{\"1\":{\"1141\":1}}],[\"中返回的结果是否是\",{\"1\":{\"1155\":1}}],[\"中判断用户是否可以下单\",{\"1\":{\"1155\":1}}],[\"中去根据\",{\"1\":{\"1155\":1}}],[\"中去\",{\"1\":{\"1155\":2,\"1171\":2}}],[\"中去快速校验一人一单\",{\"1\":{\"1155\":1}}],[\"中有两个最重要的方法\",{\"1\":{\"1132\":1}}],[\"中有堆外内存的\",{\"1\":{\"775\":1}}],[\"中间的更新动作意义并不大\",{\"1\":{\"1121\":1}}],[\"中确保\",{\"1\":{\"1037\":1}}],[\"中同步数据\",{\"1\":{\"1026\":1}}],[\"中后\",{\"1\":{\"1025\":1}}],[\"中会以什么样的策略返回\",{\"1\":{\"1023\":1}}],[\"中文意思为雪花\",{\"1\":{\"998\":1}}],[\"中文可译为溢写\",{\"1\":{\"979\":1}}],[\"中文文档\",{\"1\":{\"336\":1}}],[\"中提交一个应用程序后\",{\"1\":{\"952\":1}}],[\"中描述的资源\",{\"1\":{\"948\":1}}],[\"中对切点\",{\"1\":{\"1322\":1}}],[\"中对应着两个\",{\"1\":{\"855\":1}}],[\"中对下面的代码是怎样进行处理的\",{\"1\":{\"740\":1}}],[\"中所有数据都写入\",{\"1\":{\"843\":1}}],[\"中还有上次的\",{\"1\":{\"837\":1}}],[\"中调用\",{\"1\":{\"815\":1}}],[\"中很多方法都是异步的\",{\"1\":{\"785\":1}}],[\"中只有\",{\"1\":{\"743\":1}}],[\"中执行了\",{\"1\":{\"743\":1}}],[\"中如下代码\",{\"1\":{\"743\":1}}],[\"中关注\",{\"1\":{\"740\":1}}],[\"中使用其它几种\",{\"1\":{\"1293\":1}}],[\"中使用\",{\"1\":{\"740\":1}}],[\"中更容易说明\",{\"1\":{\"726\":1}}],[\"中消息传输基于流的方式\",{\"1\":{\"709\":1}}],[\"中包含对应查询的\",{\"1\":{\"1177\":1}}],[\"中包含\",{\"1\":{\"695\":1}}],[\"中含有\",{\"1\":{\"694\":1}}],[\"中是否包含当前的要查询的数据\",{\"1\":{\"1177\":1}}],[\"中是利用\",{\"1\":{\"1174\":1}}],[\"中是很常用的\",{\"1\":{\"661\":1}}],[\"中是一个线程等待另一个线程结束\",{\"1\":{\"547\":1}}],[\"中都存在一个threadlocalmap\",{\"1\":{\"577\":1}}],[\"中特有的方法\",{\"1\":{\"574\":1}}],[\"中因此不必是\",{\"1\":{\"562\":1}}],[\"中途给予不同的间隔时间\",{\"1\":{\"552\":1}}],[\"中挑选最近最少使用的数据淘汰\",{\"1\":{\"522\":1}}],[\"中大概存储16kb\",{\"1\":{\"487\":1}}],[\"中括号的语法表示可选\",{\"1\":{\"247\":1}}],[\"中继数据\",{\"1\":{\"238\":1}}],[\"中级调度就是决定将哪个处于挂起状态的进程重新调入内存\",{\"1\":{\"164\":1}}],[\"中级调度\",{\"1\":{\"164\":1,\"181\":1}}],[\"中断请求\",{\"1\":{\"688\":1}}],[\"中断正在执行的任务\",{\"1\":{\"571\":1}}],[\"中断处理程序\",{\"1\":{\"210\":1,\"211\":1}}],[\"中断驱动方式\",{\"1\":{\"209\":1}}],[\"中断屏蔽方法\",{\"1\":{\"170\":1}}],[\"中断的分类\",{\"1\":{\"157\":1}}],[\"中断可以使cpu从用户态切换为核心态\",{\"1\":{\"157\":1}}],[\"中断\",{\"0\":{\"157\":1},\"1\":{\"676\":2,\"689\":1}}],[\"中各自维护各自的依赖信息很容易发生出入\",{\"1\":{\"107\":1}}],[\"中最简单的设计模式之一\",{\"1\":{\"64\":1}}],[\"中的配置\",{\"1\":{\"1446\":1}}],[\"中的哪个方法\",{\"1\":{\"1384\":1}}],[\"中的体现\",{\"1\":{\"1362\":1,\"1394\":1}}],[\"中的统一\",{\"0\":{\"1322\":1}}],[\"中的扩展功能都没有用到\",{\"1\":{\"1240\":1}}],[\"中的指定元素的排名\",{\"1\":{\"1211\":3}}],[\"中的与秒杀优惠券相关的订单\",{\"1\":{\"1156\":1}}],[\"中的下单逻辑是否完成了\",{\"1\":{\"1155\":1}}],[\"中的程序\",{\"1\":{\"1155\":1}}],[\"中的不同partition\",{\"1\":{\"1026\":1}}],[\"中的消息可以分布在\",{\"1\":{\"1026\":1}}],[\"中的消息是以key\",{\"1\":{\"1023\":1}}],[\"中的资源抽象\",{\"1\":{\"948\":1}}],[\"中的内容全部写入\",{\"1\":{\"815\":1}}],[\"中的流程\",{\"1\":{\"743\":1}}],[\"中的一种错误机制\",{\"1\":{\"602\":1}}],[\"中的元数据包括表的名字\",{\"1\":{\"232\":1}}],[\"中的某标志位来表示当前处理器处于什么状态\",{\"1\":{\"156\":1}}],[\"中的\",{\"1\":{\"100\":1,\"562\":1,\"756\":2,\"855\":1,\"948\":1,\"1037\":2,\"1171\":1,\"1177\":1,\"1333\":1,\"1382\":2,\"1390\":2,\"1410\":1}}],[\"中的sell\",{\"1\":{\"59\":3}}],[\"中的引用类型的属性进行引用的复制\",{\"1\":{\"54\":1}}],[\"中\",{\"1\":{\"14\":1,\"100\":1,\"232\":1,\"459\":1,\"477\":1,\"678\":1,\"723\":1,\"725\":1,\"726\":2,\"775\":1,\"1023\":1,\"1026\":1,\"1129\":1,\"1151\":1,\"1155\":2,\"1156\":1,\"1174\":2,\"1175\":2,\"1244\":1,\"1245\":2,\"1411\":1,\"1417\":1,\"1438\":1}}],[\"建组合索引的时候\",{\"1\":{\"481\":1}}],[\"建表规约\",{\"0\":{\"480\":1}}],[\"建表时候通过表参数\",{\"1\":{\"437\":1}}],[\"建表时不指定存储格式即为textfile\",{\"1\":{\"427\":1}}],[\"建表\",{\"1\":{\"348\":1}}],[\"建表加载数据\",{\"1\":{\"348\":1,\"357\":1}}],[\"建表高阶语法\",{\"0\":{\"257\":1}}],[\"建表语句\",{\"1\":{\"256\":1}}],[\"建表语句中的语法顺序要和语法树中顺序保持一致\",{\"1\":{\"247\":1}}],[\"建议练习\",{\"1\":{\"1243\":1}}],[\"建议设置具有类似数量的datanode的机架\",{\"1\":{\"875\":1}}],[\"建议设置到\",{\"1\":{\"729\":1}}],[\"建议使用\",{\"1\":{\"794\":1}}],[\"建议明确字段\",{\"1\":{\"498\":1}}],[\"建议将数据拆成整数和小数分开存储\",{\"1\":{\"480\":1}}],[\"建议用远程模式来配置hive\",{\"1\":{\"244\":1}}],[\"建议还是封装到\",{\"1\":{\"14\":1}}],[\"建立关系\",{\"1\":{\"1252\":1}}],[\"建立\",{\"1\":{\"840\":1}}],[\"建立与客户端连接\",{\"1\":{\"826\":1,\"827\":1}}],[\"建立成功后\",{\"1\":{\"710\":1}}],[\"建立连接完毕\",{\"1\":{\"785\":1}}],[\"建立连接后\",{\"1\":{\"784\":1,\"785\":1}}],[\"建立连接\",{\"0\":{\"1202\":1},\"1\":{\"652\":1,\"1213\":2,\"1216\":1}}],[\"建立orc格式表时\",{\"1\":{\"437\":1}}],[\"建立整个企业一致性维度\",{\"1\":{\"226\":1}}],[\"建立一致性的维度\",{\"1\":{\"226\":1}}],[\"建立逻辑设备名与物理设备名的映射机制\",{\"1\":{\"213\":1}}],[\"建立逻辑设备名到物理设备名的映射关系\",{\"1\":{\"210\":1}}],[\"建立进程后的等待时间\",{\"1\":{\"166\":1}}],[\"建立pcb\",{\"1\":{\"164\":1}}],[\"建造者\",{\"1\":{\"13\":1,\"16\":1}}],[\"建造者模式则是要求按照指定的蓝图建造产品\",{\"1\":{\"20\":1}}],[\"建造者模式除了上面的用途外\",{\"1\":{\"17\":1}}],[\"建造者模式很容易进行扩展\",{\"1\":{\"15\":1}}],[\"建造者模式的封装性很好\",{\"1\":{\"15\":1}}],[\"建造者模式可以将部件和其组装过程分开\",{\"1\":{\"12\":1}}],[\"建造者模式\",{\"0\":{\"11\":1}}],[\"橡胶车座\",{\"1\":{\"14\":1}}],[\"碳纤维车架\",{\"1\":{\"14\":1}}],[\"铝合金车架\",{\"1\":{\"14\":1}}],[\"铝合金等材质的\",{\"1\":{\"14\":1}}],[\"blpop和brpop\",{\"1\":{\"1209\":1}}],[\"bloom\",{\"1\":{\"437\":5,\"658\":3}}],[\"block\",{\"1\":{\"965\":1,\"976\":2}}],[\"blockreport\",{\"1\":{\"903\":1}}],[\"block负载平衡器\",{\"0\":{\"873\":1}}],[\"block的副本数据\",{\"1\":{\"870\":1}}],[\"blockingqueue<voucherorder>\",{\"1\":{\"1157\":1}}],[\"blockingqueue<runnable>\",{\"1\":{\"572\":1}}],[\"blockingoperationexception\",{\"1\":{\"765\":3}}],[\"blocking的区别\",{\"1\":{\"679\":1}}],[\"blocking和non\",{\"1\":{\"679\":1}}],[\"blocking\",{\"1\":{\"609\":1,\"610\":1,\"679\":7}}],[\"block块采样允许随机获取n行数据\",{\"1\":{\"368\":1}}],[\"blocked\",{\"1\":{\"160\":1,\"538\":1,\"541\":1}}],[\"blount\",{\"1\":{\"265\":1}}],[\"blob\",{\"1\":{\"133\":2,\"146\":1}}],[\"blogs\",{\"1\":{\"1168\":3}}],[\"blogserviceimpl\",{\"1\":{\"1160\":1,\"1162\":1,\"1168\":1}}],[\"blogservice\",{\"1\":{\"1159\":2,\"1161\":1,\"1162\":2,\"1165\":1,\"1168\":1}}],[\"blogid\",{\"1\":{\"1168\":1}}],[\"blog不存在\",{\"1\":{\"1160\":1,\"1161\":1}}],[\"blogcontroller\",{\"1\":{\"1159\":2,\"1162\":1,\"1165\":1,\"1168\":1}}],[\"blog\",{\"1\":{\"22\":1,\"132\":1,\"145\":4,\"543\":1,\"544\":1,\"545\":1,\"549\":1,\"1100\":1,\"1159\":9,\"1160\":10,\"1161\":15,\"1162\":7,\"1167\":6,\"1168\":4}}],[\"bck\",{\"1\":{\"1196\":1}}],[\"btree\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"bbean\",{\"1\":{\"974\":2}}],[\"bbbbb|\",{\"1\":{\"699\":1}}],[\"bbb\",{\"1\":{\"617\":1,\"698\":1,\"710\":1}}],[\"bzip2\",{\"1\":{\"876\":1}}],[\"b就是dfsclient\",{\"1\":{\"872\":1}}],[\"b就能读取文件里面的内容了即使它没有相应的权限\",{\"1\":{\"872\":1}}],[\"bd\",{\"1\":{\"805\":4}}],[\"br\",{\"1\":{\"990\":2}}],[\"broker消息不丢失\",{\"1\":{\"1054\":1}}],[\"broker\",{\"1\":{\"1012\":1,\"1016\":1,\"1026\":2,\"1056\":1}}],[\"brokenbarrierexception\",{\"1\":{\"593\":4}}],[\"broadcast\",{\"1\":{\"740\":1}}],[\"break\",{\"1\":{\"88\":1,\"536\":1,\"579\":4,\"649\":1,\"702\":6,\"742\":6,\"743\":2,\"744\":1,\"754\":1,\"794\":1,\"796\":1,\"839\":1,\"991\":1}}],[\"b+树的关键字都出现在叶子节点中\",{\"1\":{\"488\":1}}],[\"b+树的效率也比b树高\",{\"1\":{\"488\":1}}],[\"b+树的查询效率更加稳定\",{\"1\":{\"488\":1}}],[\"b+树的内部节点并没有指向关键字具体信息的指针\",{\"1\":{\"488\":1}}],[\"b+树的磁盘读写代价更低\",{\"1\":{\"488\":1}}],[\"b+树的存储能力如何\",{\"0\":{\"487\":1}}],[\"b+tree中的一个节点\",{\"1\":{\"487\":1}}],[\"b无法排序\",{\"1\":{\"481\":1}}],[\"b=\",{\"1\":{\"481\":3}}],[\"bos\",{\"1\":{\"713\":3,\"714\":3}}],[\"bosseventloop\",{\"1\":{\"846\":2}}],[\"boss\",{\"1\":{\"692\":3,\"702\":3,\"711\":3,\"733\":3,\"740\":4,\"743\":1,\"748\":4,\"846\":8}}],[\"book\",{\"1\":{\"1525\":1}}],[\"books\",{\"1\":{\"1525\":2}}],[\"boolquery\",{\"1\":{\"1080\":1}}],[\"boolquerybuilder\",{\"1\":{\"1080\":1}}],[\"booleanutil\",{\"1\":{\"1127\":1,\"1129\":1,\"1161\":1}}],[\"booleanwritable\",{\"1\":{\"956\":1}}],[\"boolean直接返回true\",{\"1\":{\"598\":1}}],[\"boolean\",{\"1\":{\"59\":2,\"69\":2,\"81\":6,\"248\":2,\"340\":1,\"554\":2,\"555\":6,\"579\":1,\"585\":6,\"614\":1,\"619\":1,\"671\":1,\"701\":1,\"702\":1,\"703\":1,\"740\":4,\"741\":4,\"742\":1,\"743\":2,\"744\":2,\"746\":1,\"772\":2,\"775\":1,\"846\":2,\"956\":1,\"962\":1,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"1072\":1,\"1089\":1,\"1100\":1,\"1111\":2,\"1127\":3,\"1128\":1,\"1129\":4,\"1134\":1,\"1135\":1,\"1136\":2,\"1137\":3,\"1142\":5,\"1144\":3,\"1150\":2,\"1157\":2,\"1161\":6,\"1162\":2,\"1164\":2,\"1165\":3,\"1167\":1,\"1466\":1,\"1505\":1}}],[\"boot全局异常处理器\",{\"0\":{\"1526\":1}}],[\"boot通过\",{\"1\":{\"1524\":1}}],[\"boot启动时便会自动加载相关依赖\",{\"1\":{\"1524\":1}}],[\"boot时\",{\"1\":{\"1524\":1}}],[\"boot自动装配过程\",{\"0\":{\"1524\":1}}],[\"boot项目之后会默认在主类加上\",{\"1\":{\"1525\":1}}],[\"boot项目是如何导入包的\",{\"0\":{\"1523\":1}}],[\"boot项目的基石\",{\"1\":{\"1525\":1}}],[\"boot项目的\",{\"1\":{\"1522\":1}}],[\"boot项目创建完成会默认生成一个名为\",{\"1\":{\"1522\":1}}],[\"boot的自动装配机制\",{\"1\":{\"1525\":1}}],[\"boot的自动配置功能\",{\"1\":{\"1524\":1}}],[\"boot的注解的了解\",{\"0\":{\"1525\":1}}],[\"boot的启动流程\",{\"0\":{\"1522\":1}}],[\"boot的web起步依赖就好了\",{\"1\":{\"1521\":1}}],[\"boot的理解\",{\"0\":{\"1520\":1}}],[\"boot提供众多起步依赖\",{\"1\":{\"1521\":1}}],[\"boot有如下优点\",{\"1\":{\"1520\":1}}],[\"boot本身并不提供spring的核心功能\",{\"1\":{\"1520\":1}}],[\"boot你可以不用或者只需要很少的spring配置\",{\"1\":{\"1520\":1}}],[\"boot很容易创建一个能独立运行\",{\"1\":{\"1520\":1}}],[\"boot使用\",{\"1\":{\"1520\":1}}],[\"boot就是spring\",{\"1\":{\"1520\":1}}],[\"boot中\",{\"1\":{\"1515\":1}}],[\"boot\",{\"0\":{\"1439\":1,\"1440\":1,\"1441\":1,\"1444\":1,\"1452\":1,\"1521\":1},\"1\":{\"1022\":2,\"1070\":2,\"1087\":4,\"1172\":1,\"1219\":4,\"1221\":1,\"1236\":2,\"1245\":3,\"1290\":1,\"1411\":2,\"1417\":1,\"1428\":1,\"1437\":1,\"1438\":1,\"1440\":1,\"1442\":1,\"1445\":5,\"1449\":1,\"1453\":2,\"1454\":2,\"1455\":1,\"1456\":2,\"1462\":2,\"1523\":2,\"1525\":1}}],[\"boot<\",{\"1\":{\"1022\":2,\"1070\":2,\"1087\":4,\"1172\":1,\"1219\":5}}],[\"bootstrap\",{\"1\":{\"692\":7,\"696\":7,\"697\":7,\"698\":7,\"699\":7,\"702\":7,\"710\":7,\"725\":4,\"733\":7,\"735\":7,\"737\":7,\"740\":6,\"743\":2,\"748\":1,\"753\":4,\"754\":1,\"766\":1,\"785\":1,\"794\":1,\"1012\":1,\"1015\":2,\"1017\":1,\"1021\":2,\"1023\":2,\"1024\":1,\"1050\":1}}],[\"bound\",{\"1\":{\"692\":2,\"693\":1,\"697\":1,\"699\":1}}],[\"bonus\",{\"1\":{\"404\":1}}],[\"bodylength\",{\"1\":{\"723\":1}}],[\"body\",{\"1\":{\"374\":1,\"695\":2,\"723\":3,\"1424\":1}}],[\"b都会被完全读取\",{\"1\":{\"326\":1}}],[\"bj\",{\"1\":{\"280\":1}}],[\"b属于不同的页面\",{\"1\":{\"190\":1}}],[\"b分别使用资源1\",{\"1\":{\"176\":1}}],[\"b站工程师algernon博客\",{\"1\":{\"145\":1}}],[\"b站工程师algernon鉴黄yolo\",{\"1\":{\"145\":1}}],[\"bh​−bh​^​\",{\"1\":{\"140\":1}}],[\"bw​−bw​^​\",{\"1\":{\"140\":1}}],[\"byradius\",{\"1\":{\"1172\":1}}],[\"bylonlat\",{\"1\":{\"1172\":1}}],[\"by用于指定底层按照哪个字段作为key实现分区\",{\"1\":{\"465\":1}}],[\"by导致的数据倾斜的问题\",{\"1\":{\"463\":1}}],[\"by或者count\",{\"1\":{\"463\":1}}],[\"by或limit放在最后一个之后\",{\"1\":{\"315\":1}}],[\"by或limit子句应用于整个union结果\",{\"1\":{\"315\":1}}],[\"by或limit应用于单个select\",{\"1\":{\"315\":1}}],[\"by等放在一起调用等等\",{\"1\":{\"378\":1}}],[\"by+rand也可以实现同样的效果\",{\"1\":{\"367\":1}}],[\"by普通常规聚合操作\",{\"1\":{\"357\":1}}],[\"by子句组合的常规聚合会隐藏正在聚合的各个行\",{\"1\":{\"356\":1}}],[\"by子句的聚合操作\",{\"1\":{\"351\":2}}],[\"by中的字段倒序排序\",{\"1\":{\"353\":1}}],[\"by中select\",{\"1\":{\"306\":1}}],[\"by结果集进行union\",{\"1\":{\"352\":1}}],[\"by逻辑写在一个sql语句中的便利写法\",{\"1\":{\"352\":1}}],[\"by语法限制\",{\"1\":{\"351\":1}}],[\"by语句用于结合聚合函数\",{\"1\":{\"306\":1}}],[\"by既有分组\",{\"1\":{\"314\":1}}],[\"by是在分组之后\",{\"1\":{\"314\":1}}],[\"by根据指定字段将数据分组\",{\"1\":{\"314\":1}}],[\"by全局排序\",{\"1\":{\"314\":1}}],[\"by对比\",{\"0\":{\"314\":1}}],[\"by就相当于把cluster\",{\"1\":{\"313\":1}}],[\"by的情况下\",{\"1\":{\"491\":1}}],[\"by的场景\",{\"1\":{\"481\":1}}],[\"by的维度的所有组合进行聚合\",{\"1\":{\"352\":1}}],[\"by的功能一分为二\",{\"1\":{\"313\":1}}],[\"by的弊端就是只能通过一个字段进行分组且排序\",{\"1\":{\"313\":1}}],[\"by的时候聚合函数已经作用得出结果\",{\"1\":{\"307\":1}}],[\"by差不多\",{\"1\":{\"312\":1}}],[\"by分组\",{\"1\":{\"307\":1}}],[\"by分组的字段\",{\"1\":{\"306\":1}}],[\"by\",{\"0\":{\"306\":1,\"312\":1,\"313\":1,\"463\":1},\"1\":{\"252\":4,\"256\":3,\"260\":2,\"261\":2,\"262\":2,\"264\":4,\"265\":2,\"266\":1,\"268\":1,\"276\":4,\"280\":1,\"281\":2,\"285\":2,\"287\":1,\"289\":1,\"290\":6,\"300\":5,\"307\":3,\"310\":2,\"313\":6,\"315\":10,\"340\":1,\"348\":3,\"349\":3,\"351\":4,\"352\":1,\"353\":9,\"354\":5,\"355\":4,\"357\":3,\"358\":6,\"359\":2,\"360\":8,\"361\":6,\"363\":8,\"364\":5,\"365\":20,\"367\":3,\"378\":1,\"382\":2,\"385\":2,\"388\":1,\"391\":1,\"400\":7,\"402\":3,\"404\":3,\"407\":1,\"408\":1,\"409\":1,\"437\":4,\"444\":2,\"450\":3,\"452\":4,\"465\":1,\"466\":1,\"481\":3,\"493\":4,\"762\":1,\"1089\":1,\"1162\":2,\"1168\":1,\"1172\":1,\"1526\":1}}],[\"by​−by​^​\",{\"1\":{\"140\":1}}],[\"bytewritable\",{\"1\":{\"956\":1}}],[\"bytetohexstringpadded\",{\"1\":{\"799\":1}}],[\"bytetomessagecodec\",{\"1\":{\"714\":1}}],[\"bytetomessagecodec<message>\",{\"1\":{\"713\":1}}],[\"bytepadding\",{\"1\":{\"799\":5}}],[\"byte2hex\",{\"1\":{\"799\":5}}],[\"byte2char\",{\"1\":{\"799\":6}}],[\"bytebyf\",{\"1\":{\"723\":1}}],[\"bytebufutil\",{\"1\":{\"776\":6,\"779\":3,\"780\":2}}],[\"bytebufallocator\",{\"1\":{\"713\":1,\"744\":1,\"748\":2,\"768\":1,\"769\":2,\"776\":2,\"779\":4,\"780\":2}}],[\"bytebuf\",{\"0\":{\"767\":1,\"781\":1},\"1\":{\"692\":1,\"693\":1,\"694\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"710\":4,\"713\":5,\"714\":3,\"723\":3,\"730\":1,\"744\":10,\"748\":14,\"766\":3,\"768\":4,\"769\":4,\"770\":3,\"771\":1,\"772\":3,\"775\":19,\"776\":15,\"777\":2,\"778\":1,\"779\":12,\"780\":7,\"781\":1,\"784\":1,\"785\":1,\"787\":2,\"792\":1,\"794\":6}}],[\"bytebuffer>\",{\"1\":{\"857\":1,\"859\":2}}],[\"bytebufferutil\",{\"1\":{\"799\":1}}],[\"bytebuffer\",{\"0\":{\"796\":1,\"797\":1,\"798\":1,\"800\":1,\"805\":1,\"841\":1},\"1\":{\"610\":1,\"772\":2,\"781\":1,\"792\":1,\"796\":2,\"798\":1,\"799\":4,\"801\":5,\"805\":2,\"807\":7,\"808\":5,\"809\":6,\"814\":1,\"815\":1,\"826\":3,\"827\":3,\"836\":2,\"840\":11,\"841\":5,\"843\":5,\"846\":2,\"848\":3,\"855\":2,\"857\":4,\"859\":7,\"861\":1}}],[\"bytearrayinputstream\",{\"1\":{\"713\":1,\"714\":1,\"723\":2}}],[\"bytearrayoutputstream\",{\"1\":{\"713\":2,\"714\":2,\"723\":4}}],[\"bytesremaining\",{\"1\":{\"976\":1}}],[\"bytes\",{\"1\":{\"694\":8,\"697\":3,\"711\":3,\"713\":6,\"714\":6,\"723\":12,\"799\":2}}],[\"byte\",{\"1\":{\"70\":2,\"88\":6,\"598\":1,\"658\":1,\"692\":1,\"693\":1,\"696\":1,\"697\":3,\"698\":1,\"699\":3,\"710\":1,\"711\":1,\"713\":7,\"714\":7,\"723\":18,\"748\":2,\"772\":4,\"776\":2,\"779\":2,\"780\":4,\"799\":3,\"802\":1,\"803\":1,\"808\":2,\"839\":2,\"848\":1,\"854\":4,\"956\":1,\"1035\":2}}],[\"bx​−bx​^​\",{\"1\":{\"140\":1}}],[\"bv1wy4y1k7tc\",{\"1\":{\"131\":1}}],[\"bv1wv4y1t71f\",{\"1\":{\"117\":1}}],[\"bv1r44y1377t\",{\"1\":{\"125\":1}}],[\"bv1ya411a78p\",{\"1\":{\"117\":1}}],[\"banner\",{\"1\":{\"1444\":1,\"1446\":1}}],[\"bandwidth\",{\"1\":{\"869\":1}}],[\"baomidou<\",{\"1\":{\"1236\":2}}],[\"baocai\",{\"1\":{\"85\":5}}],[\"balancer功能\",{\"1\":{\"874\":1}}],[\"balancer是hadoop\",{\"1\":{\"874\":1}}],[\"balancer\",{\"0\":{\"873\":1,\"874\":1},\"1\":{\"873\":2,\"874\":1,\"878\":1,\"879\":1}}],[\"baldwin\",{\"1\":{\"265\":1}}],[\"backup`\",{\"1\":{\"1174\":1}}],[\"backup\",{\"1\":{\"1043\":1}}],[\"backlog\",{\"0\":{\"726\":1},\"1\":{\"726\":5}}],[\"back\",{\"1\":{\"669\":3}}],[\"backbone\",{\"0\":{\"136\":1}}],[\"bar\",{\"1\":{\"593\":6,\"1309\":9}}],[\"barbour\",{\"1\":{\"265\":1}}],[\"basics\",{\"0\":{\"1549\":1}}],[\"basicdatasource\",{\"1\":{\"1454\":1}}],[\"basicerrorcontroller\",{\"0\":{\"1415\":1},\"1\":{\"1411\":3,\"1416\":4,\"1417\":1,\"1460\":1}}],[\"basicfileattributes\",{\"1\":{\"822\":4}}],[\"basic\",{\"1\":{\"456\":1,\"457\":1}}],[\"based\",{\"1\":{\"949\":1}}],[\"basedetection\",{\"1\":{\"146\":1}}],[\"base\",{\"0\":{\"1557\":1},\"1\":{\"73\":3,\"338\":2,\"564\":1,\"1243\":1,\"1292\":1,\"1296\":1,\"1313\":2,\"1317\":1}}],[\"baby\",{\"1\":{\"336\":1}}],[\"bulk\",{\"1\":{\"1073\":1}}],[\"bulkresponse\",{\"1\":{\"1073\":1}}],[\"bulkrequest\",{\"1\":{\"1073\":2}}],[\"bug\",{\"1\":{\"742\":3,\"792\":1,\"833\":1}}],[\"buf4\",{\"1\":{\"780\":3}}],[\"buf3\",{\"1\":{\"779\":6,\"780\":2}}],[\"buf2\",{\"1\":{\"779\":6,\"780\":3,\"801\":1}}],[\"buf1\",{\"1\":{\"779\":7,\"780\":3}}],[\"buf\",{\"1\":{\"663\":4,\"710\":30,\"713\":5,\"748\":7,\"766\":2,\"768\":3,\"775\":2,\"776\":8,\"799\":21,\"801\":1,\"802\":2,\"803\":2,\"854\":5}}],[\"buffer3\",{\"1\":{\"805\":3}}],[\"buffer2\",{\"1\":{\"805\":2}}],[\"buffer1\",{\"1\":{\"805\":3}}],[\"bufferedwriter\",{\"1\":{\"795\":4}}],[\"bufferedreader是带缓冲区的字符流\",{\"1\":{\"989\":1}}],[\"bufferedreader\",{\"1\":{\"795\":4,\"990\":2}}],[\"buffer常用子类\",{\"1\":{\"610\":1}}],[\"buffer的子类中通过一个对应类型的数组用来存放数据\",{\"1\":{\"610\":1}}],[\"buffer就是一个内存块\",{\"1\":{\"610\":1}}],[\"buffer\",{\"0\":{\"802\":1,\"803\":1,\"806\":1,\"861\":1},\"1\":{\"506\":4,\"610\":2,\"612\":1,\"692\":4,\"693\":4,\"696\":4,\"697\":4,\"698\":5,\"699\":5,\"710\":2,\"713\":1,\"714\":1,\"723\":1,\"748\":2,\"766\":3,\"768\":9,\"769\":2,\"772\":4,\"773\":2,\"774\":10,\"776\":2,\"779\":3,\"780\":3,\"794\":8,\"796\":9,\"797\":4,\"799\":19,\"801\":1,\"802\":1,\"803\":1,\"806\":1,\"807\":1,\"808\":1,\"814\":1,\"815\":6,\"826\":5,\"827\":5,\"833\":1,\"836\":4,\"840\":12,\"841\":5,\"843\":13,\"846\":4,\"848\":8,\"857\":4,\"859\":4,\"861\":4,\"979\":1,\"1115\":1}}],[\"buffer中的空间\",{\"1\":{\"499\":1}}],[\"busy\",{\"1\":{\"615\":6,\"741\":1}}],[\"business\",{\"1\":{\"76\":1}}],[\"buck\",{\"1\":{\"369\":1}}],[\"bucketmapjoin\",{\"1\":{\"450\":3}}],[\"bucketing\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"bucketing=true\",{\"1\":{\"266\":1}}],[\"bucket\",{\"0\":{\"450\":1},\"1\":{\"265\":1,\"266\":2,\"293\":1,\"369\":6,\"450\":1}}],[\"bucketed\",{\"0\":{\"263\":1},\"1\":{\"267\":1}}],[\"buckets表示分为几桶\",{\"1\":{\"264\":1}}],[\"buckets\",{\"0\":{\"237\":1},\"1\":{\"264\":2,\"265\":1,\"268\":1,\"276\":1}}],[\"bucket分桶表在hdfs中表现为同一个表目录下数据根据hash散列之后变成多个文件\",{\"1\":{\"237\":1}}],[\"bucket分桶表是hive的一种优化手段表\",{\"1\":{\"237\":1}}],[\"bucket分桶\",{\"1\":{\"233\":1}}],[\"built\",{\"1\":{\"334\":1}}],[\"build>\",{\"1\":{\"102\":3,\"112\":1,\"344\":1,\"957\":1,\"1022\":1,\"1219\":1}}],[\"build标签中指定\",{\"1\":{\"102\":1}}],[\"build\",{\"1\":{\"17\":2,\"99\":2,\"112\":2,\"113\":2,\"114\":2,\"115\":2,\"1113\":1,\"1525\":1}}],[\"buildseat\",{\"1\":{\"14\":6}}],[\"buildframe\",{\"1\":{\"14\":6}}],[\"builder模式的常规用法\",{\"1\":{\"14\":1}}],[\"builder是抽象建造者\",{\"1\":{\"14\":1}}],[\"builder\",{\"1\":{\"13\":3,\"14\":13,\"16\":1,\"17\":13,\"799\":3,\"1071\":1,\"1077\":4,\"1078\":3,\"1079\":3,\"1080\":2,\"1081\":3,\"1082\":3,\"1083\":4,\"1084\":3,\"1085\":3,\"1088\":3}}],[\"bubbliiiing\",{\"1\":{\"146\":1}}],[\"behind\",{\"1\":{\"1120\":1}}],[\"benchmark\",{\"1\":{\"1019\":2,\"1020\":1,\"1021\":1}}],[\"bengio大神\",{\"1\":{\"126\":1}}],[\"bengio\",{\"1\":{\"124\":1}}],[\"beforeeach\",{\"1\":{\"1213\":1,\"1216\":1}}],[\"before\",{\"0\":{\"1337\":1},\"1\":{\"826\":1,\"1304\":2,\"1306\":1,\"1309\":1,\"1317\":1,\"1339\":1,\"1343\":1}}],[\"beginning\",{\"1\":{\"1017\":1}}],[\"beginread\",{\"1\":{\"740\":1,\"743\":1}}],[\"begin\",{\"1\":{\"593\":4,\"857\":2,\"1132\":4}}],[\"beginindex\",{\"1\":{\"566\":6}}],[\"beeline\",{\"1\":{\"244\":1}}],[\"belady异常\",{\"1\":{\"191\":1}}],[\"between\",{\"1\":{\"361\":3,\"442\":1}}],[\"bet\",{\"1\":{\"81\":3}}],[\"be\",{\"1\":{\"70\":1,\"271\":1,\"369\":1}}],[\"bean实修方法注册额外的bean或导入其他配置类\",{\"1\":{\"1525\":1}}],[\"bean来实现\",{\"1\":{\"1507\":1}}],[\"bean注解来注册bean\",{\"1\":{\"1507\":1}}],[\"bean注解比\",{\"1\":{\"1507\":1}}],[\"bean注解作用于方法\",{\"1\":{\"1507\":1}}],[\"bean是线程安全的\",{\"1\":{\"1506\":1}}],[\"beanclass\",{\"1\":{\"1505\":1}}],[\"bean的区别是什么\",{\"0\":{\"1507\":1}}],[\"bean的生命周期\",{\"0\":{\"1505\":1}}],[\"bean的作用域\",{\"0\":{\"1504\":1}}],[\"bean在spring容器中是单例的\",{\"1\":{\"1504\":1}}],[\"bean2\",{\"1\":{\"1464\":3}}],[\"bean1\",{\"1\":{\"1464\":3,\"1466\":4}}],[\"beanname\",{\"1\":{\"1505\":12}}],[\"beannameurlhandlermapping\",{\"0\":{\"1418\":1},\"1\":{\"1420\":3,\"1421\":1,\"1437\":1}}],[\"beannameviewresolver\",{\"1\":{\"1411\":1,\"1416\":1}}],[\"beannameaware\",{\"1\":{\"1284\":1}}],[\"beanwrapperimpl\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"beandefinition\",{\"1\":{\"1280\":1,\"1444\":1}}],[\"beanpostprocessor\",{\"1\":{\"1252\":1,\"1257\":3,\"1285\":1}}],[\"beanfactory本身并不会自动解析像\",{\"1\":{\"1502\":1}}],[\"beanfactory是spring容器的顶层接口\",{\"1\":{\"1502\":1}}],[\"beanfactory是类的通用工厂\",{\"1\":{\"1502\":1}}],[\"beanfactory是一个类工厂\",{\"1\":{\"1502\":1}}],[\"beanfactory是比较合适的ioc容器选择\",{\"1\":{\"1501\":1}}],[\"beanfactory和applicationcontext\",{\"1\":{\"1501\":1}}],[\"beanfactorytransactionattributesourceadvisor\",{\"1\":{\"1456\":1}}],[\"beanfactorypostprocessor\",{\"1\":{\"1285\":4}}],[\"beanfactoryaware中setbeanfactory\",{\"1\":{\"1505\":1}}],[\"beanfactoryaware\",{\"1\":{\"1284\":1}}],[\"beanfactory\",{\"0\":{\"1241\":1,\"1268\":1,\"1269\":1},\"1\":{\"1240\":4,\"1243\":5,\"1245\":1,\"1248\":7,\"1257\":4,\"1267\":1,\"1271\":2,\"1284\":1,\"1285\":2,\"1472\":1,\"1482\":2,\"1489\":1,\"1501\":1}}],[\"beantomap\",{\"1\":{\"1107\":1,\"1122\":1}}],[\"beanutil\",{\"1\":{\"1107\":2,\"1111\":1,\"1122\":1,\"1162\":1,\"1165\":2}}],[\"beanutils\",{\"1\":{\"1101\":1}}],[\"beansexception\",{\"1\":{\"1505\":6}}],[\"beans\",{\"1\":{\"110\":2,\"112\":1,\"113\":1}}],[\"beans<\",{\"1\":{\"107\":2}}],[\"bean\",{\"0\":{\"1239\":1,\"1252\":1,\"1253\":1,\"1258\":1,\"1261\":1,\"1265\":1,\"1275\":1},\"1\":{\"42\":1,\"1023\":1,\"1024\":1,\"1150\":1,\"1222\":1,\"1232\":1,\"1243\":2,\"1244\":1,\"1248\":10,\"1252\":6,\"1254\":3,\"1255\":2,\"1257\":9,\"1264\":2,\"1267\":1,\"1270\":1,\"1271\":2,\"1274\":1,\"1280\":1,\"1284\":1,\"1285\":1,\"1289\":4,\"1290\":4,\"1293\":1,\"1297\":1,\"1370\":3,\"1384\":1,\"1413\":2,\"1416\":4,\"1420\":3,\"1421\":2,\"1424\":3,\"1429\":4,\"1432\":1,\"1435\":2,\"1437\":1,\"1438\":1,\"1444\":1,\"1446\":2,\"1453\":2,\"1454\":2,\"1455\":2,\"1456\":1,\"1459\":1,\"1460\":1,\"1461\":1,\"1464\":2,\"1466\":2,\"1472\":1,\"1476\":1,\"1482\":1,\"1489\":9,\"1493\":1,\"1502\":1,\"1505\":7}}],[\"bitpos\",{\"1\":{\"1174\":1}}],[\"bitop\",{\"1\":{\"1174\":1}}],[\"bitfieldtype\",{\"1\":{\"1176\":1}}],[\"bitfieldsubcommands\",{\"1\":{\"1176\":2}}],[\"bitfield\",{\"1\":{\"1174\":2,\"1176\":3}}],[\"bitcount\",{\"1\":{\"1174\":1}}],[\"bitmap的哪个索引上\",{\"1\":{\"1177\":1}}],[\"bitmap\",{\"0\":{\"1174\":1,\"1177\":1},\"1\":{\"1174\":7,\"1175\":3,\"1176\":1,\"1177\":4}}],[\"bits\",{\"1\":{\"999\":12,\"1132\":2}}],[\"bit\",{\"1\":{\"658\":1,\"920\":1,\"1174\":6,\"1176\":1}}],[\"bio基于字节流和字符流进行操作\",{\"1\":{\"612\":1}}],[\"bio基本介绍\",{\"1\":{\"609\":1}}],[\"bio是阻塞的\",{\"1\":{\"612\":1}}],[\"bio是以流的形式处理数据\",{\"1\":{\"612\":1}}],[\"bio对比\",{\"1\":{\"612\":1}}],[\"bio方式适用于连接数较小且固定的架构\",{\"1\":{\"612\":1}}],[\"bio问题分析\",{\"1\":{\"609\":1}}],[\"bio模型\",{\"1\":{\"609\":1,\"610\":1}}],[\"bio就是传统的java\",{\"1\":{\"609\":1}}],[\"bio\",{\"0\":{\"608\":1,\"609\":1,\"849\":1},\"1\":{\"609\":1,\"612\":1,\"839\":1}}],[\"bipush\",{\"1\":{\"567\":1}}],[\"bigdata\",{\"0\":{\"1538\":1,\"1539\":1},\"1\":{\"991\":4}}],[\"big\",{\"1\":{\"772\":2}}],[\"bigger\",{\"1\":{\"369\":1}}],[\"bigint\",{\"1\":{\"248\":2,\"338\":2,\"341\":1,\"480\":2,\"1164\":3,\"1174\":2}}],[\"bibb\",{\"1\":{\"265\":1}}],[\"bi工具\",{\"1\":{\"228\":1}}],[\"bilibili\",{\"1\":{\"117\":2,\"120\":1,\"125\":1,\"127\":1,\"131\":1}}],[\"bin目录下\",{\"1\":{\"1193\":1}}],[\"bincount\",{\"1\":{\"579\":6}}],[\"bins\",{\"1\":{\"579\":1}}],[\"bin的头节点\",{\"1\":{\"579\":1}}],[\"binaryoperator\",{\"1\":{\"620\":2}}],[\"binary\",{\"1\":{\"336\":1,\"343\":3,\"672\":1}}],[\"binding\",{\"1\":{\"692\":2,\"693\":1,\"697\":1,\"699\":1}}],[\"bind\",{\"1\":{\"104\":1,\"692\":1,\"701\":1,\"702\":1,\"703\":1,\"711\":1,\"733\":1,\"740\":7,\"748\":2,\"766\":1,\"784\":1,\"794\":1,\"826\":1,\"827\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":1,\"846\":1,\"848\":1,\"859\":1,\"1196\":1}}],[\"bind中\",{\"1\":{\"104\":1}}],[\"bin\",{\"1\":{\"69\":1,\"244\":2,\"338\":3,\"579\":1,\"876\":2,\"1012\":3,\"1013\":1,\"1015\":2,\"1016\":1,\"1017\":1,\"1020\":1,\"1021\":2,\"1045\":1,\"1046\":11,\"1050\":1,\"1197\":1}}],[\"bike\",{\"1\":{\"14\":15}}],[\"b\",{\"1\":{\"54\":2,\"70\":2,\"73\":13,\"88\":10,\"104\":6,\"161\":1,\"176\":1,\"190\":1,\"279\":5,\"317\":1,\"325\":7,\"326\":29,\"330\":1,\"332\":5,\"336\":1,\"340\":5,\"348\":3,\"349\":4,\"352\":8,\"368\":2,\"378\":3,\"396\":1,\"409\":4,\"460\":9,\"481\":3,\"496\":5,\"551\":3,\"617\":6,\"619\":2,\"663\":2,\"692\":1,\"693\":2,\"697\":12,\"698\":11,\"699\":11,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":9,\"779\":4,\"780\":2,\"795\":2,\"796\":1,\"799\":1,\"803\":1,\"805\":2,\"807\":7,\"808\":2,\"821\":4,\"836\":2,\"848\":1,\"857\":1,\"926\":1,\"974\":2,\"985\":2,\"986\":2,\"1089\":1,\"1210\":3}}],[\"车座等组件\",{\"1\":{\"14\":1}}],[\"车座等组件的生产\",{\"1\":{\"14\":1}}],[\"车座有橡胶\",{\"1\":{\"14\":1}}],[\"生命周期阶段\",{\"1\":{\"1264\":1}}],[\"生命周期各个阶段\",{\"1\":{\"1255\":1}}],[\"生命周期\",{\"0\":{\"1253\":1}}],[\"生命周期中还有一类\",{\"1\":{\"1252\":1}}],[\"生命周期主要阶段有\",{\"1\":{\"1252\":1}}],[\"生命周期已经结束\",{\"1\":{\"538\":1}}],[\"生成处理器对象以及处理器拦截器\",{\"1\":{\"1530\":1}}],[\"生成代理\",{\"1\":{\"1294\":1}}],[\"生成\",{\"1\":{\"1274\":1,\"1476\":1}}],[\"生成新文件名\",{\"1\":{\"1159\":1}}],[\"生成序列号\",{\"1\":{\"1132\":1}}],[\"生成时间戳\",{\"1\":{\"1132\":1}}],[\"生成验证码\",{\"1\":{\"1099\":1}}],[\"生成50个id\",{\"1\":{\"999\":1}}],[\"生成的代理类实现相同接口\",{\"1\":{\"1305\":1}}],[\"生成的是一个无序的字符串\",{\"1\":{\"997\":1}}],[\"生成的查询计划存储在\",{\"1\":{\"232\":1}}],[\"生成edek\",{\"1\":{\"933\":1}}],[\"生成就快\",{\"1\":{\"719\":1}}],[\"生成http请求信息\",{\"1\":{\"652\":1}}],[\"生成器采用u\",{\"1\":{\"130\":1}}],[\"生成对抗网络之父\",{\"1\":{\"124\":1}}],[\"生成对抗网络gan开山之作\",{\"0\":{\"124\":1}}],[\"生成对抗神经网络gan开山之作论文\",{\"1\":{\"124\":1}}],[\"生成站点\",{\"1\":{\"95\":1}}],[\"生成jar或war文件\",{\"1\":{\"95\":1}}],[\"生成target文件\",{\"1\":{\"95\":1}}],[\"生成随机数的类\",{\"1\":{\"47\":1}}],[\"生成不同操作系统的程序\",{\"1\":{\"41\":1}}],[\"生产环境不要设置为0\",{\"1\":{\"1196\":1}}],[\"生产成功\",{\"1\":{\"1025\":1}}],[\"生产消息基准测试\",{\"0\":{\"1021\":1}}],[\"生产消息到\",{\"0\":{\"1016\":1}}],[\"生产一些消息到kafka的test主题中\",{\"1\":{\"1016\":1}}],[\"生产一个产品族的产品\",{\"1\":{\"20\":1}}],[\"生产数据并发布\",{\"1\":{\"717\":1,\"718\":1}}],[\"生产者消息不丢失\",{\"1\":{\"1054\":1}}],[\"生产者消费者模式\",{\"0\":{\"548\":1},\"1\":{\"547\":1}}],[\"生产者会等到leader分区写入成功后\",{\"1\":{\"1043\":1}}],[\"生产者只管写入\",{\"1\":{\"1043\":1}}],[\"生产者的分区写入策略\",{\"0\":{\"1031\":1}}],[\"生产者发送数据的对象\",{\"1\":{\"1026\":1}}],[\"生产者使用异步方式生产消息\",{\"0\":{\"1025\":1}}],[\"生产者程序开发\",{\"0\":{\"1023\":1}}],[\"生产者和消费者是解耦的\",{\"1\":{\"1010\":1}}],[\"生产者负责将消息生产到mq中\",{\"1\":{\"1010\":1}}],[\"生产者\",{\"1\":{\"1010\":1,\"1013\":1,\"1021\":1,\"1026\":1}}],[\"生产者仅负责产生结果数据\",{\"1\":{\"548\":1}}],[\"生产\",{\"0\":{\"44\":1},\"1\":{\"1026\":1}}],[\"生产自行车是一个复杂的过程\",{\"1\":{\"14\":1}}],[\"生活中这样的例子很多\",{\"1\":{\"4\":1}}],[\"在接口的addinterceptors方法中\",{\"1\":{\"1532\":1}}],[\"在接口方法数量比较多的时候\",{\"1\":{\"61\":1}}],[\"在项目中它通常作为独立的一层\",{\"1\":{\"1529\":1}}],[\"在加入到这个事务中\",{\"1\":{\"1514\":1}}],[\"在加载目标类时\",{\"1\":{\"1298\":1}}],[\"在加载外部类的过程中\",{\"1\":{\"66\":1}}],[\"在xml配置文件中配置或者直接基于注解\",{\"1\":{\"1513\":1}}],[\"在xml中也是可以直接用\",{\"1\":{\"1229\":1}}],[\"在性能方面\",{\"1\":{\"1512\":1}}],[\"在那些系统资源充足\",{\"1\":{\"1501\":1}}],[\"在很多时候我们简单地将ioc和di划等号\",{\"1\":{\"1500\":1}}],[\"在很多地方还必须保护这种互斥性\",{\"1\":{\"176\":1}}],[\"在要导入的自动配置类上添加\",{\"1\":{\"1466\":1}}],[\"在外置\",{\"1\":{\"1442\":1}}],[\"在整个\",{\"1\":{\"1381\":1,\"1389\":1,\"1401\":1}}],[\"在转换时\",{\"1\":{\"1370\":1}}],[\"在初始化时会从\",{\"1\":{\"1355\":1}}],[\"在合适的时机创建代理\",{\"1\":{\"1333\":1}}],[\"在当前版本的\",{\"1\":{\"1290\":1}}],[\"在容器中没有指定bean的时候才会加载\",{\"1\":{\"1525\":1}}],[\"在容器中有指定bean的时候才会加载\",{\"1\":{\"1525\":1}}],[\"在容器关闭时\",{\"1\":{\"1252\":1}}],[\"在容量允许的情况下\",{\"1\":{\"649\":1}}],[\"在类中定义一个threadlocal成员变量\",{\"1\":{\"1506\":1}}],[\"在类名上指定使用数据源\",{\"1\":{\"1236\":1}}],[\"在类初始化之后执行\",{\"1\":{\"1157\":1}}],[\"在业务层实现类方法的类名或方法名上通过\",{\"1\":{\"1236\":1}}],[\"在配置文件中进行配置\",{\"1\":{\"1236\":1}}],[\"在基础篇的最后\",{\"1\":{\"1224\":1}}],[\"在基本分页存储管理方式中\",{\"1\":{\"683\":1}}],[\"在application\",{\"1\":{\"1221\":1}}],[\"在官网\",{\"1\":{\"1204\":1}}],[\"在左侧菜单会出现这个链接\",{\"1\":{\"1202\":1}}],[\"在弹出的窗口中填写redis服务信息\",{\"1\":{\"1202\":1}}],[\"在安装目录下找到rdm\",{\"1\":{\"1201\":1}}],[\"在课前资料中可以找到redis的图形化桌面客户端\",{\"1\":{\"1201\":1}}],[\"在下面这个仓库可以找到安装包\",{\"1\":{\"1200\":1}}],[\"在下面的案例中\",{\"1\":{\"287\":1}}],[\"在任意目录输入redis\",{\"1\":{\"1195\":1}}],[\"在任意时刻\",{\"1\":{\"795\":1}}],[\"在个人主页的\",{\"1\":{\"1168\":1}}],[\"在保存blog到数据库的同时\",{\"1\":{\"1167\":1}}],[\"在保存小字符串时\",{\"1\":{\"663\":1}}],[\"在博主个人页面展示出当前用户与博主的共同关注呢\",{\"1\":{\"1165\":1}}],[\"在探店笔记的详情页面\",{\"1\":{\"1162\":1}}],[\"在bean中尽量避免定义可变的成员变量\",{\"1\":{\"1506\":1}}],[\"在blog\",{\"1\":{\"1161\":1}}],[\"在b中使用a中的方法\",{\"1\":{\"73\":1}}],[\"在实际开发中图片一般会放在\",{\"1\":{\"1159\":1}}],[\"在实现\",{\"1\":{\"1366\":1}}],[\"在实现数据的参考完整性方面\",{\"1\":{\"485\":1}}],[\"在实现上\",{\"1\":{\"170\":1}}],[\"在脚本中可以从keys和argv数组获取这些参数\",{\"1\":{\"1146\":1}}],[\"在删除锁时\",{\"1\":{\"1144\":1}}],[\"在存储value时\",{\"1\":{\"1223\":1}}],[\"在存储方式\",{\"1\":{\"1189\":1}}],[\"在存储器分配时\",{\"1\":{\"683\":1}}],[\"在存入锁时\",{\"1\":{\"1144\":1}}],[\"在释放锁时先获取锁中的线程标示\",{\"1\":{\"1144\":1}}],[\"在获取锁时存入线程标示\",{\"1\":{\"1144\":1}}],[\"在方法上添加了一把synchronized\",{\"1\":{\"1137\":1}}],[\"在扣减库存时\",{\"1\":{\"1136\":1}}],[\"在测试类中\",{\"1\":{\"1128\":1}}],[\"在测试类中通过代理对象调用sell\",{\"1\":{\"59\":1}}],[\"在两个线程并发来访问时\",{\"1\":{\"1121\":1}}],[\"在我们完成了使用工厂设计模式来完成代码的编写之后\",{\"1\":{\"1216\":1}}],[\"在我们修改完此处代码后\",{\"1\":{\"1144\":1}}],[\"在我们原有代码中是这么写的\",{\"1\":{\"1135\":1}}],[\"在我们查询商户信息时\",{\"1\":{\"1116\":1}}],[\"在我们的服务部署到tomcat后\",{\"1\":{\"1100\":1}}],[\"在数据库中查询出来这个数据后\",{\"1\":{\"1123\":1}}],[\"在数据库中有一片空间是\",{\"1\":{\"1115\":1}}],[\"在数据通信中\",{\"1\":{\"899\":1}}],[\"在酷似\",{\"1\":{\"1113\":1}}],[\"在设计这个key的时候\",{\"1\":{\"1105\":1}}],[\"在userholder处\",{\"1\":{\"1101\":1}}],[\"在unix系统中\",{\"1\":{\"211\":1}}],[\"在拦截器处\",{\"1\":{\"1101\":1}}],[\"在登录方法处修改\",{\"1\":{\"1101\":1}}],[\"在用户执行完请求后\",{\"1\":{\"1100\":1}}],[\"在用户看来是有多个线程\",{\"1\":{\"163\":1}}],[\"在资料中提供了一个项目源码\",{\"1\":{\"1095\":1}}],[\"在优化和处理简单业务的加持下\",{\"1\":{\"1094\":1}}],[\"在优化阶段即可读取到数据\",{\"1\":{\"481\":1}}],[\"在索引创建之后\",{\"1\":{\"1067\":1}}],[\"在索引比较时需要转为ascii\",{\"1\":{\"494\":1}}],[\"在企业中\",{\"1\":{\"1055\":1}}],[\"在企业中处理数据的时候\",{\"1\":{\"344\":1}}],[\"在启动kafka的脚本前\",{\"1\":{\"1045\":1}}],[\"在kafka中生产者是有写入策略\",{\"1\":{\"1035\":1}}],[\"在k级队列的进程运行过程中\",{\"1\":{\"167\":1}}],[\"在较早的版本\",{\"1\":{\"1033\":1}}],[\"在物理上被划分为一个或多个\",{\"1\":{\"1026\":1}}],[\"在消费者中会有一个offset\",{\"1\":{\"1024\":1}}],[\"在往数据库中插入数据的时候\",{\"1\":{\"1005\":1}}],[\"在2014年开源\",{\"1\":{\"998\":1}}],[\"在2020学年第一学期中表现优秀\",{\"1\":{\"52\":1,\"54\":1}}],[\"在分布式锁中\",{\"1\":{\"1151\":1}}],[\"在分布式服务中往往都会有一个生成全局id的服务来保证id的唯一性\",{\"1\":{\"1005\":1}}],[\"在分片\",{\"1\":{\"1067\":1}}],[\"在分组中进行订单和商品信息的关联合并\",{\"1\":{\"988\":1}}],[\"在分段存储管理方式中\",{\"1\":{\"683\":1}}],[\"在wordcount程序中对apple单词的数量利用计数器进行统计\",{\"1\":{\"983\":1}}],[\"在where中使用不到的字段\",{\"1\":{\"494\":1}}],[\"在客户端提交job之前\",{\"1\":{\"976\":1}}],[\"在执行业务逻辑过程中\",{\"1\":{\"1145\":1}}],[\"在执行map的时候\",{\"1\":{\"959\":1}}],[\"在执行插入语句时就在表级别加一个auto\",{\"1\":{\"510\":1}}],[\"在应用程序运行过程中\",{\"1\":{\"953\":1}}],[\"在某个分片\",{\"1\":{\"1067\":1}}],[\"在某些重要数据上进行测试或者实验\",{\"1\":{\"912\":1}}],[\"在某一时刻给整个事务系统\",{\"1\":{\"503\":1}}],[\"在某一时间段内只能实现单向传输\",{\"1\":{\"162\":1}}],[\"在fsdataoutputstream输出流上调用close\",{\"1\":{\"901\":1}}],[\"在升级的finalize执行后\",{\"1\":{\"892\":1}}],[\"在同一群集中运行两个\",{\"1\":{\"883\":1}}],[\"在指定范围内搜索member\",{\"1\":{\"1170\":1}}],[\"在指定路径的目录上设置擦除编码策略\",{\"1\":{\"875\":1}}],[\"在指导者中不涉及具体产品的信息\",{\"1\":{\"13\":1}}],[\"在namenode机器的hdfs\",{\"1\":{\"879\":1}}],[\"在namenode\",{\"1\":{\"870\":1}}],[\"在namenode启动过程中\",{\"1\":{\"870\":1}}],[\"在此期间\",{\"1\":{\"870\":1}}],[\"在此状态下namenode不允许对文件系统进行任何更改\",{\"1\":{\"870\":1}}],[\"在此metastore实例上运行多少个压缩程序工作线程\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"在原来的逻辑中\",{\"1\":{\"1124\":1}}],[\"在原来聊天项目的基础上新增\",{\"1\":{\"733\":1}}],[\"在原有关注事件的基础上\",{\"1\":{\"843\":1}}],[\"在处理时因为没有真正的\",{\"1\":{\"837\":1}}],[\"在事件未处理时\",{\"1\":{\"840\":1}}],[\"在事件发生后\",{\"1\":{\"837\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"506\":1}}],[\"在切片过程中\",{\"1\":{\"776\":1}}],[\"在异步处理时\",{\"1\":{\"756\":1}}],[\"在连接建立后被调用\",{\"1\":{\"754\":1}}],[\"在连接建立后触发\",{\"1\":{\"702\":1}}],[\"在示例1的基础上\",{\"1\":{\"718\":1}}],[\"在没有显式策略集的目录上取消策略将不会返回错误\",{\"1\":{\"875\":1}}],[\"在没有数据可读时\",{\"1\":{\"827\":1}}],[\"在没有连接建立时\",{\"1\":{\"827\":1}}],[\"在没有标点符号情况下\",{\"1\":{\"709\":1}}],[\"在没有加任何锁的情况下\",{\"1\":{\"66\":1}}],[\"在网络上传输\",{\"1\":{\"709\":1}}],[\"在线性推送模式下\",{\"1\":{\"898\":1}}],[\"在线\",{\"1\":{\"703\":1}}],[\"在线程执行时\",{\"1\":{\"552\":1}}],[\"在线程使用锁对象时\",{\"1\":{\"551\":1}}],[\"在线程t1中如何优雅地终止另一个线程t2\",{\"1\":{\"536\":1}}],[\"在线程装入内存时\",{\"1\":{\"182\":1}}],[\"在发生\",{\"1\":{\"1042\":1}}],[\"在发送消息成功时\",{\"1\":{\"1025\":1}}],[\"在发送消息出现异常时\",{\"1\":{\"1025\":1}}],[\"在发送消息前\",{\"1\":{\"699\":1}}],[\"在发现许多进程运行时经常发生缺页\",{\"1\":{\"181\":1}}],[\"在载入程序的时候\",{\"1\":{\"689\":1}}],[\"在说操作系统虚拟内存之前有必要说一下局部性原理\",{\"1\":{\"686\":1}}],[\"在引入快表的分页存储管理方式中\",{\"1\":{\"683\":1}}],[\"在引入虚拟存储技术以后\",{\"1\":{\"164\":1}}],[\"在为进程分配内存时\",{\"1\":{\"683\":1}}],[\"在选择select\",{\"1\":{\"680\":1}}],[\"在32位的机器上大小就是32\",{\"1\":{\"680\":1}}],[\"在io\",{\"1\":{\"679\":1}}],[\"在innodb中如果采用count\",{\"1\":{\"497\":1}}],[\"在inputstream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节\",{\"1\":{\"88\":1}}],[\"在inputstream类中定义了多个\",{\"1\":{\"88\":1}}],[\"在invoke方法中基本不用\",{\"1\":{\"59\":1}}],[\"在linux上一般为1024\",{\"1\":{\"680\":1}}],[\"在linux下\",{\"1\":{\"679\":1}}],[\"在linux中\",{\"1\":{\"679\":1,\"872\":1}}],[\"在linux的缓存i\",{\"1\":{\"678\":1}}],[\"在后来的版本中\",{\"1\":{\"667\":1}}],[\"在后操作之前对相应的同步变量执行p操作\",{\"1\":{\"172\":1}}],[\"在后操作之前执行p\",{\"1\":{\"172\":1}}],[\"在压缩列表中\",{\"1\":{\"665\":1}}],[\"在扩展\",{\"1\":{\"663\":1}}],[\"在位数组中把对应下标的值置为\",{\"1\":{\"659\":1}}],[\"在默认情况下\",{\"1\":{\"635\":1,\"976\":1}}],[\"在上面的工作都完成之后\",{\"1\":{\"630\":1}}],[\"在排序方面比较常用\",{\"1\":{\"614\":1}}],[\"在缓冲区被创建的时候就被指定\",{\"1\":{\"610\":1}}],[\"在各个通道上切换\",{\"1\":{\"610\":1}}],[\"在第一个拦截器中拦截所有的路径\",{\"1\":{\"1110\":1}}],[\"在第一次add时会默认赋值长度为10\",{\"1\":{\"601\":1}}],[\"在第24行添加java\",{\"1\":{\"1046\":1}}],[\"在第二步中\",{\"1\":{\"477\":1}}],[\"在第二步中找出了每个文件出现频率最高的100个词之后\",{\"1\":{\"477\":1}}],[\"在第二个mr作业中\",{\"1\":{\"326\":1}}],[\"在访问高峰期\",{\"1\":{\"591\":1}}],[\"在访问一个表的时候会被自动加上\",{\"1\":{\"510\":1}}],[\"在tomcat支撑起并发流量后\",{\"1\":{\"1094\":1}}],[\"在tryacquire方法中\",{\"1\":{\"588\":1}}],[\"在thread\",{\"1\":{\"541\":1}}],[\"在互斥模式下唤醒的是下一个线程\",{\"1\":{\"583\":1}}],[\"在构造方法中仅仅计算了table的大小\",{\"1\":{\"579\":1}}],[\"在构造过程完成后\",{\"1\":{\"13\":1}}],[\"在完成写之前\",{\"1\":{\"578\":1}}],[\"在collect中\",{\"1\":{\"979\":1}}],[\"在cpu给出有效地址后\",{\"1\":{\"683\":1}}],[\"在cpu中设置一对上\",{\"1\":{\"180\":1}}],[\"在cpu中运行不止一个程序\",{\"1\":{\"159\":1}}],[\"在cells创建或扩容时\",{\"1\":{\"564\":1}}],[\"在reduce中根据业务需求把数据进行关联整合汇总\",{\"1\":{\"988\":1}}],[\"在reduce阶段执行join关联操作\",{\"1\":{\"988\":1}}],[\"在reduce端利用自定义分组规则\",{\"1\":{\"974\":1}}],[\"在redis官网中提供了各种语言的客户端\",{\"1\":{\"1212\":1}}],[\"在redis\",{\"1\":{\"526\":1,\"527\":1}}],[\"在rpc协议中\",{\"1\":{\"949\":1}}],[\"在rom中存放了很小的\",{\"1\":{\"206\":1}}],[\"在键空间中移出最不经常使用的key\",{\"1\":{\"522\":1}}],[\"在键空间中\",{\"1\":{\"522\":1}}],[\"在4\",{\"1\":{\"522\":1}}],[\"在取出key的时候对数据进行过期检查\",{\"1\":{\"520\":1}}],[\"在该类型容器启动之后\",{\"1\":{\"1501\":1}}],[\"在该类首次处理异常时\",{\"1\":{\"1410\":1}}],[\"在该类首次使用时\",{\"1\":{\"1382\":1,\"1390\":1}}],[\"在该案例中key必须为goodsbean\",{\"1\":{\"986\":1}}],[\"在该模式中\",{\"1\":{\"916\":1}}],[\"在该方式中\",{\"1\":{\"683\":1}}],[\"在该方法中第18行\",{\"1\":{\"88\":1}}],[\"在该语句执行结束后\",{\"1\":{\"510\":1}}],[\"在表中设计一个版本号字段version\",{\"1\":{\"507\":1}}],[\"在表查询中\",{\"1\":{\"483\":1,\"498\":1}}],[\"在order\",{\"1\":{\"491\":1}}],[\"在observer模式中\",{\"1\":{\"45\":1}}],[\"在范围查询上\",{\"1\":{\"488\":1}}],[\"在功能上与不带\",{\"1\":{\"482\":1}}],[\"在代码中写分页查询逻辑时\",{\"1\":{\"482\":1}}],[\"在建索引时\",{\"1\":{\"481\":1}}],[\"在建造者模式中\",{\"1\":{\"15\":1}}],[\"在建造者模式中具有很重要的作用\",{\"1\":{\"14\":1}}],[\"在varchar字段上建立索引时\",{\"1\":{\"481\":1}}],[\"在main方法中\",{\"1\":{\"1522\":1}}],[\"在mapper初始化的时候从分布式缓存中读取小数据集数据\",{\"1\":{\"990\":1}}],[\"在mapper类或者reducer类的setup方法中\",{\"1\":{\"989\":1}}],[\"在map阶段自定义一个counter\",{\"1\":{\"983\":1}}],[\"在map阶段将\",{\"1\":{\"974\":1}}],[\"在map阶段和reduce阶段之间mapreduce程序默认对数据进行了相关的处理\",{\"1\":{\"961\":1}}],[\"在map阶段之前\",{\"1\":{\"959\":1}}],[\"在mapreduce程序中可以通过context获取到当前处理的切片所属的文件名称\",{\"1\":{\"988\":1}}],[\"在mapred\",{\"1\":{\"445\":1,\"963\":1}}],[\"在mybatis\",{\"1\":{\"483\":1}}],[\"在mirrors节点\",{\"1\":{\"92\":1}}],[\"在生产环境下\",{\"1\":{\"1205\":1}}],[\"在生产环境中\",{\"1\":{\"244\":1,\"1021\":1}}],[\"在生产者生产消息时\",{\"1\":{\"1027\":1}}],[\"在生成数据的时候\",{\"1\":{\"437\":1}}],[\"在可以预见到分区数据非常庞大的情况下\",{\"1\":{\"420\":1}}],[\"在传递大量数据时\",{\"1\":{\"694\":1}}],[\"在传统的关系型数据库例如mysql\",{\"1\":{\"420\":1}}],[\"在传送一个或多个数据块的开始和结束时\",{\"1\":{\"209\":1}}],[\"在聚合\",{\"1\":{\"351\":1}}],[\"在进程运行过程中\",{\"1\":{\"690\":1}}],[\"在进程运行期间\",{\"1\":{\"192\":1}}],[\"在进程运行期间不再改变\",{\"1\":{\"192\":1}}],[\"在进行读写操作时\",{\"1\":{\"856\":2}}],[\"在进行i\",{\"1\":{\"611\":1}}],[\"在进行sum\",{\"1\":{\"351\":1}}],[\"在查询过程中执行顺序\",{\"1\":{\"310\":1}}],[\"在写事务和分桶的组合中唯一\",{\"1\":{\"293\":1}}],[\"在创建表的时候通过stored\",{\"1\":{\"426\":1}}],[\"在创建表的时候通过external关键字指定\",{\"1\":{\"258\":1}}],[\"在创建表时\",{\"1\":{\"397\":1}}],[\"在创建物化视图的时候就把数据缓存起来了\",{\"1\":{\"275\":1}}],[\"在hadoop集群所有节点上编译安装isa\",{\"1\":{\"876\":1}}],[\"在hadoop集群所有节点上安装yasm和nasm\",{\"1\":{\"876\":1}}],[\"在having中可以使用聚合函数\",{\"1\":{\"504\":1}}],[\"在hdfs的场景里面\",{\"1\":{\"872\":1}}],[\"在hdfs中的表现形式为\",{\"1\":{\"285\":1}}],[\"在hdfs中\",{\"1\":{\"266\":1,\"918\":2}}],[\"在hive建表的时候\",{\"1\":{\"255\":1}}],[\"在hive\",{\"1\":{\"234\":1}}],[\"在这六步操作中\",{\"1\":{\"1155\":1}}],[\"在这里笔者想给大家分享一下课程内没有的思路\",{\"1\":{\"1155\":1}}],[\"在这里提到了非常多的问题\",{\"1\":{\"1137\":1}}],[\"在这里就用st来说明\",{\"1\":{\"923\":1}}],[\"在这种模式下软件被分为三层\",{\"1\":{\"1528\":1}}],[\"在这种场景下\",{\"1\":{\"453\":1}}],[\"在这种情况下\",{\"1\":{\"244\":1,\"1138\":1}}],[\"在这个方案中\",{\"1\":{\"1109\":1}}],[\"在这个执行过程中\",{\"1\":{\"160\":1}}],[\"在这个过程中包括编译源代码\",{\"1\":{\"94\":1,\"102\":1}}],[\"在结构上积极向传统数据库看齐\",{\"1\":{\"234\":1}}],[\"在输出进程的控制下\",{\"1\":{\"212\":1}}],[\"在输入进程的控制下\",{\"1\":{\"212\":1}}],[\"在中断驱动方式中\",{\"1\":{\"209\":1}}],[\"在读已提交中\",{\"1\":{\"503\":1}}],[\"在读\",{\"1\":{\"204\":1,\"209\":1}}],[\"在操作系统看来\",{\"1\":{\"195\":1}}],[\"在操作系统内核看来\",{\"1\":{\"163\":1}}],[\"在其他条件都相同时\",{\"1\":{\"191\":1}}],[\"在请求分页系统中\",{\"1\":{\"190\":1}}],[\"在作业运行时无需一直常驻内存\",{\"1\":{\"189\":1}}],[\"在不久之后\",{\"1\":{\"189\":1,\"687\":1}}],[\"在preparedstatement中设置对象的字段\",{\"1\":{\"985\":1}}],[\"在profiles节点\",{\"1\":{\"92\":1}}],[\"在pojo类中增加映射\",{\"1\":{\"483\":1}}],[\"在pcb中存放段表始址和段表长度\",{\"1\":{\"187\":1}}],[\"在程序初始化的方法中\",{\"1\":{\"990\":1}}],[\"在程序中体现为主程序段\",{\"1\":{\"683\":1}}],[\"在程序中尽量多使用commit\",{\"1\":{\"499\":1}}],[\"在程序设计中\",{\"1\":{\"677\":1}}],[\"在程序上\",{\"1\":{\"507\":1}}],[\"在程序执行过程中\",{\"1\":{\"189\":1,\"190\":1}}],[\"在程序执行中需要改目标模块时\",{\"1\":{\"179\":1}}],[\"在程序装入时\",{\"1\":{\"189\":1}}],[\"在程序运行之前\",{\"1\":{\"179\":1}}],[\"在程序运行期间\",{\"1\":{\"179\":1}}],[\"在程序运行前只需要装入它的部分代码就可以运行\",{\"1\":{\"179\":1}}],[\"在程序需要进行拓展的时候\",{\"1\":{\"72\":1}}],[\"在运行期间不能再移动\",{\"1\":{\"179\":1}}],[\"在并发环境下\",{\"1\":{\"175\":1}}],[\"在前操作之后对相应的同步变量执行v操作\",{\"1\":{\"172\":1}}],[\"在前操作之后执行v\",{\"1\":{\"172\":1}}],[\"在临界区之后执行v\",{\"1\":{\"172\":1}}],[\"在临界区之前执行p\",{\"1\":{\"172\":1}}],[\"在一些关键点前后提供扩展\",{\"1\":{\"1255\":1}}],[\"在一段时间内\",{\"1\":{\"551\":1}}],[\"在一次事务中\",{\"1\":{\"503\":1}}],[\"在一次扫描中\",{\"1\":{\"288\":1}}],[\"在一个脚本中编写多条redis命令\",{\"1\":{\"1146\":1}}],[\"在一个网络\",{\"1\":{\"1067\":1}}],[\"在一个index\",{\"1\":{\"1063\":1}}],[\"在一个索引中\",{\"1\":{\"1062\":1}}],[\"在一个集群中\",{\"1\":{\"1061\":1}}],[\"在一个域中有域控\",{\"1\":{\"923\":1}}],[\"在一个时间段内\",{\"1\":{\"189\":1}}],[\"在一个进程访问完临界资源以后会把使用临界区的权限转交给另一个进程\",{\"1\":{\"169\":1}}],[\"在一定程度上降低了系统的耦合度\",{\"1\":{\"62\":1}}],[\"在一定程度上增加了系统的复杂度\",{\"1\":{\"23\":1}}],[\"在每个分组中\",{\"1\":{\"363\":3}}],[\"在每个分组内\",{\"1\":{\"360\":1}}],[\"在每个分区中只装入一道作业\",{\"1\":{\"182\":1}}],[\"在每次调度时先计算各个作业\",{\"1\":{\"167\":1}}],[\"在每一个\",{\"1\":{\"107\":1}}],[\"在等待io完成期间进程也是在被服务的\",{\"1\":{\"166\":1}}],[\"在允许过程中即便有更紧迫的任务到达\",{\"1\":{\"165\":1}}],[\"在内存中进行\",{\"1\":{\"1000\":1}}],[\"在内存中找到后将该页表项存入快表的一个寄存器单元中\",{\"1\":{\"683\":1}}],[\"在内存中实际存放的位置\",{\"1\":{\"179\":1}}],[\"在内存中划出一块共享存储区\",{\"1\":{\"162\":1}}],[\"在内存中放入多个程序\",{\"1\":{\"159\":1}}],[\"在有了并发之后\",{\"1\":{\"159\":1}}],[\"在系统高并发的环境下\",{\"1\":{\"1003\":1}}],[\"在系统函数之上\",{\"1\":{\"158\":1}}],[\"在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类\",{\"1\":{\"35\":1}}],[\"在多个线程一起执行的时候\",{\"1\":{\"556\":1}}],[\"在多个字段需要创建索引的情况下\",{\"1\":{\"493\":1}}],[\"在多cpu的计算机中\",{\"1\":{\"163\":1}}],[\"在多道程序环境下\",{\"1\":{\"155\":1}}],[\"在多线程的情况下\",{\"1\":{\"66\":1}}],[\"在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能\",{\"1\":{\"154\":1}}],[\"在图中缩写为\",{\"1\":{\"1381\":3}}],[\"在图块尺度提取纹理等高频信息\",{\"1\":{\"130\":1}}],[\"在图像迁移之后仍保留原始输入图像信息\",{\"1\":{\"117\":1}}],[\"在防止模式崩溃的同时\",{\"1\":{\"117\":1}}],[\"在父工程中统一管理项目中的依赖信息\",{\"1\":{\"107\":1}}],[\"在exclude标签中配置一个具体的排除\",{\"1\":{\"105\":1}}],[\"在<depencies><\",{\"1\":{\"105\":1}}],[\"在\",{\"0\":{\"1322\":1},\"1\":{\"104\":1,\"332\":1,\"493\":1,\"662\":1,\"726\":3,\"740\":2,\"743\":1,\"753\":1,\"775\":1,\"791\":1,\"815\":1,\"827\":1,\"833\":1,\"856\":1,\"1150\":1,\"1151\":2,\"1170\":1,\"1171\":1,\"1293\":1,\"1411\":1,\"1438\":1,\"1449\":1,\"1482\":2,\"1493\":1,\"1515\":1,\"1516\":1}}],[\"在抽象类中已经实现\",{\"1\":{\"84\":1}}],[\"在面向对象程序设计过程中\",{\"1\":{\"83\":1}}],[\"在编程上还使用了专门的编译优化来节省内存空间\",{\"1\":{\"663\":1}}],[\"在编程中\",{\"1\":{\"73\":1}}],[\"在编译期就找到\",{\"1\":{\"1476\":1}}],[\"在编译和加载时\",{\"1\":{\"1298\":1}}],[\"在编译hadoop源码的时候可以通过编译native模块获取\",{\"1\":{\"872\":1}}],[\"在编译时就根据\",{\"1\":{\"1476\":1}}],[\"在编译时判断是否会产生数据倾斜\",{\"1\":{\"470\":1}}],[\"在编译时已经定义\",{\"1\":{\"77\":1}}],[\"在编译的时候就知道程序存放在内存的哪个位置\",{\"1\":{\"179\":1}}],[\"在编译生成的指令中一般使用的是逻辑地址\",{\"1\":{\"179\":1}}],[\"在编译\",{\"1\":{\"100\":1}}],[\"在适当的情况下\",{\"1\":{\"73\":1}}],[\"在子类中尽量不要重写父类的方\",{\"1\":{\"73\":1}}],[\"在使用锁过程中\",{\"1\":{\"1137\":1}}],[\"在使用乐观锁过程中假设100个线程同时都拿到了100的库存\",{\"1\":{\"1136\":1}}],[\"在使用dboutputformat时\",{\"1\":{\"986\":1}}],[\"在使用顺序加锁时\",{\"1\":{\"553\":1}}],[\"在使用分组和排序子句进行数据查询时\",{\"1\":{\"485\":1}}],[\"在使用orc文件时\",{\"1\":{\"437\":1}}],[\"在使用\",{\"1\":{\"101\":1,\"726\":1}}],[\"在使用继承时\",{\"1\":{\"73\":1}}],[\"在使用建造者模式的场景中\",{\"1\":{\"15\":1}}],[\"在软件开发中\",{\"1\":{\"71\":1}}],[\"在反序列化时被反射调用\",{\"1\":{\"69\":1}}],[\"在spring\",{\"1\":{\"1515\":1}}],[\"在spring内部\",{\"1\":{\"1510\":1}}],[\"在set集合中\",{\"1\":{\"1165\":1}}],[\"在seckillvoucher\",{\"1\":{\"1137\":1}}],[\"在select\",{\"1\":{\"680\":1}}],[\"在select中只查询源表数据没有问题\",{\"1\":{\"348\":1}}],[\"在select查询语句中使用dual表完成运算符\",{\"1\":{\"329\":1}}],[\"在shopserviceimpl\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"在stringredistemplate返回false\",{\"1\":{\"1127\":1}}],[\"在stringredistemplate中返回true\",{\"1\":{\"1127\":1}}],[\"在student\",{\"1\":{\"493\":1}}],[\"在slave中执行randomkey时\",{\"1\":{\"529\":1}}],[\"在sum\",{\"1\":{\"361\":1}}],[\"在sun的jdk实现中\",{\"1\":{\"9\":1}}],[\"在singleton类中添加\",{\"1\":{\"69\":1}}],[\"在singleton类中添加readresolve\",{\"1\":{\"69\":1}}],[\"在静态代码块中创建该类对象\",{\"1\":{\"66\":1}}],[\"在成员位置创建该类的对象\",{\"1\":{\"66\":4}}],[\"在调用次数较少的情况下\",{\"1\":{\"61\":1}}],[\"在job执行前\",{\"1\":{\"989\":1}}],[\"在join时\",{\"1\":{\"418\":1}}],[\"在join的时候\",{\"1\":{\"326\":1}}],[\"在jdk9zhong发布者publisher的实现类submissionpublisher的submit方法是block方法\",{\"1\":{\"719\":1}}],[\"在jdk\",{\"1\":{\"638\":1}}],[\"在jdk1\",{\"1\":{\"61\":2}}],[\"在java程序员的视角看来\",{\"1\":{\"630\":1}}],[\"在java中无法区分运行状态和可运行状态\",{\"1\":{\"538\":1}}],[\"在java中\",{\"1\":{\"25\":1}}],[\"在具体的工厂类中iterator\",{\"1\":{\"43\":1}}],[\"在工厂类中加载配置文件中的全类名\",{\"1\":{\"42\":1}}],[\"在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的\",{\"1\":{\"30\":1}}],[\"在开发中还有一个常用的使用方式\",{\"1\":{\"17\":1}}],[\"在本教程中会介绍三种工厂的使用\",{\"1\":{\"25\":1}}],[\"装配过程\",{\"0\":{\"1483\":1,\"1487\":1}}],[\"装配底层\",{\"0\":{\"1481\":1,\"1486\":1}}],[\"装配算法的解耦\",{\"1\":{\"12\":1}}],[\"装箱\",{\"1\":{\"599\":1}}],[\"装载load\",{\"1\":{\"228\":1}}],[\"装入时动态链接\",{\"1\":{\"179\":1}}],[\"装入时对地址进行重定位\",{\"1\":{\"179\":1}}],[\"装入程序将装入模块装入到内存之后也不会立即将逻辑地址变换为物理地址\",{\"1\":{\"179\":1}}],[\"装入程序按照装入模块中的地址\",{\"1\":{\"179\":1}}],[\"装入的三种方式\",{\"1\":{\"179\":1}}],[\"装饰器模式提供的都是跟原始类相同的接口\",{\"1\":{\"10\":1}}],[\"装饰器模式不改变原始类接口的情况下\",{\"1\":{\"10\":1}}],[\"装饰器\",{\"0\":{\"10\":1}}],[\"也包含了切点功能\",{\"1\":{\"1456\":1}}],[\"也被称之为前控制器\",{\"1\":{\"1438\":1}}],[\"也提供了多种销毁手段\",{\"1\":{\"1289\":1}}],[\"也都可以进行简单修改即可使用\",{\"1\":{\"1232\":1}}],[\"也都需要先通过遍历字符串才能得到目标字符串的末尾\",{\"1\":{\"662\":1}}],[\"也只会有一个\",{\"1\":{\"740\":1}}],[\"也作\",{\"1\":{\"709\":1}}],[\"也罢\",{\"1\":{\"709\":1}}],[\"也需要在dao层参数名称位置指定具体名称\",{\"1\":{\"1229\":1}}],[\"也需要从set集合中进行删除\",{\"1\":{\"1165\":1}}],[\"也需要加入\",{\"1\":{\"694\":1}}],[\"也需要定义\",{\"1\":{\"483\":1}}],[\"也无意义再从逻辑上扩大内存容量\",{\"1\":{\"689\":1}}],[\"也将内存空间分为若干个物理块或页框\",{\"1\":{\"683\":1}}],[\"也说明该单词不存在\",{\"1\":{\"668\":1}}],[\"也同时能保证代码块内变量的可见性\",{\"1\":{\"558\":1}}],[\"也会很大\",{\"1\":{\"1177\":1}}],[\"也会根据需要询问namenode来检索下一批数据块的datanode位置信息\",{\"1\":{\"902\":1}}],[\"也会受影响\",{\"1\":{\"776\":1}}],[\"也会增加\",{\"1\":{\"770\":1}}],[\"也会出现异常\",{\"1\":{\"762\":1}}],[\"也会引发对\",{\"1\":{\"666\":1}}],[\"也会提升查询效率\",{\"1\":{\"493\":1}}],[\"也会申请jvm\",{\"1\":{\"445\":1}}],[\"也返回为0\",{\"1\":{\"482\":1}}],[\"也必须存在\",{\"1\":{\"1244\":1}}],[\"也必须把b放在索引的最前列\",{\"1\":{\"481\":1}}],[\"也必须建成唯一索引\",{\"1\":{\"481\":1,\"493\":1}}],[\"也叫后端控制器\",{\"1\":{\"1530\":1}}],[\"也叫散列\",{\"1\":{\"1208\":1}}],[\"也叫页面访问量或点击量\",{\"1\":{\"1179\":1}}],[\"也叫独立访客量\",{\"1\":{\"1179\":1}}],[\"也叫min\",{\"1\":{\"437\":1}}],[\"也叫做读写混合\",{\"1\":{\"1166\":1}}],[\"也叫做读扩散\",{\"1\":{\"1166\":1}}],[\"也叫做写扩散\",{\"1\":{\"1166\":1}}],[\"也叫做开窗函数\",{\"1\":{\"356\":1}}],[\"也叫做取模mod\",{\"1\":{\"331\":1}}],[\"也没有对version的版本号+1\",{\"1\":{\"1135\":1}}],[\"也没有提高查询性能\",{\"1\":{\"270\":1}}],[\"也没其他的事情需要操心\",{\"1\":{\"1126\":1}}],[\"也没歧义\",{\"1\":{\"306\":1}}],[\"也分数据库\",{\"1\":{\"234\":1}}],[\"也称之为双写方案\",{\"1\":{\"1120\":1}}],[\"也称之为注册事件\",{\"1\":{\"831\":1}}],[\"也称之为源数据层\",{\"1\":{\"225\":1}}],[\"也称为exchange指令\",{\"1\":{\"170\":1}}],[\"也称为间接制约关系\",{\"1\":{\"168\":1}}],[\"也有利于未来的可拓展性和可维护性\",{\"1\":{\"1500\":1}}],[\"也有资料称为tgs\",{\"1\":{\"923\":1}}],[\"也有访问底层硬件设备的所有权限\",{\"1\":{\"676\":1}}],[\"也有一些跟修改相关的方法啊\",{\"1\":{\"566\":1}}],[\"也有人把数据集市叫做小型数据仓库\",{\"1\":{\"223\":1}}],[\"也有可能导致饥饿\",{\"1\":{\"176\":1}}],[\"也能增强\",{\"1\":{\"1298\":1}}],[\"也能够更有效地进行文件的管理和保护\",{\"1\":{\"196\":1}}],[\"也能保证\",{\"1\":{\"66\":1}}],[\"也可能是一个xml或json串\",{\"1\":{\"1530\":2}}],[\"也可在内存中同时装入更多的进程\",{\"1\":{\"688\":1}}],[\"也可通过良好的设计改善\",{\"1\":{\"680\":1}}],[\"也可被重新赋值\",{\"1\":{\"595\":1}}],[\"也可由程序员直接赋予\",{\"1\":{\"179\":1}}],[\"也可以在加入\",{\"1\":{\"1443\":1}}],[\"也可以在导出的时候指定分隔符换行符和文件格式\",{\"1\":{\"290\":1}}],[\"也可以根据自己的需求来删除或添加词条\",{\"1\":{\"1207\":1}}],[\"也可以增加负数\",{\"1\":{\"1206\":1}}],[\"也可以作为静态资源服务器\",{\"1\":{\"1094\":1}}],[\"也可以拥有某个订单的一个文档\",{\"1\":{\"1063\":1}}],[\"也可以说是下一毫秒\",{\"1\":{\"999\":1}}],[\"也可以创建数据集合保存\",{\"1\":{\"973\":1}}],[\"也可以将\",{\"1\":{\"861\":1}}],[\"也可以将别的进程持有的物理块置换到外存\",{\"1\":{\"192\":1}}],[\"也可以理解为硬件单元\",{\"1\":{\"854\":1}}],[\"也可以进行任务处理\",{\"1\":{\"787\":1}}],[\"也可以用来包装普通字节数组\",{\"1\":{\"780\":1}}],[\"也可以用于\",{\"1\":{\"729\":1}}],[\"也可以写入数据\",{\"1\":{\"772\":1}}],[\"也可以写入数据到缓冲区\",{\"1\":{\"610\":1}}],[\"也可以异步方式得到结果\",{\"1\":{\"756\":1}}],[\"也可以使用字母\",{\"1\":{\"920\":1}}],[\"也可以使用下面的代码来创建池化基于直接内存的\",{\"1\":{\"769\":1}}],[\"也可以使用\",{\"1\":{\"746\":1,\"997\":1,\"1440\":1,\"1442\":1}}],[\"也可以由\",{\"1\":{\"742\":1}}],[\"也可以称为软中断\",{\"1\":{\"676\":1}}],[\"也可以保存任意格式的二进制数据\",{\"1\":{\"663\":1}}],[\"也可以保存二进制数据\",{\"1\":{\"663\":1}}],[\"也可以不设置\",{\"1\":{\"601\":1}}],[\"也可以加在行上\",{\"1\":{\"508\":1}}],[\"也可以显著减少查询中分组和排序的时间\",{\"1\":{\"485\":1}}],[\"也可以从消息队列中获取消息\",{\"1\":{\"1008\":1}}],[\"也可以从已经存在的视图上创建新视图\",{\"1\":{\"270\":1}}],[\"也可以从网上下载新的皮肤\",{\"1\":{\"72\":1}}],[\"也可以配置在hive\",{\"1\":{\"268\":1}}],[\"也可以引入快表机构\",{\"1\":{\"188\":1}}],[\"也可以是文档型\",{\"1\":{\"1185\":1}}],[\"也可以是多个字段的组合\",{\"1\":{\"1005\":1}}],[\"也可以是更复杂的记录型变量\",{\"1\":{\"171\":1}}],[\"也可以是另一个进程\",{\"1\":{\"165\":1}}],[\"也可以让各进程按时间片轮流执行\",{\"1\":{\"165\":1}}],[\"也可以通过配置修改为\",{\"1\":{\"1355\":1}}],[\"也可以通过用户自定义storage\",{\"1\":{\"274\":1}}],[\"也可以通过\",{\"1\":{\"99\":1,\"1411\":1}}],[\"也可以做出不同的对象\",{\"1\":{\"12\":1}}],[\"也不妨碍前面线程读取客户端数据\",{\"1\":{\"795\":1}}],[\"也不见主人家为他交付束修金\",{\"1\":{\"709\":1}}],[\"也不能保证线程之间读取到同样的值然后互相覆盖对方值的情况\",{\"1\":{\"560\":1}}],[\"也不能再申请内存空间\",{\"1\":{\"179\":1}}],[\"也不会造成回收\",{\"1\":{\"775\":1}}],[\"也不会阻塞住\",{\"1\":{\"742\":1}}],[\"也不会出现缓冲区溢出的问题\",{\"1\":{\"663\":1}}],[\"也不会出现前面所说的缓冲区溢出的问题\",{\"1\":{\"663\":1}}],[\"也不会出现幻读\",{\"1\":{\"503\":1}}],[\"也不会放弃处理器\",{\"1\":{\"165\":1}}],[\"也不是太符合单一职责原则\",{\"1\":{\"14\":1}}],[\"也是自动配置功能的核心实现者\",{\"1\":{\"1525\":1}}],[\"也是不反射调用\",{\"1\":{\"1317\":1}}],[\"也是陈旧的说法\",{\"1\":{\"1290\":1}}],[\"也是重入一次就加一\",{\"1\":{\"1151\":1}}],[\"也是为了将消息均衡地写入到每个分区\",{\"1\":{\"1033\":1}}],[\"也是为了进行内存空间的扩充\",{\"1\":{\"189\":1}}],[\"也是使用最多的策略\",{\"1\":{\"1032\":1}}],[\"也是许多互联网公司在推荐使用的\",{\"1\":{\"997\":1}}],[\"也是最后一个\",{\"1\":{\"901\":1}}],[\"也是与原始\",{\"1\":{\"777\":1}}],[\"也是\",{\"1\":{\"772\":1,\"1514\":1}}],[\"也是利用异步的关键\",{\"1\":{\"755\":1}}],[\"也是能接受的\",{\"1\":{\"667\":1}}],[\"也是在更新提交的时候\",{\"1\":{\"507\":1}}],[\"也是用硬件实现\",{\"1\":{\"170\":1}}],[\"也是程序执行流的最小单位\",{\"1\":{\"163\":1}}],[\"也是对着类的加载而创建\",{\"1\":{\"66\":1}}],[\"也就无法删除别人的锁\",{\"1\":{\"1144\":1}}],[\"也就无法并发\",{\"1\":{\"155\":1}}],[\"也就导致高地址的大分区更可能被使用\",{\"1\":{\"183\":1}}],[\"也就不能发生进程切换\",{\"1\":{\"170\":1}}],[\"也就是产品可以被代理增强\",{\"1\":{\"1472\":1}}],[\"也就是字符串类型\",{\"1\":{\"1206\":1}}],[\"也就是运行redis\",{\"1\":{\"1196\":1}}],[\"也就是看门狗线程\",{\"1\":{\"1152\":1}}],[\"也就是我们没法保证拿锁比锁删锁是一个原子性的动作\",{\"1\":{\"1147\":1}}],[\"也就是删之前判断一下当前这把锁是否是属于自己的\",{\"1\":{\"1147\":1}}],[\"也就是一条数据\",{\"1\":{\"1063\":1}}],[\"也就是前一个reduce的输出结果\",{\"1\":{\"991\":1}}],[\"也就是所谓的join关联\",{\"1\":{\"990\":1}}],[\"也就是所说的差异拷贝\",{\"1\":{\"913\":1}}],[\"也就是mapper的输出就是程序最终的输出\",{\"1\":{\"990\":1}}],[\"也就是当前task处理的数据是哪一个文件的\",{\"1\":{\"988\":1}}],[\"也就是当缓冲区的数据已经达到阈值\",{\"1\":{\"979\":1}}],[\"也就是默认为128m\",{\"1\":{\"976\":1}}],[\"也就是程序最终输出数据类型\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"也就是必须先写cases后写deaths\",{\"1\":{\"972\":1}}],[\"也就是用key的哈希值对reducetask个数进行取模\",{\"1\":{\"968\":1}}],[\"也就是aaa的第一个a\",{\"1\":{\"923\":1}}],[\"也就是drwxr\",{\"1\":{\"919\":1}}],[\"也就是集群中会有多个namenode\",{\"1\":{\"889\":1}}],[\"也就是不管有没有事件\",{\"1\":{\"832\":1}}],[\"也就是总字节数会使用\",{\"1\":{\"694\":1}}],[\"也就是切换到了内核态\",{\"1\":{\"676\":2}}],[\"也就是列表尾的偏移量\",{\"1\":{\"665\":1}}],[\"也就是\",{\"1\":{\"661\":1}}],[\"也就是都不保证线程安全\",{\"1\":{\"600\":1}}],[\"也就是都属于美式风味\",{\"1\":{\"39\":1}}],[\"也就是都属于意大利风味\",{\"1\":{\"39\":1}}],[\"也就是只有网络请求模块和数据操作模块是单线程的\",{\"1\":{\"516\":1}}],[\"也就是只有一个进程访问临界资源后\",{\"1\":{\"169\":1}}],[\"也就是谓词下推\",{\"1\":{\"468\":1}}],[\"也就是处理1gb的数据\",{\"1\":{\"414\":1}}],[\"也就是解决hive数仓中数据如何更新这个问题\",{\"1\":{\"405\":1}}],[\"也就是满足当前累计消费总金额这个需求\",{\"1\":{\"401\":1}}],[\"也就是hive\",{\"1\":{\"281\":1}}],[\"也就是几个部分\",{\"1\":{\"264\":1}}],[\"也就是小数据变成大数据可以隐式转换\",{\"1\":{\"248\":1}}],[\"也就是地址需要用32个二进制位来表示\",{\"1\":{\"179\":1}}],[\"也就是有4\",{\"1\":{\"179\":1}}],[\"也就是同一品牌的产品\",{\"1\":{\"36\":1}}],[\"也就是同一类产品\",{\"1\":{\"36\":1}}],[\"也就是说将其中的处理器方法映射到url路径上\",{\"1\":{\"1531\":1}}],[\"也就是说不管外部方法是否开启事务\",{\"1\":{\"1514\":1}}],[\"也就是说当上边抢锁完毕后\",{\"1\":{\"1152\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"522\":1}}],[\"也就是说段页式管理机制中段与段之间以及段的内部都是离散的\",{\"1\":{\"683\":1}}],[\"也就是说这个读写过程是阻塞的\",{\"1\":{\"680\":1}}],[\"也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的\",{\"1\":{\"679\":1}}],[\"也就是说一个页\",{\"1\":{\"487\":1}}],[\"也就是说在分区的基础上继续分区\",{\"1\":{\"259\":1}}],[\"也就是说proxypoint作为访问对象和目标对象的中介\",{\"1\":{\"58\":1}}],[\"也就是说\",{\"1\":{\"36\":1,\"104\":1,\"678\":1}}],[\"也就是实现了构建算法\",{\"1\":{\"12\":1}}],[\"也带来了弊端\",{\"1\":{\"73\":1}}],[\"也更方便使用程序来控制创建过程\",{\"1\":{\"15\":1}}],[\"也相对独立地改变\",{\"1\":{\"10\":1}}],[\"由它在目标方法调用前后加入事务操作\",{\"1\":{\"1456\":1}}],[\"由解析\",{\"1\":{\"1333\":1}}],[\"由代理结合通知和目标\",{\"1\":{\"1298\":1}}],[\"由代理创建新的\",{\"1\":{\"1294\":1}}],[\"由代码可以看出\",{\"1\":{\"591\":1}}],[\"由系统本身完成\",{\"1\":{\"1120\":1}}],[\"由多个\",{\"1\":{\"1026\":1}}],[\"由多个部件构成\",{\"1\":{\"16\":1}}],[\"由recordreader对象\",{\"1\":{\"979\":1}}],[\"由文件\",{\"1\":{\"888\":1}}],[\"由dfs\",{\"1\":{\"880\":2}}],[\"由director负责\",{\"1\":{\"12\":1}}],[\"由四部分组成\",{\"1\":{\"771\":1}}],[\"由下一个\",{\"1\":{\"749\":1}}],[\"由\",{\"1\":{\"742\":2,\"748\":1,\"775\":1,\"792\":1,\"875\":1,\"1438\":1,\"1444\":1,\"1446\":1}}],[\"由非\",{\"1\":{\"742\":1,\"748\":1}}],[\"由注册线程去执行\",{\"1\":{\"740\":1}}],[\"由地址变换机构自动地将页号p送入高速缓冲寄存器\",{\"1\":{\"683\":1}}],[\"由字节码中是否跟随由invokespecial指令所决定\",{\"1\":{\"630\":1}}],[\"由executors类提供的工厂方法来创建线程池\",{\"1\":{\"574\":1}}],[\"由调用者线程自行处理该任务\",{\"1\":{\"573\":1}}],[\"由三部分组成\",{\"1\":{\"549\":1}}],[\"由metastore再去连接mysql数据库来存取元数据\",{\"1\":{\"240\":1}}],[\"由参数hive\",{\"1\":{\"234\":1}}],[\"由ods层数据加工而成\",{\"1\":{\"226\":1}}],[\"由一组相似的记录组成\",{\"1\":{\"195\":1}}],[\"由一组系统调用组成\",{\"1\":{\"154\":1}}],[\"由程序员指出应该先调入哪些部分\",{\"1\":{\"192\":1}}],[\"由操作系统决定\",{\"1\":{\"683\":1}}],[\"由操作系统负责将内存中暂时用不到的信息换出到外存\",{\"1\":{\"189\":1,\"190\":1}}],[\"由操作系统负责将所需信息从外存调入内存\",{\"1\":{\"189\":1,\"190\":1}}],[\"由操作系统内核程序根据用户程序大小检索该表\",{\"1\":{\"182\":1}}],[\"由操作系统代为完成\",{\"1\":{\"158\":1}}],[\"由运行态到阻塞态\",{\"1\":{\"171\":1}}],[\"由时钟装置发出时钟中断来通知cpu时间片已到\",{\"1\":{\"167\":1}}],[\"由几个用户级线程映射到几个内核级线程可引出多线程模型\",{\"1\":{\"163\":1}}],[\"由应用程序提供线程库实现\",{\"1\":{\"163\":1}}],[\"由子类实现\",{\"1\":{\"88\":1}}],[\"由其具体子类实现\",{\"1\":{\"84\":1}}],[\"由此也产生了一种新的实现模式\",{\"1\":{\"66\":1}}],[\"由于cglib采用动态创建子类的方式生成代理对象\",{\"1\":{\"1511\":1}}],[\"由于ioc这个词汇比较抽象而di却更直观\",{\"1\":{\"1500\":1}}],[\"由于id这一列构建了索引\",{\"1\":{\"455\":1}}],[\"由于name已经存在\",{\"1\":{\"1206\":1}}],[\"由于redis中只有k1\",{\"1\":{\"1205\":1}}],[\"由于他们上线不是很频繁\",{\"1\":{\"1166\":1}}],[\"由于是spring的事务是放在threadlocal中\",{\"1\":{\"1157\":1}}],[\"由于课程中已经说明了有关\",{\"1\":{\"1152\":1}}],[\"由于本套视频并不讲解zookeeper的原理和分布式锁的实现\",{\"1\":{\"1140\":1}}],[\"由于加锁本身就让性能降低\",{\"1\":{\"1140\":1}}],[\"由于现在我们部署了多个tomcat\",{\"1\":{\"1138\":1}}],[\"由于保证了互斥性\",{\"1\":{\"1126\":1}}],[\"由于线程线程2持有着锁\",{\"1\":{\"1126\":1}}],[\"由于我们的缓存的数据源来自于数据库\",{\"1\":{\"1120\":1}}],[\"由于其又被final修饰\",{\"1\":{\"1113\":1}}],[\"由于其被static修饰\",{\"1\":{\"1113\":1}}],[\"由于存入的数据比较简单\",{\"1\":{\"1104\":1}}],[\"由于进程的最后一页经常装不满一块\",{\"1\":{\"683\":1}}],[\"由于维护和兼容性测试的成本\",{\"1\":{\"638\":1}}],[\"由于在垃圾回收过程中\",{\"1\":{\"634\":1}}],[\"由于hash冲突效率就会降低\",{\"1\":{\"491\":1}}],[\"由于非叶节点并不是最终指向文件内容的节点\",{\"1\":{\"488\":1}}],[\"由于内存限制\",{\"1\":{\"477\":1}}],[\"由于内存无法容纳所有作业\",{\"1\":{\"189\":1}}],[\"由于联接中仅涉及b的key1列\",{\"1\":{\"326\":2}}],[\"由于只有两个组\",{\"1\":{\"313\":1}}],[\"由于使用了split\",{\"1\":{\"293\":1}}],[\"由于使用了多态性\",{\"1\":{\"34\":1}}],[\"由于会命中物化视图\",{\"1\":{\"276\":1}}],[\"由于还可以完全屏蔽数据库层\",{\"1\":{\"244\":1}}],[\"由于设备速度慢\",{\"1\":{\"212\":1}}],[\"由于这种策略调入的页面一定会被访问到\",{\"1\":{\"192\":1}}],[\"由于第二轮已将所有帧的访问位设为0\",{\"1\":{\"191\":1}}],[\"由于长期得不到想要的资源\",{\"1\":{\"175\":1}}],[\"由于高频率的进程切换\",{\"1\":{\"167\":1}}],[\"由于共享内存地址空间\",{\"1\":{\"163\":1}}],[\"由于操作系统的管理工作\",{\"1\":{\"157\":1}}],[\"由于外部容器已经提供\",{\"1\":{\"100\":1}}],[\"由于\",{\"1\":{\"66\":1,\"493\":1,\"775\":1}}],[\"由于某些原因需要给某对象提供一个代理以控制对该对象的访问\",{\"1\":{\"56\":1}}],[\"由于实现了构建和装配的解耦\",{\"1\":{\"12\":1}}],[\"由具体工厂来创建\",{\"1\":{\"33\":1,\"38\":1}}],[\"由builder来负责\",{\"1\":{\"12\":1}}],[\"和拦截器合在一起称为\",{\"1\":{\"1438\":1}}],[\"和环绕通知链\",{\"1\":{\"1340\":1}}],[\"和get\",{\"1\":{\"1206\":1}}],[\"和一个经纬度\",{\"1\":{\"1171\":1}}],[\"和一系列随机映射函数\",{\"1\":{\"658\":1}}],[\"和偏移量这两个参数\",{\"1\":{\"1168\":1}}],[\"和优惠卷存入到\",{\"1\":{\"1155\":1}}],[\"和lock都是悲观锁的代表\",{\"1\":{\"1135\":1}}],[\"和对象\",{\"1\":{\"1113\":1}}],[\"和新增一致\",{\"1\":{\"1089\":1}}],[\"和复制分片\",{\"1\":{\"1067\":1}}],[\"和分区的\",{\"1\":{\"1041\":1}}],[\"和若干个\",{\"1\":{\"1026\":1}}],[\"和5位\",{\"1\":{\"998\":1}}],[\"和集群建立链接\",{\"1\":{\"992\":1}}],[\"和job结果进行绑定\",{\"1\":{\"962\":1}}],[\"和应用程序管理器\",{\"1\":{\"945\":1}}],[\"和文件所有者属于同一组的用户\",{\"1\":{\"917\":1}}],[\"和审计\",{\"1\":{\"916\":1}}],[\"和m个校验块\",{\"1\":{\"875\":1}}],[\"和可读数据\",{\"1\":{\"827\":1}}],[\"和它的子类使用了池化机制\",{\"1\":{\"775\":1}}],[\"和物理块\",{\"1\":{\"683\":1}}],[\"和动态变化\",{\"1\":{\"626\":1}}],[\"和et\",{\"1\":{\"680\":1}}],[\"和equals\",{\"1\":{\"616\":1}}],[\"和executors\",{\"1\":{\"574\":1}}],[\"和semaphore类似\",{\"1\":{\"592\":1}}],[\"和set相比增加了一个权重参数score\",{\"1\":{\"515\":1}}],[\"和公平锁一样都会进入到tryacquire方法\",{\"1\":{\"588\":1}}],[\"和callable\",{\"1\":{\"575\":1}}],[\"和countdownlatch和类似\",{\"1\":{\"593\":1}}],[\"和count\",{\"0\":{\"497\":1},\"1\":{\"497\":3}}],[\"和自己创建单线程执行任务的区别\",{\"1\":{\"574\":1}}],[\"和unpark\",{\"0\":{\"549\":1}}],[\"和wait\",{\"0\":{\"546\":1}}],[\"和notify\",{\"0\":{\"545\":1}}],[\"和klass\",{\"1\":{\"540\":1}}],[\"和reduce\",{\"1\":{\"990\":1}}],[\"和runtime\",{\"1\":{\"633\":1}}],[\"和run\",{\"0\":{\"532\":1},\"1\":{\"532\":1}}],[\"和rdmbs中的order\",{\"1\":{\"312\":1}}],[\"和版本1的主要区别是update语句采用了split\",{\"1\":{\"293\":1}}],[\"和数据源系统进行解耦合\",{\"1\":{\"225\":1}}],[\"和数据应用层\",{\"1\":{\"224\":1}}],[\"和用户文件目录\",{\"1\":{\"196\":1}}],[\"和段的长度\",{\"1\":{\"187\":1}}],[\"和段内地址\",{\"1\":{\"187\":1}}],[\"和页表长度\",{\"1\":{\"185\":1}}],[\"和界地址寄存器\",{\"1\":{\"180\":1}}],[\"和时分复用技术\",{\"1\":{\"155\":1}}],[\"和\",{\"0\":{\"804\":1,\"1322\":1},\"1\":{\"112\":1,\"161\":1,\"313\":1,\"437\":1,\"493\":1,\"538\":1,\"549\":1,\"651\":1,\"663\":8,\"665\":2,\"667\":1,\"695\":1,\"740\":1,\"748\":2,\"763\":1,\"779\":1,\"785\":1,\"787\":1,\"795\":1,\"802\":1,\"803\":1,\"804\":1,\"821\":1,\"840\":1,\"855\":1,\"951\":1,\"1029\":1,\"1042\":1,\"1149\":1,\"1171\":1,\"1174\":1,\"1186\":1,\"1243\":1,\"1290\":1,\"1317\":1,\"1321\":2,\"1376\":1}}],[\"和测试\",{\"1\":{\"100\":1}}],[\"和测试类\",{\"1\":{\"7\":1}}],[\"和安装\",{\"1\":{\"95\":1}}],[\"和媒体公司的业务洽淡等\",{\"1\":{\"76\":1}}],[\"和proxyobject是同一个对象\",{\"1\":{\"59\":1}}],[\"和拿铁咖啡\",{\"1\":{\"25\":1}}],[\"和装配\",{\"1\":{\"12\":1}}],[\"并让它实现webmvcconfigurer接口\",{\"1\":{\"1532\":1}}],[\"并注入spring容器\",{\"1\":{\"1524\":1}}],[\"并用泛型技术解析事件对象的原始类型\",{\"1\":{\"1497\":1}}],[\"并演示\",{\"1\":{\"1445\":1}}],[\"并结合匹配到的拦截器一起返回给\",{\"1\":{\"1438\":1}}],[\"并与匹配的拦截器一起返回给\",{\"1\":{\"1355\":1}}],[\"并与对应的\",{\"1\":{\"953\":1}}],[\"并逐一调用它们的初始化\",{\"1\":{\"1355\":1}}],[\"并处理方法参数与方法返回值\",{\"1\":{\"1352\":1}}],[\"并暂存于二级缓存\",{\"1\":{\"1336\":1}}],[\"并非继承而来\",{\"1\":{\"1245\":1}}],[\"并非每次都对三个内存\",{\"1\":{\"628\":1}}],[\"并集\",{\"1\":{\"1210\":1,\"1211\":1}}],[\"并未提供windows安装包\",{\"1\":{\"1200\":1}}],[\"并以十进制形式返回\",{\"1\":{\"1174\":1}}],[\"并按照与指定点之间的距离排序后返回\",{\"1\":{\"1170\":1}}],[\"并按照与圆心之间的距离排序后返回\",{\"1\":{\"1170\":1}}],[\"并反序列化为指定类型\",{\"1\":{\"1129\":4}}],[\"并返回给leader\",{\"1\":{\"1051\":1}}],[\"并返回此对象的地址\",{\"1\":{\"632\":1}}],[\"并配置好\",{\"1\":{\"1046\":1}}],[\"并解压到\",{\"1\":{\"1046\":1}}],[\"并解压\",{\"1\":{\"1012\":1}}],[\"并有相关机制对cache文件进行管理\",{\"1\":{\"989\":1}}],[\"并监控它的运行状态\",{\"1\":{\"953\":1}}],[\"并监控它的整个运行过程\",{\"1\":{\"952\":1}}],[\"并定义该拦截器匹配那些请求路径\",{\"1\":{\"1532\":1}}],[\"并定义其两个子类\",{\"1\":{\"25\":1}}],[\"并定时发送心跳信息汇报当前节点的资源使用情况和\",{\"1\":{\"949\":1}}],[\"并设置\",{\"1\":{\"1394\":2}}],[\"并设置过期时间\",{\"1\":{\"1147\":1}}],[\"并设置超时时间\",{\"1\":{\"1122\":1}}],[\"并设置为加密区\",{\"1\":{\"936\":1}}],[\"并设置唤醒状态为\",{\"1\":{\"741\":1}}],[\"并可以在web\",{\"1\":{\"914\":1}}],[\"并可动态调整\",{\"1\":{\"731\":1}}],[\"并写入一个内部数据队列\",{\"1\":{\"901\":1}}],[\"并写入临时表\",{\"1\":{\"409\":1}}],[\"并执行来自所有namenode的命令\",{\"1\":{\"889\":1}}],[\"并负责运行故障转移以使其本地namenode处于active状态\",{\"1\":{\"885\":1}}],[\"并从\",{\"1\":{\"838\":1}}],[\"并\",{\"1\":{\"741\":1}}],[\"并转换成string类型\",{\"1\":{\"718\":1}}],[\"并为匹配切点的目标类创建代理\",{\"1\":{\"1453\":1}}],[\"并为各个任务申请资源\",{\"1\":{\"949\":1}}],[\"并为它们进行编号\",{\"1\":{\"683\":1}}],[\"并为每个页加以编号\",{\"1\":{\"683\":1}}],[\"并查集\",{\"0\":{\"671\":1}}],[\"并进行计数\",{\"1\":{\"662\":1}}],[\"并把堆内对象的首地址赋值给引用变量\",{\"1\":{\"630\":1}}],[\"并生成对应的class类对象\",{\"1\":{\"630\":1}}],[\"并对原java\",{\"1\":{\"610\":1}}],[\"并没有重复读取\",{\"1\":{\"1166\":1}}],[\"并没有获得到锁\",{\"1\":{\"1126\":1}}],[\"并没有发生内存复制\",{\"1\":{\"776\":1}}],[\"并没有进行对象的赋值操作\",{\"1\":{\"66\":1}}],[\"并没能达到多线程的效果\",{\"1\":{\"532\":1}}],[\"并防止其他用户读取正在写入的同一资源\",{\"1\":{\"508\":1}}],[\"并计数\",{\"1\":{\"478\":1}}],[\"并其下一行数据写入到最终排序的文件中\",{\"1\":{\"478\":1}}],[\"并重载evaluate方法\",{\"1\":{\"344\":1}}],[\"并缓冲a的值\",{\"1\":{\"326\":1}}],[\"并显示整个结果\",{\"1\":{\"317\":1}}],[\"并添加新的列集\",{\"1\":{\"279\":1}}],[\"并提供对于物化视图的查询自动重写机制\",{\"1\":{\"274\":1}}],[\"并提高了软件质量和可维护性\",{\"1\":{\"97\":1}}],[\"并在任务运行失败时重新为任务申请资源以重启任务\",{\"1\":{\"947\":1}}],[\"并在过期时删除旧的检查点\",{\"1\":{\"909\":1}}],[\"并在已复制的块中删除\",{\"1\":{\"888\":1}}],[\"并在jdk9中完全取消了这些组合的支持\",{\"1\":{\"638\":1}}],[\"并在内部消亡\",{\"1\":{\"627\":1}}],[\"并在其中缓冲之前的其他表\",{\"1\":{\"326\":1}}],[\"并在随后有执行引擎调用执行\",{\"1\":{\"232\":1}}],[\"并在cpu运行\",{\"1\":{\"160\":1}}],[\"并具有更灵活的结构\",{\"1\":{\"223\":1}}],[\"并将该请求放入\",{\"1\":{\"726\":1}}],[\"并将预取机制集成到高速缓存控制逻辑中实现\",{\"1\":{\"687\":1}}],[\"并将此页号与高速缓冲中的所有页号进行比较\",{\"1\":{\"683\":1}}],[\"并将\",{\"1\":{\"666\":1}}],[\"并将其映射成一个新的元素\",{\"1\":{\"617\":1}}],[\"并将其存储到数组的第一个索引位置\",{\"1\":{\"88\":1}}],[\"并将这次需要更新的数据的endtime更改为更新值的starttime\",{\"1\":{\"409\":1}}],[\"并将完整的自举程序读入内存\",{\"1\":{\"206\":1}}],[\"并修改超级块的内容\",{\"1\":{\"198\":1}}],[\"并修改页表中相应的页表项\",{\"1\":{\"190\":1}}],[\"并常驻内存\",{\"1\":{\"197\":1}}],[\"并使用\",{\"1\":{\"713\":1}}],[\"并使用高速缓存的层次结构实现\",{\"1\":{\"687\":1}}],[\"并使用concretestrategy角色去实现需求\",{\"1\":{\"80\":1}}],[\"并使分区的大小正好适合进程的需要\",{\"1\":{\"182\":1}}],[\"并剥夺这些进程的资源\",{\"1\":{\"178\":1}}],[\"并抢占它的资源\",{\"1\":{\"178\":1}}],[\"并建立相应的进程\",{\"1\":{\"164\":1}}],[\"并不仅仅是这里会使用\",{\"1\":{\"1214\":1}}],[\"并不需要大家过于精通\",{\"1\":{\"1146\":1}}],[\"并不需要等待\",{\"1\":{\"679\":1}}],[\"并不影响整体系统的运行\",{\"1\":{\"883\":1}}],[\"并不推荐使用\",{\"1\":{\"286\":1}}],[\"并不是\",{\"1\":{\"1155\":1}}],[\"并不是真正无拷贝\",{\"1\":{\"855\":1}}],[\"并不是要取代数据库\",{\"1\":{\"222\":1}}],[\"并不是所有的资源都可以改造成可共享使用资源\",{\"1\":{\"176\":1}}],[\"并不一定真实\",{\"1\":{\"167\":1}}],[\"并不意识到线程的存在\",{\"1\":{\"163\":1}}],[\"并不涉及具体的部件对象的创建\",{\"1\":{\"13\":1}}],[\"并由操作系统内核对中断进行处理\",{\"1\":{\"157\":1}}],[\"并行的操作\",{\"1\":{\"1066\":1}}],[\"并行回收器\",{\"1\":{\"638\":1}}],[\"并行执行\",{\"0\":{\"446\":1}}],[\"并行\",{\"1\":{\"155\":1}}],[\"并发过来\",{\"1\":{\"1137\":1}}],[\"并发送\",{\"1\":{\"726\":1}}],[\"并发回收器\",{\"1\":{\"638\":1}}],[\"并发局限于应用中\",{\"1\":{\"612\":1}}],[\"并发编程面试必备\",{\"1\":{\"562\":1}}],[\"并发编程的三大特性\",{\"0\":{\"556\":1}}],[\"并发执行的进程p1\",{\"1\":{\"175\":1}}],[\"并发度不高\",{\"1\":{\"163\":1}}],[\"并发性能大大提升\",{\"1\":{\"579\":1}}],[\"并发性能较差\",{\"1\":{\"506\":1}}],[\"并发性能好\",{\"1\":{\"503\":1,\"506\":1}}],[\"并发性\",{\"1\":{\"159\":1}}],[\"并发和共享的关系\",{\"1\":{\"155\":1}}],[\"并发\",{\"1\":{\"155\":2}}],[\"并合理地组织调度计算机的工作和资源的分配\",{\"1\":{\"153\":1}}],[\"并检查\",{\"1\":{\"101\":1}}],[\"并通过运行该脚本启动任务\",{\"1\":{\"953\":1}}],[\"并通过nm分配\",{\"1\":{\"944\":1}}],[\"并通过\",{\"1\":{\"97\":1}}],[\"并通过该类进行了字节流和字符流之间的解码转换\",{\"1\":{\"9\":1}}],[\"并能够自动化项目的构建和部署\",{\"1\":{\"94\":1}}],[\"并符合\",{\"1\":{\"86\":1}}],[\"并初始化instance\",{\"1\":{\"66\":1}}],[\"并初始化其静态属性\",{\"1\":{\"66\":1}}],[\"并且body携带json数据\",{\"1\":{\"1525\":1}}],[\"并且content\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"并且是将函数的返回值直接填入http响应体中\",{\"1\":{\"1525\":1}}],[\"并且要求更多功能的场景中\",{\"1\":{\"1501\":1}}],[\"并且功能要求不是很严格的场景\",{\"1\":{\"1501\":1}}],[\"并且仅会走\",{\"1\":{\"1254\":1}}],[\"并且查询时能自动把json反序列化为java对象\",{\"1\":{\"1222\":1}}],[\"并且能将java对象自动的序列化为json字符串\",{\"1\":{\"1222\":1}}],[\"并且能够保证数据的完整性\",{\"1\":{\"995\":1}}],[\"并且将不同数据类型的操作api封装到了不同的类型中\",{\"1\":{\"1217\":1}}],[\"并且将value设置为空\",{\"1\":{\"1124\":1}}],[\"并且使用的还是连接池对象\",{\"1\":{\"1216\":1}}],[\"并且频繁的创建和销毁连接会有性能损耗\",{\"1\":{\"1214\":1}}],[\"并且指定有效期\",{\"1\":{\"1206\":1}}],[\"并且内存占用极小\",{\"1\":{\"1180\":1}}],[\"并且还可以记录当前获取数据时间戳最小值\",{\"1\":{\"1167\":1}}],[\"并且实现也相对简单\",{\"1\":{\"1166\":1}}],[\"并且返回\",{\"1\":{\"1155\":1}}],[\"并且选举一个slave变成master\",{\"1\":{\"1153\":1}}],[\"并且生成token作为redis的key\",{\"1\":{\"1106\":1}}],[\"并且把自己的信息存放到第一台服务器的session中\",{\"1\":{\"1102\":1}}],[\"并且把内存扩展到磁盘空间\",{\"1\":{\"688\":1}}],[\"并且访问对应的db\",{\"1\":{\"1100\":1}}],[\"并且放行\",{\"1\":{\"1098\":1,\"1106\":1}}],[\"并且放在索引组合顺序的最后\",{\"1\":{\"481\":1}}],[\"并且当我们要对这个索引中的文档进行索引\",{\"1\":{\"1061\":1}}],[\"并且向rm主角色汇报资源使用情况\",{\"1\":{\"944\":1}}],[\"并且需要思考如何建立映射才能对性能更好\",{\"1\":{\"1065\":1}}],[\"并且需要x权限才能访问目录的子级\",{\"1\":{\"918\":1}}],[\"并且需要单独手动启动metastore服务\",{\"1\":{\"244\":1}}],[\"并且快照只是记录一些元数据信息\",{\"1\":{\"913\":1}}],[\"并且在数据从mapper到reducer的过程中\",{\"1\":{\"988\":1}}],[\"并且在遍历的时候进行统计\",{\"1\":{\"983\":1}}],[\"并且在可配置的时间间隔内\",{\"1\":{\"909\":1}}],[\"并且在等待i\",{\"1\":{\"209\":1}}],[\"并且该地址列表是排序好的\",{\"1\":{\"902\":1}}],[\"并且该字段在多张表中的\",{\"1\":{\"493\":1}}],[\"并且zkfc看到当前没有其他节点持有锁znode\",{\"1\":{\"885\":1}}],[\"并且线程太多\",{\"1\":{\"826\":1}}],[\"并且一旦工人负责了某个\",{\"1\":{\"787\":1}}],[\"并且一次性对整个记录整合\",{\"1\":{\"438\":1}}],[\"并且没有\",{\"1\":{\"777\":1}}],[\"并且没有任何性能影响和空间的浪费\",{\"1\":{\"66\":1}}],[\"并且采用了与\",{\"1\":{\"770\":1}}],[\"并且处理病人的能力提高到了\",{\"1\":{\"755\":1}}],[\"并且遵守两者的契约\",{\"1\":{\"716\":1}}],[\"并且又再次收到了用户进程的system\",{\"1\":{\"679\":1}}],[\"并且\",{\"1\":{\"658\":2}}],[\"并且长时间不能被垃圾收集器收集\",{\"1\":{\"636\":1}}],[\"并且检查这个符号引用代表的类是否已经被加载\",{\"1\":{\"630\":1}}],[\"并且不能自定义仓库名称\",{\"1\":{\"1202\":1}}],[\"并且不必为每个连接都创建一个线程\",{\"1\":{\"610\":1}}],[\"并且不利用mapreduce的处理\",{\"1\":{\"435\":1}}],[\"并且都不是线程安全的\",{\"1\":{\"604\":1}}],[\"并且都不释放\",{\"1\":{\"552\":1}}],[\"并且同时5个线程来获取资源\",{\"1\":{\"591\":1}}],[\"并且性能和高可用性等各方面表现一般\",{\"1\":{\"526\":1}}],[\"并且redis底层会通过限制删除操作的时常和频率来减少删除操作对cpu的影响\",{\"1\":{\"520\":1}}],[\"并且插入时可能造成页分裂\",{\"1\":{\"494\":1}}],[\"并且随着数据量的增加所耗费的时间也会增加\",{\"1\":{\"485\":1}}],[\"并且每个元素只能是\",{\"1\":{\"658\":1}}],[\"并且每个分组内再按照age进行倒序排序\",{\"1\":{\"313\":1}}],[\"并且每种存储引擎也不一定支持所有的索引类型\",{\"1\":{\"485\":1}}],[\"并且部分高性能引擎将其作为默认的文件存储格式\",{\"1\":{\"429\":1}}],[\"并且各个桶中能放的行数最多相差1\",{\"1\":{\"364\":1}}],[\"并且为这个文件提供了一个索引文件\",{\"1\":{\"979\":1}}],[\"并且为每一个桶分配一个桶编号\",{\"1\":{\"364\":1}}],[\"并且为了系统安全\",{\"1\":{\"176\":1}}],[\"并且根据倒序排序\",{\"1\":{\"349\":1}}],[\"并且表b和c的键的特定值的值被缓冲在reducer的内存中\",{\"1\":{\"326\":1}}],[\"并且表a和b的键的特定值的值被缓冲在reducer的内存中\",{\"1\":{\"326\":1}}],[\"并且表的属性设置transactional=true\",{\"1\":{\"268\":1}}],[\"并且按累计确诊病例进行倒序排序\",{\"1\":{\"265\":1}}],[\"并且可以设置逻辑过期时间\",{\"1\":{\"1129\":2}}],[\"并且可以设置ttl过期时间\",{\"1\":{\"1129\":2}}],[\"并且可以一次性读取一行字符\",{\"1\":{\"989\":1}}],[\"并且可以将这些行中的某些属性添加到结果集中\",{\"1\":{\"356\":1}}],[\"并且可以在单独的主机上\",{\"1\":{\"243\":1}}],[\"并且可将程序分配到不连续的存储区\",{\"1\":{\"179\":1}}],[\"并且derby数据库和metastore服务都嵌入在主hiveserver进程中\",{\"1\":{\"242\":1}}],[\"并且只会通知一次\",{\"1\":{\"680\":1}}],[\"并且只会装载一次\",{\"1\":{\"66\":1}}],[\"并且只要某个用户修改了该文件数据\",{\"1\":{\"200\":1}}],[\"并且支持设置依赖关系\",{\"1\":{\"991\":1}}],[\"并且支持随机访问\",{\"1\":{\"197\":1}}],[\"并且支持多个装饰器的嵌套使用\",{\"1\":{\"10\":1}}],[\"并且程序的指令也是顺序的在内存中存放\",{\"1\":{\"189\":1}}],[\"并且p\",{\"1\":{\"172\":1}}],[\"并且小于0的时候需要阻塞\",{\"1\":{\"172\":1}}],[\"并且会增大进程的响应时间\",{\"1\":{\"167\":1}}],[\"并且终止依赖传递\",{\"1\":{\"105\":1}}],[\"并且配置时生成的路径也是由此生成\",{\"1\":{\"98\":1}}],[\"并且父类修改后\",{\"1\":{\"73\":1}}],[\"并且严格保证实例化顺序\",{\"1\":{\"66\":1}}],[\"并创建\",{\"1\":{\"743\":1}}],[\"并创建singleton类的对象instance\",{\"1\":{\"66\":1}}],[\"并创建对象进行存储\",{\"1\":{\"42\":1}}],[\"并向调用者返回完整的产品类\",{\"1\":{\"14\":1}}],[\"让sorted\",{\"1\":{\"1211\":1}}],[\"让num值自增2\",{\"1\":{\"1206\":1}}],[\"让用户用他查询的\",{\"1\":{\"1177\":1}}],[\"让用户程序依赖于抽象\",{\"1\":{\"74\":1}}],[\"让程序串行执行\",{\"1\":{\"1140\":1}}],[\"让拦截器生效\",{\"1\":{\"1100\":1}}],[\"让订单号放在首位\",{\"1\":{\"988\":1}}],[\"让从角色通过主角色的修改日志记录重演修改操作\",{\"1\":{\"882\":1}}],[\"让dfsclient绕开datanode自己去读取数据\",{\"1\":{\"872\":1}}],[\"让这个线程能够被充分利用\",{\"1\":{\"829\":1}}],[\"让消息传递给下一个handler\",{\"1\":{\"748\":1}}],[\"让\",{\"1\":{\"741\":1,\"743\":1,\"744\":1}}],[\"让所有数据包长度固定\",{\"1\":{\"697\":1}}],[\"让reset后回到标记位置\",{\"1\":{\"610\":1}}],[\"让请求线程阻塞\",{\"1\":{\"591\":1}}],[\"让某个线程先结束即可\",{\"1\":{\"552\":1}}],[\"让他们关联同一个guardedobject\",{\"1\":{\"547\":1}}],[\"让各种客户端通过连接metastore服务\",{\"1\":{\"240\":1}}],[\"让新回收的块成为第一个分组\",{\"1\":{\"198\":1}}],[\"让一个hash类型key的字段值自增并指定步长\",{\"1\":{\"1208\":1}}],[\"让一个浮点类型的数字自增并指定步长\",{\"1\":{\"1206\":1}}],[\"让一个整型的key自增并指定步长\",{\"1\":{\"1206\":1}}],[\"让一个整型的key自增1\",{\"1\":{\"1206\":1}}],[\"让一个用户只能下一个单\",{\"1\":{\"1137\":1}}],[\"让一个或多个死锁进程回退到避免死锁的地步\",{\"1\":{\"178\":1}}],[\"让一个项目从另一个项目中继承配置信息的机制\",{\"1\":{\"107\":1}}],[\"让权等待\",{\"1\":{\"168\":1}}],[\"让每一个进程在一定时间间隔内都可以得到响应\",{\"1\":{\"167\":1}}],[\"让computer类依赖抽象\",{\"1\":{\"74\":1}}],[\"让子类决定实例化哪个产品类对象\",{\"1\":{\"32\":1}}],[\"让其子类实现工厂接口\",{\"1\":{\"23\":1}}],[\"让其子类自己决定实例化哪一个工厂类\",{\"1\":{\"23\":1}}],[\"让它们更容易\",{\"1\":{\"10\":1}}],[\"让客户按目标接口的格式访问适配者\",{\"1\":{\"5\":1}}],[\"这便是spring\",{\"1\":{\"1524\":1}}],[\"这儿\",{\"1\":{\"1455\":1}}],[\"这其中有异常\",{\"1\":{\"1444\":1}}],[\"这其实是redis\",{\"1\":{\"529\":1}}],[\"这体现的是适配器设计模式\",{\"1\":{\"1343\":1}}],[\"这需要用到redis客户端\",{\"1\":{\"1198\":1}}],[\"这需要进一步测试\",{\"1\":{\"680\":1}}],[\"这完全可以忽略\",{\"1\":{\"1179\":1}}],[\"这几条记录\",{\"1\":{\"1167\":1}}],[\"这几个方法为什么不直接定义成抽象方法呢\",{\"1\":{\"585\":1}}],[\"这把锁加锁的逻辑需要写入到每一个主丛节点上\",{\"1\":{\"1153\":1}}],[\"这句话相当于对以上抢锁进行了监听\",{\"1\":{\"1152\":1}}],[\"这句话有数种拆解方式\",{\"1\":{\"709\":1}}],[\"这套机制的核心逻辑在于\",{\"1\":{\"1135\":1}}],[\"这明显不合适\",{\"1\":{\"1131\":1}}],[\"这么大数据量\",{\"1\":{\"1114\":1}}],[\"这在实际开发中对企业讲\",{\"1\":{\"1113\":1}}],[\"这对数据完整性要求不高的大数据处理领域\",{\"1\":{\"995\":1}}],[\"这对用户肯定是不友好的\",{\"1\":{\"74\":1}}],[\"这三个域组成了一个域树\",{\"1\":{\"923\":1}}],[\"这三项里\",{\"1\":{\"637\":1}}],[\"这区别于ha模式下的多namenode\",{\"1\":{\"889\":1}}],[\"这允许在块组级别而不是块级别进行文件管理\",{\"1\":{\"875\":1}}],[\"这块内存不受\",{\"1\":{\"855\":1}}],[\"这项能力\",{\"1\":{\"854\":1}}],[\"这期间\",{\"1\":{\"854\":1}}],[\"这期间用户线程阻塞\",{\"1\":{\"854\":1}}],[\"这边有可能出bug\",{\"1\":{\"1141\":1}}],[\"这边的\",{\"1\":{\"848\":1}}],[\"这边说的请求分页存储管理和操作系统内存管理中的分页存储管理有何不同\",{\"1\":{\"689\":1}}],[\"这称之为多路复用\",{\"1\":{\"828\":1}}],[\"这行代码完成的事实是\",{\"1\":{\"740\":1,\"743\":1}}],[\"这白纸黑字明摆着的\",{\"1\":{\"709\":1}}],[\"这不仅会使相当一部分内存空间都处于暂时或\",{\"1\":{\"689\":1}}],[\"这不利于类的扩展与维护\",{\"1\":{\"77\":1}}],[\"这两种数据结构的设计目标\",{\"1\":{\"667\":1}}],[\"这两个注解\",{\"1\":{\"1466\":1}}],[\"这两个主要是提供了redis命令对应的api\",{\"1\":{\"1212\":1}}],[\"这两个主要记住\",{\"1\":{\"221\":1}}],[\"这两个参数第一次会由前端来指定\",{\"1\":{\"1168\":1}}],[\"这两个线程由于使用的是同一份代码\",{\"1\":{\"1138\":1}}],[\"这两个元素里保存的信息\",{\"1\":{\"665\":1}}],[\"这两个类型\",{\"1\":{\"663\":1}}],[\"这两个只是理论上的三个步骤\",{\"1\":{\"228\":1}}],[\"这意味着最少3个机架\",{\"1\":{\"875\":1}}],[\"这意味着在读写条带化文件时\",{\"1\":{\"875\":1}}],[\"这意味着程序将确保每个datanode上的磁盘使用量与群集中的总体使用量相差不超过5\",{\"1\":{\"873\":1}}],[\"这意味着\",{\"1\":{\"663\":1,\"1067\":1}}],[\"这意味着数据会立即加载到单一的集中存储库中\",{\"1\":{\"228\":1}}],[\"这\",{\"1\":{\"663\":1,\"694\":1}}],[\"这次你get了么\",{\"1\":{\"651\":1}}],[\"这一\",{\"1\":{\"1290\":1}}],[\"这一操作保证了对象的实例字段在java代码中不赋值就可以使用\",{\"1\":{\"630\":1}}],[\"这一策略的类\",{\"1\":{\"81\":2}}],[\"这成为rehashing\",{\"1\":{\"606\":1}}],[\"这唯一的线程也不会被释放\",{\"1\":{\"574\":1}}],[\"这部分数据是锁定的\",{\"1\":{\"506\":1}}],[\"这点有待商榷\",{\"1\":{\"503\":1}}],[\"这会进行aop\",{\"1\":{\"1505\":1}}],[\"这会带来额外的内存开销\",{\"1\":{\"1222\":1}}],[\"这会大大消耗资源和时间\",{\"1\":{\"498\":1}}],[\"这会导致类的个数增加\",{\"1\":{\"86\":1}}],[\"这使得范围查找可以通过指针连接查找\",{\"1\":{\"488\":1}}],[\"这也可以说是redis为什么快的一个原因\",{\"1\":{\"663\":1}}],[\"这也是典型适配器模式体现\",{\"1\":{\"1437\":1}}],[\"这也是\",{\"1\":{\"1366\":1}}],[\"这也是为什么说数据是相对有序的\",{\"1\":{\"1035\":1}}],[\"这也是一个可以改进的地方\",{\"1\":{\"662\":1}}],[\"这也是经典的内存不可见问题\",{\"1\":{\"560\":1}}],[\"这也是创建索引的主要原因\",{\"1\":{\"485\":1}}],[\"这也就印证了我们之前说的真实类和代理类实现同样的接口\",{\"1\":{\"59\":1}}],[\"这要求系统记录进程的历史信息\",{\"1\":{\"178\":1}}],[\"这是必填参数\",{\"1\":{\"875\":1}}],[\"这是为了解决\",{\"1\":{\"742\":1}}],[\"这是为了满足用户要求而形成的一种存储管理方式\",{\"1\":{\"683\":1}}],[\"这是分页和分段两种存储管理方式相结合的产物\",{\"1\":{\"683\":1}}],[\"这是按照实际占用字节数进行分配内存的\",{\"1\":{\"663\":1}}],[\"这是一种习惯\",{\"1\":{\"1500\":1}}],[\"这是一种特殊的采样方法\",{\"1\":{\"369\":1}}],[\"这是一个可以改进的地方\",{\"1\":{\"662\":2}}],[\"这是默认策略\",{\"1\":{\"573\":1}}],[\"这是效率提升的因素之一\",{\"1\":{\"561\":1}}],[\"这是因为这些版本的\",{\"1\":{\"1243\":1}}],[\"这是因为\",{\"1\":{\"835\":1,\"1462\":1}}],[\"这是因为指令通常是顺序存放\",{\"1\":{\"687\":1}}],[\"这是因为默认情况下\",{\"1\":{\"663\":1}}],[\"这是因为每张myisam的数据表都有一个meta信息存储了row\",{\"1\":{\"497\":1}}],[\"这是因为索引会对数据按照某种顺序进行排序\",{\"1\":{\"493\":1}}],[\"这是因为非索引字段更新不需要对索引进行维护\",{\"1\":{\"493\":1}}],[\"这是不对的\",{\"1\":{\"483\":1}}],[\"这是银行家算法核心思想\",{\"1\":{\"177\":1}}],[\"这是和装饰器模式的最大不同\",{\"1\":{\"10\":1}}],[\"这违背了空闲让进的原则\",{\"1\":{\"169\":1}}],[\"这就使得所有的数据都挤压到reduce阶段处理\",{\"1\":{\"988\":1}}],[\"这就造成了半包\",{\"1\":{\"694\":1}}],[\"这就会直接影响到压缩列表的访问性能\",{\"1\":{\"667\":1}}],[\"这就增加了处理过程中的灵活性\",{\"1\":{\"610\":1}}],[\"这就导致了资源紧张及浪费的情况\",{\"1\":{\"445\":1}}],[\"这就导致了内存中会驻留大量的\",{\"1\":{\"189\":1}}],[\"这就意味着之后可能所有进程都无法顺利执行下去\",{\"1\":{\"177\":1}}],[\"这就算作冲突\",{\"1\":{\"105\":1}}],[\"这就是删锁时的原子性问题\",{\"1\":{\"1145\":1}}],[\"这就是误删别人锁的情况说明\",{\"1\":{\"1143\":1}}],[\"这就是分布式锁的核心思路\",{\"1\":{\"1140\":1}}],[\"这就是数据分区问题\",{\"1\":{\"968\":1}}],[\"这就是\",{\"1\":{\"694\":1,\"1138\":1}}],[\"这就是沙箱安全机制\",{\"1\":{\"624\":1}}],[\"这就是双亲委派机制\",{\"1\":{\"623\":1}}],[\"这就是索引下推\",{\"1\":{\"495\":1}}],[\"这就是两个函数\",{\"1\":{\"171\":1}}],[\"这就是依赖的传递性\",{\"1\":{\"104\":1}}],[\"这就是浅克隆的效果\",{\"1\":{\"54\":1}}],[\"这导致一种反向的控制结构\",{\"1\":{\"86\":1}}],[\"这类方法名一般为isxxx\",{\"1\":{\"84\":1}}],[\"这里为啥要切点\",{\"1\":{\"1339\":1}}],[\"这里返回的对象会替换掉原本的bean\",{\"1\":{\"1505\":2}}],[\"这里返回的对象会替换掉原本的\",{\"1\":{\"1254\":2}}],[\"这里返回的对象若不为\",{\"1\":{\"1254\":1}}],[\"这里如果返回\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"这里出于怀旧的原因\",{\"1\":{\"1245\":1}}],[\"这里采用了json序列化来代替默认的jdk序列化方式\",{\"1\":{\"1222\":1}}],[\"这里采用了引用计数法来控制回收内存\",{\"1\":{\"775\":1}}],[\"这里需要把主键修改为自增长\",{\"1\":{\"1164\":1}}],[\"这里重点介绍redis提供的调用函数\",{\"1\":{\"1146\":2}}],[\"这里有同学有疑问\",{\"1\":{\"1455\":1}}],[\"这里有两个关键字\",{\"1\":{\"1182\":1}}],[\"这里有几个问题\",{\"1\":{\"1121\":1}}],[\"这里有个费解的地方就是\",{\"1\":{\"742\":1}}],[\"这里具体逻辑就不分析了\",{\"1\":{\"1107\":1}}],[\"这里对应有一个acks的配置\",{\"1\":{\"1043\":1}}],[\"这里指定的是stringserializer方式\",{\"1\":{\"1023\":1}}],[\"这里调用一次map方法进程处理\",{\"1\":{\"979\":1}}],[\"这里这么写\",{\"1\":{\"839\":2}}],[\"这里是直接查询数据库\",{\"1\":{\"1116\":1}}],[\"这里是将\",{\"1\":{\"785\":1}}],[\"这里是关键\",{\"1\":{\"353\":1}}],[\"这里仅介绍其跟\",{\"1\":{\"780\":1}}],[\"这里要知道\",{\"1\":{\"742\":1}}],[\"这里\",{\"1\":{\"740\":1,\"743\":1}}],[\"这里n指的是数组的长度\",{\"1\":{\"605\":1}}],[\"这里的argv\",{\"1\":{\"1146\":1}}],[\"这里的缓冲区大小要比map端的更为灵活\",{\"1\":{\"980\":1}}],[\"这里的排序也是对序列化的字节做的排序\",{\"1\":{\"979\":1}}],[\"这里的\",{\"1\":{\"761\":1,\"1146\":1}}],[\"这里的束修金\",{\"1\":{\"709\":1}}],[\"这里的优雅指的是给t2一个处理其他事情的机会\",{\"1\":{\"536\":1}}],[\"这里的经纪人是明星的朋友\",{\"1\":{\"76\":1}}],[\"这里使用了struct来构造数据\",{\"1\":{\"351\":1}}],[\"这里当执行create\",{\"1\":{\"276\":1}}],[\"这里bike是产品\",{\"1\":{\"14\":1}}],[\"这大大降低了客户程序与实现细节的耦合度\",{\"1\":{\"74\":1}}],[\"这种业务方法嵌套调用的时候\",{\"1\":{\"1514\":1}}],[\"这种用法比较普遍\",{\"1\":{\"1223\":1}}],[\"这种启动属于前台启动\",{\"1\":{\"1195\":1}}],[\"这种思路就称为位图\",{\"1\":{\"1174\":1}}],[\"这种做法和课程中有哪种好呢\",{\"1\":{\"1155\":1}}],[\"这种在特殊情况下产生的连续多次空间扩展操作就叫做\",{\"1\":{\"666\":1}}],[\"这种根据数据大小和类型进行不同的空间大小分配的设计思想\",{\"1\":{\"665\":1}}],[\"这种方案巧妙在于\",{\"1\":{\"1126\":1}}],[\"这种方法好不好\",{\"1\":{\"779\":1}}],[\"这种方法可以有效地节省内存开销\",{\"1\":{\"664\":1}}],[\"这种方式相对麻烦\",{\"1\":{\"1513\":1}}],[\"这种方式会导致一个用户无限点赞\",{\"1\":{\"1161\":1}}],[\"这种方式优点在于节约内存空间\",{\"1\":{\"1123\":1}}],[\"这种方式对服务器资源要求比较高\",{\"1\":{\"612\":1}}],[\"这种方式就是cbo优化器引擎会选择的方案\",{\"1\":{\"455\":1}}],[\"这种方式需要一个重定位寄存器\",{\"1\":{\"179\":1}}],[\"这种方式需要考虑进程的优先级\",{\"1\":{\"176\":1}}],[\"这种方式的优点是实现简单\",{\"1\":{\"178\":1}}],[\"这种方式速度更快\",{\"1\":{\"162\":1}}],[\"这种方式速度慢\",{\"1\":{\"162\":1}}],[\"这种方式比较好理解\",{\"1\":{\"69\":1}}],[\"这种数据结构是高效且性能很好的\",{\"1\":{\"658\":1}}],[\"这种通过创建副本对象来避免共享的手段称之为\",{\"1\":{\"566\":1}}],[\"这种集群模式没有中心节点\",{\"1\":{\"527\":1}}],[\"这种情况占位符\",{\"1\":{\"1230\":1}}],[\"这种情况下\",{\"1\":{\"1067\":1,\"1506\":1}}],[\"这种情况下该怎么处理呢\",{\"1\":{\"477\":1}}],[\"这种情况一般有如下两种解决方式\",{\"1\":{\"1003\":1}}],[\"这种情况我们可以适当增加位数组大小或者调整我们的哈希函数\",{\"1\":{\"659\":1}}],[\"这种情况需要使用深克隆\",{\"1\":{\"54\":1}}],[\"这种解法的主要思路如下\",{\"1\":{\"477\":1}}],[\"这种join的原理是将map\",{\"1\":{\"470\":1}}],[\"这种场景下\",{\"1\":{\"469\":1}}],[\"这种指定分区查询的方式叫做分区裁剪\",{\"1\":{\"259\":1}}],[\"这种频繁的页面调度行为称为抖动\",{\"1\":{\"192\":1}}],[\"这种不可被中断的操作就是原子操作\",{\"1\":{\"161\":1}}],[\"这种模式就是strategy模式\",{\"1\":{\"79\":1}}],[\"这种模式涉及到一个单一的类\",{\"1\":{\"64\":1}}],[\"这种复用可以在运行时动态进行\",{\"1\":{\"77\":1}}],[\"这种类型的设计模式属于创建型模式\",{\"1\":{\"64\":1}}],[\"这时最常见的选择\",{\"1\":{\"1514\":1}}],[\"这时其他线程\",{\"1\":{\"1143\":1}}],[\"这时将数据从用户缓冲区\",{\"1\":{\"854\":1}}],[\"这时将剩余数据发送\",{\"1\":{\"694\":1}}],[\"这时写入\",{\"1\":{\"817\":1}}],[\"这时读取会返回\",{\"1\":{\"817\":1}}],[\"这时需要使用\",{\"1\":{\"785\":1}}],[\"这时需要向\",{\"1\":{\"741\":1}}],[\"这时调用\",{\"1\":{\"776\":1}}],[\"这时调用find方法来查找\",{\"1\":{\"579\":1}}],[\"这时无须\",{\"1\":{\"775\":1}}],[\"这时即使\",{\"1\":{\"775\":1}}],[\"这时要重复读取的话\",{\"1\":{\"774\":1}}],[\"这时要重新设置打断标记\",{\"1\":{\"536\":1}}],[\"这时会引发扩容\",{\"1\":{\"773\":1}}],[\"这时会调用equals方法来检查hashcode相等的对象是否真的相同\",{\"1\":{\"596\":1}}],[\"这时刚才的客户端代码\",{\"1\":{\"753\":1}}],[\"这时的\",{\"1\":{\"743\":1,\"776\":1}}],[\"这时是处理\",{\"1\":{\"743\":1,\"744\":1}}],[\"这时现象就是客户端数据发不出去\",{\"1\":{\"707\":1}}],[\"这时放不下了\",{\"1\":{\"694\":1}}],[\"这时cpu会暂时执行下一个即将要执行的指令\",{\"1\":{\"676\":1}}],[\"这时当前运行进程会切换到处理此异常的内核相关进程\",{\"1\":{\"676\":1}}],[\"这时打印的结果是\",{\"1\":{\"663\":1}}],[\"这时在操作这个字符串时就会提早结束\",{\"1\":{\"662\":1}}],[\"这时thread\",{\"1\":{\"591\":1}}],[\"这时仅比较值是不够的\",{\"1\":{\"563\":1}}],[\"这时该线程实际不会用到cpu\",{\"1\":{\"538\":1}}],[\"这时sleep方法会抛出interruptedexception\",{\"1\":{\"533\":1}}],[\"这时一种主动的死锁检测方法\",{\"1\":{\"513\":1}}],[\"这时候耦合很严重\",{\"1\":{\"1009\":1}}],[\"这时候会增加网络传输消耗\",{\"1\":{\"976\":1}}],[\"这时候会使用\",{\"1\":{\"576\":1}}],[\"这时候切换回来以后\",{\"1\":{\"625\":1}}],[\"这时候\",{\"1\":{\"576\":1,\"743\":1}}],[\"这时候其他线程读取的数据就是脏数据了\",{\"1\":{\"560\":1}}],[\"这时候就可以判定程序出现了数据倾斜的问题\",{\"1\":{\"462\":1}}],[\"这时候是没有必要检索索引以后再检索数据的\",{\"1\":{\"455\":1}}],[\"这时候可以使用模板方法模式\",{\"1\":{\"87\":1}}],[\"这时呢\",{\"1\":{\"105\":1}}],[\"这时\",{\"1\":{\"56\":1,\"666\":1,\"774\":1,\"775\":1,\"776\":1,\"1438\":1}}],[\"这些东西加在一起即支持某项功能\",{\"1\":{\"1521\":1}}],[\"这些被创建和管理的对象叫做bean\",{\"1\":{\"1502\":1}}],[\"这些流程都不会走\",{\"1\":{\"1472\":1}}],[\"这些通知调用时因为要为通知方法绑定参数\",{\"1\":{\"1350\":1}}],[\"这些通知调用时无需再次检查切点\",{\"1\":{\"1343\":1}}],[\"这些扩展功能由不同的\",{\"1\":{\"1271\":1}}],[\"这些扩展功能由\",{\"1\":{\"1264\":1}}],[\"这些请求就都会访问到数据库\",{\"1\":{\"1123\":1}}],[\"这些请求都会打到数据库\",{\"1\":{\"1123\":1}}],[\"这些功能都得靠nginx起作用\",{\"1\":{\"1094\":1}}],[\"这些拷贝叫做复制分片\",{\"1\":{\"1067\":1}}],[\"这些都是池化思想的体现\",{\"1\":{\"1214\":1}}],[\"这些都是透明的\",{\"1\":{\"1066\":1}}],[\"这些都是映射里面可以设置的\",{\"1\":{\"1065\":1}}],[\"这些都会造成线程资源的浪费\",{\"1\":{\"609\":1}}],[\"这些信息会在系统启动时从datanode汇报中重建\",{\"1\":{\"903\":1}}],[\"这些信息一般保存在进程控制块中\",{\"1\":{\"165\":1}}],[\"这些操作对用户来说是透明的\",{\"1\":{\"902\":1}}],[\"这些事件发生\",{\"1\":{\"867\":1}}],[\"这些事件宏观上是同时发生的\",{\"1\":{\"155\":1}}],[\"这些\",{\"1\":{\"867\":1,\"1421\":1}}],[\"这些方法的执行流程如下图\",{\"1\":{\"1532\":1}}],[\"这些方法的未指明返回值的\",{\"1\":{\"772\":1}}],[\"这些方法不会改变\",{\"1\":{\"774\":1}}],[\"这些代码可以认为是现成的\",{\"1\":{\"733\":1}}],[\"这些段在内存中可以不相邻接\",{\"1\":{\"683\":1}}],[\"这些在每块中未被利用的空间\",{\"1\":{\"683\":1}}],[\"这些数据拷贝操作所带来的cpu以及内存开销是非常大的\",{\"1\":{\"678\":1}}],[\"这些数据源通常是事务性数据库\",{\"1\":{\"228\":1}}],[\"这些stage没有依赖关系\",{\"1\":{\"446\":1}}],[\"这些初始化工作是通过执行\",{\"1\":{\"206\":1}}],[\"这些指令会告诉cpu去内存的哪个地址存\",{\"1\":{\"179\":1}}],[\"这些进程都无法向前推进\",{\"1\":{\"175\":1}}],[\"这些进程为了完成某种任务\",{\"1\":{\"168\":1}}],[\"这些对象同当前对象存在关联\",{\"1\":{\"76\":1}}],[\"这些对象都需要创建\",{\"1\":{\"25\":1}}],[\"这些皮肤有共同的特点\",{\"1\":{\"72\":1}}],[\"这些工厂只生产同种类产品\",{\"1\":{\"36\":1}}],[\"这增加了系统的复杂度\",{\"1\":{\"35\":1}}],[\"这显然违背了软件设计的开闭原则\",{\"1\":{\"25\":1}}],[\"这并不是什么好事\",{\"1\":{\"23\":1}}],[\"这样通过拦截器就可以增强处理器的功能\",{\"1\":{\"1532\":1}}],[\"这样我们的后端就可以直接把json格式的数据映射到我们的userregisterrequest类上\",{\"1\":{\"1525\":1}}],[\"这样我们就用极小的空间\",{\"1\":{\"1174\":1}}],[\"这样程序不就超级快了吗\",{\"1\":{\"1155\":1}}],[\"这样程序的性能能够得到提高\",{\"1\":{\"499\":1}}],[\"这样数据不就一直占用我们内存了吗\",{\"1\":{\"1126\":1}}],[\"这样是会存在缓存穿透问题的\",{\"1\":{\"1124\":1}}],[\"这样缓存永远不会生效\",{\"1\":{\"1123\":1}}],[\"这样极为不靠谱\",{\"1\":{\"1101\":1}}],[\"这样属于同一个州的数据就会变成一组进行reduce处理\",{\"1\":{\"972\":1}}],[\"这样用户可以直接通过resourcemanage\",{\"1\":{\"953\":1}}],[\"这样能够充分利用每个机器的带宽\",{\"1\":{\"898\":1}}],[\"这样连接建立到连接断开之间就是消息的边界\",{\"1\":{\"695\":1}}],[\"这样可将用户程序的任一页放入任一物理块中\",{\"1\":{\"683\":1}}],[\"这样可以明显减少系统资源的浪费\",{\"1\":{\"1042\":1}}],[\"这样可以节省内存空间\",{\"1\":{\"663\":1}}],[\"这样可以保证获得最低的缺页率\",{\"1\":{\"690\":1}}],[\"这样可以保证对java核心源代码的保护\",{\"1\":{\"624\":1}}],[\"这样可以保证系统的稳定性和安全性\",{\"1\":{\"158\":1}}],[\"这样可以更快地对指定分区数据进行查询\",{\"1\":{\"236\":1}}],[\"这样会性能数据会更准确些\",{\"1\":{\"1021\":1}}],[\"这样会使得用户空间和内核空间在传递该结构时复制开销大\",{\"1\":{\"680\":1}}],[\"这样会导致性能相对较差\",{\"1\":{\"453\":1}}],[\"这样会导致性能非常差\",{\"1\":{\"446\":1}}],[\"这样会导致死锁\",{\"1\":{\"175\":1}}],[\"这样所带来的缺点是\",{\"1\":{\"680\":1}}],[\"这样一来\",{\"1\":{\"663\":1}}],[\"这样一个真正可用的对象才算完全创建出来\",{\"1\":{\"630\":1}}],[\"这样在用户空间和内核空间的copy只需一次\",{\"1\":{\"680\":1}}],[\"这样在对字符串做修改操作的时候\",{\"1\":{\"663\":1}}],[\"这样在修改字符串的时候\",{\"1\":{\"663\":1}}],[\"这样获取字符串长度的时候\",{\"1\":{\"663\":1}}],[\"这样申请一个\",{\"1\":{\"658\":1}}],[\"这样加锁的好处是对于链表头节点加锁\",{\"1\":{\"579\":1}}],[\"这样它们在累加时操作的不同的\",{\"1\":{\"564\":1}}],[\"这样当客户端要查找某个key时\",{\"1\":{\"528\":1}}],[\"这样对cpu友好\",{\"1\":{\"520\":1}}],[\"这样uuid就是有序的uuid了\",{\"1\":{\"502\":1}}],[\"这样也可以较少的建立一些索引\",{\"1\":{\"493\":1}}],[\"这样也就解除了和coffee实现类的耦合\",{\"1\":{\"28\":1}}],[\"这样降低了数据的维护速度\",{\"1\":{\"485\":1}}],[\"这样相同的单词肯定是紧挨着的\",{\"1\":{\"478\":1}}],[\"这样的操作\",{\"1\":{\"1155\":1}}],[\"这样的我们可以防止死锁\",{\"1\":{\"1149\":1}}],[\"这样的代码中\",{\"1\":{\"1149\":1}}],[\"这样的代码可实现共享\",{\"1\":{\"187\":1}}],[\"这样的话\",{\"1\":{\"1102\":1}}],[\"这样的话每个索引总共就有2个分片\",{\"1\":{\"1067\":1}}],[\"这样的话就可以保证多线程同时访问的线程安全问题\",{\"1\":{\"579\":1}}],[\"这样的多路复用\",{\"1\":{\"795\":1}}],[\"这样的好处是可以提高查询速度\",{\"1\":{\"1061\":1}}],[\"这样的好处是\",{\"1\":{\"663\":1}}],[\"这样的效率会更高\",{\"1\":{\"455\":1}}],[\"这样写更好\",{\"1\":{\"307\":1}}],[\"这样留下的空闲区就不会太小\",{\"1\":{\"183\":1}}],[\"这样做的目的是提高内存的利用率和系统吞吐量\",{\"1\":{\"164\":1}}],[\"这样做确实简化了系统结构\",{\"1\":{\"14\":1}}],[\"这样多次调用objectinputstream类中的readobject方法\",{\"1\":{\"69\":1}}],[\"这样不仅能确保线程安全\",{\"1\":{\"66\":1}}],[\"这样\",{\"1\":{\"61\":1,\"663\":1,\"688\":1,\"1042\":1,\"1123\":1,\"1223\":1}}],[\"这样就屏蔽了数据库的影响\",{\"1\":{\"1499\":1}}],[\"这样就会导致我们的程序执行得很慢\",{\"1\":{\"1155\":1}}],[\"这样就可以实现拿锁\",{\"1\":{\"1146\":1}}],[\"这样就能保证事务的特性\",{\"1\":{\"1137\":1}}],[\"这样就能确保在给定的时间里\",{\"1\":{\"508\":1}}],[\"这样就不会达到等待统计两个线程运行结束的预期了\",{\"1\":{\"593\":1}}],[\"这样就不会产生循环等待\",{\"1\":{\"176\":1}}],[\"这样就避免了reduce\",{\"1\":{\"470\":1}}],[\"这样就形成了最早的\",{\"1\":{\"182\":1}}],[\"这样就降低了客户与实现模块间的耦合\",{\"1\":{\"74\":1}}],[\"这样就降低了客户代码修改的可能性\",{\"1\":{\"29\":1}}],[\"这样就实现了懒加载的效果\",{\"1\":{\"66\":1}}],[\"这样就解决了简单工厂模式的缺点\",{\"1\":{\"34\":1}}],[\"这样以后就避免了修改客户代码\",{\"1\":{\"29\":1}}],[\"这样只需要修改工厂类的代码\",{\"1\":{\"28\":1}}],[\"这样使得我们的插头在当地能使用\",{\"1\":{\"4\":1}}],[\"这个注解时spring\",{\"1\":{\"1525\":1}}],[\"这个注解可以标注在类或者方法上\",{\"1\":{\"1515\":1}}],[\"这个自动配置类提供\",{\"1\":{\"1438\":1}}],[\"这个地址\",{\"1\":{\"1411\":1}}],[\"这个地方就需要使用到我们的\",{\"1\":{\"1171\":1}}],[\"这个地方说的可见性并不是并发编程中指的内存可见性\",{\"1\":{\"1140\":1}}],[\"这个后处理器配置错误页面地址\",{\"1\":{\"1411\":1}}],[\"这个高层转换接口\",{\"1\":{\"1370\":1}}],[\"这个视频中没有展示\",{\"1\":{\"1243\":1}}],[\"这个代码咱们就不再解释啦\",{\"1\":{\"1224\":1}}],[\"这个格式并非固定\",{\"1\":{\"1207\":1}}],[\"这个很容易\",{\"1\":{\"1175\":1}}],[\"这个值会作为下一次查询的条件\",{\"1\":{\"1168\":1}}],[\"这个需求\",{\"1\":{\"1166\":1}}],[\"这个用户发了动态\",{\"1\":{\"1166\":1}}],[\"这个页面会发起两个请求\",{\"1\":{\"1165\":1}}],[\"这个时间是用需要加锁的个数\",{\"1\":{\"1153\":1}}],[\"这个时候用户进程再调用read操作\",{\"1\":{\"679\":1}}],[\"这个时候就需要提出新的解决方案了\",{\"1\":{\"372\":1}}],[\"这个问题我们开始是利用删之前\",{\"1\":{\"1147\":1}}],[\"这个问题直到\",{\"1\":{\"847\":1}}],[\"这个问题直到8\",{\"1\":{\"501\":1}}],[\"这个脚本\",{\"1\":{\"1146\":1}}],[\"这个方法是从常量池中拿到数据\",{\"1\":{\"1137\":1}}],[\"这个方案\",{\"1\":{\"1128\":1}}],[\"这个过期时间并不会直接作用于redis\",{\"1\":{\"1126\":1}}],[\"这个过程没法固定死\",{\"1\":{\"1321\":1}}],[\"这个过程是由master节点完成的\",{\"1\":{\"1068\":1}}],[\"这个过程需要等待\",{\"1\":{\"679\":1}}],[\"这个请求会去访问redis\",{\"1\":{\"1123\":1}}],[\"这个数据穿透了缓存\",{\"1\":{\"1123\":1}}],[\"这个数据应该做什么样的处理\",{\"1\":{\"179\":1}}],[\"这个userdto对象就没有敏感信息了\",{\"1\":{\"1101\":1}}],[\"这个\",{\"1\":{\"1066\":1,\"1177\":1,\"1453\":1,\"1466\":1}}],[\"这个节点上不仅仅只有一个leader\",{\"1\":{\"1050\":1}}],[\"这个pid对用户来说\",{\"1\":{\"1029\":1}}],[\"这个对象kafka生产消息封装了出现的异常\",{\"1\":{\"1025\":1}}],[\"这个根据自身业务进行设定即可\",{\"1\":{\"998\":1}}],[\"这个比例默认是0\",{\"1\":{\"979\":1}}],[\"这个溢写是由单独线程来完成\",{\"1\":{\"979\":1}}],[\"这个从内存往磁盘写数据的过程被称为spill\",{\"1\":{\"979\":1}}],[\"这个主要考察的就是自定义分区的实现\",{\"1\":{\"973\":1}}],[\"这个操作比较重量级\",{\"1\":{\"854\":1}}],[\"这个操作对直接内存代价昂贵\",{\"1\":{\"770\":1}}],[\"这个事件会频繁触发\",{\"1\":{\"844\":1}}],[\"这个设置便被忽略\",{\"1\":{\"726\":1}}],[\"这个限制称之为\",{\"1\":{\"694\":1}}],[\"这个限制使得\",{\"1\":{\"662\":1}}],[\"这个段的数据\",{\"1\":{\"694\":1}}],[\"这个消息是\",{\"1\":{\"693\":1}}],[\"这个图和blocking\",{\"1\":{\"679\":1}}],[\"这个结构体大小计算出来是\",{\"1\":{\"663\":1}}],[\"这个哈希码的作用是确定对象在哈希表中的索引位置\",{\"1\":{\"596\":1}}],[\"这个队列主要用于等待条件的成立\",{\"1\":{\"584\":1}}],[\"这个流程是发生在master节点中的\",{\"1\":{\"529\":1}}],[\"这个命令可能导致redis死循环阻塞\",{\"1\":{\"529\":1}}],[\"这个index级别比较range还低\",{\"1\":{\"481\":1}}],[\"这个目录就是起到覆盖索引的作用\",{\"1\":{\"481\":1}}],[\"这个速度损耗可以忽略\",{\"1\":{\"481\":1,\"493\":1}}],[\"这个小顶堆中的词就是出现频率最高的100词\",{\"1\":{\"477\":1}}],[\"这个程序的大多数的task都已经运行结束了\",{\"1\":{\"462\":1}}],[\"这个文件不是orc文件\",{\"1\":{\"293\":1}}],[\"这个新特性就是\",{\"1\":{\"285\":1}}],[\"这个进程可以是刚刚被暂停执行的进程\",{\"1\":{\"165\":1}}],[\"这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索\",{\"1\":{\"107\":1}}],[\"这个项目作为父工程\",{\"1\":{\"98\":1}}],[\"这个类提供了一种访问其唯一的对象的方式\",{\"1\":{\"64\":1}}],[\"这个例子其实就是典型的代理模式\",{\"1\":{\"58\":1}}],[\"这个就是静态工厂模式\",{\"1\":{\"30\":1}}],[\"这个接口\",{\"1\":{\"13\":1}}],[\"这个模式适用于\",{\"1\":{\"12\":1}}],[\"桥接模式将接口部分和实现部分分离\",{\"1\":{\"10\":1}}],[\"桥接\",{\"0\":{\"10\":1}}],[\"v3\",{\"1\":{\"1205\":1,\"1206\":2}}],[\"vm的实现\",{\"1\":{\"628\":1}}],[\"var4\",{\"1\":{\"1135\":1}}],[\"var2\",{\"1\":{\"1135\":2}}],[\"var1\",{\"1\":{\"1135\":2}}],[\"var5\",{\"1\":{\"1135\":6}}],[\"var\",{\"1\":{\"872\":2}}],[\"varchar\",{\"1\":{\"493\":2}}],[\"varchar是可变长字符串\",{\"1\":{\"480\":1}}],[\"valid\",{\"1\":{\"1525\":1}}],[\"validate\",{\"1\":{\"590\":2}}],[\"valsdkf\",{\"1\":{\"1089\":2}}],[\"val2\",{\"1\":{\"332\":2,\"351\":4}}],[\"val1\",{\"1\":{\"332\":2,\"351\":6}}],[\"valules\",{\"1\":{\"286\":1}}],[\"value和\",{\"1\":{\"1525\":1}}],[\"value适用于注入基本类型\",{\"1\":{\"1503\":1}}],[\"value用于注入bean\",{\"1\":{\"1503\":1}}],[\"value的数据库\",{\"1\":{\"1204\":1}}],[\"value支持多种不同数据结构\",{\"1\":{\"1190\":1}}],[\"value对的形式存储\",{\"1\":{\"1182\":1}}],[\"value对的value加起来\",{\"1\":{\"979\":1}}],[\"valueat\",{\"1\":{\"1176\":1}}],[\"value不想写死\",{\"1\":{\"1146\":1}}],[\"value键值对的方式\",{\"1\":{\"1105\":1}}],[\"value键值对存储的\",{\"1\":{\"1023\":1}}],[\"value数据中\",{\"1\":{\"1056\":1}}],[\"value数据类型\",{\"1\":{\"972\":2,\"973\":2,\"974\":2}}],[\"valuebytes\",{\"1\":{\"1035\":1}}],[\"value之间以制表符\",{\"1\":{\"980\":1}}],[\"value表示这一行文本内容\",{\"1\":{\"979\":1}}],[\"value是本行的文本内容\",{\"1\":{\"965\":1}}],[\"value是该词出现的频率\",{\"1\":{\"477\":1}}],[\"value类型\",{\"1\":{\"962\":4,\"985\":1,\"986\":2,\"988\":2,\"991\":4}}],[\"valueout为单词个数longwritable\",{\"1\":{\"961\":1}}],[\"valueout\",{\"1\":{\"959\":1,\"961\":1}}],[\"valueof\",{\"1\":{\"723\":1,\"795\":2,\"1023\":1,\"1025\":1,\"1142\":1,\"1156\":3,\"1157\":1,\"1161\":1,\"1162\":1,\"1165\":3,\"1168\":1,\"1172\":1}}],[\"valuein\",{\"1\":{\"959\":1,\"961\":1}}],[\"value进行对比\",{\"1\":{\"601\":1}}],[\"value也就是entry对象进行回收\",{\"1\":{\"577\":1}}],[\"value2\",{\"1\":{\"460\":2}}],[\"value1\",{\"1\":{\"380\":2,\"460\":2}}],[\"value等\",{\"1\":{\"358\":1}}],[\"valuefalseornull\",{\"1\":{\"340\":1}}],[\"valuetrue\",{\"1\":{\"340\":1}}],[\"values\",{\"1\":{\"268\":1,\"298\":1,\"339\":3,\"351\":1,\"723\":2,\"960\":2,\"972\":2,\"973\":2,\"974\":2,\"986\":2,\"988\":4,\"1180\":3,\"1451\":1}}],[\"value\",{\"0\":{\"1481\":1,\"1483\":1},\"1\":{\"251\":1,\"278\":1,\"279\":2,\"326\":1,\"339\":1,\"340\":2,\"346\":1,\"365\":8,\"373\":2,\"566\":5,\"574\":2,\"579\":9,\"701\":2,\"723\":6,\"772\":9,\"773\":1,\"840\":1,\"958\":2,\"960\":2,\"968\":2,\"972\":5,\"973\":7,\"974\":3,\"983\":2,\"985\":2,\"986\":4,\"988\":11,\"990\":4,\"1023\":3,\"1024\":5,\"1035\":1,\"1129\":6,\"1155\":1,\"1162\":1,\"1165\":1,\"1168\":1,\"1171\":3,\"1172\":3,\"1190\":1,\"1206\":2,\"1207\":1,\"1208\":1,\"1252\":1,\"1254\":1,\"1264\":2,\"1267\":1,\"1297\":1,\"1355\":1,\"1362\":1,\"1446\":1,\"1482\":1,\"1485\":1,\"1489\":1,\"1505\":1,\"1525\":3,\"1526\":1,\"1531\":2}}],[\"value>键值对\",{\"1\":{\"986\":1}}],[\"value>对\",{\"1\":{\"965\":1}}],[\"value>\",{\"1\":{\"250\":2,\"872\":2,\"879\":1,\"910\":2,\"919\":1,\"926\":1,\"927\":4,\"936\":6,\"965\":1,\"979\":2}}],[\"val\",{\"1\":{\"17\":8,\"326\":18,\"579\":7,\"669\":4,\"673\":5}}],[\"verify\",{\"1\":{\"1223\":1}}],[\"version的内容是2\",{\"1\":{\"293\":1}}],[\"version=\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"version\",{\"1\":{\"99\":1,\"105\":5,\"112\":4,\"343\":1,\"713\":2,\"714\":2,\"723\":2,\"1236\":2}}],[\"version>3\",{\"1\":{\"1236\":1}}],[\"version>1\",{\"1\":{\"1219\":1}}],[\"version>5\",{\"1\":{\"112\":1}}],[\"version>2\",{\"1\":{\"112\":2}}],[\"version>6\",{\"1\":{\"112\":1}}],[\"version>4\",{\"1\":{\"99\":1}}],[\"version>\",{\"1\":{\"60\":1,\"98\":1,\"99\":3,\"101\":1,\"102\":1,\"104\":2,\"105\":1,\"107\":8,\"108\":1,\"112\":10,\"113\":1,\"114\":2,\"115\":2,\"344\":3,\"783\":1,\"957\":7,\"985\":2,\"1022\":6,\"1070\":6,\"1087\":1,\"1150\":1,\"1172\":2,\"1213\":2,\"1219\":3,\"1236\":3,\"1466\":1}}],[\"vecnode\",{\"1\":{\"669\":9}}],[\"vec\",{\"1\":{\"669\":7}}],[\"vector<treenode\",{\"1\":{\"669\":1}}],[\"vector<int>\",{\"1\":{\"669\":2}}],[\"vectorized\",{\"1\":{\"438\":2}}],[\"v>键值对\",{\"1\":{\"985\":1}}],[\"v>\",{\"1\":{\"339\":3,\"579\":22,\"1113\":3}}],[\"v1\",{\"1\":{\"318\":1,\"340\":1,\"380\":1,\"962\":4,\"1046\":1,\"1205\":1,\"1206\":2}}],[\"v2>\",{\"1\":{\"968\":2}}],[\"v2<\",{\"1\":{\"957\":1}}],[\"v2\",{\"1\":{\"271\":1,\"340\":1,\"962\":5,\"968\":1,\"1205\":1,\"1206\":2}}],[\"vs\",{\"0\":{\"769\":1,\"770\":1,\"825\":1,\"849\":1,\"850\":1},\"1\":{\"179\":1,\"766\":1,\"792\":2,\"851\":1}}],[\"v必须成对的出现\",{\"1\":{\"172\":1}}],[\"v操作\",{\"1\":{\"162\":1,\"171\":2}}],[\"v=mpu2histivi\",{\"1\":{\"144\":1}}],[\"vi\",{\"1\":{\"1197\":1}}],[\"visitor\",{\"1\":{\"1179\":1}}],[\"visitfile\",{\"1\":{\"822\":6}}],[\"vim\",{\"1\":{\"878\":5,\"1012\":2,\"1046\":3}}],[\"vimeo\",{\"1\":{\"132\":1}}],[\"vinkgin\",{\"1\":{\"285\":1,\"936\":1}}],[\"vinngkin\",{\"1\":{\"281\":1}}],[\"vingkin\",{\"1\":{\"234\":1,\"235\":1,\"236\":1,\"237\":2,\"266\":1,\"268\":1,\"279\":1,\"280\":1,\"281\":3,\"298\":1,\"330\":8,\"336\":4,\"340\":2,\"344\":1,\"519\":2,\"648\":2,\"914\":7,\"926\":6,\"957\":1,\"962\":4,\"972\":1,\"973\":1,\"974\":2,\"983\":2,\"985\":1,\"986\":1,\"989\":1,\"990\":1,\"991\":4,\"1088\":1,\"1230\":1,\"1232\":1}}],[\"viewreslover解析后返回具体view\",{\"1\":{\"1530\":1}}],[\"viewresolver\",{\"1\":{\"1416\":2,\"1438\":1}}],[\"view代表的是用户界面\",{\"1\":{\"1528\":1}}],[\"view来使用\",{\"1\":{\"396\":1}}],[\"view配套使用\",{\"1\":{\"376\":1,\"378\":1}}],[\"view使用\",{\"1\":{\"349\":1}}],[\"view是一种特殊的语法\",{\"1\":{\"349\":1}}],[\"view侧视图\",{\"1\":{\"348\":1,\"349\":1}}],[\"views物化视图\",{\"0\":{\"273\":1}}],[\"views\",{\"1\":{\"271\":1,\"276\":3}}],[\"view\",{\"0\":{\"269\":1,\"349\":1},\"1\":{\"270\":1,\"271\":9,\"272\":2,\"276\":13,\"318\":3,\"348\":1,\"349\":2,\"378\":2,\"391\":1,\"396\":1,\"1179\":1,\"1411\":2,\"1416\":3,\"1441\":2,\"1528\":1}}],[\"video\",{\"1\":{\"117\":2,\"120\":1,\"125\":1,\"127\":1,\"131\":1}}],[\"voucherorderhandler\",{\"1\":{\"1157\":2}}],[\"voucherorder\",{\"1\":{\"1134\":7,\"1137\":21,\"1157\":20}}],[\"voucherorderserviceimpl\",{\"1\":{\"1134\":1,\"1136\":1,\"1137\":1,\"1150\":1,\"1156\":1,\"1157\":1}}],[\"voucherid\",{\"1\":{\"1134\":4,\"1135\":1,\"1136\":2,\"1137\":15,\"1142\":3,\"1150\":3,\"1156\":5,\"1157\":3}}],[\"voucherserviceimpl\",{\"1\":{\"1133\":1,\"1156\":1}}],[\"voucherservice\",{\"1\":{\"1133\":2}}],[\"vouchercontroller\",{\"1\":{\"1133\":2}}],[\"voucher\",{\"1\":{\"1100\":1,\"1131\":1,\"1133\":19,\"1134\":1,\"1135\":2,\"1136\":3,\"1137\":10,\"1156\":9,\"1157\":2}}],[\"vocation\",{\"1\":{\"619\":1}}],[\"volatile的有序性是通过插入内存屏障来保证指令按照顺序执行\",{\"1\":{\"559\":1}}],[\"volatile的底层实现原理是内存屏障\",{\"1\":{\"557\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"558\":1}}],[\"volatile关键字只能修饰变量\",{\"1\":{\"558\":1}}],[\"volatile和synchronized在有序性上的不同\",{\"0\":{\"559\":1}}],[\"volatile和synchronized\",{\"0\":{\"558\":1}}],[\"volatile原理\",{\"0\":{\"557\":1}}],[\"volatile\",{\"1\":{\"22\":1,\"66\":4,\"68\":1,\"69\":1,\"522\":4,\"555\":2,\"564\":3,\"579\":3,\"726\":1,\"846\":2,\"1151\":1}}],[\"voidpromise\",{\"1\":{\"725\":1,\"742\":1,\"743\":1}}],[\"void\",{\"1\":{\"6\":6,\"7\":2,\"14\":12,\"17\":6,\"23\":4,\"34\":2,\"43\":1,\"47\":9,\"51\":1,\"52\":3,\"54\":6,\"58\":4,\"59\":6,\"60\":2,\"68\":3,\"70\":1,\"73\":1,\"74\":12,\"75\":8,\"76\":5,\"81\":7,\"85\":11,\"248\":2,\"344\":1,\"373\":1,\"536\":4,\"541\":1,\"551\":1,\"554\":9,\"555\":9,\"562\":1,\"585\":4,\"590\":2,\"614\":2,\"617\":1,\"645\":2,\"646\":1,\"648\":2,\"668\":2,\"669\":2,\"671\":2,\"673\":2,\"692\":8,\"696\":4,\"697\":3,\"698\":3,\"699\":3,\"701\":3,\"702\":7,\"703\":2,\"704\":5,\"705\":2,\"707\":2,\"710\":5,\"711\":3,\"713\":2,\"714\":2,\"716\":7,\"717\":5,\"718\":9,\"723\":2,\"725\":3,\"726\":2,\"733\":4,\"734\":1,\"735\":2,\"736\":1,\"737\":3,\"738\":1,\"740\":14,\"741\":5,\"742\":3,\"743\":8,\"744\":1,\"748\":7,\"749\":2,\"753\":5,\"754\":3,\"758\":1,\"766\":9,\"768\":1,\"775\":2,\"776\":1,\"784\":2,\"785\":1,\"794\":4,\"795\":2,\"796\":1,\"799\":4,\"809\":2,\"820\":1,\"822\":1,\"834\":2,\"836\":1,\"839\":2,\"840\":2,\"843\":2,\"846\":5,\"848\":2,\"857\":3,\"859\":8,\"958\":1,\"960\":1,\"962\":2,\"968\":1,\"972\":6,\"973\":3,\"974\":6,\"983\":1,\"985\":7,\"986\":3,\"988\":6,\"990\":2,\"991\":1,\"999\":1,\"1023\":1,\"1024\":1,\"1025\":1,\"1035\":2,\"1071\":2,\"1089\":10,\"1100\":1,\"1101\":2,\"1111\":1,\"1127\":1,\"1128\":2,\"1129\":3,\"1132\":1,\"1133\":1,\"1142\":2,\"1144\":1,\"1147\":1,\"1150\":1,\"1152\":2,\"1156\":1,\"1157\":4,\"1160\":1,\"1161\":1,\"1162\":1,\"1171\":1,\"1180\":1,\"1213\":4,\"1216\":2,\"1221\":1,\"1223\":2,\"1224\":1,\"1234\":1,\"1244\":1,\"1257\":3,\"1285\":2,\"1294\":2,\"1304\":3,\"1306\":2,\"1309\":4,\"1317\":1,\"1416\":1,\"1449\":2,\"1451\":1,\"1505\":1}}],[\"v\",{\"0\":{\"10\":3},\"1\":{\"271\":9,\"567\":1,\"579\":6,\"621\":2,\"648\":19,\"649\":7,\"808\":1}}],[\"代价是一个代理类配两个\",{\"1\":{\"1321\":1}}],[\"代金券id\",{\"1\":{\"1134\":1,\"1137\":3,\"1157\":1}}],[\"代表这个方法将启用事务功能\",{\"1\":{\"1515\":1}}],[\"代表着各类所有公共\",{\"1\":{\"1515\":1}}],[\"代表着整体中某一段的数据\",{\"1\":{\"779\":1}}],[\"代表环绕通知\",{\"1\":{\"1322\":1}}],[\"代表只使用1个库\",{\"1\":{\"1196\":1}}],[\"代表地理坐标\",{\"1\":{\"1170\":1}}],[\"代表没有购买资格\",{\"1\":{\"1157\":1}}],[\"代表每毫秒内可产生最大序列号\",{\"1\":{\"999\":1}}],[\"代表另一个用户提交作业或访问hdfs\",{\"1\":{\"927\":1}}],[\"代表实际写入字节数\",{\"1\":{\"843\":1}}],[\"代表了上一级路径\",{\"1\":{\"821\":1}}],[\"代表了当前路径\",{\"1\":{\"821\":1}}],[\"代表了\",{\"1\":{\"821\":2}}],[\"代表关注\",{\"1\":{\"740\":1}}],[\"代售点\",{\"1\":{\"58\":1}}],[\"代售点是代理对象\",{\"1\":{\"58\":1}}],[\"代码参考项目\",{\"1\":{\"1299\":1,\"1301\":1}}],[\"代码参考\",{\"0\":{\"1242\":1,\"1247\":1,\"1250\":1,\"1254\":1,\"1259\":1,\"1263\":1,\"1266\":1,\"1270\":1,\"1273\":1,\"1276\":1,\"1279\":1,\"1283\":1,\"1288\":1,\"1292\":1,\"1296\":1,\"1312\":1,\"1316\":1,\"1320\":1,\"1324\":1,\"1328\":1,\"1332\":1,\"1335\":1,\"1338\":1,\"1342\":1,\"1345\":1,\"1349\":1,\"1354\":1,\"1357\":1,\"1361\":1,\"1365\":1,\"1372\":1,\"1375\":1,\"1378\":1,\"1389\":1,\"1393\":1,\"1397\":1,\"1401\":1,\"1405\":1,\"1409\":1,\"1428\":1,\"1471\":1,\"1475\":1,\"1479\":1,\"1484\":1,\"1488\":1,\"1492\":1,\"1496\":1}}],[\"代码说明\",{\"1\":{\"1215\":1,\"1216\":1}}],[\"代码走到这里\",{\"1\":{\"1151\":1}}],[\"代码分析\",{\"1\":{\"1122\":1}}],[\"代码思路\",{\"1\":{\"1118\":1}}],[\"代码解读\",{\"1\":{\"784\":1,\"785\":1}}],[\"代码略\",{\"1\":{\"741\":2}}],[\"代码改为\",{\"1\":{\"693\":1}}],[\"代码模板\",{\"0\":{\"641\":1}}],[\"代码模拟stampedlock读和写的过程\",{\"1\":{\"590\":1}}],[\"代码中创建了大量大对象\",{\"1\":{\"636\":1}}],[\"代码演示\",{\"1\":{\"551\":1}}],[\"代码\",{\"0\":{\"133\":1,\"1111\":1},\"1\":{\"131\":1,\"787\":1,\"821\":1,\"1171\":1,\"1175\":1,\"1176\":1}}],[\"代码复现\",{\"0\":{\"121\":1,\"128\":1,\"146\":1}}],[\"代码实战\",{\"1\":{\"117\":1}}],[\"代码我们只需要修改computer类\",{\"1\":{\"74\":1}}],[\"代码的可读性及使用的成本就是比较高\",{\"1\":{\"17\":1}}],[\"代码可读性会非常差\",{\"1\":{\"17\":1}}],[\"代码结构相似\",{\"1\":{\"10\":1}}],[\"代码如下所示\",{\"1\":{\"663\":1}}],[\"代码如下\",{\"0\":{\"1118\":1},\"1\":{\"6\":1,\"7\":1,\"30\":1,\"34\":1,\"39\":1,\"51\":1,\"52\":1,\"54\":2,\"58\":1,\"59\":1,\"60\":1,\"74\":1,\"75\":1,\"76\":1,\"85\":1,\"1222\":1}}],[\"代理增强\",{\"1\":{\"1505\":1}}],[\"代理增强是借助多态来实现\",{\"1\":{\"1310\":1}}],[\"代理与目标是两个对象\",{\"1\":{\"1480\":1}}],[\"代理的设计特点\",{\"1\":{\"1480\":1}}],[\"代理的创建时机\",{\"1\":{\"1336\":1}}],[\"代理进一步理解\",{\"0\":{\"1477\":1}}],[\"代理进阶\",{\"0\":{\"1314\":1}}],[\"代理方法执行时会做如下工作\",{\"1\":{\"1343\":1}}],[\"代理创建时机\",{\"0\":{\"1334\":1}}],[\"代理创建器\",{\"0\":{\"1331\":1}}],[\"代理相关类图\",{\"1\":{\"1322\":1}}],[\"代理一点都不难\",{\"1\":{\"1310\":1}}],[\"代理服务器再把它转给你的浏览器\",{\"1\":{\"63\":1}}],[\"代理类中还得增加仅调用\",{\"1\":{\"1321\":1}}],[\"代理类的源码\",{\"1\":{\"1309\":1}}],[\"代理类$proxy0\",{\"1\":{\"1309\":1}}],[\"代理类\",{\"1\":{\"59\":3}}],[\"代理对象调用流程如下\",{\"1\":{\"1340\":1}}],[\"代理对象调用接口方法时传递的实际参数\",{\"1\":{\"59\":1}}],[\"代理对象虽然还是同一个\",{\"1\":{\"1294\":1}}],[\"代理对象可以扩展目标对象的功能\",{\"1\":{\"62\":1}}],[\"代理对象中的方法的method实例\",{\"1\":{\"60\":1}}],[\"代理对象\",{\"1\":{\"59\":1,\"60\":1,\"1304\":1,\"1306\":1}}],[\"代理对象的调用处理程序\",{\"1\":{\"59\":1}}],[\"代理对象作为访问对象和目标对象之间的中介\",{\"1\":{\"56\":1}}],[\"代理工厂类\",{\"1\":{\"59\":1}}],[\"代理工厂\",{\"1\":{\"59\":1,\"60\":1}}],[\"代理点收取一些服务费用\",{\"1\":{\"58\":2,\"59\":2,\"60\":1}}],[\"代理模式能将客户端与目标对象分离\",{\"1\":{\"62\":1}}],[\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用\",{\"1\":{\"62\":1}}],[\"代理模式真实对象和代理对象实现相同的接口\",{\"1\":{\"59\":1}}],[\"代理模式\",{\"0\":{\"55\":1}}],[\"代理模式不改变原始类接口的条件下\",{\"1\":{\"10\":1}}],[\"代理\",{\"0\":{\"10\":1,\"1306\":1,\"1315\":1,\"1478\":1},\"1\":{\"57\":2,\"63\":3,\"737\":1,\"1325\":1}}],[\"从三个方法中选择合适的方法\",{\"1\":{\"1532\":1}}],[\"从源码得知\",{\"1\":{\"1525\":1}}],[\"从本质上来说\",{\"1\":{\"1520\":1}}],[\"从配置中获取重要的事件发布器\",{\"1\":{\"1446\":1}}],[\"从输出日志可以看到调用\",{\"1\":{\"1294\":1}}],[\"从磁盘路径查找\",{\"1\":{\"1245\":1}}],[\"从磁盘读出或向磁盘写入数据所经历的时间\",{\"1\":{\"204\":1}}],[\"从类路径查找\",{\"1\":{\"1245\":1}}],[\"从最后一次签到开始向前统计\",{\"1\":{\"1176\":1}}],[\"从表结构上也能看出\",{\"1\":{\"1133\":1}}],[\"从表层来看\",{\"1\":{\"9\":1}}],[\"从redis查询商铺缓存\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":3}}],[\"从redis获取验证码并校验\",{\"1\":{\"1107\":1}}],[\"从redis中取出token对应的value\",{\"1\":{\"1106\":1}}],[\"从resultset读取查询结果\",{\"1\":{\"985\":1}}],[\"从分布式缓存文件中加载我们的内容\",{\"1\":{\"990\":1}}],[\"从程序的上下文环境中获取全局计数器\",{\"1\":{\"983\":1}}],[\"从3\",{\"1\":{\"883\":1}}],[\"从namenode节点复制hadoop安装包到新节点\",{\"1\":{\"878\":1}}],[\"从内核态切换回用户态\",{\"1\":{\"854\":1}}],[\"从\",{\"0\":{\"803\":1,\"1017\":1,\"1330\":1},\"1\":{\"797\":1,\"840\":2,\"1026\":1,\"1042\":1,\"1340\":1}}],[\"从尾部开始查找出站处理器\",{\"1\":{\"766\":1}}],[\"从尾部开始触发\",{\"1\":{\"766\":1}}],[\"从tail向上找出站处理器\",{\"1\":{\"766\":1}}],[\"从当前位置向上找出站处理器\",{\"1\":{\"766\":1}}],[\"从当前位置开始扫描到第一个\",{\"1\":{\"191\":1}}],[\"从进程发出指定逻辑地址的访问请求\",{\"1\":{\"683\":1}}],[\"从kernel的角度\",{\"1\":{\"679\":1}}],[\"从用户进程角度讲\",{\"1\":{\"679\":1}}],[\"从任何主机访问的名为root的用户都可以假冒属于任何组的任何用户\",{\"1\":{\"927\":1}}],[\"从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点\",{\"1\":{\"656\":1}}],[\"从任务管理器可以看出操作系统对硬件和软件资源的分配\",{\"1\":{\"153\":1}}],[\"从每个叶子到根的所有路径上不能有两个连续的红节点\",{\"1\":{\"656\":1}}],[\"从数学角度推导\",{\"1\":{\"649\":1}}],[\"从数据集中任意选择数据淘汰\",{\"1\":{\"522\":1}}],[\"从0开始\",{\"1\":{\"644\":1,\"985\":1}}],[\"从虚拟机的角度来看\",{\"1\":{\"630\":1}}],[\"从文件中\",{\"1\":{\"629\":1}}],[\"从文件中读取对象\",{\"1\":{\"68\":1}}],[\"从流中排除某些元素\",{\"1\":{\"616\":1}}],[\"从jdk1\",{\"1\":{\"610\":1}}],[\"从右向左迁移bin\",{\"1\":{\"579\":1}}],[\"从已设置过期时间的数据集中挑选最不经常使用的数据淘汰\",{\"1\":{\"522\":1}}],[\"从已设置过期时间的数据集中挑选即将要过期的数据淘汰\",{\"1\":{\"522\":1}}],[\"从已设置过期时间的数据集中任意选择数据淘汰\",{\"1\":{\"522\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"522\":1}}],[\"从已有视图创建新视图\",{\"1\":{\"271\":1}}],[\"从性能上来说\",{\"1\":{\"504\":1}}],[\"从物理实现方式\",{\"1\":{\"492\":1}}],[\"从功能逻辑上说\",{\"1\":{\"492\":1}}],[\"从第一行聚合到当前行\",{\"1\":{\"361\":1}}],[\"从该维度进行层级聚合\",{\"1\":{\"352\":1}}],[\"从source\",{\"1\":{\"809\":1}}],[\"从slave角度来看\",{\"1\":{\"530\":1}}],[\"从sql层面上来说上述问题的解决方案是\",{\"1\":{\"348\":1}}],[\"从student表中select数据insert到student\",{\"1\":{\"287\":1}}],[\"从效果上来看有点像inner\",{\"1\":{\"324\":1}}],[\"从hdfs中删除某些内容时\",{\"1\":{\"909\":1}}],[\"从hdfs的角度来看就是文件夹下继续划分文件夹\",{\"1\":{\"262\":1}}],[\"从hive\",{\"1\":{\"474\":1}}],[\"从hive2\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"从何处调入页面\",{\"1\":{\"192\":1}}],[\"从逻辑上扩充了内存的容量\",{\"1\":{\"189\":1}}],[\"从中找到一个满足条件的分区\",{\"1\":{\"182\":1}}],[\"从写程序到程序运行\",{\"1\":{\"179\":1}}],[\"从作业被提交到系统开始\",{\"1\":{\"166\":1}}],[\"从就绪队列中按照一定的算法选中一个进程并将处理机分配给它运行\",{\"1\":{\"164\":1}}],[\"从pcb恢复运行环境\",{\"1\":{\"161\":1}}],[\"从下往上看\",{\"1\":{\"153\":1,\"154\":1}}],[\"从父类继承而来的实现是静态的\",{\"1\":{\"77\":1}}],[\"从硬盘中获取的数据为\",{\"1\":{\"74\":1}}],[\"从而将相关bean加入到ioc容器中\",{\"1\":{\"1502\":1}}],[\"从而将单个文件分成多个文件\",{\"1\":{\"263\":1}}],[\"从而节约我们的内存空间\",{\"1\":{\"1223\":1}}],[\"从而使用户能够更加的节约时间\",{\"1\":{\"1166\":1}}],[\"从而影响业务\",{\"1\":{\"1120\":1}}],[\"从而可以在任务失败时重新启动任务\",{\"1\":{\"953\":1}}],[\"从而可以构造出复杂的对象\",{\"1\":{\"12\":1}}],[\"从而避免对于数据库访问压力过大\",{\"1\":{\"1126\":1}}],[\"从而避免对原始数据的破坏\",{\"1\":{\"912\":1}}],[\"从而避免数据库和缓存不一致的问题\",{\"1\":{\"1122\":1}}],[\"从而避免了长作业饥饿问题\",{\"1\":{\"167\":1}}],[\"从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题\",{\"1\":{\"97\":1}}],[\"从而确保整体应用是在正常有序的状态下退出的\",{\"1\":{\"747\":1}}],[\"从而回调\",{\"1\":{\"740\":1}}],[\"从而会形成碎片\",{\"1\":{\"683\":1}}],[\"从而引起\",{\"1\":{\"666\":1}}],[\"从而引发错误\",{\"1\":{\"101\":1}}],[\"从而有效节省内存空间\",{\"1\":{\"663\":1}}],[\"从而出现内存泄漏\",{\"1\":{\"577\":1}}],[\"从而提高性能\",{\"1\":{\"564\":1}}],[\"从而提高软件开发效率\",{\"1\":{\"71\":1}}],[\"从而保证数据操作的排他性\",{\"1\":{\"507\":1}}],[\"从而满足了持久性要求\",{\"1\":{\"506\":1}}],[\"从而判断数据对该readview是否可见\",{\"1\":{\"503\":1}}],[\"从而形成一条版本链\",{\"1\":{\"503\":1}}],[\"从而很方便的实现了进程互斥\",{\"1\":{\"171\":1}}],[\"从而无法下载依赖\",{\"1\":{\"101\":1}}],[\"从上往下看\",{\"1\":{\"153\":1,\"154\":1}}],[\"从上面看\",{\"1\":{\"680\":1}}],[\"从上面类图我们可以看到使用继承复用产生了很多子类\",{\"1\":{\"77\":1}}],[\"从上面源代码中可以看出runtime类使用的是饿汉式\",{\"1\":{\"70\":1}}],[\"从上面代码可以看到\",{\"1\":{\"88\":1}}],[\"从上面代码我们可以看出\",{\"1\":{\"66\":1}}],[\"从上面代码我们可以看出该方式在成员位置声明singleton类型的静态变量\",{\"1\":{\"66\":1}}],[\"从上面代码中可以看出测试类直接访问的是proxypoint类对象\",{\"1\":{\"58\":1}}],[\"从上面的类中\",{\"1\":{\"59\":1}}],[\"从上图可以看出\",{\"1\":{\"9\":1}}],[\"从以上的编写的代码可以看到\",{\"1\":{\"34\":1}}],[\"从软件设计上\",{\"1\":{\"17\":1}}],[\"是我们存在于时间之内\",{\"1\":{\"1525\":1}}],[\"是使用\",{\"1\":{\"1515\":1}}],[\"是beanfactory的子接口\",{\"1\":{\"1501\":1}}],[\"是ioc的顶层接口\",{\"1\":{\"1501\":1}}],[\"是基础类型的ioc容器\",{\"1\":{\"1501\":1}}],[\"是基于关注的好友来做feed流\",{\"1\":{\"1166\":1}}],[\"是完全异步\",{\"1\":{\"1499\":1}}],[\"是完全由elasticsearch管理的\",{\"1\":{\"1066\":1}}],[\"是其对应对象\",{\"1\":{\"1489\":1}}],[\"是其子类\",{\"1\":{\"72\":1}}],[\"是特殊类型\",{\"1\":{\"1489\":1}}],[\"是后者被\",{\"1\":{\"1455\":1}}],[\"是后一个阶段map的输入\",{\"1\":{\"991\":1}}],[\"是利用了自动配置类来简化了\",{\"1\":{\"1453\":1}}],[\"是这么实现的\",{\"1\":{\"1411\":1}}],[\"是返回值处理器解析的\",{\"1\":{\"1398\":1}}],[\"是反射调用\",{\"1\":{\"1317\":1}}],[\"是多态调用\",{\"1\":{\"1310\":1}}],[\"是rest风格的控制器\",{\"1\":{\"1525\":1}}],[\"是redis中最简单的存储类型\",{\"1\":{\"1206\":1}}],[\"是redis的哨兵启动脚本\",{\"1\":{\"1193\":1}}],[\"是redis的服务端启动脚本\",{\"1\":{\"1193\":1}}],[\"是redis提供的命令行客户端\",{\"1\":{\"1193\":1}}],[\"是regexp\",{\"1\":{\"330\":1}}],[\"是相对于传统关系型数据库而言\",{\"1\":{\"1184\":1}}],[\"是博主与粉丝的关系\",{\"1\":{\"1164\":1}}],[\"是通过\",{\"1\":{\"1157\":1}}],[\"是他本身\",{\"1\":{\"1152\":1}}],[\"是自己的锁\",{\"1\":{\"1151\":1}}],[\"是可以实现互斥的\",{\"1\":{\"1138\":1}}],[\"是可以在一个mapreduce中实现的\",{\"1\":{\"452\":1}}],[\"是预估值\",{\"1\":{\"1135\":1}}],[\"是操作前读取的内存值\",{\"1\":{\"1135\":1}}],[\"是操作系统最基本\",{\"1\":{\"156\":1}}],[\"是阻塞方法\",{\"1\":{\"1132\":1}}],[\"是有不少的leader需要选举\",{\"1\":{\"1050\":1}}],[\"是针对partition的一个角色\",{\"1\":{\"1050\":1}}],[\"是针对broker的一个角色\",{\"1\":{\"1050\":1}}],[\"是要求性能最高\",{\"1\":{\"1043\":1}}],[\"是透明的\",{\"1\":{\"1029\":1}}],[\"是作为临时存储存在的\",{\"1\":{\"1008\":1}}],[\"是正整数\",{\"1\":{\"998\":1}}],[\"是全局唯一性的呢\",{\"1\":{\"997\":1}}],[\"是全双工的\",{\"1\":{\"795\":1}}],[\"是将请求参数绑定到控制器的方法参数上\",{\"1\":{\"1531\":1}}],[\"是将字节流转换为一系列结构化对象的过程\",{\"1\":{\"956\":1}}],[\"是将结构化对象转换成字节流以便于进行网络传输或写入持久存储的过程\",{\"1\":{\"956\":1}}],[\"是根据应用程序的需求动态生成的\",{\"1\":{\"948\":1}}],[\"是yarn\",{\"1\":{\"948\":1}}],[\"是数据存储的某一时刻的状态记录\",{\"1\":{\"911\":1}}],[\"是数据仓库的数据准备区\",{\"1\":{\"225\":1}}],[\"是集群的从角色\",{\"1\":{\"903\":1}}],[\"是namenode之间的federation\",{\"1\":{\"889\":1}}],[\"是hadoop官方推荐的hdfs\",{\"1\":{\"884\":1}}],[\"是datanode和dfsclient之间沟通的socket的本地路径\",{\"1\":{\"872\":1}}],[\"是打开短路本地读取功能的开关\",{\"1\":{\"872\":1}}],[\"是无连接的\",{\"1\":{\"848\":1}}],[\"是普通文件\",{\"1\":{\"823\":1}}],[\"是目录\",{\"1\":{\"823\":1}}],[\"是目前应用较广泛的一种存储管理方式\",{\"1\":{\"683\":1}}],[\"是工具类\",{\"1\":{\"821\":1}}],[\"是因为线程1的拿锁\",{\"1\":{\"1145\":1}}],[\"是因为\",{\"1\":{\"815\":1}}],[\"是非线程安全的\",{\"1\":{\"806\":1}}],[\"是在第一次被访问时执行初始化\",{\"1\":{\"1355\":1}}],[\"是在redis基础上实现了分布式的可伸缩的java数据结构\",{\"1\":{\"1212\":1}}],[\"是在读取时\",{\"1\":{\"804\":1}}],[\"是在查询结果返回集以后对查询结果进行过滤的操作\",{\"1\":{\"504\":1}}],[\"是把未读完的部分向前压缩\",{\"1\":{\"798\":1}}],[\"是写入位置\",{\"1\":{\"798\":1}}],[\"是什么\",{\"0\":{\"789\":1},\"1\":{\"1248\":1}}],[\"是什么意思\",{\"1\":{\"179\":1}}],[\"是接下来添加的处理器都是给\",{\"1\":{\"784\":1}}],[\"是对字节数据的封装\",{\"1\":{\"767\":1}}],[\"是对现实世界数据特征的描述\",{\"1\":{\"233\":1}}],[\"是从loglog算法派生的概率算法\",{\"1\":{\"1179\":1}}],[\"是从原始\",{\"1\":{\"776\":1}}],[\"是从尾部开始查找\",{\"1\":{\"766\":1}}],[\"是从当前节点找上一个出站处理器\",{\"1\":{\"766\":1}}],[\"是按照\",{\"1\":{\"766\":2}}],[\"是原材料\",{\"1\":{\"766\":1}}],[\"是车间中的流水线\",{\"1\":{\"766\":1}}],[\"是让非\",{\"1\":{\"742\":1}}],[\"是登录\",{\"1\":{\"712\":1}}],[\"是中文一句著名的无标点符号句子\",{\"1\":{\"709\":1}}],[\"是最大段长度\",{\"1\":{\"694\":1}}],[\"是最终要引用的对象\",{\"1\":{\"57\":1}}],[\"是流式协议\",{\"1\":{\"694\":1}}],[\"是内存单元真正的地址\",{\"1\":{\"684\":1}}],[\"是物理单位\",{\"1\":{\"683\":1}}],[\"是计算机科学中的一个术语\",{\"1\":{\"677\":1}}],[\"是如何根据数据的大小和类型来进行不同的空间大小分配\",{\"1\":{\"665\":1}}],[\"是如何解决的\",{\"1\":{\"662\":1}}],[\"是则说明字符串结束了\",{\"1\":{\"662\":1}}],[\"是用过zk来进行选举\",{\"1\":{\"1050\":1}}],[\"是用\",{\"1\":{\"661\":1}}],[\"是用软件的方式模拟脱机技术\",{\"1\":{\"212\":1}}],[\"是同步非阻塞的\",{\"1\":{\"610\":1}}],[\"是保证当线程由于页缺失故障\",{\"1\":{\"576\":1}}],[\"是保证编译器优化的时候不会让指令乱序\",{\"1\":{\"559\":1}}],[\"是executor\",{\"1\":{\"574\":1}}],[\"是线程安全的\",{\"1\":{\"560\":1}}],[\"是当事务回滚时能够撤销所有已经成功执行的sql语句\",{\"1\":{\"506\":1}}],[\"是mysql\",{\"1\":{\"495\":1}}],[\"是metastore默认部署模式\",{\"1\":{\"242\":1}}],[\"是不同的接口\",{\"1\":{\"1325\":1}}],[\"是不反射调用\",{\"1\":{\"1317\":1}}],[\"是不是后边的问题都不会发生了\",{\"1\":{\"1147\":1}}],[\"是不保证数据零丢失的\",{\"1\":{\"526\":1}}],[\"是不可能将全部几个g的索引都加载进内存的\",{\"1\":{\"486\":1}}],[\"是不会加载静态内部类的\",{\"1\":{\"66\":1}}],[\"是必须的\",{\"1\":{\"483\":1}}],[\"是以一个staging开头的文件夹维护的\",{\"1\":{\"292\":1}}],[\"是复制操作\",{\"1\":{\"283\":1}}],[\"是科学实验\",{\"1\":{\"263\":1}}],[\"是面向单个部门使用的\",{\"1\":{\"223\":1}}],[\"是面向整个集团组织的数据\",{\"1\":{\"223\":1}}],[\"是转动一圈需要的时间\",{\"1\":{\"204\":1}}],[\"是为了在操作失败时\",{\"1\":{\"1135\":1}}],[\"是为了能灵活保存不同大小的字符串\",{\"1\":{\"663\":1}}],[\"是为了进一步优化读性能\",{\"1\":{\"590\":1}}],[\"是为了解决让权等待问题\",{\"1\":{\"171\":1}}],[\"是为了使程序的扩展性好\",{\"1\":{\"72\":1}}],[\"是双标志先检查法的改良版本\",{\"1\":{\"169\":1}}],[\"是否存在于容器\",{\"1\":{\"1466\":1}}],[\"是否生效\",{\"1\":{\"1454\":1}}],[\"是否可以为null等等\",{\"1\":{\"1182\":1}}],[\"是否可抢占式\",{\"1\":{\"167\":1}}],[\"是否可抢占\",{\"1\":{\"167\":5}}],[\"是否补签\",{\"1\":{\"1174\":1}}],[\"是否大于\",{\"1\":{\"1155\":1}}],[\"是否一致\",{\"1\":{\"1106\":1}}],[\"是否被索引等等\",{\"1\":{\"1065\":1}}],[\"是否成功\",{\"1\":{\"876\":1}}],[\"是否能读写根据构造\",{\"1\":{\"813\":1}}],[\"是否能够传递到\",{\"1\":{\"104\":1}}],[\"是否要继续循环\",{\"1\":{\"744\":1}}],[\"是否保证线程安全\",{\"1\":{\"600\":1}}],[\"是否对\",{\"1\":{\"566\":1}}],[\"是否在metastore实例上运行启动压缩合并\",{\"1\":{\"297\":1,\"298\":1}}],[\"是否在metastore实例上运行启动线程和清理线程\",{\"1\":{\"268\":1,\"276\":1}}],[\"是否重写查询使用物化视图可以通过全局参数控制\",{\"1\":{\"276\":1}}],[\"是否开启\",{\"1\":{\"848\":1}}],[\"是否开启分桶功能\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"是否开启动态分区功能\",{\"1\":{\"261\":1}}],[\"是否为外部表等\",{\"1\":{\"232\":1}}],[\"是否相等\",{\"1\":{\"195\":1}}],[\"是否已分配\",{\"1\":{\"182\":1}}],[\"是否会多扣一笔呢\",{\"1\":{\"1003\":1}}],[\"是否会多扣一次\",{\"1\":{\"1003\":1}}],[\"是否会导致饥饿\",{\"1\":{\"167\":6}}],[\"是否会发生从一个事件到另一个事件转换的时候出现中断\",{\"1\":{\"161\":1}}],[\"是进程最基本的特征\",{\"1\":{\"159\":1}}],[\"是进程实体的运行过程\",{\"1\":{\"159\":1}}],[\"是动态的产生\",{\"1\":{\"159\":1}}],[\"是系统进行资源分配和调度的一个独立单位\",{\"1\":{\"159\":1}}],[\"是系统的管理者\",{\"1\":{\"156\":1}}],[\"是一套标准的代理和服务\",{\"1\":{\"1045\":1}}],[\"是一组\",{\"1\":{\"746\":1}}],[\"是一个基于内存的键值型nosql数据库\",{\"1\":{\"1190\":1}}],[\"是一个内存级数据库\",{\"1\":{\"1171\":1}}],[\"是一个在\",{\"1\":{\"1149\":1}}],[\"是一个非常重要的事情\",{\"1\":{\"1137\":1}}],[\"是一个为应用程序植入管理功能的框架\",{\"1\":{\"1045\":1}}],[\"是一个有序的队列\",{\"1\":{\"1026\":1}}],[\"是一个逻辑结构\",{\"1\":{\"1026\":1}}],[\"是一个异步的\",{\"1\":{\"789\":1}}],[\"是一个工具类\",{\"1\":{\"780\":1}}],[\"是一个组合的\",{\"1\":{\"779\":1}}],[\"是一个产品的加工车间\",{\"1\":{\"766\":1}}],[\"是一个\",{\"1\":{\"743\":1}}],[\"是一个用于表述指向文件的引用的抽象化概念\",{\"1\":{\"677\":1}}],[\"是一个用于存储\",{\"1\":{\"219\":1}}],[\"是一个叫做\",{\"1\":{\"658\":1}}],[\"是一个抽象类\",{\"1\":{\"581\":1}}],[\"是一个谓词\",{\"1\":{\"459\":1}}],[\"是一个临时结果集\",{\"1\":{\"318\":1}}],[\"是一段特殊的程序段\",{\"1\":{\"171\":1}}],[\"是一种在分布式系统下用来生成全局唯一id的工具\",{\"1\":{\"1131\":1}}],[\"是一种在存储引擎层使用索引过滤数据的一种优化方式\",{\"1\":{\"495\":1}}],[\"是一种拉消息模式的消息队列\",{\"1\":{\"1024\":1}}],[\"是一种测量和评估软件性能指标的活动\",{\"1\":{\"1019\":1}}],[\"是一种禁入机制\",{\"1\":{\"880\":1}}],[\"是一种准入机制\",{\"1\":{\"880\":1}}],[\"是一种编码容错技术\",{\"1\":{\"875\":1}}],[\"是一种读写分离的并发策略\",{\"1\":{\"578\":1}}],[\"是一种支持嵌套数据模型对的列式存储系统\",{\"1\":{\"429\":1}}],[\"是一种虚拟表\",{\"1\":{\"270\":1}}],[\"是一种优化手段表\",{\"1\":{\"259\":1}}],[\"是一种高级通信的方式\",{\"1\":{\"162\":1}}],[\"是一种低级通信方式\",{\"1\":{\"162\":1}}],[\"是一种为访问类提供一个创建一组相关或相互依赖对象的接口\",{\"1\":{\"37\":1}}],[\"是一款为\",{\"1\":{\"91\":1}}],[\"是模板方法的组成部分\",{\"1\":{\"84\":1}}],[\"是实现算法各个步骤的方法\",{\"1\":{\"84\":1}}],[\"是指redis中存储的数据都是以key\",{\"1\":{\"1182\":1}}],[\"是指通过互联网访问\",{\"1\":{\"1179\":1}}],[\"是指目前的分布式获取锁只能尝试一次\",{\"1\":{\"1149\":1}}],[\"是指事务\",{\"1\":{\"503\":1}}],[\"是指控制和管理整个计算机系统的硬件和软件资源\",{\"1\":{\"153\":1}}],[\"是指\",{\"1\":{\"76\":1,\"1243\":1}}],[\"是开源项目中比较常用的一种单例模式\",{\"1\":{\"66\":1}}],[\"是\",{\"1\":{\"64\":1,\"241\":1,\"579\":1,\"694\":3,\"743\":2,\"749\":1,\"766\":1,\"773\":2,\"840\":2,\"1037\":1,\"1176\":1,\"1240\":1,\"1245\":1,\"1355\":2,\"1482\":4,\"1489\":1,\"1499\":1,\"1525\":1}}],[\"是代理对象所代表的真实对象\",{\"1\":{\"57\":1}}],[\"是spring\",{\"1\":{\"1531\":2}}],[\"是sql92定义的标准统计行数的语法\",{\"1\":{\"482\":1}}],[\"是streamdecoder的设计实现在实际上采用了适配器模式\",{\"1\":{\"9\":1}}],[\"是sun\",{\"1\":{\"9\":1}}],[\"是欧洲标准\",{\"1\":{\"4\":1}}],[\"实战版\",{\"1\":{\"1532\":1}}],[\"实战\",{\"0\":{\"1057\":1,\"1090\":1}}],[\"实时从\",{\"1\":{\"1026\":1}}],[\"实时操作系统\",{\"1\":{\"165\":1}}],[\"实验如下\",{\"1\":{\"753\":1}}],[\"实际应用中很少使用\",{\"1\":{\"1513\":1}}],[\"实际是通过aop实现的\",{\"1\":{\"1513\":1}}],[\"实际是事件发布器\",{\"1\":{\"1444\":1}}],[\"实际是被作为\",{\"1\":{\"1280\":1}}],[\"实际的\",{\"1\":{\"1329\":1}}],[\"实际的方法实现是对sun\",{\"1\":{\"9\":1}}],[\"实际开发过程中\",{\"1\":{\"1114\":1}}],[\"实际开发中\",{\"1\":{\"1113\":1,\"1115\":1}}],[\"实际成交金额\",{\"1\":{\"988\":1}}],[\"实际支付价格\",{\"1\":{\"988\":3}}],[\"实际不是物理设备级别的读写\",{\"1\":{\"854\":1}}],[\"实际写入字节\",{\"1\":{\"843\":2}}],[\"实际传输一个超大文件\",{\"1\":{\"820\":1}}],[\"实际读到了数据\",{\"1\":{\"744\":1}}],[\"实际内容\",{\"1\":{\"709\":1}}],[\"实际每次读取的一般是它的整数倍\",{\"1\":{\"693\":1}}],[\"实际中可以通过redis来实现\",{\"1\":{\"973\":1}}],[\"实际中\",{\"1\":{\"679\":1}}],[\"实际上控制反转\",{\"1\":{\"1243\":1}}],[\"实际上并不是原子性的\",{\"1\":{\"1145\":1}}],[\"实际上并不是锁\",{\"1\":{\"561\":1}}],[\"实际上写入的就是旧的数据\",{\"1\":{\"1121\":1}}],[\"实际上是\",{\"1\":{\"740\":1}}],[\"实际上是在设定规范和契约\",{\"1\":{\"73\":1}}],[\"实际上\",{\"1\":{\"677\":1,\"1045\":1}}],[\"实际并不是\",{\"1\":{\"560\":1}}],[\"实际工作场景中\",{\"1\":{\"419\":1}}],[\"实际查询的时候再去改写sql去访问实际的数据表\",{\"1\":{\"275\":1}}],[\"实际用于进程推进的时间很少\",{\"1\":{\"192\":1}}],[\"实际参数\",{\"1\":{\"60\":1}}],[\"实例化该autoconfiguration类中定义的bean\",{\"1\":{\"1524\":1}}],[\"实例化后执行\",{\"1\":{\"1505\":1}}],[\"实例化后执行的方法\",{\"1\":{\"1505\":1}}],[\"实例化前执行\",{\"1\":{\"1505\":1}}],[\"实例化前\",{\"1\":{\"1505\":1}}],[\"实例创建后\",{\"1\":{\"1336\":1}}],[\"实例对象\",{\"1\":{\"1252\":1}}],[\"实例数据\",{\"1\":{\"631\":1}}],[\"实例\",{\"0\":{\"14\":1},\"1\":{\"59\":1,\"770\":2,\"781\":1,\"821\":1,\"1142\":1,\"1150\":1}}],[\"实现拦截时需要执行的具体业务逻辑\",{\"1\":{\"1532\":1}}],[\"实现handlerinterceptor接口\",{\"1\":{\"1532\":1}}],[\"实现组件重用\",{\"1\":{\"1406\":1}}],[\"实现组件之间的解耦\",{\"1\":{\"1240\":1}}],[\"实现增强\",{\"1\":{\"1300\":1,\"1302\":1}}],[\"实现之\",{\"0\":{\"1299\":1,\"1301\":1,\"1303\":1}}],[\"实现都\",{\"1\":{\"1243\":1}}],[\"实现数据的crud了\",{\"1\":{\"1198\":1}}],[\"实现下面接口\",{\"1\":{\"1176\":1}}],[\"实现签到接口\",{\"1\":{\"1175\":1}}],[\"实现签到功能\",{\"0\":{\"1175\":1}}],[\"实现附近商户功能\",{\"0\":{\"1172\":1}}],[\"实现分页查询收邮箱\",{\"0\":{\"1168\":1}}],[\"实现分布式锁版本一\",{\"0\":{\"1142\":1}}],[\"实现分布式锁时需要实现的两个基本方法\",{\"1\":{\"1141\":1}}],[\"实现共同关注功能\",{\"1\":{\"1165\":1}}],[\"实现共享\",{\"1\":{\"187\":1}}],[\"实现两个接口\",{\"1\":{\"1164\":1}}],[\"实现代码\",{\"1\":{\"1160\":1}}],[\"实现查看发布探店笔记的接口\",{\"1\":{\"1160\":1}}],[\"实现异步下单功能\",{\"1\":{\"1156\":1}}],[\"实现秒杀下单\",{\"0\":{\"1134\":1}}],[\"实现缓存重建\",{\"1\":{\"1129\":1}}],[\"实现复杂\",{\"1\":{\"1123\":1}}],[\"实现商铺和缓存与数据库双写一致\",{\"0\":{\"1122\":1}}],[\"实现最终一致\",{\"1\":{\"1120\":1}}],[\"实现登录拦截功能\",{\"0\":{\"1100\":1}}],[\"实现发送短信验证码功能\",{\"0\":{\"1099\":1}}],[\"实现思路\",{\"1\":{\"990\":1,\"1164\":1}}],[\"实现思想\",{\"1\":{\"872\":1,\"874\":1}}],[\"实现在map阶段的join操作\",{\"1\":{\"990\":1}}],[\"实现多路复用\",{\"1\":{\"850\":1}}],[\"实现一个\",{\"1\":{\"794\":1}}],[\"实现一个热插拔的效果\",{\"1\":{\"72\":1}}],[\"实现类\",{\"1\":{\"784\":1,\"785\":1}}],[\"实现类中的就绪事件集合替换为\",{\"1\":{\"742\":1}}],[\"实现来讲\",{\"1\":{\"775\":1}}],[\"实现虚拟地址向物理地址的转换\",{\"1\":{\"689\":1}}],[\"实现离散分配\",{\"1\":{\"683\":1}}],[\"实现的分布式锁存在下面的问题\",{\"1\":{\"1149\":1}}],[\"实现的\",{\"1\":{\"662\":1}}],[\"实现的细节也依赖于抽象\",{\"1\":{\"74\":1}}],[\"实现clone\",{\"1\":{\"629\":1}}],[\"实现原子性的关键\",{\"1\":{\"506\":1}}],[\"实现原理\",{\"0\":{\"292\":1}}],[\"实现bucket\",{\"1\":{\"469\":1}}],[\"实现map\",{\"0\":{\"468\":1}}],[\"实现随机分区\",{\"0\":{\"465\":1}}],[\"实现过程都会进行解析返回\",{\"1\":{\"440\":1}}],[\"实现过程\",{\"0\":{\"406\":1}}],[\"实现如下\",{\"1\":{\"400\":1}}],[\"实现步骤\",{\"1\":{\"344\":1,\"872\":1,\"873\":1,\"874\":1,\"988\":1,\"1161\":1}}],[\"实现方法\",{\"1\":{\"191\":1}}],[\"实现方式\",{\"1\":{\"6\":1,\"7\":1}}],[\"实现保护与实现共享的原因相似\",{\"1\":{\"187\":1}}],[\"实现起来比较复杂\",{\"1\":{\"176\":1}}],[\"实现互斥的p操作在实现同步的p操作之前\",{\"1\":{\"175\":1}}],[\"实现进程同步与互斥\",{\"1\":{\"173\":1}}],[\"实现进程状态转换\",{\"1\":{\"161\":1}}],[\"实现简单\",{\"1\":{\"165\":1,\"170\":2,\"182\":2,\"209\":1,\"1123\":1}}],[\"实现操作系统的内核功能的程序就是内核程序\",{\"1\":{\"156\":1}}],[\"实现对硬件机器的拓展\",{\"1\":{\"154\":1}}],[\"实现子类对父类的反向控制\",{\"1\":{\"87\":1}}],[\"实现抽象类中所定义的抽象方法和钩子方法\",{\"1\":{\"84\":1}}],[\"实现抽象原型类的\",{\"1\":{\"50\":1}}],[\"实现了真正的异步\",{\"1\":{\"856\":1}}],[\"实现了\",{\"1\":{\"746\":1,\"1260\":2}}],[\"实现了调节发布者发布数据的速率\",{\"1\":{\"719\":1}}],[\"实现了某个接口就有了相应的行为\",{\"1\":{\"595\":1}}],[\"实现了懒惰初始化\",{\"1\":{\"579\":1}}],[\"实现了反向控制\",{\"1\":{\"86\":2}}],[\"实现了selltickets\",{\"1\":{\"59\":1}}],[\"实现了抽象主题中的具体业务\",{\"1\":{\"57\":1}}],[\"实现了抽象产品角色所定义的接口\",{\"1\":{\"33\":1,\"38\":1}}],[\"实现了更好的复用\",{\"1\":{\"12\":1}}],[\"实现或者继承抽象产品的子类\",{\"1\":{\"27\":1}}],[\"实现\",{\"0\":{\"28\":1,\"34\":1,\"39\":1,\"51\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"400\":1,\"402\":1,\"404\":1,\"1089\":1,\"1249\":1},\"1\":{\"13\":1,\"161\":1,\"170\":1,\"183\":4,\"723\":2,\"775\":1,\"1026\":2,\"1322\":1,\"1493\":1}}],[\"实现所有方法\",{\"1\":{\"7\":1}}],[\"oxm\",{\"1\":{\"1499\":2}}],[\"ogroup\",{\"1\":{\"920\":1}}],[\"other\",{\"1\":{\"857\":2,\"917\":1}}],[\"owor\",{\"1\":{\"839\":1}}],[\"owner为空\",{\"1\":{\"542\":1}}],[\"owner\",{\"1\":{\"278\":1}}],[\"oom\",{\"1\":{\"826\":1}}],[\"oos\",{\"1\":{\"54\":3,\"68\":2,\"713\":2,\"714\":2}}],[\"oio\",{\"1\":{\"726\":1,\"762\":2,\"765\":2}}],[\"ois\",{\"1\":{\"54\":2,\"68\":2,\"713\":2,\"714\":2}}],[\"o对比\",{\"1\":{\"679\":1}}],[\"o多路复用\",{\"1\":{\"679\":2}}],[\"o访问\",{\"1\":{\"679\":1}}],[\"o的缺点\",{\"1\":{\"678\":1}}],[\"o的数据缓存在文件系统的页缓存\",{\"1\":{\"678\":1}}],[\"o的新特性\",{\"1\":{\"610\":1}}],[\"o机制中\",{\"1\":{\"678\":1}}],[\"o又被称作标准i\",{\"1\":{\"678\":1}}],[\"o编程时\",{\"1\":{\"611\":1}}],[\"o方式\",{\"1\":{\"610\":1}}],[\"ok\",{\"1\":{\"519\":2,\"711\":1,\"1099\":2,\"1107\":1,\"1122\":3,\"1129\":1,\"1133\":2,\"1134\":1,\"1137\":3,\"1156\":1,\"1157\":1,\"1159\":2,\"1160\":1,\"1161\":3,\"1162\":3,\"1164\":2,\"1165\":6,\"1167\":1,\"1168\":2,\"1172\":4,\"1175\":1,\"1176\":3,\"1205\":2,\"1206\":5,\"1208\":2,\"1424\":1,\"1525\":1,\"1526\":1,\"1531\":1}}],[\"o利用率\",{\"1\":{\"517\":1}}],[\"o采用了多线程\",{\"1\":{\"516\":1}}],[\"o和键值对读写是有一个线程完成的\",{\"1\":{\"516\":1}}],[\"o和网络传输非常有帮助\",{\"1\":{\"432\":1}}],[\"o和网络带宽是hadoop的宝贵资源\",{\"1\":{\"432\":1}}],[\"over\",{\"1\":{\"357\":1,\"358\":2,\"360\":7,\"361\":3,\"363\":4,\"364\":2,\"365\":10,\"400\":3,\"402\":1,\"404\":1}}],[\"overwrite\",{\"1\":{\"276\":1,\"283\":2,\"286\":1,\"288\":2,\"290\":6,\"318\":1,\"409\":1,\"410\":1,\"869\":1}}],[\"override\",{\"1\":{\"14\":6,\"17\":2,\"23\":3,\"34\":1,\"47\":4,\"51\":1,\"52\":1,\"54\":1,\"73\":1,\"81\":6,\"85\":4,\"373\":1,\"536\":1,\"554\":6,\"555\":6,\"692\":5,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"702\":5,\"703\":2,\"704\":5,\"705\":2,\"707\":2,\"710\":3,\"711\":3,\"713\":2,\"714\":2,\"717\":4,\"718\":8,\"723\":6,\"725\":2,\"733\":4,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"740\":6,\"741\":2,\"743\":2,\"748\":6,\"749\":1,\"753\":5,\"754\":2,\"757\":1,\"758\":2,\"766\":9,\"784\":1,\"785\":1,\"794\":4,\"822\":5,\"846\":2,\"857\":2,\"859\":6,\"958\":1,\"960\":1,\"962\":1,\"972\":5,\"973\":3,\"974\":7,\"985\":6,\"986\":2,\"988\":6,\"990\":2,\"1035\":3,\"1088\":1,\"1099\":2,\"1100\":2,\"1107\":1,\"1111\":3,\"1122\":2,\"1129\":1,\"1133\":1,\"1134\":1,\"1137\":1,\"1142\":3,\"1144\":2,\"1150\":1,\"1152\":1,\"1156\":2,\"1157\":2,\"1160\":1,\"1161\":3,\"1162\":2,\"1164\":2,\"1165\":2,\"1167\":1,\"1168\":1,\"1172\":1,\"1175\":1,\"1176\":1,\"1309\":4,\"1416\":1,\"1449\":1,\"1451\":1,\"1505\":6,\"1525\":1}}],[\"odbc\",{\"1\":{\"232\":1}}],[\"ods层\",{\"0\":{\"225\":1}}],[\"ods\",{\"1\":{\"224\":1,\"228\":2,\"408\":1,\"409\":2}}],[\"onstartup\",{\"1\":{\"1449\":1,\"1451\":2}}],[\"onsubscribe\",{\"1\":{\"716\":1,\"717\":1,\"718\":2}}],[\"once\",{\"1\":{\"1053\":3,\"1054\":2}}],[\"once保障\",{\"1\":{\"1053\":1}}],[\"oncomplete\",{\"1\":{\"716\":1,\"717\":1,\"718\":2,\"1152\":3}}],[\"one\",{\"1\":{\"1082\":1,\"1099\":1,\"1107\":1}}],[\"onedrive\",{\"1\":{\"991\":4}}],[\"onetwothreefourfive\",{\"1\":{\"808\":1}}],[\"onetwothree\",{\"1\":{\"807\":1}}],[\"onerror\",{\"1\":{\"716\":1,\"717\":1,\"718\":2}}],[\"onunhandledinboundmessage\",{\"1\":{\"775\":2}}],[\"onnext\",{\"1\":{\"716\":1,\"717\":1,\"718\":2}}],[\"on\",{\"0\":{\"472\":1},\"1\":{\"221\":2,\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"320\":2,\"321\":2,\"322\":2,\"323\":2,\"324\":2,\"325\":2,\"326\":13,\"369\":6,\"409\":1,\"423\":3,\"460\":2,\"740\":1,\"1230\":1}}],[\"onlyifabsent\",{\"1\":{\"579\":3}}],[\"only\",{\"1\":{\"76\":1,\"290\":1,\"1184\":1,\"1206\":1}}],[\"oldlimit\",{\"1\":{\"799\":3,\"809\":3}}],[\"oldwakenup\",{\"1\":{\"741\":3,\"742\":2}}],[\"old这两个组合声明为废弃\",{\"1\":{\"638\":1}}],[\"old作为cms出现\",{\"1\":{\"638\":1}}],[\"old\",{\"1\":{\"628\":1,\"638\":9}}],[\"oldval\",{\"1\":{\"579\":5}}],[\"oldmode\",{\"1\":{\"69\":1}}],[\"olap函数\",{\"1\":{\"356\":1}}],[\"olap专题\",{\"1\":{\"227\":1}}],[\"olap目标是做数据分析\",{\"1\":{\"221\":1}}],[\"olap\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"oltp目标是做数据处理\",{\"1\":{\"221\":1}}],[\"oltp\",{\"0\":{\"221\":1},\"1\":{\"221\":1}}],[\"o请求的顺序\",{\"1\":{\"211\":1}}],[\"o请求到来时\",{\"1\":{\"211\":1}}],[\"o请求\",{\"1\":{\"211\":1}}],[\"o调度\",{\"1\":{\"211\":1}}],[\"o系统\",{\"1\":{\"211\":1}}],[\"o核心子系统\",{\"0\":{\"211\":1},\"1\":{\"211\":1}}],[\"o软件层次结构\",{\"0\":{\"210\":1}}],[\"o指令\",{\"1\":{\"209\":2}}],[\"o已完成\",{\"1\":{\"209\":1}}],[\"o完成的过程中cpu可以切换到别的进程执行\",{\"1\":{\"209\":1}}],[\"o完成的过程中cpu需要不断的轮询检查\",{\"1\":{\"209\":1}}],[\"o控制方式\",{\"0\":{\"209\":1}}],[\"o控制器会通过中断信号主动报告i\",{\"1\":{\"209\":1}}],[\"o控制器可能会对应多个设备\",{\"1\":{\"208\":1}}],[\"o控制器的组成\",{\"1\":{\"208\":1}}],[\"o控制器\",{\"0\":{\"208\":1},\"1\":{\"208\":1}}],[\"o与寄存器独立编址\",{\"1\":{\"208\":1}}],[\"o专用地址\",{\"1\":{\"208\":1}}],[\"o开销较大\",{\"1\":{\"192\":1}}],[\"o速度比文件区的更快\",{\"1\":{\"181\":1}}],[\"o设备输入的数据\",{\"1\":{\"212\":1}}],[\"o设备获得数据\",{\"1\":{\"212\":1}}],[\"o设备有不同的硬件特性\",{\"1\":{\"210\":1}}],[\"o设备与内存之间的传输\",{\"1\":{\"209\":1}}],[\"o设备可并行工作\",{\"1\":{\"209\":1}}],[\"o设备可以尽早投入使用\",{\"1\":{\"167\":1}}],[\"o设备可以和cpu并行工作\",{\"1\":{\"167\":1}}],[\"o设备只能串行工作\",{\"1\":{\"209\":1}}],[\"o设备\",{\"1\":{\"209\":6}}],[\"o设备的并行性得到提升\",{\"1\":{\"209\":1}}],[\"o设备的电子部件\",{\"1\":{\"208\":1}}],[\"o设备的机械部件\",{\"1\":{\"208\":1}}],[\"o设备的分类\",{\"1\":{\"207\":1}}],[\"o设备的基本概念和分类\",{\"0\":{\"207\":1}}],[\"o设备介绍\",{\"1\":{\"207\":1}}],[\"o设备等\",{\"1\":{\"157\":1}}],[\"o繁忙型进程优先运行\",{\"1\":{\"167\":1}}],[\"o繁忙型进程\",{\"1\":{\"167\":1}}],[\"o型进程\",{\"1\":{\"167\":1}}],[\"o操作都是缓存i\",{\"1\":{\"678\":1}}],[\"o操作开始之前\",{\"1\":{\"209\":2}}],[\"o操作写回外存\",{\"1\":{\"191\":1}}],[\"o操作完成的时间\",{\"1\":{\"166\":1}}],[\"o操作\",{\"1\":{\"158\":1,\"167\":1,\"191\":1,\"192\":1,\"432\":1}}],[\"os++\",{\"1\":{\"1168\":1}}],[\"osr\",{\"0\":{\"1049\":1},\"1\":{\"1049\":2}}],[\"os还须再利用页\",{\"1\":{\"688\":1}}],[\"os的运行机制和体系结构\",{\"0\":{\"156\":1}}],[\"os\",{\"1\":{\"153\":1,\"1168\":6}}],[\"opsforhyperloglog\",{\"1\":{\"1180\":2}}],[\"opsforhash\",{\"1\":{\"1107\":1,\"1111\":1,\"1224\":3}}],[\"opsforgeo\",{\"1\":{\"1171\":1,\"1172\":1}}],[\"opsforzset\",{\"1\":{\"1162\":5,\"1167\":1,\"1168\":1}}],[\"opsforset\",{\"1\":{\"1161\":4,\"1165\":3}}],[\"opsforvalue\",{\"1\":{\"1107\":1,\"1122\":2,\"1124\":3,\"1127\":4,\"1128\":2,\"1129\":8,\"1132\":1,\"1133\":1,\"1142\":1,\"1144\":2,\"1156\":1,\"1175\":1,\"1176\":1,\"1221\":2,\"1223\":4}}],[\"ops\",{\"1\":{\"742\":3}}],[\"op\",{\"1\":{\"740\":2,\"742\":5,\"743\":1,\"834\":1,\"836\":2,\"840\":2,\"843\":6,\"846\":2,\"875\":1}}],[\"options0\",{\"1\":{\"740\":1}}],[\"options\",{\"1\":{\"740\":3,\"869\":1,\"1004\":1,\"1199\":1}}],[\"option\",{\"1\":{\"693\":2,\"725\":1,\"726\":1}}],[\"optional<employee>\",{\"1\":{\"619\":1}}],[\"optional\",{\"1\":{\"276\":1,\"1482\":1,\"1489\":3}}],[\"optional>\",{\"1\":{\"104\":1,\"1022\":1,\"1087\":1,\"1219\":1,\"1473\":1}}],[\"optimization\",{\"0\":{\"1548\":1}}],[\"optimize\",{\"1\":{\"437\":1,\"450\":3,\"453\":1,\"459\":1,\"470\":3}}],[\"optimizedrc\",{\"1\":{\"430\":1}}],[\"optimise\",{\"1\":{\"456\":1,\"457\":1}}],[\"opt\",{\"1\":{\"191\":2,\"690\":1}}],[\"operationcomplete\",{\"1\":{\"740\":1,\"743\":1,\"753\":3,\"754\":1,\"758\":1}}],[\"operation\",{\"0\":{\"225\":1},\"1\":{\"293\":1}}],[\"operating\",{\"1\":{\"153\":1}}],[\"opens\",{\"1\":{\"1243\":1,\"1292\":1,\"1296\":1,\"1313\":2,\"1317\":1}}],[\"openssl\",{\"1\":{\"876\":1}}],[\"openai\",{\"1\":{\"125\":2}}],[\"openmmlab图像生成开源算法库mmgeneration\",{\"1\":{\"124\":1}}],[\"openmmlab开源图像生成算法库mmgeneration\",{\"1\":{\"121\":1,\"128\":1}}],[\"open\",{\"1\":{\"121\":1,\"124\":1,\"128\":1,\"740\":2,\"826\":2,\"827\":1,\"830\":1,\"834\":2,\"836\":2,\"840\":3,\"843\":4,\"846\":3,\"848\":2,\"857\":1,\"859\":1}}],[\"orm\",{\"1\":{\"1499\":2}}],[\"orm映射\",{\"0\":{\"483\":1}}],[\"oracle\",{\"1\":{\"984\":1,\"1454\":1}}],[\"oracle中\",{\"1\":{\"420\":1}}],[\"origin\",{\"1\":{\"776\":8,\"799\":3}}],[\"originalfilename\",{\"1\":{\"1159\":2}}],[\"original\",{\"1\":{\"671\":2,\"1067\":1}}],[\"originaltransaction\",{\"1\":{\"293\":1}}],[\"ordinal\",{\"1\":{\"723\":1}}],[\"orderedcharacterencodingfilter\",{\"1\":{\"1462\":1}}],[\"ordered\",{\"1\":{\"1260\":1}}],[\"orderedeventexecutor\",{\"1\":{\"746\":1}}],[\"orderbydesc\",{\"1\":{\"1161\":1}}],[\"ordertasks\",{\"1\":{\"1157\":3}}],[\"orderkey\",{\"1\":{\"1156\":5}}],[\"orderid\",{\"1\":{\"1134\":3,\"1137\":9,\"1156\":3,\"1157\":5}}],[\"order这张表中\",{\"1\":{\"1131\":1}}],[\"orderssize\",{\"1\":{\"988\":2}}],[\"orderslist\",{\"1\":{\"988\":5}}],[\"orders\",{\"1\":{\"988\":3,\"1186\":1}}],[\"orders等具体的信息\",{\"1\":{\"442\":1}}],[\"order\",{\"0\":{\"115\":1,\"312\":1,\"314\":1},\"1\":{\"300\":1,\"310\":1,\"314\":1,\"315\":1,\"348\":1,\"349\":2,\"351\":1,\"353\":2,\"354\":1,\"355\":2,\"358\":2,\"360\":3,\"361\":3,\"363\":4,\"364\":3,\"365\":10,\"367\":1,\"400\":3,\"402\":1,\"404\":1,\"452\":1,\"481\":3,\"493\":2,\"1100\":2,\"1132\":1,\"1134\":1,\"1137\":3,\"1142\":1,\"1150\":2,\"1156\":2,\"1157\":5,\"1162\":2,\"1168\":1,\"1172\":1,\"1260\":1}}],[\"ordercoffee\",{\"1\":{\"34\":1}}],[\"orc矢量查询\",{\"0\":{\"438\":1}}],[\"orc提供了两种索引机制\",{\"1\":{\"437\":1}}],[\"orc文件索引\",{\"0\":{\"437\":1}}],[\"orc\",{\"0\":{\"430\":1},\"1\":{\"267\":1,\"268\":2,\"276\":1,\"290\":1,\"293\":1,\"296\":1,\"298\":1,\"430\":1,\"437\":10}}],[\"org\",{\"1\":{\"91\":1,\"112\":5,\"113\":4,\"114\":4,\"115\":4,\"117\":1,\"125\":2,\"131\":1,\"144\":1,\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"374\":2,\"397\":1,\"433\":2,\"1023\":2,\"1024\":2,\"1046\":1,\"1219\":4,\"1236\":1,\"1332\":1,\"1335\":1,\"1338\":1,\"1342\":1,\"1345\":1,\"1349\":1,\"1428\":1,\"1445\":5,\"1453\":1,\"1454\":1,\"1455\":1,\"1456\":2,\"1461\":1,\"1462\":1}}],[\"or\",{\"1\":{\"63\":1,\"271\":1,\"278\":1,\"283\":1,\"332\":2,\"337\":1,\"409\":1,\"740\":1,\"743\":1,\"1164\":1,\"1205\":1}}],[\"o\",{\"0\":{\"678\":1,\"679\":1,\"1535\":1},\"1\":{\"47\":6,\"60\":3,\"191\":1,\"197\":1,\"208\":1,\"497\":1,\"523\":1,\"576\":1,\"609\":1,\"611\":1,\"662\":2,\"663\":4,\"665\":2,\"678\":2,\"679\":8,\"737\":2,\"748\":12,\"750\":2,\"751\":5,\"760\":4,\"761\":3,\"762\":3,\"763\":4,\"764\":3,\"808\":1,\"920\":2,\"974\":3,\"1440\":1}}],[\"observer2\",{\"1\":{\"47\":2}}],[\"observer1\",{\"1\":{\"47\":2}}],[\"observers\",{\"1\":{\"47\":4}}],[\"observer角色负责接收来自subject角色的状态变化的通知\",{\"1\":{\"46\":1}}],[\"observer\",{\"1\":{\"46\":1,\"47\":9}}],[\"observer本来的意思是\",{\"1\":{\"45\":1}}],[\"observer模式也被称为publish\",{\"1\":{\"45\":1}}],[\"observer模式适用于根据对象状态进行相应处理的场景\",{\"1\":{\"45\":1}}],[\"observer模式篇\",{\"1\":{\"44\":1}}],[\"objenesiscglibaopproxy\",{\"1\":{\"1325\":1}}],[\"object的缩写\",{\"1\":{\"1529\":1}}],[\"objectprovider\",{\"1\":{\"1482\":1}}],[\"objectfactory\",{\"1\":{\"1290\":1,\"1297\":1,\"1482\":1,\"1489\":3}}],[\"objectmapper\",{\"1\":{\"1073\":4,\"1223\":2}}],[\"objectutils\",{\"1\":{\"1232\":1}}],[\"objectutil\",{\"1\":{\"749\":1,\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":1,\"1161\":1}}],[\"object类中的方法\",{\"1\":{\"545\":1}}],[\"object>\",{\"1\":{\"483\":2,\"733\":1,\"740\":5,\"743\":1,\"859\":1,\"1107\":1,\"1111\":1,\"1221\":1,\"1222\":2,\"1224\":1,\"1232\":1}}],[\"objectinputstream类\",{\"1\":{\"69\":1}}],[\"objectinputstream\",{\"1\":{\"54\":2,\"68\":2,\"713\":2,\"714\":2,\"723\":4}}],[\"objectoutputstream\",{\"1\":{\"54\":2,\"68\":2,\"713\":2,\"714\":2,\"723\":2}}],[\"object\",{\"0\":{\"395\":1},\"1\":{\"42\":1,\"59\":16,\"60\":2,\"69\":8,\"70\":3,\"250\":2,\"336\":3,\"393\":1,\"395\":4,\"541\":2,\"551\":4,\"554\":2,\"555\":4,\"567\":1,\"579\":1,\"603\":3,\"701\":2,\"702\":1,\"707\":2,\"710\":1,\"711\":1,\"723\":8,\"733\":3,\"734\":1,\"735\":1,\"737\":3,\"738\":1,\"743\":1,\"748\":3,\"749\":2,\"766\":6,\"775\":4,\"794\":2,\"859\":2,\"968\":1,\"1035\":2,\"1063\":1,\"1099\":1,\"1100\":2,\"1111\":3,\"1221\":1,\"1223\":1,\"1257\":4,\"1304\":1,\"1306\":2,\"1309\":10,\"1317\":4,\"1505\":8,\"1521\":1}}],[\"obj2\",{\"1\":{\"603\":1}}],[\"obj1\",{\"1\":{\"603\":1}}],[\"obj\",{\"1\":{\"42\":2,\"60\":2,\"69\":5,\"541\":2,\"603\":1}}],[\"ofpattern\",{\"1\":{\"1132\":1,\"1175\":1,\"1176\":1}}],[\"ofseconds\",{\"1\":{\"1024\":1}}],[\"off\",{\"1\":{\"88\":6}}],[\"offset大小\",{\"1\":{\"1056\":1}}],[\"offset\",{\"1\":{\"9\":2,\"300\":1,\"799\":7,\"855\":1,\"1024\":4,\"1025\":5,\"1026\":2,\"1168\":9,\"1174\":3,\"1175\":1}}],[\"of\",{\"1\":{\"69\":1,\"70\":2,\"128\":1,\"369\":4,\"437\":1,\"442\":3,\"717\":1,\"718\":1,\"775\":1,\"789\":1,\"882\":1,\"1049\":1,\"1089\":2,\"1165\":1,\"1168\":1,\"1172\":1,\"1206\":1,\"1429\":2,\"1432\":2}}],[\"ofobuilder\",{\"1\":{\"14\":2}}],[\"ofo单车builder类\",{\"1\":{\"14\":1}}],[\"outvalue\",{\"1\":{\"958\":2,\"960\":3,\"972\":6,\"974\":2,\"983\":1,\"985\":3,\"986\":3,\"988\":10}}],[\"outkey\",{\"1\":{\"958\":3,\"972\":3,\"973\":3,\"974\":3,\"983\":2,\"988\":7,\"990\":3}}],[\"outbound\",{\"1\":{\"787\":1}}],[\"outlist\",{\"1\":{\"714\":2,\"723\":2}}],[\"output文件夹应该不存在\",{\"1\":{\"962\":1}}],[\"outputstream\",{\"1\":{\"839\":1}}],[\"outputstreamwriter\",{\"1\":{\"795\":2}}],[\"output=true\",{\"1\":{\"433\":1}}],[\"output\",{\"1\":{\"433\":5,\"962\":1}}],[\"outputvalue\",{\"1\":{\"373\":2}}],[\"outputkey\",{\"1\":{\"373\":3}}],[\"outputencoding>\",{\"1\":{\"99\":1}}],[\"outputencoding>utf\",{\"1\":{\"99\":1}}],[\"outer\",{\"0\":{\"323\":1},\"1\":{\"321\":2,\"322\":2,\"323\":2,\"326\":1,\"461\":3}}],[\"outerhandle\",{\"1\":{\"69\":1}}],[\"out\",{\"1\":{\"6\":7,\"7\":5,\"14\":2,\"17\":2,\"23\":3,\"34\":2,\"43\":1,\"47\":4,\"51\":3,\"52\":1,\"54\":3,\"58\":2,\"59\":3,\"60\":2,\"68\":2,\"70\":3,\"73\":2,\"74\":7,\"75\":5,\"76\":2,\"81\":6,\"85\":7,\"344\":1,\"369\":4,\"536\":2,\"562\":10,\"565\":1,\"614\":2,\"616\":1,\"617\":3,\"618\":1,\"619\":2,\"620\":3,\"621\":9,\"645\":1,\"648\":2,\"668\":2,\"702\":12,\"710\":1,\"713\":11,\"714\":12,\"717\":2,\"718\":4,\"723\":18,\"725\":1,\"726\":5,\"737\":3,\"746\":4,\"748\":1,\"765\":4,\"768\":1,\"774\":5,\"776\":8,\"779\":3,\"780\":3,\"784\":1,\"794\":2,\"795\":2,\"799\":6,\"805\":2,\"809\":1,\"820\":2,\"821\":2,\"822\":6,\"823\":1,\"826\":1,\"834\":2,\"836\":1,\"839\":5,\"843\":4,\"848\":1,\"859\":4,\"972\":4,\"974\":5,\"985\":7,\"988\":1,\"991\":1,\"999\":3,\"1049\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":3,\"1132\":2,\"1150\":1,\"1213\":3,\"1221\":1,\"1223\":2,\"1224\":1,\"1244\":3,\"1257\":5,\"1294\":2,\"1304\":3,\"1306\":3,\"1309\":4,\"1317\":2,\"1416\":1,\"1441\":1,\"1526\":1}}],[\"如事务处理\",{\"1\":{\"1500\":1}}],[\"如最大\",{\"1\":{\"1454\":1}}],[\"如本例\",{\"1\":{\"1333\":1}}],[\"如代理增强\",{\"1\":{\"1254\":1}}],[\"如图\",{\"1\":{\"1195\":1,\"1223\":1}}],[\"如图所示\",{\"1\":{\"659\":1}}],[\"如内存\",{\"1\":{\"948\":1}}],[\"如内存清零指令\",{\"1\":{\"156\":1}}],[\"如每个队列分配一定的资源\",{\"1\":{\"945\":1}}],[\"如此以来\",{\"1\":{\"920\":1}}],[\"如创建\",{\"1\":{\"888\":1}}],[\"如粘包\",{\"1\":{\"792\":1}}],[\"如上图所示\",{\"1\":{\"679\":1}}],[\"如上代码中的sd\",{\"1\":{\"9\":1}}],[\"如硬盘读写操作完成\",{\"1\":{\"676\":1}}],[\"如缺页异常\",{\"1\":{\"676\":1}}],[\"如linux的\",{\"1\":{\"676\":1}}],[\"如读写文件\",{\"1\":{\"538\":1}}],[\"如释放锁\",{\"1\":{\"536\":1}}],[\"如desc\",{\"1\":{\"480\":1}}],[\"如druid\",{\"1\":{\"274\":1}}],[\"如不指定\",{\"1\":{\"365\":2}}],[\"如梦令\",{\"1\":{\"256\":1}}],[\"如hive内置的derby\",{\"1\":{\"239\":1}}],[\"如read\",{\"1\":{\"210\":2}}],[\"如显示该目录中的所有文件及相应的属性\",{\"1\":{\"196\":1}}],[\"如cpu\",{\"1\":{\"176\":1}}],[\"如com\",{\"1\":{\"98\":1}}],[\"如100ms\",{\"1\":{\"167\":1}}],[\"如p\",{\"1\":{\"162\":1}}],[\"如修改进程状态标志\",{\"1\":{\"161\":1}}],[\"如存储分配\",{\"1\":{\"158\":1}}],[\"如程序状态字\",{\"1\":{\"157\":1}}],[\"如0表示用户态\",{\"1\":{\"156\":1}}],[\"如下所示\",{\"1\":{\"663\":1}}],[\"如下图\",{\"1\":{\"662\":1,\"666\":2,\"1104\":1}}],[\"如下表\",{\"1\":{\"480\":1}}],[\"如下配置编码格式\",{\"1\":{\"99\":1}}],[\"如下\",{\"1\":{\"88\":1,\"353\":1,\"755\":1,\"779\":1,\"1137\":1}}],[\"如和粉丝的见面会\",{\"1\":{\"76\":1}}],[\"如intel\",{\"1\":{\"74\":1}}],[\"如何走出人生的艰难时刻\",{\"1\":{\"1525\":1}}],[\"如何拥有高质量的关系\",{\"1\":{\"1525\":1}}],[\"如何让心智变得更成熟\",{\"1\":{\"1525\":1}}],[\"如何养成一个新习惯\",{\"1\":{\"1525\":1}}],[\"如何读取\",{\"1\":{\"1446\":1}}],[\"如何读取小文件\",{\"0\":{\"436\":1}}],[\"如何工作\",{\"1\":{\"1417\":1}}],[\"如何避免反射\",{\"0\":{\"1319\":1}}],[\"如何从后向前遍历每个\",{\"1\":{\"1176\":1}}],[\"如何从海量数据中找出高频词\",{\"0\":{\"475\":1},\"1\":{\"475\":1}}],[\"如何得到本月到今天为止的所有签到数据\",{\"1\":{\"1176\":1}}],[\"如何使用\",{\"1\":{\"1150\":1}}],[\"如何使用缓存\",{\"0\":{\"1115\":1}}],[\"如何保证缓存与数据库的操作的同时成功或失败\",{\"1\":{\"1121\":1}}],[\"如何保证不同的用户对文件由不同的操作权限\",{\"1\":{\"194\":1}}],[\"如何达成一致\",{\"1\":{\"1037\":1}}],[\"如何有多个\",{\"1\":{\"973\":1}}],[\"如何拿到\",{\"0\":{\"847\":1}}],[\"如何改进呢\",{\"1\":{\"846\":1}}],[\"如何写入后数据大小未超过\",{\"1\":{\"773\":1}}],[\"如何设计协议呢\",{\"1\":{\"709\":1}}],[\"如何将逻辑地址转换为物理地址\",{\"1\":{\"683\":1}}],[\"如何将这中间的三分之一数据拿出来呢\",{\"1\":{\"364\":1}}],[\"如何选择\",{\"1\":{\"1398\":1}}],[\"如何选择合适的垃圾收集算法\",{\"1\":{\"633\":1}}],[\"如何选择需要看表的大小\",{\"1\":{\"496\":1}}],[\"如何选择重复依赖\",{\"1\":{\"105\":1}}],[\"如何指定分隔符\",{\"1\":{\"251\":1}}],[\"如何在磁盘中读\",{\"1\":{\"203\":1}}],[\"如何回收\",{\"1\":{\"198\":1}}],[\"如何实现\",{\"1\":{\"779\":1}}],[\"如何实现的\",{\"1\":{\"566\":1}}],[\"如何实现文件的逻辑块号到物理块号的转换\",{\"1\":{\"197\":1}}],[\"如何实现虚拟内存技术\",{\"1\":{\"189\":1}}],[\"如何实现进程控制\",{\"1\":{\"161\":1}}],[\"如何进行处理呢\",{\"1\":{\"1411\":1}}],[\"如何进行空闲块的分配\",{\"1\":{\"198\":1}}],[\"如何进行回收\",{\"1\":{\"182\":1}}],[\"如何进行分配\",{\"1\":{\"182\":1}}],[\"如何进行分区的分配和回收操作\",{\"1\":{\"182\":1}}],[\"如何区分各个程序的数据在内存的什么地方\",{\"1\":{\"179\":1}}],[\"如何合理的设置各类进程的优先级\",{\"1\":{\"167\":1}}],[\"如何正确的使用继承\",{\"1\":{\"73\":1}}],[\"如何解决\",{\"1\":{\"23\":1,\"102\":1,\"197\":1}}],[\"如有人只喜欢穿某一个品牌的衣服和鞋\",{\"1\":{\"41\":1}}],[\"如电器工厂中的电视机\",{\"1\":{\"41\":1}}],[\"如电器厂既生产电视机又生产洗衣机或空调\",{\"1\":{\"36\":1}}],[\"如提拉米苏\",{\"1\":{\"39\":1}}],[\"如畜牧场只养动物\",{\"1\":{\"36\":1}}],[\"如要制造一个超人\",{\"1\":{\"19\":1}}],[\"如果匹配dispatcherservlet的请求路径\",{\"1\":{\"1530\":1}}],[\"如果代理对象实现了某个接口\",{\"1\":{\"1500\":1}}],[\"如果待装配类型有\",{\"1\":{\"1489\":1}}],[\"如果待装配类型有泛型参数\",{\"1\":{\"1489\":1}}],[\"如果待装配类型是数组\",{\"1\":{\"1489\":1}}],[\"如果待装配类型是\",{\"1\":{\"1489\":3}}],[\"如果待装配的成员变量或方法参数上用\",{\"1\":{\"1489\":1}}],[\"如果待装配的类型是\",{\"1\":{\"1489\":1}}],[\"如果待排序的列有多个\",{\"1\":{\"493\":1}}],[\"如果结果仍\",{\"1\":{\"1482\":1}}],[\"如果结果\",{\"1\":{\"1482\":1}}],[\"如果结果是1\",{\"1\":{\"1141\":1}}],[\"如果自己配置了\",{\"1\":{\"1456\":1}}],[\"如果知道数据源的实现类类型\",{\"1\":{\"1454\":1}}],[\"如果返回的\",{\"1\":{\"1438\":2}}],[\"如果编译时添加了\",{\"1\":{\"1366\":2}}],[\"如果指定了接口\",{\"1\":{\"1325\":1}}],[\"如果同一个\",{\"1\":{\"1289\":1}}],[\"如果同时考虑这两种分类\",{\"1\":{\"77\":1}}],[\"如果dao层查询出来的数据没有一个实体类对象与之一一对应\",{\"1\":{\"1230\":1}}],[\"如果操作存在的数据\",{\"1\":{\"1208\":1}}],[\"如果操作不存在的数据\",{\"1\":{\"1208\":1}}],[\"如果操作成功\",{\"1\":{\"1152\":1}}],[\"如果value是一个java对象\",{\"1\":{\"1207\":1}}],[\"如果做水平扩展会给数据查询带来很多麻烦\",{\"1\":{\"1189\":1}}],[\"如果说用户要查询的\",{\"1\":{\"1177\":1}}],[\"如果算法不精准\",{\"1\":{\"1166\":1}}],[\"如果交集为空\",{\"1\":{\"1165\":1}}],[\"如果已存在一个事务\",{\"1\":{\"1514\":1}}],[\"如果已点赞\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"如果已经存在则更新其score值\",{\"1\":{\"1211\":1}}],[\"如果已经有其他节点持有锁\",{\"1\":{\"885\":1}}],[\"如果已经\",{\"1\":{\"741\":1}}],[\"如果已经完成\",{\"1\":{\"740\":1}}],[\"如果未来业务有其他拼接字段\",{\"1\":{\"1232\":1}}],[\"如果未点赞\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"如果未指定scheme\",{\"1\":{\"290\":1}}],[\"如果判断我出来不为\",{\"1\":{\"1157\":1}}],[\"如果抢购成功\",{\"1\":{\"1156\":1}}],[\"如果充足\",{\"1\":{\"1155\":1}}],[\"如果访问的人很多\",{\"1\":{\"1155\":1}}],[\"如果传入参数\",{\"1\":{\"1152\":1}}],[\"如果带带参数传入的值是\",{\"1\":{\"1152\":1}}],[\"如果持有这把锁的人再次持有这把锁\",{\"1\":{\"1151\":1}}],[\"如果持有对外部对象的引用的话\",{\"1\":{\"636\":1}}],[\"如果脚本中的key\",{\"1\":{\"1146\":1}}],[\"如果属于自己\",{\"1\":{\"1143\":1}}],[\"如果redis中不存在指定的键\",{\"1\":{\"1142\":1,\"1144\":1}}],[\"如果redis中有大量的key已经过期\",{\"1\":{\"529\":1}}],[\"如果插入key成功\",{\"1\":{\"1140\":1}}],[\"如果下过这个订单\",{\"1\":{\"1137\":1}}],[\"如果获取锁失败\",{\"1\":{\"1142\":1,\"1150\":1}}],[\"如果获取某个值\",{\"1\":{\"1136\":1}}],[\"如果获取到了锁的线程\",{\"1\":{\"1127\":1}}],[\"如果预估值\",{\"1\":{\"1135\":1}}],[\"如果预计三年后数据量根本达不到这个级别\",{\"1\":{\"480\":1}}],[\"如果大1\",{\"1\":{\"1135\":1}}],[\"如果大量的请求同时过来访问这种不存在的数据\",{\"1\":{\"1123\":1}}],[\"如果时间充足\",{\"1\":{\"1134\":1,\"1137\":1}}],[\"如果时间片太小\",{\"1\":{\"167\":1}}],[\"如果时间片太大\",{\"1\":{\"167\":1}}],[\"如果尚未开始或已经结束则无法下单\",{\"1\":{\"1134\":1}}],[\"如果封装数据\",{\"1\":{\"1128\":1}}],[\"如果失败\",{\"1\":{\"1127\":1}}],[\"如果失去共享性\",{\"1\":{\"155\":1}}],[\"如果失去并发性\",{\"1\":{\"155\":1}}],[\"如果从缓存没有查询到数据\",{\"1\":{\"1127\":1}}],[\"如果布隆过滤器判断存在\",{\"1\":{\"1123\":1}}],[\"如果当过期时间到了之后\",{\"1\":{\"1147\":1}}],[\"如果当数据库中数据发生变化\",{\"1\":{\"1120\":1}}],[\"如果当前存在事务\",{\"1\":{\"1514\":6}}],[\"如果当前没有事务\",{\"1\":{\"1514\":3}}],[\"如果当前创建的bean是单例的则会放入单例池\",{\"1\":{\"1505\":1}}],[\"如果当前用户已经点赞\",{\"1\":{\"1161\":1}}],[\"如果当前节点的数据是字符串\",{\"1\":{\"665\":1}}],[\"如果当前节点的数据是整数\",{\"1\":{\"665\":1}}],[\"如果当前字符是\",{\"1\":{\"662\":1}}],[\"如果当前字符不是\",{\"1\":{\"662\":1}}],[\"如果当前数组的长度小于64\",{\"1\":{\"605\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"605\":1}}],[\"如果当前线程暂时没有数据可读\",{\"1\":{\"609\":1}}],[\"如果当前线程独占着锁\",{\"1\":{\"585\":1}}],[\"如果当前线程自旋成功\",{\"1\":{\"542\":1}}],[\"如果缓存的id和当前线程的id相同\",{\"1\":{\"1144\":1}}],[\"如果缓存未命中\",{\"1\":{\"1122\":1}}],[\"如果缓存不存在\",{\"1\":{\"1118\":1}}],[\"如果缓存有\",{\"1\":{\"1118\":1}}],[\"如果缓存数据不存在\",{\"1\":{\"1117\":1}}],[\"如果缓存数据存在\",{\"1\":{\"1117\":1}}],[\"如果小伙伴们看过threadlocal的源码\",{\"1\":{\"1100\":1}}],[\"如果小于这个值就会进行合并\",{\"1\":{\"435\":1}}],[\"如果手机号合法\",{\"1\":{\"1098\":1}}],[\"如果消息达到一定的条件\",{\"1\":{\"1056\":1}}],[\"如果出现这种情况\",{\"1\":{\"1055\":1}}],[\"如果出现retry时\",{\"1\":{\"1027\":1}}],[\"如果topic有多个分区\",{\"1\":{\"1035\":1}}],[\"如果thread\",{\"1\":{\"541\":1}}],[\"如果this输给了h返回true\",{\"1\":{\"81\":1}}],[\"如果this战胜了h返回true\",{\"1\":{\"81\":1}}],[\"如果key不存在\",{\"1\":{\"1206\":1}}],[\"如果key不存在则是新增\",{\"1\":{\"1206\":1}}],[\"如果kernel中的数据还没有准备好\",{\"1\":{\"679\":1}}],[\"如果kafka是基于zk来进行选举\",{\"1\":{\"1050\":1}}],[\"如果kafka不具备幂等性的\",{\"1\":{\"1027\":1}}],[\"如果若干个消费者的group\",{\"1\":{\"1024\":1}}],[\"如果校验失败\",{\"1\":{\"1005\":1}}],[\"如果校验成功\",{\"1\":{\"1005\":1}}],[\"如果校验通过\",{\"1\":{\"590\":1}}],[\"如果查询结果为空\",{\"1\":{\"1161\":1}}],[\"如果查询的字段在该表的物化视图中都有\",{\"1\":{\"276\":1}}],[\"如果查到了就走成功的流程\",{\"1\":{\"1003\":1}}],[\"如果还是借助数据库主键自增的形式\",{\"1\":{\"997\":1}}],[\"如果还有大进程到来\",{\"1\":{\"183\":1}}],[\"如果job设置过combiner\",{\"1\":{\"979\":1}}],[\"如果用\",{\"1\":{\"1442\":1}}],[\"如果用lua脚本来表示则是这样的\",{\"1\":{\"1146\":1}}],[\"如果用户不存在\",{\"1\":{\"1098\":1}}],[\"如果用户自己对partitioner有需求\",{\"1\":{\"979\":1}}],[\"如果用的是runnable则执行的是runnable中的run方法\",{\"1\":{\"532\":1}}],[\"如果split\",{\"1\":{\"976\":1}}],[\"如果州相等\",{\"1\":{\"974\":1}}],[\"如果namenode长时间没有接受到datanode发送的心跳\",{\"1\":{\"903\":1}}],[\"如果成功设置值\",{\"1\":{\"1142\":1,\"1144\":1}}],[\"如果成功\",{\"1\":{\"885\":1}}],[\"如果本地namenode运行状况良好\",{\"1\":{\"885\":1}}],[\"如果hdfs处于安全模式下\",{\"1\":{\"870\":1}}],[\"如果hive的底层走的是mapreduce\",{\"1\":{\"470\":1}}],[\"如果hive的程序\",{\"1\":{\"435\":2}}],[\"如果作为附件的\",{\"1\":{\"859\":1}}],[\"如果工作在\",{\"1\":{\"847\":1}}],[\"如果所有的数据写完了\",{\"1\":{\"843\":1}}],[\"如果所有值都为null\",{\"1\":{\"340\":1}}],[\"如果内容过大\",{\"1\":{\"840\":1}}],[\"如果内存规整\",{\"1\":{\"630\":1}}],[\"如果内存中没有空闲块\",{\"1\":{\"190\":1}}],[\"如果内存中有空闲块\",{\"1\":{\"190\":1}}],[\"如果内存中空闲空间的总和本来可以满足某进程的要求\",{\"1\":{\"182\":1}}],[\"如果连接数过多\",{\"1\":{\"826\":1}}],[\"如果连续出现丢包\",{\"1\":{\"707\":1}}],[\"如果文件不存在\",{\"1\":{\"822\":1}}],[\"如果文件已存在\",{\"1\":{\"822\":1}}],[\"如果希望用\",{\"1\":{\"822\":1}}],[\"如果目标是接口类型或已经是\",{\"1\":{\"1325\":1}}],[\"如果目标端文件已经存在\",{\"1\":{\"869\":1}}],[\"如果目录还有内容\",{\"1\":{\"822\":1}}],[\"如果目录已存在\",{\"1\":{\"822\":1}}],[\"如果目前没有可用数据时\",{\"1\":{\"610\":1}}],[\"如果设置为文件的末尾\",{\"1\":{\"817\":1}}],[\"如果设备就绪则在设备等待队列中加入一项并继续遍历\",{\"1\":{\"680\":1}}],[\"如果原始\",{\"1\":{\"776\":1}}],[\"如果执行\",{\"1\":{\"776\":1}}],[\"如果执行了程序中的某条指令\",{\"1\":{\"189\":1}}],[\"如果计数为\",{\"1\":{\"775\":1}}],[\"如果计算机按字节编址\",{\"1\":{\"179\":1}}],[\"如果写入后数据大小超过\",{\"1\":{\"773\":1}}],[\"如果改为\",{\"1\":{\"766\":2}}],[\"如果注释掉\",{\"1\":{\"766\":4}}],[\"如果期间又有\",{\"1\":{\"742\":1}}],[\"如果超时\",{\"1\":{\"742\":2}}],[\"如果超出指定长度仍未出现分隔符\",{\"1\":{\"698\":1}}],[\"如果线程由于\",{\"1\":{\"741\":1}}],[\"如果能确保编解码器不会保存状态\",{\"1\":{\"714\":1}}],[\"如果能收到客户端数据\",{\"1\":{\"707\":1}}],[\"如果登录失败\",{\"1\":{\"702\":1}}],[\"如果登录成功\",{\"1\":{\"702\":1}}],[\"如果组不存在返回\",{\"1\":{\"701\":3}}],[\"如果需执行的指令或访问的数据尚未在内存\",{\"1\":{\"689\":1}}],[\"如果需要的值是字符串\",{\"1\":{\"1482\":1}}],[\"如果需要将自定义的对象作为key传递\",{\"1\":{\"956\":1}}],[\"如果需要重复读取\",{\"1\":{\"774\":1}}],[\"如果需要扩容\",{\"1\":{\"601\":1}}],[\"如果需要主线程汇总结果\",{\"1\":{\"592\":1}}],[\"如果需要请走搜索引擎来解决\",{\"1\":{\"481\":1}}],[\"如果需要实现双向同时通信\",{\"1\":{\"162\":1}}],[\"如果需要\",{\"1\":{\"63\":1,\"1411\":1}}],[\"如果他所要访问的页\",{\"1\":{\"688\":1}}],[\"如果某数据被访问过\",{\"1\":{\"687\":1}}],[\"如果某个broker\",{\"1\":{\"1050\":1}}],[\"如果某个redis实例有故障\",{\"1\":{\"526\":1}}],[\"如果某个词词频过高或者整个文件都是同一个词的话\",{\"1\":{\"478\":1}}],[\"如果某个值出现了数据倾斜\",{\"1\":{\"470\":1}}],[\"如果某个数据被访问过\",{\"1\":{\"189\":1}}],[\"如果程序中的某条指令被执行\",{\"1\":{\"687\":1}}],[\"如果程序运行只需要很小的空间的话\",{\"1\":{\"683\":1}}],[\"如果程序运行需要内存的话\",{\"1\":{\"683\":1}}],[\"如果直接把物理地址暴露出来的话会带来严重的问题\",{\"1\":{\"685\":1}}],[\"如果报告了fd后没有被处理\",{\"1\":{\"680\":1}}],[\"如果遍历完所有fd后没有发现就绪设备\",{\"1\":{\"680\":1}}],[\"如果遍历到的词的出现次数大于堆顶上词的出现次数\",{\"1\":{\"477\":1}}],[\"如果立即返回设为null即可\",{\"1\":{\"680\":1}}],[\"如果处理的连接数不是很高的话\",{\"1\":{\"679\":1}}],[\"如果count==0\",{\"1\":{\"668\":1}}],[\"如果construct\",{\"1\":{\"14\":1}}],[\"如果该值为空\",{\"1\":{\"880\":2}}],[\"如果该目录从祖先目录继承了擦除编码策略\",{\"1\":{\"875\":1}}],[\"如果该分支不存在\",{\"1\":{\"668\":3}}],[\"如果该对象逃离了方法的作用范围\",{\"1\":{\"539\":1}}],[\"如果该对象没有逃离方法的作用范围\",{\"1\":{\"539\":1}}],[\"如果该对象足够大的话\",{\"1\":{\"66\":1}}],[\"如果空间不不够\",{\"1\":{\"666\":1}}],[\"如果前一个节点的长度大于等于\",{\"1\":{\"665\":1,\"666\":1}}],[\"如果前一个节点的长度小于\",{\"1\":{\"665\":1,\"666\":1}}],[\"如果值为0\",{\"1\":{\"999\":1}}],[\"如果值都为\",{\"1\":{\"659\":2}}],[\"如果值相同\",{\"1\":{\"403\":3}}],[\"如果你的方法必须要用两个\",{\"1\":{\"1525\":1}}],[\"如果你的集群中至少有两个节点\",{\"1\":{\"1067\":1}}],[\"如果你在方法内部加锁\",{\"1\":{\"1137\":1}}],[\"如果你选择第一种方案\",{\"1\":{\"1121\":1}}],[\"如果你想要最小化gc的中断或停顿时间\",{\"1\":{\"639\":1}}],[\"如果你想要最小化地使用内存和并行开销\",{\"1\":{\"639\":1}}],[\"如果你想要最大化应用程序的吞吐量\",{\"1\":{\"639\":1}}],[\"如果你要调用的java方法所在的jar包不是hive自带的\",{\"1\":{\"343\":1}}],[\"如果字符串常量池中不存在该字符串\",{\"1\":{\"632\":1}}],[\"如果字长为16位的计算机按字编址\",{\"1\":{\"179\":1}}],[\"如果存海量数据\",{\"1\":{\"1171\":1}}],[\"如果存在则是修改\",{\"1\":{\"1206\":1}}],[\"如果存在则将其保存到threadlocal中\",{\"1\":{\"1106\":1}}],[\"如果存在删除\",{\"1\":{\"972\":1,\"973\":1,\"974\":1,\"988\":1}}],[\"如果存在返回数量\",{\"1\":{\"668\":1}}],[\"如果存在一个值不为\",{\"1\":{\"659\":2}}],[\"如果存在\",{\"1\":{\"632\":1,\"668\":2}}],[\"如果存储长度大于此值\",{\"1\":{\"480\":1}}],[\"如果存储的字符串长度几乎相等\",{\"1\":{\"480\":1}}],[\"如果存储的数据范围查过decimal的范围\",{\"1\":{\"480\":1}}],[\"如果拼接的结果调用intern\",{\"1\":{\"632\":1}}],[\"如果实例成员变量是引用变量\",{\"1\":{\"630\":1}}],[\"如果找到\",{\"1\":{\"630\":1}}],[\"如果只有一个分区\",{\"1\":{\"1035\":1}}],[\"如果只有一个线程操作此数据\",{\"1\":{\"627\":1}}],[\"如果只有少量数据\",{\"1\":{\"995\":1}}],[\"如果只有读操作\",{\"1\":{\"539\":1}}],[\"如果父类加载器可以完成类加载任务\",{\"1\":{\"623\":1}}],[\"如果父类加载器还存在父类加载器\",{\"1\":{\"623\":1}}],[\"如果相等就继续判断下一个是否和当前相等\",{\"1\":{\"980\":1}}],[\"如果相等即为连续两天登录\",{\"1\":{\"399\":1}}],[\"如果相同的话直接覆盖\",{\"1\":{\"605\":1}}],[\"如果重写了\",{\"1\":{\"597\":1}}],[\"如果检验没通过\",{\"1\":{\"590\":1}}],[\"如果检测到外部中断信号\",{\"1\":{\"157\":1}}],[\"如果发送的事件对象不是\",{\"1\":{\"1497\":1}}],[\"如果发现\",{\"1\":{\"1476\":1}}],[\"如果发现数据不够\",{\"1\":{\"841\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"588\":1}}],[\"如果发生在slave节点中\",{\"1\":{\"529\":1}}],[\"如果技术竞争比较激烈\",{\"1\":{\"579\":1}}],[\"如果链表长度大于等于阈值8\",{\"1\":{\"579\":1}}],[\"如果链表头节点不为空则通过synchronized来加锁遍历链表\",{\"1\":{\"579\":1}}],[\"如果链表头节点为空\",{\"1\":{\"579\":1}}],[\"如果头节点已经是要查找的key\",{\"1\":{\"579\":1}}],[\"如果扩容过程中\",{\"1\":{\"579\":1}}],[\"如果任务失败\",{\"1\":{\"756\":2}}],[\"如果任务执行失败而终止那么没有任何补救措施\",{\"1\":{\"574\":1}}],[\"如果任务队列已满\",{\"1\":{\"573\":1}}],[\"如果无限制的创建\",{\"1\":{\"570\":1}}],[\"如果主线程希望\",{\"1\":{\"563\":1}}],[\"如果先调用unpark再调用park不会阻塞线程\",{\"1\":{\"549\":1}}],[\"如果变量在线程中共享\",{\"1\":{\"539\":1}}],[\"如果变量没有在线程间共享\",{\"1\":{\"539\":1}}],[\"如果调用了阻塞api\",{\"1\":{\"538\":1}}],[\"如果调用线程的stop\",{\"1\":{\"536\":1}}],[\"如果打断的是正常运行的线程\",{\"1\":{\"534\":1}}],[\"如果打断的是阻塞线程\",{\"1\":{\"534\":1}}],[\"如果此时内存已满\",{\"1\":{\"688\":1}}],[\"如果此时线程锁住了共享资源\",{\"1\":{\"536\":1}}],[\"如果此时操作主从切换\",{\"1\":{\"530\":1}}],[\"如果此时已经有事务对这条数据进行了更改\",{\"1\":{\"507\":1}}],[\"如果此时已经是在最下级的队列\",{\"1\":{\"167\":1}}],[\"如果过期\",{\"1\":{\"529\":1,\"1128\":1}}],[\"如果想要通过beanfactory实现这些功能\",{\"1\":{\"1502\":1}}],[\"如果想要细粒度控制则需要设置association的fetchtype=\",{\"1\":{\"1230\":1}}],[\"如果想要授予r\",{\"1\":{\"925\":1}}],[\"如果想自定义hadoop数据类型\",{\"1\":{\"956\":1}}],[\"如果想重复读取数据\",{\"1\":{\"803\":1}}],[\"如果想随机查看redis中的一个key\",{\"1\":{\"529\":1}}],[\"如果想增加一个产品\",{\"1\":{\"23\":1}}],[\"如果故障转移发生了\",{\"1\":{\"526\":1}}],[\"如果mybatis版本低于3\",{\"1\":{\"1230\":1}}],[\"如果mysql宕机\",{\"1\":{\"506\":2}}],[\"如果map的输出结果真的很大\",{\"1\":{\"979\":1}}],[\"如果master\",{\"1\":{\"526\":1}}],[\"如果master节点异常\",{\"1\":{\"526\":1}}],[\"如果我们请求的url是\",{\"1\":{\"1525\":1}}],[\"如果我们直接使用userid\",{\"1\":{\"1137\":1}}],[\"如果我们的id具有太明显的规则\",{\"1\":{\"1131\":1}}],[\"如果我们采用phone\",{\"1\":{\"1105\":1}}],[\"如果我们想获取生产者消息是否成功\",{\"1\":{\"1025\":1}}],[\"如果我们要查找定位第一个元素和最后一个元素\",{\"1\":{\"665\":1}}],[\"如果我们需要判断某个字符串是否在布隆过滤器中时\",{\"1\":{\"659\":1}}],[\"如果我们给某一行数据加上了排他锁\",{\"1\":{\"510\":1}}],[\"如果我们使用工厂来生产对象\",{\"1\":{\"25\":1}}],[\"如果buffer\",{\"1\":{\"506\":1}}],[\"如果事务执行失败或者调用了rollback\",{\"1\":{\"506\":1}}],[\"如果事务表没有分区和分桶\",{\"1\":{\"293\":1}}],[\"如果对jdk9及以上版本的hotspot虚拟机使用参数\",{\"1\":{\"640\":1}}],[\"如果对象是在内部产生\",{\"1\":{\"627\":1}}],[\"如果对\",{\"1\":{\"493\":1}}],[\"如果进行更新的时候\",{\"1\":{\"493\":1}}],[\"如果进行范围查询\",{\"1\":{\"491\":1}}],[\"如果进程占用处理机很长时间\",{\"1\":{\"167\":1}}],[\"如果进程在就绪队列中等待了很长时间\",{\"1\":{\"167\":1}}],[\"如果把所有同一内部节点的关键字存放在同一块盘中\",{\"1\":{\"488\":1}}],[\"如果更新学生表中的student\",{\"1\":{\"482\":1}}],[\"如果其中出现了错误也会释放锁\",{\"1\":{\"541\":1}}],[\"如果其中一列全为null\",{\"1\":{\"482\":1}}],[\"如果其他进程希望与metastore服务器通信\",{\"1\":{\"244\":1}}],[\"如果where\",{\"1\":{\"481\":1}}],[\"如果可以是consts最好\",{\"1\":{\"481\":1}}],[\"如果可以进入\",{\"1\":{\"168\":1}}],[\"如果左边的值未确定\",{\"1\":{\"481\":1}}],[\"如果修改字段含义或对应字段表示的状态追加时\",{\"1\":{\"480\":1}}],[\"如果拿出来的输入流中还有数据的话\",{\"1\":{\"478\":1}}],[\"如果第一个文件中词的个数小于100\",{\"1\":{\"477\":1}}],[\"如果在引导类上自己添加了\",{\"1\":{\"1453\":1}}],[\"如果在4500ms有线程加锁失败\",{\"1\":{\"1153\":1}}],[\"如果在操作过程中\",{\"1\":{\"1135\":1}}],[\"如果在一些key\",{\"1\":{\"1056\":1}}],[\"如果在生产消息时\",{\"1\":{\"1032\":1}}],[\"如果在这个\",{\"1\":{\"775\":1}}],[\"如果在这个位置\",{\"1\":{\"741\":1}}],[\"如果在指定毫秒内无法连接\",{\"1\":{\"725\":1}}],[\"如果在快表中未找到对应地页表项\",{\"1\":{\"683\":1}}],[\"如果在jdk14中使用xx\",{\"1\":{\"640\":1}}],[\"如果在java文件夹中添加java类\",{\"1\":{\"102\":1}}],[\"如果在扩容过程中其他线程来get\",{\"1\":{\"579\":1}}],[\"如果在线程池中使用threadlocal会造成内存泄漏\",{\"1\":{\"577\":1}}],[\"如果在\",{\"1\":{\"562\":1,\"775\":1,\"1290\":1}}],[\"如果在main线程中调用了t1线程的run方法\",{\"1\":{\"532\":1}}],[\"如果在map中不存在\",{\"1\":{\"477\":1}}],[\"如果在数据量非常大的情况下\",{\"1\":{\"493\":1}}],[\"如果两者都满足\",{\"1\":{\"1134\":1}}],[\"如果两者相同\",{\"1\":{\"596\":1}}],[\"如果两者一致则更新成功\",{\"1\":{\"507\":1}}],[\"如果两次cas都不成功\",{\"1\":{\"588\":1}}],[\"如果两张表比较大\",{\"1\":{\"467\":1}}],[\"如果两个\",{\"1\":{\"749\":1}}],[\"如果两个需要求交集的表太大\",{\"1\":{\"325\":1}}],[\"如果两个进程都想着进入临界区\",{\"1\":{\"169\":1}}],[\"如果两个软件实体无须直接通信\",{\"1\":{\"76\":1}}],[\"如果单个task数据量比较小\",{\"1\":{\"445\":1}}],[\"如果不指定扫描具体包\",{\"1\":{\"1455\":1}}],[\"如果不指定则默认以时间等相关数据命名\",{\"1\":{\"914\":1}}],[\"如果不充足\",{\"1\":{\"1155\":1}}],[\"如果不存在则抛出异常\",{\"1\":{\"1514\":1}}],[\"如果不存在\",{\"1\":{\"1152\":1}}],[\"如果不存在才能创建成功\",{\"1\":{\"701\":1}}],[\"如果不大1\",{\"1\":{\"1135\":1}}],[\"如果不是\",{\"1\":{\"1124\":1,\"1144\":1}}],[\"如果不是特别在意内存\",{\"1\":{\"1104\":1}}],[\"如果不符合\",{\"1\":{\"1099\":2,\"1107\":1}}],[\"如果不一致则什么都不做\",{\"1\":{\"1146\":1}}],[\"如果不一致则不释放锁\",{\"1\":{\"1144\":1}}],[\"如果不一致\",{\"1\":{\"1098\":1}}],[\"如果不合法\",{\"1\":{\"1098\":1}}],[\"如果不为null\",{\"1\":{\"1025\":1}}],[\"如果不为目录设置粘滞位\",{\"1\":{\"920\":1}}],[\"如果不取消\",{\"1\":{\"843\":1}}],[\"如果不用\",{\"1\":{\"828\":1}}],[\"如果不调用\",{\"1\":{\"766\":1,\"775\":1}}],[\"如果不希望永远阻塞\",{\"1\":{\"725\":1}}],[\"如果不处理\",{\"1\":{\"680\":1}}],[\"如果不想编译器使用字节对齐的方式进行分配内存\",{\"1\":{\"663\":1}}],[\"如果不够的话\",{\"1\":{\"663\":1}}],[\"如果不满足需求\",{\"1\":{\"986\":1}}],[\"如果不满足的话\",{\"1\":{\"663\":1}}],[\"如果不满足map\",{\"1\":{\"449\":1}}],[\"如果不考虑同步机制的话\",{\"1\":{\"627\":1}}],[\"如果不同的话\",{\"1\":{\"596\":1}}],[\"如果不包含\",{\"1\":{\"437\":1}}],[\"如果不使用分区表\",{\"1\":{\"413\":1}}],[\"如果不能平均分配\",{\"1\":{\"364\":1}}],[\"如果这两个方法都是要保证事务的\",{\"1\":{\"1514\":1}}],[\"如果这时没有同优先级的线程\",{\"1\":{\"533\":1}}],[\"如果这个数据不存在\",{\"1\":{\"1124\":1}}],[\"如果这个连接不做任何事情就会造成不必要的开销\",{\"1\":{\"609\":1}}],[\"如果这个时候锁恰好没有被占用\",{\"1\":{\"588\":1}}],[\"如果这个1g的大文件中有某个词词频过高\",{\"1\":{\"477\":1}}],[\"如果这个key的出现的次数超过这个范围\",{\"1\":{\"470\":1}}],[\"如果这条数据没有更新或者这条数据不是要更改的数据\",{\"1\":{\"409\":1}}],[\"如果这局猜拳获胜\",{\"1\":{\"81\":1}}],[\"如果取不到返回的默认值\",{\"1\":{\"399\":1}}],[\"如果数据库是空\",{\"1\":{\"1177\":1}}],[\"如果数据量不大\",{\"1\":{\"973\":1}}],[\"如果数据量很大\",{\"1\":{\"486\":1}}],[\"如果数据块丢失\",{\"1\":{\"875\":1}}],[\"如果数据本身是倾斜的\",{\"1\":{\"463\":1}}],[\"如果数据中每一行只有个别字段是json格式字符串\",{\"1\":{\"395\":1}}],[\"如果数据排序后分为三部分\",{\"1\":{\"364\":1}}],[\"如果数据文件格式比较特殊可以使用row\",{\"1\":{\"251\":1}}],[\"如果函数具有over子句\",{\"1\":{\"356\":1}}],[\"如果\",{\"1\":{\"340\":1,\"663\":1,\"694\":4,\"726\":1,\"775\":1,\"776\":1,\"1013\":1,\"1149\":1,\"1155\":2,\"1177\":1,\"1243\":1,\"1292\":1,\"1296\":1,\"1438\":1}}],[\"如果为true\",{\"1\":{\"1532\":1}}],[\"如果为false\",{\"1\":{\"1532\":1}}],[\"如果为null\",{\"1\":{\"1025\":1}}],[\"如果为零\",{\"1\":{\"910\":2}}],[\"如果为\",{\"1\":{\"741\":1}}],[\"如果为负数则倒着数\",{\"1\":{\"336\":1}}],[\"如果为空\",{\"1\":{\"243\":1}}],[\"如果a\",{\"1\":{\"340\":1}}],[\"如果a不等于任何值\",{\"1\":{\"332\":1}}],[\"如果a等于任何值\",{\"1\":{\"332\":1}}],[\"如果a为null\",{\"1\":{\"332\":1}}],[\"如果a为false\",{\"1\":{\"332\":1}}],[\"如果a或b或两者均为true\",{\"1\":{\"332\":1}}],[\"如果a或b为null\",{\"1\":{\"332\":1}}],[\"如果a和b均为true\",{\"1\":{\"332\":1}}],[\"如果除一个要连接的表之外的所有表都很小\",{\"1\":{\"326\":1}}],[\"如果省略streamtable提示\",{\"1\":{\"326\":2}}],[\"如果列都不是原始数据类型\",{\"1\":{\"290\":1}}],[\"如果将一个长度大于等于\",{\"1\":{\"666\":1}}],[\"如果将新分区直接添加到hdfs\",{\"1\":{\"281\":1}}],[\"如果将抽象工厂模式看成汽车配件生产工厂\",{\"1\":{\"20\":1}}],[\"如果删除或更改基础表\",{\"1\":{\"270\":1}}],[\"如果使用哈希\",{\"1\":{\"1104\":1}}],[\"如果使用string\",{\"1\":{\"1104\":1}}],[\"如果使用synchronized给对象上锁之后\",{\"1\":{\"541\":1}}],[\"如果使用方案一\",{\"1\":{\"469\":1}}],[\"如果使用local关键字\",{\"1\":{\"290\":1}}],[\"如果使用delimited表示使用默认的lazysimpleserde类来处理数据\",{\"1\":{\"251\":1}}],[\"如果使用工厂方法模式\",{\"1\":{\"19\":1}}],[\"如果强制转换失败\",{\"1\":{\"248\":1}}],[\"如果定义的数据类型和文件不一致\",{\"1\":{\"248\":1}}],[\"如果定义了这个方法\",{\"1\":{\"69\":1}}],[\"如果被淘汰的页面没有被修改过\",{\"1\":{\"191\":1}}],[\"如果采用第一个方案\",{\"1\":{\"1121\":1}}],[\"如果采用的是myisam存储引擎\",{\"1\":{\"497\":1}}],[\"如果采用连续分配的方式\",{\"1\":{\"189\":1,\"689\":1}}],[\"如果采用方案一\",{\"1\":{\"176\":1}}],[\"如果段过大\",{\"1\":{\"188\":1}}],[\"如果每个表在联接子句中使用相同的列\",{\"1\":{\"326\":1}}],[\"如果每个页面大小是2^k\",{\"1\":{\"184\":1}}],[\"如果每类资源只有1个\",{\"1\":{\"175\":1}}],[\"如果缺页率明显下降\",{\"1\":{\"181\":1}}],[\"如果多道程序的话会冲突\",{\"1\":{\"179\":1}}],[\"如果按照字节编址的话\",{\"1\":{\"179\":1}}],[\"如果系统进入不安全状态\",{\"1\":{\"177\":1}}],[\"如果系统处于安全状态\",{\"1\":{\"177\":1}}],[\"如果分配资源后\",{\"1\":{\"177\":1}}],[\"如果源源不断的有短进程到达\",{\"1\":{\"167\":1}}],[\"如果源源不断的有短作业\",{\"1\":{\"167\":1}}],[\"如果让i\",{\"1\":{\"167\":1}}],[\"如果一致则释放锁\",{\"1\":{\"1144\":1,\"1146\":1}}],[\"如果一致\",{\"1\":{\"1098\":1,\"1106\":1}}],[\"如果一次性将所有的垃圾进行处理\",{\"1\":{\"634\":1}}],[\"如果一本书需要知道第11章是什么标题\",{\"1\":{\"481\":1}}],[\"如果一直重复这样会导致饥饿\",{\"1\":{\"176\":1}}],[\"如果一直得不到服务\",{\"1\":{\"167\":1}}],[\"如果一个类加载器收到了类加载的请求\",{\"1\":{\"623\":1}}],[\"如果一个类被其他的类所继承\",{\"1\":{\"73\":1}}],[\"如果一个文件的大小超过了256块\",{\"1\":{\"197\":1}}],[\"如果一个进程频繁的进行i\",{\"1\":{\"167\":1}}],[\"如果新到达的进程剩余时间比当前运行的进程剩余时间更短\",{\"1\":{\"167\":1}}],[\"如果有拦截器则生成\",{\"1\":{\"1530\":1}}],[\"如果有人插入成功\",{\"1\":{\"1140\":1}}],[\"如果有一个条件不满足则直接结束\",{\"1\":{\"1134\":1}}],[\"如果有这个key则插入失败\",{\"1\":{\"1127\":1}}],[\"如果有session信息\",{\"1\":{\"1098\":1}}],[\"如果有剩余未读字节\",{\"1\":{\"843\":1}}],[\"如果有很多连接建立\",{\"1\":{\"826\":1}}],[\"如果有多个构造方法\",{\"1\":{\"1505\":1}}],[\"如果有多个线程操作此数据\",{\"1\":{\"627\":1}}],[\"如果有多个二级索引\",{\"1\":{\"497\":1}}],[\"如果有事件发生\",{\"1\":{\"610\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"588\":1}}],[\"如果有空闲线程\",{\"1\":{\"570\":1}}],[\"如果有结果不断从一个线程到另一个线程\",{\"1\":{\"547\":1}}],[\"如果有写操作\",{\"1\":{\"539\":1}}],[\"如果有大量的索引\",{\"1\":{\"485\":1}}],[\"如果有全球化需要\",{\"1\":{\"482\":1}}],[\"如果有order\",{\"1\":{\"481\":1}}],[\"如果有两张表按照相同的划分规则\",{\"1\":{\"418\":1}}],[\"如果有两张非常大的表要进行join\",{\"1\":{\"418\":1}}],[\"如果有\",{\"1\":{\"305\":1,\"742\":1,\"876\":1}}],[\"如果有些部分没有用上\",{\"1\":{\"182\":2}}],[\"如果有进程提前归还了一些资源\",{\"1\":{\"177\":1}}],[\"如果有源源不断的进程使用1或者2\",{\"1\":{\"176\":1}}],[\"如果有更加紧急的进程需要cpu\",{\"1\":{\"165\":1}}],[\"如果有新的需求\",{\"1\":{\"15\":1}}],[\"如果是基于redis\",{\"1\":{\"1202\":1}}],[\"如果是不同的\",{\"1\":{\"1177\":1}}],[\"如果是活跃粉丝\",{\"1\":{\"1166\":1}}],[\"如果是大v\",{\"1\":{\"1166\":1}}],[\"如果是个普通的人\",{\"1\":{\"1166\":1}}],[\"如果是没有传入时间\",{\"1\":{\"1152\":1}}],[\"如果是对于\",{\"1\":{\"1151\":1}}],[\"如果是null\",{\"1\":{\"1124\":1}}],[\"如果是副本\",{\"1\":{\"1068\":1}}],[\"如果是正常断开\",{\"1\":{\"840\":1}}],[\"如果是\",{\"1\":{\"743\":1,\"840\":2,\"1042\":1,\"1144\":1,\"1152\":1,\"1155\":1,\"1157\":1,\"1177\":1,\"1440\":1}}],[\"如果是可读\",{\"1\":{\"742\":1}}],[\"如果是可接入\",{\"1\":{\"742\":1}}],[\"如果是数组\",{\"1\":{\"631\":1}}],[\"如果是数组的话还会包含数组长度\",{\"1\":{\"540\":1}}],[\"如果是动态变化的\",{\"1\":{\"626\":1}}],[\"如果是固定的就可能出现stackoverflowerror\",{\"1\":{\"626\":1}}],[\"如果是共享锁的话会将连着的占有共享锁的线程一同释放\",{\"1\":{\"583\":1}}],[\"如果是互斥锁+共享锁的情况下\",{\"1\":{\"583\":1}}],[\"如果是前者需要考虑\",{\"1\":{\"560\":1}}],[\"如果是在休眠的时候被打断\",{\"1\":{\"536\":1}}],[\"如果是innodb\",{\"1\":{\"497\":1}}],[\"如果是小文件可以自动将小文件进行合并\",{\"1\":{\"435\":1}}],[\"如果是1就是负数了\",{\"1\":{\"998\":1}}],[\"如果是1\",{\"1\":{\"191\":1,\"1135\":1}}],[\"如果是0\",{\"1\":{\"191\":1}}],[\"如果是同一进程内的线程切换\",{\"1\":{\"163\":1}}],[\"如果是多线程环境\",{\"1\":{\"66\":1}}],[\"如果没这个判断\",{\"1\":{\"742\":1}}],[\"如果没抢到\",{\"1\":{\"588\":1}}],[\"如果没读空\",{\"1\":{\"162\":1}}],[\"如果没有特殊指定\",{\"1\":{\"1501\":1}}],[\"如果没有指定接口\",{\"1\":{\"1325\":1}}],[\"如果没有设置过期时间\",{\"1\":{\"1205\":1}}],[\"如果没有出错\",{\"1\":{\"1193\":1}}],[\"如果没有卡过自动释放锁的时间点\",{\"1\":{\"1143\":1}}],[\"如果没有过期\",{\"1\":{\"1128\":1}}],[\"如果没有命中则直接返回空数据\",{\"1\":{\"1128\":1}}],[\"如果没有获得到\",{\"1\":{\"1127\":1}}],[\"如果没有缓存来作为\",{\"1\":{\"1114\":1}}],[\"如果没有则拦截\",{\"1\":{\"1106\":1}}],[\"如果没有则需要在双亲委派模式下对相应的类进行加载\",{\"1\":{\"630\":1}}],[\"如果没有session信息\",{\"1\":{\"1098\":1}}],[\"如果没有有\",{\"1\":{\"876\":1}}],[\"如果没有读到数据\",{\"1\":{\"827\":1}}],[\"如果没有连接建立\",{\"1\":{\"827\":1}}],[\"如果没有失败\",{\"1\":{\"756\":1}}],[\"如果没有大量的闲置连接和死亡连接\",{\"1\":{\"680\":1}}],[\"如果没有找到文件\",{\"1\":{\"630\":1}}],[\"如果没有\",{\"1\":{\"630\":1,\"1411\":1}}],[\"如果没有相符的hashcode\",{\"1\":{\"596\":1}}],[\"如果没有竞争\",{\"1\":{\"564\":1}}],[\"如果没有partition\",{\"1\":{\"358\":1}}],[\"如果没有足够的内存空间\",{\"1\":{\"179\":1}}],[\"如果没有就把自身的标志位置为true\",{\"1\":{\"169\":1}}],[\"如果没有并发性\",{\"1\":{\"155\":1}}],[\"如果没有定义\",{\"1\":{\"69\":1}}],[\"如果没有定义selltickets接口\",{\"1\":{\"60\":1}}],[\"如果没有接口使用cglib代理\",{\"1\":{\"61\":1}}],[\"如果管道没写满\",{\"1\":{\"162\":1}}],[\"如果提供vx和qq同时发送文件则不能实现\",{\"1\":{\"155\":1}}],[\"如果子工程坐标中的groupid和version与父工程一致\",{\"1\":{\"107\":1}}],[\"如果现在又有新的动力源或者新的颜色的话\",{\"1\":{\"77\":1}}],[\"如果instance不为null\",{\"1\":{\"66\":2}}],[\"如果接口增加一个方法\",{\"1\":{\"61\":1}}],[\"如果要的不是\",{\"1\":{\"1411\":1}}],[\"如果要降序则在命令的z后面添加rev即可\",{\"1\":{\"1211\":1}}],[\"如果要让redis以后台方式启动\",{\"1\":{\"1196\":1}}],[\"如果要求数据一定不能丢失\",{\"1\":{\"1043\":1}}],[\"如果要将order\",{\"1\":{\"315\":2}}],[\"如果要读写多个离散存储的数据块\",{\"1\":{\"209\":1}}],[\"如果要买火车票的话\",{\"1\":{\"58\":1}}],[\"如果要加同一个产品族的话\",{\"1\":{\"39\":1}}],[\"如果要实现新产品直接修改工厂类\",{\"1\":{\"29\":1}}],[\"如果要更换对象\",{\"1\":{\"25\":1}}],[\"如果创建的时候直接new该对象\",{\"1\":{\"25\":1}}],[\"如果创建这个类的实例\",{\"1\":{\"17\":1}}],[\"如果参数更多呢\",{\"1\":{\"17\":1}}],[\"如果产品之间的差异性很大\",{\"1\":{\"15\":1}}],[\"如果去欧洲国家去旅游的话\",{\"1\":{\"4\":1}}],[\"如\",{\"1\":{\"9\":1,\"41\":1,\"165\":1,\"195\":1,\"211\":1,\"481\":2,\"493\":1,\"785\":1,\"792\":1,\"1065\":1,\"1240\":1,\"1254\":3,\"1355\":2,\"1472\":1,\"1505\":4}}],[\"对方考取的学校\",{\"1\":{\"1525\":1}}],[\"对方用户不存在或者不在线\",{\"1\":{\"703\":1}}],[\"对加了\",{\"1\":{\"1505\":1}}],[\"对静态方法\",{\"1\":{\"1298\":1}}],[\"对依赖注入阶段的扩展\",{\"1\":{\"1257\":1}}],[\"对拦截器代码进行了相关优化\",{\"1\":{\"1232\":1}}],[\"对性能有一定影响\",{\"1\":{\"1189\":1}}],[\"对服务器压力巨大\",{\"1\":{\"1166\":1}}],[\"对版本号进行+1\",{\"1\":{\"1135\":1}}],[\"对产品口碑\",{\"1\":{\"1113\":1}}],[\"对文档数据根据不同属性进行的分类标识\",{\"1\":{\"1064\":1}}],[\"对资源本身没有任何副作用\",{\"1\":{\"1004\":1}}],[\"对商品信息文件和订单信息文件进行join处理\",{\"1\":{\"988\":1}}],[\"对排序后的键值对调用reduce方法\",{\"1\":{\"980\":1}}],[\"对所有溢出文件进行最终的merge合并\",{\"1\":{\"965\":1}}],[\"对切片中的数据按照一定的规则读取解析返回<key\",{\"1\":{\"965\":1}}],[\"对values进行迭代遍历加出该key的总个数\",{\"1\":{\"961\":1}}],[\"对volatile变量之间会加入读屏障\",{\"1\":{\"557\":1}}],[\"对volatile变量的写指令后会加入写屏障\",{\"1\":{\"557\":1}}],[\"对hdfs的指定目录进行透明加密\",{\"1\":{\"928\":1}}],[\"对该文件具有完全的权限\",{\"1\":{\"917\":1}}],[\"对重要目录进行创建snapshot的操作\",{\"1\":{\"912\":1}}],[\"对自己感兴趣的事件进行处理\",{\"1\":{\"787\":1}}],[\"对某些数据包又显得不够\",{\"1\":{\"697\":1}}],[\"对socket进行扫描时是线性扫描\",{\"1\":{\"680\":1}}],[\"对student\",{\"1\":{\"276\":1}}],[\"对字符串的操作效率不高\",{\"1\":{\"662\":1}}],[\"对字符串操作时\",{\"1\":{\"662\":1}}],[\"对程序员很不友好\",{\"1\":{\"662\":1}}],[\"对程序员的要求比较高\",{\"1\":{\"17\":1}}],[\"对给定元素再次进行相同的哈希计算\",{\"1\":{\"659\":1}}],[\"对延迟反而带来负面效果\",{\"1\":{\"637\":1}}],[\"对齐填充\",{\"1\":{\"631\":1,\"713\":1,\"714\":1,\"723\":1}}],[\"对内容进行复制\",{\"1\":{\"566\":1}}],[\"对i++操作的方法加同步锁\",{\"1\":{\"560\":1}}],[\"对共享变量的读取\",{\"1\":{\"557\":1}}],[\"对共享变量的改动都会同步到主存中\",{\"1\":{\"557\":1,\"567\":1}}],[\"对共享数据设置初始值\",{\"1\":{\"173\":1}}],[\"对比生产者和消费者\",{\"1\":{\"1021\":1}}],[\"对比\",{\"1\":{\"549\":1,\"1284\":1}}],[\"对阻塞状态的线程来说只要他们一直不唤醒\",{\"1\":{\"538\":1}}],[\"对业务的影响非常大\",{\"1\":{\"530\":1}}],[\"对redo\",{\"1\":{\"506\":1}}],[\"对用于连接的字段创建索引\",{\"1\":{\"493\":1}}],[\"对用户不透明\",{\"1\":{\"181\":1}}],[\"对\",{\"1\":{\"493\":1,\"792\":1,\"1298\":1,\"1499\":1}}],[\"对分组或者排序的字段进行索引\",{\"1\":{\"493\":1}}],[\"对分区表进行查询时\",{\"1\":{\"305\":1}}],[\"对索引进行范围检索\",{\"1\":{\"481\":1}}],[\"对500个小文件进行多路排序的思路如下\",{\"1\":{\"478\":1}}],[\"对500个小文件进行多路排序\",{\"1\":{\"478\":1}}],[\"对遍历到的每个词x\",{\"1\":{\"477\":1}}],[\"对数据库访问压力过大\",{\"1\":{\"1126\":1}}],[\"对数据库进行恢复\",{\"1\":{\"506\":1}}],[\"对数据被其他事务修改持乐观态度\",{\"1\":{\"507\":1}}],[\"对数据被其他事务修改持保守态度\",{\"1\":{\"507\":1}}],[\"对数据按照某个条件进行查询后再进行\",{\"1\":{\"493\":1}}],[\"对数据进行过滤\",{\"1\":{\"718\":1}}],[\"对数据进行排序的时候\",{\"1\":{\"493\":1}}],[\"对数据进行分组查询\",{\"1\":{\"493\":1}}],[\"对数据的分布的信息\",{\"1\":{\"457\":1}}],[\"对数据结构操作的一组过程\",{\"1\":{\"173\":1}}],[\"对有关联关系的操作进行解析时\",{\"1\":{\"453\":1}}],[\"对执行计划进行格式化\",{\"1\":{\"441\":1}}],[\"对每个map任务的带宽限速\",{\"1\":{\"869\":1}}],[\"对每个分区的数据进行编号\",{\"1\":{\"403\":3}}],[\"对每个不同的实现都需要定义一个子类\",{\"1\":{\"86\":1}}],[\"对表所有行求和\",{\"1\":{\"360\":1}}],[\"对column中非null进行统计\",{\"1\":{\"351\":1}}],[\"对两张表进行join关联查询\",{\"1\":{\"348\":1}}],[\"对前n个进行脱敏替换\",{\"1\":{\"342\":1}}],[\"对这张表进行查询\",{\"1\":{\"316\":1}}],[\"对物化视图进行查询并返回结果\",{\"1\":{\"276\":1}}],[\"对美国新冠疫情的一份数据进行按state进行分成5桶\",{\"1\":{\"265\":1}}],[\"对全体数据进行处理存在困难时\",{\"1\":{\"263\":1}}],[\"对桶的个数进行取模\",{\"1\":{\"263\":1}}],[\"对外是一个虚拟视图\",{\"1\":{\"779\":1}}],[\"对外暴露的是\",{\"1\":{\"574\":1}}],[\"对外暴露的接口容易暴露信息\",{\"1\":{\"501\":1}}],[\"对外暴露服务地址\",{\"1\":{\"240\":1}}],[\"对外提供静态方法获取该对象\",{\"1\":{\"66\":7,\"68\":2,\"69\":2}}],[\"对一个表进行查询\",{\"1\":{\"276\":1}}],[\"对一个比较大型的项目进行了模块拆分\",{\"1\":{\"107\":1}}],[\"对一些设备的错误进行处理\",{\"1\":{\"210\":1}}],[\"对设备的访问权限也不一样\",{\"1\":{\"210\":1}}],[\"对换性\",{\"1\":{\"189\":1}}],[\"对换区空间只占磁盘空间的小部分\",{\"1\":{\"181\":1}}],[\"对可剥夺的资源不会产生\",{\"1\":{\"175\":1}}],[\"对系统资源的竞争\",{\"1\":{\"175\":1}}],[\"对不可剥夺资源的竞争可能会引起死锁\",{\"1\":{\"175\":1}}],[\"对不同的临界资源需要设置不同的互斥信号量\",{\"1\":{\"172\":1}}],[\"对不起\",{\"1\":{\"28\":1}}],[\"对信号量的操作只有三种\",{\"1\":{\"171\":1}}],[\"对请求访问的进程\",{\"1\":{\"168\":1}}],[\"对其他调度算法的折中权衡\",{\"1\":{\"167\":1}}],[\"对长作业不利\",{\"1\":{\"167\":1}}],[\"对短作业有利\",{\"1\":{\"167\":1}}],[\"对短作业不利\",{\"1\":{\"167\":1}}],[\"对短作业来说用户体验不好\",{\"1\":{\"167\":1}}],[\"对新的进程各种数据的恢复\",{\"1\":{\"165\":1}}],[\"对原来代码没有侵入性\",{\"1\":{\"1128\":1}}],[\"对原来运行进程各种数据的保存\",{\"1\":{\"165\":1}}],[\"对原始\",{\"1\":{\"775\":1,\"776\":1}}],[\"对原始表student\",{\"1\":{\"276\":1}}],[\"对原始类功能进行增强\",{\"1\":{\"10\":1}}],[\"对操作系统不透明\",{\"1\":{\"163\":1}}],[\"对操作系统透明\",{\"1\":{\"163\":1}}],[\"对应配置\",{\"1\":{\"1462\":1}}],[\"对应第2\",{\"1\":{\"1445\":1}}],[\"对应第1步\",{\"1\":{\"1445\":1}}],[\"对应代码\",{\"1\":{\"1285\":1}}],[\"对应应该落在\",{\"1\":{\"1177\":1}}],[\"对应的解析器\",{\"1\":{\"1485\":2}}],[\"对应的自动配置类为\",{\"1\":{\"1454\":1}}],[\"对应的控制器方法\",{\"1\":{\"1438\":1}}],[\"对应的低级通知\",{\"0\":{\"1337\":1}}],[\"对应的表有两个\",{\"1\":{\"1159\":1}}],[\"对应的代码如下\",{\"1\":{\"1043\":1}}],[\"对应的offset是什么\",{\"1\":{\"1025\":1}}],[\"对应pid\",{\"1\":{\"1029\":1}}],[\"对应目录是hdfs上的目录\",{\"1\":{\"989\":1}}],[\"对应一个maptask处理\",{\"1\":{\"976\":1}}],[\"对应着reducetask\",{\"1\":{\"960\":1}}],[\"对应着maptask\",{\"1\":{\"958\":1}}],[\"对应\",{\"1\":{\"740\":1,\"1445\":1}}],[\"对应于do类名也是单数形式\",{\"1\":{\"480\":1}}],[\"对应于在代理对象上调用的接口方法的\",{\"1\":{\"59\":1}}],[\"对应分区的大小\",{\"1\":{\"182\":1}}],[\"对应jar包的作用范围\",{\"1\":{\"100\":1}}],[\"对银行工作人员进行评分等\",{\"1\":{\"83\":1}}],[\"对修改关闭\",{\"1\":{\"72\":1}}],[\"对扩展开放\",{\"1\":{\"72\":1}}],[\"对接口进行代理\",{\"1\":{\"60\":1}}],[\"对具体原型类\",{\"1\":{\"54\":1}}],[\"对象装配\",{\"1\":{\"1489\":2}}],[\"对象绑定与类型转换\",{\"0\":{\"1367\":1}}],[\"对象也能够销毁\",{\"1\":{\"1252\":1}}],[\"对象注册到\",{\"1\":{\"1248\":1}}],[\"对象被垃圾回收\",{\"1\":{\"855\":1}}],[\"对象仅维护了此内存的虚引用\",{\"1\":{\"855\":1}}],[\"对象还在\",{\"1\":{\"775\":1}}],[\"对象中不能\",{\"1\":{\"753\":1}}],[\"对象中显示的都是李四\",{\"1\":{\"54\":1}}],[\"对象异步接收结果线程\",{\"1\":{\"737\":1}}],[\"对象变为要传输的数据\",{\"1\":{\"723\":1}}],[\"对象真正存储的有效数据\",{\"1\":{\"631\":1}}],[\"对象的类型是代理类型\",{\"1\":{\"1294\":1}}],[\"对象的内部结构\",{\"1\":{\"1243\":1}}],[\"对象的内存布局\",{\"0\":{\"631\":1}}],[\"对象的初始计数为\",{\"1\":{\"775\":1}}],[\"对象的创建非常复杂\",{\"1\":{\"53\":1}}],[\"对象创建才刚刚开始\",{\"1\":{\"630\":1}}],[\"对象头\",{\"0\":{\"540\":1},\"1\":{\"631\":1}}],[\"对象\",{\"1\":{\"480\":1,\"574\":1,\"664\":4,\"723\":1,\"737\":2,\"738\":1,\"753\":3,\"754\":1,\"759\":1,\"775\":1,\"785\":1,\"1248\":1,\"1294\":1,\"1339\":1,\"1343\":1,\"1369\":1,\"1416\":1,\"1438\":2,\"1444\":1,\"1449\":1,\"1497\":1}}],[\"对象间的耦合度低\",{\"1\":{\"77\":1}}],[\"对象r1和r2是同一个对象\",{\"1\":{\"51\":1}}],[\"对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中\",{\"1\":{\"7\":1}}],[\"对象适配器模式\",{\"0\":{\"7\":1}}],[\"对于声明式事务\",{\"1\":{\"1515\":1}}],[\"对于多例的对象因为要频繁创建代理对象\",{\"1\":{\"1512\":1}}],[\"对于多级分区表来说也是一样的\",{\"1\":{\"285\":1}}],[\"对于单例的对象无需频繁创建代理对象\",{\"1\":{\"1512\":1}}],[\"对于单例对象来讲\",{\"1\":{\"1294\":1}}],[\"对于aspectj的实现也有两种\",{\"1\":{\"1508\":1}}],[\"对于a的每个mapper\",{\"1\":{\"326\":1}}],[\"对于beanfactory而言\",{\"1\":{\"1501\":1}}],[\"对于bucket\",{\"1\":{\"293\":1}}],[\"对于资源有限\",{\"1\":{\"1501\":1}}],[\"对于资源的分配\",{\"1\":{\"163\":1}}],[\"对于没有实现接口的对象\",{\"1\":{\"1500\":1}}],[\"对于存储的数据\",{\"1\":{\"1182\":1}}],[\"对于新型的feed流的的效果\",{\"1\":{\"1166\":1}}],[\"对于新增的数据\",{\"1\":{\"409\":1}}],[\"对于传统的模式的内容解锁\",{\"1\":{\"1166\":1}}],[\"对于作为用户的你来说\",{\"1\":{\"1066\":1}}],[\"对于作业来说\",{\"1\":{\"166\":1}}],[\"对于客户端交互的接口\",{\"1\":{\"1005\":1}}],[\"对于部署的不同雪花算法服务中\",{\"1\":{\"1001\":1}}],[\"对于机器码\",{\"1\":{\"1001\":1}}],[\"对于机架数少于奇偶校验单元数的群集\",{\"1\":{\"875\":1}}],[\"对于机架容错\",{\"1\":{\"875\":1}}],[\"对于水平分表就需要保证表中\",{\"1\":{\"997\":1}}],[\"对于mapreduce框架来说\",{\"1\":{\"984\":1}}],[\"对于maptask究竟给哪个reducetask处理\",{\"1\":{\"968\":1}}],[\"对于map阶段的输出结果我们可以假设为<hadoop\",{\"1\":{\"961\":1}}],[\"对于map每行有两列分别为key\",{\"1\":{\"346\":1}}],[\"对于keyout和valueout要根据具体的业务进行判断\",{\"1\":{\"961\":1}}],[\"对于一些数据\",{\"1\":{\"1205\":1}}],[\"对于一个新来的用户\",{\"1\":{\"925\":1}}],[\"对于一个文件或文件夹而言\",{\"1\":{\"925\":1}}],[\"对于一次i\",{\"1\":{\"679\":1}}],[\"对于目录\",{\"1\":{\"918\":1}}],[\"对于文件\",{\"1\":{\"918\":1}}],[\"对于大多不变的数据\",{\"1\":{\"913\":1}}],[\"对于大表来说\",{\"1\":{\"325\":1}}],[\"对于每一个雪花算法服务\",{\"1\":{\"998\":1}}],[\"对于每一个分组\",{\"1\":{\"961\":1}}],[\"对于每一个socket\",{\"1\":{\"679\":1}}],[\"对于每个块\",{\"1\":{\"902\":1}}],[\"对于datanode出现了故障\",{\"1\":{\"883\":1}}],[\"对于delete\",{\"1\":{\"506\":1}}],[\"对于delete语句\",{\"1\":{\"293\":1}}],[\"对于ha的解决方案\",{\"1\":{\"882\":1}}],[\"对于段式管理\",{\"1\":{\"683\":1}}],[\"对于页表所需的内存空间\",{\"1\":{\"683\":1}}],[\"对于缓存i\",{\"1\":{\"679\":1}}],[\"对于32位操作系统而言\",{\"1\":{\"676\":1}}],[\"对于引用类型来说\",{\"1\":{\"597\":2}}],[\"对于基本类型来说\",{\"1\":{\"597\":1}}],[\"对于队列中的线程是公平的\",{\"1\":{\"588\":1}}],[\"对于jdk\",{\"1\":{\"579\":2}}],[\"对于join\",{\"1\":{\"461\":1}}],[\"对于局部变量不管是基本类型还是包装类型都不需要考虑\",{\"1\":{\"560\":1}}],[\"对于update\",{\"1\":{\"506\":1}}],[\"对于update就是更新后的数据\",{\"1\":{\"293\":1}}],[\"对于insert\",{\"1\":{\"506\":1}}],[\"对于insert就是插入的数据\",{\"1\":{\"293\":1}}],[\"对于可重复读\",{\"1\":{\"503\":1}}],[\"对于可变长记录文件\",{\"1\":{\"195\":1}}],[\"对于核心业务\",{\"1\":{\"502\":1}}],[\"对于count\",{\"1\":{\"497\":1}}],[\"对于等值查询来说\",{\"1\":{\"491\":1}}],[\"对于联合索引的情况\",{\"1\":{\"491\":1}}],[\"对于遍历到的词x\",{\"1\":{\"477\":1}}],[\"对于right\",{\"1\":{\"461\":1}}],[\"对于left\",{\"1\":{\"461\":1}}],[\"对于local\",{\"1\":{\"283\":1}}],[\"对于修改的数据\",{\"1\":{\"409\":1}}],[\"对于上面两个问题的解决方案如下\",{\"1\":{\"374\":1}}],[\"对于该案例就是抽取第一桶的数据\",{\"1\":{\"369\":1}}],[\"对于sum+窗口函数\",{\"1\":{\"360\":1}}],[\"对于有\",{\"1\":{\"353\":1}}],[\"对于grouping\",{\"1\":{\"353\":1}}],[\"对于不受容器管理的对象不能增强\",{\"1\":{\"1511\":1}}],[\"对于不符合手机号规则的数据直接返回\",{\"1\":{\"344\":1}}],[\"对于不同的中断信号\",{\"1\":{\"157\":1}}],[\"对于敏感数据往往需要进行脱敏处理\",{\"1\":{\"344\":1}}],[\"对于从a中检索到的每一行\",{\"1\":{\"326\":1}}],[\"对于从c中检索的每一行\",{\"1\":{\"326\":1}}],[\"对于下面的代码\",{\"1\":{\"325\":1}}],[\"对于载入的数据又三个字段\",{\"1\":{\"285\":1}}],[\"对于加载数据的一些基本操作看之前的文章即可\",{\"1\":{\"284\":1}}],[\"对于其元数据并不会删除\",{\"1\":{\"258\":1}}],[\"对于临界资源的互斥访问可以分为四个部分\",{\"1\":{\"168\":1}}],[\"对于临界资源的访问\",{\"1\":{\"168\":1}}],[\"对于抢占式还需要在就绪队列变化时\",{\"1\":{\"167\":1}}],[\"对于非抢占式只需要在进程主动放弃处理机时进程调度即可\",{\"1\":{\"167\":1}}],[\"对于非基本类型属性\",{\"1\":{\"51\":1}}],[\"对于长作业来说\",{\"1\":{\"167\":1}}],[\"对于进程来说\",{\"1\":{\"166\":1}}],[\"对于系统开销\",{\"1\":{\"163\":1}}],[\"对于并发性\",{\"1\":{\"163\":1}}],[\"对于输入是416∗416的图像\",{\"1\":{\"138\":1}}],[\"对于输入为256∗256的图像\",{\"1\":{\"136\":1}}],[\"对于三种\",{\"1\":{\"100\":1}}],[\"对于\",{\"1\":{\"66\":1,\"775\":1,\"997\":2,\"1443\":1}}],[\"对于自行车的生产就可以使用建造者模式\",{\"1\":{\"14\":1}}],[\"对上面的代码大家应该很熟\",{\"1\":{\"43\":1}}],[\"对组件进行一定顺序的组装\",{\"1\":{\"14\":1}}],[\"对他中的抽象的未实现的方法给出实现\",{\"1\":{\"9\":1}}],[\"字母的地形上飞跃\",{\"1\":{\"1113\":1}}],[\"字典树\",{\"0\":{\"668\":1}}],[\"字节数据常常会有此情况\",{\"1\":{\"698\":1}}],[\"字节就会缓冲在接收方的滑动窗口中\",{\"1\":{\"694\":1}}],[\"字节扩展至\",{\"1\":{\"666\":1}}],[\"字节的内存\",{\"1\":{\"1174\":1}}],[\"字节的指令类型\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"字节的序列化方式\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"字节的版本\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"字节的魔数\",{\"1\":{\"713\":1,\"714\":1,\"723\":1}}],[\"字节的新节点加入到压缩列表的表头节点\",{\"1\":{\"666\":1}}],[\"字节的空间进行编码\",{\"1\":{\"665\":1}}],[\"字节的空间来保存这个长度值\",{\"1\":{\"665\":2,\"666\":3}}],[\"字节对齐\",{\"1\":{\"663\":1}}],[\"字节对齐的方式给变量分配内存\",{\"1\":{\"663\":1}}],[\"字节跳动\",{\"1\":{\"633\":1}}],[\"字节码层面分析synchronized\",{\"1\":{\"541\":1}}],[\"字节\",{\"1\":{\"480\":1,\"663\":1,\"665\":3,\"666\":3,\"692\":1,\"693\":3,\"697\":1,\"1021\":1}}],[\"字节大小扩展为\",{\"1\":{\"666\":1}}],[\"字节大小\",{\"1\":{\"374\":1,\"666\":2}}],[\"字节流\",{\"1\":{\"9\":1}}],[\"字符来标识字符串结尾了\",{\"1\":{\"663\":1}}],[\"字符标识\",{\"1\":{\"662\":1}}],[\"字符将被误认为是字符串结尾\",{\"1\":{\"662\":1}}],[\"字符\",{\"1\":{\"662\":3,\"663\":1}}],[\"字符作为结尾标记有个缺陷\",{\"1\":{\"662\":1}}],[\"字符数组\",{\"1\":{\"663\":1}}],[\"字符数组的结构\",{\"1\":{\"661\":1,\"662\":1}}],[\"字符数组存在一些缺陷\",{\"1\":{\"661\":1}}],[\"字符数组来实现字符串\",{\"1\":{\"661\":1}}],[\"字符串与\",{\"0\":{\"805\":1}}],[\"字符串结尾还是会加上\",{\"1\":{\"663\":1}}],[\"字符串操作函数不高效且不安全\",{\"1\":{\"662\":1}}],[\"字符串里面不能包含有\",{\"1\":{\"662\":1}}],[\"字符串里面不能含有\",{\"1\":{\"662\":1}}],[\"字符串的结尾是以\",{\"1\":{\"662\":1}}],[\"字符串中的所有内容\",{\"1\":{\"662\":1}}],[\"字符串后面\",{\"1\":{\"662\":1}}],[\"字符串\",{\"1\":{\"662\":1,\"663\":1,\"1217\":1}}],[\"字符串在\",{\"1\":{\"661\":1}}],[\"字符串拼接到\",{\"1\":{\"662\":1}}],[\"字符串拼接\",{\"0\":{\"632\":1}}],[\"字符串不加单引号会导致索引失效\",{\"1\":{\"505\":1}}],[\"字符串转小写函数\",{\"1\":{\"336\":2}}],[\"字符串转大写函数\",{\"1\":{\"336\":2}}],[\"字符串截取函数\",{\"1\":{\"336\":2}}],[\"字符串连接函数\",{\"1\":{\"336\":2}}],[\"字符串反转函数\",{\"1\":{\"336\":2}}],[\"字符串长度函数\",{\"1\":{\"336\":2}}],[\"字符串函数\",{\"0\":{\"336\":1},\"1\":{\"336\":1}}],[\"字符串类型\",{\"1\":{\"248\":1}}],[\"字符流\",{\"1\":{\"9\":1}}],[\"字段约束等等信息\",{\"1\":{\"1185\":1}}],[\"字段数据类型\",{\"1\":{\"1185\":1}}],[\"字段更新器\",{\"1\":{\"562\":1}}],[\"字段上建立索引时\",{\"1\":{\"493\":1}}],[\"字段需要创建索引\",{\"1\":{\"493\":1}}],[\"字段创建了索引\",{\"1\":{\"493\":1}}],[\"字段的数值有唯一性的限制\",{\"1\":{\"493\":1}}],[\"字段长度短\",{\"1\":{\"480\":1}}],[\"字段允许适当冗余\",{\"1\":{\"480\":1}}],[\"字段名\",{\"1\":{\"480\":1,\"1185\":1}}],[\"字段名必须使用小写字母或数字\",{\"1\":{\"480\":1}}],[\"字段之间以\",{\"1\":{\"348\":1}}],[\"字段之间分隔符\",{\"1\":{\"252\":1}}],[\"字段顺序类型等元信息\",{\"1\":{\"239\":1}}],[\"字段\",{\"0\":{\"1064\":1},\"1\":{\"237\":1,\"256\":1,\"353\":1,\"986\":1}}],[\"但会走\",{\"1\":{\"1411\":1}}],[\"但具体转换工作是\",{\"1\":{\"1398\":1}}],[\"但分为两种情况\",{\"1\":{\"1366\":1}}],[\"但碰到循环依赖会提前至依赖注入之前执行\",{\"1\":{\"1333\":1}}],[\"但避免了反射\",{\"1\":{\"1321\":1}}],[\"但\",{\"1\":{\"1298\":1,\"1472\":1}}],[\"但理念上殊途同归\",{\"1\":{\"1297\":1}}],[\"但加在\",{\"1\":{\"1294\":1}}],[\"但它们是组合了\",{\"1\":{\"1245\":1}}],[\"但它也存在以下缺点\",{\"1\":{\"77\":1}}],[\"但依然存在一些问题\",{\"1\":{\"1223\":1}}],[\"但底层数据结构却差别很大\",{\"1\":{\"1211\":1}}],[\"但拆分表了之后\",{\"1\":{\"1131\":1}}],[\"但内存读写速度没有跟上\",{\"1\":{\"1115\":1}}],[\"但内存已无空闲空间时\",{\"1\":{\"690\":1}}],[\"但有一个主题突然被删除了\",{\"1\":{\"1037\":1}}],[\"但后续轮询策略表现更佳\",{\"1\":{\"1033\":1}}],[\"但运行在\",{\"1\":{\"951\":1}}],[\"但非常少\",{\"1\":{\"951\":1}}],[\"但非阻塞模式下\",{\"1\":{\"827\":1}}],[\"但仍将尝试在多个节点之间分布条带化文件以保留节点级容错能力\",{\"1\":{\"875\":1}}],[\"但流量低的场景\",{\"1\":{\"867\":1}}],[\"但这样做的一个最大问题是无法订制每种数据源的详细配置\",{\"1\":{\"1454\":1}}],[\"但这样又会导致占用内存过多\",{\"1\":{\"843\":1}}],[\"但这种说法是不完整的\",{\"1\":{\"1252\":1}}],[\"但这也会影响查询的性能\",{\"1\":{\"1126\":1}}],[\"但这时\",{\"1\":{\"837\":1}}],[\"但这并不是说明insert没有用武之地\",{\"1\":{\"286\":1}}],[\"但长时间\",{\"1\":{\"826\":1}}],[\"但治标不治本\",{\"1\":{\"826\":1}}],[\"但多线程下\",{\"1\":{\"826\":1}}],[\"但线程不必阻塞\",{\"1\":{\"827\":1}}],[\"但线程相当于闲置\",{\"1\":{\"826\":1}}],[\"但线程池中的线程不会回收\",{\"1\":{\"577\":1}}],[\"但实际上\",{\"1\":{\"795\":1}}],[\"但实际上observer角色并非主动地去观察\",{\"1\":{\"45\":1}}],[\"但经过\",{\"1\":{\"787\":1}}],[\"但不会在处理完后从\",{\"1\":{\"837\":1}}],[\"但不会改变写指针位置\",{\"1\":{\"772\":1}}],[\"但不会超过cpu的核心数\",{\"1\":{\"564\":1}}],[\"但也要注意及时主动释放\",{\"1\":{\"769\":1}}],[\"但读写性能高\",{\"1\":{\"769\":1}}],[\"但都是要等任务结束\",{\"1\":{\"756\":1}}],[\"但只要后续病人源源不断地来\",{\"1\":{\"755\":1}}],[\"但工人与\",{\"1\":{\"748\":1}}],[\"但除了第一个处于\",{\"1\":{\"726\":1}}],[\"但要注意\",{\"1\":{\"1290\":1}}],[\"但要注意如果\",{\"1\":{\"817\":1}}],[\"但要注意对于编解码器类\",{\"1\":{\"714\":1}}],[\"但要解决的问题\",{\"1\":{\"10\":1}}],[\"但主人家则总是给私塾先生以白菜豆腐为菜\",{\"1\":{\"709\":1}}],[\"但通过分隔符来断句不是很好\",{\"1\":{\"709\":1}}],[\"但通常都是编译或汇编时在转换为绝对地址\",{\"1\":{\"179\":1}}],[\"但应用程序没有感知到\",{\"1\":{\"707\":1}}],[\"但发生超时\",{\"1\":{\"694\":1}}],[\"但发生死锁的时候就一定是处于不安全状态\",{\"1\":{\"177\":1}}],[\"但低效也是相对的\",{\"1\":{\"680\":1}}],[\"但sc是null\",{\"1\":{\"827\":1}}],[\"但select\",{\"1\":{\"680\":1}}],[\"但sum\",{\"1\":{\"482\":1}}],[\"但缺点是具有一定的错误识别率和删除难度\",{\"1\":{\"658\":1}}],[\"但缺点是synchronized属于重量级锁\",{\"1\":{\"558\":1}}],[\"但并非为了挑选一个最好的收集器出来\",{\"1\":{\"638\":1}}],[\"但当每次使用代理对象的任意方法时\",{\"1\":{\"1294\":1}}],[\"但当你执行\",{\"1\":{\"576\":1}}],[\"但当非守护线程执行完毕后\",{\"1\":{\"537\":1}}],[\"但每个任务执行时间较短的情况\",{\"1\":{\"574\":1}}],[\"但每次只使用其中的某一族产品\",{\"1\":{\"41\":1}}],[\"但因为其不在\",{\"1\":{\"562\":1}}],[\"但函数需要无副作用\",{\"1\":{\"562\":4}}],[\"但wait需要和synchronized一起使用\",{\"1\":{\"546\":1}}],[\"但条件不满足进入waiting状态的线程\",{\"1\":{\"541\":1}}],[\"但写redo\",{\"1\":{\"506\":1}}],[\"但如果数据报文超过\",{\"1\":{\"848\":1}}],[\"但如果内容本身包含了分隔符\",{\"1\":{\"698\":1}}],[\"但如果这部分数据很少的话\",{\"1\":{\"694\":1}}],[\"但如果这么做\",{\"1\":{\"694\":1}}],[\"但如果程序所要访问的页\",{\"1\":{\"688\":1}}],[\"但如果每次读写数据都需要磁盘io\",{\"1\":{\"506\":1}}],[\"但如果提前调入的页面大多数都没被访问过\",{\"1\":{\"192\":1}}],[\"但truncate无事务且不触发trigger\",{\"1\":{\"482\":1}}],[\"但提高查找速度是明显的\",{\"1\":{\"481\":1,\"493\":1}}],[\"但必须考虑数据一致\",{\"1\":{\"480\":1}}],[\"但在linux下默认是区分大小写\",{\"1\":{\"480\":1}}],[\"但在实际过程中\",{\"1\":{\"191\":1}}],[\"但往往很多的join场景不满足map\",{\"1\":{\"467\":1}}],[\"但留下空位\",{\"1\":{\"403\":1}}],[\"但没有修改过的页面\",{\"1\":{\"191\":1}}],[\"但修改过的页面\",{\"1\":{\"191\":1}}],[\"但各段之间可以不相邻\",{\"1\":{\"187\":1}}],[\"但各个进程之间信息交换又是必须的\",{\"1\":{\"162\":1}}],[\"但代价有点大\",{\"1\":{\"178\":1}}],[\"但又独立运作\",{\"1\":{\"923\":1}}],[\"但又必须彻底释放\",{\"1\":{\"775\":1}}],[\"但又对自己已有的资源保持不放\",{\"1\":{\"175\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"175\":1}}],[\"但由于\",{\"1\":{\"1042\":1}}],[\"但由于某种原因这些数据在接收时\",{\"1\":{\"809\":1}}],[\"但由于接收方处理不及时且窗口大小足够大\",{\"1\":{\"694\":1}}],[\"但由于每次只能调入一页\",{\"1\":{\"192\":1}}],[\"但由于该进程需要连续的内存空间\",{\"1\":{\"182\":1}}],[\"但由于没有空闲cpu\",{\"1\":{\"160\":1}}],[\"但由于资源有限\",{\"1\":{\"155\":1}}],[\"但我们不能把所有的数据都放入到\",{\"1\":{\"1171\":1}}],[\"但我们能够同时运行gta和其他软件\",{\"1\":{\"155\":1}}],[\"但我们知道他们对构造方法中的字节流类\",{\"1\":{\"9\":1}}],[\"但一个时间段内只允许一个进程访问该资源\",{\"1\":{\"155\":1}}],[\"但微观上是交替发生的\",{\"1\":{\"155\":1}}],[\"但其底层实现还是用多路复用模拟了异步\",{\"1\":{\"856\":1}}],[\"但其中个别部分易变时\",{\"1\":{\"87\":1}}],[\"但其接口同新系统的接口不一致\",{\"1\":{\"8\":1}}],[\"但某些步骤的具体实现还未知\",{\"1\":{\"83\":1}}],[\"但是可以有多个\",{\"1\":{\"1525\":1}}],[\"但是可以获取共享锁\",{\"1\":{\"582\":1}}],[\"但是user实体类中具有role实体类\",{\"1\":{\"1230\":1}}],[\"但是并不能正确删除\",{\"1\":{\"1230\":1}}],[\"但是set集合是不能排序的\",{\"1\":{\"1162\":1}}],[\"但是你想想是吗\",{\"1\":{\"1155\":1}}],[\"但是你事后不能改变分片的数量\",{\"1\":{\"1067\":1}}],[\"但是会有一个总共的加锁时间\",{\"1\":{\"1153\":1}}],[\"但是会造成太多过期key没有被删除\",{\"1\":{\"520\":1}}],[\"但是假设在主机还没有来得及把数据写入到从机去的时候\",{\"1\":{\"1153\":1}}],[\"但是假设在线程1没有走完的时候\",{\"1\":{\"1126\":1}}],[\"但是毕竟没有锁住\",{\"1\":{\"1149\":1}}],[\"但是目前还剩下一个问题锁不住\",{\"1\":{\"1147\":1}}],[\"但是目前的情况是\",{\"1\":{\"1137\":1}}],[\"但是线程1他会接着往后执行\",{\"1\":{\"1145\":1}}],[\"但是线程1\",{\"1\":{\"1143\":1}}],[\"但是却无法和线程1和线程2实现互斥\",{\"1\":{\"1138\":1}}],[\"但是锁对象却不是同一个\",{\"1\":{\"1138\":1}}],[\"但是锁已经释放也会导致问题\",{\"1\":{\"1137\":1}}],[\"但是以上做法依然有问题\",{\"1\":{\"1137\":1}}],[\"但是以上代码还是存在问题\",{\"1\":{\"1137\":1}}],[\"但是以上这种方式通过测试发现会有很多失败的情况\",{\"1\":{\"1136\":1}}],[\"但是乐观锁比较适合更新数据\",{\"1\":{\"1137\":1}}],[\"但是100个人中只有1个人能扣减成功\",{\"1\":{\"1136\":1}}],[\"但是现在还有原子性问题\",{\"1\":{\"1147\":1}}],[\"但是现在由于线程1已经操作过了\",{\"1\":{\"1135\":1}}],[\"但是现在这个拦截器他只是拦截需要被拦截的路径\",{\"1\":{\"1109\":1}}],[\"但是他们的锁对象写的虽然和服务器a一样\",{\"1\":{\"1138\":1}}],[\"但是他自己满足version=1\",{\"1\":{\"1135\":1}}],[\"但是他没有最大连接数的限制\",{\"1\":{\"680\":1}}],[\"但是还没有来得及去扣减\",{\"1\":{\"1135\":1}}],[\"但是还没有调用start\",{\"1\":{\"538\":1}}],[\"但是数据库中一定存在这个数据\",{\"1\":{\"1123\":1}}],[\"但是数据库中也没有数据\",{\"1\":{\"1123\":1}}],[\"但是数据累积太多一定对实时系统它的实时性是有说影响的\",{\"1\":{\"1055\":1}}],[\"但是中间如果没有人查询\",{\"1\":{\"1121\":1}}],[\"但是方案一调用者如何处理呢\",{\"1\":{\"1121\":1}}],[\"但是缓存也会增加代码复杂度和运营的成本\",{\"1\":{\"1114\":1}}],[\"但是redis的key是共享的\",{\"1\":{\"1105\":1}}],[\"但是关于key的处理\",{\"1\":{\"1105\":1}}],[\"但是每当任意一台服务器的session修改时\",{\"1\":{\"1102\":1}}],[\"但是第二次这个用户访问到了第二台tomcat\",{\"1\":{\"1102\":1}}],[\"但是对于topic\",{\"1\":{\"1035\":1}}],[\"但是工程量和实现难度比较大\",{\"1\":{\"1005\":1}}],[\"但是前端进行拦截器显然是针对普通用户\",{\"1\":{\"1005\":1}}],[\"但是接口反馈超时\",{\"1\":{\"1003\":1}}],[\"但是又会导致最终结果被分散到多个不同文件中\",{\"1\":{\"988\":1}}],[\"但是又违背了空闲让进以及有限等待原则\",{\"1\":{\"169\":1}}],[\"但是通常情况下mapreduce中reduce的并行度是极小的\",{\"1\":{\"988\":1}}],[\"但是通过group\",{\"1\":{\"356\":1}}],[\"但是用户和用户组管理涉及到root权限等\",{\"1\":{\"924\":1}}],[\"但是找不到问题的具体存放位置\",{\"1\":{\"883\":1}}],[\"但是要付出的成本更高\",{\"1\":{\"882\":1}}],[\"但是是两个接口\",{\"1\":{\"756\":1}}],[\"但是channel对象并没有正确连接\",{\"1\":{\"753\":1}}],[\"但是页式管理其中的页并无任何实际意义\",{\"1\":{\"683\":1}}],[\"但是空间性能的提升是以时间为代价的\",{\"1\":{\"683\":1}}],[\"但是所有socket都很活跃的情况下\",{\"1\":{\"680\":1}}],[\"但是同样有缺点\",{\"1\":{\"680\":1}}],[\"但是文件描述符这一个概念往往只适用于unix\",{\"1\":{\"677\":1}}],[\"但是缺点是其返回的结果是概率性的\",{\"1\":{\"658\":1}}],[\"但是从java程序的视角来看\",{\"1\":{\"630\":1}}],[\"但是流是单向的只能读或者写\",{\"1\":{\"610\":1}}],[\"但是limit是可以修改的\",{\"1\":{\"610\":1}}],[\"但是需要flip\",{\"1\":{\"610\":1}}],[\"但是它应该满足幂等性\",{\"1\":{\"1004\":2}}],[\"但是它没有直接使用\",{\"1\":{\"661\":1}}],[\"但是它仅能得到当前可用数据\",{\"1\":{\"610\":1}}],[\"但是它自己可以获取共享锁\",{\"1\":{\"582\":1}}],[\"但是能实现多个接口\",{\"1\":{\"595\":1}}],[\"但是公平锁会判断队列中是否有线程处于等待状态\",{\"1\":{\"588\":1}}],[\"但是处理任务队列中的任务\",{\"1\":{\"571\":1}}],[\"但是其内部的同步代码还是会发生重排序\",{\"1\":{\"559\":1}}],[\"但是其string底层并没有采用c的字符串\",{\"1\":{\"515\":1}}],[\"但是没有收到任何的信息\",{\"1\":{\"1003\":1}}],[\"但是没有被即使清理\",{\"1\":{\"529\":1}}],[\"但是没有遵循让权等待\",{\"1\":{\"169\":1}}],[\"但是也带来了新的问题\",{\"1\":{\"506\":1}}],[\"但是也有抢占式的版本\",{\"1\":{\"167\":1}}],[\"但是具体要恢复到哪个版本\",{\"1\":{\"503\":1}}],[\"但是因为联合索引中有lastname\",{\"1\":{\"495\":1}}],[\"但是值的类型不可控\",{\"1\":{\"483\":3}}],[\"但是很大\",{\"1\":{\"680\":1}}],[\"但是很容易可以发现问题\",{\"1\":{\"477\":1}}],[\"但是很适合用于用一台计算机控制多个相同对象的场合\",{\"1\":{\"182\":1}}],[\"但是这个时候还有一个问题\",{\"1\":{\"1171\":1}}],[\"但是这样添加锁\",{\"1\":{\"1137\":1}}],[\"但是这样我们分析过\",{\"1\":{\"1136\":1}}],[\"但是这样也会造成效率的降低\",{\"1\":{\"680\":1}}],[\"但是这种方案具有两个大问题\",{\"1\":{\"1102\":1}}],[\"但是这种方式业内比较少用\",{\"1\":{\"997\":1}}],[\"但是这并不是最佳的执行方案\",{\"1\":{\"455\":1}}],[\"但是这回降低系统性能\",{\"1\":{\"182\":1}}],[\"但是hive会不智能的选择\",{\"1\":{\"452\":1}}],[\"但是hive依旧默认挨个执行每个stage\",{\"1\":{\"446\":1}}],[\"但是hive的索引与关系型数据库中的索引并不相同\",{\"1\":{\"420\":1}}],[\"但是如果每个访问的用户都保存到redis中\",{\"1\":{\"1179\":1}}],[\"但是如果以上两个条件都不满足\",{\"1\":{\"1152\":1}}],[\"但是如果卡顿的时间超长\",{\"1\":{\"1149\":1}}],[\"但是如果现在是服务器b的tomcat内部\",{\"1\":{\"1138\":1}}],[\"但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适\",{\"1\":{\"1105\":1}}],[\"但是如果进行水平分表之后\",{\"1\":{\"997\":1}}],[\"但是如果在代码中\",{\"1\":{\"963\":1}}],[\"但是如果在字段col1上面存在索引时\",{\"1\":{\"422\":1}}],[\"但是如果很多的话\",{\"1\":{\"680\":1}}],[\"但是如果保存的元素数量增加了\",{\"1\":{\"667\":1}}],[\"但是如果发现有相同hashcode值的对象\",{\"1\":{\"596\":1}}],[\"但是如果竞争激烈\",{\"1\":{\"561\":1}}],[\"但是如果数据加载的文件整体就是json文件\",{\"1\":{\"395\":1}}],[\"但是如果子类对这些已经实现的方法任意修改\",{\"1\":{\"73\":1}}],[\"但是效率不高\",{\"1\":{\"367\":1}}],[\"但是效率不一样\",{\"1\":{\"325\":1}}],[\"但是我运行出来的grouping\",{\"1\":{\"353\":1}}],[\"但是由于mysql性能本身一般\",{\"1\":{\"1140\":1}}],[\"但是由于人们目前无法预知进程的若干个页面中\",{\"1\":{\"690\":1}}],[\"但是由于成员变量里有\",{\"1\":{\"663\":1}}],[\"但是由于state=0\",{\"1\":{\"591\":1}}],[\"但是由于加锁本身也需要消耗资源\",{\"1\":{\"506\":1}}],[\"但是由于udf分类标准扩大化\",{\"1\":{\"334\":1}}],[\"但是由于300号块内存放了再下一组的信息\",{\"1\":{\"198\":1}}],[\"但是只返回左表全部数据\",{\"1\":{\"324\":1}}],[\"但是两个字段只能是同一个字段\",{\"1\":{\"314\":1}}],[\"但是此时他的锁到期了\",{\"1\":{\"1145\":1}}],[\"但是此时他获得到了锁的资源\",{\"1\":{\"1126\":1}}],[\"但是此时redis中没有数据\",{\"1\":{\"1123\":1}}],[\"但是此时r1已经分配出去三个了\",{\"1\":{\"178\":1}}],[\"但是此时的查询结果还不能确定\",{\"1\":{\"304\":1}}],[\"但是不超过16\",{\"1\":{\"1202\":1}}],[\"但是不会影响我们之前记录的6\",{\"1\":{\"1167\":1}}],[\"但是不会exit\",{\"1\":{\"640\":1}}],[\"但是不设置过期时间\",{\"1\":{\"1126\":1}}],[\"但是不抛出异常\",{\"1\":{\"573\":1}}],[\"但是不能保证数据平均分区\",{\"1\":{\"968\":1}}],[\"但是不能取代reentrantlock\",{\"1\":{\"590\":1}}],[\"但是不能在只查询源表的时候\",{\"1\":{\"348\":1}}],[\"但是不能跟着聚合函数\",{\"1\":{\"304\":1}}],[\"但是不保证成功\",{\"1\":{\"248\":1}}],[\"但是存储元数据的数据库在单独的进程中运行\",{\"1\":{\"243\":1}}],[\"但是一次只能支持一个活动用户\",{\"1\":{\"242\":1}}],[\"但是最基础的分层思想\",{\"1\":{\"224\":1}}],[\"但是实现困难\",{\"1\":{\"191\":1}}],[\"但是有了过期时间之后\",{\"1\":{\"1147\":1}}],[\"但是有如下区别\",{\"1\":{\"610\":1}}],[\"但是有外部碎片\",{\"1\":{\"182\":1}}],[\"但是有些情况下需要简化系统结构\",{\"1\":{\"14\":1}}],[\"但是之后p1进程又申请资源r2\",{\"1\":{\"175\":1}}],[\"但是发生循环等待的时候未必死锁\",{\"1\":{\"175\":1}}],[\"但是与ground\",{\"1\":{\"139\":1}}],[\"但是运行阶段\",{\"1\":{\"100\":1}}],[\"但是办理具体业务却因人而异\",{\"1\":{\"83\":1}}],[\"但是似乎组装的电脑的cpu只能是intel的\",{\"1\":{\"74\":1}}],[\"但是在\",{\"1\":{\"1177\":1}}],[\"但是在集群模式下就不行了\",{\"1\":{\"1138\":1}}],[\"但是在重构数据完成前\",{\"1\":{\"1126\":1}}],[\"但是在连接数少并且连接都十分活跃的情况下\",{\"1\":{\"680\":1}}],[\"但是在加载自定义string类的时候会率先使用引导类加载器进行加载\",{\"1\":{\"624\":1}}],[\"但是在一些别的场景下\",{\"1\":{\"446\":1}}],[\"但是在java文件夹中添加xml文件\",{\"1\":{\"102\":1}}],[\"但是在getinstance\",{\"1\":{\"66\":1}}],[\"但是在现实生活中许多工厂是综合型的工厂\",{\"1\":{\"36\":1}}],[\"但是\",{\"1\":{\"66\":1,\"196\":1,\"281\":1,\"634\":1,\"663\":1,\"664\":1,\"679\":2,\"683\":1,\"997\":1,\"1512\":1,\"1525\":1}}],[\"但是到jdk1\",{\"1\":{\"61\":1}}],[\"但构件间的建造顺序是稳定的\",{\"1\":{\"16\":1}}],[\"但将它们组合在一起的算法却相对稳定\",{\"1\":{\"16\":1}}],[\"但同时也加重了抽象建造者类的职责\",{\"1\":{\"14\":1}}],[\"但组件接口定义和自己要求的接口定义不同\",{\"1\":{\"8\":1}}],[\"使之更易用\",{\"1\":{\"792\":1}}],[\"使之成为新对象的一部分\",{\"1\":{\"77\":1}}],[\"使它们并发执行\",{\"1\":{\"688\":1}}],[\"使程序继续执行下去\",{\"1\":{\"688\":1}}],[\"使每个页面的大小与内存物理块的大小相同\",{\"1\":{\"683\":1}}],[\"使其元素不超过给定数量\",{\"1\":{\"616\":1}}],[\"使一个线程从某通道发送请求读取数据\",{\"1\":{\"610\":1}}],[\"使字段与do类解耦\",{\"1\":{\"483\":1}}],[\"使磁头定位到目标扇区所需要的时间\",{\"1\":{\"204\":1}}],[\"使多个用户可以共享使用一个文件\",{\"1\":{\"194\":1}}],[\"使操作系统获得计算机的控制权\",{\"1\":{\"157\":1}}],[\"使上面定义的单例类\",{\"1\":{\"68\":1}}],[\"使用该注解表示开启了全局异常的捕获\",{\"1\":{\"1526\":1}}],[\"使用bean\",{\"1\":{\"1505\":1}}],[\"使用bucket\",{\"0\":{\"469\":1},\"1\":{\"450\":1}}],[\"使用不同的bean\",{\"1\":{\"1504\":1}}],[\"使用上较为古怪\",{\"1\":{\"1472\":1}}],[\"使用上一个处理器的处理结果\",{\"1\":{\"784\":1}}],[\"使用默认转换器\",{\"1\":{\"1376\":1}}],[\"使用lambdaquerywrapper的情况\",{\"1\":{\"1235\":1}}],[\"使用lambdaquerywrapper和lambdaupdatewrapper替代querywrapper和updatewrapper\",{\"1\":{\"1235\":1}}],[\"使用querywrapper的情况\",{\"1\":{\"1235\":1}}],[\"使用非常简单\",{\"1\":{\"1218\":1}}],[\"使用方式如下\",{\"1\":{\"1199\":1}}],[\"使用方法\",{\"1\":{\"989\":1}}],[\"使用这把锁咱们就不使用主从了\",{\"1\":{\"1153\":1}}],[\"使用这种方式\",{\"1\":{\"634\":1}}],[\"使用规则等\",{\"1\":{\"1133\":1}}],[\"使用锁来解决\",{\"1\":{\"1126\":1}}],[\"使用完成后再进行回收\",{\"1\":{\"1100\":1}}],[\"使用分配策略尽可能达到最公平的分配\",{\"1\":{\"1038\":1}}],[\"使用分布式缓存技术将小的数据集进行分布式缓存\",{\"1\":{\"990\":1}}],[\"使用匿名内部类实现callback接口\",{\"1\":{\"1025\":1}}],[\"使用下面的命令来消费\",{\"1\":{\"1017\":1}}],[\"使用kafka内置的测试程序\",{\"1\":{\"1016\":1}}],[\"使用消息队列可以将系统进行解耦合\",{\"1\":{\"1009\":1}}],[\"使用掩码\",{\"1\":{\"999\":1}}],[\"使用线程启动jc\",{\"1\":{\"991\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"570\":1}}],[\"使用工具类toolrunner提交程序\",{\"1\":{\"962\":1,\"988\":1}}],[\"使用工具类toolrunner提交mapreduce作业\",{\"1\":{\"962\":1}}],[\"使用工厂方法模式对上例进行改进\",{\"1\":{\"34\":1}}],[\"使用工厂方法模式就可以完美的解决\",{\"1\":{\"31\":1}}],[\"使用命令前需要设置相关参数并重启hdfs服务\",{\"1\":{\"926\":1}}],[\"使用命令fuser将进程杀死\",{\"1\":{\"885\":1}}],[\"使用服务的用户先要证明自己的身份\",{\"1\":{\"916\":1}}],[\"使用此信息namenode知道如何从块中构建文件\",{\"1\":{\"903\":1}}],[\"使用此依赖范围的\",{\"1\":{\"100\":4}}],[\"使用2n+1台journalnode存储共享edits\",{\"1\":{\"886\":1}}],[\"使用journal\",{\"1\":{\"884\":1}}],[\"使用json函数处理\",{\"1\":{\"393\":1}}],[\"使用zookeeper中zkfc来实现主备切换\",{\"1\":{\"884\":1}}],[\"使用如下方式写入\",{\"1\":{\"808\":1}}],[\"使用如下方式读取\",{\"1\":{\"807\":1}}],[\"使用更流畅\",{\"1\":{\"781\":1}}],[\"使用更方便的机器\",{\"1\":{\"154\":1}}],[\"使用同一块底层内存\",{\"1\":{\"777\":1}}],[\"使用同一个框架内的不同\",{\"1\":{\"107\":1}}],[\"使用的\",{\"1\":{\"1442\":1}}],[\"使用的线程都是守护线程\",{\"1\":{\"858\":1}}],[\"使用的还是\",{\"1\":{\"855\":1}}],[\"使用的就是直接内存了\",{\"1\":{\"775\":1}}],[\"使用的是操作系统内存\",{\"1\":{\"855\":1}}],[\"使用的是\",{\"1\":{\"775\":1}}],[\"使用它调整超时时间\",{\"1\":{\"725\":1}}],[\"使用它可以提供非阻塞的高伸缩性网络\",{\"1\":{\"610\":1}}],[\"使用虚拟地址访问内存有以下优势\",{\"1\":{\"685\":1}}],[\"使用布隆过滤器中的哈希函数对元素值进行计算\",{\"1\":{\"659\":1}}],[\"使用当前类加载器以classloader+包名+类名为key进行查找对应的\",{\"1\":{\"630\":1}}],[\"使用反序列化\",{\"1\":{\"629\":1}}],[\"使用一个atomicinteger来表示状态和数量\",{\"1\":{\"571\":1}}],[\"使用一个大小为500大小的堆\",{\"1\":{\"478\":1}}],[\"使用支持原子类型操作的类\",{\"1\":{\"560\":1}}],[\"使用可释放的定时锁\",{\"1\":{\"551\":1}}],[\"使用能减少回表的次数\",{\"1\":{\"505\":1}}],[\"使用联合索引时\",{\"1\":{\"505\":1}}],[\"使用where约束来自数据库的数据\",{\"1\":{\"504\":1}}],[\"使用最频繁的字段放到联合索引左侧\",{\"1\":{\"493\":1}}],[\"使用字符串时\",{\"1\":{\"566\":1}}],[\"使用字符串前缀创建索引\",{\"1\":{\"493\":1}}],[\"使用字节码技术生成代理类\",{\"1\":{\"61\":1}}],[\"使用列数据类型小的字段创建索引\",{\"1\":{\"493\":1}}],[\"使用isnull\",{\"1\":{\"482\":1}}],[\"使用inputformat进行数据读取操作\",{\"1\":{\"984\":1}}],[\"使用insert+select语法将数据加载到分桶表中\",{\"1\":{\"266\":1}}],[\"使用intel处理器\",{\"1\":{\"74\":1}}],[\"使用10mb内存分别对\",{\"1\":{\"478\":1}}],[\"使用多路归并排序对大文件进行排序\",{\"1\":{\"478\":1}}],[\"使用小顶堆\",{\"1\":{\"477\":1}}],[\"使用了谓词下推\",{\"1\":{\"460\":1}}],[\"使用了多尺度特征\",{\"1\":{\"138\":1}}],[\"使用spring\",{\"1\":{\"1520\":2,\"1524\":1}}],[\"使用stringredistemplate\",{\"1\":{\"1223\":1}}],[\"使用strategy模式可以整体地替换算法的实现部分\",{\"1\":{\"79\":1}}],[\"使用snapshot来进行整个集群\",{\"1\":{\"912\":1}}],[\"使用select\",{\"1\":{\"679\":1}}],[\"使用semaphore限流\",{\"1\":{\"591\":1}}],[\"使用skew\",{\"0\":{\"470\":1}}],[\"使用sort\",{\"1\":{\"450\":1}}],[\"使用条件\",{\"1\":{\"444\":1}}],[\"使用条件式生成对抗网络\",{\"1\":{\"130\":1}}],[\"使用hash索引还需要对数据重新排序\",{\"1\":{\"491\":1}}],[\"使用hashmap统计每个小文件单词出现的频次\",{\"1\":{\"477\":1}}],[\"使用hive的过程中\",{\"1\":{\"444\":1}}],[\"使用hdfs命令创建分区文件夹\",{\"1\":{\"281\":1}}],[\"使用clone\",{\"1\":{\"629\":1}}],[\"使用char定长字符串类型\",{\"1\":{\"480\":1}}],[\"使用concat\",{\"1\":{\"383\":1}}],[\"使用case\",{\"1\":{\"380\":1}}],[\"使用cglib实现动态代理\",{\"1\":{\"61\":1}}],[\"使用udtf时的正确做法\",{\"1\":{\"378\":1}}],[\"使用order\",{\"1\":{\"367\":1}}],[\"使用optional配置终止传递\",{\"1\":{\"104\":1}}],[\"使用之前课程创建好的student表数据\",{\"1\":{\"340\":1}}],[\"使用事务表\",{\"0\":{\"298\":1}}],[\"使用mapper读取订单数据和缓存的商品数据进行连接\",{\"1\":{\"990\":1}}],[\"使用mapper处理订单数据和商品数据\",{\"1\":{\"988\":1}}],[\"使用maven的构建命令可以快速打包\",{\"1\":{\"91\":1}}],[\"使用msck命令进行修复\",{\"1\":{\"281\":2}}],[\"使用add\",{\"1\":{\"279\":1}}],[\"使用rebuild进行重构\",{\"1\":{\"276\":1}}],[\"使用runtime类中的方法\",{\"1\":{\"70\":1}}],[\"使用视图优化嵌套查询\",{\"1\":{\"272\":1}}],[\"使用视图的好处\",{\"0\":{\"272\":1}}],[\"使用动态分区要设置两个参数\",{\"1\":{\"261\":1}}],[\"使用哪个serde类进行序列化\",{\"1\":{\"251\":1}}],[\"使用第二代命令行工具执行\",{\"1\":{\"244\":1}}],[\"使用第三方提供的组件\",{\"1\":{\"8\":1}}],[\"使用epoll没有前面两者的线性下降的性能问题\",{\"1\":{\"680\":1}}],[\"使用explode函数+lateral\",{\"1\":{\"349\":1}}],[\"使用extended\",{\"1\":{\"328\":1}}],[\"使用external关键字\",{\"1\":{\"258\":1}}],[\"使用excludes标签配置依赖的排除\",{\"1\":{\"105\":1}}],[\"使用elt\",{\"1\":{\"228\":1}}],[\"使用单\",{\"1\":{\"214\":1}}],[\"使用单例类\",{\"1\":{\"65\":1}}],[\"使用户看到的内存容量\",{\"1\":{\"189\":1}}],[\"使用开关中断实现\",{\"1\":{\"171\":1}}],[\"使用dependencymanagement标签配置对依赖的管理\",{\"1\":{\"107\":1}}],[\"使用propagation属性声明事物的传播行为\",{\"1\":{\"1515\":1}}],[\"使用proxy获取代理对象\",{\"1\":{\"59\":1}}],[\"使用pc寄存器存储字节码指令地址有什么用呢\",{\"0\":{\"625\":1}}],[\"使用parent标签指定当前工程的父工程\",{\"1\":{\"107\":1}}],[\"使用框架时所需要的\",{\"1\":{\"107\":1}}],[\"使用委托这种弱关联关系可以很方便地整体替换算法\",{\"1\":{\"79\":1}}],[\"使用金士顿作为内存条\",{\"1\":{\"74\":1}}],[\"使用希捷希捷硬盘取数据\",{\"1\":{\"74\":1}}],[\"使用希捷硬盘存储数据\",{\"1\":{\"74\":1}}],[\"使用组合关系\",{\"1\":{\"73\":1}}],[\"使用真实对象的类加载器即可\",{\"1\":{\"59\":1}}],[\"使用具体原型类中的\",{\"1\":{\"50\":1}}],[\"使用迭代器遍历集合\",{\"1\":{\"43\":1}}],[\"使用迭代器遍历\",{\"1\":{\"43\":1}}],[\"使用\",{\"0\":{\"433\":1,\"453\":1},\"1\":{\"23\":1,\"91\":1,\"449\":1,\"493\":1,\"571\":1,\"663\":1,\"753\":1,\"791\":1,\"796\":1,\"818\":1,\"821\":1,\"826\":1,\"827\":1,\"847\":1,\"854\":1,\"855\":3,\"1244\":1,\"1325\":3,\"1438\":2,\"1525\":1}}],[\"使用场景\",{\"0\":{\"16\":1,\"41\":1,\"53\":1,\"63\":1},\"1\":{\"574\":1}}],[\"使用建造者模式可以有效的封装变化\",{\"1\":{\"15\":1}}],[\"使得程序串行执行\",{\"1\":{\"1140\":1}}],[\"使得各个部分的数据产生关联性\",{\"1\":{\"875\":1}}],[\"使得\",{\"1\":{\"663\":1}}],[\"使得集合中的元素可以根据score进行有序排列\",{\"1\":{\"515\":1}}],[\"使得每个进程都可以在一个时间片内完成\",{\"1\":{\"167\":1}}],[\"使得一个进程内可以并发处理各种任务\",{\"1\":{\"163\":1}}],[\"使得软件包依赖的管理和使用更加智能和方便\",{\"1\":{\"97\":1}}],[\"使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中\",{\"1\":{\"97\":1}}],[\"使得开发人员能够更加专注于应用程序的开发和维护\",{\"1\":{\"94\":1}}],[\"使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤\",{\"1\":{\"83\":1}}],[\"使得系统中类的个数成倍增加\",{\"1\":{\"23\":1}}],[\"使得创建过程更加清晰\",{\"1\":{\"15\":1}}],[\"使得相同的创建过程可以创建不同的产品对象\",{\"1\":{\"15\":1}}],[\"使得同样的构建过程可以创建不同的表示\",{\"1\":{\"12\":1}}],[\"使得原本由于接口不兼容而不能一起工作的那些类能一起工作\",{\"1\":{\"4\":1}}],[\"当得到真实的视图对象view后\",{\"1\":{\"1530\":1}}],[\"当dispatcherservlet根据handlermapping得到对应请求的handler后\",{\"1\":{\"1530\":1}}],[\"当dfsclient与数据在同一个机器上时\",{\"1\":{\"872\":1}}],[\"当浏览器发送一个请求\",{\"1\":{\"1438\":1}}],[\"当中\",{\"1\":{\"1248\":1}}],[\"当中断发生后\",{\"1\":{\"157\":1}}],[\"当中断发生时\",{\"1\":{\"157\":1}}],[\"当延迟加载开启后\",{\"1\":{\"1230\":1}}],[\"当这个key过期了\",{\"1\":{\"1205\":1}}],[\"当这一切都完成之后\",{\"1\":{\"679\":1}}],[\"当过期时间到了之后\",{\"1\":{\"1205\":1}}],[\"当方法上参数的名称和url地址栏不相同时\",{\"1\":{\"1168\":1}}],[\"当张三写了一个内容\",{\"1\":{\"1166\":1}}],[\"当张三和李四和王五发了消息后\",{\"1\":{\"1166\":1}}],[\"当以上\",{\"1\":{\"1156\":1}}],[\"当以上判断逻辑走完之后\",{\"1\":{\"1155\":1}}],[\"当10s之后\",{\"1\":{\"1152\":1}}],[\"当第一天线程利用lua删除锁时\",{\"1\":{\"1147\":1}}],[\"当第二次存储相同字符串时\",{\"1\":{\"659\":1}}],[\"当他标注在类上时\",{\"1\":{\"1515\":1}}],[\"当他卡顿结束后\",{\"1\":{\"1145\":1}}],[\"当他写入缓存后\",{\"1\":{\"1121\":1}}],[\"当线程在获得锁失败后\",{\"1\":{\"1149\":1}}],[\"当线程2走到删除锁逻辑时\",{\"1\":{\"1143\":1}}],[\"当线程想要获取锁时\",{\"1\":{\"588\":1}}],[\"当分线程全部走完\",{\"1\":{\"1132\":1}}],[\"当分配四个内存块的时候\",{\"1\":{\"191\":1}}],[\"当countdownlatch\",{\"1\":{\"1132\":1}}],[\"当cpu在执行用户态的进程时\",{\"1\":{\"676\":2}}],[\"当异步程序没有执行完时\",{\"1\":{\"1132\":1}}],[\"当代计算机最大的问题是\",{\"1\":{\"1115\":1}}],[\"当注册完成后\",{\"1\":{\"1106\":1}}],[\"当监听线程知道用户想要和tomcat连接连接时\",{\"1\":{\"1100\":1}}],[\"当partition数量大于1的时候\",{\"1\":{\"1035\":1}}],[\"当内存中的数据量到达一定阈值\",{\"1\":{\"980\":1}}],[\"当内存不足以容纳新写入的数据时\",{\"1\":{\"522\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"522\":1}}],[\"当map\",{\"1\":{\"979\":1}}],[\"当master和slave机器始终严重不一致时\",{\"1\":{\"530\":1}}],[\"当master节点挂掉后需要运维介入切换节点\",{\"1\":{\"525\":1}}],[\"当整个数据处理结束之后开始对磁盘中的临时文件进行merge合并\",{\"1\":{\"979\":1}}],[\"当整个系统达到安全标准时\",{\"1\":{\"870\":1}}],[\"当溢写线程启动后\",{\"1\":{\"979\":1}}],[\"当划到最后一部分的时候进行计算\",{\"1\":{\"976\":1}}],[\"当reduce进行处理的时候\",{\"1\":{\"974\":1}}],[\"当redis内存达到咱们设定的max\",{\"1\":{\"1119\":1}}],[\"当redis\",{\"1\":{\"528\":1}}],[\"当redis已用内存超过maxmemory限定时\",{\"1\":{\"522\":1}}],[\"当下yarn仅支持cpu和内存两种资源\",{\"1\":{\"948\":1}}],[\"当下hive支持mapreduce\",{\"1\":{\"232\":1}}],[\"当加密区域被创建时\",{\"1\":{\"931\":1}}],[\"当namenode关闭时\",{\"1\":{\"903\":1}}],[\"当该块结束时\",{\"1\":{\"902\":1}}],[\"当该类资源又进程释放的时候\",{\"1\":{\"175\":1}}],[\"当副本为3\",{\"1\":{\"879\":1}}],[\"当一部分数据块丢失时\",{\"1\":{\"875\":1}}],[\"当一个read操作发生时\",{\"1\":{\"679\":1}}],[\"当一个元素加入布隆过滤器中的时候\",{\"1\":{\"659\":1}}],[\"当一个key过期时\",{\"1\":{\"529\":1}}],[\"当一个等待时间超过设置的某一阈值时\",{\"1\":{\"513\":1}}],[\"当一个程序中如果有一些操作彼此之间有关联性\",{\"1\":{\"452\":1}}],[\"当一个task运行结束以后\",{\"1\":{\"445\":1}}],[\"当一个进程访问某临界资源的时候\",{\"1\":{\"168\":1}}],[\"当一个进程正在cpu上执行的时候\",{\"1\":{\"165\":1}}],[\"当一个线程被阻塞以后\",{\"1\":{\"163\":1}}],[\"当一个用户级线程被阻塞以后\",{\"1\":{\"163\":1}}],[\"当一个产品族中的多个对象被设计成一起工作时\",{\"1\":{\"40\":1}}],[\"当消息处理器第一次写入消息时\",{\"1\":{\"843\":1}}],[\"当包装\",{\"1\":{\"780\":1}}],[\"当计数为\",{\"1\":{\"775\":1}}],[\"当订阅者的缓冲池满了之后\",{\"1\":{\"719\":1}}],[\"当\",{\"1\":{\"714\":1,\"742\":2,\"948\":1,\"1411\":1}}],[\"当出现异常时触发\",{\"1\":{\"705\":1}}],[\"当连接断开时触发\",{\"1\":{\"705\":1}}],[\"当应答未到达前\",{\"1\":{\"694\":1}}],[\"当发送的数据超过\",{\"1\":{\"694\":1}}],[\"当发生了缓冲区溢出就有可能造成程序异常结束\",{\"1\":{\"663\":1}}],[\"当发生重量级锁竞争的时候\",{\"1\":{\"542\":1}}],[\"当发生回滚时\",{\"1\":{\"506\":1}}],[\"当滑动窗口中缓冲了多个报文就会粘包\",{\"1\":{\"694\":1}}],[\"当需淘汰一个页面时\",{\"1\":{\"690\":1}}],[\"当需要时做类型转换\",{\"1\":{\"1370\":3}}],[\"当需要修改对象某个字段时很不方便\",{\"1\":{\"1208\":1}}],[\"当需要淘汰一个页面时\",{\"1\":{\"191\":2}}],[\"当需要创建的对象是一系列相互关联或相互依赖的产品族时\",{\"1\":{\"41\":1}}],[\"当物理内存的供应量变小时\",{\"1\":{\"685\":1}}],[\"当epoll\",{\"1\":{\"680\":2}}],[\"当select函数返回后\",{\"1\":{\"680\":1}}],[\"当它标注在方法上时\",{\"1\":{\"1515\":1}}],[\"当它收到一个asynchronous\",{\"1\":{\"679\":1}}],[\"当它的update方法被调用后\",{\"1\":{\"46\":1}}],[\"当任何一个socket中的数据准备好了\",{\"1\":{\"679\":1}}],[\"当任务执行完毕\",{\"1\":{\"574\":1}}],[\"当任务到达时\",{\"1\":{\"570\":1}}],[\"当kernel一直等到数据准备好了\",{\"1\":{\"679\":1}}],[\"当程序打开一个现有文件或者创建一个新文件时\",{\"1\":{\"677\":1}}],[\"当程序中出现group\",{\"1\":{\"463\":1}}],[\"当判断出缓冲区大小不够用时\",{\"1\":{\"663\":1}}],[\"当位数组初始化时\",{\"1\":{\"659\":1}}],[\"当字符串存储要加入到布隆过滤器中时\",{\"1\":{\"659\":1}}],[\"当有多个线程进入时\",{\"1\":{\"1141\":1}}],[\"当有多个字段时\",{\"1\":{\"303\":1}}],[\"当有事件触发时\",{\"1\":{\"611\":1}}],[\"当并发数很大时\",{\"1\":{\"609\":1}}],[\"当hash表的负载达到了指定的\",{\"1\":{\"606\":1}}],[\"当hive表对应的数据量大\",{\"1\":{\"259\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"605\":1}}],[\"当链表长度大于8并且node数组长度大于64的时候\",{\"1\":{\"579\":1}}],[\"当等待的线程数满足计数个数\",{\"1\":{\"593\":1}}],[\"当队列为空时\",{\"1\":{\"584\":1}}],[\"当条件成立时\",{\"1\":{\"584\":1}}],[\"当条件分散在两个表时\",{\"1\":{\"461\":1}}],[\"当tomcat端的socket接受到数据后\",{\"1\":{\"1100\":1}}],[\"当t1释放锁t2被唤醒后\",{\"1\":{\"583\":1}}],[\"当thread\",{\"1\":{\"541\":1}}],[\"当可重入时\",{\"1\":{\"582\":1}}],[\"当aqs需要同时实现为互斥锁+共享锁的时候\",{\"1\":{\"582\":1}}],[\"当aqs只实现为互斥锁的时候\",{\"1\":{\"582\":1}}],[\"当a小于b时\",{\"1\":{\"496\":1}}],[\"当初始化完毕后\",{\"1\":{\"1157\":1}}],[\"当初始化或扩容完成后\",{\"1\":{\"579\":1}}],[\"当初始化时\",{\"1\":{\"579\":1}}],[\"当扩容是\",{\"1\":{\"579\":1}}],[\"当使用了threadlocal对象之后\",{\"1\":{\"577\":1}}],[\"当你添加了数据库访问框架的起步依赖时\",{\"1\":{\"1515\":1}}],[\"当你创建一个索引的时候\",{\"1\":{\"1066\":1}}],[\"当你执行业务计算时\",{\"1\":{\"576\":1}}],[\"当你将浏览器配置成使用代理功能时\",{\"1\":{\"63\":1}}],[\"当活动线程数等于最大线程数且阻塞队列满的情况下采取的策略\",{\"1\":{\"573\":1}}],[\"当活动线程数==最大线程数且阻塞队列满的情况下采取的策略\",{\"1\":{\"572\":1}}],[\"当局部变量是引用变量时则需要进行逃逸分析判断\",{\"1\":{\"539\":1}}],[\"当调用\",{\"1\":{\"1321\":1}}],[\"当调用一次\",{\"1\":{\"851\":1}}],[\"当调用unpark时\",{\"1\":{\"549\":1}}],[\"当调用park时会查看counter是否为0\",{\"1\":{\"549\":1}}],[\"当调用了start\",{\"1\":{\"538\":1}}],[\"当调用getinstance\",{\"1\":{\"66\":1}}],[\"当java进程中有多个线程执行时\",{\"1\":{\"537\":1}}],[\"当客户端操作的key没有分配在该节点上时\",{\"1\":{\"527\":1}}],[\"当删除的key是所占内存很大时\",{\"1\":{\"523\":1}}],[\"当删除一个文件时\",{\"1\":{\"196\":1}}],[\"当存在大量的热点缓存数据时\",{\"1\":{\"522\":1}}],[\"当要对表做结构变更操作的时候\",{\"1\":{\"510\":1}}],[\"当对一个non\",{\"1\":{\"679\":1}}],[\"当对一个表做增删改查操作的时候\",{\"1\":{\"510\":1}}],[\"当对表中的数据进行增删改操作的时候\",{\"1\":{\"485\":1}}],[\"当事务提交时\",{\"1\":{\"506\":1}}],[\"当事务对数据库进行修改时\",{\"1\":{\"506\":1}}],[\"当数据修改时\",{\"1\":{\"506\":1}}],[\"当数据量大的时候就需要使用mapreduce的map阶段来进行数据清洗了\",{\"1\":{\"373\":1}}],[\"当数据量小的时候\",{\"1\":{\"373\":1}}],[\"当数据量特别大时\",{\"1\":{\"263\":1}}],[\"当向数据库写入数据时\",{\"1\":{\"506\":1}}],[\"当从数据库读取数据时\",{\"1\":{\"506\":1}}],[\"当没有二级索引的时候\",{\"1\":{\"497\":1}}],[\"当我们调用一个业务方法时\",{\"1\":{\"1514\":1}}],[\"当我们只查询user信息时\",{\"1\":{\"1230\":1}}],[\"当我们关闭连接其实并不是关闭\",{\"1\":{\"1216\":1}}],[\"当我们关注了用户后\",{\"1\":{\"1166\":1}}],[\"当我们使用了连接池后\",{\"1\":{\"1216\":1}}],[\"当我们点击美食之后\",{\"1\":{\"1171\":1}}],[\"当我们点击抢购时\",{\"1\":{\"1134\":1}}],[\"当我们去设置了多个锁时\",{\"1\":{\"1153\":1}}],[\"当我们向集群写数据时\",{\"1\":{\"1149\":1}}],[\"当我们向redis插入太多数据\",{\"1\":{\"1119\":1}}],[\"当我们客户端访问不存在的数据时\",{\"1\":{\"1123\":1}}],[\"当我们修改了数据之后\",{\"1\":{\"1122\":1}}],[\"当我们给redis设置了过期时间ttl之后\",{\"1\":{\"1119\":1}}],[\"当我们校验用户是否登录时\",{\"1\":{\"1106\":1}}],[\"当我们往压缩列表中插入数据时\",{\"1\":{\"665\":1}}],[\"当我们需要判断一个元素是否存在于布隆过滤器的时候\",{\"1\":{\"659\":1}}],[\"当我们利用索引查询时候\",{\"1\":{\"486\":1}}],[\"当我们执行\",{\"1\":{\"452\":1}}],[\"当遍历完所有小文件后\",{\"1\":{\"477\":1}}],[\"当提交运行一个程序时\",{\"1\":{\"462\":1}}],[\"当多个线程对同一个集合的内容进行操作时\",{\"1\":{\"602\":1}}],[\"当多个stage之间没有依赖关系时\",{\"1\":{\"446\":1}}],[\"当多个磁盘i\",{\"1\":{\"211\":1}}],[\"当查询条件中包含对该字段的等值过滤时候\",{\"1\":{\"437\":1}}],[\"当查询中有大于等于小于的操作时\",{\"1\":{\"437\":1}}],[\"当进行范围或者等值查询\",{\"1\":{\"437\":1}}],[\"当进程调用epoll\",{\"1\":{\"680\":1}}],[\"当进程被调度时\",{\"1\":{\"185\":1}}],[\"当进程不能进入临界区时\",{\"1\":{\"168\":1}}],[\"当为某张表的某个字段创建索引时\",{\"1\":{\"421\":1}}],[\"当为进程分配的物理块数增大时\",{\"1\":{\"191\":1}}],[\"当底层实现计算时\",{\"1\":{\"415\":1}}],[\"当y=8时\",{\"1\":{\"369\":1}}],[\"当y=2时\",{\"1\":{\"369\":1}}],[\"当只有一个数据块时\",{\"1\":{\"368\":1}}],[\"当往下第n行为null时候\",{\"1\":{\"365\":1}}],[\"当往上第n行为null时候\",{\"1\":{\"365\":1}}],[\"当输入规模大时\",{\"1\":{\"314\":1}}],[\"当访问hive数据时\",{\"1\":{\"292\":1}}],[\"当原表发生改变时\",{\"1\":{\"276\":1}}],[\"当启动hiveserver进程时\",{\"1\":{\"242\":1}}],[\"当某个autoconfiguration类满足其注解\",{\"1\":{\"1524\":1}}],[\"当某个datanode出现问题时\",{\"1\":{\"883\":1}}],[\"当某个socket有数据到达了就通知用户进程\",{\"1\":{\"679\":1}}],[\"当某个进程需要的资源被其他进程所占有的时候\",{\"1\":{\"176\":1}}],[\"当某个进程请求的资源得不到满足的时候\",{\"1\":{\"176\":1}}],[\"当某一列的值全是null时\",{\"1\":{\"482\":1}}],[\"当某页被访问时\",{\"1\":{\"191\":1}}],[\"当所访问的信息不在内存时\",{\"1\":{\"189\":1,\"190\":1}}],[\"当大量作业要求运行时\",{\"1\":{\"189\":1}}],[\"当页表很大的时候\",{\"1\":{\"186\":1}}],[\"当很多个空闲分区都能满足需求时\",{\"1\":{\"182\":1}}],[\"当用户过来访问的时候\",{\"1\":{\"1177\":1}}],[\"当用户读取数据时才去关注的人里边去读取数据\",{\"1\":{\"1166\":1}}],[\"当用户操作过之后\",{\"1\":{\"1161\":1}}],[\"当用户下单之后\",{\"1\":{\"1155\":1}}],[\"当用户开始进行下单\",{\"1\":{\"1134\":1}}],[\"当用户开始查询redis时\",{\"1\":{\"1128\":1}}],[\"当用户抢购时\",{\"1\":{\"1131\":1}}],[\"当用户发起请求\",{\"1\":{\"1155\":1}}],[\"当用户发起请求时\",{\"1\":{\"1100\":1}}],[\"当用户发出read操作时\",{\"1\":{\"679\":1}}],[\"当用户向\",{\"1\":{\"952\":1}}],[\"当用户误操作时\",{\"1\":{\"912\":1}}],[\"当用户进程调用了select\",{\"1\":{\"679\":1}}],[\"当用户进程调用了recvfrom这个系统调用\",{\"1\":{\"679\":1}}],[\"当用户进程要装入内存时\",{\"1\":{\"182\":1}}],[\"当用户查询数据时\",{\"1\":{\"437\":1}}],[\"当用户写入数据时\",{\"1\":{\"437\":1}}],[\"当用户请求访问某个设备时\",{\"1\":{\"211\":1}}],[\"当用户想要访问文件时\",{\"1\":{\"201\":1}}],[\"当用户需要使用一个文件的时候\",{\"1\":{\"196\":1}}],[\"当用户程序太大时\",{\"1\":{\"182\":1}}],[\"当资源已经分配完毕\",{\"1\":{\"171\":1}}],[\"当已有进程进入临界区\",{\"1\":{\"168\":1}}],[\"当临界区空闲的时候\",{\"1\":{\"168\":1}}],[\"当读进程将数据全部取走以后\",{\"1\":{\"162\":1}}],[\"当管道写满的时候\",{\"1\":{\"162\":1}}],[\"当直接引用或者间接引用出现了相同的jar包\",{\"1\":{\"105\":1}}],[\"当然我们也可以通过help命令来帮助我们去查看命令\",{\"1\":{\"1204\":1}}],[\"当然我们可以对其进行修改\",{\"1\":{\"680\":1}}],[\"当然是使用我们之前学习过的set集合咯\",{\"1\":{\"1165\":1}}],[\"当然这里边有两个难点\",{\"1\":{\"1155\":1}}],[\"当然这也比我们直接使用syn来的好\",{\"1\":{\"1136\":1}}],[\"当然不会\",{\"1\":{\"1152\":1}}],[\"当然乐观锁还有一些变种的处理方式比如cas\",{\"1\":{\"1135\":1}}],[\"当然还有其他解决方案\",{\"1\":{\"997\":1}}],[\"当然也可以使用aspectj\",{\"1\":{\"1500\":1}}],[\"当然也可以配置关注哪个注解\",{\"1\":{\"1455\":1}}],[\"当然也可以手动指定需要流式传输的表\",{\"1\":{\"326\":1}}],[\"当然也有人使用\",{\"1\":{\"997\":1}}],[\"当然就会慢下来了\",{\"1\":{\"719\":1}}],[\"当然\",{\"1\":{\"588\":1,\"775\":1,\"1063\":1,\"1411\":1,\"1462\":1,\"1522\":1}}],[\"当然安全序列可能有多个\",{\"1\":{\"177\":1}}],[\"当然了\",{\"1\":{\"102\":1}}],[\"当然该方式也存在内存浪费问题\",{\"1\":{\"66\":1}}],[\"当前服务器时间戳\",{\"1\":{\"999\":1}}],[\"当前时间小于上一次生成id使用的时间\",{\"1\":{\"999\":1}}],[\"当前时间`\",{\"1\":{\"742\":1}}],[\"当前处理的文件是\",{\"1\":{\"988\":1}}],[\"当前体系结构的弊端\",{\"1\":{\"888\":1}}],[\"当前hdfs体系架构\",{\"0\":{\"888\":1}}],[\"当前hash表中的元素数量\",{\"1\":{\"606\":1}}],[\"当前类需要实现cloneable接口\",{\"1\":{\"629\":1}}],[\"当前位置\",{\"1\":{\"610\":1}}],[\"当前线程标示\",{\"1\":{\"1146\":1}}],[\"当前线程再加入到队列中等待唤醒\",{\"1\":{\"588\":1}}],[\"当前线程运行结束\",{\"1\":{\"538\":1}}],[\"当前数据库还普遍采用wait\",{\"1\":{\"513\":1}}],[\"当前写操作没有完成前\",{\"1\":{\"508\":1}}],[\"当前程序会自动通过两个mapreduce来运行\",{\"1\":{\"466\":1}}],[\"当前行\",{\"1\":{\"361\":1}}],[\"当前的写事务id\",{\"1\":{\"293\":1}}],[\"当前库下已有一张表student\",{\"1\":{\"289\":1}}],[\"当前有两个进程都要访问临界资源\",{\"1\":{\"169\":1}}],[\"当前运行进程重新回到就绪队列\",{\"1\":{\"167\":1}}],[\"当前运行的进程暂停运行\",{\"1\":{\"157\":1}}],[\"当前工程作为父工程\",{\"1\":{\"107\":1}}],[\"当前对象的方法参数等\",{\"1\":{\"76\":1}}],[\"当前对象的成员对象\",{\"1\":{\"76\":1}}],[\"当前对象所创建的对象\",{\"1\":{\"76\":1}}],[\"当前对象本身\",{\"1\":{\"76\":1}}],[\"当前系统业务所期待的接口\",{\"1\":{\"5\":1}}],[\"当软件需要发生变化时\",{\"1\":{\"72\":1}}],[\"当通过反射方式调用构造方法进行创建创建时\",{\"1\":{\"69\":1}}],[\"当互联网返回响应时\",{\"1\":{\"63\":1}}],[\"当自身状态发生变化后\",{\"1\":{\"46\":1}}],[\"当观察对象的状态发生变化时\",{\"1\":{\"45\":1}}],[\"当产品族中需要增加一个新的产品时\",{\"1\":{\"40\":1}}],[\"当不希望实现一个接口中所有的方法时\",{\"1\":{\"7\":1}}],[\"创建spring\",{\"1\":{\"1525\":1}}],[\"创建singleton类的对象s2\",{\"1\":{\"68\":1}}],[\"创建singleton类的对象s1\",{\"1\":{\"68\":1}}],[\"创建并初始化容器\",{\"1\":{\"1522\":1}}],[\"创建的产品\",{\"1\":{\"1472\":1}}],[\"创建的对象较复杂\",{\"1\":{\"16\":1}}],[\"创建项目文件夹\",{\"1\":{\"1449\":1}}],[\"创建模块\",{\"1\":{\"1441\":1}}],[\"创建前后的增强\",{\"1\":{\"1254\":1}}],[\"创建容器\",{\"1\":{\"1245\":2,\"1444\":1}}],[\"创建json序列化工具\",{\"1\":{\"1222\":1}}],[\"创建jedis的连接池\",{\"0\":{\"1215\":1}}],[\"创建redistemplate对象\",{\"1\":{\"1222\":1}}],[\"创建redissonclient对象\",{\"1\":{\"1150\":1}}],[\"创建工程\",{\"1\":{\"1213\":1}}],[\"创建时间\",{\"1\":{\"1164\":1}}],[\"创建时初始化好\",{\"1\":{\"740\":1}}],[\"创建锁对象\",{\"1\":{\"1157\":1}}],[\"创建秒杀代金券对象\",{\"1\":{\"1156\":1}}],[\"创建订单\",{\"1\":{\"1134\":2,\"1137\":3,\"1155\":1,\"1157\":1}}],[\"创建订单时\",{\"1\":{\"1003\":1}}],[\"创建新用户并保存\",{\"1\":{\"1107\":1}}],[\"创建数据模型\",{\"1\":{\"1073\":1}}],[\"创建数据库\",{\"1\":{\"278\":1}}],[\"创建自定义分区器\",{\"1\":{\"1035\":1}}],[\"创建连接器\",{\"1\":{\"1449\":1}}],[\"创建连接池对象\",{\"1\":{\"1215\":1}}],[\"创建连接\",{\"1\":{\"1023\":1}}],[\"创建topic\",{\"1\":{\"1018\":1}}],[\"创建名为test的主题\",{\"1\":{\"1015\":1}}],[\"创建cluster对象\",{\"1\":{\"992\":1}}],[\"创建主控制器控制上面两个作业一起提交\",{\"1\":{\"991\":1}}],[\"创建集合\",{\"1\":{\"988\":1}}],[\"创建作业实例\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"创建配置对象\",{\"1\":{\"962\":2,\"988\":1}}],[\"创建应用程序\",{\"1\":{\"952\":1}}],[\"创建es客户端\",{\"1\":{\"1071\":1}}],[\"创建ez\",{\"1\":{\"936\":1}}],[\"创建enhancer对象\",{\"1\":{\"60\":1}}],[\"创建keystore\",{\"1\":{\"936\":1}}],[\"创建加密区\",{\"1\":{\"934\":1}}],[\"创建快照\",{\"1\":{\"914\":1}}],[\"创建本地路径\",{\"1\":{\"872\":1}}],[\"创建多级目录用\",{\"1\":{\"822\":1}}],[\"创建了服务器\",{\"1\":{\"826\":1,\"827\":1}}],[\"创建了\",{\"1\":{\"740\":1}}],[\"创建了很多个\",{\"1\":{\"107\":1}}],[\"创建\",{\"0\":{\"768\":1,\"830\":1,\"1015\":1,\"1020\":1},\"1\":{\"740\":2,\"780\":1,\"784\":1,\"785\":1,\"794\":1,\"840\":1,\"846\":1,\"1013\":1,\"1142\":1,\"1150\":1,\"1252\":1,\"1343\":1,\"1438\":1,\"1449\":2}}],[\"创建成功\",{\"1\":{\"704\":1}}],[\"创建群聊\",{\"1\":{\"704\":1}}],[\"创建hash表时指定的初始容量\",{\"1\":{\"606\":1}}],[\"创建hive事务表\",{\"1\":{\"268\":1,\"298\":1}}],[\"创建普通索引就可以大幅提升数据查询的效率\",{\"1\":{\"493\":1}}],[\"创建普通数据表并载入数据\",{\"1\":{\"266\":1}}],[\"创建索引注意事项\",{\"1\":{\"493\":1}}],[\"创建索引和维护索引要耗费时间\",{\"1\":{\"485\":1}}],[\"创建索引时避免有如下极端误解\",{\"1\":{\"481\":1}}],[\"创建索引\",{\"1\":{\"423\":1,\"1072\":2,\"1089\":2}}],[\"创建临时表\",{\"1\":{\"409\":1}}],[\"创建ods层增量表\",{\"1\":{\"408\":1}}],[\"创建增量表\",{\"0\":{\"408\":1}}],[\"创建拉链表\",{\"0\":{\"407\":1}}],[\"创建实验用表tb\",{\"1\":{\"378\":1}}],[\"创建空表dual\",{\"1\":{\"329\":1}}],[\"创建两张新表\",{\"1\":{\"288\":1}}],[\"创建表指定创建布隆索引\",{\"1\":{\"437\":1}}],[\"创建表并制定构建索引\",{\"1\":{\"437\":1}}],[\"创建表dual\",{\"1\":{\"329\":1}}],[\"创建表\",{\"1\":{\"280\":1}}],[\"创建视图\",{\"1\":{\"271\":1}}],[\"创建视图时\",{\"1\":{\"270\":1}}],[\"创建事务表\",{\"0\":{\"268\":1}}],[\"创建分桶表\",{\"0\":{\"265\":1}}],[\"创建分区表\",{\"0\":{\"260\":1},\"1\":{\"281\":1,\"289\":1}}],[\"创建一级目录\",{\"1\":{\"822\":1}}],[\"创建一张目标表student\",{\"1\":{\"287\":1}}],[\"创建一张源表student\",{\"1\":{\"287\":1}}],[\"创建一张新的分区表\",{\"1\":{\"261\":1}}],[\"创建一个生产者对象kafkaproducer\",{\"1\":{\"1023\":1}}],[\"创建一个\",{\"1\":{\"1019\":1}}],[\"创建一个topic\",{\"1\":{\"1015\":1}}],[\"创建一个集合用于缓存我们的商品数据\",{\"1\":{\"990\":1}}],[\"创建一个目录\",{\"1\":{\"936\":1}}],[\"创建一个独立的\",{\"1\":{\"748\":1}}],[\"创建一个聊天组\",{\"1\":{\"701\":1}}],[\"创建一个写事务id\",{\"1\":{\"293\":1}}],[\"创建一个含有两个字段的表tab1\",{\"1\":{\"285\":1}}],[\"创建一个新的事务\",{\"1\":{\"1514\":1}}],[\"创建一个新的进程执行指定的字符串命令\",{\"1\":{\"70\":1}}],[\"创建一个新节点\",{\"1\":{\"668\":1}}],[\"创建一个新文件时\",{\"1\":{\"196\":1}}],[\"创建一个新对象\",{\"1\":{\"51\":2}}],[\"创建一个读卡器\",{\"1\":{\"6\":1}}],[\"创建完成后当使用select\",{\"1\":{\"260\":1}}],[\"创建方式\",{\"1\":{\"258\":1}}],[\"创建文件和目录时使用的umask\",{\"1\":{\"919\":1}}],[\"创建文件夹\",{\"1\":{\"870\":1}}],[\"创建文件\",{\"1\":{\"196\":1,\"199\":1}}],[\"创建态\",{\"1\":{\"160\":1}}],[\"创建代理的工作一般是在\",{\"1\":{\"1453\":1}}],[\"创建代理类\",{\"1\":{\"737\":1}}],[\"创建代理工厂对象\",{\"1\":{\"60\":1}}],[\"创建代理对象\",{\"1\":{\"60\":1,\"1322\":1}}],[\"创建对象\",{\"1\":{\"1223\":1}}],[\"创建对象的步骤\",{\"0\":{\"630\":1}}],[\"创建对象的方式\",{\"0\":{\"629\":1}}],[\"创建对象输出流\",{\"1\":{\"68\":1}}],[\"创建对象输出流对象\",{\"1\":{\"54\":1}}],[\"创建对象输入流对象\",{\"1\":{\"68\":1}}],[\"创建对象出入流对象\",{\"1\":{\"54\":1}}],[\"创建者模式对比\",{\"0\":{\"18\":1}}],[\"创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式\",{\"1\":{\"16\":1}}],[\"创建共享单车\",{\"1\":{\"14\":1}}],[\"创建适配器对象\",{\"1\":{\"7\":1}}],[\"ml\",{\"0\":{\"1534\":1}}],[\"mget\",{\"1\":{\"1206\":2}}],[\"mq\",{\"1\":{\"1008\":1}}],[\"mrjobflow\",{\"1\":{\"991\":2}}],[\"mr\",{\"1\":{\"986\":3}}],[\"mr提交yarn交互流程\",{\"0\":{\"953\":1}}],[\"mrv1\",{\"1\":{\"948\":1}}],[\"mr作业提交\",{\"1\":{\"942\":1}}],[\"mr作业状态汇报\",{\"1\":{\"942\":1}}],[\"mrappmaster\",{\"1\":{\"942\":2}}],[\"m表示文件做了修改\",{\"1\":{\"914\":1}}],[\"mvc拦截器的开发步骤如下\",{\"1\":{\"1532\":1}}],[\"mvc拦截器的执行流程如下\",{\"1\":{\"1532\":1}}],[\"mvc中\",{\"1\":{\"1532\":1}}],[\"mvc中的接收普通参数的注解\",{\"1\":{\"1531\":1}}],[\"mvc的拦截器\",{\"0\":{\"1532\":1}}],[\"mvc的执行流程\",{\"0\":{\"1530\":1}}],[\"mvc支持rest风格的一个重要标志\",{\"1\":{\"1531\":1}}],[\"mvc注解\",{\"0\":{\"1531\":1}}],[\"mvc框架的接口\",{\"1\":{\"1530\":1}}],[\"mvc是一种设计模式\",{\"1\":{\"1528\":1}}],[\"mvc\",{\"0\":{\"1438\":1},\"1\":{\"1411\":2,\"1441\":2,\"1499\":2}}],[\"mvcconfig\",{\"1\":{\"1100\":1}}],[\"mvcc保证隔离性\",{\"1\":{\"506\":1}}],[\"mvcc的意思是多版本并发控制\",{\"1\":{\"503\":1}}],[\"mvcc只存在读已提交和可重复读的情况下\",{\"1\":{\"503\":1}}],[\"mvnrepository\",{\"1\":{\"99\":1,\"104\":1,\"112\":1}}],[\"mvn\",{\"1\":{\"95\":7,\"1442\":2}}],[\"mtu\",{\"1\":{\"694\":6}}],[\"mtn\",{\"1\":{\"402\":1}}],[\"mth\",{\"1\":{\"402\":3}}],[\"md5\",{\"1\":{\"343\":2,\"494\":1}}],[\"md5加密\",{\"1\":{\"343\":1}}],[\"multicastevent\",{\"1\":{\"1497\":1}}],[\"multipart\",{\"1\":{\"1461\":2}}],[\"multipartautoconfiguration\",{\"0\":{\"1461\":1}}],[\"multipartfile\",{\"1\":{\"1159\":1,\"1362\":1}}],[\"multiplexing就是我们说的select\",{\"1\":{\"679\":1}}],[\"multiplexing\",{\"1\":{\"679\":2}}],[\"multiple\",{\"1\":{\"290\":1}}],[\"mutex\",{\"1\":{\"549\":1}}],[\"must\",{\"1\":{\"70\":1,\"1080\":1}}],[\"mkdir\",{\"1\":{\"281\":2,\"872\":1,\"936\":1}}],[\"mpsc\",{\"1\":{\"741\":1}}],[\"mp\",{\"1\":{\"260\":1,\"261\":1,\"281\":1,\"1317\":5}}],[\"mfd\",{\"1\":{\"196\":1}}],[\"m\",{\"0\":{\"362\":3,\"364\":1},\"1\":{\"163\":2,\"214\":1,\"340\":1,\"344\":2,\"368\":2,\"402\":2,\"523\":1,\"749\":3,\"809\":3,\"926\":2,\"1022\":1,\"1040\":2,\"1317\":2}}],[\"mset和mget\",{\"1\":{\"1206\":1}}],[\"mset\",{\"1\":{\"1205\":1,\"1206\":2}}],[\"mss\",{\"1\":{\"694\":10}}],[\"msck是metastore\",{\"1\":{\"281\":1}}],[\"msck\",{\"0\":{\"281\":1},\"1\":{\"280\":1,\"281\":11}}],[\"ms\",{\"0\":{\"147\":1},\"1\":{\"832\":1,\"1021\":1,\"1024\":1,\"1244\":4}}],[\"msg\",{\"1\":{\"6\":16,\"7\":2,\"702\":8,\"703\":7,\"704\":19,\"710\":2,\"711\":7,\"713\":4,\"714\":4,\"723\":4,\"736\":2,\"737\":2,\"738\":5,\"743\":3,\"748\":8,\"749\":3,\"766\":15,\"775\":8,\"784\":2,\"787\":1,\"794\":4}}],[\"mm\",{\"1\":{\"337\":6,\"1132\":1,\"1175\":1}}],[\"mmgeneration\",{\"1\":{\"121\":1,\"124\":1,\"128\":1,\"133\":1}}],[\"mmlab\",{\"1\":{\"121\":1,\"124\":1,\"128\":1}}],[\"myimportselector\",{\"1\":{\"1464\":4}}],[\"myimportselector=\",{\"1\":{\"1464\":1}}],[\"myisam和innodb的存储引擎只支持btree索引\",{\"1\":{\"485\":1}}],[\"mycondition1\",{\"1\":{\"1466\":3}}],[\"mycontroller\",{\"1\":{\"1441\":1}}],[\"myconfig1\",{\"1\":{\"1285\":2}}],[\"myctrl\",{\"1\":{\"991\":1}}],[\"mybeanpostprocessor\",{\"1\":{\"1505\":1}}],[\"mybeanfactory\",{\"1\":{\"1257\":3}}],[\"mybatisproperties\",{\"1\":{\"1455\":1}}],[\"mybatisplus\",{\"1\":{\"1236\":3}}],[\"mybatisplusinterceptor\",{\"1\":{\"1232\":4}}],[\"mybatisplusconfig\",{\"1\":{\"1232\":1}}],[\"mybatisautoconfiguration\",{\"0\":{\"1455\":1},\"1\":{\"1455\":3}}],[\"mybatisx\",{\"1\":{\"1237\":1}}],[\"mybatis动态表模式实现\",{\"0\":{\"1232\":1}}],[\"mybatis+pagehelper插件即可实现分页操作\",{\"1\":{\"1231\":1}}],[\"mybatis分页操作\",{\"0\":{\"1231\":1}}],[\"mybatis分页插件\",{\"1\":{\"102\":1}}],[\"mybatis\",{\"0\":{\"1227\":2,\"1228\":1,\"1233\":1,\"1236\":1},\"1\":{\"1234\":1,\"1236\":2,\"1366\":1,\"1440\":1,\"1455\":5}}],[\"mybatis逆向工程插件等等\",{\"1\":{\"102\":1}}],[\"mybatis中有时会将用于编写sql语句的映射文件和mapper接口都写在src\",{\"1\":{\"102\":1}}],[\"mysnap2\",{\"1\":{\"914\":2}}],[\"mysnap1\",{\"1\":{\"914\":4}}],[\"mysql本身就带有锁机制\",{\"1\":{\"1140\":1}}],[\"mysql的单表的容量不宜超过500w\",{\"1\":{\"1131\":1}}],[\"mysql的悲观锁和乐观锁\",{\"0\":{\"507\":1}}],[\"mysql服务器层并没有实现行锁机制\",{\"1\":{\"511\":1}}],[\"mysql中不同的存储引擎支持的锁是不一样的\",{\"1\":{\"506\":1}}],[\"mysql中索引的存储类型有两种\",{\"1\":{\"485\":1}}],[\"mysql默认页为16kb\",{\"1\":{\"506\":1}}],[\"mysql索引会失效变成全表扫描\",{\"1\":{\"505\":1}}],[\"mysql可以将数据恢复到指定版本\",{\"1\":{\"503\":1}}],[\"mysql事务隔离级别和mvcc\",{\"1\":{\"503\":1}}],[\"mysql8\",{\"1\":{\"502\":1}}],[\"mysql在使用不等于的时候无法使用索引会导致全表扫描\",{\"1\":{\"505\":1}}],[\"mysql在解析的过程中\",{\"1\":{\"498\":1}}],[\"mysql在windows下不区分大小写\",{\"1\":{\"480\":1}}],[\"mysql并不是跳过offset行\",{\"1\":{\"481\":1}}],[\"mysql\",{\"0\":{\"484\":1},\"1\":{\"232\":1,\"241\":2,\"984\":1,\"985\":2,\"986\":4,\"997\":2,\"1046\":2,\"1140\":2,\"1174\":1,\"1236\":5,\"1440\":1}}],[\"mysql数据库驱动和jackson\",{\"1\":{\"91\":1}}],[\"myprocessor\",{\"1\":{\"718\":3}}],[\"myfunction\",{\"1\":{\"614\":2}}],[\"my\",{\"1\":{\"278\":1,\"743\":1,\"1525\":1}}],[\"myqcloud\",{\"1\":{\"197\":1}}],[\"myheritage\",{\"1\":{\"125\":1}}],[\"middleware\",{\"0\":{\"1559\":1}}],[\"mi\",{\"1\":{\"1340\":7}}],[\"mit\",{\"1\":{\"923\":1}}],[\"mixed\",{\"1\":{\"628\":1}}],[\"millis\",{\"0\":{\"725\":1},\"1\":{\"725\":1}}],[\"milliseconds\",{\"1\":{\"574\":2,\"725\":1,\"742\":1,\"1152\":2}}],[\"milk\",{\"1\":{\"34\":1}}],[\"misc\",{\"1\":{\"343\":1}}],[\"mintime\",{\"1\":{\"1168\":7}}],[\"min指定\",{\"1\":{\"901\":1}}],[\"mina\",{\"1\":{\"790\":1,\"792\":1}}],[\"min\",{\"1\":{\"360\":1,\"619\":1,\"621\":1,\"742\":1,\"870\":2,\"1168\":1,\"1211\":3,\"1220\":1}}],[\"minutes\",{\"1\":{\"1107\":1,\"1111\":1,\"1122\":1,\"1124\":2,\"1127\":2,\"1129\":4}}],[\"minute\",{\"1\":{\"337\":3}}],[\"minor\",{\"0\":{\"628\":1},\"1\":{\"294\":1,\"628\":1}}],[\"minwid\",{\"1\":{\"293\":1}}],[\"microservice\",{\"0\":{\"1547\":1}}],[\"micro\",{\"0\":{\"112\":1}}],[\"mirror>\",{\"1\":{\"92\":1}}],[\"mirrorof>\",{\"1\":{\"92\":1}}],[\"mothod\",{\"1\":{\"1531\":1}}],[\"mothed\",{\"1\":{\"374\":1}}],[\"move\",{\"1\":{\"822\":3}}],[\"moved\",{\"1\":{\"579\":1}}],[\"monitorexit是退出synchronized语句\",{\"1\":{\"541\":1}}],[\"monitorenter是进入synchronized语句\",{\"1\":{\"541\":1}}],[\"monitor中只能有一个owner\",{\"1\":{\"541\":1}}],[\"monitor的结构如下\",{\"1\":{\"541\":1}}],[\"monitor被翻译成监视器或管程\",{\"1\":{\"541\":1}}],[\"monitor原理\",{\"0\":{\"541\":1}}],[\"monitor\",{\"1\":{\"536\":10,\"549\":1}}],[\"money\",{\"1\":{\"402\":6}}],[\"month\",{\"1\":{\"337\":3,\"352\":1,\"353\":20,\"354\":6,\"355\":4}}],[\"modified字段值为当前时间\",{\"1\":{\"483\":1}}],[\"modified的类型均为datetime类型\",{\"1\":{\"480\":1}}],[\"modified\",{\"1\":{\"480\":1}}],[\"mode<\",{\"1\":{\"919\":1}}],[\"mode指定\",{\"1\":{\"919\":1}}],[\"mode是namenode的维护状态\",{\"1\":{\"870\":1}}],[\"mode\",{\"1\":{\"268\":1,\"276\":1,\"289\":1,\"297\":1,\"298\":1,\"444\":3,\"638\":1}}],[\"mode=nonstrict\",{\"1\":{\"261\":1}}],[\"model代表的是数据\",{\"1\":{\"1528\":1}}],[\"modelandview中包含的是\",{\"1\":{\"1530\":1}}],[\"modelandview包含了视图逻辑名和模型数据信息\",{\"1\":{\"1530\":1}}],[\"modelandview\",{\"1\":{\"1394\":1,\"1438\":4}}],[\"modelandviewcontainer\",{\"1\":{\"1362\":1,\"1394\":7,\"1438\":2}}],[\"modelattribute\",{\"0\":{\"1387\":1,\"1388\":1},\"1\":{\"1362\":2,\"1389\":1,\"1390\":5,\"1394\":2}}],[\"model中\",{\"1\":{\"679\":1}}],[\"modeling\",{\"1\":{\"146\":1}}],[\"model\",{\"1\":{\"125\":1,\"1362\":1,\"1416\":2,\"1521\":1}}],[\"modelversion>\",{\"1\":{\"98\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"modules>\",{\"1\":{\"108\":1,\"115\":1}}],[\"module>\",{\"1\":{\"108\":2,\"115\":3}}],[\"module<\",{\"1\":{\"107\":1}}],[\"module\",{\"1\":{\"107\":3,\"1243\":1}}],[\"most\",{\"1\":{\"70\":1,\"1053\":1}}],[\"mobikebuilder\",{\"1\":{\"14\":2}}],[\"mobikebuilder和ofobuilder是具体的建造者\",{\"1\":{\"14\":1}}],[\"m0\",{\"1\":{\"59\":3,\"543\":1,\"544\":1,\"545\":1,\"549\":1}}],[\"m3\",{\"1\":{\"59\":6,\"702\":1}}],[\"m2\",{\"1\":{\"59\":3,\"92\":1,\"702\":1}}],[\"m1\",{\"1\":{\"59\":3,\"702\":1}}],[\"mazi\",{\"1\":{\"1210\":2}}],[\"makefile\",{\"1\":{\"876\":1}}],[\"make\",{\"1\":{\"876\":3,\"1193\":2}}],[\"maybemoredatasupplier\",{\"1\":{\"744\":3}}],[\"maybesuperuser\",{\"1\":{\"740\":1}}],[\"magicnum\",{\"1\":{\"713\":2,\"714\":2,\"723\":2}}],[\"mage\",{\"1\":{\"261\":1}}],[\"malloc函数申请内存\",{\"1\":{\"682\":1}}],[\"male\",{\"1\":{\"340\":1}}],[\"mandatory\",{\"1\":{\"1514\":2}}],[\"man\",{\"1\":{\"1208\":5}}],[\"manifest>\",{\"1\":{\"957\":1}}],[\"management\",{\"1\":{\"933\":1,\"1045\":1}}],[\"managerid\",{\"1\":{\"404\":1}}],[\"manager\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"884\":1,\"945\":2}}],[\"many\",{\"1\":{\"579\":1}}],[\"mask\",{\"1\":{\"342\":13,\"999\":2}}],[\"masking\",{\"1\":{\"342\":1}}],[\"master大量清理过期key\",{\"1\":{\"530\":1}}],[\"master里设置了过期时间的key\",{\"1\":{\"530\":1}}],[\"master会先清理删除它\",{\"1\":{\"529\":1}}],[\"master和slave进程是否正常工作\",{\"1\":{\"526\":1}}],[\"master\",{\"1\":{\"133\":1,\"146\":1}}],[\"marketprice\",{\"1\":{\"985\":10,\"986\":1}}],[\"markreaderindex\",{\"1\":{\"774\":1}}],[\"mark\",{\"0\":{\"804\":1},\"1\":{\"610\":1,\"631\":1,\"639\":1,\"774\":1,\"804\":3}}],[\"mary\",{\"1\":{\"340\":1}}],[\"mart\",{\"1\":{\"223\":1}}],[\"major\",{\"0\":{\"628\":1},\"1\":{\"294\":1,\"628\":1}}],[\"matrix\",{\"1\":{\"875\":1}}],[\"matchquery\",{\"1\":{\"1080\":2}}],[\"matchallquery\",{\"1\":{\"1075\":1,\"1077\":1,\"1078\":1,\"1079\":1}}],[\"matchamousse\",{\"1\":{\"39\":1}}],[\"match\",{\"1\":{\"480\":1}}],[\"matches\",{\"1\":{\"344\":1,\"1466\":1}}],[\"matcher\",{\"1\":{\"344\":2}}],[\"math\",{\"1\":{\"343\":2,\"648\":2,\"649\":3}}],[\"mathematical\",{\"1\":{\"338\":1}}],[\"materializedview\",{\"1\":{\"276\":1}}],[\"materialized\",{\"0\":{\"273\":1},\"1\":{\"276\":16}}],[\"maxage\",{\"1\":{\"1084\":1}}],[\"maxmessageperread\",{\"1\":{\"744\":2}}],[\"maxmessagehandle\",{\"1\":{\"744\":1}}],[\"maxmemory\",{\"1\":{\"70\":1,\"1196\":1}}],[\"max查看\",{\"1\":{\"680\":1}}],[\"maxk\",{\"1\":{\"649\":2}}],[\"maxvalue\",{\"1\":{\"649\":2}}],[\"maxn\",{\"1\":{\"646\":4}}],[\"maximum\",{\"1\":{\"579\":2,\"694\":2}}],[\"maximumpoolsize\",{\"1\":{\"572\":3}}],[\"max值的索引\",{\"1\":{\"437\":1}}],[\"max值的索引数据\",{\"1\":{\"437\":1}}],[\"max值\",{\"1\":{\"437\":1}}],[\"maxwid\",{\"1\":{\"293\":1}}],[\"max\",{\"1\":{\"260\":5,\"261\":4,\"281\":4,\"343\":2,\"351\":3,\"358\":1,\"360\":1,\"382\":3,\"437\":1,\"444\":1,\"574\":2,\"601\":1,\"619\":1,\"621\":1,\"648\":2,\"649\":3,\"726\":1,\"773\":2,\"776\":1,\"777\":1,\"839\":3,\"870\":1,\"968\":1,\"999\":6,\"1084\":1,\"1161\":1,\"1165\":1,\"1168\":6,\"1211\":3,\"1220\":3}}],[\"machine\",{\"1\":{\"125\":1}}],[\"maven综合案例\",{\"0\":{\"109\":1}}],[\"maven自动解决依赖冲突问题能力\",{\"1\":{\"105\":1}}],[\"maven依赖冲突特性\",{\"0\":{\"105\":1}}],[\"maven依赖传递特性\",{\"0\":{\"104\":1}}],[\"maven依赖传递和依赖冲突\",{\"0\":{\"103\":1}}],[\"maven规定的固定的key\",{\"1\":{\"99\":1}}],[\"mavensearch插件搜索\",{\"1\":{\"99\":1}}],[\"maven仓库信息官网\",{\"1\":{\"99\":1}}],[\"maven工程聚合关系\",{\"0\":{\"108\":1}}],[\"maven工程继承关系\",{\"0\":{\"107\":1}}],[\"maven工程继承和聚合关系\",{\"0\":{\"106\":1}}],[\"maven工程build构建配置\",{\"0\":{\"102\":1}}],[\"maven工程依赖下载失败错误解决\",{\"0\":{\"101\":1}}],[\"maven工程依赖管理配置\",{\"0\":{\"99\":1}}],[\"maven工程核心信息配置和解读\",{\"0\":{\"98\":1}}],[\"maven会将该项目打成的jar包放本地路径\",{\"1\":{\"98\":1}}],[\"maven<\",{\"1\":{\"92\":1,\"102\":1,\"105\":1,\"107\":3}}],[\"maven选用编译项目的jdk版本\",{\"1\":{\"92\":1}}],[\"maven下载镜像\",{\"1\":{\"92\":1}}],[\"maven功能配置\",{\"0\":{\"92\":1}}],[\"maven就会自动下载并复制这些依赖项到项目中\",{\"1\":{\"91\":1}}],[\"maven就是一个软件\",{\"1\":{\"91\":1}}],[\"maven介绍\",{\"0\":{\"91\":1}}],[\"maven简介\",{\"0\":{\"90\":1}}],[\"maven\",{\"0\":{\"89\":1},\"1\":{\"91\":9,\"92\":6,\"94\":1,\"97\":7,\"100\":7,\"101\":7,\"102\":2,\"105\":1,\"107\":5,\"108\":1,\"112\":7,\"113\":6,\"114\":6,\"115\":6,\"344\":1,\"957\":2,\"1022\":1,\"1219\":5,\"1300\":2}}],[\"map就不一样\",{\"1\":{\"1100\":1}}],[\"map处理完之后\",{\"1\":{\"979\":1}}],[\"maptask的初始化方法\",{\"1\":{\"988\":1}}],[\"maptask的个数是与逻辑切片的个数相等的\",{\"1\":{\"976\":1}}],[\"maptask工作机制详解\",{\"0\":{\"979\":1}}],[\"maptask并行度的决定机制叫做逻辑规划\",{\"1\":{\"976\":1}}],[\"maptask并行度机制\",{\"0\":{\"976\":1}}],[\"map输出数据写入内存缓冲区\",{\"1\":{\"965\":1}}],[\"map方法基于行来调用\",{\"1\":{\"959\":1}}],[\"map阶段执行过程\",{\"0\":{\"965\":1}}],[\"map阶段的处理类\",{\"1\":{\"958\":1}}],[\"map阶段\",{\"0\":{\"958\":1}}],[\"mapwritable\",{\"1\":{\"956\":1}}],[\"map|reduce\",{\"1\":{\"942\":1}}],[\"mapping是处理数据的方式和规则方面做一些限制\",{\"1\":{\"1065\":1}}],[\"mapping\",{\"0\":{\"1065\":1},\"1\":{\"924\":1}}],[\"mapping组映射\",{\"0\":{\"924\":1}}],[\"mapperfactorybean\",{\"1\":{\"1280\":1,\"1455\":2}}],[\"mapperpostprocessor\",{\"1\":{\"1279\":1}}],[\"mapperscannerconfigurer\",{\"1\":{\"1270\":1,\"1455\":1}}],[\"mapperscan\",{\"1\":{\"1232\":1,\"1455\":3}}],[\"mapper分别读取不同的数据集\",{\"1\":{\"988\":1}}],[\"mapper\",{\"0\":{\"1278\":1},\"1\":{\"962\":1,\"1073\":6,\"1223\":3,\"1232\":1,\"1270\":1,\"1271\":1,\"1280\":1,\"1366\":1,\"1455\":4}}],[\"mapper的输出中\",{\"1\":{\"988\":1}}],[\"mapper的keyin和valuein分别对应着textinputformat返回的键值对\",{\"1\":{\"959\":1}}],[\"mapper的四个泛型分别为\",{\"1\":{\"959\":1}}],[\"mapper<longwritable\",{\"1\":{\"373\":1,\"958\":2,\"972\":2,\"973\":2,\"974\":2,\"983\":1,\"985\":2,\"986\":2,\"988\":5,\"990\":3}}],[\"mappedbytebuffer\",{\"1\":{\"861\":1}}],[\"map的执行流程为\",{\"1\":{\"961\":1}}],[\"map的value为需要缓存的值\",{\"1\":{\"577\":1}}],[\"map的key为threadlocal对象\",{\"1\":{\"577\":1}}],[\"map端join的关键是将小表文件做一个分布式缓存\",{\"1\":{\"448\":1}}],[\"mapred\",{\"1\":{\"963\":1}}],[\"mapredfiles=true\",{\"1\":{\"435\":1}}],[\"mapreduce框架在执行的时候会自动将缓存的数据分发到各个maptask运行的机器上\",{\"1\":{\"990\":1}}],[\"mapreduce框架在作业所有task执行之前会把指定的分布式缓存文件拷贝到各个task运行的节点上\",{\"1\":{\"989\":1}}],[\"mapreduce分布式缓存\",{\"0\":{\"989\":1}}],[\"mapreducer写入mysql操作\",{\"0\":{\"986\":1}}],[\"mapreduce读取mysql操作\",{\"0\":{\"985\":1}}],[\"mapreduce读取数据库操作\",{\"0\":{\"984\":1}}],[\"mapreduce提供partitioner接口\",{\"1\":{\"979\":1}}],[\"mapreduce工作流程详解\",{\"0\":{\"978\":1}}],[\"mapreduce并行度机制\",{\"0\":{\"975\":1}}],[\"mapreduce的默认分区规则是hashpartitioner\",{\"1\":{\"968\":1}}],[\"mapreduce的压缩主要可以在下面四个阶段\",{\"1\":{\"432\":1}}],[\"mapreduce流程梳理\",{\"0\":{\"964\":1}}],[\"mapreduce客户端程序驱动类\",{\"1\":{\"962\":1}}],[\"mapreduce程序中读取缓存文件\",{\"1\":{\"989\":1}}],[\"mapreduce程序运行模式\",{\"0\":{\"963\":1}}],[\"mapreduce程序会对数据先按key的字典序对键值对进行排序\",{\"1\":{\"961\":1}}],[\"mapreduce程序已采用其默认的读取数据组件textinputformat对文本数据进行了读取\",{\"1\":{\"959\":1}}],[\"mapreduce是一个离线计算框架\",{\"1\":{\"955\":1}}],[\"mapreduce相关介绍\",{\"0\":{\"955\":1}}],[\"mapreduce属性优化\",{\"0\":{\"443\":1}}],[\"mapreduce中每个小文件会启动一个maptask计算处理\",{\"1\":{\"435\":1}}],[\"mapreduce在处理数据之间join的时候有两种方式\",{\"1\":{\"418\":1}}],[\"mapreduce\",{\"0\":{\"954\":1,\"967\":1,\"968\":1,\"969\":1,\"981\":1,\"982\":1,\"987\":1,\"991\":1,\"992\":1,\"993\":1,\"1554\":1},\"1\":{\"313\":2,\"433\":5,\"445\":1,\"470\":1,\"951\":1,\"957\":2,\"963\":2,\"974\":1,\"984\":1,\"985\":1,\"991\":8}}],[\"mapfiles=true\",{\"1\":{\"435\":1}}],[\"map<long\",{\"1\":{\"1171\":1}}],[\"map<object\",{\"1\":{\"1111\":1,\"1224\":1}}],[\"map<attributekey<\",{\"1\":{\"740\":1}}],[\"map<channeloption<\",{\"1\":{\"740\":1}}],[\"map<class<\",{\"1\":{\"733\":1}}],[\"map<integer\",{\"1\":{\"671\":1,\"723\":1,\"738\":1}}],[\"map<statusenum\",{\"1\":{\"621\":1}}],[\"map<string\",{\"1\":{\"42\":1,\"256\":1,\"483\":1,\"990\":1,\"1035\":1,\"1107\":1,\"1172\":1,\"1213\":1,\"1232\":1,\"1416\":1,\"1429\":1}}],[\"map<k\",{\"1\":{\"339\":3,\"1113\":1}}],[\"mapjoindriver\",{\"1\":{\"990\":1}}],[\"mapjoinmapper\",{\"1\":{\"990\":2}}],[\"mapjoin\",{\"1\":{\"326\":2,\"418\":1,\"448\":1}}],[\"map映射kv之间的分隔符\",{\"1\":{\"252\":1}}],[\"map映射\",{\"1\":{\"248\":1,\"252\":1}}],[\"map\",{\"0\":{\"448\":1,\"990\":1},\"1\":{\"42\":3,\"252\":1,\"256\":1,\"290\":1,\"339\":6,\"373\":1,\"433\":2,\"444\":1,\"464\":1,\"469\":1,\"477\":3,\"483\":3,\"579\":1,\"617\":2,\"620\":1,\"621\":3,\"658\":1,\"733\":3,\"956\":1,\"958\":1,\"972\":1,\"973\":1,\"974\":1,\"979\":1,\"983\":1,\"985\":1,\"986\":1,\"988\":2,\"990\":2,\"991\":2,\"1113\":3,\"1152\":2,\"1162\":2,\"1165\":2,\"1171\":3,\"1213\":2,\"1355\":2,\"1429\":2,\"1482\":1,\"1489\":1}}],[\"main线程就先执行\",{\"1\":{\"1132\":1}}],[\"mainclass>\",{\"1\":{\"957\":1}}],[\"maintainable\",{\"1\":{\"789\":1}}],[\"main分区插入tmp\",{\"1\":{\"261\":1}}],[\"mainboard=\",{\"1\":{\"17\":2}}],[\"mainboard\",{\"1\":{\"17\":17}}],[\"main\",{\"1\":{\"6\":1,\"7\":1,\"14\":1,\"17\":2,\"43\":1,\"47\":2,\"51\":1,\"52\":1,\"54\":2,\"58\":1,\"59\":2,\"60\":1,\"68\":2,\"70\":1,\"73\":1,\"74\":1,\"81\":2,\"85\":1,\"102\":2,\"133\":1,\"260\":1,\"261\":3,\"281\":1,\"344\":1,\"536\":1,\"541\":1,\"551\":1,\"554\":3,\"555\":3,\"562\":1,\"614\":1,\"617\":1,\"645\":2,\"646\":1,\"648\":4,\"663\":2,\"668\":1,\"669\":1,\"692\":4,\"693\":2,\"696\":1,\"697\":3,\"698\":1,\"699\":3,\"702\":2,\"717\":1,\"718\":1,\"725\":1,\"726\":2,\"733\":2,\"735\":1,\"737\":1,\"740\":1,\"748\":1,\"750\":1,\"751\":1,\"753\":1,\"754\":1,\"760\":3,\"761\":1,\"762\":4,\"763\":3,\"764\":1,\"766\":1,\"776\":1,\"795\":2,\"796\":18,\"809\":1,\"820\":1,\"822\":1,\"834\":2,\"836\":7,\"839\":2,\"840\":1,\"843\":2,\"846\":1,\"848\":2,\"857\":3,\"859\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":5,\"999\":1,\"1244\":1,\"1257\":1,\"1304\":1,\"1306\":1,\"1309\":1,\"1317\":1,\"1441\":1,\"1442\":1,\"1444\":1,\"1446\":1,\"1449\":1}}],[\"mediatype\",{\"1\":{\"1398\":1,\"1411\":1}}],[\"menber\",{\"1\":{\"1171\":1}}],[\"messages\",{\"1\":{\"1244\":7}}],[\"messagesource\",{\"1\":{\"1244\":4}}],[\"messageconverter\",{\"0\":{\"1395\":1,\"1396\":1},\"1\":{\"1394\":2,\"1398\":3,\"1411\":1}}],[\"messagecodec\",{\"1\":{\"713\":3}}],[\"messagecodecsharable\",{\"1\":{\"702\":4,\"714\":1,\"723\":1,\"733\":4,\"735\":2,\"737\":2}}],[\"messageclasses\",{\"1\":{\"723\":16,\"733\":2}}],[\"messageclass\",{\"1\":{\"723\":2}}],[\"message>>\",{\"1\":{\"723\":1}}],[\"message>\",{\"1\":{\"714\":1,\"723\":3}}],[\"messagetomessagecodec<bytebuf\",{\"1\":{\"714\":1,\"723\":1}}],[\"messagetomessagecodec\",{\"1\":{\"714\":1}}],[\"messagetype\",{\"1\":{\"713\":2,\"714\":2,\"723\":7}}],[\"message\",{\"1\":{\"702\":10,\"703\":4,\"713\":9,\"714\":6,\"723\":12,\"733\":13,\"734\":6,\"735\":2,\"737\":2,\"775\":1,\"846\":1}}],[\"merge有三种形式\",{\"1\":{\"980\":1}}],[\"merge阶段\",{\"1\":{\"980\":1}}],[\"merge\",{\"1\":{\"258\":1,\"435\":4,\"450\":1,\"671\":1}}],[\"metrics\",{\"1\":{\"1046\":1}}],[\"metadata存储介质\",{\"1\":{\"241\":1}}],[\"metadata是存储在内置的derby中\",{\"1\":{\"241\":1}}],[\"metadata即hive的元数据\",{\"1\":{\"239\":1}}],[\"metadata\",{\"0\":{\"239\":1},\"1\":{\"238\":1,\"1025\":5,\"1466\":1}}],[\"metastore可以在不安装hive其他部分的情况下单独运行\",{\"1\":{\"474\":1}}],[\"metastore独立模式\",{\"0\":{\"474\":1}}],[\"metastore内运行\",{\"1\":{\"294\":1}}],[\"metastore单独配置\",{\"1\":{\"241\":1}}],[\"metastore服务在其自己的单独jvm上运行\",{\"1\":{\"244\":1}}],[\"metastore服务将通过jdbc与metastore数据库进行通信\",{\"1\":{\"243\":1}}],[\"metastore服务与主hiveserver进程在同一进程中运行\",{\"1\":{\"243\":1}}],[\"metastore服务是否需要单独配置\",{\"1\":{\"241\":1}}],[\"metastore服务配置有3种模式\",{\"1\":{\"241\":1}}],[\"metastore服务的作用是管理metadata元数据\",{\"1\":{\"240\":1}}],[\"metastore即元数据服务\",{\"1\":{\"240\":1}}],[\"metastore\",{\"0\":{\"240\":1,\"241\":1},\"1\":{\"234\":1,\"235\":1,\"242\":1,\"243\":2,\"244\":4,\"254\":1}}],[\"meta\",{\"1\":{\"146\":1,\"1443\":1,\"1464\":2,\"1465\":1,\"1476\":2}}],[\"methodbeforeadviceinterceptor\",{\"1\":{\"1343\":1}}],[\"methodbeforeadviceadapter\",{\"1\":{\"1343\":1}}],[\"methodinvocation\",{\"0\":{\"1344\":1},\"1\":{\"1340\":1,\"1343\":1,\"1346\":1}}],[\"methodinterceptor\",{\"1\":{\"60\":1,\"1306\":1,\"1317\":2,\"1322\":2,\"1325\":2,\"1343\":1,\"1350\":1}}],[\"methodname\",{\"1\":{\"733\":4}}],[\"methods\",{\"1\":{\"70\":2}}],[\"methodproxy\",{\"1\":{\"60\":4,\"1306\":3,\"1317\":2,\"1321\":1,\"1480\":1}}],[\"method\",{\"1\":{\"23\":3,\"59\":14,\"60\":3,\"84\":4,\"343\":4,\"567\":1,\"734\":3,\"737\":4,\"1152\":1,\"1257\":1,\"1304\":2,\"1306\":1,\"1309\":7,\"1317\":1,\"1384\":1}}],[\"megvii\",{\"1\":{\"146\":1}}],[\"member\",{\"1\":{\"701\":4,\"1170\":1,\"1171\":2,\"1210\":3,\"1211\":6}}],[\"members\",{\"1\":{\"701\":2,\"704\":4}}],[\"memset\",{\"1\":{\"646\":1}}],[\"memeber\",{\"1\":{\"1211\":1}}],[\"memery的时候\",{\"1\":{\"1119\":1}}],[\"meme\",{\"1\":{\"125\":1}}],[\"memory存储引擎支持hash和btree索引\",{\"1\":{\"485\":1}}],[\"memory=\",{\"1\":{\"17\":2}}],[\"memory\",{\"1\":{\"17\":17,\"74\":15,\"854\":1,\"1149\":1}}],[\"meeting\",{\"1\":{\"76\":1}}],[\"mb\",{\"1\":{\"1021\":1}}],[\"mbuilder\",{\"1\":{\"14\":5}}],[\"mbike\",{\"1\":{\"14\":8}}],[\"n多个线程\",{\"1\":{\"1155\":1}}],[\"nginx\",{\"1\":{\"1155\":2,\"1159\":1}}],[\"nginx基于七层模型走的事http协议\",{\"1\":{\"1094\":1}}],[\"nx满足互斥性\",{\"1\":{\"1147\":1}}],[\"nx\",{\"1\":{\"1141\":1,\"1147\":1}}],[\"nx是互斥\",{\"1\":{\"1141\":1}}],[\"n+1\",{\"1\":{\"1040\":1}}],[\"nm\",{\"1\":{\"942\":1,\"944\":1,\"947\":1,\"949\":3}}],[\"nn从缓存中取出一个新的edek\",{\"1\":{\"934\":1}}],[\"n456789abcdef\",{\"1\":{\"840\":1}}],[\"nworld\",{\"1\":{\"840\":1}}],[\"nhaha\",{\"1\":{\"809\":1}}],[\"nho\",{\"1\":{\"809\":2}}],[\"ntp4\",{\"1\":{\"878\":1}}],[\"ntpdate\",{\"1\":{\"878\":1}}],[\"nthreads\",{\"1\":{\"574\":3}}],[\"ntile函数即可以满足\",{\"1\":{\"364\":1}}],[\"ntile\",{\"0\":{\"364\":1},\"1\":{\"364\":2}}],[\"n的值可以在hadoop的mapred\",{\"1\":{\"445\":1}}],[\"nba\",{\"1\":{\"348\":6,\"349\":2}}],[\"nba总冠军球队名单分析\",{\"0\":{\"348\":1}}],[\"nvl\",{\"1\":{\"340\":4}}],[\"nil\",{\"1\":{\"1151\":3}}],[\"nil节点\",{\"1\":{\"656\":1}}],[\"nimbus\",{\"1\":{\"951\":1}}],[\"nián\",{\"1\":{\"920\":1}}],[\"ni\",{\"1\":{\"809\":2}}],[\"nick\",{\"1\":{\"407\":1,\"408\":1,\"409\":3}}],[\"ningbi\",{\"1\":{\"262\":1}}],[\"nioworkers\",{\"1\":{\"750\":2,\"751\":2}}],[\"niobyteunsafe\",{\"1\":{\"742\":1,\"744\":1,\"775\":1}}],[\"niomessageunsafe\",{\"1\":{\"742\":1,\"743\":1}}],[\"niounsafe\",{\"1\":{\"742\":1}}],[\"nioeventloop\",{\"0\":{\"741\":1,\"748\":1,\"750\":1,\"751\":1},\"1\":{\"726\":1,\"741\":4,\"742\":4,\"750\":1}}],[\"nioeventloopgroup\",{\"1\":{\"692\":11,\"693\":7,\"696\":2,\"697\":23,\"698\":21,\"699\":23,\"702\":6,\"710\":2,\"711\":4,\"725\":2,\"733\":6,\"735\":2,\"737\":2,\"740\":1,\"748\":29,\"750\":3,\"751\":6,\"753\":4,\"754\":2,\"758\":2,\"759\":1,\"766\":2,\"784\":2,\"785\":2,\"794\":3}}],[\"niosocketchannel\",{\"1\":{\"692\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":1,\"710\":1,\"725\":1,\"733\":1,\"735\":1,\"737\":1,\"743\":5,\"744\":1,\"748\":4,\"753\":4,\"754\":2,\"766\":2,\"784\":1,\"785\":2,\"794\":3}}],[\"nioserversocketchannel\",{\"1\":{\"692\":1,\"702\":1,\"711\":1,\"733\":1,\"740\":14,\"748\":2,\"766\":1,\"784\":2,\"794\":1}}],[\"nio方式适用于连接数目多且连接比较短的架构\",{\"1\":{\"612\":1}}],[\"nio的通道类似于流\",{\"1\":{\"610\":1}}],[\"nio的非阻塞模式\",{\"1\":{\"610\":1}}],[\"nio三大核心组件\",{\"1\":{\"610\":2}}],[\"nio是面向缓冲区编程的\",{\"1\":{\"610\":1}}],[\"nio有三大核心部分\",{\"1\":{\"610\":1}}],[\"nio包下\",{\"1\":{\"610\":1}}],[\"nio相关类都放在了java\",{\"1\":{\"610\":1}}],[\"nio全称java\",{\"1\":{\"610\":1}}],[\"nio基本介绍\",{\"1\":{\"610\":1}}],[\"nio\",{\"0\":{\"608\":1,\"610\":1,\"849\":1,\"855\":1,\"1550\":1},\"1\":{\"9\":1,\"608\":1,\"612\":2,\"725\":1,\"726\":1,\"740\":9,\"741\":2,\"742\":7,\"743\":7,\"744\":2,\"748\":6,\"753\":1,\"772\":1,\"775\":2,\"784\":1,\"785\":1,\"792\":1,\"795\":1,\"805\":1,\"826\":1,\"827\":1,\"833\":1,\"835\":1,\"836\":3,\"839\":1}}],[\"n个磁道才能存储\",{\"1\":{\"204\":1}}],[\"n个用户级线程映射到m个内核级线程\",{\"1\":{\"163\":1}}],[\"nru\",{\"1\":{\"191\":1}}],[\"n\",{\"0\":{\"362\":3,\"364\":1,\"727\":1},\"1\":{\"163\":2,\"264\":1,\"309\":2,\"336\":2,\"342\":12,\"351\":1,\"365\":2,\"399\":2,\"491\":1,\"497\":1,\"523\":1,\"579\":6,\"599\":1,\"605\":2,\"616\":2,\"645\":4,\"648\":12,\"649\":10,\"662\":2,\"663\":3,\"665\":1,\"669\":3,\"692\":7,\"693\":9,\"695\":1,\"697\":23,\"698\":22,\"699\":23,\"716\":1,\"748\":18,\"796\":17,\"799\":2,\"809\":8,\"836\":6,\"840\":4,\"859\":3,\"973\":1,\"977\":1,\"1022\":1,\"1040\":2}}],[\"native\",{\"1\":{\"876\":3}}],[\"nasm\",{\"1\":{\"876\":2}}],[\"nagle\",{\"1\":{\"694\":3}}],[\"nanotime\",{\"1\":{\"741\":2,\"742\":2,\"820\":2}}],[\"nanjing\",{\"1\":{\"197\":1}}],[\"nan355655600\",{\"1\":{\"145\":1}}],[\"name2\",{\"1\":{\"1206\":3}}],[\"namenode元数据管理\",{\"0\":{\"904\":1}}],[\"namenode就会认为该datanode失效\",{\"1\":{\"903\":1}}],[\"namenode所在机器通常会配置有大量内存\",{\"1\":{\"903\":1}}],[\"namenode是hadoop集群中的单点故障\",{\"1\":{\"903\":1}}],[\"namenode是hdfs的核心\",{\"1\":{\"903\":1}}],[\"namenode对于hdfs至关重要\",{\"1\":{\"903\":1}}],[\"namenode并不持久化存储每个文件中各个块所在的datanode的位置信息\",{\"1\":{\"903\":1}}],[\"namenode知道hdfs中任何给定文件的块列表及其位置\",{\"1\":{\"903\":1}}],[\"namenode不存储实际数据或数据集\",{\"1\":{\"903\":1}}],[\"namenode仅存储管理hdfs的元数据\",{\"1\":{\"903\":1}}],[\"namenode职责\",{\"1\":{\"903\":1}}],[\"namenode返回具有该块所有副本的datanode位置地址列表\",{\"1\":{\"902\":1}}],[\"namenode执行各种检查判断\",{\"1\":{\"901\":1}}],[\"namenode执行块管理\",{\"1\":{\"888\":1}}],[\"namenode单点故障问题\",{\"0\":{\"883\":1}}],[\"namenode检测到失败的ec块\",{\"1\":{\"875\":1}}],[\"namenode扩展\",{\"1\":{\"875\":1}}],[\"namenode\",{\"1\":{\"870\":4,\"875\":1,\"901\":1,\"926\":1}}],[\"namenode保持在安全模式\",{\"1\":{\"870\":1}}],[\"name就是在handler处理链中传递的数据\",{\"1\":{\"766\":1}}],[\"namespace\",{\"1\":{\"646\":1,\"669\":1}}],[\"names\",{\"1\":{\"621\":2,\"733\":2}}],[\"name被覆盖\",{\"1\":{\"519\":1}}],[\"name来决定导出位置\",{\"1\":{\"290\":1}}],[\"name指定其他的serde类来处理数据\",{\"1\":{\"251\":1}}],[\"name=yarn\",{\"1\":{\"963\":1}}],[\"name=\",{\"1\":{\"766\":1}}],[\"name=property\",{\"1\":{\"251\":1,\"278\":1}}],[\"name=name\",{\"1\":{\"76\":3}}],[\"name>\",{\"1\":{\"92\":1,\"872\":2,\"879\":1,\"910\":2,\"919\":1,\"926\":1,\"927\":4,\"936\":6,\"1219\":1}}],[\"name\",{\"1\":{\"42\":2,\"52\":6,\"54\":8,\"76\":9,\"81\":7,\"251\":1,\"256\":2,\"260\":1,\"261\":1,\"262\":1,\"264\":5,\"268\":1,\"276\":10,\"278\":4,\"279\":18,\"280\":7,\"281\":2,\"287\":2,\"288\":1,\"289\":2,\"290\":1,\"298\":2,\"313\":1,\"315\":6,\"316\":4,\"318\":3,\"320\":3,\"321\":2,\"322\":2,\"323\":2,\"336\":2,\"339\":4,\"340\":1,\"347\":1,\"348\":3,\"349\":3,\"351\":7,\"357\":2,\"374\":1,\"480\":2,\"519\":4,\"701\":16,\"702\":5,\"733\":4,\"766\":7,\"963\":1,\"1073\":1,\"1079\":1,\"1082\":1,\"1083\":2,\"1142\":2,\"1144\":3,\"1146\":12,\"1147\":1,\"1186\":1,\"1205\":3,\"1206\":12,\"1207\":2,\"1208\":9,\"1213\":6,\"1221\":5,\"1223\":4,\"1224\":1,\"1230\":12,\"1234\":3,\"1235\":3,\"1236\":2,\"1525\":5}}],[\"nouniquebeandefinitionexception\",{\"1\":{\"1482\":1}}],[\"nowsecond\",{\"1\":{\"1132\":2}}],[\"now\",{\"1\":{\"1128\":2,\"1129\":2,\"1132\":4,\"1134\":2,\"1137\":2,\"1142\":2,\"1150\":2,\"1175\":4,\"1176\":4}}],[\"noargsconstructor\",{\"1\":{\"1089\":1,\"1525\":1}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"1482\":1}}],[\"nosuchfileexception\",{\"1\":{\"822\":2}}],[\"nosuchmethoderror\",{\"1\":{\"59\":1,\"1309\":1}}],[\"nosuchmethodexception\",{\"1\":{\"59\":3,\"1309\":1}}],[\"nosql可以翻译做not\",{\"1\":{\"1184\":1}}],[\"nosql\",{\"1\":{\"791\":1,\"1182\":1}}],[\"nodemanager通信\",{\"1\":{\"953\":1}}],[\"nodemanager是每个节点上的资源和任务管理器\",{\"1\":{\"946\":1}}],[\"nodemanager\",{\"0\":{\"946\":1},\"1\":{\"944\":1,\"953\":2}}],[\"node3\",{\"1\":{\"936\":1}}],[\"node3不需要参与\",{\"1\":{\"879\":1}}],[\"node2\",{\"1\":{\"910\":2,\"936\":1}}],[\"node检测到jn\",{\"1\":{\"886\":1}}],[\"node4\",{\"1\":{\"878\":2,\"879\":2}}],[\"node1\",{\"1\":{\"878\":2,\"879\":1,\"910\":2,\"926\":3,\"936\":3,\"1050\":1}}],[\"nodelay\",{\"0\":{\"728\":1},\"1\":{\"694\":1}}],[\"node\",{\"0\":{\"886\":1},\"1\":{\"585\":2,\"669\":9,\"884\":1,\"886\":1}}],[\"node<k\",{\"1\":{\"579\":16}}],[\"node是否宕机了\",{\"1\":{\"526\":1}}],[\"node上进行\",{\"1\":{\"886\":1}}],[\"node上\",{\"1\":{\"526\":1}}],[\"node挂掉了\",{\"1\":{\"526\":1}}],[\"no\",{\"1\":{\"522\":1,\"579\":1}}],[\"normalize\",{\"1\":{\"821\":1}}],[\"normal\",{\"1\":{\"481\":1,\"750\":2}}],[\"noconditionaltask=true\",{\"1\":{\"450\":1}}],[\"noconditionaltask\",{\"1\":{\"448\":1}}],[\"noclassdeffounderror\",{\"1\":{\"59\":1}}],[\"nonblocking\",{\"1\":{\"679\":2}}],[\"non\",{\"1\":{\"610\":1}}],[\"nonfairsync\",{\"1\":{\"591\":2}}],[\"nonematch\",{\"1\":{\"619\":2}}],[\"none\",{\"1\":{\"302\":1}}],[\"nonstrict\",{\"1\":{\"268\":1,\"276\":1,\"289\":1,\"297\":1,\"298\":1}}],[\"nohup\",{\"1\":{\"244\":1,\"1012\":2,\"1045\":1}}],[\"notblank\",{\"1\":{\"1525\":3}}],[\"notation\",{\"1\":{\"1063\":1}}],[\"notify不能先notify\",{\"1\":{\"549\":1}}],[\"notifyall是唤醒所有等待线程\",{\"1\":{\"549\":1}}],[\"notify和notifyall必须配合object\",{\"1\":{\"549\":1}}],[\"notify\",{\"1\":{\"549\":1,\"554\":2,\"555\":3}}],[\"notifyobservers\",{\"1\":{\"47\":2}}],[\"note\",{\"1\":{\"290\":1}}],[\"notes\",{\"1\":{\"128\":1}}],[\"not\",{\"1\":{\"76\":1,\"256\":1,\"260\":1,\"261\":1,\"278\":1,\"285\":1,\"286\":1,\"317\":1,\"330\":5,\"332\":6,\"369\":1,\"1164\":5,\"1174\":5,\"1206\":1,\"1514\":1}}],[\"nu\",{\"1\":{\"1046\":1}}],[\"numpartitions\",{\"1\":{\"973\":2}}],[\"numreducetasks\",{\"1\":{\"968\":2}}],[\"numtasks=10\",{\"1\":{\"445\":1}}],[\"numerator\",{\"1\":{\"369\":1}}],[\"nums下标从0开始\",{\"1\":{\"673\":1}}],[\"nums\",{\"1\":{\"349\":2,\"353\":7,\"354\":5,\"355\":1,\"673\":9}}],[\"num\",{\"1\":{\"264\":1,\"276\":1,\"280\":1,\"287\":2,\"288\":1,\"289\":2,\"290\":1,\"313\":1,\"315\":7,\"316\":4,\"317\":2,\"318\":12,\"336\":1,\"338\":1,\"340\":1,\"351\":1,\"1021\":2,\"1176\":5,\"1206\":1}}],[\"number的概念\",{\"1\":{\"1029\":1}}],[\"number=16\",{\"1\":{\"446\":1}}],[\"number家族\",{\"0\":{\"363\":1}}],[\"number等\",{\"1\":{\"358\":1}}],[\"number\",{\"1\":{\"47\":3,\"363\":3,\"365\":4,\"403\":2,\"404\":1,\"718\":2,\"1029\":2}}],[\"numbergenerator\",{\"1\":{\"47\":6}}],[\"nunbergenerator\",{\"1\":{\"47\":1}}],[\"null<>1的返回结果是null\",{\"1\":{\"482\":1}}],[\"null<>null的返回结果是null\",{\"1\":{\"482\":1}}],[\"null=null的返回结果是null\",{\"1\":{\"482\":1}}],[\"null与任何值的直接比较都为null\",{\"1\":{\"482\":1}}],[\"nullwritable\",{\"1\":{\"373\":2,\"956\":1,\"973\":2,\"974\":8,\"986\":7,\"988\":2,\"990\":1,\"991\":1}}],[\"nullwritable>\",{\"1\":{\"373\":1,\"973\":2,\"974\":4,\"986\":2,\"988\":2,\"990\":3}}],[\"nullif\",{\"1\":{\"340\":4}}],[\"null空值判断\",{\"1\":{\"330\":1}}],[\"nullpointerexception\",{\"1\":{\"6\":1,\"88\":1,\"579\":1,\"741\":1}}],[\"null\",{\"1\":{\"6\":2,\"22\":4,\"23\":3,\"28\":1,\"30\":1,\"59\":4,\"66\":6,\"68\":2,\"69\":6,\"88\":1,\"330\":3,\"340\":10,\"344\":1,\"351\":2,\"353\":4,\"354\":4,\"409\":1,\"565\":1,\"579\":21,\"585\":1,\"668\":6,\"669\":5,\"671\":2,\"701\":5,\"703\":1,\"704\":3,\"713\":1,\"723\":2,\"725\":1,\"737\":3,\"738\":2,\"740\":6,\"741\":2,\"742\":1,\"743\":2,\"744\":3,\"748\":2,\"756\":1,\"760\":1,\"762\":1,\"763\":1,\"827\":2,\"840\":1,\"843\":1,\"846\":3,\"857\":1,\"859\":2,\"956\":1,\"973\":1,\"988\":1,\"990\":2,\"1023\":1,\"1025\":2,\"1099\":2,\"1100\":1,\"1107\":2,\"1111\":1,\"1122\":1,\"1124\":5,\"1127\":5,\"1128\":2,\"1129\":12,\"1152\":10,\"1156\":1,\"1160\":1,\"1161\":1,\"1162\":4,\"1164\":4,\"1165\":1,\"1168\":1,\"1172\":3,\"1174\":6,\"1176\":1,\"1213\":1,\"1216\":1,\"1234\":1,\"1235\":2,\"1244\":3,\"1254\":1,\"1420\":1,\"1435\":1,\"1438\":3,\"1464\":1,\"1466\":1,\"1505\":1}}],[\"never\",{\"1\":{\"1514\":1}}],[\"neverregistered\",{\"1\":{\"740\":2,\"743\":2}}],[\"needstoselectagain\",{\"1\":{\"741\":1}}],[\"neck部分就是多尺度特征融合的过程\",{\"1\":{\"137\":1}}],[\"neck\",{\"0\":{\"137\":1}}],[\"neurips\",{\"1\":{\"124\":2}}],[\"netutil\",{\"1\":{\"726\":1}}],[\"netty概述\",{\"0\":{\"788\":1}}],[\"netty<\",{\"1\":{\"783\":1}}],[\"netty源码分析\",{\"0\":{\"739\":1}}],[\"netty优化\",{\"0\":{\"722\":1}}],[\"netty\",{\"0\":{\"758\":1,\"789\":1,\"790\":1,\"791\":1,\"792\":1,\"1545\":1},\"1\":{\"693\":2,\"694\":1,\"713\":1,\"725\":1,\"726\":2,\"731\":1,\"740\":15,\"741\":4,\"742\":6,\"743\":8,\"744\":4,\"746\":7,\"749\":1,\"755\":1,\"756\":7,\"762\":5,\"765\":18,\"770\":1,\"772\":1,\"775\":5,\"780\":1,\"785\":1,\"789\":2,\"791\":3,\"792\":4,\"795\":1}}],[\"network\",{\"1\":{\"244\":1,\"789\":1,\"878\":1}}],[\"networks\",{\"1\":{\"117\":1,\"120\":1,\"127\":1,\"128\":1}}],[\"net\",{\"1\":{\"145\":4,\"543\":1,\"544\":1,\"545\":1,\"549\":1,\"726\":3}}],[\"netron可视化yolov3网络结构\",{\"1\":{\"145\":1}}],[\"net网络结构\",{\"1\":{\"130\":1}}],[\"nets\",{\"1\":{\"124\":1,\"130\":1}}],[\"nexus\",{\"1\":{\"92\":1}}],[\"nextid\",{\"1\":{\"737\":1,\"999\":3,\"1132\":2,\"1134\":1,\"1137\":3,\"1156\":1,\"1157\":2}}],[\"nextint\",{\"1\":{\"47\":1,\"81\":2,\"645\":2,\"648\":8,\"697\":1,\"698\":1,\"699\":1,\"1035\":1}}],[\"nextline\",{\"1\":{\"702\":3,\"754\":1,\"794\":1}}],[\"nextlogin\",{\"1\":{\"400\":5}}],[\"nextnode\",{\"1\":{\"668\":8}}],[\"nexttable\",{\"1\":{\"579\":1}}],[\"nextday\",{\"1\":{\"400\":5}}],[\"nexthand2\",{\"1\":{\"81\":3}}],[\"nexthand1\",{\"1\":{\"81\":3}}],[\"nexthand\",{\"1\":{\"81\":7}}],[\"next\",{\"1\":{\"43\":1,\"167\":2,\"279\":1,\"365\":2,\"511\":1,\"579\":3,\"743\":1,\"746\":4,\"749\":6,\"758\":1,\"759\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":2,\"846\":2}}],[\"nested\",{\"1\":{\"69\":1,\"1514\":2}}],[\"new修饰的内部方法都会开启自己的新事务\",{\"1\":{\"1514\":1}}],[\"newgeosearchargs\",{\"1\":{\"1172\":1}}],[\"newtimeout\",{\"1\":{\"1152\":2}}],[\"new出来的对象\",{\"1\":{\"1137\":1}}],[\"newr\",{\"1\":{\"1129\":2}}],[\"news\",{\"1\":{\"923\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"574\":3,\"1157\":1}}],[\"newbuilder\",{\"1\":{\"1113\":1}}],[\"newbuffer\",{\"1\":{\"840\":3}}],[\"newbandwidth\",{\"1\":{\"873\":1}}],[\"newpos\",{\"1\":{\"817\":2}}],[\"newpromise\",{\"1\":{\"740\":1}}],[\"newproxyinstance\",{\"1\":{\"59\":3,\"737\":1,\"1304\":1}}],[\"newproxyinstance方法\",{\"1\":{\"59\":1}}],[\"newattrarray\",{\"1\":{\"740\":1}}],[\"newoptionarray\",{\"1\":{\"740\":1}}],[\"newnode\",{\"1\":{\"668\":7}}],[\"new指令之后会接着就是执行方法\",{\"1\":{\"630\":1}}],[\"new的时候可以给arraylist设置数组的长度值\",{\"1\":{\"601\":1}}],[\"newdata\",{\"1\":{\"590\":1}}],[\"newchannel\",{\"1\":{\"740\":1}}],[\"newcachedthreadpool\",{\"1\":{\"574\":2}}],[\"newcondition\",{\"1\":{\"554\":1,\"555\":1}}],[\"newfixedthreadpool\",{\"1\":{\"574\":4,\"593\":2,\"757\":1,\"1128\":1,\"1129\":1}}],[\"newline\",{\"1\":{\"373\":2,\"768\":1,\"795\":2,\"799\":5}}],[\"newinstance\",{\"1\":{\"42\":1,\"68\":2,\"69\":2,\"733\":1}}],[\"new\",{\"1\":{\"6\":4,\"7\":4,\"14\":5,\"17\":3,\"22\":4,\"23\":3,\"28\":3,\"30\":2,\"34\":2,\"39\":4,\"42\":2,\"43\":1,\"47\":8,\"51\":1,\"52\":1,\"54\":8,\"58\":2,\"59\":17,\"60\":2,\"66\":7,\"68\":6,\"69\":3,\"70\":3,\"73\":3,\"74\":4,\"81\":9,\"85\":2,\"88\":2,\"160\":1,\"279\":5,\"280\":1,\"344\":1,\"373\":1,\"483\":1,\"536\":2,\"538\":1,\"541\":1,\"551\":4,\"554\":14,\"555\":15,\"562\":1,\"566\":4,\"574\":7,\"579\":4,\"585\":7,\"590\":1,\"591\":1,\"592\":2,\"593\":2,\"615\":6,\"617\":1,\"621\":1,\"629\":1,\"645\":2,\"648\":8,\"649\":2,\"668\":3,\"669\":1,\"671\":1,\"673\":1,\"692\":13,\"693\":1,\"696\":6,\"697\":8,\"698\":7,\"699\":7,\"702\":29,\"703\":4,\"704\":9,\"707\":5,\"710\":5,\"711\":9,\"713\":12,\"714\":6,\"717\":3,\"718\":4,\"723\":20,\"725\":5,\"726\":6,\"733\":18,\"734\":1,\"735\":10,\"737\":12,\"738\":1,\"740\":12,\"741\":2,\"743\":2,\"746\":2,\"748\":18,\"749\":1,\"750\":1,\"751\":1,\"753\":19,\"754\":9,\"757\":1,\"758\":3,\"759\":3,\"760\":2,\"761\":2,\"762\":3,\"763\":3,\"764\":3,\"765\":2,\"766\":15,\"768\":1,\"772\":1,\"776\":2,\"779\":2,\"780\":4,\"784\":5,\"785\":5,\"794\":11,\"795\":14,\"796\":1,\"799\":12,\"807\":2,\"808\":4,\"820\":4,\"822\":6,\"826\":3,\"827\":2,\"834\":2,\"836\":1,\"839\":3,\"840\":2,\"843\":3,\"846\":9,\"848\":2,\"854\":3,\"857\":1,\"859\":4,\"958\":2,\"960\":1,\"962\":7,\"972\":8,\"973\":7,\"974\":6,\"985\":3,\"986\":3,\"988\":14,\"989\":1,\"990\":6,\"991\":9,\"992\":1,\"999\":5,\"1023\":3,\"1024\":2,\"1025\":2,\"1035\":1,\"1071\":3,\"1072\":3,\"1073\":14,\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":3,\"1084\":2,\"1085\":2,\"1088\":2,\"1089\":3,\"1100\":2,\"1101\":1,\"1107\":1,\"1111\":1,\"1113\":3,\"1127\":1,\"1128\":2,\"1129\":3,\"1132\":1,\"1133\":1,\"1134\":1,\"1137\":3,\"1142\":1,\"1147\":2,\"1150\":2,\"1152\":2,\"1156\":3,\"1157\":2,\"1159\":2,\"1161\":1,\"1164\":2,\"1165\":3,\"1168\":2,\"1171\":3,\"1172\":4,\"1180\":1,\"1213\":1,\"1215\":2,\"1216\":1,\"1222\":2,\"1223\":2,\"1232\":3,\"1234\":1,\"1235\":2,\"1244\":2,\"1257\":3,\"1304\":2,\"1306\":1,\"1309\":8,\"1317\":3,\"1413\":2,\"1416\":5,\"1420\":2,\"1424\":2,\"1429\":6,\"1432\":6,\"1435\":2,\"1449\":5,\"1451\":1,\"1464\":3,\"1466\":1,\"1514\":1}}],[\"+x\",{\"1\":{\"1046\":1}}],[\"+goodsinfo\",{\"1\":{\"990\":1}}],[\"+表示增加了文件\",{\"1\":{\"914\":1}}],[\"+buf2\",{\"1\":{\"779\":1}}],[\"+t\",{\"1\":{\"683\":1}}],[\"+k∗w\",{\"1\":{\"649\":1}}],[\"+useconcmarksweepgc的话\",{\"1\":{\"640\":1}}],[\"+useconcmarksweepgc来开启cms收集器的话\",{\"1\":{\"640\":1}}],[\"+1\",{\"1\":{\"477\":1,\"576\":1,\"698\":1,\"1151\":2,\"1161\":2,\"1176\":1}}],[\"+λnoobj​i=0∑s2​j=0∑b​1i\",{\"1\":{\"140\":1}}],[\"+i=1∑n​bce\",{\"1\":{\"140\":1}}],[\"+i=0∑s2​j=0∑b​1i\",{\"1\":{\"140\":1}}],[\"+pg​\",{\"1\":{\"122\":1}}],[\"++bincount\",{\"1\":{\"579\":1}}],[\"++i\",{\"1\":{\"562\":1}}],[\"++\",{\"1\":{\"81\":2,\"742\":1,\"743\":1}}],[\"+=\",{\"1\":{\"81\":1,\"646\":1,\"673\":3,\"843\":1,\"960\":1,\"972\":2}}],[\"+\",{\"1\":{\"6\":2,\"17\":26,\"47\":1,\"51\":1,\"52\":1,\"54\":3,\"73\":4,\"74\":2,\"76\":6,\"81\":15,\"88\":1,\"166\":1,\"167\":2,\"170\":1,\"179\":1,\"184\":1,\"188\":1,\"197\":1,\"214\":1,\"326\":2,\"328\":1,\"329\":1,\"336\":1,\"351\":3,\"511\":1,\"526\":1,\"551\":1,\"562\":3,\"576\":1,\"579\":2,\"621\":2,\"637\":1,\"645\":4,\"648\":5,\"649\":4,\"663\":1,\"669\":3,\"673\":4,\"679\":1,\"692\":10,\"693\":20,\"697\":110,\"698\":110,\"699\":111,\"704\":7,\"709\":1,\"717\":1,\"718\":2,\"725\":1,\"726\":4,\"742\":2,\"748\":60,\"753\":2,\"766\":4,\"768\":2,\"772\":20,\"773\":10,\"774\":30,\"775\":1,\"776\":60,\"779\":40,\"780\":20,\"784\":1,\"785\":1,\"799\":38,\"805\":20,\"807\":30,\"808\":20,\"809\":2,\"820\":4,\"836\":20,\"840\":1,\"843\":3,\"846\":1,\"848\":10,\"857\":10,\"875\":1,\"920\":1,\"934\":1,\"972\":2,\"974\":4,\"976\":1,\"985\":10,\"988\":11,\"990\":3,\"999\":4,\"1023\":1,\"1049\":1,\"1107\":2,\"1111\":1,\"1122\":3,\"1124\":3,\"1126\":1,\"1127\":5,\"1128\":3,\"1129\":5,\"1132\":5,\"1133\":1,\"1135\":1,\"1142\":3,\"1144\":6,\"1147\":2,\"1150\":2,\"1152\":2,\"1156\":1,\"1157\":1,\"1161\":3,\"1162\":7,\"1165\":3,\"1167\":1,\"1168\":4,\"1171\":1,\"1172\":3,\"1174\":5,\"1175\":2,\"1176\":2,\"1180\":1,\"1195\":1,\"1213\":2,\"1221\":1,\"1223\":2,\"1224\":1,\"1232\":1,\"1257\":3,\"1317\":2,\"1394\":1,\"1441\":2,\"1526\":2}}],[\"pgsql\",{\"1\":{\"1236\":1}}],[\"ps\",{\"1\":{\"985\":7}}],[\"psw\",{\"1\":{\"156\":1,\"157\":1}}],[\"pk即primary\",{\"1\":{\"480\":1}}],[\"pexpire\",{\"1\":{\"1151\":2}}],[\"pendingregistrationpromise\",{\"1\":{\"740\":2}}],[\"people\",{\"1\":{\"495\":2}}],[\"perf\",{\"1\":{\"1021\":2}}],[\"performance\",{\"1\":{\"789\":1,\"841\":1}}],[\"permissions\",{\"1\":{\"919\":2}}],[\"permits\",{\"1\":{\"591\":7}}],[\"per\",{\"1\":{\"435\":1,\"799\":1}}],[\"percent\",{\"1\":{\"368\":1,\"979\":2}}],[\"peterson算法\",{\"1\":{\"169\":1}}],[\"pvs\",{\"1\":{\"1505\":2}}],[\"pv4\",{\"1\":{\"361\":1}}],[\"pv2\",{\"1\":{\"361\":1}}],[\"pv\",{\"1\":{\"359\":4,\"360\":15,\"361\":6,\"363\":8,\"364\":5,\"1179\":1}}],[\"p1\",{\"1\":{\"336\":1,\"377\":6}}],[\"png\",{\"1\":{\"197\":1}}],[\"p2进程申请资源r1\",{\"1\":{\"175\":1}}],[\"p2分别申请并占有了资源r1\",{\"1\":{\"175\":1}}],[\"p操作\",{\"1\":{\"171\":1}}],[\"p0和p1都无法进入临界区\",{\"1\":{\"169\":1}}],[\"p0和p1将会同时访问临界区\",{\"1\":{\"169\":1}}],[\"pct\",{\"1\":{\"870\":1}}],[\"pc寄存器为什么要设定为线程私有\",{\"1\":{\"625\":1}}],[\"pcb会常驻内存\",{\"1\":{\"181\":1}}],[\"pcb记录进程数据\",{\"1\":{\"164\":1}}],[\"pcb的组成\",{\"1\":{\"159\":1}}],[\"pcb\",{\"1\":{\"159\":2}}],[\"pc​\",{\"1\":{\"140\":1}}],[\"py\",{\"1\":{\"146\":1}}],[\"pytorch\",{\"1\":{\"131\":1,\"146\":1}}],[\"pjreddie\",{\"1\":{\"144\":2}}],[\"phase>\",{\"1\":{\"344\":1}}],[\"phonum\",{\"1\":{\"344\":9}}],[\"phonenumberudf\",{\"1\":{\"344\":4}}],[\"phone\",{\"1\":{\"17\":16,\"407\":1,\"408\":1,\"409\":3,\"1099\":7,\"1107\":7,\"1223\":1}}],[\"php\",{\"1\":{\"336\":1,\"377\":6}}],[\"phno\",{\"1\":{\"321\":2,\"322\":2}}],[\"phillipi\",{\"1\":{\"131\":1}}],[\"ping\",{\"1\":{\"1199\":1}}],[\"pingmessage\",{\"1\":{\"707\":1,\"723\":1}}],[\"pid\",{\"1\":{\"1029\":3}}],[\"pipeline管道\",{\"0\":{\"898\":1}}],[\"pipeline\",{\"0\":{\"766\":1},\"1\":{\"692\":3,\"696\":2,\"697\":3,\"698\":3,\"699\":3,\"702\":8,\"707\":4,\"710\":2,\"711\":4,\"733\":8,\"735\":4,\"737\":4,\"740\":13,\"743\":12,\"744\":9,\"748\":3,\"749\":1,\"752\":1,\"753\":4,\"754\":2,\"766\":13,\"775\":5,\"784\":2,\"785\":1,\"787\":4,\"794\":3}}],[\"pixsrv\",{\"1\":{\"131\":1}}],[\"pix2pix在语义标签图转真实照片\",{\"1\":{\"130\":1}}],[\"pix2pix\",{\"1\":{\"130\":1,\"131\":2,\"133\":2}}],[\"picture2\",{\"1\":{\"197\":1}}],[\"pic\",{\"1\":{\"117\":1}}],[\"pdata\",{\"1\":{\"122\":1}}],[\"pdf\",{\"1\":{\"117\":2,\"124\":1}}],[\"plus多数据源\",{\"0\":{\"1236\":1},\"1\":{\"1236\":1}}],[\"plus包中的stringutils\",{\"1\":{\"1234\":1}}],[\"plus的解决方案\",{\"0\":{\"1234\":1}}],[\"plus\",{\"0\":{\"1227\":1,\"1233\":1},\"1\":{\"1236\":2}}],[\"plusseconds\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"plugin\",{\"1\":{\"1300\":1}}],[\"plugin>\",{\"1\":{\"102\":2,\"112\":1,\"344\":1,\"957\":2,\"1022\":1,\"1219\":1}}],[\"plugin<\",{\"1\":{\"102\":2,\"112\":1,\"344\":1,\"957\":2,\"1022\":1,\"1219\":1}}],[\"plugin标签引入插件\",{\"1\":{\"102\":1}}],[\"plugins>\",{\"1\":{\"102\":1,\"112\":1,\"344\":1,\"957\":1,\"1022\":1,\"1219\":1}}],[\"plugins<\",{\"1\":{\"102\":1,\"112\":1,\"344\":1,\"957\":2,\"1022\":1}}],[\"plugins\",{\"1\":{\"102\":1}}],[\"please\",{\"1\":{\"775\":1}}],[\"plaintext\",{\"1\":{\"1018\":1}}],[\"platformdependent\",{\"1\":{\"740\":3}}],[\"plan\",{\"1\":{\"442\":1}}],[\"player\",{\"1\":{\"81\":7}}],[\"pointcutadvisor\",{\"1\":{\"1322\":1}}],[\"pointcut\",{\"1\":{\"1322\":2}}],[\"point\",{\"1\":{\"882\":1,\"1171\":1}}],[\"pongmessage\",{\"1\":{\"723\":1}}],[\"portlet\",{\"1\":{\"1499\":1}}],[\"port=9988\",{\"1\":{\"1045\":1}}],[\"port=16001\",{\"1\":{\"936\":1}}],[\"port=16000\",{\"1\":{\"936\":1}}],[\"port\",{\"1\":{\"723\":1,\"1088\":3,\"1196\":1,\"1220\":1}}],[\"port>\",{\"1\":{\"102\":1}}],[\"pop\",{\"1\":{\"669\":1}}],[\"pooldatasourceimpl\",{\"1\":{\"1454\":1}}],[\"pooleddatasource\",{\"1\":{\"1454\":2}}],[\"pooledbytebuf\",{\"1\":{\"775\":1}}],[\"pool2<\",{\"1\":{\"1219\":1}}],[\"poolconfig\",{\"1\":{\"1215\":6}}],[\"pool的使用大大提高了读写数据的效率\",{\"1\":{\"506\":1}}],[\"pool中的数据写入磁盘是以数据页为单位进行的\",{\"1\":{\"506\":1}}],[\"pool中的数据写入磁盘属于随机io\",{\"1\":{\"506\":1}}],[\"pool中的数据\",{\"1\":{\"506\":1}}],[\"pool中修改的数据写入磁盘要快呢\",{\"1\":{\"506\":1}}],[\"pool中修改的数据还没有刷新到磁盘\",{\"1\":{\"506\":1}}],[\"pool中修改的数据会定期刷新到磁盘中\",{\"1\":{\"506\":1}}],[\"pool中没有\",{\"1\":{\"506\":1}}],[\"pool中读取\",{\"1\":{\"506\":1}}],[\"pool中包含了磁盘中部分数据页的映射\",{\"1\":{\"506\":1}}],[\"pool\",{\"1\":{\"506\":4,\"1115\":1,\"1219\":1,\"1220\":1,\"1466\":1}}],[\"pojo类的布尔属性不能加is\",{\"1\":{\"483\":1}}],[\"policies\",{\"1\":{\"875\":1}}],[\"policyfile\",{\"1\":{\"875\":1}}],[\"policy指定\",{\"1\":{\"875\":1}}],[\"policy\",{\"1\":{\"374\":1,\"875\":7}}],[\"poll高很多\",{\"1\":{\"680\":1}}],[\"poll中\",{\"1\":{\"680\":1}}],[\"poll还有一个特点就是\",{\"1\":{\"680\":1}}],[\"poll本质上和select没有区别\",{\"1\":{\"680\":2}}],[\"poll和epoll时要根据具体的使用场合以及这三种方式的自身特点\",{\"1\":{\"680\":1}}],[\"poll和epoll都是io多路复用的机制\",{\"1\":{\"680\":1}}],[\"poll和epoll的区别\",{\"0\":{\"680\":1}}],[\"poll和epoll\",{\"1\":{\"679\":2}}],[\"poll\",{\"1\":{\"675\":1,\"680\":4,\"846\":1,\"1024\":2}}],[\"poloclub\",{\"1\":{\"125\":1}}],[\"postman\",{\"1\":{\"1440\":1}}],[\"postmapping\",{\"1\":{\"1133\":2,\"1159\":2,\"1175\":1,\"1525\":1,\"1526\":1,\"1531\":1}}],[\"posthandle\",{\"1\":{\"1438\":1,\"1532\":1}}],[\"postprocessbeforedestruction\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"postprocessbeforeinitialization\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"postprocessbeforeinstantiation\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"postprocessproperties\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"postprocessafterinstantiation\",{\"1\":{\"1254\":1,\"1505\":1}}],[\"postprocessafterinitialization\",{\"1\":{\"1254\":2,\"1505\":1}}],[\"postgres\",{\"1\":{\"1236\":1}}],[\"postgresql\",{\"1\":{\"1236\":2}}],[\"postconstruct修饰的发给发将在bean实例化后被调用\",{\"1\":{\"1503\":1}}],[\"postconstruct\",{\"1\":{\"1157\":1,\"1254\":1,\"1264\":1,\"1285\":1,\"1289\":2,\"1503\":1,\"1505\":1}}],[\"posttags\",{\"1\":{\"1083\":1}}],[\"postvisitdirectory\",{\"1\":{\"822\":2}}],[\"post\",{\"1\":{\"651\":1,\"1004\":1,\"1179\":1,\"1462\":1}}],[\"position\",{\"1\":{\"610\":1,\"798\":3,\"799\":6,\"803\":2,\"804\":1,\"808\":1,\"809\":1,\"817\":3,\"820\":5,\"840\":3}}],[\"pos是从1开始的索引\",{\"1\":{\"336\":1}}],[\"pos\",{\"1\":{\"336\":2,\"817\":1}}],[\"pom不会讲项目打包\",{\"1\":{\"98\":1}}],[\"pom\",{\"1\":{\"97\":1,\"98\":2,\"99\":1,\"100\":2,\"101\":2,\"107\":1,\"112\":3,\"113\":3,\"114\":3,\"115\":3,\"1172\":2,\"1219\":2,\"1440\":3,\"1521\":1}}],[\"poursauce\",{\"1\":{\"85\":4}}],[\"pourvegetable\",{\"1\":{\"85\":4}}],[\"pouroil\",{\"1\":{\"85\":2}}],[\"payloadapplicationevent\",{\"1\":{\"1497\":1}}],[\"padding\",{\"1\":{\"799\":6}}],[\"paddings\",{\"1\":{\"799\":2}}],[\"page<shop>\",{\"1\":{\"1172\":1}}],[\"page<>\",{\"1\":{\"1161\":1,\"1165\":1,\"1172\":1}}],[\"page<blog>\",{\"1\":{\"1161\":1,\"1165\":1}}],[\"page<product>\",{\"1\":{\"1089\":2}}],[\"pagerequest\",{\"1\":{\"1089\":8}}],[\"pagesize\",{\"1\":{\"1089\":4}}],[\"page\",{\"1\":{\"678\":1,\"1161\":4,\"1165\":4,\"1167\":1,\"1172\":6}}],[\"packet默认64k\",{\"1\":{\"901\":1}}],[\"packed\",{\"1\":{\"663\":6}}],[\"packaging>\",{\"1\":{\"98\":1,\"107\":1,\"108\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"package\",{\"1\":{\"59\":1,\"95\":2,\"974\":1}}],[\"passwd\",{\"1\":{\"924\":1}}],[\"passwd和\",{\"1\":{\"924\":1}}],[\"password=123456\",{\"1\":{\"1046\":1}}],[\"password=www\",{\"1\":{\"1046\":1}}],[\"password需在当前目录自己创建\",{\"1\":{\"936\":1}}],[\"password<\",{\"1\":{\"936\":1}}],[\"password\",{\"1\":{\"272\":2,\"701\":2,\"702\":4,\"703\":2,\"936\":1,\"1220\":1,\"1236\":2,\"1525\":2}}],[\"passhandle\",{\"1\":{\"69\":3}}],[\"parnew+serial\",{\"1\":{\"638\":1}}],[\"parnew\",{\"1\":{\"638\":4}}],[\"park和unpark是locksupport类中的方法\",{\"1\":{\"549\":1}}],[\"park\",{\"0\":{\"549\":1},\"1\":{\"549\":3,\"554\":2,\"555\":3}}],[\"parammap\",{\"1\":{\"1232\":4}}],[\"param指定参数名称\",{\"1\":{\"1229\":1}}],[\"parameterizableviewcontroller\",{\"1\":{\"1436\":1}}],[\"parameternamediscoverer\",{\"1\":{\"1384\":1}}],[\"parameters\",{\"1\":{\"1366\":1}}],[\"parametervalue\",{\"1\":{\"733\":4}}],[\"parametertypes\",{\"1\":{\"733\":4}}],[\"param\",{\"0\":{\"1229\":1},\"1\":{\"483\":1,\"701\":20,\"723\":1,\"799\":2,\"972\":4,\"973\":3,\"999\":1,\"1129\":24,\"1142\":1,\"1304\":1,\"1306\":1,\"1366\":1}}],[\"parallel\",{\"1\":{\"446\":1,\"638\":7,\"639\":1}}],[\"parallel=true\",{\"1\":{\"446\":1}}],[\"parquet的性能也较之其它文件格式有所提升\",{\"1\":{\"429\":1}}],[\"parquet是一种支持嵌套结构的列式存储文件格式\",{\"1\":{\"429\":1}}],[\"parquet\",{\"0\":{\"429\":1}}],[\"parser\",{\"1\":{\"1368\":3}}],[\"parsedouble\",{\"1\":{\"986\":2}}],[\"parselong\",{\"1\":{\"972\":2,\"974\":1,\"986\":2}}],[\"parseint\",{\"1\":{\"723\":1}}],[\"parse\",{\"0\":{\"377\":1,\"378\":1},\"1\":{\"336\":3,\"377\":5,\"378\":4}}],[\"partial\",{\"1\":{\"628\":1}}],[\"partition=2\",{\"1\":{\"1050\":1}}],[\"partition=true\",{\"1\":{\"261\":1}}],[\"partitioncountfortopic\",{\"1\":{\"1035\":2}}],[\"partitioner\",{\"1\":{\"1035\":2}}],[\"partitioner<text\",{\"1\":{\"973\":1}}],[\"partitioner<k2\",{\"1\":{\"968\":1}}],[\"partitioned\",{\"0\":{\"259\":1},\"1\":{\"260\":1,\"261\":1,\"262\":1,\"280\":1,\"281\":1,\"285\":1,\"289\":1}}],[\"partition在每个新添加的分区上运行命令\",{\"1\":{\"281\":1}}],[\"partition\",{\"0\":{\"280\":1,\"289\":1},\"1\":{\"261\":9,\"262\":3,\"268\":1,\"276\":1,\"279\":5,\"280\":10,\"283\":2,\"286\":2,\"289\":5,\"297\":1,\"298\":1,\"357\":1,\"358\":2,\"360\":4,\"361\":3,\"363\":4,\"364\":2,\"365\":10,\"400\":3,\"402\":1,\"404\":1,\"458\":1,\"968\":1,\"1025\":4,\"1026\":5,\"1035\":1,\"1037\":2,\"1041\":1,\"1052\":1}}],[\"partitions可以不写\",{\"1\":{\"281\":1}}],[\"partitions\",{\"0\":{\"236\":1},\"1\":{\"280\":1,\"281\":3,\"1020\":1}}],[\"partition分区是hive的一种优化手段表\",{\"1\":{\"236\":1}}],[\"partition分区\",{\"0\":{\"968\":1},\"1\":{\"233\":1}}],[\"partcol2=val2\",{\"1\":{\"283\":2,\"286\":2}}],[\"partcol1=val1\",{\"1\":{\"283\":2,\"286\":2}}],[\"part080809\",{\"1\":{\"280\":1}}],[\"part080808\",{\"1\":{\"280\":1}}],[\"part时会发现有多了个role字段\",{\"1\":{\"260\":1}}],[\"part\",{\"1\":{\"260\":3,\"261\":1,\"281\":9,\"423\":5,\"458\":4}}],[\"parent\",{\"1\":{\"746\":1,\"1219\":1}}],[\"parent>\",{\"1\":{\"107\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"parent<\",{\"1\":{\"107\":2,\"1219\":1}}],[\"paper\",{\"1\":{\"124\":3}}],[\"pathresourceresolver\",{\"1\":{\"1432\":1}}],[\"pathvariable和\",{\"1\":{\"1525\":1}}],[\"pathvariable\",{\"1\":{\"1116\":1,\"1161\":1,\"1162\":1,\"1164\":3,\"1165\":1,\"1362\":1,\"1525\":3,\"1531\":2}}],[\"path=$path\",{\"1\":{\"1046\":1}}],[\"path=\",{\"1\":{\"1012\":1}}],[\"path<\",{\"1\":{\"872\":1,\"936\":1}}],[\"paths\",{\"1\":{\"821\":7,\"822\":12,\"823\":3,\"857\":1}}],[\"path>\",{\"1\":{\"102\":1,\"869\":1}}],[\"path\",{\"0\":{\"821\":1},\"1\":{\"92\":2,\"278\":1,\"280\":2,\"336\":2,\"377\":7,\"378\":8,\"821\":11,\"822\":29,\"823\":5,\"869\":1,\"872\":1,\"875\":6,\"936\":1,\"962\":4,\"972\":4,\"973\":4,\"974\":4,\"985\":1,\"986\":1,\"988\":4,\"991\":4,\"1411\":1}}],[\"patternlayout\",{\"1\":{\"1022\":1}}],[\"pattern\",{\"1\":{\"42\":2,\"64\":1,\"344\":2,\"1120\":3,\"1257\":1}}],[\"paa\",{\"1\":{\"81\":2}}],[\"ppd=\",{\"1\":{\"459\":1}}],[\"ppd\",{\"0\":{\"459\":1},\"1\":{\"459\":1}}],[\"pp\",{\"1\":{\"58\":2}}],[\"pull\",{\"1\":{\"949\":1}}],[\"publisher<r>\",{\"1\":{\"716\":1}}],[\"publisher\",{\"1\":{\"716\":1,\"717\":4,\"718\":4}}],[\"public\",{\"1\":{\"6\":15,\"7\":6,\"9\":2,\"14\":27,\"17\":24,\"22\":10,\"23\":9,\"28\":2,\"30\":2,\"34\":14,\"39\":7,\"42\":2,\"43\":2,\"47\":16,\"51\":4,\"52\":7,\"54\":15,\"58\":7,\"59\":23,\"60\":7,\"66\":15,\"68\":9,\"69\":5,\"70\":4,\"73\":6,\"74\":25,\"75\":10,\"76\":15,\"81\":27,\"85\":15,\"88\":4,\"92\":1,\"344\":3,\"373\":1,\"536\":5,\"541\":1,\"551\":1,\"554\":12,\"555\":12,\"562\":1,\"566\":1,\"567\":1,\"572\":1,\"574\":3,\"579\":3,\"585\":6,\"590\":2,\"591\":1,\"592\":1,\"614\":4,\"617\":2,\"645\":3,\"648\":4,\"649\":2,\"668\":7,\"671\":5,\"673\":3,\"692\":7,\"696\":3,\"697\":3,\"698\":3,\"699\":3,\"701\":3,\"702\":6,\"703\":2,\"704\":5,\"705\":3,\"707\":2,\"710\":2,\"711\":1,\"713\":1,\"714\":1,\"716\":11,\"717\":6,\"718\":11,\"723\":30,\"725\":4,\"726\":5,\"733\":14,\"734\":1,\"735\":2,\"736\":1,\"737\":4,\"738\":2,\"740\":9,\"741\":2,\"743\":6,\"744\":2,\"748\":4,\"749\":1,\"753\":1,\"754\":3,\"756\":2,\"757\":1,\"758\":2,\"766\":9,\"775\":1,\"776\":2,\"794\":2,\"795\":4,\"796\":2,\"799\":4,\"809\":1,\"820\":2,\"822\":6,\"834\":4,\"836\":2,\"839\":4,\"840\":1,\"843\":4,\"846\":8,\"848\":4,\"857\":4,\"859\":10,\"956\":2,\"958\":1,\"960\":1,\"962\":5,\"968\":4,\"972\":9,\"973\":7,\"974\":12,\"985\":10,\"986\":4,\"988\":7,\"990\":1,\"991\":2,\"999\":4,\"1023\":3,\"1024\":2,\"1025\":1,\"1035\":4,\"1071\":3,\"1073\":1,\"1088\":2,\"1089\":12,\"1099\":2,\"1100\":4,\"1101\":4,\"1107\":1,\"1111\":6,\"1116\":1,\"1122\":2,\"1128\":3,\"1129\":8,\"1132\":3,\"1133\":3,\"1134\":1,\"1137\":3,\"1142\":4,\"1144\":2,\"1147\":1,\"1150\":3,\"1152\":1,\"1156\":2,\"1157\":3,\"1159\":4,\"1160\":1,\"1161\":4,\"1162\":3,\"1164\":4,\"1165\":4,\"1167\":1,\"1168\":3,\"1172\":2,\"1175\":2,\"1176\":2,\"1215\":2,\"1222\":2,\"1230\":1,\"1232\":2,\"1234\":1,\"1236\":1,\"1244\":2,\"1257\":5,\"1285\":4,\"1294\":8,\"1304\":3,\"1306\":3,\"1309\":12,\"1317\":2,\"1413\":2,\"1416\":4,\"1420\":3,\"1424\":3,\"1429\":4,\"1432\":1,\"1435\":2,\"1441\":2,\"1449\":2,\"1451\":1,\"1464\":3,\"1466\":2,\"1505\":7,\"1515\":1,\"1525\":5,\"1526\":3,\"1531\":2}}],[\"push\",{\"1\":{\"669\":6}}],[\"pushdown\",{\"1\":{\"459\":1,\"495\":1}}],[\"purge\",{\"1\":{\"280\":1}}],[\"pudong\",{\"1\":{\"262\":1}}],[\"putmapping\",{\"1\":{\"1164\":1}}],[\"putall\",{\"1\":{\"1107\":1}}],[\"puttreeval\",{\"1\":{\"579\":1}}],[\"puttreeval会看key是否已经在树中\",{\"1\":{\"579\":1}}],[\"putifabsent\",{\"1\":{\"579\":1}}],[\"putval\",{\"1\":{\"579\":2}}],[\"put流程\",{\"1\":{\"579\":1}}],[\"put到了forwardingnode\",{\"1\":{\"579\":1}}],[\"putfield\",{\"1\":{\"567\":2}}],[\"putstatic\",{\"1\":{\"560\":1}}],[\"put命令\",{\"1\":{\"281\":1}}],[\"put\",{\"1\":{\"42\":1,\"279\":2,\"281\":2,\"477\":2,\"483\":2,\"579\":2,\"671\":3,\"723\":14,\"733\":3,\"737\":1,\"802\":2,\"808\":2,\"809\":3,\"815\":1,\"840\":2,\"973\":5,\"990\":1,\"1004\":1,\"1023\":4,\"1024\":6,\"1028\":1,\"1035\":1,\"1043\":1,\"1172\":1,\"1224\":2}}],[\"p\",{\"1\":{\"42\":4,\"126\":2,\"145\":3,\"281\":2,\"302\":4,\"303\":5,\"307\":3,\"310\":1,\"344\":2,\"562\":12,\"579\":7,\"740\":2,\"869\":1,\"872\":1,\"1199\":1,\"1304\":1,\"1306\":2,\"1317\":2}}],[\"prepared\",{\"1\":{\"1444\":1}}],[\"preparedstatement\",{\"1\":{\"985\":1}}],[\"prehandle\",{\"1\":{\"1100\":1,\"1111\":2,\"1438\":1,\"1532\":1}}],[\"prehandvalue\",{\"1\":{\"81\":4}}],[\"pretags\",{\"1\":{\"1083\":1}}],[\"prettyhexdump\",{\"1\":{\"776\":6,\"779\":3,\"780\":2}}],[\"preferred\",{\"1\":{\"1050\":1}}],[\"prefix=\",{\"1\":{\"876\":1,\"1142\":1,\"1441\":1}}],[\"prefixsum\",{\"1\":{\"673\":3}}],[\"prefix++\",{\"1\":{\"668\":1}}],[\"prefix\",{\"1\":{\"668\":3,\"799\":1,\"1088\":1,\"1142\":2,\"1144\":6,\"1147\":2,\"1441\":1,\"1525\":1}}],[\"prefix表示以该处节点之前的字符串为前缀的单词数量\",{\"1\":{\"668\":1}}],[\"premature\",{\"1\":{\"742\":1}}],[\"preorder\",{\"1\":{\"669\":4}}],[\"previsitdirectory\",{\"1\":{\"822\":2}}],[\"prevlen\",{\"1\":{\"665\":7,\"666\":8}}],[\"prevhand\",{\"1\":{\"81\":3}}],[\"predestory修饰的方法将在容器销毁前调用\",{\"1\":{\"1503\":1}}],[\"predestory用于声明bean的生命周期\",{\"1\":{\"1503\":1}}],[\"predestroy\",{\"1\":{\"1254\":1,\"1264\":1,\"1289\":1,\"1505\":1}}],[\"predicate<\",{\"1\":{\"614\":1}}],[\"pred\",{\"1\":{\"579\":2}}],[\"preceding\",{\"1\":{\"361\":4}}],[\"propagation\",{\"1\":{\"1514\":7}}],[\"props\",{\"1\":{\"1021\":2}}],[\"propertyvalues\",{\"1\":{\"1505\":2}}],[\"propertysource\",{\"1\":{\"1446\":1}}],[\"propertyeditorregistry\",{\"1\":{\"1369\":1,\"1370\":1}}],[\"propertyeditor\",{\"1\":{\"1369\":2,\"1370\":2}}],[\"property=\",{\"1\":{\"1230\":2}}],[\"property>\",{\"1\":{\"872\":2,\"879\":1,\"910\":2,\"919\":1,\"926\":1,\"927\":4,\"936\":6}}],[\"property\",{\"1\":{\"238\":1,\"251\":1,\"278\":1,\"279\":5,\"1370\":2,\"1525\":2}}],[\"properties=\",{\"1\":{\"1230\":6}}],[\"properties>\",{\"1\":{\"92\":1,\"99\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"properties\",{\"1\":{\"42\":4,\"279\":1,\"723\":8,\"733\":9,\"1012\":4,\"1018\":1,\"1022\":1,\"1023\":10,\"1024\":12,\"1028\":1,\"1035\":1,\"1043\":1,\"1045\":1,\"1046\":2,\"1244\":5,\"1441\":1,\"1444\":1}}],[\"producer开始写入数据\",{\"1\":{\"1051\":1}}],[\"producer是不断地往kafka中写入数据\",{\"1\":{\"1043\":1}}],[\"producerconfig\",{\"1\":{\"1035\":1}}],[\"producerrecord<string\",{\"1\":{\"1025\":1}}],[\"producerrecord<>\",{\"1\":{\"1023\":1,\"1025\":1}}],[\"producerrecord\",{\"1\":{\"1023\":1}}],[\"producer\",{\"1\":{\"1016\":1,\"1021\":4,\"1023\":2,\"1025\":2,\"1026\":1,\"1029\":1}}],[\"product相关的key\",{\"1\":{\"1207\":1}}],[\"products\",{\"1\":{\"1089\":2}}],[\"productpage\",{\"1\":{\"1089\":2}}],[\"productlist\",{\"1\":{\"1089\":2}}],[\"productdao\",{\"1\":{\"1089\":11}}],[\"product\",{\"1\":{\"13\":1,\"33\":1,\"38\":1,\"1089\":15,\"1207\":2}}],[\"profile\",{\"1\":{\"878\":1,\"1012\":2,\"1046\":2,\"1525\":1}}],[\"profile>\",{\"1\":{\"92\":1}}],[\"program\",{\"1\":{\"822\":2}}],[\"programming的通用api\",{\"1\":{\"716\":1}}],[\"promisetask$runnableadapter\",{\"1\":{\"765\":2}}],[\"promisetask\",{\"1\":{\"765\":7}}],[\"promise<v>\",{\"1\":{\"756\":1}}],[\"promise<object>\",{\"1\":{\"738\":1}}],[\"promise<object>>\",{\"1\":{\"738\":1}}],[\"promises\",{\"1\":{\"737\":1,\"738\":2}}],[\"promise\",{\"0\":{\"756\":1,\"759\":1},\"1\":{\"725\":1,\"735\":3,\"737\":10,\"738\":6,\"740\":25,\"743\":9,\"756\":3,\"759\":6,\"760\":4,\"761\":4,\"762\":4,\"763\":7,\"764\":6,\"765\":4,\"766\":8}}],[\"procotolframedecoder\",{\"1\":{\"702\":2,\"733\":2,\"735\":1,\"737\":1}}],[\"proc\",{\"1\":{\"680\":1,\"726\":2}}],[\"proceed\",{\"1\":{\"1340\":3,\"1346\":2}}],[\"proceedings\",{\"1\":{\"124\":2}}],[\"procedure\",{\"1\":{\"949\":1}}],[\"processselectedkeysplain\",{\"1\":{\"742\":1}}],[\"processselectedkeysoptimized\",{\"1\":{\"742\":1}}],[\"processselectedkeys\",{\"1\":{\"741\":2,\"742\":2}}],[\"processselectedkey\",{\"1\":{\"726\":1,\"742\":2}}],[\"processor1\",{\"1\":{\"1285\":2}}],[\"processors\",{\"1\":{\"1257\":3}}],[\"processor\",{\"1\":{\"718\":3,\"1257\":4}}],[\"processor<integer\",{\"1\":{\"718\":1}}],[\"processor<t\",{\"1\":{\"716\":1}}],[\"processing\",{\"1\":{\"221\":2}}],[\"process\",{\"1\":{\"70\":3,\"167\":1}}],[\"proactor模式是和异步io相关的\",{\"1\":{\"611\":1}}],[\"provider\",{\"1\":{\"936\":5}}],[\"provided\",{\"1\":{\"100\":2,\"104\":1}}],[\"province字段需要从前端传过来\",{\"1\":{\"1232\":1}}],[\"province格式回调\",{\"1\":{\"1232\":1}}],[\"province=bj\",{\"1\":{\"280\":1}}],[\"province=\",{\"1\":{\"280\":1}}],[\"province\",{\"1\":{\"262\":8,\"280\":10,\"374\":1,\"1232\":2}}],[\"proof\",{\"1\":{\"128\":1}}],[\"projectlombok<\",{\"1\":{\"1022\":1,\"1070\":1,\"1087\":1,\"1219\":2}}],[\"projects\",{\"1\":{\"821\":7,\"1217\":1}}],[\"project>\",{\"1\":{\"108\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"project2<\",{\"1\":{\"108\":1}}],[\"project1<\",{\"1\":{\"108\":1}}],[\"project<\",{\"1\":{\"108\":1}}],[\"project\",{\"1\":{\"98\":3,\"99\":2,\"107\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"480\":1,\"1219\":1,\"1521\":1}}],[\"probstrategy\",{\"1\":{\"81\":4}}],[\"proxy通过接口去创建代理对象\",{\"1\":{\"1500\":1}}],[\"proxytargetclass\",{\"1\":{\"1322\":1,\"1325\":2}}],[\"proxyfastclass\",{\"1\":{\"1320\":1,\"1321\":2}}],[\"proxyfactory不是代理模式中所说的代理类\",{\"1\":{\"59\":1}}],[\"proxyfactory是代理类吗\",{\"1\":{\"59\":1}}],[\"proxyfactory\",{\"1\":{\"59\":6,\"60\":3,\"1322\":2,\"1325\":1,\"1340\":1,\"1343\":1,\"1350\":1}}],[\"proxymode\",{\"1\":{\"1290\":1,\"1297\":1}}],[\"proxyuser\",{\"1\":{\"927\":4}}],[\"proxyobject\",{\"1\":{\"59\":6,\"60\":2}}],[\"proxy并不是我们上述所说的代理对象的类\",{\"1\":{\"59\":1}}],[\"proxypoint\",{\"1\":{\"58\":3}}],[\"proxy\",{\"0\":{\"927\":1,\"1303\":1},\"1\":{\"57\":2,\"59\":14,\"737\":2,\"1137\":2,\"1142\":2,\"1150\":2,\"1157\":2,\"1304\":7,\"1306\":4,\"1309\":5,\"1317\":7,\"1321\":2,\"1322\":1}}],[\"prototype\",{\"1\":{\"1252\":1,\"1290\":1,\"1294\":1,\"1297\":1,\"1504\":1}}],[\"prototypetest\",{\"1\":{\"51\":2}}],[\"protobuf\",{\"1\":{\"712\":1,\"1023\":1}}],[\"protocolversion\",{\"1\":{\"711\":1}}],[\"protocol\",{\"1\":{\"377\":1,\"378\":6,\"789\":1}}],[\"protect\",{\"1\":{\"63\":1}}],[\"protected\",{\"1\":{\"14\":2,\"51\":1,\"59\":2,\"373\":1,\"585\":5,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":3,\"703\":2,\"704\":5,\"710\":1,\"711\":2,\"713\":2,\"714\":2,\"723\":1,\"733\":2,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"740\":2,\"741\":2,\"743\":1,\"748\":3,\"753\":4,\"754\":1,\"766\":2,\"775\":2,\"784\":2,\"785\":1,\"794\":2,\"958\":1,\"960\":1,\"972\":2,\"973\":2,\"974\":3,\"983\":1,\"985\":1,\"986\":2,\"988\":5,\"990\":2}}],[\"priorityordered\",{\"1\":{\"1260\":1}}],[\"priorityblockingqueue\",{\"1\":{\"572\":1}}],[\"primary\",{\"1\":{\"1067\":1,\"1164\":1,\"1174\":1,\"1236\":1,\"1482\":1,\"1489\":1}}],[\"primitive\",{\"1\":{\"248\":1}}],[\"price\",{\"1\":{\"256\":3,\"1089\":1,\"1186\":2,\"1207\":1}}],[\"printer\",{\"1\":{\"1368\":3}}],[\"printf\",{\"1\":{\"663\":2,\"799\":2,\"859\":3}}],[\"print\",{\"1\":{\"47\":2,\"669\":1,\"1416\":1,\"1420\":1}}],[\"printstacktrace\",{\"1\":{\"42\":1,\"536\":1,\"551\":2,\"554\":2,\"555\":4,\"593\":4,\"702\":1,\"717\":1,\"718\":2,\"725\":1,\"726\":1,\"734\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":2,\"795\":4,\"796\":1,\"807\":1,\"808\":1,\"820\":2,\"823\":1,\"834\":2,\"836\":1,\"840\":1,\"846\":4,\"848\":2,\"857\":1,\"859\":6}}],[\"println\",{\"1\":{\"6\":7,\"7\":5,\"14\":2,\"17\":2,\"23\":3,\"34\":2,\"43\":1,\"47\":2,\"51\":3,\"52\":1,\"54\":3,\"58\":2,\"59\":3,\"60\":2,\"68\":2,\"70\":3,\"73\":2,\"74\":7,\"75\":5,\"76\":2,\"81\":6,\"85\":7,\"344\":1,\"536\":2,\"562\":10,\"565\":1,\"614\":2,\"616\":1,\"617\":3,\"618\":1,\"619\":2,\"620\":3,\"621\":9,\"645\":1,\"648\":2,\"668\":2,\"702\":12,\"710\":1,\"717\":2,\"718\":4,\"726\":4,\"737\":3,\"746\":4,\"748\":1,\"765\":4,\"768\":1,\"774\":5,\"776\":8,\"779\":3,\"780\":3,\"784\":1,\"794\":2,\"795\":2,\"799\":4,\"805\":2,\"809\":1,\"820\":2,\"821\":2,\"822\":6,\"823\":1,\"826\":1,\"834\":2,\"836\":1,\"839\":1,\"843\":4,\"848\":1,\"859\":1,\"974\":1,\"988\":1,\"991\":1,\"999\":3,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":3,\"1132\":2,\"1150\":1,\"1213\":3,\"1221\":1,\"1223\":2,\"1224\":1,\"1244\":3,\"1257\":5,\"1294\":2,\"1304\":3,\"1306\":3,\"1309\":4,\"1317\":2,\"1416\":1,\"1441\":1,\"1526\":1}}],[\"privatetmp=true\",{\"1\":{\"1197\":1}}],[\"private\",{\"1\":{\"7\":1,\"14\":4,\"17\":13,\"22\":6,\"34\":1,\"42\":1,\"47\":3,\"52\":1,\"54\":3,\"58\":1,\"59\":7,\"60\":1,\"66\":15,\"68\":6,\"69\":8,\"70\":2,\"73\":1,\"74\":6,\"76\":6,\"81\":17,\"373\":2,\"554\":2,\"579\":2,\"617\":1,\"671\":1,\"673\":5,\"696\":1,\"710\":2,\"717\":1,\"718\":3,\"723\":3,\"726\":1,\"733\":7,\"737\":3,\"740\":4,\"741\":1,\"742\":3,\"743\":1,\"766\":1,\"768\":1,\"799\":8,\"809\":1,\"840\":1,\"846\":7,\"859\":8,\"958\":2,\"960\":1,\"972\":3,\"973\":1,\"974\":3,\"985\":7,\"986\":1,\"988\":5,\"990\":1,\"999\":15,\"1023\":1,\"1024\":1,\"1035\":1,\"1071\":4,\"1073\":3,\"1088\":2,\"1089\":7,\"1100\":1,\"1101\":1,\"1111\":1,\"1124\":1,\"1127\":3,\"1128\":4,\"1129\":4,\"1132\":3,\"1142\":1,\"1144\":1,\"1147\":1,\"1150\":2,\"1152\":1,\"1156\":1,\"1157\":5,\"1159\":1,\"1160\":1,\"1161\":2,\"1162\":1,\"1168\":3,\"1213\":1,\"1215\":1,\"1221\":1,\"1223\":2,\"1224\":1,\"1230\":3,\"1257\":1,\"1285\":1,\"1294\":3,\"1309\":1,\"1480\":1,\"1525\":6}}],[\"wuhan2020\",{\"1\":{\"1525\":3}}],[\"wget\",{\"1\":{\"1046\":1}}],[\"wrapifnecessary\",{\"1\":{\"1333\":1}}],[\"wrapper\",{\"1\":{\"1164\":3,\"1165\":3,\"1234\":3,\"1235\":2}}],[\"wrappedbuffer\",{\"1\":{\"780\":3}}],[\"writablecomparator\",{\"1\":{\"974\":1}}],[\"writablecomparable<covidtop1bean>\",{\"1\":{\"974\":1}}],[\"writablecomparable<t>\",{\"1\":{\"956\":1}}],[\"writablecomparable\",{\"1\":{\"974\":2}}],[\"writablecomparable接口可用于用户自定义对象的比较规则\",{\"1\":{\"956\":1}}],[\"writable\",{\"1\":{\"956\":1,\"972\":1,\"985\":1}}],[\"writable序列化机制\",{\"0\":{\"956\":1}}],[\"writevalueasstring\",{\"1\":{\"1073\":4,\"1223\":1}}],[\"writedbdriver\",{\"1\":{\"986\":4}}],[\"writedbreducer\",{\"1\":{\"986\":3}}],[\"writedbmapper\",{\"1\":{\"986\":3}}],[\"writedouble\",{\"1\":{\"772\":1,\"985\":2}}],[\"write进行collect数据收集\",{\"1\":{\"979\":1}}],[\"writeutf\",{\"1\":{\"974\":2,\"985\":2}}],[\"write叫做序列化方法\",{\"1\":{\"956\":1}}],[\"writehandler\",{\"1\":{\"859\":4}}],[\"writeclient\",{\"1\":{\"843\":1}}],[\"writecharsequence\",{\"1\":{\"772\":1}}],[\"writechar\",{\"1\":{\"772\":1}}],[\"writefloat\",{\"1\":{\"772\":1}}],[\"writelong\",{\"1\":{\"772\":1,\"972\":2,\"974\":1,\"985\":2}}],[\"writelock\",{\"1\":{\"590\":2}}],[\"writeserver\",{\"1\":{\"843\":1}}],[\"writes集中写\",{\"0\":{\"808\":1}}],[\"writeshort\",{\"1\":{\"772\":1}}],[\"writesd\",{\"1\":{\"6\":3,\"7\":1}}],[\"writeboolean\",{\"1\":{\"772\":1}}],[\"writebyte\",{\"1\":{\"698\":2,\"699\":2,\"713\":4,\"714\":4,\"723\":4,\"772\":1,\"776\":1}}],[\"writebytes\",{\"1\":{\"692\":1,\"693\":1,\"696\":1,\"697\":1,\"710\":24,\"711\":1,\"713\":2,\"714\":2,\"723\":2,\"748\":2,\"766\":3,\"772\":4,\"776\":2,\"779\":4,\"780\":2,\"794\":1,\"803\":1}}],[\"writeinbound\",{\"1\":{\"713\":2}}],[\"writeintle\",{\"1\":{\"772\":1}}],[\"writeint\",{\"1\":{\"713\":2,\"714\":2,\"723\":2,\"772\":2,\"773\":1}}],[\"writeoutbound\",{\"1\":{\"713\":1}}],[\"writeobject2file\",{\"1\":{\"68\":2}}],[\"writeobject\",{\"1\":{\"54\":1,\"68\":1,\"713\":1,\"714\":1,\"723\":2}}],[\"writerindex\",{\"1\":{\"768\":1}}],[\"writer\",{\"1\":{\"707\":2,\"795\":8}}],[\"writeandflush\",{\"1\":{\"692\":1,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":8,\"703\":3,\"704\":9,\"707\":1,\"710\":2,\"711\":1,\"734\":1,\"735\":1,\"737\":1,\"748\":2,\"752\":1,\"753\":3,\"754\":1,\"766\":4,\"785\":1,\"794\":2}}],[\"write系统调用\",{\"1\":{\"210\":1}}],[\"writetf\",{\"1\":{\"6\":3,\"7\":1}}],[\"write\",{\"0\":{\"842\":1,\"844\":1},\"1\":{\"6\":3,\"7\":1,\"210\":1,\"293\":1,\"373\":1,\"506\":1,\"590\":1,\"697\":1,\"698\":1,\"699\":1,\"726\":1,\"742\":1,\"752\":1,\"766\":16,\"768\":2,\"772\":2,\"773\":1,\"774\":3,\"776\":3,\"779\":2,\"795\":2,\"803\":2,\"808\":1,\"815\":3,\"831\":1,\"833\":1,\"834\":1,\"839\":3,\"840\":3,\"843\":12,\"854\":2,\"859\":3,\"958\":1,\"960\":1,\"972\":3,\"973\":2,\"974\":3,\"983\":1,\"985\":3,\"986\":3,\"988\":4,\"990\":1,\"1120\":2}}],[\"w\",{\"1\":{\"340\":1,\"648\":8,\"649\":5,\"809\":2,\"918\":1,\"920\":1}}],[\"welcomepagehandlermapping\",{\"1\":{\"1435\":3,\"1436\":1,\"1437\":1}}],[\"weekofyear\",{\"1\":{\"337\":3}}],[\"web应用服务器接受到这个请求\",{\"1\":{\"1530\":1}}],[\"webmvc\",{\"1\":{\"1499\":1}}],[\"webmvcautoconfiguration\",{\"0\":{\"1459\":1}}],[\"webmvcconfigurer\",{\"1\":{\"1100\":1}}],[\"webapplicationcontext\",{\"1\":{\"1451\":1}}],[\"webapp\",{\"1\":{\"1441\":2}}],[\"websocket\",{\"1\":{\"1499\":3}}],[\"webserverfactory\",{\"1\":{\"1413\":2}}],[\"website\",{\"1\":{\"336\":3,\"359\":6,\"360\":4,\"361\":2,\"363\":2,\"364\":2,\"365\":4}}],[\"webdatabinderfactory\",{\"1\":{\"1384\":1}}],[\"web<\",{\"1\":{\"1022\":1}}],[\"web\",{\"0\":{\"895\":1,\"1351\":1},\"1\":{\"1046\":5,\"1245\":3,\"1290\":1,\"1355\":1,\"1428\":1,\"1441\":1,\"1447\":2,\"1461\":1,\"1462\":1,\"1499\":4}}],[\"web主页上会显示安全模式是打开还是关闭\",{\"1\":{\"870\":1}}],[\"webflux\",{\"0\":{\"720\":1},\"1\":{\"1499\":4}}],[\"webgui是通过浏览器访问hive\",{\"1\":{\"232\":1}}],[\"webgui\",{\"1\":{\"232\":1}}],[\"web工程打包方式为jar\",{\"1\":{\"114\":1,\"115\":1}}],[\"ws\",{\"1\":{\"336\":3,\"383\":1,\"385\":1}}],[\"w3\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"www\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"117\":2,\"118\":1,\"119\":1,\"120\":1,\"125\":2,\"127\":1,\"131\":1,\"144\":1,\"336\":3,\"1089\":2,\"1146\":1,\"1219\":1}}],[\"wantedby=multi\",{\"1\":{\"1197\":1}}],[\"wangwu\",{\"1\":{\"737\":1,\"748\":8,\"1073\":1,\"1082\":1,\"1083\":1,\"1210\":5}}],[\"walk\",{\"1\":{\"823\":1}}],[\"walkfiletree\",{\"1\":{\"822\":3}}],[\"wakenup\",{\"1\":{\"741\":5,\"742\":3}}],[\"wakeup\",{\"1\":{\"741\":9,\"742\":4,\"833\":1,\"846\":1}}],[\"wakesupfortask\",{\"1\":{\"741\":1}}],[\"was\",{\"1\":{\"740\":1,\"743\":1}}],[\"wasactive\",{\"1\":{\"740\":2}}],[\"waittime\",{\"1\":{\"1152\":2}}],[\"waitforcompletion\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"992\":1}}],[\"wait时\",{\"1\":{\"680\":2}}],[\"wait检测到描述符事件发生并将此事件通知应用程序\",{\"1\":{\"680\":2}}],[\"wait便可以收到通知\",{\"1\":{\"680\":1}}],[\"waitstatus\",{\"1\":{\"585\":1}}],[\"wait会释放锁对象\",{\"1\":{\"546\":1}}],[\"wait是object方法\",{\"1\":{\"546\":1}}],[\"wait\",{\"0\":{\"545\":1},\"1\":{\"171\":2,\"513\":1,\"534\":1,\"549\":1,\"554\":2,\"555\":3,\"680\":1,\"702\":3,\"741\":1,\"1220\":1}}],[\"waiting\",{\"1\":{\"160\":1,\"533\":1,\"538\":2,\"546\":1,\"754\":1,\"826\":1,\"848\":2}}],[\"watchdog\",{\"0\":{\"1152\":1}}],[\"watch\",{\"1\":{\"144\":1}}],[\"waterproof\",{\"1\":{\"75\":5}}],[\"war项目\",{\"0\":{\"1441\":1}}],[\"warn\",{\"1\":{\"741\":1}}],[\"warrior\",{\"1\":{\"261\":1}}],[\"warehouse\",{\"0\":{\"226\":1},\"1\":{\"219\":1,\"223\":1,\"234\":3,\"235\":2,\"236\":1,\"237\":2,\"254\":2,\"266\":1,\"280\":1,\"281\":5,\"285\":1}}],[\"war\",{\"1\":{\"112\":1,\"1441\":1}}],[\"war包版本插件不匹配\",{\"1\":{\"112\":1}}],[\"war<\",{\"1\":{\"98\":1}}],[\"war指的是web项目打包方式\",{\"1\":{\"98\":1}}],[\"whitelabelerrorview\",{\"1\":{\"1411\":1}}],[\"which\",{\"1\":{\"799\":2}}],[\"while中的var1+var2\",{\"1\":{\"1135\":1}}],[\"while\",{\"1\":{\"43\":1,\"536\":1,\"554\":2,\"555\":4,\"564\":1,\"579\":1,\"645\":3,\"669\":1,\"671\":2,\"673\":2,\"702\":1,\"743\":2,\"744\":1,\"754\":1,\"794\":1,\"795\":2,\"796\":2,\"815\":2,\"826\":1,\"827\":1,\"834\":2,\"836\":2,\"839\":2,\"840\":2,\"843\":4,\"846\":4,\"990\":1,\"991\":1,\"999\":1,\"1024\":1,\"1135\":2,\"1152\":1,\"1157\":1,\"1176\":1}}],[\"when语句\",{\"1\":{\"380\":1}}],[\"when条件转换函数\",{\"1\":{\"351\":1}}],[\"when\",{\"1\":{\"340\":7,\"351\":3,\"380\":2,\"382\":3,\"579\":1}}],[\"where中不能使用聚合函数\",{\"1\":{\"504\":1}}],[\"where是在结果返回之前起作用的\",{\"1\":{\"504\":1}}],[\"where是在分组前对数据进行过滤\",{\"1\":{\"308\":1}}],[\"where是一个约束声明\",{\"1\":{\"504\":1}}],[\"where和having的区别\",{\"0\":{\"504\":1}}],[\"where语句中不能使用聚合函数\",{\"1\":{\"307\":1}}],[\"where后面不可以使用聚合函数\",{\"1\":{\"308\":1}}],[\"where后面可以跟着hive支持的任何表达式和运算符\",{\"1\":{\"304\":1}}],[\"where后面是一个布尔表达式\",{\"1\":{\"304\":1}}],[\"where\",{\"0\":{\"304\":1,\"317\":1},\"1\":{\"260\":1,\"272\":1,\"298\":2,\"300\":2,\"307\":3,\"310\":2,\"317\":3,\"318\":8,\"320\":1,\"325\":2,\"330\":10,\"332\":8,\"351\":1,\"363\":2,\"364\":1,\"400\":2,\"404\":1,\"437\":2,\"455\":1,\"460\":2,\"481\":5,\"482\":1,\"493\":8,\"495\":1,\"496\":3,\"1107\":1,\"1136\":2,\"1137\":2,\"1157\":1,\"1162\":1,\"1167\":1,\"1230\":11}}],[\"what\",{\"1\":{\"91\":1}}],[\"woman\",{\"1\":{\"1208\":3}}],[\"world\",{\"0\":{\"782\":1},\"1\":{\"711\":1,\"753\":3,\"766\":1,\"783\":1,\"785\":1,\"809\":3,\"834\":1,\"839\":1,\"1055\":1}}],[\"work\",{\"1\":{\"999\":2}}],[\"workid值必须大于0并且小于\",{\"1\":{\"999\":1}}],[\"workid位需要左移的位数\",{\"1\":{\"999\":1}}],[\"workid\",{\"1\":{\"999\":1}}],[\"workid占用5个比特位\",{\"1\":{\"999\":1}}],[\"workid占用的位数\",{\"1\":{\"999\":1}}],[\"workqueue\",{\"1\":{\"572\":2}}],[\"works\",{\"1\":{\"374\":1}}],[\"workerid\",{\"1\":{\"998\":1,\"999\":7}}],[\"workers\",{\"1\":{\"846\":4,\"878\":1}}],[\"workereventloops\",{\"1\":{\"846\":4}}],[\"workereventloop\",{\"1\":{\"846\":7}}],[\"worker\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"692\":6,\"696\":3,\"697\":3,\"698\":3,\"699\":3,\"702\":3,\"710\":3,\"711\":3,\"733\":3,\"743\":3,\"748\":5,\"846\":9,\"999\":7}}],[\"words\",{\"1\":{\"958\":2,\"983\":2}}],[\"wordcountreducer\",{\"1\":{\"960\":2,\"962\":2}}],[\"wordcountmapper\",{\"1\":{\"958\":2,\"962\":2}}],[\"wordcountdriver\",{\"1\":{\"957\":1,\"962\":9}}],[\"wordcount\",{\"0\":{\"957\":1},\"1\":{\"957\":1,\"962\":1,\"991\":4}}],[\"word中就被设置成指向monitor对象的指针\",{\"1\":{\"541\":1}}],[\"word的形式\",{\"1\":{\"540\":1}}],[\"word\",{\"1\":{\"6\":2,\"540\":2,\"631\":2,\"958\":2,\"983\":3}}],[\"won\",{\"1\":{\"81\":3}}],[\"will\",{\"1\":{\"92\":1}}],[\"window\",{\"1\":{\"356\":1,\"361\":1}}],[\"windows\",{\"0\":{\"217\":1},\"1\":{\"856\":1,\"1200\":1}}],[\"winner\",{\"1\":{\"81\":3}}],[\"winningstrategy\",{\"1\":{\"81\":4}}],[\"wincount++\",{\"1\":{\"81\":1}}],[\"wincount\",{\"1\":{\"81\":2}}],[\"win\",{\"1\":{\"81\":12,\"256\":2}}],[\"withdistance\",{\"1\":{\"1172\":1}}],[\"with\",{\"1\":{\"70\":3,\"128\":1,\"130\":1,\"251\":1,\"276\":1,\"278\":1,\"279\":1,\"290\":1,\"300\":1,\"318\":7,\"354\":1,\"355\":2,\"374\":2,\"400\":2,\"404\":1,\"423\":1}}],[\"a49\",{\"1\":{\"1496\":1}}],[\"a48\",{\"1\":{\"1492\":1}}],[\"a47\",{\"1\":{\"1488\":1}}],[\"a46\",{\"1\":{\"1484\":1}}],[\"a45\",{\"1\":{\"1479\":1}}],[\"a44\",{\"1\":{\"1475\":1}}],[\"a43\",{\"1\":{\"1471\":1}}],[\"a39\",{\"1\":{\"1445\":6}}],[\"a35\",{\"1\":{\"1428\":1}}],[\"a31\",{\"1\":{\"1409\":1}}],[\"a30\",{\"1\":{\"1405\":2}}],[\"ajc\",{\"0\":{\"1299\":1},\"1\":{\"1298\":1,\"1300\":1}}],[\"aware\",{\"0\":{\"1281\":1,\"1282\":1},\"1\":{\"1252\":1,\"1284\":1,\"1472\":1}}],[\"await\",{\"1\":{\"554\":2,\"555\":3,\"593\":4,\"702\":1,\"737\":1,\"756\":1,\"763\":2,\"765\":5,\"1132\":3}}],[\"aop只能对ioc容器中的bean进行增强\",{\"1\":{\"1511\":1}}],[\"aop不能对哪些类进行增强\",{\"0\":{\"1511\":1}}],[\"aop为ioc的使用提供了更多的便利\",{\"1\":{\"1510\":1}}],[\"aop基于代理\",{\"1\":{\"1509\":1}}],[\"aop输入运行时增强\",{\"1\":{\"1509\":1}}],[\"aop的区别\",{\"0\":{\"1509\":1}}],[\"aop和aspectj\",{\"0\":{\"1509\":1}}],[\"aop和cglib实现aop是有所不同的\",{\"1\":{\"1508\":1}}],[\"aop会使用cglib生成一个被代理对象的子类来作为代理\",{\"1\":{\"1500\":1}}],[\"aop会使用jdk\",{\"1\":{\"1500\":1}}],[\"aop是基于动态代理的\",{\"1\":{\"1500\":1}}],[\"aop是面向切面编程的意思\",{\"1\":{\"1500\":1}}],[\"aopautoconfiguration\",{\"0\":{\"1453\":1},\"1\":{\"1453\":1}}],[\"aopproxy\",{\"1\":{\"1322\":2}}],[\"aopproxyfactory\",{\"1\":{\"1322\":1}}],[\"aop\",{\"0\":{\"1298\":1,\"1299\":1,\"1301\":1,\"1303\":1},\"1\":{\"1243\":1,\"1298\":2,\"1332\":1,\"1335\":1,\"1338\":1,\"1342\":1,\"1345\":1,\"1349\":1,\"1453\":6,\"1499\":1}}],[\"aopcontext\",{\"1\":{\"1137\":1,\"1142\":1,\"1150\":1,\"1157\":1}}],[\"aop<\",{\"1\":{\"107\":2}}],[\"a就是datanode\",{\"1\":{\"872\":1}}],[\"a5\",{\"1\":{\"805\":2}}],[\"a08\",{\"1\":{\"1292\":1,\"1296\":1}}],[\"a07\",{\"1\":{\"1288\":1}}],[\"a06\",{\"1\":{\"1283\":1}}],[\"a05\",{\"1\":{\"1270\":1,\"1273\":1,\"1276\":1,\"1279\":1}}],[\"a04\",{\"1\":{\"1263\":1,\"1266\":1}}],[\"a03\",{\"1\":{\"1254\":1,\"1259\":1}}],[\"a02\",{\"1\":{\"1247\":1,\"1250\":2}}],[\"a01\",{\"1\":{\"1242\":1}}],[\"a0\",{\"1\":{\"805\":2}}],[\"a为快表的命中率\",{\"1\":{\"683\":1}}],[\"a+b\",{\"1\":{\"637\":1}}],[\"aaaaaaaaa\",{\"1\":{\"699\":1}}],[\"aaa\",{\"0\":{\"916\":1},\"1\":{\"617\":1,\"710\":2,\"916\":1,\"1449\":1}}],[\"aqs这个抽象类把模板方法运用地炉火纯青\",{\"1\":{\"585\":1}}],[\"aqs中还有一个非常重要的内部类conditionobject\",{\"1\":{\"584\":1}}],[\"aqs中维护了一个队列\",{\"1\":{\"583\":1}}],[\"aqs中定义了一个状态变量state\",{\"1\":{\"582\":1}}],[\"aqs队列\",{\"0\":{\"583\":1}}],[\"aqs的全称是abstractqueuedsynchronizer\",{\"1\":{\"581\":1}}],[\"aqs是什么\",{\"0\":{\"581\":1}}],[\"aqs\",{\"0\":{\"580\":1}}],[\"ahead\",{\"1\":{\"506\":1}}],[\"a>\",{\"1\":{\"481\":1}}],[\"a>10\",{\"1\":{\"481\":1}}],[\"a索引即可\",{\"1\":{\"481\":1}}],[\"a列的几乎接近于唯一值\",{\"1\":{\"481\":1}}],[\"a=\",{\"1\":{\"481\":2}}],[\"a=b返回null\",{\"1\":{\"340\":1}}],[\"auth\",{\"1\":{\"1213\":1}}],[\"authentication\",{\"1\":{\"916\":1,\"923\":1,\"936\":1}}],[\"author\",{\"1\":{\"648\":2,\"962\":2,\"972\":1,\"973\":1,\"974\":1}}],[\"authorization\",{\"1\":{\"441\":1,\"916\":1,\"1111\":1}}],[\"autoconfigurationpackage\",{\"1\":{\"1525\":1}}],[\"autoconfigurationpackages\",{\"1\":{\"1455\":1}}],[\"autoconfigurationimportselector\",{\"1\":{\"1525\":2}}],[\"autoconfiguration2\",{\"1\":{\"1464\":3}}],[\"autoconfiguration1\",{\"1\":{\"1464\":3,\"1466\":1}}],[\"autoconfigure\",{\"1\":{\"1428\":1,\"1453\":1,\"1454\":1,\"1455\":1,\"1456\":2}}],[\"auto=false\",{\"1\":{\"1453\":1}}],[\"autoproxy\",{\"1\":{\"1332\":1,\"1335\":1,\"1338\":1,\"1349\":1}}],[\"autowired或者相关注解对对象进行依赖注入\",{\"1\":{\"1505\":1}}],[\"autowired一起使用\",{\"1\":{\"1503\":1}}],[\"autowired用于按类型注入\",{\"1\":{\"1503\":1}}],[\"autowiredannotationbeanpostprocessor\",{\"1\":{\"1264\":1,\"1267\":1}}],[\"autowired\",{\"0\":{\"1265\":1,\"1285\":1,\"1486\":1,\"1487\":1},\"1\":{\"1023\":1,\"1024\":1,\"1089\":2,\"1221\":1,\"1223\":1,\"1224\":1,\"1248\":2,\"1252\":1,\"1254\":1,\"1257\":2,\"1264\":2,\"1267\":1,\"1285\":2,\"1294\":3,\"1489\":1,\"1502\":1,\"1503\":1,\"1505\":1,\"1525\":1}}],[\"autogen\",{\"1\":{\"876\":1}}],[\"auto\",{\"1\":{\"444\":3,\"448\":2,\"450\":2,\"510\":1,\"742\":2,\"1024\":2,\"1164\":1,\"1174\":1}}],[\"autauga\",{\"1\":{\"265\":1}}],[\"a对应ascii\",{\"1\":{\"336\":1}}],[\"a和b按位进行异或操作的结果\",{\"1\":{\"331\":1}}],[\"a和b按位进行或操作的结果\",{\"1\":{\"331\":1}}],[\"a和b按位进行与操作的结果\",{\"1\":{\"331\":1}}],[\"a除以b所得的余数部分\",{\"1\":{\"331\":1}}],[\"avro\",{\"1\":{\"1023\":1}}],[\"avoid\",{\"1\":{\"740\":1}}],[\"avgsize=16000000\",{\"1\":{\"435\":1}}],[\"avg这样的聚合函数在窗口中的使用\",{\"1\":{\"360\":1}}],[\"avg等\",{\"1\":{\"358\":1}}],[\"avg\",{\"1\":{\"351\":2,\"1021\":1}}],[\"availableprocessors\",{\"1\":{\"846\":1,\"847\":1}}],[\"available\",{\"1\":{\"290\":1}}],[\"av24011528\",{\"1\":{\"120\":1,\"127\":1}}],[\"afterreturningadviceinterceptor\",{\"1\":{\"1343\":1}}],[\"afterreturningadviceadapter\",{\"1\":{\"1343\":1}}],[\"afterreturning\",{\"1\":{\"1343\":1}}],[\"aftereach\",{\"1\":{\"1213\":1,\"1216\":1}}],[\"after=network\",{\"1\":{\"1197\":1}}],[\"aftercompletion\",{\"1\":{\"1111\":1,\"1438\":1,\"1532\":1}}],[\"after\",{\"1\":{\"279\":2,\"826\":1,\"827\":1,\"1304\":2,\"1306\":1,\"1309\":1,\"1317\":1}}],[\"affinelayer\",{\"1\":{\"131\":1}}],[\"a29\",{\"1\":{\"1401\":1}}],[\"a28\",{\"1\":{\"1397\":2}}],[\"a27\",{\"1\":{\"1393\":1}}],[\"a26\",{\"1\":{\"1389\":1}}],[\"a23\",{\"1\":{\"1372\":1,\"1375\":1,\"1378\":1}}],[\"a22\",{\"1\":{\"1365\":2}}],[\"a21\",{\"1\":{\"1361\":1}}],[\"a20\",{\"1\":{\"1354\":1,\"1357\":2}}],[\"a2\",{\"1\":{\"279\":4}}],[\"a19\",{\"1\":{\"1349\":1}}],[\"a18\",{\"1\":{\"1342\":1,\"1345\":1}}],[\"a17\",{\"1\":{\"1333\":1,\"1335\":1,\"1338\":1}}],[\"a16\",{\"1\":{\"1328\":2}}],[\"a15\",{\"1\":{\"1324\":2}}],[\"a14application\",{\"1\":{\"1317\":1}}],[\"a13\",{\"1\":{\"1316\":1,\"1320\":2}}],[\"a12\",{\"1\":{\"1309\":2,\"1312\":1}}],[\"a1\",{\"1\":{\"279\":8}}],[\"against\",{\"1\":{\"740\":1}}],[\"aggressivelazyloading=false\",{\"1\":{\"1230\":1}}],[\"aggregationbuilders\",{\"1\":{\"1084\":1,\"1085\":1}}],[\"aggregationbuilder\",{\"1\":{\"1084\":3,\"1085\":3}}],[\"aggregation\",{\"1\":{\"334\":1,\"1084\":1,\"1085\":1}}],[\"aggr=true\",{\"1\":{\"464\":1}}],[\"agg\",{\"1\":{\"276\":4}}],[\"agegroup\",{\"1\":{\"1085\":1}}],[\"age作为表的字段内容插入表中\",{\"1\":{\"289\":1}}],[\"age\",{\"1\":{\"262\":1,\"268\":1,\"280\":1,\"287\":1,\"289\":1,\"290\":1,\"298\":3,\"313\":1,\"318\":3,\"339\":4,\"340\":1,\"347\":1,\"351\":9,\"1073\":2,\"1076\":1,\"1078\":1,\"1080\":1,\"1081\":1,\"1084\":1,\"1085\":1,\"1205\":13,\"1206\":10,\"1207\":1,\"1208\":11,\"1213\":1,\"1224\":1,\"1234\":3,\"1235\":3}}],[\"agent\",{\"0\":{\"1301\":1},\"1\":{\"76\":2,\"1298\":1,\"1302\":1}}],[\"atbeanpostprocessor\",{\"1\":{\"1276\":1}}],[\"attr\",{\"1\":{\"740\":1,\"743\":1}}],[\"attrs0\",{\"1\":{\"740\":1}}],[\"attrs\",{\"1\":{\"740\":3,\"822\":8}}],[\"attributekey<object>\",{\"1\":{\"740\":2,\"743\":1}}],[\"attribute\",{\"1\":{\"663\":6}}],[\"attach\",{\"1\":{\"840\":1,\"843\":2}}],[\"attachment\",{\"1\":{\"740\":2,\"840\":2,\"843\":1,\"857\":2,\"859\":13}}],[\"attack\",{\"1\":{\"260\":2,\"261\":2,\"281\":2}}],[\"at\",{\"1\":{\"579\":1,\"762\":8,\"765\":20,\"775\":1,\"1053\":2,\"1054\":1}}],[\"atomicmarkablereference\",{\"1\":{\"562\":1}}],[\"atomicstampedreference\",{\"1\":{\"562\":1}}],[\"atomicreferencefieldupdater\",{\"1\":{\"562\":1}}],[\"atomicreferencearray\",{\"1\":{\"562\":1}}],[\"atomicreference\",{\"1\":{\"562\":1}}],[\"atomicboolean\",{\"1\":{\"562\":1,\"702\":2}}],[\"atomiclongfieldupdater\",{\"1\":{\"562\":1}}],[\"atomiclongarray\",{\"1\":{\"562\":1}}],[\"atomiclong\",{\"1\":{\"562\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"562\":1}}],[\"atomicintegerarray\",{\"1\":{\"562\":1}}],[\"atomicinteger\",{\"1\":{\"562\":3,\"822\":6,\"846\":2}}],[\"atomic\",{\"1\":{\"562\":1,\"822\":2}}],[\"atomic原子类\",{\"0\":{\"562\":1}}],[\"atguigu<\",{\"1\":{\"112\":1,\"113\":1,\"114\":2,\"115\":2}}],[\"atguigu\",{\"1\":{\"105\":1,\"107\":3}}],[\"alaska\",{\"1\":{\"973\":1}}],[\"alabama\",{\"1\":{\"265\":5,\"973\":1}}],[\"algorithm=json\",{\"1\":{\"723\":1,\"733\":1}}],[\"algorithm\",{\"1\":{\"723\":9}}],[\"aload\",{\"1\":{\"567\":2}}],[\"alert\",{\"1\":{\"495\":1}}],[\"alter\",{\"1\":{\"271\":2,\"276\":3,\"278\":3,\"279\":14,\"280\":7,\"423\":1}}],[\"allfinished\",{\"1\":{\"991\":1}}],[\"allowsnapshot\",{\"1\":{\"914\":1}}],[\"allocation\",{\"0\":{\"1068\":1}}],[\"allocatedirect\",{\"1\":{\"801\":1,\"855\":1}}],[\"allocate\",{\"1\":{\"744\":1,\"796\":1,\"801\":2,\"807\":3,\"808\":2,\"809\":2,\"826\":1,\"827\":1,\"836\":1,\"840\":3,\"843\":1,\"846\":1,\"848\":1,\"855\":1,\"857\":1,\"859\":2}}],[\"allocator\",{\"0\":{\"730\":1,\"731\":1},\"1\":{\"731\":1,\"744\":4,\"770\":1}}],[\"allochandle\",{\"1\":{\"743\":5,\"744\":10}}],[\"alloc\",{\"1\":{\"663\":9,\"692\":1,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"710\":2,\"714\":1,\"723\":1,\"730\":1,\"766\":3,\"794\":2}}],[\"all<\",{\"1\":{\"783\":1,\"1022\":1}}],[\"allargsconstructor\",{\"1\":{\"766\":1,\"1089\":1,\"1525\":1}}],[\"allsalary\",{\"1\":{\"620\":2}}],[\"allmatch\",{\"1\":{\"619\":1}}],[\"allkeys\",{\"1\":{\"522\":3}}],[\"all合并修改后的数据即可\",{\"1\":{\"409\":1}}],[\"all操作合并即可\",{\"1\":{\"409\":1}}],[\"all的子查询的示例\",{\"1\":{\"316\":1}}],[\"all\",{\"0\":{\"303\":1},\"1\":{\"260\":4,\"261\":10,\"281\":9,\"300\":1,\"303\":1,\"315\":2,\"318\":1,\"352\":1,\"353\":3,\"354\":3,\"386\":1,\"388\":2,\"409\":1,\"799\":1,\"1023\":1,\"1043\":3,\"1089\":2}}],[\"allenwoon\",{\"1\":{\"336\":1}}],[\"allen\",{\"1\":{\"248\":1,\"278\":1,\"340\":3,\"343\":6}}],[\"alibaba\",{\"1\":{\"1466\":1}}],[\"alibaba<\",{\"1\":{\"101\":1,\"104\":1,\"1466\":1}}],[\"ali\",{\"1\":{\"791\":1}}],[\"alipay\",{\"1\":{\"480\":1}}],[\"alias=cluster1\",{\"1\":{\"1046\":1}}],[\"alias\",{\"1\":{\"276\":1,\"936\":1}}],[\"aliyunadmin\",{\"1\":{\"480\":1}}],[\"aliyun\",{\"1\":{\"92\":1,\"480\":1,\"878\":1}}],[\"aspects\",{\"1\":{\"1499\":1}}],[\"aspect\",{\"0\":{\"1330\":1},\"1\":{\"1333\":2,\"1339\":1}}],[\"aspectj相当于在被增强方法的class文件的对应位置调用增强方法实现aop\",{\"1\":{\"1508\":1}}],[\"aspectj是在字节码的层面上实现的\",{\"1\":{\"1508\":1}}],[\"aspectj与spring\",{\"1\":{\"1508\":1}}],[\"aspectjafteradvice\",{\"1\":{\"1339\":1}}],[\"aspectjafterthrowingadvice\",{\"1\":{\"1339\":1}}],[\"aspectjafterreturningadvice\",{\"1\":{\"1339\":1,\"1343\":1}}],[\"aspectjaroundadvice\",{\"1\":{\"1339\":1}}],[\"aspectjmethodbeforeadvice\",{\"1\":{\"1339\":1,\"1343\":1}}],[\"aspectjexpressionpointcut\",{\"1\":{\"1322\":1}}],[\"aspectj\",{\"0\":{\"1508\":1},\"1\":{\"1298\":5,\"1299\":1,\"1300\":1,\"1301\":1,\"1329\":2}}],[\"aspectj<\",{\"1\":{\"1137\":1}}],[\"aside\",{\"1\":{\"1120\":1}}],[\"asm\",{\"1\":{\"945\":1,\"1274\":1,\"1366\":1}}],[\"as的作用就是验证client端的身份\",{\"1\":{\"923\":1}}],[\"async\",{\"1\":{\"869\":1,\"1243\":1}}],[\"asynchronoussocketchannel\",{\"1\":{\"859\":6}}],[\"asynchronousserversocketchannel\",{\"1\":{\"859\":4}}],[\"asynchronousfilechannel\",{\"1\":{\"857\":3}}],[\"asynchronous\",{\"1\":{\"679\":1,\"789\":1}}],[\"aslist\",{\"1\":{\"615\":1,\"617\":1,\"620\":1,\"702\":1}}],[\"asc\",{\"1\":{\"1078\":1}}],[\"ascii\",{\"1\":{\"336\":3,\"799\":2}}],[\"asc|desc\",{\"1\":{\"264\":2}}],[\"association>\",{\"1\":{\"1230\":2}}],[\"associated\",{\"1\":{\"70\":2}}],[\"assignment\",{\"1\":{\"1040\":1,\"1041\":1}}],[\"assist\",{\"1\":{\"260\":1,\"261\":1,\"281\":1}}],[\"asserteventloop\",{\"1\":{\"740\":1}}],[\"assert\",{\"1\":{\"340\":4,\"741\":1,\"743\":1,\"1156\":1}}],[\"assassin\",{\"1\":{\"261\":1}}],[\"as\",{\"1\":{\"248\":2,\"267\":1,\"268\":1,\"271\":4,\"272\":2,\"276\":5,\"279\":1,\"290\":2,\"296\":1,\"298\":1,\"307\":1,\"310\":1,\"318\":13,\"341\":3,\"344\":1,\"347\":1,\"348\":1,\"349\":3,\"351\":10,\"353\":14,\"354\":9,\"355\":2,\"357\":2,\"360\":4,\"361\":2,\"363\":5,\"364\":2,\"365\":10,\"374\":1,\"378\":9,\"382\":4,\"385\":2,\"388\":6,\"391\":2,\"395\":4,\"396\":2,\"397\":1,\"400\":8,\"402\":1,\"404\":2,\"409\":1,\"423\":1,\"426\":1,\"437\":4,\"579\":2}}],[\"abean\",{\"1\":{\"974\":2}}],[\"abortpolicy终止策略\",{\"1\":{\"573\":1}}],[\"about\",{\"1\":{\"238\":1,\"276\":1}}],[\"ab\",{\"1\":{\"336\":1}}],[\"abcdef\",{\"1\":{\"694\":2}}],[\"abcdefg\",{\"1\":{\"614\":1}}],[\"abc123def\",{\"1\":{\"342\":7}}],[\"abc\",{\"1\":{\"336\":1,\"505\":1,\"694\":2,\"1441\":1}}],[\"abs\",{\"1\":{\"131\":1,\"144\":1,\"338\":3}}],[\"abstractelasticsearchconfiguration\",{\"1\":{\"1088\":1}}],[\"abstractfuture\",{\"1\":{\"762\":2}}],[\"abstractunsafe\",{\"1\":{\"740\":3,\"743\":2}}],[\"abstractchannelhandlercontext\",{\"1\":{\"749\":2}}],[\"abstractchannel\",{\"1\":{\"740\":4,\"743\":3}}],[\"abstractclass\",{\"1\":{\"85\":3}}],[\"abstractbootstrap\",{\"1\":{\"740\":4}}],[\"abstractniobytechannel\",{\"1\":{\"742\":1,\"744\":1,\"775\":1}}],[\"abstractniomessagechannel\",{\"1\":{\"742\":1,\"743\":1}}],[\"abstractniounsafe\",{\"1\":{\"725\":1}}],[\"abstractniochannel\",{\"1\":{\"725\":2,\"740\":1,\"742\":2,\"743\":1}}],[\"abstractskin\",{\"1\":{\"72\":1}}],[\"abstract\",{\"1\":{\"14\":8,\"33\":1,\"34\":2,\"38\":1,\"47\":3,\"84\":2,\"85\":3,\"88\":2,\"124\":1,\"442\":1,\"723\":3,\"733\":1,\"775\":1}}],[\"aioserver\",{\"1\":{\"859\":1}}],[\"aiodemo1\",{\"1\":{\"857\":4}}],[\"aio方式适用于连接数目多且连接比较长的架构\",{\"1\":{\"612\":1}}],[\"aio使用场景分析\",{\"1\":{\"612\":1}}],[\"aio叫做异步非阻塞io\",{\"1\":{\"611\":1}}],[\"aio\",{\"0\":{\"608\":1,\"611\":1,\"856\":1,\"857\":1,\"859\":1},\"1\":{\"608\":1,\"827\":1,\"856\":1,\"857\":3,\"858\":1}}],[\"ai大咖\",{\"1\":{\"126\":1}}],[\"ai\",{\"0\":{\"215\":1},\"1\":{\"125\":1}}],[\"ai艺术\",{\"1\":{\"124\":1}}],[\"a都下载导入到c项目的jar包文件夹中\",{\"1\":{\"104\":1}}],[\"acls\",{\"1\":{\"926\":2}}],[\"acl权限管理\",{\"0\":{\"925\":1}}],[\"ack机制\",{\"1\":{\"1054\":1}}],[\"acks\",{\"1\":{\"1023\":2,\"1043\":4}}],[\"acks=1\",{\"1\":{\"1021\":2}}],[\"ack模式\",{\"1\":{\"1021\":1}}],[\"ackqueue\",{\"1\":{\"901\":1}}],[\"acknowledgedresponse\",{\"1\":{\"1072\":1}}],[\"acknowledged\",{\"1\":{\"1072\":2}}],[\"acknowledge\",{\"1\":{\"899\":1}}],[\"ack应答响应\",{\"0\":{\"899\":1}}],[\"ack\",{\"1\":{\"694\":4,\"726\":3,\"899\":1,\"1051\":2}}],[\"acquired\",{\"1\":{\"1152\":2}}],[\"acquiresharedinterruptibly\",{\"1\":{\"585\":1}}],[\"acquireshared\",{\"1\":{\"585\":1}}],[\"acquireinterruptibly\",{\"1\":{\"585\":1}}],[\"acquirequeued\",{\"1\":{\"585\":1}}],[\"acquire\",{\"1\":{\"585\":1}}],[\"accounting\",{\"1\":{\"916\":1}}],[\"accpet\",{\"1\":{\"726\":2,\"859\":1}}],[\"accepthandler\",{\"1\":{\"859\":3}}],[\"acceptor\",{\"1\":{\"740\":1}}],[\"accept\",{\"0\":{\"743\":1,\"834\":1},\"1\":{\"614\":1,\"725\":1,\"726\":6,\"740\":3,\"742\":1,\"743\":5,\"748\":2,\"795\":1,\"826\":3,\"827\":4,\"831\":1,\"833\":1,\"834\":2,\"836\":2,\"837\":1,\"839\":1,\"840\":5,\"843\":2,\"846\":3,\"859\":4,\"1398\":1,\"1411\":1}}],[\"access\",{\"1\":{\"63\":1,\"683\":1,\"854\":1,\"925\":1,\"1499\":1,\"1529\":1}}],[\"accumulateandget\",{\"1\":{\"562\":1}}],[\"acid\",{\"1\":{\"293\":1}}],[\"active\",{\"1\":{\"692\":1,\"693\":1,\"697\":2,\"698\":1,\"699\":2,\"702\":1,\"710\":1,\"740\":2,\"743\":1,\"748\":3,\"1008\":1,\"1220\":1}}],[\"activebydefault>\",{\"1\":{\"92\":1}}],[\"activation>\",{\"1\":{\"92\":1}}],[\"am\",{\"1\":{\"944\":1,\"946\":1,\"948\":2,\"949\":4}}],[\"amd等\",{\"1\":{\"74\":1}}],[\"american=com\",{\"1\":{\"42\":1}}],[\"americandessertfactory\",{\"1\":{\"39\":1}}],[\"americanocoffee\",{\"1\":{\"28\":1,\"30\":1}}],[\"americano\",{\"1\":{\"28\":1,\"30\":1}}],[\"americancoffeefactory\",{\"1\":{\"34\":1}}],[\"americancoffee\",{\"1\":{\"25\":1,\"34\":1,\"39\":1,\"42\":1}}],[\"anylock\",{\"1\":{\"1150\":1}}],[\"anymatch\",{\"1\":{\"619\":1}}],[\"anyone\",{\"1\":{\"70\":1}}],[\"analyze\",{\"1\":{\"458\":2}}],[\"analytical\",{\"1\":{\"221\":1}}],[\"anayze分析器\",{\"0\":{\"458\":1}}],[\"angelababy\",{\"1\":{\"336\":11}}],[\"angela\",{\"1\":{\"336\":3}}],[\"annotationtransactionattributesource\",{\"1\":{\"1456\":1}}],[\"annotationawareaspectjautoproxycreator\",{\"1\":{\"1333\":1,\"1453\":1}}],[\"annotationbeannamegenerator\",{\"1\":{\"1274\":1}}],[\"annotationmetadata\",{\"1\":{\"1274\":1,\"1277\":1,\"1464\":1}}],[\"annotationconfigreactivewebserverapplicationcontext\",{\"1\":{\"1245\":1}}],[\"annotationconfigservletwebserverapplicationcontext\",{\"1\":{\"1245\":1}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"1245\":1}}],[\"annotationconfigwebapplicationcontext\",{\"1\":{\"1245\":1}}],[\"annotations\",{\"1\":{\"112\":1,\"113\":1}}],[\"annotatedtypemetadata\",{\"1\":{\"1466\":1}}],[\"annotated\",{\"1\":{\"128\":1}}],[\"an\",{\"1\":{\"128\":1,\"741\":1,\"789\":1}}],[\"animegan\",{\"1\":{\"125\":1}}],[\"antirez\",{\"1\":{\"1190\":1}}],[\"antitheft\",{\"1\":{\"75\":7}}],[\"ant\",{\"1\":{\"94\":1}}],[\"android\",{\"1\":{\"770\":2}}],[\"and\",{\"1\":{\"70\":1,\"76\":1,\"131\":1,\"170\":1,\"260\":1,\"279\":2,\"307\":1,\"332\":2,\"361\":2,\"437\":3,\"460\":2,\"481\":3,\"495\":2,\"579\":1,\"1136\":2,\"1137\":2,\"1157\":1}}],[\"app\",{\"1\":{\"1171\":1}}],[\"appender\",{\"1\":{\"1022\":3}}],[\"appendhexdumprowprefix\",{\"1\":{\"799\":3}}],[\"appendprettyhexdump\",{\"1\":{\"768\":1,\"799\":3}}],[\"append\",{\"1\":{\"768\":7,\"799\":21,\"843\":1,\"869\":1,\"988\":6,\"1232\":2}}],[\"apple\",{\"1\":{\"983\":3}}],[\"apply\",{\"1\":{\"614\":1,\"1129\":3}}],[\"application在run方法中重点做了以下操作\",{\"1\":{\"1522\":1}}],[\"application调用run方法的大致流程如下图\",{\"1\":{\"1522\":1}}],[\"application类的初始化和启动\",{\"1\":{\"1522\":1}}],[\"application的入口类\",{\"1\":{\"1522\":1}}],[\"applicationevent\",{\"1\":{\"1497\":1}}],[\"applicationlistener\",{\"1\":{\"1493\":1}}],[\"applicationrunner\",{\"1\":{\"1446\":1}}],[\"applicationcontext类型的容器是比较合适的选择\",{\"1\":{\"1501\":1}}],[\"applicationcontext要求更多的系统资源\",{\"1\":{\"1501\":1}}],[\"applicationcontext所管理的对象\",{\"1\":{\"1501\":1}}],[\"applicationcontextaware\",{\"1\":{\"1284\":1}}],[\"applicationcontext\",{\"0\":{\"1241\":1,\"1249\":1},\"1\":{\"1240\":2,\"1243\":6,\"1244\":1,\"1245\":2,\"1251\":1,\"1284\":1,\"1285\":3,\"1290\":1,\"1297\":1,\"1429\":1,\"1435\":1,\"1444\":1,\"1489\":1,\"1501\":1}}],[\"applicationclientprotocol\",{\"1\":{\"949\":1}}],[\"applications\",{\"1\":{\"945\":2}}],[\"applicationmasterprotocol\",{\"1\":{\"949\":1}}],[\"applicationmaster\",{\"0\":{\"947\":1},\"1\":{\"944\":1,\"945\":2,\"952\":2,\"953\":8}}],[\"application\",{\"0\":{\"1291\":1},\"1\":{\"70\":2,\"723\":1,\"733\":2,\"789\":1,\"1290\":1,\"1441\":1,\"1444\":9,\"1504\":1}}],[\"apr\",{\"1\":{\"726\":4}}],[\"ap\",{\"1\":{\"197\":1}}],[\"apachelog\",{\"1\":{\"374\":1}}],[\"apache\",{\"0\":{\"218\":1,\"229\":1,\"230\":1,\"233\":1,\"238\":1},\"1\":{\"91\":1,\"102\":2,\"112\":4,\"113\":3,\"114\":3,\"115\":3,\"229\":1,\"231\":1,\"268\":1,\"276\":1,\"296\":1,\"297\":1,\"298\":1,\"336\":1,\"344\":3,\"374\":2,\"397\":1,\"433\":2,\"436\":1,\"792\":1,\"957\":6,\"985\":1,\"1022\":5,\"1023\":2,\"1024\":2,\"1040\":1,\"1041\":1,\"1070\":2,\"1219\":4,\"1442\":1}}],[\"api开发\",{\"0\":{\"1022\":1}}],[\"api中仅仅包含了如下四个接口\",{\"1\":{\"716\":1}}],[\"api中的内容\",{\"1\":{\"9\":1}}],[\"api层面对\",{\"1\":{\"538\":1}}],[\"api进行通信\",{\"1\":{\"244\":1}}],[\"api<\",{\"1\":{\"112\":1,\"113\":1,\"1070\":1}}],[\"api\",{\"1\":{\"79\":1,\"80\":2,\"100\":1,\"112\":1,\"663\":5,\"791\":1,\"792\":3,\"850\":2,\"1379\":2,\"1499\":3}}],[\"ar表示一个topic下的所有副本\",{\"1\":{\"1049\":1}}],[\"ar\",{\"0\":{\"1049\":1},\"1\":{\"1049\":1}}],[\"arkansas\",{\"1\":{\"973\":1}}],[\"argumentresolvers\",{\"1\":{\"1381\":1}}],[\"argv\",{\"1\":{\"1146\":1,\"1151\":10,\"1156\":3}}],[\"arg\",{\"1\":{\"585\":26}}],[\"argn\",{\"1\":{\"358\":2}}],[\"arg2\",{\"1\":{\"343\":2}}],[\"arg1\",{\"1\":{\"343\":2,\"358\":2}}],[\"args\",{\"1\":{\"6\":1,\"7\":1,\"14\":1,\"17\":2,\"43\":1,\"47\":1,\"51\":1,\"52\":1,\"54\":2,\"58\":1,\"59\":7,\"60\":4,\"68\":2,\"70\":1,\"73\":1,\"74\":1,\"81\":1,\"85\":1,\"344\":1,\"536\":1,\"541\":1,\"551\":1,\"554\":3,\"555\":3,\"562\":1,\"614\":1,\"617\":1,\"645\":1,\"648\":2,\"668\":1,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"717\":1,\"718\":1,\"725\":1,\"726\":2,\"733\":2,\"735\":1,\"737\":3,\"748\":1,\"754\":1,\"766\":1,\"776\":1,\"795\":2,\"796\":1,\"809\":1,\"820\":1,\"822\":1,\"834\":2,\"836\":1,\"839\":2,\"840\":1,\"843\":2,\"846\":1,\"848\":2,\"857\":1,\"859\":1,\"962\":8,\"972\":5,\"973\":5,\"974\":5,\"985\":2,\"986\":2,\"988\":7,\"991\":1,\"999\":1,\"1244\":1,\"1257\":1,\"1304\":2,\"1306\":3,\"1309\":4,\"1317\":1,\"1444\":1,\"1449\":1}}],[\"archive\",{\"1\":{\"1046\":1}}],[\"archive档案文件\",{\"1\":{\"989\":1}}],[\"archive>\",{\"1\":{\"957\":1}}],[\"archive文件归档\",{\"1\":{\"906\":1}}],[\"archer\",{\"1\":{\"261\":1,\"281\":1}}],[\"arch\",{\"1\":{\"146\":1}}],[\"arxiv\",{\"1\":{\"117\":1,\"131\":1,\"144\":1}}],[\"arraywritable\",{\"1\":{\"956\":1}}],[\"arrays\",{\"1\":{\"615\":1,\"617\":1,\"620\":1,\"702\":1}}],[\"arrayblockingqueue<>\",{\"1\":{\"1157\":1}}],[\"arrayblockingqueue\",{\"1\":{\"572\":1}}],[\"array<string>\",{\"1\":{\"348\":1}}],[\"array<t>\",{\"1\":{\"339\":3}}],[\"array类型的数据作为输入\",{\"1\":{\"346\":1}}],[\"array\",{\"1\":{\"336\":3,\"339\":7,\"723\":3,\"841\":1,\"956\":1,\"1482\":1}}],[\"array数组\",{\"1\":{\"248\":1}}],[\"arraylist<string>\",{\"1\":{\"988\":2}}],[\"arraylist<>\",{\"1\":{\"43\":1,\"47\":1,\"617\":1,\"826\":1,\"827\":1,\"1089\":1,\"1168\":1,\"1171\":1,\"1172\":1,\"1257\":1}}],[\"arraylist\",{\"1\":{\"743\":1}}],[\"arraylist的扩容机制\",{\"0\":{\"601\":1}}],[\"arraylist底层采用的是object数组\",{\"1\":{\"600\":1}}],[\"arraylist和linkedlist都是不同步的\",{\"1\":{\"600\":1}}],[\"arraylist和linkedlist的区别\",{\"0\":{\"600\":1}}],[\"arraylist类中的iter内部类是具体的商品类\",{\"1\":{\"43\":1}}],[\"arraylist是具体的工厂类\",{\"1\":{\"43\":1}}],[\"arr\",{\"1\":{\"70\":3,\"839\":3}}],[\"are\",{\"1\":{\"70\":1,\"809\":3}}],[\"article\",{\"1\":{\"145\":4,\"543\":1,\"544\":1,\"545\":1,\"549\":1}}],[\"artifact>\",{\"1\":{\"344\":1}}],[\"artifact\",{\"1\":{\"104\":1,\"112\":1}}],[\"artifactid+verson\",{\"1\":{\"102\":1}}],[\"artifactid>\",{\"1\":{\"60\":1,\"98\":1,\"99\":2,\"101\":1,\"102\":2,\"104\":2,\"105\":2,\"107\":13,\"108\":1,\"112\":6,\"113\":6,\"114\":3,\"115\":3,\"344\":3,\"783\":1,\"957\":7,\"985\":2,\"1022\":9,\"1070\":9,\"1087\":7,\"1137\":1,\"1150\":1,\"1172\":5,\"1213\":2,\"1219\":9,\"1236\":2,\"1442\":1,\"1466\":1,\"1473\":1}}],[\"artifacts\",{\"1\":{\"92\":1}}],[\"arthas\",{\"1\":{\"59\":1,\"1310\":1,\"1313\":1}}],[\"advance\",{\"0\":{\"1544\":1}}],[\"advanced\",{\"1\":{\"1299\":1,\"1301\":1}}],[\"advised\",{\"1\":{\"1322\":1}}],[\"advisor3\",{\"1\":{\"1333\":1}}],[\"advisors\",{\"1\":{\"1333\":1}}],[\"advisor\",{\"0\":{\"1330\":1},\"1\":{\"1322\":1,\"1333\":3}}],[\"advice\",{\"1\":{\"1322\":2}}],[\"advertised\",{\"1\":{\"1018\":1}}],[\"adversarial\",{\"1\":{\"117\":1,\"120\":1,\"124\":1,\"127\":1,\"128\":2,\"130\":1}}],[\"adouble\",{\"1\":{\"621\":2}}],[\"admin通过该\",{\"1\":{\"949\":1}}],[\"admin\",{\"1\":{\"480\":1,\"936\":1,\"949\":1}}],[\"addapplicationlistenerbean\",{\"1\":{\"1497\":1}}],[\"addandget\",{\"1\":{\"562\":1}}],[\"addmapping\",{\"1\":{\"1449\":1}}],[\"addmilk\",{\"1\":{\"34\":2}}],[\"adderrorpages\",{\"1\":{\"1413\":1}}],[\"addbeanpostprocessor\",{\"1\":{\"1257\":3}}],[\"addservlet\",{\"1\":{\"1449\":1}}],[\"addservletcontainerinitializer\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"addseckillvoucher\",{\"1\":{\"1133\":3,\"1156\":1}}],[\"addsugar\",{\"1\":{\"34\":2}}],[\"addvoucher\",{\"1\":{\"1133\":1}}],[\"addpathpatterns\",{\"1\":{\"1100\":1}}],[\"addpolicies\",{\"1\":{\"875\":1}}],[\"addjob\",{\"1\":{\"991\":2}}],[\"adddependingjob\",{\"1\":{\"991\":1}}],[\"addinnerinterceptor\",{\"1\":{\"1232\":1}}],[\"addinterceptor\",{\"1\":{\"1100\":2}}],[\"addinterceptors\",{\"1\":{\"1100\":1}}],[\"addinputpath\",{\"1\":{\"972\":1,\"973\":1,\"974\":1}}],[\"adding\",{\"1\":{\"579\":1}}],[\"addcachefile\",{\"1\":{\"989\":2,\"990\":1}}],[\"addcachearchive\",{\"1\":{\"989\":1}}],[\"addclasspath>\",{\"1\":{\"957\":1}}],[\"addcontext\",{\"1\":{\"1449\":1}}],[\"addcomponents\",{\"1\":{\"779\":1}}],[\"addcount\",{\"1\":{\"579\":1}}],[\"addtaskwakesup\",{\"1\":{\"741\":1}}],[\"addtask\",{\"1\":{\"741\":1}}],[\"addlinstener\",{\"1\":{\"756\":1}}],[\"addlistener\",{\"1\":{\"735\":1,\"737\":2,\"740\":2,\"743\":1,\"752\":1,\"753\":2,\"754\":1,\"758\":1,\"761\":1,\"764\":1,\"766\":1,\"794\":1}}],[\"addlast\",{\"1\":{\"692\":3,\"696\":2,\"697\":3,\"698\":3,\"699\":3,\"702\":8,\"707\":4,\"710\":2,\"711\":4,\"733\":8,\"735\":4,\"737\":4,\"740\":3,\"743\":1,\"748\":4,\"753\":4,\"754\":2,\"766\":9,\"784\":2,\"785\":1,\"794\":3}}],[\"addwaiter\",{\"1\":{\"585\":1}}],[\"addr\",{\"1\":{\"324\":4,\"407\":1,\"408\":1,\"409\":3}}],[\"address\",{\"1\":{\"54\":8,\"320\":3,\"323\":2,\"324\":2,\"325\":4,\"495\":1,\"840\":1,\"848\":2}}],[\"add|replace\",{\"1\":{\"279\":1}}],[\"addobserver\",{\"1\":{\"47\":3}}],[\"add\",{\"1\":{\"34\":2,\"43\":3,\"47\":1,\"279\":1,\"280\":3,\"281\":3,\"337\":3,\"400\":3,\"495\":1,\"617\":1,\"671\":1,\"673\":3,\"702\":1,\"713\":1,\"714\":2,\"723\":2,\"740\":1,\"826\":1,\"827\":1,\"846\":1,\"988\":2,\"999\":1,\"1073\":4,\"1157\":1,\"1161\":1,\"1162\":1,\"1165\":1,\"1167\":1,\"1168\":1,\"1171\":2,\"1172\":1,\"1180\":1,\"1243\":1,\"1257\":1,\"1292\":1,\"1296\":1,\"1313\":2,\"1317\":1}}],[\"adaptee\",{\"1\":{\"5\":1}}],[\"adapter\",{\"1\":{\"5\":2,\"6\":4,\"7\":4}}],[\"a\",{\"1\":{\"6\":2,\"68\":2,\"73\":17,\"104\":2,\"105\":4,\"161\":1,\"190\":1,\"271\":2,\"276\":2,\"279\":4,\"317\":1,\"318\":1,\"320\":12,\"323\":8,\"325\":10,\"326\":24,\"330\":1,\"332\":9,\"336\":1,\"338\":2,\"340\":6,\"348\":2,\"349\":5,\"351\":1,\"352\":7,\"378\":2,\"409\":10,\"460\":8,\"481\":4,\"496\":5,\"551\":3,\"567\":2,\"617\":6,\"637\":1,\"663\":2,\"668\":7,\"669\":3,\"692\":2,\"693\":2,\"697\":12,\"698\":12,\"699\":12,\"748\":6,\"772\":2,\"773\":1,\"774\":3,\"776\":8,\"779\":4,\"780\":2,\"795\":1,\"796\":1,\"799\":1,\"805\":2,\"807\":7,\"808\":2,\"821\":3,\"822\":1,\"836\":2,\"843\":1,\"848\":1,\"857\":1,\"920\":1,\"974\":2,\"1199\":1,\"1205\":3,\"1206\":1,\"1210\":4,\"1317\":4}}],[\"c则redis停止\",{\"1\":{\"1195\":1}}],[\"cj\",{\"1\":{\"1236\":1}}],[\"cj2\",{\"1\":{\"991\":4}}],[\"cj1\",{\"1\":{\"991\":4}}],[\"cp\",{\"1\":{\"876\":1,\"1196\":1}}],[\"cpu性能提升了\",{\"1\":{\"1115\":1}}],[\"cpu缓存\",{\"1\":{\"1115\":1}}],[\"cpu中的内存管理单元就是用于将逻辑地址翻译成物理地址\",{\"1\":{\"684\":1}}],[\"cpu密集型\",{\"1\":{\"576\":1}}],[\"cpu空闲时\",{\"1\":{\"535\":1}}],[\"cpu要分别发出多条i\",{\"1\":{\"209\":1}}],[\"cpu每发出一条i\",{\"1\":{\"209\":1}}],[\"cpu介入频率进一步降低\",{\"1\":{\"209\":1}}],[\"cpu与i\",{\"1\":{\"209\":1}}],[\"cpu不再需要不停的轮询\",{\"1\":{\"209\":1}}],[\"cpu需要一直轮询检查\",{\"1\":{\"209\":1}}],[\"cpu和i\",{\"1\":{\"209\":2}}],[\"cpu干预的频率\",{\"1\":{\"209\":3}}],[\"cpu检查是否越界\",{\"1\":{\"180\":1}}],[\"cpu利用率得到明显的提升\",{\"1\":{\"209\":1}}],[\"cpu利用率低\",{\"1\":{\"209\":1}}],[\"cpu利用率\",{\"1\":{\"166\":1}}],[\"cpu最昂贵的部件\",{\"1\":{\"160\":1}}],[\"cpu都要检查当前是否有外部中断的信号\",{\"1\":{\"157\":1}}],[\"cpu立即进入核心态\",{\"1\":{\"157\":1}}],[\"cpu有两种处理器状态\",{\"1\":{\"156\":1}}],[\"cpu如何判断当前是否可以执行特权指令\",{\"1\":{\"156\":1}}],[\"cpu=\",{\"1\":{\"17\":2}}],[\"cpu\",{\"0\":{\"847\":1},\"1\":{\"17\":17,\"74\":15,\"209\":4,\"576\":6,\"664\":1,\"742\":1,\"755\":1,\"792\":1,\"826\":1,\"827\":1,\"846\":4,\"847\":1,\"854\":5,\"855\":7,\"948\":1}}],[\"cd\",{\"1\":{\"876\":1,\"936\":1,\"1012\":4,\"1045\":1,\"1046\":5,\"1193\":1,\"1196\":1}}],[\"c0\",{\"1\":{\"875\":1}}],[\"c++\",{\"1\":{\"697\":1,\"698\":1,\"699\":1}}],[\"c+m\",{\"1\":{\"214\":1}}],[\"c−v\",{\"1\":{\"648\":1}}],[\"cms被标记为deprecate了\",{\"1\":{\"640\":1}}],[\"cms\",{\"0\":{\"640\":1},\"1\":{\"638\":4}}],[\"cms回收停顿了几次\",{\"1\":{\"633\":1}}],[\"cms解决什么问题\",{\"1\":{\"633\":1}}],[\"cms和g1了解么\",{\"1\":{\"633\":1}}],[\"cms特点\",{\"1\":{\"633\":1}}],[\"cms收集器与g1收集器的特点\",{\"1\":{\"633\":1}}],[\"cmu\",{\"1\":{\"119\":1}}],[\"cyclicbarrier\",{\"0\":{\"593\":1},\"1\":{\"593\":4}}],[\"cycle\",{\"1\":{\"117\":1,\"1294\":5}}],[\"cyclegan在照片转莫奈油画\",{\"1\":{\"117\":1}}],[\"cyclegan是image\",{\"1\":{\"117\":1}}],[\"cyclegan照片转梵高莫奈油画\",{\"1\":{\"117\":1}}],[\"cyclegan\",{\"0\":{\"116\":1,\"129\":1},\"1\":{\"117\":1,\"121\":1,\"131\":1}}],[\"center\",{\"1\":{\"923\":1,\"999\":8}}],[\"cellsbusy\",{\"1\":{\"564\":1}}],[\"cells\",{\"1\":{\"564\":1}}],[\"cell\",{\"1\":{\"564\":3}}],[\"ceil\",{\"1\":{\"338\":4}}],[\"ceil都会生成3个anchor\",{\"1\":{\"138\":1}}],[\"ceil对应更大的感受野\",{\"1\":{\"138\":1}}],[\"c3\",{\"1\":{\"1420\":2}}],[\"c3=value3\",{\"1\":{\"483\":1}}],[\"c3个维度\",{\"1\":{\"352\":1}}],[\"cbo计算代价的手段\",{\"1\":{\"458\":1}}],[\"cbo\",{\"0\":{\"457\":1},\"1\":{\"457\":1}}],[\"cbuf\",{\"1\":{\"9\":2}}],[\"curl\",{\"1\":{\"1440\":2}}],[\"currentproxy\",{\"1\":{\"1137\":1,\"1142\":1,\"1150\":1,\"1157\":1}}],[\"currentpage\",{\"1\":{\"1089\":4}}],[\"currentchildattrs\",{\"1\":{\"740\":3}}],[\"currentchildoptions\",{\"1\":{\"740\":3}}],[\"currentchildhandler\",{\"1\":{\"740\":2}}],[\"currentchildgroup\",{\"1\":{\"740\":2}}],[\"currenttimemillis\",{\"1\":{\"823\":2,\"999\":16,\"1132\":2,\"1162\":1,\"1167\":1}}],[\"currenttimenanos\",{\"1\":{\"742\":6}}],[\"currentthread\",{\"1\":{\"536\":2,\"717\":1,\"718\":1,\"741\":1,\"859\":3,\"1142\":1,\"1144\":2,\"1147\":1,\"1152\":1}}],[\"currenttransaction\",{\"1\":{\"293\":1}}],[\"currenthandvalue\",{\"1\":{\"81\":9}}],[\"current\",{\"1\":{\"70\":3,\"302\":1,\"337\":6,\"343\":2,\"360\":1,\"361\":3,\"909\":1,\"1161\":2,\"1164\":1,\"1165\":3,\"1172\":7}}],[\"currentruntime\",{\"1\":{\"70\":2}}],[\"customcombiner\",{\"1\":{\"970\":1}}],[\"cube下\",{\"1\":{\"354\":1}}],[\"cube\",{\"0\":{\"354\":1},\"1\":{\"352\":1,\"354\":1}}],[\"cnblogs\",{\"1\":{\"602\":1}}],[\"cn\",{\"1\":{\"336\":3,\"503\":1,\"733\":1,\"735\":1,\"1050\":1,\"1179\":1,\"1532\":1}}],[\"cnt3\",{\"1\":{\"351\":1}}],[\"cnt2\",{\"1\":{\"351\":2}}],[\"cnt1\",{\"1\":{\"351\":3}}],[\"cnts>\",{\"1\":{\"307\":1}}],[\"cnts\",{\"1\":{\"307\":1,\"310\":3}}],[\"cnt\",{\"1\":{\"276\":3,\"351\":2}}],[\"c三个表都在一个mr作业中联接\",{\"1\":{\"326\":1}}],[\"crash\",{\"1\":{\"1054\":1}}],[\"crash之后\",{\"1\":{\"1048\":1,\"1050\":1}}],[\"crypto\",{\"1\":{\"936\":1}}],[\"crc16\",{\"1\":{\"528\":1}}],[\"crc32\",{\"1\":{\"343\":1}}],[\"crc32加密\",{\"1\":{\"343\":1}}],[\"cross\",{\"0\":{\"325\":1},\"1\":{\"325\":3}}],[\"createnewfilename\",{\"1\":{\"1159\":1}}],[\"createvoucherorder\",{\"1\":{\"1137\":4,\"1142\":1,\"1150\":1,\"1157\":2}}],[\"createuserwithphone\",{\"1\":{\"1099\":1,\"1107\":1}}],[\"createindex\",{\"1\":{\"1089\":1}}],[\"createindexresponse\",{\"1\":{\"1072\":1}}],[\"createindexrequest\",{\"1\":{\"1072\":2}}],[\"createzone\",{\"1\":{\"936\":1}}],[\"createsnapshot\",{\"1\":{\"914\":1}}],[\"creategroup\",{\"1\":{\"701\":1,\"704\":1}}],[\"createtempdirectory\",{\"1\":{\"1449\":1}}],[\"createtree\",{\"1\":{\"669\":2}}],[\"createtime\",{\"1\":{\"359\":2,\"360\":4,\"361\":4,\"363\":2,\"364\":4,\"365\":18}}],[\"createdirectories\",{\"1\":{\"822\":1}}],[\"createdirectory\",{\"1\":{\"822\":1,\"823\":1}}],[\"createdby\",{\"1\":{\"278\":1}}],[\"createdessert\",{\"1\":{\"39\":3}}],[\"create\",{\"1\":{\"60\":1,\"256\":1,\"258\":1,\"260\":1,\"261\":1,\"262\":1,\"265\":1,\"266\":1,\"268\":1,\"271\":3,\"272\":4,\"276\":2,\"278\":2,\"279\":1,\"280\":1,\"281\":1,\"285\":1,\"287\":2,\"288\":2,\"289\":1,\"298\":1,\"318\":4,\"329\":1,\"340\":1,\"344\":1,\"348\":1,\"351\":2,\"352\":1,\"357\":1,\"359\":2,\"374\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"395\":1,\"397\":1,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"423\":1,\"437\":5,\"480\":2,\"936\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"1015\":1,\"1020\":1,\"1072\":1,\"1107\":1,\"1150\":1,\"1164\":1,\"1174\":1,\"1176\":1,\"1306\":1}}],[\"createcoffee\",{\"1\":{\"28\":1,\"30\":1,\"34\":4,\"39\":3,\"42\":1}}],[\"createbike\",{\"1\":{\"14\":6}}],[\"ctx\",{\"1\":{\"692\":9,\"693\":2,\"696\":4,\"697\":3,\"698\":3,\"699\":3,\"702\":13,\"703\":5,\"704\":12,\"705\":6,\"707\":4,\"710\":10,\"711\":3,\"713\":2,\"714\":3,\"723\":3,\"730\":1,\"734\":2,\"736\":1,\"738\":1,\"740\":7,\"743\":3,\"748\":4,\"766\":28,\"775\":2,\"784\":1,\"794\":5,\"1449\":2,\"1451\":2}}],[\"ctl\",{\"1\":{\"680\":1}}],[\"ctl注册fd\",{\"1\":{\"680\":1}}],[\"ctas\",{\"1\":{\"318\":1}}],[\"ctas和插入语句中的cte\",{\"1\":{\"318\":1}}],[\"ctes\",{\"1\":{\"318\":1}}],[\"cte的使用\",{\"1\":{\"318\":1}}],[\"cte可以在\",{\"1\":{\"318\":1}}],[\"cte仅在单个语句的执行范围内定义\",{\"1\":{\"318\":1}}],[\"cte\",{\"0\":{\"318\":1},\"1\":{\"318\":2}}],[\"cvpods\",{\"1\":{\"146\":3}}],[\"cvpr\",{\"1\":{\"130\":1}}],[\"cccccc\",{\"1\":{\"699\":1}}],[\"ccc\",{\"1\":{\"617\":1,\"698\":1}}],[\"cc\",{\"1\":{\"124\":2,\"496\":9}}],[\"c依赖a\",{\"1\":{\"104\":1}}],[\"chgrp\",{\"1\":{\"920\":1}}],[\"chmod\",{\"1\":{\"920\":2,\"1046\":1}}],[\"child\",{\"1\":{\"743\":7}}],[\"childattrs\",{\"1\":{\"740\":2,\"743\":1}}],[\"childoptions\",{\"1\":{\"740\":2,\"743\":1}}],[\"childgroup\",{\"1\":{\"740\":1,\"743\":1}}],[\"childhandler\",{\"1\":{\"692\":1,\"702\":1,\"711\":1,\"733\":1,\"740\":1,\"743\":2,\"748\":2,\"766\":1,\"784\":2,\"794\":1}}],[\"chinese\",{\"1\":{\"718\":2,\"1244\":1}}],[\"ch\",{\"1\":{\"692\":5,\"696\":3,\"697\":4,\"698\":4,\"699\":4,\"702\":10,\"707\":4,\"710\":3,\"711\":5,\"733\":10,\"735\":5,\"737\":5,\"740\":4,\"742\":3,\"748\":6,\"753\":8,\"754\":3,\"766\":6,\"784\":3,\"785\":2,\"794\":5,\"836\":1}}],[\"check来解决这样的问题\",{\"1\":{\"1126\":1}}],[\"checkpoint\",{\"1\":{\"910\":1}}],[\"checking\",{\"1\":{\"876\":1}}],[\"checknative来检查native包是否安装好\",{\"1\":{\"872\":1}}],[\"checknotnull\",{\"1\":{\"749\":1}}],[\"check\",{\"1\":{\"775\":1}}],[\"checkdeadlock\",{\"1\":{\"765\":2}}],[\"check的缩写\",{\"1\":{\"281\":1}}],[\"checkresolve\",{\"1\":{\"69\":1}}],[\"chatresponsemessage\",{\"1\":{\"703\":2,\"723\":3}}],[\"chatrequestmessagehandler\",{\"1\":{\"703\":1}}],[\"chatrequestmessage\",{\"1\":{\"702\":1,\"703\":1,\"723\":3}}],[\"chatclient\",{\"1\":{\"702\":1}}],[\"chatserver\",{\"1\":{\"702\":1}}],[\"channeldemo7\",{\"1\":{\"846\":1}}],[\"channeldemo6\",{\"1\":{\"834\":1,\"836\":7}}],[\"channeldemo1\",{\"1\":{\"796\":18}}],[\"channelduplexhandler\",{\"1\":{\"707\":4}}],[\"channeloutboundhandleradapter\",{\"1\":{\"766\":5}}],[\"channeloption\",{\"1\":{\"693\":2,\"725\":1,\"726\":1,\"740\":1}}],[\"channelconfig\",{\"1\":{\"743\":1,\"744\":1}}],[\"channelpipeline\",{\"1\":{\"740\":3,\"743\":1,\"744\":1,\"766\":2}}],[\"channelpromise\",{\"1\":{\"725\":2,\"740\":5,\"743\":2,\"766\":3}}],[\"channelfactory\",{\"1\":{\"740\":1}}],[\"channelfuturelistener\",{\"1\":{\"740\":2,\"743\":1,\"753\":2,\"754\":1,\"766\":1}}],[\"channelfuture\",{\"0\":{\"753\":1},\"1\":{\"692\":9,\"696\":3,\"697\":3,\"698\":3,\"699\":3,\"710\":3,\"711\":3,\"725\":1,\"735\":1,\"740\":6,\"743\":1,\"753\":15,\"754\":5}}],[\"channels\",{\"1\":{\"704\":4,\"826\":3,\"827\":3,\"836\":2}}],[\"channelhandler\",{\"1\":{\"703\":2,\"704\":5,\"705\":1,\"714\":1,\"734\":1,\"736\":1,\"738\":1,\"740\":2,\"766\":4,\"775\":3}}],[\"channelhandlercontext\",{\"1\":{\"692\":3,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":3,\"703\":2,\"704\":5,\"705\":2,\"707\":2,\"710\":4,\"711\":2,\"713\":2,\"714\":2,\"723\":2,\"734\":1,\"736\":1,\"738\":1,\"740\":3,\"743\":3,\"748\":3,\"766\":7,\"784\":1,\"794\":2}}],[\"channelread\",{\"1\":{\"702\":1,\"710\":1,\"711\":1,\"743\":3,\"748\":3,\"766\":7,\"794\":2}}],[\"channelread0\",{\"1\":{\"702\":1,\"703\":2,\"704\":5,\"711\":1,\"734\":1,\"736\":1,\"738\":1,\"784\":1}}],[\"channelactive\",{\"1\":{\"692\":3,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":1,\"710\":1,\"740\":2,\"743\":2}}],[\"channelinitializer<niosocketchannel>\",{\"1\":{\"748\":3,\"754\":1,\"766\":1,\"784\":1,\"794\":2}}],[\"channelinitializer<channel>\",{\"1\":{\"740\":1,\"753\":4,\"766\":1,\"785\":1}}],[\"channelinitializer<socketchannel>\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"733\":2,\"735\":1,\"737\":1}}],[\"channelinitializer\",{\"1\":{\"740\":2,\"784\":1,\"785\":1}}],[\"channelinactive\",{\"1\":{\"692\":2,\"705\":1}}],[\"channelinboundhandleradapter\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":1,\"705\":1,\"710\":1,\"711\":1,\"748\":3,\"766\":5,\"794\":2}}],[\"channel读取或者写入数据必须通过buffer\",{\"1\":{\"610\":1}}],[\"channel\",{\"0\":{\"752\":1,\"820\":1,\"831\":1,\"832\":1,\"850\":1,\"861\":1},\"1\":{\"610\":2,\"692\":8,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"701\":22,\"702\":12,\"703\":5,\"704\":6,\"705\":4,\"707\":2,\"710\":3,\"711\":2,\"713\":4,\"725\":3,\"726\":1,\"733\":10,\"735\":6,\"737\":15,\"740\":38,\"741\":2,\"742\":5,\"743\":12,\"744\":2,\"746\":8,\"748\":11,\"749\":1,\"752\":5,\"753\":21,\"754\":8,\"755\":1,\"762\":1,\"765\":2,\"766\":12,\"775\":2,\"784\":1,\"785\":4,\"787\":4,\"794\":8,\"796\":2,\"797\":1,\"802\":2,\"803\":2,\"807\":2,\"808\":4,\"813\":2,\"814\":2,\"815\":3,\"816\":2,\"817\":2,\"826\":4,\"827\":5,\"828\":3,\"829\":1,\"831\":3,\"832\":1,\"833\":1,\"834\":6,\"836\":7,\"838\":1,\"840\":8,\"841\":3,\"843\":7,\"844\":1,\"846\":2,\"848\":5,\"850\":3,\"851\":1,\"855\":1,\"861\":5,\"867\":5}}],[\"changesplitmapper\",{\"1\":{\"373\":1}}],[\"change\",{\"1\":{\"279\":12}}],[\"champion\",{\"1\":{\"348\":3,\"349\":2}}],[\"championship\",{\"1\":{\"348\":6,\"349\":2}}],[\"chaining\",{\"1\":{\"318\":1}}],[\"charts=true\",{\"1\":{\"1046\":1}}],[\"charsequence\",{\"1\":{\"772\":1}}],[\"charset=utf\",{\"1\":{\"1416\":1,\"1462\":1}}],[\"charset=utf8mb4\",{\"1\":{\"1164\":1,\"1174\":1}}],[\"charset\",{\"1\":{\"710\":1,\"748\":2,\"766\":1,\"772\":2,\"794\":2,\"805\":1,\"840\":3,\"843\":1,\"859\":2}}],[\"charbuffer\",{\"1\":{\"610\":1,\"805\":1,\"861\":1}}],[\"characterencoding=utf\",{\"1\":{\"1046\":1,\"1236\":1}}],[\"characterencoding=utf8\",{\"1\":{\"986\":1}}],[\"characterstream\",{\"1\":{\"617\":2}}],[\"character创建了数值在\",{\"1\":{\"598\":1}}],[\"character\",{\"1\":{\"482\":1,\"617\":1,\"899\":1}}],[\"char\",{\"1\":{\"9\":1,\"252\":4,\"290\":5,\"371\":1,\"566\":2,\"661\":3,\"662\":5,\"663\":11,\"668\":3,\"692\":1,\"697\":1,\"698\":1,\"699\":1,\"772\":1,\"796\":1,\"799\":7}}],[\"chown\",{\"1\":{\"920\":2}}],[\"cho\",{\"1\":{\"81\":2}}],[\"cglib在创建代理对象时所花费的时间比jdk动态代理多很多\",{\"1\":{\"1512\":1}}],[\"cglib创建的代理对象比jdk动态代理创建的代理对象高很多\",{\"1\":{\"1512\":1}}],[\"cglibproxydemo\",{\"1\":{\"1306\":1}}],[\"cglib\",{\"0\":{\"1306\":1,\"1314\":1,\"1315\":1,\"1318\":1,\"1319\":1,\"1322\":1},\"1\":{\"1307\":2,\"1325\":1,\"1480\":1}}],[\"cglib不能对声明为final的类或者方法进行代理\",{\"1\":{\"61\":1}}],[\"cglib底层采用asm字节码生成框架\",{\"1\":{\"61\":1}}],[\"cglib是第三方提供的包\",{\"1\":{\"60\":1}}],[\"cglib是一个功能强大\",{\"1\":{\"60\":1}}],[\"cglib动态代理方式\",{\"1\":{\"60\":1}}],[\"cglib动态代理\",{\"0\":{\"60\":1}}],[\"c\",{\"0\":{\"662\":1},\"1\":{\"54\":2,\"68\":2,\"88\":6,\"104\":7,\"161\":1,\"176\":1,\"204\":2,\"206\":1,\"214\":1,\"279\":4,\"325\":2,\"326\":18,\"336\":1,\"340\":2,\"352\":6,\"378\":3,\"382\":2,\"388\":1,\"460\":1,\"481\":2,\"617\":2,\"648\":5,\"649\":9,\"661\":3,\"662\":11,\"663\":5,\"668\":10,\"692\":5,\"693\":5,\"697\":18,\"698\":16,\"699\":18,\"740\":1,\"746\":1,\"748\":18,\"750\":2,\"751\":5,\"760\":4,\"761\":3,\"762\":3,\"763\":4,\"764\":3,\"772\":2,\"773\":1,\"774\":3,\"776\":8,\"779\":4,\"780\":2,\"796\":18,\"799\":1,\"805\":2,\"807\":7,\"808\":2,\"822\":2,\"834\":2,\"836\":10,\"846\":2,\"848\":1,\"857\":4,\"1012\":1,\"1046\":1,\"1151\":1,\"1210\":2,\"1449\":1,\"1451\":1}}],[\"c2=value2\",{\"1\":{\"483\":1}}],[\"c2\",{\"1\":{\"52\":3,\"54\":6}}],[\"c1=value1\",{\"1\":{\"483\":1}}],[\"c1\",{\"1\":{\"52\":4,\"54\":8,\"279\":3,\"875\":1}}],[\"cin\",{\"1\":{\"669\":2}}],[\"city\",{\"1\":{\"262\":8,\"320\":3,\"323\":2}}],[\"citation类和student类必须实现serializable接口\",{\"1\":{\"54\":1}}],[\"citationtest1\",{\"1\":{\"54\":1}}],[\"citationtest\",{\"1\":{\"52\":1,\"54\":1}}],[\"citation\",{\"1\":{\"52\":6,\"54\":11}}],[\"cike\",{\"1\":{\"261\":1}}],[\"ci​\",{\"1\":{\"140\":1}}],[\"ci​^​\",{\"1\":{\"140\":1}}],[\"circle\",{\"1\":{\"23\":5}}],[\"cachingresourceresolver\",{\"1\":{\"1432\":1}}],[\"cachingmetadatareaderfactory\",{\"1\":{\"1274\":1}}],[\"caching\",{\"1\":{\"1120\":1}}],[\"cache1\",{\"1\":{\"1432\":1}}],[\"cacheid\",{\"1\":{\"1144\":2}}],[\"cacheclient\",{\"1\":{\"1129\":5}}],[\"cachecode\",{\"1\":{\"1099\":3,\"1107\":3}}],[\"cachebuilder\",{\"1\":{\"1113\":1}}],[\"cache<k\",{\"1\":{\"1113\":1}}],[\"cache\",{\"1\":{\"448\":1,\"678\":1,\"1113\":2,\"1120\":1,\"1122\":4,\"1124\":5,\"1127\":5,\"1128\":4,\"1129\":8}}],[\"category\",{\"1\":{\"1089\":2}}],[\"cat访问仿佛就是未加密的文件\",{\"1\":{\"928\":1}}],[\"catch\",{\"1\":{\"42\":1,\"47\":2,\"59\":10,\"88\":1,\"536\":1,\"551\":2,\"554\":2,\"555\":4,\"593\":4,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":3,\"710\":1,\"711\":1,\"717\":1,\"718\":1,\"723\":3,\"725\":1,\"726\":1,\"733\":3,\"734\":1,\"735\":1,\"737\":1,\"740\":5,\"741\":4,\"742\":2,\"743\":4,\"744\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":3,\"795\":4,\"796\":1,\"807\":1,\"808\":1,\"820\":2,\"823\":1,\"834\":2,\"836\":1,\"840\":1,\"846\":4,\"848\":2,\"857\":1,\"859\":3,\"1023\":1,\"1024\":1,\"1025\":1,\"1071\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1157\":1,\"1159\":1,\"1309\":5}}],[\"can\",{\"1\":{\"1152\":1}}],[\"cancelledkeyexception\",{\"1\":{\"742\":2}}],[\"cancelledkeys\",{\"1\":{\"741\":1}}],[\"cancel\",{\"0\":{\"838\":1},\"1\":{\"716\":1,\"717\":2,\"718\":3,\"756\":1,\"835\":1,\"836\":1,\"838\":1,\"840\":2,\"846\":2}}],[\"cannot\",{\"1\":{\"271\":1}}],[\"caused\",{\"1\":{\"762\":1}}],[\"cause\",{\"1\":{\"705\":2,\"725\":2,\"735\":3,\"737\":1,\"740\":9,\"743\":1,\"756\":1,\"763\":1,\"764\":1}}],[\"capacity\",{\"1\":{\"579\":2,\"606\":3,\"610\":1,\"768\":3,\"772\":2,\"773\":4,\"774\":3,\"776\":1,\"777\":1,\"798\":1,\"799\":5,\"840\":1,\"874\":2}}],[\"cap\",{\"1\":{\"579\":2}}],[\"carbondata\",{\"1\":{\"336\":1}}],[\"card\",{\"1\":{\"6\":8,\"7\":2}}],[\"california\",{\"1\":{\"973\":1}}],[\"calculatestrategy\",{\"1\":{\"741\":2}}],[\"calcite实现\",{\"1\":{\"274\":1}}],[\"callback\",{\"1\":{\"1317\":1}}],[\"callable<integer>\",{\"1\":{\"757\":1,\"758\":1}}],[\"called\",{\"1\":{\"740\":1,\"743\":1}}],[\"callerrunspolicy调用者运行策略\",{\"1\":{\"573\":1}}],[\"callsuper\",{\"1\":{\"733\":2}}],[\"call\",{\"1\":{\"679\":3,\"757\":1,\"758\":1,\"765\":2,\"949\":1,\"1146\":7,\"1151\":10,\"1156\":4}}],[\"calendar类中的getinstance\",{\"1\":{\"43\":1}}],[\"cassandra\",{\"1\":{\"791\":1}}],[\"cas是乐观锁的一种实现方式\",{\"1\":{\"630\":1}}],[\"cas是基于乐观锁的思想~~\",{\"1\":{\"561\":1}}],[\"cas体现的是无锁并发\",{\"1\":{\"561\":1}}],[\"cas的特点\",{\"0\":{\"561\":1}}],[\"cas\",{\"1\":{\"507\":1,\"564\":1,\"591\":1}}],[\"cascade\",{\"1\":{\"278\":1}}],[\"cascade关键字慎重使用\",{\"1\":{\"278\":1}}],[\"castor\",{\"1\":{\"1499\":1}}],[\"castabat\",{\"1\":{\"579\":1}}],[\"cast\",{\"1\":{\"248\":1,\"341\":4,\"385\":1}}],[\"cases\",{\"1\":{\"265\":3,\"266\":1,\"302\":1,\"972\":8,\"974\":8}}],[\"case\",{\"1\":{\"69\":1,\"340\":4,\"351\":2,\"380\":2,\"382\":3,\"702\":7,\"741\":3}}],[\"caixin\",{\"1\":{\"85\":5}}],[\"covidtop1driver\",{\"1\":{\"974\":4}}],[\"covidtop1reducer\",{\"1\":{\"974\":3}}],[\"covidtop1mapper\",{\"1\":{\"974\":3}}],[\"covidtop1bean\",{\"1\":{\"974\":17}}],[\"covidtop1groupingcomparator\",{\"1\":{\"974\":4}}],[\"covidpartitiondriver\",{\"1\":{\"973\":4}}],[\"covidpartitionreducer\",{\"1\":{\"973\":3}}],[\"covidpartitionmapper\",{\"1\":{\"973\":3}}],[\"covidsumdriver\",{\"1\":{\"972\":4}}],[\"covidsumreducer\",{\"1\":{\"972\":3}}],[\"covidsummapper\",{\"1\":{\"972\":3}}],[\"covidcountbean>\",{\"1\":{\"972\":4}}],[\"covidcountbean\",{\"1\":{\"972\":11}}],[\"covid\",{\"0\":{\"971\":1},\"1\":{\"974\":1}}],[\"covid19\",{\"1\":{\"265\":1,\"266\":4,\"271\":12,\"302\":4,\"303\":5,\"307\":3,\"310\":1,\"369\":2}}],[\"coding\",{\"0\":{\"875\":1},\"1\":{\"875\":1}}],[\"coder\",{\"1\":{\"1525\":1}}],[\"code\",{\"1\":{\"973\":3,\"991\":8,\"1099\":7,\"1100\":1,\"1107\":3}}],[\"codeword\",{\"1\":{\"875\":1}}],[\"codec\",{\"1\":{\"433\":1,\"702\":4,\"733\":4,\"735\":2,\"737\":2}}],[\"codec=\",{\"1\":{\"433\":1}}],[\"code>\",{\"1\":{\"70\":2}}],[\"copyoptions\",{\"1\":{\"1107\":1}}],[\"copyonwrite并发容器适用于对于绝大部分访问都是读\",{\"1\":{\"578\":1}}],[\"copyonwritearraylist是java\",{\"1\":{\"578\":1}}],[\"copyonwritearraylist\",{\"0\":{\"578\":1}}],[\"copyproperties\",{\"1\":{\"1101\":1,\"1107\":1,\"1162\":1,\"1165\":2}}],[\"copy过来的数据会先放入内存缓冲区中\",{\"1\":{\"980\":1}}],[\"copy阶段\",{\"1\":{\"980\":1}}],[\"copy\",{\"0\":{\"778\":1},\"1\":{\"566\":1,\"822\":2,\"823\":1,\"878\":1}}],[\"cout\",{\"1\":{\"646\":1,\"669\":3}}],[\"coucurrenthashmap和hashmap的实现方式都是一样的\",{\"1\":{\"579\":1}}],[\"course\",{\"1\":{\"493\":2}}],[\"countdeaths\",{\"1\":{\"972\":3}}],[\"countdown\",{\"1\":{\"702\":1,\"1132\":2}}],[\"countdownlatch名为信号枪\",{\"1\":{\"1132\":1}}],[\"countdownlatch要想恢复设定值只能重新创建新的countdownlatch对象\",{\"1\":{\"593\":1}}],[\"countdownlatch就不如future了\",{\"1\":{\"592\":1}}],[\"countdownlatch\",{\"0\":{\"592\":1},\"1\":{\"592\":1,\"702\":2,\"1132\":4}}],[\"countdownlatch都继承了该抽象类\",{\"1\":{\"581\":1}}],[\"countcases\",{\"1\":{\"972\":3}}],[\"count++\",{\"1\":{\"668\":1,\"1176\":1}}],[\"count表示以当前单词结尾的单词数量\",{\"1\":{\"668\":1}}],[\"counter=3\",{\"1\":{\"983\":1}}],[\"counters\",{\"1\":{\"983\":2}}],[\"counter计数器\",{\"0\":{\"982\":1}}],[\"countercells初始有两个cell\",{\"1\":{\"579\":1}}],[\"counter++\",{\"1\":{\"541\":1}}],[\"counter\",{\"1\":{\"541\":1,\"549\":1,\"983\":4,\"986\":2}}],[\"count变量\",{\"1\":{\"497\":1}}],[\"count的值\",{\"1\":{\"497\":1}}],[\"country\",{\"1\":{\"374\":1}}],[\"country=\",{\"1\":{\"280\":4}}],[\"county\",{\"1\":{\"265\":2,\"266\":1,\"271\":3,\"302\":2,\"303\":2,\"974\":7}}],[\"count\",{\"0\":{\"463\":1,\"497\":2},\"1\":{\"47\":2,\"265\":2,\"266\":1,\"271\":2,\"276\":3,\"302\":1,\"307\":3,\"310\":1,\"328\":1,\"349\":1,\"351\":11,\"353\":7,\"354\":5,\"355\":2,\"437\":2,\"481\":1,\"482\":6,\"493\":2,\"497\":2,\"592\":4,\"619\":1,\"668\":4,\"832\":3,\"834\":5,\"836\":9,\"843\":3,\"960\":3,\"985\":1,\"1132\":4,\"1137\":9,\"1151\":3,\"1157\":3,\"1164\":3,\"1168\":1,\"1176\":3,\"1180\":2}}],[\"correlation=true\",{\"1\":{\"453\":1}}],[\"corepoolsize\",{\"1\":{\"572\":3}}],[\"core<\",{\"1\":{\"104\":1,\"107\":2,\"112\":1,\"113\":1,\"957\":1,\"985\":1,\"1070\":2,\"1172\":2,\"1219\":1}}],[\"core\",{\"1\":{\"104\":1,\"110\":2,\"113\":2,\"726\":1,\"910\":2,\"927\":1,\"936\":3,\"1499\":1}}],[\"cookie等\",{\"1\":{\"1530\":1}}],[\"cookievalue\",{\"1\":{\"1362\":2}}],[\"cookie2\",{\"1\":{\"359\":2}}],[\"cookie1\",{\"1\":{\"352\":1,\"359\":2,\"363\":1}}],[\"cookieid\",{\"1\":{\"352\":1,\"353\":7,\"354\":5,\"355\":2,\"359\":2,\"360\":7,\"361\":4,\"363\":7,\"364\":5,\"365\":14}}],[\"cookie\",{\"1\":{\"352\":4,\"353\":7,\"354\":5,\"355\":2}}],[\"cookprocess\",{\"1\":{\"85\":3}}],[\"coalesce函数\",{\"1\":{\"351\":1}}],[\"coalesce\",{\"1\":{\"340\":5,\"351\":2}}],[\"cost\",{\"1\":{\"457\":1}}],[\"cos\",{\"1\":{\"197\":1}}],[\"coco目标检测数据集80个类别\",{\"0\":{\"147\":1}}],[\"col4\",{\"1\":{\"388\":2}}],[\"collect1\",{\"1\":{\"621\":2}}],[\"collectors\",{\"1\":{\"620\":1,\"621\":4,\"1162\":2,\"1165\":2,\"1171\":1}}],[\"collect\",{\"1\":{\"383\":2,\"385\":1,\"620\":1,\"621\":6,\"1162\":2,\"1165\":2,\"1171\":1}}],[\"collectionutils\",{\"1\":{\"1232\":1}}],[\"collectionutil\",{\"1\":{\"1165\":1,\"1176\":1}}],[\"collections\",{\"1\":{\"614\":1,\"1024\":1,\"1147\":1,\"1156\":1,\"1157\":1,\"1162\":1,\"1172\":2,\"1449\":1,\"1451\":1}}],[\"collection接口是抽象工厂类\",{\"1\":{\"43\":1}}],[\"collection\",{\"0\":{\"43\":1},\"1\":{\"252\":1,\"256\":1,\"290\":1,\"339\":1,\"348\":1,\"602\":1,\"1482\":1,\"1489\":2}}],[\"colname表示基于什么抽\",{\"1\":{\"369\":1}}],[\"colname\",{\"1\":{\"369\":1,\"399\":2,\"450\":3}}],[\"col3=2\",{\"1\":{\"285\":1}}],[\"col3=1\",{\"1\":{\"285\":1}}],[\"col3\",{\"1\":{\"285\":1,\"382\":4,\"385\":3,\"388\":5,\"391\":5}}],[\"col2row2\",{\"1\":{\"391\":2}}],[\"col2row1\",{\"1\":{\"388\":4}}],[\"col2\",{\"1\":{\"285\":1,\"351\":2,\"382\":4,\"385\":3,\"388\":5,\"391\":2,\"482\":1}}],[\"col1\",{\"1\":{\"285\":1,\"351\":3,\"382\":4,\"385\":3,\"388\":4,\"391\":2,\"422\":1,\"482\":1}}],[\"column是分步查询的条件\",{\"1\":{\"1230\":1}}],[\"column=\",{\"1\":{\"1230\":7}}],[\"columnname\",{\"1\":{\"395\":1,\"437\":1}}],[\"columns\",{\"1\":{\"279\":3,\"437\":2,\"458\":1}}],[\"column\",{\"1\":{\"279\":7,\"351\":1,\"457\":1}}],[\"col\",{\"1\":{\"264\":5,\"279\":1,\"300\":5,\"313\":1,\"365\":2,\"482\":3}}],[\"colab\",{\"1\":{\"133\":1}}],[\"color=\",{\"1\":{\"1083\":1}}],[\"colorado\",{\"1\":{\"973\":1}}],[\"colormind\",{\"1\":{\"132\":1}}],[\"colorizer\",{\"1\":{\"125\":1}}],[\"com组合起来被称为一个域林\",{\"1\":{\"923\":1}}],[\"com也是一个单独的域树\",{\"1\":{\"923\":1}}],[\"combiner会优化mapreduce的中间结果\",{\"1\":{\"979\":1}}],[\"combiner组件不是禁用\",{\"1\":{\"970\":1}}],[\"combiner组件的使用\",{\"0\":{\"970\":1}}],[\"combiner的输出kv应该跟reducer的输入kv类型要对应起来\",{\"1\":{\"970\":1}}],[\"combiner的作用就是对map端的输出先做一次局部合并\",{\"1\":{\"969\":1}}],[\"combiner能够应用的前提是不能影响最终的业务逻辑\",{\"1\":{\"970\":1}}],[\"combiner默认不开启\",{\"1\":{\"970\":1}}],[\"combiner规约\",{\"0\":{\"969\":1}}],[\"combinedchannelduplexhandler\",{\"1\":{\"714\":1}}],[\"combinehiveinputformat\",{\"1\":{\"436\":1}}],[\"commit\",{\"1\":{\"1024\":2}}],[\"commit所释放的资源\",{\"1\":{\"499\":1}}],[\"commit和rollback\",{\"1\":{\"267\":1,\"296\":1}}],[\"comments\",{\"1\":{\"1159\":1}}],[\"comment\",{\"1\":{\"256\":4,\"265\":6,\"266\":6,\"271\":1,\"278\":1,\"279\":4,\"1164\":4,\"1174\":6}}],[\"commandlinerunner\",{\"1\":{\"1446\":1}}],[\"commands\",{\"1\":{\"1204\":1}}],[\"commandexecutor\",{\"1\":{\"1152\":3}}],[\"command\",{\"1\":{\"232\":1,\"702\":2,\"1205\":1}}],[\"commonannotationbeanpostprocessor\",{\"1\":{\"1264\":1}}],[\"commonds\",{\"1\":{\"1199\":1}}],[\"commonfollow\",{\"1\":{\"1165\":1}}],[\"common<\",{\"1\":{\"344\":1,\"957\":1}}],[\"commontableexpression\",{\"1\":{\"300\":2}}],[\"commons<\",{\"1\":{\"1022\":1,\"1219\":1}}],[\"commons\",{\"1\":{\"110\":1,\"112\":3}}],[\"common\",{\"0\":{\"113\":1,\"318\":1},\"1\":{\"110\":2,\"318\":1,\"1023\":2,\"1024\":2,\"1219\":1}}],[\"come\",{\"1\":{\"167\":1}}],[\"component注解替代\",{\"1\":{\"1525\":1}}],[\"component注解修饰的bean\",{\"1\":{\"1525\":1}}],[\"component注解的自定义性更强\",{\"1\":{\"1507\":1}}],[\"component注解作用于类\",{\"1\":{\"1507\":1}}],[\"component和\",{\"0\":{\"1507\":1}}],[\"component用于声明通用的bean\",{\"1\":{\"1503\":1}}],[\"components\",{\"1\":{\"1476\":2}}],[\"componentscan注解的集合\",{\"1\":{\"1525\":1}}],[\"componentscanpostprocessor\",{\"1\":{\"1273\":1}}],[\"componentscan\",{\"0\":{\"1272\":1},\"1\":{\"1248\":1,\"1270\":1,\"1271\":1,\"1503\":1,\"1507\":1,\"1525\":1}}],[\"component\",{\"1\":{\"779\":2,\"1129\":1,\"1132\":1,\"1294\":3,\"1476\":2,\"1489\":1,\"1503\":1,\"1505\":1,\"1525\":1}}],[\"compositebuffer\",{\"1\":{\"779\":1}}],[\"compositebytebuf\",{\"0\":{\"779\":1},\"1\":{\"779\":2,\"780\":2,\"781\":1}}],[\"completionhandler<asynchronoussocketchannel\",{\"1\":{\"859\":1}}],[\"completionhandler<integer\",{\"1\":{\"857\":1,\"859\":2}}],[\"completed\",{\"1\":{\"699\":1,\"857\":3,\"859\":3}}],[\"complete\",{\"1\":{\"692\":1,\"693\":2,\"697\":1,\"698\":1,\"744\":2,\"748\":6}}],[\"complex\",{\"1\":{\"248\":1}}],[\"compute\",{\"1\":{\"457\":1,\"458\":2}}],[\"computer\",{\"0\":{\"1543\":1},\"1\":{\"6\":6,\"7\":5,\"74\":11}}],[\"compress=true\",{\"1\":{\"433\":2}}],[\"compress\",{\"1\":{\"433\":7}}],[\"comparingdouble\",{\"1\":{\"621\":1}}],[\"comparingint\",{\"1\":{\"618\":1,\"619\":1}}],[\"compareandswapint\",{\"1\":{\"1135\":1}}],[\"compareandset\",{\"1\":{\"741\":1,\"742\":2}}],[\"compare\",{\"1\":{\"614\":1,\"621\":1,\"974\":2}}],[\"compareto\",{\"1\":{\"614\":1,\"974\":3}}],[\"comparator\",{\"1\":{\"618\":2,\"619\":1,\"621\":1}}],[\"comparator接口出自java\",{\"1\":{\"603\":1}}],[\"comparable<t>\",{\"1\":{\"956\":1}}],[\"comparable接口出自java\",{\"1\":{\"603\":1}}],[\"comparable和comparator的区别\",{\"0\":{\"603\":1}}],[\"compact\",{\"1\":{\"423\":1,\"797\":1,\"798\":1,\"809\":1,\"840\":1}}],[\"compaction\",{\"1\":{\"294\":2,\"1056\":1}}],[\"compactor\",{\"1\":{\"268\":2,\"276\":2,\"297\":2,\"298\":2}}],[\"companyname\",{\"1\":{\"98\":3}}],[\"company\",{\"1\":{\"76\":10}}],[\"compiletime=true\",{\"1\":{\"470\":1}}],[\"compile\",{\"1\":{\"95\":1,\"100\":1,\"104\":1,\"344\":1,\"1300\":1}}],[\"compilerversion>\",{\"1\":{\"92\":1}}],[\"compilerversion>1\",{\"1\":{\"92\":1}}],[\"compiler\",{\"1\":{\"92\":6,\"102\":1,\"112\":4,\"113\":4,\"114\":4,\"115\":4,\"957\":1,\"1022\":1}}],[\"com\",{\"1\":{\"59\":4,\"92\":1,\"98\":1,\"99\":1,\"104\":2,\"112\":1,\"117\":2,\"118\":1,\"120\":2,\"121\":2,\"124\":1,\"125\":8,\"126\":2,\"127\":2,\"128\":3,\"131\":3,\"132\":2,\"133\":2,\"144\":3,\"145\":4,\"146\":4,\"197\":1,\"336\":1,\"344\":1,\"377\":6,\"562\":1,\"602\":1,\"618\":1,\"648\":1,\"649\":1,\"661\":1,\"664\":1,\"762\":2,\"765\":2,\"841\":1,\"878\":1,\"974\":1,\"985\":1,\"986\":1,\"991\":4,\"1046\":1,\"1088\":1,\"1089\":2,\"1146\":1,\"1200\":2,\"1230\":1,\"1232\":1,\"1236\":1,\"1242\":1,\"1247\":1,\"1250\":1,\"1254\":1,\"1259\":1,\"1263\":1,\"1266\":1,\"1270\":1,\"1273\":1,\"1276\":1,\"1279\":1,\"1283\":1,\"1288\":1,\"1292\":1,\"1294\":5,\"1296\":1,\"1312\":1,\"1316\":1,\"1320\":2,\"1324\":1,\"1328\":1,\"1354\":1,\"1357\":2,\"1361\":1,\"1365\":1,\"1372\":1,\"1375\":1,\"1378\":1,\"1389\":1,\"1393\":1,\"1397\":1,\"1401\":1,\"1405\":1,\"1409\":1,\"1445\":3,\"1466\":1,\"1471\":1,\"1475\":1,\"1479\":1,\"1484\":1,\"1488\":1,\"1492\":1,\"1496\":1,\"1525\":1}}],[\"coffe\",{\"1\":{\"30\":1}}],[\"coffee>\",{\"1\":{\"42\":1}}],[\"coffeefactory\",{\"1\":{\"34\":5,\"42\":2}}],[\"coffeestore对象和simplecoffeefactory工厂对象的耦合\",{\"1\":{\"28\":1}}],[\"coffeestore类中的ordercoffee\",{\"1\":{\"28\":1}}],[\"coffeestore\",{\"1\":{\"25\":1,\"34\":2}}],[\"coffee\",{\"1\":{\"25\":1,\"28\":6,\"30\":5,\"34\":12,\"39\":3,\"42\":3}}],[\"conditiaononmissingbean\",{\"1\":{\"1525\":1}}],[\"conditioncontext\",{\"1\":{\"1466\":1}}],[\"condition典型的运用场景是在blockingqueue中的实现\",{\"1\":{\"584\":1}}],[\"conditionobject中也维护了一个队列\",{\"1\":{\"584\":1}}],[\"condition队列\",{\"0\":{\"584\":1}}],[\"condition1\",{\"1\":{\"554\":3}}],[\"condition为false报错\",{\"1\":{\"340\":1}}],[\"condition\",{\"1\":{\"300\":1,\"340\":3,\"495\":1,\"554\":1,\"555\":6,\"1466\":3}}],[\"conditionalonbean\",{\"1\":{\"1525\":1}}],[\"conditional衍生注解\",{\"1\":{\"1525\":1}}],[\"conditional注解是由spring\",{\"1\":{\"1525\":1}}],[\"conditional指定的生效条件\",{\"1\":{\"1524\":1}}],[\"conditional\",{\"1\":{\"130\":1,\"1466\":3,\"1525\":1}}],[\"cond\",{\"1\":{\"549\":1}}],[\"converters\",{\"1\":{\"1368\":1}}],[\"converter\",{\"1\":{\"1368\":2}}],[\"convert\",{\"1\":{\"448\":2,\"450\":2}}],[\"conversionservice\",{\"1\":{\"1370\":1,\"1376\":3}}],[\"conversionpattern=\",{\"1\":{\"1022\":1}}],[\"conversion\",{\"1\":{\"341\":1,\"799\":2}}],[\"conv\",{\"1\":{\"338\":3}}],[\"conneted\",{\"1\":{\"696\":1}}],[\"connetted\",{\"1\":{\"692\":1,\"697\":2,\"698\":2,\"699\":2}}],[\"connector\",{\"1\":{\"957\":1,\"985\":1,\"1449\":5}}],[\"connecting\",{\"1\":{\"726\":5,\"826\":1}}],[\"connectionfactory\",{\"1\":{\"1222\":2}}],[\"connection\",{\"1\":{\"321\":2,\"322\":2,\"725\":1}}],[\"connectpromise\",{\"1\":{\"725\":4}}],[\"connecttimeoutexception\",{\"1\":{\"725\":2}}],[\"connecttimeoutfuture\",{\"1\":{\"725\":1}}],[\"connecttimeoutmillis\",{\"1\":{\"725\":3}}],[\"connect\",{\"0\":{\"725\":1},\"1\":{\"692\":1,\"696\":1,\"697\":2,\"698\":2,\"699\":2,\"702\":1,\"710\":1,\"725\":5,\"726\":2,\"733\":1,\"735\":1,\"737\":1,\"742\":2,\"748\":1,\"753\":5,\"754\":1,\"766\":1,\"785\":3,\"794\":1,\"826\":1,\"831\":1,\"840\":1,\"843\":2,\"992\":1}}],[\"connected\",{\"1\":{\"692\":2,\"693\":1,\"697\":1,\"698\":1,\"699\":1,\"726\":2,\"826\":1,\"827\":1,\"836\":2,\"846\":1,\"859\":1}}],[\"conn\",{\"1\":{\"321\":8,\"322\":8}}],[\"concurrentmapcache\",{\"1\":{\"1432\":1}}],[\"concurrentlinkedqueue<>\",{\"1\":{\"846\":1}}],[\"concurrentlinkedqueue<runnable>\",{\"1\":{\"846\":1}}],[\"concurrent\",{\"1\":{\"638\":1,\"639\":1,\"741\":2,\"756\":1,\"762\":4,\"765\":14}}],[\"concurrenthashmap<k\",{\"1\":{\"1113\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"733\":1,\"738\":1,\"1113\":1}}],[\"concurrenthashmap的线程安全是基于segment加锁的基础上\",{\"1\":{\"579\":1}}],[\"concurrenthashmap和hashmap都是基于数组和链表实现的\",{\"1\":{\"579\":1}}],[\"concurrenthashmap\",{\"0\":{\"579\":1},\"1\":{\"579\":1}}],[\"concurrent包提供的方法\",{\"1\":{\"578\":1}}],[\"concurrencylevel\",{\"1\":{\"579\":4}}],[\"concurrency\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"concat\",{\"1\":{\"336\":6,\"383\":1,\"385\":1,\"1230\":1}}],[\"concatenate\",{\"1\":{\"258\":1}}],[\"concreteclass\",{\"1\":{\"85\":6}}],[\"concretestrategy角色负责实现strategy角色的接口\",{\"1\":{\"80\":1}}],[\"concretestrategy\",{\"1\":{\"80\":1}}],[\"concretesubject角色表示具体的被观察对象\",{\"1\":{\"46\":1}}],[\"concretesubject\",{\"1\":{\"46\":1,\"47\":1}}],[\"concreteobserver角色表示具体的observer\",{\"1\":{\"46\":1}}],[\"concreteobserver\",{\"1\":{\"46\":1,\"47\":2}}],[\"concrete\",{\"1\":{\"38\":1,\"84\":2}}],[\"concreteproduct\",{\"1\":{\"33\":1,\"38\":1}}],[\"concretefactory\",{\"1\":{\"33\":1}}],[\"concretebuilder\",{\"1\":{\"13\":1}}],[\"consumer的速率\",{\"1\":{\"1056\":1}}],[\"consumer1\",{\"1\":{\"1042\":4}}],[\"consumer0\",{\"1\":{\"1042\":4}}],[\"consumer2\",{\"1\":{\"1042\":2}}],[\"consumerrecords<string\",{\"1\":{\"1024\":1}}],[\"consumer\",{\"1\":{\"1017\":1,\"1024\":3,\"1026\":3,\"1037\":5,\"1038\":3,\"1040\":1,\"1041\":1}}],[\"consumer<\",{\"1\":{\"614\":1}}],[\"consoleappender\",{\"1\":{\"1022\":1}}],[\"console\",{\"1\":{\"1016\":1,\"1017\":1}}],[\"const\",{\"1\":{\"646\":1,\"662\":1}}],[\"consts\",{\"1\":{\"481\":1}}],[\"constructor的newinstance\",{\"1\":{\"629\":1}}],[\"constructor\",{\"1\":{\"68\":5}}],[\"construct\",{\"1\":{\"14\":3}}],[\"consistency自监督损失函数\",{\"1\":{\"117\":1}}],[\"consistent\",{\"1\":{\"117\":1}}],[\"conf文件中的一些配置\",{\"1\":{\"1196\":1}}],[\"conf文件\",{\"1\":{\"1138\":1}}],[\"conf目录中有一个名为user\",{\"1\":{\"875\":1}}],[\"confirmshutdown\",{\"1\":{\"741\":1}}],[\"configs\",{\"1\":{\"1035\":1}}],[\"configurablewebbindinginitializer\",{\"1\":{\"1376\":1}}],[\"configuration注解声明配置类更加语义化\",{\"1\":{\"1525\":1}}],[\"configuration的不同语义的版本\",{\"1\":{\"1525\":1}}],[\"configurationpropertysources\",{\"1\":{\"1444\":1,\"1446\":1}}],[\"configurationproperties读取配置信息并于bean绑定\",{\"1\":{\"1525\":1}}],[\"configurationpropertiesbindingpostprocessor\",{\"1\":{\"1264\":1}}],[\"configurationproperties\",{\"1\":{\"1088\":1,\"1254\":1,\"1264\":1,\"1505\":1,\"1525\":2}}],[\"configurationclasspostprocessor\",{\"1\":{\"1270\":1}}],[\"configuration\",{\"1\":{\"775\":1,\"962\":4,\"972\":2,\"973\":2,\"974\":2,\"985\":2,\"986\":2,\"988\":2,\"991\":2,\"1023\":1,\"1088\":1,\"1100\":1,\"1150\":1,\"1222\":1,\"1230\":2,\"1232\":1,\"1285\":1,\"1464\":3,\"1466\":1,\"1525\":1}}],[\"configuration>\",{\"1\":{\"102\":2,\"344\":1,\"936\":1,\"957\":2,\"1022\":1,\"1219\":1}}],[\"configuredb\",{\"1\":{\"985\":1,\"986\":1}}],[\"configured\",{\"1\":{\"962\":1,\"988\":1}}],[\"configure\",{\"1\":{\"876\":1,\"968\":1,\"1035\":1}}],[\"configureblocking\",{\"1\":{\"740\":1,\"743\":1,\"827\":2,\"831\":1,\"834\":1,\"836\":2,\"840\":2,\"843\":3,\"846\":2}}],[\"config\",{\"1\":{\"42\":2,\"480\":2,\"723\":4,\"725\":1,\"733\":1,\"740\":7,\"743\":5,\"744\":7,\"1012\":3,\"1013\":1,\"1035\":1,\"1045\":1,\"1046\":2,\"1150\":5,\"1464\":1}}],[\"conf\",{\"1\":{\"92\":2,\"254\":1,\"962\":4,\"963\":2,\"972\":3,\"973\":3,\"974\":3,\"985\":3,\"986\":3,\"988\":3,\"991\":5,\"1046\":2,\"1196\":4,\"1197\":1}}],[\"container中启动应用程序的\",{\"1\":{\"953\":1}}],[\"containermanagementprotocol\",{\"1\":{\"949\":1}}],[\"container表示的\",{\"1\":{\"948\":1}}],[\"container容器\",{\"0\":{\"948\":1}}],[\"container启动\",{\"1\":{\"946\":1}}],[\"container\",{\"1\":{\"942\":1,\"946\":1,\"947\":1,\"948\":4,\"949\":3}}],[\"containskey\",{\"1\":{\"671\":1}}],[\"contains\",{\"1\":{\"69\":1,\"339\":4,\"988\":1}}],[\"controlledjob\",{\"1\":{\"991\":4}}],[\"controlledjob类\",{\"1\":{\"991\":1}}],[\"controller执行完成后返回modelandview\",{\"1\":{\"1530\":1}}],[\"controller代表的是数据的处理逻辑\",{\"1\":{\"1528\":1}}],[\"controller中进行测试\",{\"1\":{\"1526\":1}}],[\"controller和\",{\"1\":{\"1525\":1}}],[\"controller用于声明视图层的控制器bean\",{\"1\":{\"1503\":1}}],[\"controller用于类上声明bean\",{\"1\":{\"1503\":1}}],[\"controller3\",{\"1\":{\"1420\":1}}],[\"controlleradvice开启全局异常处理\",{\"1\":{\"1526\":1}}],[\"controlleradvice\",{\"0\":{\"1380\":1,\"1387\":1,\"1399\":1,\"1407\":1},\"1\":{\"1382\":2,\"1390\":2,\"1410\":1,\"1438\":5,\"1526\":1}}],[\"controller是高可用的\",{\"1\":{\"1050\":1}}],[\"controller是kafka集群的老大\",{\"1\":{\"1050\":1}}],[\"controller\",{\"0\":{\"885\":1},\"1\":{\"1050\":1,\"1384\":2,\"1411\":1,\"1420\":1,\"1421\":1,\"1437\":1,\"1441\":1,\"1447\":1,\"1528\":1,\"1530\":1}}],[\"control\",{\"1\":{\"925\":1}}],[\"continuereading\",{\"1\":{\"743\":1,\"744\":3}}],[\"continue\",{\"1\":{\"741\":3,\"834\":1,\"836\":1}}],[\"content\",{\"1\":{\"92\":1,\"702\":2,\"711\":2}}],[\"contextannotationautowirecandidateresolver\",{\"1\":{\"1264\":1,\"1485\":1,\"1489\":2}}],[\"context会依赖传递core\",{\"1\":{\"112\":1}}],[\"context<\",{\"1\":{\"107\":2,\"112\":1,\"113\":1}}],[\"context角色保存了concretestrategy角色的实例\",{\"1\":{\"80\":1}}],[\"context\",{\"1\":{\"80\":1,\"110\":2,\"113\":1,\"373\":3,\"740\":1,\"958\":3,\"960\":3,\"972\":6,\"973\":6,\"974\":6,\"983\":4,\"985\":3,\"986\":8,\"988\":15,\"990\":5,\"1244\":6,\"1294\":1,\"1429\":2,\"1435\":3,\"1444\":1,\"1449\":4,\"1451\":1,\"1466\":1,\"1473\":1}}],[\"cst\",{\"1\":{\"726\":4}}],[\"csdn博客\",{\"1\":{\"602\":1}}],[\"csdn\",{\"1\":{\"145\":4,\"543\":1,\"544\":1,\"545\":1,\"549\":1}}],[\"cs\",{\"1\":{\"9\":1,\"119\":1}}],[\"cluter\",{\"1\":{\"992\":1}}],[\"cluster2\",{\"1\":{\"1046\":1}}],[\"cluster1\",{\"1\":{\"1046\":1}}],[\"cluster默认会对key使用crc16算法进行hash得到一个整数值\",{\"1\":{\"528\":1}}],[\"cluster的客户端来连接集群时\",{\"1\":{\"528\":1}}],[\"cluster将所有数据划分为16384个槽位\",{\"1\":{\"528\":1}}],[\"cluster架构下\",{\"1\":{\"527\":1}}],[\"clusterd\",{\"1\":{\"450\":1}}],[\"cluster\",{\"0\":{\"313\":1,\"314\":1},\"1\":{\"300\":1,\"313\":1,\"314\":1,\"315\":3,\"1035\":4,\"1046\":1}}],[\"clustered\",{\"1\":{\"264\":2,\"265\":1,\"268\":1,\"276\":1}}],[\"clearreadpending\",{\"1\":{\"744\":1}}],[\"clear\",{\"1\":{\"743\":1,\"796\":1,\"797\":1,\"798\":1,\"826\":1,\"827\":1,\"843\":1,\"859\":1,\"988\":2}}],[\"clean\",{\"1\":{\"95\":1}}],[\"cli连接redis服务\",{\"1\":{\"1202\":1}}],[\"cli的交互控制台\",{\"1\":{\"1199\":1}}],[\"cli来执行\",{\"1\":{\"1196\":1}}],[\"cli\",{\"1\":{\"232\":2,\"1193\":1,\"1196\":1,\"1199\":2}}],[\"client<\",{\"1\":{\"957\":1,\"1070\":2}}],[\"client用dek加密文件内容发送给datanode进行存储\",{\"1\":{\"934\":1}}],[\"client发送edek给kms\",{\"1\":{\"934\":1}}],[\"client向nn请求在hdfs某个加密区新建文件\",{\"1\":{\"934\":1}}],[\"clients<\",{\"1\":{\"1022\":1,\"1213\":1}}],[\"clients\",{\"1\":{\"789\":1,\"1040\":1,\"1041\":1,\"1212\":1}}],[\"client端\",{\"1\":{\"297\":1}}],[\"client\",{\"1\":{\"6\":1,\"7\":1,\"14\":1,\"17\":2,\"58\":1,\"59\":2,\"60\":1,\"73\":1,\"85\":1,\"692\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"726\":5,\"733\":1,\"735\":1,\"737\":1,\"794\":1,\"834\":1,\"839\":1,\"848\":1,\"872\":2,\"942\":1,\"957\":1,\"985\":1,\"1072\":6,\"1073\":8,\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2,\"1309\":1}}],[\"cloud\",{\"1\":{\"336\":1}}],[\"clock\",{\"1\":{\"191\":2}}],[\"closechannel\",{\"1\":{\"859\":4}}],[\"closeonread\",{\"1\":{\"744\":1}}],[\"closeonreaderror\",{\"1\":{\"743\":1}}],[\"closed\",{\"1\":{\"743\":4}}],[\"closeall\",{\"1\":{\"741\":1}}],[\"closeable\",{\"1\":{\"88\":1}}],[\"closeifclosed\",{\"1\":{\"740\":1}}],[\"closeforcibly\",{\"1\":{\"740\":2,\"743\":2}}],[\"closefutureclient\",{\"1\":{\"754\":1}}],[\"closefuture\",{\"0\":{\"754\":1},\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"725\":1,\"733\":2,\"735\":1,\"737\":1,\"740\":2,\"743\":2,\"752\":1,\"754\":5,\"794\":1}}],[\"close\",{\"1\":{\"54\":1,\"696\":1,\"702\":2,\"707\":1,\"717\":1,\"718\":1,\"725\":1,\"740\":2,\"742\":1,\"743\":1,\"744\":5,\"752\":1,\"754\":2,\"794\":1,\"816\":2,\"833\":1,\"836\":1,\"839\":1,\"846\":2,\"859\":2,\"1035\":1,\"1071\":4,\"1072\":3,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1213\":1,\"1216\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"51\":2,\"52\":2,\"54\":2}}],[\"cloneable\",{\"1\":{\"51\":2,\"52\":1,\"54\":1}}],[\"clone\",{\"1\":{\"50\":3,\"51\":4,\"52\":3,\"54\":3}}],[\"clause\",{\"1\":{\"369\":1}}],[\"clazz\",{\"1\":{\"42\":2,\"68\":2,\"723\":4}}],[\"classutils\",{\"1\":{\"1466\":1}}],[\"classmetadata\",{\"1\":{\"1274\":1}}],[\"class文件\",{\"1\":{\"630\":1}}],[\"class的newinstance\",{\"1\":{\"629\":1}}],[\"classes根目录下\",{\"1\":{\"102\":1}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"1245\":1}}],[\"classpathresource\",{\"1\":{\"1147\":1,\"1156\":1,\"1429\":2,\"1432\":1}}],[\"classpathprefix>\",{\"1\":{\"957\":1}}],[\"classpath\",{\"1\":{\"100\":7,\"1435\":1}}],[\"classnotfoundexception\",{\"1\":{\"59\":3,\"69\":1,\"723\":1,\"733\":1}}],[\"classname\",{\"1\":{\"42\":2}}],[\"class<r>\",{\"1\":{\"1129\":3}}],[\"class<t>\",{\"1\":{\"723\":3,\"733\":1,\"737\":1}}],[\"class<\",{\"1\":{\"59\":1,\"723\":3,\"733\":4,\"737\":1,\"1505\":1,\"1525\":1}}],[\"classloader\",{\"1\":{\"59\":1,\"737\":1}}],[\"class\",{\"0\":{\"1516\":1},\"1\":{\"6\":5,\"7\":2,\"14\":7,\"17\":5,\"22\":5,\"23\":4,\"28\":1,\"30\":1,\"34\":5,\"39\":2,\"42\":4,\"43\":1,\"47\":5,\"51\":2,\"52\":2,\"54\":4,\"58\":3,\"59\":18,\"60\":3,\"66\":10,\"68\":8,\"69\":4,\"70\":4,\"73\":4,\"74\":6,\"75\":2,\"76\":4,\"81\":5,\"84\":2,\"85\":4,\"88\":1,\"279\":1,\"343\":2,\"344\":1,\"373\":1,\"536\":2,\"554\":3,\"555\":3,\"565\":1,\"567\":1,\"579\":5,\"614\":1,\"617\":1,\"624\":1,\"645\":1,\"648\":2,\"649\":2,\"668\":2,\"671\":1,\"673\":1,\"692\":6,\"696\":3,\"697\":3,\"698\":3,\"699\":3,\"702\":4,\"703\":2,\"704\":5,\"705\":1,\"710\":1,\"711\":1,\"713\":1,\"714\":1,\"717\":1,\"718\":2,\"723\":21,\"725\":2,\"726\":3,\"733\":15,\"734\":2,\"735\":5,\"736\":1,\"737\":4,\"738\":1,\"748\":3,\"753\":4,\"754\":2,\"766\":4,\"776\":1,\"780\":1,\"784\":1,\"785\":1,\"794\":2,\"795\":2,\"796\":1,\"799\":1,\"805\":1,\"820\":1,\"834\":2,\"836\":1,\"839\":2,\"843\":2,\"846\":3,\"848\":2,\"857\":1,\"859\":4,\"958\":1,\"960\":1,\"962\":18,\"968\":1,\"970\":1,\"972\":12,\"973\":12,\"974\":15,\"985\":11,\"986\":14,\"988\":13,\"990\":1,\"991\":17,\"999\":1,\"1023\":1,\"1035\":3,\"1071\":2,\"1073\":1,\"1088\":1,\"1089\":3,\"1100\":2,\"1101\":2,\"1107\":1,\"1111\":2,\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":3,\"1129\":4,\"1132\":1,\"1147\":1,\"1150\":1,\"1156\":1,\"1157\":1,\"1159\":2,\"1162\":1,\"1165\":2,\"1168\":1,\"1215\":1,\"1221\":1,\"1222\":1,\"1223\":2,\"1224\":1,\"1230\":1,\"1232\":1,\"1236\":3,\"1244\":2,\"1257\":2,\"1285\":2,\"1290\":1,\"1294\":7,\"1297\":1,\"1298\":1,\"1300\":1,\"1302\":1,\"1304\":5,\"1306\":3,\"1309\":5,\"1317\":1,\"1429\":1,\"1441\":1,\"1451\":1,\"1454\":1,\"1464\":6,\"1466\":4,\"1476\":1,\"1505\":1,\"1516\":1,\"1525\":5,\"1526\":2}}],[\"=f\",{\"1\":{\"1002\":1}}],[\"=69\",{\"1\":{\"998\":1}}],[\"=max\",{\"1\":{\"649\":1}}],[\"=e\",{\"1\":{\"320\":3,\"321\":2,\"322\":2,\"323\":2,\"324\":2}}],[\"=1k个键值\",{\"1\":{\"487\":1}}],[\"=100值有900条\",{\"1\":{\"455\":1}}],[\"=1\",{\"1\":{\"298\":1,\"1135\":1}}],[\"=pdata\",{\"1\":{\"122\":1}}],[\"=>\",{\"1\":{\"73\":1,\"784\":1,\"785\":1,\"792\":2}}],[\"=new\",{\"1\":{\"60\":1,\"1157\":1}}],[\"========================\",{\"1\":{\"776\":1,\"1024\":1}}],[\"==================================\",{\"1\":{\"702\":2}}],[\"==比较的是两个引用是否指向同一个对象地址\",{\"1\":{\"597\":1}}],[\"==比较的是值是否相等\",{\"1\":{\"597\":1}}],[\"==与equals的区别\",{\"0\":{\"597\":1}}],[\"==\",{\"1\":{\"6\":1,\"22\":4,\"23\":1,\"51\":1,\"54\":2,\"66\":6,\"68\":2,\"69\":1,\"81\":4,\"88\":4,\"344\":1,\"496\":2,\"566\":2,\"574\":1,\"579\":14,\"588\":1,\"614\":1,\"668\":10,\"669\":1,\"671\":1,\"704\":1,\"707\":2,\"723\":2,\"740\":1,\"741\":3,\"742\":2,\"743\":2,\"768\":1,\"796\":1,\"799\":1,\"809\":1,\"836\":1,\"839\":1,\"840\":3,\"846\":1,\"859\":1,\"976\":1,\"999\":2,\"1025\":1,\"1099\":2,\"1100\":1,\"1107\":2,\"1111\":1,\"1122\":1,\"1129\":2,\"1135\":1,\"1146\":1,\"1151\":3,\"1152\":5,\"1156\":2,\"1157\":1,\"1160\":1,\"1161\":1,\"1162\":3,\"1165\":1,\"1168\":3,\"1172\":3,\"1176\":3,\"1180\":1}}],[\"=\",{\"0\":{\"1516\":1},\"1\":{\"6\":5,\"7\":5,\"14\":7,\"17\":18,\"22\":4,\"28\":3,\"30\":3,\"34\":2,\"42\":7,\"43\":3,\"47\":10,\"51\":2,\"52\":3,\"54\":15,\"58\":2,\"59\":16,\"60\":5,\"66\":7,\"68\":14,\"69\":10,\"70\":6,\"73\":3,\"74\":8,\"76\":3,\"81\":32,\"85\":2,\"88\":5,\"154\":2,\"166\":5,\"167\":1,\"169\":1,\"179\":5,\"184\":2,\"188\":1,\"191\":2,\"198\":1,\"204\":2,\"261\":6,\"262\":6,\"268\":7,\"271\":1,\"272\":1,\"276\":7,\"278\":1,\"279\":4,\"280\":3,\"289\":2,\"297\":6,\"298\":9,\"302\":1,\"307\":3,\"310\":1,\"313\":1,\"317\":1,\"318\":8,\"326\":13,\"332\":3,\"340\":3,\"344\":7,\"351\":3,\"363\":1,\"364\":1,\"373\":4,\"374\":2,\"399\":2,\"400\":2,\"409\":1,\"422\":1,\"433\":1,\"437\":6,\"438\":2,\"444\":1,\"450\":6,\"455\":3,\"483\":1,\"491\":1,\"495\":1,\"496\":1,\"528\":1,\"536\":2,\"541\":2,\"551\":2,\"554\":13,\"555\":34,\"562\":21,\"565\":2,\"566\":1,\"567\":1,\"572\":1,\"579\":45,\"585\":3,\"590\":7,\"591\":1,\"592\":1,\"593\":6,\"599\":2,\"606\":1,\"614\":3,\"615\":1,\"617\":4,\"619\":2,\"620\":4,\"621\":5,\"637\":1,\"645\":12,\"646\":6,\"648\":27,\"649\":17,\"658\":2,\"668\":14,\"669\":17,\"671\":10,\"673\":6,\"692\":13,\"693\":2,\"694\":2,\"696\":6,\"697\":11,\"698\":9,\"699\":10,\"702\":26,\"703\":8,\"704\":11,\"707\":2,\"710\":7,\"711\":6,\"713\":17,\"714\":13,\"717\":3,\"718\":6,\"719\":1,\"723\":42,\"725\":8,\"726\":4,\"733\":28,\"734\":4,\"735\":8,\"737\":17,\"738\":6,\"740\":36,\"741\":10,\"742\":23,\"743\":25,\"744\":12,\"746\":2,\"748\":8,\"749\":2,\"750\":1,\"751\":1,\"753\":4,\"754\":5,\"755\":1,\"757\":2,\"758\":3,\"759\":3,\"760\":2,\"761\":2,\"762\":3,\"763\":3,\"764\":3,\"765\":2,\"766\":5,\"768\":4,\"769\":2,\"775\":1,\"776\":5,\"779\":4,\"780\":4,\"794\":7,\"795\":9,\"796\":4,\"799\":44,\"801\":2,\"802\":1,\"803\":2,\"805\":3,\"807\":5,\"808\":4,\"809\":4,\"814\":1,\"815\":1,\"817\":2,\"820\":11,\"821\":5,\"822\":15,\"823\":5,\"826\":5,\"827\":6,\"830\":1,\"831\":1,\"832\":3,\"834\":10,\"836\":12,\"839\":6,\"840\":19,\"843\":19,\"846\":29,\"848\":5,\"854\":4,\"857\":2,\"859\":5,\"875\":1,\"958\":4,\"960\":2,\"962\":6,\"965\":1,\"972\":14,\"973\":9,\"974\":17,\"976\":3,\"979\":2,\"983\":3,\"985\":22,\"986\":7,\"988\":23,\"990\":9,\"991\":7,\"992\":2,\"999\":27,\"1018\":1,\"1023\":4,\"1024\":7,\"1025\":6,\"1035\":1,\"1040\":2,\"1043\":3,\"1049\":1,\"1071\":1,\"1072\":10,\"1073\":19,\"1075\":4,\"1076\":4,\"1077\":5,\"1078\":5,\"1079\":7,\"1080\":6,\"1081\":6,\"1082\":6,\"1083\":7,\"1084\":6,\"1085\":6,\"1088\":2,\"1089\":22,\"1099\":6,\"1100\":2,\"1101\":1,\"1107\":10,\"1111\":5,\"1113\":4,\"1122\":4,\"1124\":5,\"1127\":7,\"1128\":10,\"1129\":28,\"1132\":17,\"1133\":1,\"1134\":6,\"1135\":2,\"1136\":6,\"1137\":25,\"1142\":7,\"1144\":5,\"1146\":1,\"1147\":1,\"1150\":9,\"1151\":1,\"1152\":12,\"1156\":12,\"1157\":19,\"1159\":3,\"1160\":2,\"1161\":16,\"1162\":17,\"1164\":4,\"1165\":18,\"1167\":8,\"1168\":15,\"1171\":6,\"1172\":18,\"1175\":5,\"1176\":8,\"1177\":1,\"1180\":6,\"1213\":8,\"1215\":2,\"1216\":3,\"1221\":2,\"1222\":2,\"1223\":8,\"1224\":2,\"1230\":8,\"1232\":4,\"1234\":3,\"1235\":4,\"1244\":2,\"1257\":3,\"1285\":1,\"1290\":1,\"1294\":7,\"1297\":2,\"1304\":3,\"1306\":4,\"1309\":6,\"1317\":5,\"1325\":2,\"1416\":1,\"1429\":4,\"1432\":1,\"1435\":1,\"1449\":5,\"1451\":1,\"1525\":4,\"1526\":2,\"1531\":2}}],[\"iblogservice\",{\"1\":{\"1159\":1}}],[\"ibatis自带的queryforlist\",{\"1\":{\"483\":1}}],[\"ilock\",{\"1\":{\"1142\":1}}],[\"illegalaccessexception\",{\"1\":{\"733\":1,\"1309\":1}}],[\"illegalargumentexception\",{\"1\":{\"579\":1,\"592\":1,\"723\":1,\"999\":2}}],[\"ivoucherorderservice\",{\"1\":{\"1137\":2,\"1142\":2,\"1150\":2,\"1157\":1}}],[\"ignored\",{\"1\":{\"742\":1}}],[\"iiiiiii|\",{\"1\":{\"699\":1}}],[\"iiiiiii\",{\"1\":{\"698\":1}}],[\"i−1\",{\"1\":{\"648\":1,\"649\":2}}],[\"i是链表在table中的下标\",{\"1\":{\"579\":1}}],[\"iadd\",{\"1\":{\"560\":1}}],[\"ian\",{\"1\":{\"124\":1}}],[\"ix\",{\"1\":{\"510\":3}}],[\"icr\",{\"1\":{\"1132\":1}}],[\"iconst\",{\"1\":{\"560\":1}}],[\"icp\",{\"1\":{\"495\":1}}],[\"iccv\",{\"1\":{\"117\":1}}],[\"idgenerator\",{\"0\":{\"1555\":1}}],[\"id查询出role的完整信息\",{\"1\":{\"1230\":1}}],[\"id查询出user完整信息以及role\",{\"1\":{\"1230\":1}}],[\"id<0\",{\"1\":{\"1177\":1}}],[\"id`\",{\"1\":{\"1164\":2,\"1174\":1}}],[\"idstr\",{\"1\":{\"1162\":2,\"1168\":2,\"1172\":2}}],[\"ids\",{\"1\":{\"1162\":3,\"1165\":2,\"1168\":4,\"1172\":4,\"1230\":3}}],[\"id的组成部分\",{\"1\":{\"1131\":1}}],[\"id的规律性太明显\",{\"1\":{\"1131\":1}}],[\"id数据类型\",{\"1\":{\"1129\":2}}],[\"idea\",{\"1\":{\"1300\":1,\"1442\":1}}],[\"idempotence\",{\"1\":{\"1028\":2}}],[\"identity\",{\"1\":{\"620\":1,\"621\":1}}],[\"identifiers\",{\"1\":{\"302\":1}}],[\"id是一样的\",{\"1\":{\"1024\":1}}],[\"id是主键\",{\"1\":{\"482\":1}}],[\"idle\",{\"1\":{\"707\":4,\"1220\":2}}],[\"idlestateevent\",{\"1\":{\"707\":4}}],[\"idlestatehandler\",{\"1\":{\"707\":2}}],[\"idlestate\",{\"1\":{\"707\":4}}],[\"id更新\",{\"1\":{\"482\":1}}],[\"id则为外键\",{\"1\":{\"482\":1}}],[\"id构建了索引\",{\"1\":{\"455\":1}}],[\"id=\",{\"1\":{\"1230\":6}}],[\"id=0\",{\"1\":{\"1012\":1}}],[\"id=c\",{\"1\":{\"460\":1}}],[\"id=10086\",{\"1\":{\"377\":6}}],[\"id=b\",{\"1\":{\"325\":4,\"460\":1,\"481\":1}}],[\"id依然有出入\",{\"1\":{\"354\":1}}],[\"id与理论情况有点出入\",{\"1\":{\"353\":1}}],[\"id与理论上有点出入\",{\"1\":{\"353\":1}}],[\"id表示结果属于哪一个分组集合\",{\"1\":{\"352\":1}}],[\"idx即index\",{\"1\":{\"480\":1}}],[\"idx\",{\"1\":{\"336\":1,\"423\":5}}],[\"id\",{\"1\":{\"256\":2,\"260\":1,\"261\":1,\"262\":1,\"268\":2,\"278\":1,\"281\":1,\"293\":2,\"298\":4,\"320\":9,\"321\":6,\"322\":6,\"323\":6,\"324\":4,\"325\":4,\"329\":1,\"332\":3,\"339\":4,\"347\":1,\"353\":10,\"354\":6,\"355\":4,\"357\":2,\"374\":1,\"377\":1,\"378\":4,\"423\":5,\"452\":2,\"455\":2,\"460\":4,\"480\":1,\"481\":2,\"482\":1,\"493\":1,\"501\":1,\"692\":7,\"693\":9,\"697\":21,\"698\":17,\"699\":21,\"748\":18,\"753\":4,\"878\":1,\"997\":6,\"998\":6,\"999\":17,\"1000\":7,\"1012\":1,\"1024\":2,\"1025\":1,\"1029\":1,\"1073\":6,\"1089\":3,\"1116\":4,\"1122\":7,\"1124\":5,\"1127\":8,\"1128\":7,\"1129\":25,\"1132\":3,\"1134\":1,\"1135\":1,\"1136\":4,\"1137\":11,\"1142\":2,\"1144\":3,\"1147\":1,\"1155\":2,\"1156\":1,\"1157\":4,\"1160\":2,\"1161\":13,\"1162\":16,\"1164\":4,\"1165\":6,\"1167\":2,\"1168\":2,\"1171\":1,\"1172\":3,\"1177\":10,\"1186\":5,\"1207\":2,\"1230\":21}}],[\"id>\",{\"1\":{\"92\":2,\"1129\":3,\"1230\":6}}],[\"ipad2018\",{\"1\":{\"1089\":1}}],[\"ip3\",{\"1\":{\"1021\":1}}],[\"ip2\",{\"1\":{\"1021\":1}}],[\"ipv4\",{\"1\":{\"694\":1,\"726\":1}}],[\"ip地址\",{\"1\":{\"374\":1}}],[\"ip\",{\"1\":{\"374\":1,\"694\":3,\"709\":1,\"878\":1,\"1001\":1,\"1018\":1,\"1023\":1,\"1024\":1}}],[\"ipynb\",{\"1\":{\"133\":2}}],[\"ipconfig\",{\"1\":{\"70\":1}}],[\"img\",{\"1\":{\"197\":1,\"642\":1,\"656\":1,\"662\":3,\"663\":3,\"665\":2,\"666\":3,\"1429\":1,\"1437\":1}}],[\"imgflip\",{\"1\":{\"125\":1}}],[\"images\",{\"1\":{\"1089\":3,\"1429\":1}}],[\"image\",{\"1\":{\"117\":2,\"130\":2,\"135\":1,\"141\":1,\"142\":1,\"183\":1,\"188\":4,\"189\":2,\"190\":3,\"191\":5,\"192\":3,\"194\":4,\"195\":11,\"196\":11,\"197\":14,\"198\":13,\"199\":8,\"200\":4,\"201\":5,\"202\":2,\"203\":5,\"204\":7,\"205\":7,\"206\":3,\"207\":4,\"208\":4,\"209\":6,\"210\":6,\"211\":1,\"212\":7,\"213\":8,\"214\":13,\"348\":1,\"884\":1,\"885\":1,\"889\":1,\"1159\":5,\"1193\":1,\"1196\":1,\"1212\":1}}],[\"immediate\",{\"1\":{\"76\":1}}],[\"impala等轻松地与metastore集成\",{\"1\":{\"474\":1}}],[\"implementation\",{\"1\":{\"128\":1,\"579\":1}}],[\"implements\",{\"1\":{\"6\":3,\"7\":1,\"23\":3,\"34\":2,\"39\":2,\"47\":2,\"51\":1,\"52\":1,\"54\":1,\"58\":2,\"59\":4,\"60\":1,\"68\":1,\"69\":1,\"74\":3,\"75\":2,\"81\":2,\"88\":1,\"579\":1,\"718\":1,\"723\":2,\"726\":1,\"733\":1,\"846\":2,\"859\":3,\"962\":1,\"968\":1,\"972\":1,\"974\":1,\"985\":1,\"988\":1,\"1035\":1,\"1100\":2,\"1111\":2,\"1157\":1,\"1236\":1,\"1304\":1,\"1309\":2,\"1464\":1,\"1466\":1,\"1505\":1}}],[\"import注解导入的importselector来完成的\",{\"1\":{\"1525\":1}}],[\"importingclassmetadata\",{\"1\":{\"1464\":1}}],[\"importbeandefinitionregistrar\",{\"1\":{\"1455\":1}}],[\"importresource\",{\"1\":{\"1270\":1}}],[\"import\",{\"1\":{\"59\":5,\"100\":1,\"648\":2,\"999\":2,\"1270\":1,\"1464\":1,\"1465\":2,\"1525\":3}}],[\"i++是否线程安全\",{\"0\":{\"560\":1}}],[\"i++\",{\"1\":{\"47\":2,\"81\":2,\"88\":1,\"555\":6,\"560\":1,\"562\":1,\"593\":2,\"645\":3,\"646\":2,\"648\":5,\"649\":2,\"668\":3,\"669\":4,\"673\":1,\"692\":1,\"693\":1,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"795\":2,\"799\":6,\"809\":1,\"840\":1,\"843\":1,\"846\":1,\"988\":1,\"999\":2,\"1023\":1,\"1025\":1,\"1132\":2,\"1180\":1}}],[\"i\",{\"0\":{\"207\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"678\":1,\"679\":1},\"1\":{\"47\":4,\"81\":5,\"88\":4,\"158\":1,\"207\":2,\"208\":4,\"209\":8,\"211\":3,\"477\":1,\"496\":4,\"522\":1,\"555\":12,\"560\":2,\"562\":37,\"567\":1,\"576\":1,\"579\":5,\"593\":4,\"599\":2,\"609\":1,\"611\":1,\"645\":12,\"646\":11,\"648\":33,\"649\":22,\"668\":13,\"669\":16,\"673\":4,\"679\":2,\"692\":9,\"693\":11,\"696\":2,\"697\":25,\"698\":21,\"699\":25,\"717\":2,\"718\":2,\"743\":4,\"748\":30,\"750\":2,\"751\":5,\"759\":1,\"760\":4,\"761\":3,\"762\":3,\"763\":4,\"764\":3,\"776\":1,\"795\":6,\"796\":17,\"799\":30,\"803\":2,\"808\":1,\"809\":7,\"836\":6,\"840\":4,\"843\":2,\"846\":4,\"852\":1,\"857\":3,\"974\":3,\"988\":3,\"999\":4,\"1023\":4,\"1025\":3,\"1132\":4,\"1180\":4,\"1526\":1}}],[\"isfollow\",{\"1\":{\"1164\":9,\"1165\":2}}],[\"isfalse\",{\"1\":{\"1161\":1}}],[\"ismember\",{\"1\":{\"1161\":6}}],[\"islike\",{\"1\":{\"1161\":1}}],[\"islock\",{\"1\":{\"1128\":2,\"1129\":4,\"1142\":2,\"1150\":4,\"1157\":2}}],[\"isblogliked\",{\"1\":{\"1161\":3,\"1162\":1,\"1168\":1}}],[\"isblank\",{\"1\":{\"1111\":1,\"1128\":1,\"1129\":1}}],[\"isbefore\",{\"1\":{\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"istrue\",{\"1\":{\"1127\":1,\"1129\":1}}],[\"isempty\",{\"1\":{\"1111\":1,\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":1,\"1161\":1,\"1162\":1,\"1165\":1,\"1168\":1,\"1176\":1}}],[\"ispresent\",{\"1\":{\"1466\":1}}],[\"isprime\",{\"1\":{\"646\":7}}],[\"isphoneinvalid\",{\"1\":{\"1099\":2,\"1107\":1}}],[\"isr里面的follower开始同步数据\",{\"1\":{\"1051\":1}}],[\"isr\",{\"0\":{\"1049\":1},\"1\":{\"1049\":2}}],[\"isreadable\",{\"1\":{\"836\":1,\"840\":1,\"843\":1,\"846\":1}}],[\"isregularfile\",{\"1\":{\"823\":1}}],[\"isdirectory\",{\"1\":{\"823\":1}}],[\"isdone\",{\"1\":{\"740\":1,\"756\":1}}],[\"isoutofbounds\",{\"1\":{\"799\":1}}],[\"isopen\",{\"1\":{\"743\":1}}],[\"isconnectable\",{\"1\":{\"843\":1}}],[\"isconnected\",{\"1\":{\"671\":1}}],[\"iscanceled\",{\"1\":{\"756\":1}}],[\"isvalid\",{\"1\":{\"740\":1,\"742\":1,\"743\":1}}],[\"iswritable\",{\"1\":{\"843\":1}}],[\"iswindows\",{\"1\":{\"740\":1}}],[\"isweakerthan\",{\"1\":{\"81\":1}}],[\"isassignablefrom\",{\"1\":{\"1489\":1}}],[\"isafter\",{\"1\":{\"1128\":1,\"1129\":1,\"1134\":1,\"1137\":1,\"1142\":1,\"1150\":1}}],[\"isa\",{\"1\":{\"875\":1,\"876\":6}}],[\"isacknowledged\",{\"1\":{\"1072\":2}}],[\"isacceptable\",{\"1\":{\"743\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":1,\"846\":1}}],[\"isactive\",{\"1\":{\"740\":4,\"743\":1}}],[\"isanylocaladdress\",{\"1\":{\"740\":1}}],[\"isautoread\",{\"1\":{\"740\":1,\"743\":2,\"744\":2}}],[\"isshuttingdown\",{\"1\":{\"741\":1}}],[\"isshutdown\",{\"1\":{\"741\":1}}],[\"issuccess\",{\"1\":{\"702\":1,\"735\":1,\"737\":1,\"740\":1,\"743\":1,\"756\":2,\"763\":1,\"764\":1,\"1161\":4,\"1162\":4,\"1165\":4,\"1167\":2}}],[\"isstrongerthan\",{\"1\":{\"81\":3}}],[\"isheldexclusively\",{\"1\":{\"585\":1}}],[\"isinterrupted\",{\"1\":{\"534\":1,\"536\":1}}],[\"isinstantiable\",{\"1\":{\"69\":2}}],[\"isnotblank\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1129\":2,\"1234\":1,\"1235\":2}}],[\"isnotempty\",{\"1\":{\"344\":1,\"1232\":2}}],[\"isnotnull\",{\"1\":{\"340\":4}}],[\"isnull\",{\"1\":{\"340\":4,\"482\":2}}],[\"is\",{\"1\":{\"42\":2,\"91\":1,\"271\":1,\"278\":1,\"279\":3,\"330\":4,\"409\":1,\"510\":3,\"789\":1,\"876\":1,\"1420\":1,\"1424\":1}}],[\"itself\",{\"1\":{\"1152\":1}}],[\"its\",{\"1\":{\"279\":1}}],[\"itcast\",{\"1\":{\"276\":1,\"278\":6,\"733\":2,\"735\":1,\"762\":2,\"765\":2,\"920\":7,\"1050\":1}}],[\"itcastsafetydoor\",{\"1\":{\"75\":2}}],[\"iterable<product>\",{\"1\":{\"1089\":1}}],[\"iterable<goodsbean>\",{\"1\":{\"986\":1}}],[\"iterable<nullwritable>\",{\"1\":{\"974\":1}}],[\"iterable<text>\",{\"1\":{\"973\":1,\"988\":2}}],[\"iterable<covidcountbean>\",{\"1\":{\"972\":1}}],[\"iterable<longwritable>\",{\"1\":{\"960\":1}}],[\"iterable\",{\"1\":{\"746\":1,\"960\":1,\"961\":2}}],[\"iterator<selectionkey>\",{\"1\":{\"743\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":2,\"846\":2}}],[\"iterator<string>\",{\"1\":{\"43\":1}}],[\"iterator接口是抽象商品类\",{\"1\":{\"43\":1}}],[\"iterator\",{\"1\":{\"43\":1,\"743\":1,\"834\":1,\"836\":1,\"840\":1,\"843\":2,\"846\":2}}],[\"iterator方法\",{\"0\":{\"43\":1}}],[\"iter\",{\"0\":{\"837\":1},\"1\":{\"743\":3,\"834\":4,\"836\":4,\"840\":4,\"843\":8,\"846\":8}}],[\"item\",{\"1\":{\"347\":1,\"717\":2,\"718\":6,\"1186\":2}}],[\"items\",{\"1\":{\"252\":1,\"256\":1,\"290\":1,\"348\":1}}],[\"it\",{\"1\":{\"43\":3,\"279\":2,\"330\":2}}],[\"itheima\",{\"1\":{\"42\":2,\"59\":3,\"281\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":3,\"1242\":1,\"1247\":1,\"1250\":1,\"1254\":1,\"1259\":1,\"1263\":1,\"1266\":1,\"1270\":1,\"1273\":1,\"1276\":1,\"1279\":1,\"1283\":1,\"1288\":1,\"1292\":1,\"1294\":5,\"1296\":1,\"1312\":1,\"1316\":1,\"1320\":2,\"1324\":1,\"1328\":1,\"1354\":1,\"1357\":2,\"1361\":1,\"1365\":1,\"1372\":1,\"1375\":1,\"1378\":1,\"1389\":1,\"1393\":1,\"1397\":1,\"1401\":1,\"1405\":1,\"1409\":1,\"1445\":3,\"1471\":1,\"1475\":1,\"1479\":1,\"1484\":1,\"1488\":1,\"1492\":1,\"1496\":1}}],[\"italydessertfactory\",{\"1\":{\"39\":1}}],[\"ioc容器销毁时销毁\",{\"1\":{\"1504\":1}}],[\"ioc容器启动时创建\",{\"1\":{\"1504\":1}}],[\"ioc是通过di来实现的\",{\"1\":{\"1500\":1}}],[\"ioc可以帮助我们维护对象与对象之间的依赖关系\",{\"1\":{\"1500\":1}}],[\"ioc叫反转控制\",{\"1\":{\"1500\":1}}],[\"ioc\",{\"1\":{\"1499\":1}}],[\"iocp\",{\"1\":{\"856\":1}}],[\"io性能优化\",{\"0\":{\"994\":1}}],[\"iotime\",{\"1\":{\"741\":2}}],[\"iostarttime\",{\"1\":{\"741\":2}}],[\"ioratio\",{\"1\":{\"741\":7}}],[\"io对比\",{\"1\":{\"679\":1}}],[\"io在kernel准备数据的情况下会立刻返回\",{\"1\":{\"679\":1}}],[\"io会一直block住对应的进程知道操作完成\",{\"1\":{\"679\":1}}],[\"io其实用的很少\",{\"1\":{\"679\":1}}],[\"io给block\",{\"1\":{\"679\":1}}],[\"io只调用了一个system\",{\"1\":{\"679\":1}}],[\"io的web\",{\"1\":{\"679\":1}}],[\"io的图其实并没有太大的不同\",{\"1\":{\"679\":1}}],[\"io的特点是用户进程需要不断地主动询问kernel数据好了没有\",{\"1\":{\"679\":1}}],[\"io的特点就是io执行的两个阶段都会被block\",{\"1\":{\"679\":1}}],[\"io多路复用就是通过一种机制使得一个进程可以监视多个文件描述符\",{\"1\":{\"680\":1}}],[\"io多路复用的特点是通过一种机制使得一个进程能够同时等待多个文件描述符\",{\"1\":{\"679\":1}}],[\"io多路复用\",{\"1\":{\"675\":1,\"679\":1,\"1190\":1}}],[\"io包中很多类进行了改写\",{\"1\":{\"610\":1}}],[\"io包中的reader\",{\"1\":{\"9\":1}}],[\"io包下\",{\"1\":{\"609\":1}}],[\"io编程\",{\"1\":{\"609\":1}}],[\"io密集型\",{\"1\":{\"576\":1}}],[\"io<\",{\"1\":{\"112\":2,\"113\":2,\"1022\":1}}],[\"io\",{\"0\":{\"748\":1,\"851\":1,\"854\":1},\"1\":{\"59\":1,\"110\":1,\"112\":1,\"113\":1,\"117\":1,\"120\":1,\"125\":1,\"127\":1,\"128\":1,\"131\":1,\"132\":1,\"433\":2,\"436\":1,\"610\":1,\"679\":7,\"725\":3,\"726\":1,\"740\":13,\"741\":11,\"742\":7,\"743\":7,\"744\":4,\"746\":8,\"749\":1,\"750\":1,\"762\":5,\"765\":18,\"775\":3,\"780\":1,\"787\":2,\"795\":2,\"828\":2,\"851\":4,\"854\":4,\"855\":1,\"856\":3,\"857\":1,\"1190\":1,\"1204\":1,\"1212\":1,\"1217\":1,\"1440\":2}}],[\"ioexception\",{\"1\":{\"9\":2,\"69\":3,\"70\":1,\"88\":4,\"373\":1,\"723\":3,\"726\":3,\"733\":1,\"741\":1,\"742\":1,\"795\":6,\"796\":1,\"807\":1,\"808\":1,\"820\":2,\"822\":7,\"823\":1,\"834\":2,\"836\":1,\"839\":2,\"840\":2,\"843\":2,\"846\":7,\"848\":1,\"857\":2,\"859\":4,\"958\":1,\"960\":1,\"972\":6,\"973\":2,\"974\":4,\"983\":1,\"985\":3,\"986\":2,\"988\":5,\"990\":2,\"991\":1,\"1071\":1,\"1159\":1,\"1449\":1}}],[\"inherited\",{\"1\":{\"1525\":1}}],[\"injectionmetadata\",{\"1\":{\"1267\":3}}],[\"inject\",{\"1\":{\"1257\":2}}],[\"indices\",{\"1\":{\"1072\":3,\"1075\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"indexer<\",{\"1\":{\"1473\":1}}],[\"indexed\",{\"0\":{\"1473\":1,\"1474\":1},\"1\":{\"672\":1,\"1476\":1}}],[\"index=false\",{\"1\":{\"1089\":1}}],[\"index=false表示不做索引关联\",{\"1\":{\"1089\":1}}],[\"index=true之后\",{\"1\":{\"437\":1}}],[\"indexname\",{\"1\":{\"1089\":2}}],[\"indexresponse\",{\"1\":{\"1073\":1}}],[\"indexrequest\",{\"1\":{\"1073\":5}}],[\"index稀疏索引\",{\"1\":{\"1052\":1}}],[\"index位置增加val\",{\"1\":{\"673\":1}}],[\"index有效利用\",{\"1\":{\"437\":1}}],[\"index大小对比索引\",{\"1\":{\"437\":1}}],[\"index行组索引\",{\"1\":{\"437\":1}}],[\"index可以帮助提高查询orc文件的性能\",{\"1\":{\"437\":1}}],[\"index命令来实现通过mapreduce更新索引表\",{\"1\":{\"424\":1}}],[\"index提高查询性能\",{\"1\":{\"419\":1}}],[\"index\",{\"0\":{\"1061\":1},\"1\":{\"419\":1,\"423\":3,\"437\":13,\"481\":2,\"495\":2,\"673\":14,\"768\":4,\"772\":4,\"773\":2,\"774\":7,\"776\":2,\"779\":2,\"799\":2,\"846\":7,\"1052\":1,\"1073\":7,\"1435\":1,\"1436\":3,\"1447\":2}}],[\"indexoutofboundsexception\",{\"1\":{\"88\":1,\"776\":1,\"799\":1}}],[\"inbound\",{\"1\":{\"775\":1,\"787\":1}}],[\"ineventloop\",{\"1\":{\"740\":1,\"741\":7,\"743\":2,\"746\":1,\"749\":1}}],[\"inetsocketaddress\",{\"1\":{\"726\":1,\"740\":3,\"754\":1,\"826\":2,\"827\":1,\"834\":1,\"836\":1,\"840\":2,\"843\":2,\"846\":1,\"848\":3,\"859\":1}}],[\"inactive\",{\"1\":{\"705\":1,\"826\":1}}],[\"initbinder\",{\"0\":{\"1380\":1,\"1381\":1},\"1\":{\"1370\":1,\"1376\":3,\"1381\":1,\"1382\":5}}],[\"initmethod\",{\"1\":{\"1289\":2}}],[\"initmap\",{\"1\":{\"740\":1}}],[\"initeventloops\",{\"1\":{\"846\":2}}],[\"init\",{\"1\":{\"740\":3,\"748\":1,\"999\":2,\"1157\":1,\"1285\":1}}],[\"initandregister\",{\"1\":{\"740\":5}}],[\"initchannel\",{\"1\":{\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"733\":2,\"735\":1,\"737\":3,\"740\":5,\"748\":3,\"753\":4,\"754\":1,\"766\":2,\"784\":2,\"785\":2,\"794\":2}}],[\"inittable\",{\"1\":{\"579\":1}}],[\"initializingbean\",{\"0\":{\"1282\":1},\"1\":{\"1284\":1,\"1289\":2}}],[\"initial\",{\"1\":{\"606\":1}}],[\"initialcapacity\",{\"1\":{\"579\":5}}],[\"initiator\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"in的逻辑\",{\"1\":{\"496\":1}}],[\"innodb引擎也采用这种方法\",{\"1\":{\"513\":1}}],[\"innodb行级锁是通过给索引上的索引项加锁来实现的\",{\"1\":{\"512\":1}}],[\"innodb中行级锁是怎么实现的\",{\"0\":{\"512\":1}}],[\"innodb中每行数据都有隐藏列\",{\"1\":{\"503\":1}}],[\"innodb通过锁机制来保证这一点\",{\"1\":{\"506\":1}}],[\"innodb提供了缓存\",{\"1\":{\"506\":1}}],[\"innodb作为mysql的存储引擎\",{\"1\":{\"506\":1}}],[\"innodb会根据undo\",{\"1\":{\"506\":1}}],[\"innodb会生成对应的undo\",{\"1\":{\"506\":1}}],[\"innodb实现回滚靠的是undo\",{\"1\":{\"506\":1}}],[\"innodb实现mvcc\",{\"1\":{\"503\":1}}],[\"innodb的默认隔离级别是repeatable\",{\"1\":{\"503\":1}}],[\"innodb数据文件本身是一颗b+树\",{\"1\":{\"490\":1}}],[\"innodb为什么使用自增主键是一个很好的选择\",{\"0\":{\"490\":1}}],[\"innodb为什么不建议用过长的字段作为主键\",{\"0\":{\"489\":1}}],[\"innodb存储引擎中页的大小为16\",{\"1\":{\"487\":1}}],[\"inner\",{\"0\":{\"320\":1},\"1\":{\"320\":3,\"324\":2,\"325\":1,\"461\":1}}],[\"in操作能避免则避免\",{\"1\":{\"482\":1}}],[\"inf\",{\"1\":{\"344\":3,\"1443\":1,\"1447\":2,\"1464\":2,\"1465\":1,\"1476\":2}}],[\"information\",{\"1\":{\"276\":1}}],[\"info\",{\"1\":{\"272\":1,\"352\":4,\"353\":7,\"354\":5,\"355\":2,\"359\":6,\"360\":4,\"361\":2,\"363\":2,\"364\":2,\"365\":4,\"493\":1,\"1023\":1,\"1024\":5,\"1025\":1,\"1072\":5,\"1089\":2,\"1180\":1,\"1294\":4}}],[\"in语句的常量\",{\"1\":{\"317\":1}}],[\"in\",{\"1\":{\"276\":1,\"317\":2,\"332\":4,\"334\":1,\"336\":3,\"343\":1,\"369\":1,\"491\":1,\"496\":5,\"579\":1,\"645\":1,\"648\":2,\"702\":3,\"713\":9,\"714\":9,\"723\":15,\"726\":2,\"733\":2,\"754\":1,\"762\":1,\"794\":1,\"799\":1,\"834\":1,\"839\":2,\"840\":1,\"857\":1,\"858\":1,\"859\":1,\"962\":2,\"972\":5,\"973\":1,\"974\":5,\"985\":7,\"1049\":1,\"1149\":1,\"1162\":2,\"1165\":1,\"1168\":1,\"1172\":1,\"1230\":3}}],[\"inputshutdown\",{\"1\":{\"743\":1}}],[\"inputstream类就使用了模板方法模式\",{\"1\":{\"88\":1}}],[\"inputstreamreader\",{\"1\":{\"795\":2,\"990\":1}}],[\"inputstreamreader做了inputstream字节流类到reader字符流之间的转换\",{\"1\":{\"9\":1}}],[\"inputstreamreader是对同样实现了reader的streamdecoder的封装\",{\"1\":{\"9\":1}}],[\"inputstreamreader继承自java\",{\"1\":{\"9\":1}}],[\"inputstream\",{\"1\":{\"9\":2,\"42\":1,\"70\":3,\"88\":1,\"723\":1,\"733\":1,\"839\":1}}],[\"inputbytesmax\",{\"1\":{\"444\":1}}],[\"input\",{\"1\":{\"374\":2,\"436\":1,\"470\":2,\"754\":1,\"962\":1,\"989\":1,\"990\":1,\"991\":1}}],[\"inputformat\",{\"1\":{\"283\":2}}],[\"inpath\",{\"1\":{\"261\":7,\"262\":3,\"280\":1,\"283\":2,\"285\":1,\"287\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":1,\"352\":1,\"357\":1,\"359\":2}}],[\"incomplete\",{\"1\":{\"765\":2}}],[\"incolor\",{\"1\":{\"125\":1}}],[\"incmessagesread\",{\"1\":{\"743\":1,\"744\":1}}],[\"incr和incrby和decy\",{\"1\":{\"1206\":1}}],[\"incrbyfloat\",{\"1\":{\"1206\":1}}],[\"incrby\",{\"1\":{\"1156\":2,\"1206\":6}}],[\"incr\",{\"1\":{\"515\":1,\"1206\":3}}],[\"increment\",{\"1\":{\"983\":1,\"986\":2,\"1132\":1,\"1164\":1,\"1174\":1,\"1211\":1}}],[\"incrementandget\",{\"1\":{\"562\":1,\"822\":3}}],[\"increment修饰的列分配递增的值\",{\"1\":{\"510\":1}}],[\"increment列的表中插入数据时需要获取的一种特殊的表级锁\",{\"1\":{\"510\":1}}],[\"inc锁释放掉\",{\"1\":{\"510\":1}}],[\"inc锁\",{\"1\":{\"510\":1}}],[\"inc锁是当想使用含有auto\",{\"1\":{\"510\":1}}],[\"includedistance\",{\"1\":{\"1172\":1}}],[\"include\",{\"1\":{\"663\":2,\"1079\":2}}],[\"include<bits\",{\"1\":{\"646\":1,\"669\":1}}],[\"includes>\",{\"1\":{\"102\":1}}],[\"include>\",{\"1\":{\"102\":1}}],[\"invocationtargetexception\",{\"1\":{\"1309\":1,\"1317\":1}}],[\"invocationhandler接口\",{\"1\":{\"1309\":1}}],[\"invocationhandler中invoke方法参数说明\",{\"1\":{\"59\":1}}],[\"invocationhandler\",{\"1\":{\"59\":12,\"61\":1,\"1309\":5,\"1317\":1}}],[\"invokejoinpoint\",{\"1\":{\"1340\":1}}],[\"invokechannelread\",{\"1\":{\"749\":4}}],[\"invokelater\",{\"1\":{\"740\":1}}],[\"invokehandleraddedifneeded\",{\"1\":{\"740\":1,\"743\":1}}],[\"invokespecial\",{\"1\":{\"567\":1}}],[\"invokesuper\",{\"1\":{\"60\":1,\"1306\":1,\"1317\":2,\"1321\":1,\"1480\":1}}],[\"invoked\",{\"1\":{\"70\":1}}],[\"invokereadresolve\",{\"1\":{\"69\":1}}],[\"invoke方法通过反射执行了真实对象所属类\",{\"1\":{\"59\":1}}],[\"invoke\",{\"1\":{\"59\":9,\"61\":1,\"734\":3,\"1304\":1,\"1306\":1,\"1309\":5,\"1317\":4,\"1321\":1,\"1340\":2}}],[\"insert语句会直接创建delta目录\",{\"1\":{\"292\":1}}],[\"inserts\",{\"0\":{\"289\":1},\"1\":{\"290\":1}}],[\"insert2\",{\"1\":{\"288\":2}}],[\"insert1\",{\"1\":{\"288\":2}}],[\"insert中\",{\"1\":{\"287\":1}}],[\"insert+select\",{\"1\":{\"287\":1}}],[\"insert表的数据就是通过student表中的数据先导出再导入实现的\",{\"1\":{\"287\":1}}],[\"insert插入数据\",{\"0\":{\"286\":1}}],[\"insert\",{\"0\":{\"290\":1},\"1\":{\"261\":1,\"266\":1,\"268\":1,\"270\":1,\"271\":2,\"276\":1,\"286\":3,\"287\":4,\"288\":2,\"289\":1,\"290\":6,\"293\":1,\"298\":1,\"318\":3,\"351\":1,\"409\":1,\"410\":1,\"501\":1,\"668\":5,\"988\":2}}],[\"install\",{\"1\":{\"95\":2,\"876\":3,\"1192\":1,\"1193\":1,\"1197\":1}}],[\"instantiationawarebeanpostprocessor\",{\"1\":{\"1505\":1}}],[\"instantiationexception\",{\"1\":{\"733\":1}}],[\"instantiate\",{\"1\":{\"70\":1}}],[\"instanceclass\",{\"1\":{\"733\":2}}],[\"instanceof\",{\"1\":{\"579\":1,\"702\":1,\"711\":2,\"740\":1,\"748\":1,\"775\":1}}],[\"instance对象是随着类的加载而创建的\",{\"1\":{\"66\":1}}],[\"instanceb\",{\"1\":{\"22\":1}}],[\"instance\",{\"1\":{\"22\":15,\"66\":26,\"68\":13,\"69\":11,\"70\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"740\":1,\"1071\":3,\"1219\":1}}],[\"inside\",{\"1\":{\"23\":3}}],[\"intvalue\",{\"1\":{\"1156\":1,\"1157\":1}}],[\"intwritable\",{\"1\":{\"956\":1}}],[\"intbuffer\",{\"1\":{\"610\":1,\"861\":1}}],[\"into\",{\"1\":{\"261\":8,\"262\":3,\"264\":2,\"265\":1,\"266\":1,\"268\":2,\"271\":1,\"276\":1,\"280\":1,\"283\":2,\"285\":1,\"286\":2,\"287\":2,\"289\":1,\"298\":1,\"329\":1,\"340\":1,\"348\":1,\"351\":2,\"352\":1,\"357\":1,\"359\":2}}],[\"int>\",{\"1\":{\"256\":1}}],[\"integration\",{\"1\":{\"1499\":1}}],[\"integer>>\",{\"1\":{\"758\":1}}],[\"integer>\",{\"1\":{\"671\":1,\"758\":1,\"973\":2}}],[\"integer\",{\"1\":{\"59\":1,\"519\":2,\"574\":1,\"598\":1,\"599\":1,\"614\":1,\"620\":2,\"717\":1,\"718\":1,\"723\":1,\"757\":1,\"758\":1,\"773\":1,\"857\":1,\"859\":2,\"968\":1,\"973\":1,\"1073\":1,\"1088\":1,\"1161\":1,\"1164\":1,\"1165\":1,\"1168\":3,\"1172\":4,\"1205\":10,\"1206\":11,\"1208\":7,\"1209\":2,\"1210\":11,\"1234\":1}}],[\"intersect\",{\"1\":{\"1165\":1}}],[\"intern\",{\"1\":{\"1137\":4}}],[\"internallockleasetime\",{\"1\":{\"1152\":1}}],[\"internal\",{\"1\":{\"762\":1,\"765\":2,\"1313\":1}}],[\"interval\",{\"1\":{\"1024\":1}}],[\"interval的值\",{\"1\":{\"910\":1}}],[\"interval<\",{\"1\":{\"910\":2}}],[\"intervalmsec\",{\"1\":{\"903\":1}}],[\"interval配置项配置\",{\"1\":{\"903\":1}}],[\"interview\",{\"0\":{\"1540\":1},\"2\":{\"653\":1,\"654\":1}}],[\"interestops\",{\"1\":{\"740\":6,\"742\":2,\"743\":6,\"840\":2,\"843\":4,\"846\":2}}],[\"interrupted\",{\"1\":{\"585\":2,\"741\":1,\"742\":1}}],[\"interruptedexception\",{\"1\":{\"47\":2,\"373\":1,\"536\":2,\"551\":2,\"554\":2,\"555\":4,\"585\":4,\"593\":4,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"717\":2,\"718\":2,\"733\":1,\"748\":1,\"754\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"958\":1,\"960\":1,\"972\":2,\"973\":2,\"974\":2,\"983\":1,\"985\":1,\"986\":2,\"988\":5,\"990\":2,\"1127\":1,\"1129\":1,\"1132\":1}}],[\"interrupt\",{\"0\":{\"534\":1},\"1\":{\"536\":2,\"741\":1,\"833\":1}}],[\"intermediate=true\",{\"1\":{\"433\":1}}],[\"interceptors\",{\"1\":{\"1343\":1}}],[\"interceptor\",{\"1\":{\"1232\":3}}],[\"interceptorregistry\",{\"1\":{\"1100\":1}}],[\"intercept\",{\"1\":{\"60\":1}}],[\"intercept方法参数说明\",{\"1\":{\"60\":1}}],[\"interfaceaudience\",{\"1\":{\"956\":1,\"968\":1}}],[\"interfaceclass\",{\"1\":{\"733\":4}}],[\"interfacename\",{\"1\":{\"733\":4}}],[\"interfacestability\",{\"1\":{\"956\":1,\"968\":1}}],[\"interfaces\",{\"0\":{\"895\":1},\"1\":{\"59\":1,\"737\":2}}],[\"interface\",{\"1\":{\"6\":2,\"23\":1,\"34\":1,\"39\":1,\"47\":1,\"58\":1,\"59\":1,\"75\":3,\"81\":1,\"232\":1,\"614\":1,\"701\":3,\"716\":4,\"723\":1,\"756\":2,\"956\":1,\"1089\":1,\"1142\":1,\"1257\":1,\"1304\":1,\"1309\":2,\"1525\":1}}],[\"intelcpu\",{\"1\":{\"74\":6}}],[\"intel处理器\",{\"1\":{\"74\":1}}],[\"intel\",{\"1\":{\"17\":2,\"875\":1}}],[\"int\",{\"1\":{\"9\":4,\"47\":6,\"59\":1,\"69\":1,\"70\":1,\"73\":12,\"81\":24,\"88\":9,\"248\":4,\"256\":1,\"260\":5,\"261\":5,\"262\":2,\"265\":3,\"266\":3,\"268\":2,\"276\":1,\"278\":1,\"279\":10,\"280\":2,\"281\":5,\"285\":3,\"287\":3,\"288\":1,\"289\":2,\"298\":2,\"338\":4,\"340\":2,\"341\":1,\"342\":4,\"343\":1,\"351\":4,\"357\":2,\"359\":1,\"378\":1,\"382\":1,\"385\":1,\"388\":3,\"402\":1,\"407\":1,\"408\":1,\"409\":1,\"480\":1,\"483\":2,\"493\":2,\"541\":1,\"555\":6,\"564\":1,\"566\":3,\"567\":1,\"571\":1,\"572\":2,\"574\":1,\"579\":9,\"585\":11,\"590\":2,\"591\":3,\"592\":1,\"593\":2,\"599\":1,\"645\":10,\"646\":6,\"648\":23,\"649\":25,\"663\":8,\"668\":7,\"669\":10,\"671\":11,\"673\":17,\"676\":1,\"692\":1,\"693\":1,\"696\":1,\"697\":2,\"698\":2,\"699\":2,\"713\":3,\"714\":3,\"723\":25,\"725\":1,\"726\":1,\"733\":5,\"737\":1,\"740\":1,\"741\":1,\"742\":4,\"743\":4,\"759\":1,\"768\":2,\"772\":9,\"773\":1,\"774\":1,\"795\":2,\"796\":1,\"799\":24,\"802\":1,\"803\":2,\"809\":2,\"814\":1,\"827\":1,\"832\":3,\"834\":2,\"836\":3,\"839\":1,\"840\":4,\"843\":4,\"846\":4,\"854\":1,\"956\":1,\"962\":2,\"968\":2,\"973\":2,\"974\":4,\"988\":6,\"999\":2,\"1023\":1,\"1025\":2,\"1035\":1,\"1089\":4,\"1132\":3,\"1135\":1,\"1137\":3,\"1157\":2,\"1168\":1,\"1172\":2,\"1175\":1,\"1176\":2,\"1180\":2,\"1206\":1,\"1309\":4,\"1321\":3,\"1526\":1}}],[\"ifcfg\",{\"1\":{\"878\":1}}],[\"if函数使用\",{\"1\":{\"351\":1}}],[\"if条件判断\",{\"1\":{\"340\":2}}],[\"if\",{\"1\":{\"6\":1,\"22\":4,\"23\":4,\"28\":2,\"30\":2,\"66\":6,\"68\":2,\"69\":5,\"81\":8,\"88\":5,\"256\":1,\"260\":1,\"261\":1,\"276\":1,\"278\":2,\"280\":3,\"285\":1,\"286\":1,\"340\":4,\"344\":2,\"351\":1,\"397\":1,\"409\":1,\"482\":2,\"496\":2,\"536\":1,\"555\":2,\"566\":3,\"579\":23,\"585\":9,\"590\":2,\"592\":1,\"614\":1,\"645\":2,\"646\":2,\"648\":1,\"649\":1,\"668\":7,\"669\":7,\"671\":2,\"702\":4,\"703\":2,\"704\":3,\"707\":2,\"711\":2,\"718\":1,\"723\":3,\"725\":2,\"733\":1,\"735\":1,\"737\":3,\"738\":2,\"740\":19,\"741\":10,\"742\":13,\"743\":15,\"744\":5,\"748\":1,\"749\":1,\"754\":1,\"775\":1,\"794\":1,\"796\":1,\"799\":5,\"809\":1,\"822\":1,\"823\":2,\"827\":2,\"834\":2,\"836\":4,\"839\":1,\"840\":5,\"843\":6,\"846\":6,\"859\":2,\"972\":1,\"973\":2,\"974\":3,\"983\":1,\"986\":1,\"988\":4,\"991\":1,\"999\":5,\"1025\":1,\"1099\":4,\"1100\":1,\"1107\":3,\"1111\":3,\"1122\":3,\"1124\":3,\"1127\":4,\"1128\":3,\"1129\":11,\"1134\":4,\"1135\":2,\"1137\":9,\"1142\":4,\"1144\":1,\"1146\":1,\"1150\":5,\"1151\":4,\"1152\":9,\"1156\":3,\"1157\":4,\"1160\":1,\"1161\":5,\"1162\":5,\"1164\":1,\"1165\":5,\"1167\":1,\"1168\":2,\"1172\":3,\"1176\":2,\"1180\":1,\"1205\":1,\"1206\":1,\"1213\":1,\"1216\":1,\"1232\":2,\"1321\":2,\"1467\":1,\"1505\":6}}],[\"slog4j日志\",{\"1\":{\"1022\":1}}],[\"slot\",{\"1\":{\"528\":1,\"948\":1}}],[\"slf桥接log4j日志\",{\"1\":{\"1022\":1}}],[\"slf4j<\",{\"1\":{\"1022\":1}}],[\"slf4j\",{\"1\":{\"702\":2,\"705\":1,\"713\":1,\"714\":1,\"725\":1,\"733\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"754\":1,\"766\":1,\"796\":1,\"834\":1,\"836\":1,\"846\":2,\"857\":1,\"1089\":1,\"1129\":1,\"1159\":1,\"1505\":1}}],[\"slice\",{\"0\":{\"776\":1},\"1\":{\"713\":2,\"776\":13,\"781\":1}}],[\"slave成为新的master后\",{\"1\":{\"530\":1}}],[\"slave的机器时钟比master走得快很多\",{\"1\":{\"530\":1}}],[\"slave是不会主动清理过期key的\",{\"1\":{\"529\":1}}],[\"sleep不会释放锁对象\",{\"1\":{\"546\":1}}],[\"sleep不需要强制和synchronized配合使用\",{\"1\":{\"546\":1}}],[\"sleep是thread方法\",{\"1\":{\"546\":1}}],[\"sleep有休眠时间\",{\"1\":{\"533\":1}}],[\"sleep\",{\"0\":{\"533\":1,\"546\":1},\"1\":{\"47\":2,\"533\":1,\"534\":1,\"536\":2,\"551\":2,\"593\":2,\"717\":1,\"718\":1,\"748\":1,\"750\":1,\"751\":1,\"757\":1,\"758\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"1023\":1,\"1127\":2,\"1129\":1}}],[\"skiplist\",{\"1\":{\"1211\":1}}],[\"skiptrash\",{\"1\":{\"910\":1}}],[\"skiptrash来跳过垃圾桶直接永久删除\",{\"1\":{\"910\":1}}],[\"skipcrccheck\",{\"1\":{\"869\":1}}],[\"skip\",{\"1\":{\"616\":1,\"1172\":1}}],[\"skin\",{\"1\":{\"256\":3}}],[\"skewjoin\",{\"1\":{\"470\":2}}],[\"skewjoin=true\",{\"1\":{\"470\":1}}],[\"skew\",{\"1\":{\"470\":1}}],[\"skewindata=true\",{\"1\":{\"466\":1}}],[\"smartinitializingsingleton\",{\"1\":{\"1493\":1}}],[\"smartloli\",{\"1\":{\"1046\":1}}],[\"smalltable\",{\"1\":{\"448\":1}}],[\"smallfiles\",{\"1\":{\"435\":1}}],[\"smallint\",{\"1\":{\"248\":2,\"480\":1}}],[\"smembers\",{\"1\":{\"515\":1,\"1210\":3}}],[\"smb\",{\"1\":{\"450\":1}}],[\"sf<\",{\"1\":{\"344\":1}}],[\"s+表示用来匹配空白符\",{\"1\":{\"336\":1}}],[\"s+\",{\"1\":{\"336\":1,\"958\":1,\"983\":1}}],[\"snipaste\",{\"1\":{\"823\":2}}],[\"sndbuf\",{\"0\":{\"729\":1},\"1\":{\"694\":2,\"729\":1}}],[\"snapshotdiff\",{\"1\":{\"914\":1}}],[\"snapshot来查看隐藏文件\",{\"1\":{\"914\":1}}],[\"snapshot\",{\"1\":{\"911\":1,\"962\":1}}],[\"snapshot快照是整个文件系统或某个目录在某个时刻的镜像\",{\"1\":{\"911\":1}}],[\"snapshot快照\",{\"0\":{\"911\":1}}],[\"snapshot<\",{\"1\":{\"105\":1,\"107\":3,\"112\":1,\"113\":1,\"114\":2,\"115\":2,\"1219\":1}}],[\"snappy\",{\"1\":{\"876\":1}}],[\"snappycodec\",{\"1\":{\"433\":2}}],[\"sname\",{\"1\":{\"276\":1,\"287\":1,\"288\":1,\"289\":1}}],[\"snowflakeidgenerator\",{\"1\":{\"999\":7}}],[\"snowflake\",{\"0\":{\"998\":1},\"1\":{\"996\":1,\"998\":1}}],[\"sno\",{\"1\":{\"276\":2,\"287\":1,\"288\":1,\"289\":1}}],[\"salenum\",{\"1\":{\"985\":10,\"986\":1}}],[\"salary\",{\"1\":{\"357\":4,\"404\":3}}],[\"safemode\",{\"1\":{\"870\":6}}],[\"safesetsuccess\",{\"1\":{\"740\":2,\"743\":1}}],[\"safesetfailure\",{\"1\":{\"740\":3,\"743\":2}}],[\"safer\",{\"1\":{\"272\":1}}],[\"sayhello\",{\"1\":{\"735\":1,\"737\":4}}],[\"sadd\",{\"1\":{\"515\":1,\"1156\":2,\"1210\":4}}],[\"sample\",{\"1\":{\"369\":1}}],[\"sage\",{\"1\":{\"289\":1}}],[\"savesuper\",{\"1\":{\"1321\":3}}],[\"saveshop2redis\",{\"1\":{\"1128\":3}}],[\"saveblog\",{\"1\":{\"1159\":1,\"1167\":1}}],[\"saveuser\",{\"1\":{\"1100\":1,\"1101\":2,\"1111\":1}}],[\"saveall\",{\"1\":{\"1089\":2}}],[\"save\",{\"1\":{\"74\":3,\"1089\":2,\"1133\":3,\"1134\":1,\"1137\":3,\"1156\":2,\"1157\":1,\"1159\":1,\"1164\":1,\"1165\":1,\"1167\":1,\"1317\":1,\"1321\":6,\"1525\":1,\"1526\":1,\"1531\":1}}],[\"sso\",{\"1\":{\"1532\":1}}],[\"ssm\",{\"1\":{\"1245\":2}}],[\"sshfench\",{\"1\":{\"885\":1}}],[\"ssh\",{\"1\":{\"878\":1}}],[\"ssh免密登录\",{\"1\":{\"878\":1}}],[\"ss=new\",{\"1\":{\"839\":1}}],[\"ssckey\",{\"1\":{\"837\":3,\"840\":4,\"846\":2}}],[\"ssc\",{\"1\":{\"740\":1,\"826\":3,\"827\":4,\"840\":4,\"843\":5,\"846\":4,\"859\":9}}],[\"ss\",{\"1\":{\"337\":3,\"726\":2,\"795\":2,\"839\":1}}],[\"ssn\",{\"1\":{\"272\":3}}],[\"sstf\",{\"1\":{\"204\":1}}],[\"software\",{\"1\":{\"1012\":1,\"1046\":1}}],[\"solomon\",{\"1\":{\"875\":2}}],[\"solution\",{\"1\":{\"649\":2}}],[\"somaxconn\",{\"1\":{\"726\":2}}],[\"something\",{\"1\":{\"590\":3}}],[\"so\",{\"0\":{\"726\":1,\"729\":2},\"1\":{\"693\":2,\"694\":2,\"725\":1,\"726\":1,\"729\":2,\"740\":1,\"872\":1,\"876\":10}}],[\"socket都是成对出现的\",{\"1\":{\"1100\":1}}],[\"socket<\",{\"1\":{\"872\":1}}],[\"socket是一种进程间的通讯方式\",{\"1\":{\"872\":1}}],[\"sockettimeoutexception\",{\"1\":{\"726\":1}}],[\"socket\",{\"1\":{\"726\":3,\"740\":3,\"785\":1,\"795\":4,\"834\":5,\"839\":3,\"844\":2,\"848\":1,\"854\":6,\"855\":3,\"866\":1,\"872\":7}}],[\"socketaddress\",{\"1\":{\"725\":2,\"740\":4,\"840\":1}}],[\"socketchannal\",{\"1\":{\"725\":1,\"728\":1,\"729\":2,\"730\":1,\"731\":1}}],[\"socketchannel\",{\"1\":{\"610\":1,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":2,\"710\":1,\"711\":1,\"733\":2,\"735\":1,\"737\":1,\"743\":1,\"748\":2,\"784\":4,\"785\":2,\"815\":1,\"826\":6,\"827\":5,\"834\":1,\"836\":5,\"840\":5,\"843\":5,\"846\":4,\"861\":1}}],[\"socket执行读操作时\",{\"1\":{\"679\":1}}],[\"socketserverchannel\",{\"1\":{\"610\":1}}],[\"sogou\",{\"1\":{\"437\":6}}],[\"sortorder\",{\"1\":{\"1078\":1}}],[\"sort的情况\",{\"1\":{\"481\":1}}],[\"sortmerge\",{\"1\":{\"450\":2}}],[\"sort目录下就有有5个对应的分桶文件\",{\"1\":{\"266\":1}}],[\"sort\",{\"0\":{\"314\":1},\"1\":{\"265\":1,\"266\":1,\"300\":1,\"313\":3,\"314\":1,\"315\":3,\"339\":3,\"367\":1,\"437\":2,\"614\":1,\"645\":4,\"979\":1,\"1078\":1,\"1089\":5}}],[\"sortedset的常见命令有\",{\"1\":{\"1211\":1}}],[\"sortedset具备下列特性\",{\"1\":{\"1211\":1}}],[\"sortedset中的每一个元素都带有一个score属性\",{\"1\":{\"1211\":1}}],[\"sortedset类型\",{\"0\":{\"1211\":1}}],[\"sortedmerge\",{\"1\":{\"450\":1}}],[\"sorted\",{\"1\":{\"264\":2,\"265\":1,\"450\":1,\"515\":1,\"618\":3,\"619\":1}}],[\"source\",{\"1\":{\"437\":2,\"809\":14,\"821\":3,\"822\":6,\"823\":3,\"840\":8,\"869\":1,\"1012\":1,\"1046\":1,\"1073\":4,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"sourceencoding>\",{\"1\":{\"99\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"sourceencoding>utf\",{\"1\":{\"99\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"source>\",{\"1\":{\"92\":1,\"102\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"919\":1,\"926\":1,\"957\":1,\"1022\":1}}],[\"source>17<\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"source>1\",{\"1\":{\"92\":1}}],[\"sqlsessiontemplate\",{\"1\":{\"1455\":1}}],[\"sqlsession\",{\"1\":{\"1455\":2}}],[\"sqlsessionfactory\",{\"1\":{\"1455\":1,\"1472\":1}}],[\"sql会变成select\",{\"1\":{\"1230\":1}}],[\"sqlite\",{\"1\":{\"1046\":2}}],[\"sqlexception\",{\"1\":{\"985\":2}}],[\"sql语句\",{\"0\":{\"482\":1}}],[\"sql语句为\",{\"1\":{\"455\":1}}],[\"sql性能优化的目标\",{\"1\":{\"481\":1}}],[\"sql性能\",{\"1\":{\"481\":1}}],[\"sql中\",{\"1\":{\"248\":1}}],[\"sql\",{\"0\":{\"245\":1,\"246\":1,\"257\":1,\"277\":1,\"282\":1,\"283\":1,\"286\":1,\"299\":1,\"300\":1,\"301\":1,\"311\":1,\"319\":1},\"1\":{\"483\":1,\"1184\":2,\"1232\":1}}],[\"square\",{\"1\":{\"23\":5}}],[\"sweep\",{\"1\":{\"639\":1}}],[\"swap需要两个参数\",{\"1\":{\"170\":1}}],[\"swap指令和swap指令的区别\",{\"1\":{\"170\":1}}],[\"swap指令\",{\"1\":{\"170\":1}}],[\"switch\",{\"1\":{\"69\":1,\"702\":1,\"741\":2,\"1321\":2}}],[\"srem\",{\"1\":{\"1210\":3}}],[\"src\",{\"1\":{\"662\":3,\"772\":3,\"991\":4,\"1193\":1,\"1196\":2,\"1197\":1,\"1244\":1,\"1441\":1}}],[\"srnt\",{\"1\":{\"167\":1}}],[\"srtn\",{\"1\":{\"167\":1}}],[\"srome\",{\"1\":{\"128\":1}}],[\"spill\",{\"1\":{\"979\":1}}],[\"spread方法会综合高位地位\",{\"1\":{\"579\":1}}],[\"spread方法能保证返回结果是正数\",{\"1\":{\"579\":1}}],[\"spread\",{\"1\":{\"579\":2}}],[\"springmvc\",{\"0\":{\"1527\":1}}],[\"spring是怎么解决循环依赖的\",{\"0\":{\"1518\":1}}],[\"spring是如何管理事务的\",{\"0\":{\"1513\":1}}],[\"spring是如何管理bean的\",{\"0\":{\"1503\":1}}],[\"spring的事务如何配置\",{\"0\":{\"1515\":1}}],[\"spring的核心是ioc和aop\",{\"1\":{\"1500\":1}}],[\"spring在transactiondefinition接口中规定了其中类型的事务传播行为\",{\"1\":{\"1514\":1}}],[\"spring中的事务传播行为\",{\"0\":{\"1514\":1}}],[\"spring提供了transactiontemplate和transactionmanager手动管理事务\",{\"1\":{\"1513\":1}}],[\"spring容器关闭时调用disposablebean中的destory\",{\"1\":{\"1505\":1}}],[\"spring就知道要哪些包下带声明的类需要被扫描\",{\"1\":{\"1503\":1}}],[\"spring通过ioc来管理bean\",{\"1\":{\"1503\":1}}],[\"spring为beanfactory提供了很多实现\",{\"1\":{\"1502\":1}}],[\"spring主要提供了两种类型的容器\",{\"1\":{\"1501\":1}}],[\"spring其他功能基本都需要依赖于该类库\",{\"1\":{\"1499\":1}}],[\"spring4\",{\"1\":{\"1499\":1}}],[\"springfactoriesloader\",{\"1\":{\"1464\":1}}],[\"springframework\",{\"1\":{\"1022\":2,\"1070\":2,\"1087\":4,\"1172\":3,\"1219\":4,\"1332\":1,\"1335\":1,\"1338\":1,\"1342\":1,\"1345\":1,\"1349\":1,\"1428\":1,\"1445\":5,\"1453\":1,\"1454\":1,\"1456\":2,\"1461\":1,\"1462\":1}}],[\"springframework<\",{\"1\":{\"107\":10,\"112\":1,\"113\":1,\"1087\":1,\"1473\":1}}],[\"springcontext\",{\"1\":{\"1451\":2}}],[\"springapplicationrunlisteners\",{\"1\":{\"1444\":1,\"1446\":1}}],[\"springapplication\",{\"1\":{\"1442\":1,\"1444\":2,\"1445\":1,\"1446\":2}}],[\"springboot实现登录拦截器\",{\"1\":{\"1532\":1}}],[\"springbootconfiguration\",{\"1\":{\"1525\":2}}],[\"springbootapplication看作是\",{\"1\":{\"1525\":1}}],[\"springbootapplication\",{\"1\":{\"1525\":1}}],[\"springboot\",{\"0\":{\"1519\":1},\"1\":{\"1244\":1}}],[\"springboot已经提供了对springdataredis的支持\",{\"1\":{\"1218\":1}}],[\"springboottest\",{\"1\":{\"1089\":1,\"1221\":1,\"1223\":1,\"1224\":1}}],[\"spring对象的数据序列化及反序列化\",{\"1\":{\"1217\":1}}],[\"springdatajpa使用起来非常简单\",{\"1\":{\"1221\":1}}],[\"springdata是spring中数据操作的模块\",{\"1\":{\"1217\":1}}],[\"springdataredis的使用步骤\",{\"1\":{\"1221\":1}}],[\"springdataredis中提供了redistemplate工具类\",{\"1\":{\"1217\":1}}],[\"springdataredis\",{\"0\":{\"1217\":1},\"1\":{\"1172\":1}}],[\"spring\",{\"0\":{\"1238\":1,\"1322\":1,\"1450\":1,\"1498\":1,\"1509\":1,\"1511\":1,\"1521\":1,\"1523\":1,\"1524\":1,\"1526\":1},\"1\":{\"110\":7,\"112\":3,\"791\":2,\"1217\":2,\"1219\":1,\"1220\":1,\"1236\":2,\"1243\":1,\"1245\":4,\"1252\":1,\"1255\":1,\"1274\":1,\"1280\":2,\"1284\":1,\"1289\":2,\"1290\":3,\"1317\":1,\"1321\":1,\"1322\":1,\"1355\":1,\"1362\":1,\"1379\":1,\"1394\":1,\"1411\":4,\"1417\":1,\"1440\":3,\"1441\":3,\"1442\":1,\"1444\":2,\"1446\":2,\"1453\":2,\"1454\":2,\"1455\":4,\"1462\":1,\"1464\":2,\"1465\":1,\"1466\":1,\"1476\":2,\"1480\":1,\"1497\":1,\"1499\":19,\"1500\":2,\"1509\":2,\"1510\":1,\"1511\":1,\"1520\":4,\"1521\":1,\"1522\":1,\"1523\":1,\"1524\":2,\"1525\":1,\"1532\":3}}],[\"spof\",{\"1\":{\"882\":1}}],[\"spop\",{\"1\":{\"515\":1}}],[\"spooling技术\",{\"1\":{\"212\":1}}],[\"split与block的对应关系默认是一对一\",{\"1\":{\"979\":1}}],[\"splitsize\",{\"1\":{\"976\":1}}],[\"split\",{\"1\":{\"336\":3,\"391\":1,\"702\":2,\"809\":3,\"840\":2,\"958\":1,\"972\":1,\"973\":3,\"974\":1,\"976\":2,\"983\":1,\"986\":1,\"988\":6,\"990\":2}}],[\"spark\",{\"1\":{\"791\":1,\"951\":1}}],[\"spark3种执行引擎\",{\"1\":{\"232\":1}}],[\"space\",{\"1\":{\"336\":3}}],[\"spec\",{\"1\":{\"279\":2}}],[\"specific\",{\"1\":{\"276\":1}}],[\"spf\",{\"1\":{\"167\":1}}],[\"sjf优点\",{\"1\":{\"167\":1}}],[\"sjf和spf都是非抢占式算法\",{\"1\":{\"167\":1}}],[\"sjf\",{\"1\":{\"167\":1}}],[\"scp\",{\"1\":{\"878\":1,\"910\":2,\"936\":2}}],[\"scrollresult\",{\"1\":{\"1168\":3}}],[\"script\",{\"1\":{\"1147\":5,\"1156\":6,\"1157\":1}}],[\"scripts\",{\"1\":{\"878\":1}}],[\"screen=\",{\"1\":{\"17\":2}}],[\"screen\",{\"1\":{\"17\":17}}],[\"sckey\",{\"1\":{\"837\":1,\"840\":4,\"843\":5,\"846\":2}}],[\"sc\",{\"1\":{\"645\":3,\"648\":10,\"826\":5,\"827\":5,\"834\":2,\"836\":7,\"840\":10,\"843\":12,\"846\":11,\"859\":23,\"986\":2}}],[\"scala\",{\"1\":{\"998\":1}}],[\"scattering\",{\"0\":{\"807\":1}}],[\"scavenge和serial\",{\"1\":{\"638\":1}}],[\"scavenge\",{\"1\":{\"638\":4}}],[\"scard\",{\"1\":{\"515\":1,\"1210\":3}}],[\"scanner\",{\"1\":{\"645\":2,\"648\":6,\"702\":6,\"754\":4,\"794\":4}}],[\"scan\",{\"1\":{\"204\":2,\"276\":1}}],[\"score\",{\"1\":{\"1162\":7,\"1211\":1}}],[\"scoket\",{\"1\":{\"784\":1}}],[\"scode\",{\"1\":{\"395\":2,\"405\":2}}],[\"scope注解修改bean的作用域\",{\"1\":{\"1504\":1}}],[\"scope用于声明bean的作用域\",{\"1\":{\"1503\":1}}],[\"scopedproxymode\",{\"1\":{\"1290\":1,\"1297\":1}}],[\"scope\",{\"0\":{\"1290\":1,\"1294\":1},\"1\":{\"100\":2,\"1248\":1,\"1290\":4,\"1293\":3,\"1294\":1,\"1297\":3}}],[\"scope>\",{\"1\":{\"99\":1,\"105\":1,\"112\":1,\"113\":1,\"1022\":1,\"1070\":1,\"1087\":2,\"1213\":1,\"1219\":1,\"1442\":1}}],[\"scope属性是可选的\",{\"1\":{\"99\":1}}],[\"scheduleexpirationrenewal\",{\"1\":{\"1152\":1}}],[\"scheduler\",{\"1\":{\"945\":2}}],[\"scheduleatfixedrate\",{\"1\":{\"751\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"746\":1}}],[\"scheduledtask\",{\"1\":{\"742\":2}}],[\"schedule\",{\"1\":{\"725\":2}}],[\"schema\",{\"1\":{\"234\":1}}],[\"schemalocation=\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"1219\":1}}],[\"schmidhuber在2016年nips大会上打断goodfellow的gan\",{\"1\":{\"126\":1}}],[\"s2\",{\"1\":{\"68\":4,\"318\":1,\"614\":2,\"713\":2,\"1210\":2}}],[\"s1和s2\",{\"1\":{\"1210\":1}}],[\"s1\",{\"1\":{\"68\":4,\"318\":2,\"614\":2,\"713\":3,\"1210\":8}}],[\"sb\",{\"1\":{\"47\":1,\"843\":3,\"988\":6}}],[\"suffix\",{\"1\":{\"1441\":1}}],[\"suffix=\",{\"1\":{\"1441\":1}}],[\"success\",{\"1\":{\"741\":2,\"760\":2,\"761\":2,\"986\":1,\"1134\":2,\"1135\":2,\"1136\":2,\"1137\":6,\"1142\":2,\"1144\":2,\"1157\":2}}],[\"suspend\",{\"1\":{\"740\":1}}],[\"suppresswarnings\",{\"1\":{\"740\":1}}],[\"supplier<\",{\"1\":{\"614\":1}}],[\"supported\",{\"1\":{\"1514\":1}}],[\"supports\",{\"1\":{\"1514\":1}}],[\"supportseventtype\",{\"1\":{\"1497\":1}}],[\"supportsparameter\",{\"1\":{\"1362\":1}}],[\"support\",{\"1\":{\"219\":1,\"261\":1,\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"302\":1,\"1461\":1}}],[\"supervisor\",{\"1\":{\"951\":1}}],[\"super\",{\"1\":{\"51\":1,\"52\":1,\"54\":1,\"59\":2,\"591\":1,\"692\":2,\"716\":1,\"733\":1,\"758\":2,\"766\":8,\"822\":5,\"974\":1,\"1321\":4}}],[\"summary\",{\"1\":{\"1205\":2,\"1206\":1}}],[\"summarizingdouble\",{\"1\":{\"620\":1}}],[\"sumrange\",{\"1\":{\"673\":1}}],[\"sum+group\",{\"1\":{\"357\":1}}],[\"sum\",{\"1\":{\"81\":3,\"307\":5,\"310\":1,\"351\":6,\"357\":2,\"360\":8,\"361\":2,\"402\":1,\"482\":4,\"620\":4,\"673\":3}}],[\"sunion\",{\"1\":{\"1210\":2}}],[\"sunion等\",{\"1\":{\"515\":1}}],[\"sunday\",{\"1\":{\"132\":1}}],[\"sun\",{\"1\":{\"59\":1,\"836\":1}}],[\"submissionpublisher<string>\",{\"1\":{\"718\":1}}],[\"submissionpublisher<>\",{\"1\":{\"717\":1,\"718\":1}}],[\"submissionpublisher<integer>\",{\"1\":{\"717\":1,\"718\":1}}],[\"submit=\",{\"1\":{\"992\":1}}],[\"submit方法就会继续执行下去\",{\"1\":{\"719\":1}}],[\"submit是一个阻塞式方法\",{\"1\":{\"718\":1}}],[\"submit\",{\"0\":{\"575\":1},\"1\":{\"575\":1,\"593\":4,\"717\":1,\"718\":2,\"757\":1,\"758\":1,\"765\":2,\"962\":1,\"1128\":1,\"1129\":1,\"1132\":1,\"1157\":1}}],[\"sublen\",{\"1\":{\"566\":4}}],[\"sub\",{\"1\":{\"337\":3,\"409\":1,\"1296\":1,\"1378\":1}}],[\"subscription\",{\"1\":{\"716\":2,\"717\":10,\"718\":19}}],[\"subscriber<string>\",{\"1\":{\"718\":1}}],[\"subscriber<>\",{\"1\":{\"717\":1,\"718\":1}}],[\"subscriber<integer>\",{\"1\":{\"717\":1}}],[\"subscriber<t>\",{\"1\":{\"716\":1}}],[\"subscriber和subscription完成一个发布\",{\"1\":{\"717\":1}}],[\"subscriber\",{\"1\":{\"716\":2,\"717\":2,\"718\":2}}],[\"subscribe\",{\"1\":{\"45\":1,\"716\":1,\"717\":1,\"718\":2,\"1024\":1}}],[\"substring\",{\"1\":{\"336\":2,\"566\":2,\"614\":1}}],[\"substr\",{\"1\":{\"336\":4}}],[\"subquery\",{\"1\":{\"332\":2}}],[\"subq2\",{\"1\":{\"315\":1}}],[\"subq1\",{\"1\":{\"315\":1}}],[\"subject角色定义了注册观察者和删除观察者的方法\",{\"1\":{\"46\":1}}],[\"subject角色表示观察对象\",{\"1\":{\"46\":1}}],[\"subject\",{\"1\":{\"46\":1,\"47\":1,\"57\":2}}],[\"sugar\",{\"1\":{\"34\":1}}],[\"signup\",{\"1\":{\"1525\":1,\"1526\":1,\"1531\":1}}],[\"signcount\",{\"1\":{\"1176\":3}}],[\"sign\",{\"1\":{\"1175\":5,\"1176\":3,\"1525\":1,\"1526\":1,\"1531\":1}}],[\"sign`\",{\"1\":{\"1174\":1}}],[\"signal\",{\"1\":{\"395\":2,\"396\":5,\"397\":1,\"554\":2,\"555\":3,\"679\":1}}],[\"signal原语简称为p\",{\"1\":{\"171\":1}}],[\"side\",{\"0\":{\"988\":1,\"990\":1},\"1\":{\"990\":2,\"991\":1}}],[\"simpleurlhandlermapping\",{\"0\":{\"1426\":1},\"1\":{\"1429\":4,\"1430\":2,\"1437\":1}}],[\"simpletypeconverter\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"simpleredislock\",{\"1\":{\"1142\":5,\"1150\":3}}],[\"simple认证\",{\"0\":{\"922\":1}}],[\"simplefilevisitor<path>\",{\"1\":{\"822\":3}}],[\"simplecontrollerhandleradapter\",{\"0\":{\"1418\":1},\"1\":{\"1420\":3,\"1421\":1,\"1435\":3,\"1436\":1,\"1437\":1}}],[\"simplecoffeefactory\",{\"1\":{\"28\":1,\"30\":1}}],[\"simplechannelinboundhandler<string>\",{\"1\":{\"784\":1}}],[\"simplechannelinboundhandler<rpcresponsemessage>\",{\"1\":{\"736\":1,\"738\":1}}],[\"simplechannelinboundhandler<rpcrequestmessage>\",{\"1\":{\"734\":1}}],[\"simplechannelinboundhandler<httprequest>\",{\"1\":{\"711\":1}}],[\"simplechannelinboundhandler<groupmembersrequestmessage>\",{\"1\":{\"704\":1}}],[\"simplechannelinboundhandler<groupquitrequestmessage>\",{\"1\":{\"704\":1}}],[\"simplechannelinboundhandler<groupjoinrequestmessage>\",{\"1\":{\"704\":1}}],[\"simplechannelinboundhandler<groupchatrequestmessage>\",{\"1\":{\"704\":1}}],[\"simplechannelinboundhandler<groupcreaterequestmessage>\",{\"1\":{\"704\":1}}],[\"simplechannelinboundhandler<chatrequestmessage>\",{\"1\":{\"703\":1}}],[\"simplechannelinboundhandler<loginrequestmessage>\",{\"1\":{\"702\":1,\"703\":1}}],[\"simple\",{\"1\":{\"661\":1,\"921\":1}}],[\"sinter\",{\"1\":{\"1210\":3}}],[\"sinterstore\",{\"1\":{\"515\":1}}],[\"since\",{\"1\":{\"648\":2,\"1205\":2,\"1206\":1}}],[\"single\",{\"1\":{\"882\":1}}],[\"singlethreadeventexecutor$5\",{\"1\":{\"762\":1,\"765\":2}}],[\"singlethreadeventexecutor\",{\"1\":{\"741\":4,\"762\":1,\"765\":2}}],[\"singletonobjects\",{\"1\":{\"1243\":1,\"1472\":1}}],[\"singletonlist\",{\"1\":{\"1024\":1,\"1147\":1}}],[\"singleton类\",{\"1\":{\"68\":2,\"69\":1}}],[\"singletonholder\",{\"1\":{\"66\":2,\"68\":2,\"69\":3,\"1071\":3}}],[\"singleton\",{\"0\":{\"1294\":1},\"1\":{\"64\":1,\"66\":39,\"68\":24,\"69\":12,\"1290\":2,\"1293\":1,\"1504\":1}}],[\"singleton4\",{\"1\":{\"22\":6}}],[\"singleton3\",{\"1\":{\"22\":5}}],[\"singleton2\",{\"1\":{\"22\":5}}],[\"singleton1\",{\"1\":{\"22\":5}}],[\"singer\",{\"1\":{\"374\":1}}],[\"sismember\",{\"1\":{\"515\":1,\"1156\":2,\"1210\":5}}],[\"size=5\",{\"1\":{\"1167\":1}}],[\"size=512000000\",{\"1\":{\"448\":1}}],[\"size一个数据块对应一个切片文件\",{\"1\":{\"976\":1}}],[\"size相等\",{\"1\":{\"976\":1}}],[\"sizeof\",{\"1\":{\"646\":1,\"663\":2}}],[\"size计算实际发生在put\",{\"1\":{\"579\":1}}],[\"size计算流程\",{\"1\":{\"579\":1}}],[\"sizectl\",{\"1\":{\"579\":2}}],[\"size的子集合\",{\"1\":{\"483\":1}}],[\"size\",{\"1\":{\"339\":5,\"435\":1,\"483\":3,\"579\":3,\"606\":2,\"669\":3,\"694\":1,\"743\":3,\"818\":1,\"820\":6,\"965\":2,\"976\":5,\"979\":1,\"988\":2,\"999\":1,\"1021\":2,\"1077\":1,\"1161\":1,\"1165\":1,\"1167\":1,\"1168\":1,\"1171\":1,\"1172\":6,\"1177\":1,\"1180\":1}}],[\"site\",{\"1\":{\"95\":1,\"133\":1,\"234\":1,\"254\":1,\"268\":1,\"445\":2,\"870\":1,\"872\":1,\"874\":1,\"879\":1,\"880\":2,\"910\":3,\"926\":1,\"927\":1,\"936\":9,\"963\":1,\"1013\":1}}],[\"shift\",{\"1\":{\"999\":6}}],[\"shell\",{\"1\":{\"924\":1}}],[\"shellfench\",{\"1\":{\"885\":1}}],[\"sheshou\",{\"1\":{\"260\":1,\"261\":1}}],[\"shuangkou\",{\"1\":{\"1525\":1}}],[\"shuffle阶段十分繁琐\",{\"1\":{\"988\":1}}],[\"shuffle和merge要花大量的时间\",{\"1\":{\"432\":1}}],[\"shutdowngracefully\",{\"1\":{\"692\":3,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":3,\"710\":1,\"711\":2,\"725\":1,\"733\":3,\"735\":1,\"737\":1,\"747\":1,\"754\":1,\"794\":1}}],[\"shutdown\",{\"1\":{\"571\":1,\"741\":1,\"1196\":2}}],[\"sh\",{\"1\":{\"280\":2,\"876\":1,\"910\":2,\"936\":3,\"1012\":3,\"1015\":2,\"1016\":1,\"1017\":1,\"1020\":1,\"1021\":2,\"1045\":1,\"1046\":3,\"1050\":1}}],[\"shards\",{\"0\":{\"1066\":1}}],[\"sharable💡\",{\"0\":{\"714\":1}}],[\"sharable\",{\"1\":{\"703\":2,\"704\":5,\"705\":1,\"714\":2,\"734\":1,\"736\":1,\"738\":1}}],[\"shade\",{\"1\":{\"344\":1}}],[\"sha2\",{\"1\":{\"343\":3}}],[\"sha1\",{\"1\":{\"343\":2}}],[\"sha\",{\"1\":{\"343\":6}}],[\"shanghai\",{\"1\":{\"262\":1,\"280\":1}}],[\"shapetype\",{\"1\":{\"23\":5}}],[\"shapefactory\",{\"1\":{\"23\":2}}],[\"shape\",{\"1\":{\"23\":6}}],[\"shortcircuit<\",{\"1\":{\"872\":1}}],[\"shortcircuit\",{\"1\":{\"872\":1}}],[\"shortbuffer\",{\"1\":{\"610\":1,\"861\":1}}],[\"short\",{\"1\":{\"598\":1,\"772\":1,\"799\":2}}],[\"shortest\",{\"1\":{\"167\":3}}],[\"shouldbreakreadready\",{\"1\":{\"744\":1}}],[\"should\",{\"1\":{\"369\":1,\"1080\":1}}],[\"shops\",{\"1\":{\"1172\":3}}],[\"shopserviceimpl\",{\"1\":{\"1128\":1,\"1172\":1}}],[\"shopservice\",{\"1\":{\"1116\":1,\"1128\":1,\"1171\":1,\"1172\":1}}],[\"shopidstr\",{\"1\":{\"1172\":3}}],[\"shopid\",{\"1\":{\"1172\":1}}],[\"shopcontroller\",{\"1\":{\"1172\":1}}],[\"shopmap\",{\"1\":{\"1122\":1}}],[\"shopjson\",{\"1\":{\"1122\":2,\"1124\":4,\"1127\":4,\"1128\":3,\"1129\":4}}],[\"shopprice\",{\"1\":{\"985\":10,\"986\":1}}],[\"shop<\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"shop\",{\"0\":{\"112\":1},\"1\":{\"1100\":2,\"1122\":17,\"1124\":14,\"1127\":17,\"1128\":14,\"1129\":21,\"1171\":7,\"1172\":6}}],[\"shows\",{\"1\":{\"276\":2,\"876\":1}}],[\"show\",{\"1\":{\"52\":3,\"54\":5,\"271\":3,\"276\":3,\"281\":1,\"328\":1,\"342\":4}}],[\"showbike\",{\"1\":{\"14\":3}}],[\"sysconfig\",{\"1\":{\"878\":1}}],[\"sys快照比较\",{\"1\":{\"503\":1}}],[\"sys\",{\"1\":{\"503\":1,\"680\":1,\"726\":2}}],[\"systemdesign\",{\"0\":{\"1558\":1}}],[\"systemd\",{\"1\":{\"1197\":1}}],[\"systemconstants\",{\"1\":{\"1159\":2,\"1161\":1,\"1165\":1,\"1172\":4}}],[\"systemctl\",{\"1\":{\"878\":2,\"1197\":6}}],[\"systempath\",{\"1\":{\"100\":1}}],[\"system\",{\"0\":{\"635\":1},\"1\":{\"6\":7,\"7\":5,\"14\":2,\"17\":2,\"23\":3,\"34\":2,\"43\":1,\"47\":4,\"51\":3,\"52\":1,\"54\":3,\"58\":2,\"59\":3,\"60\":2,\"68\":2,\"70\":3,\"73\":2,\"74\":7,\"75\":5,\"76\":2,\"81\":6,\"85\":7,\"100\":1,\"153\":1,\"344\":1,\"536\":2,\"562\":10,\"565\":1,\"614\":2,\"616\":1,\"617\":3,\"618\":1,\"619\":2,\"620\":3,\"621\":9,\"633\":1,\"645\":2,\"648\":4,\"668\":2,\"702\":15,\"710\":1,\"717\":2,\"718\":4,\"726\":6,\"737\":3,\"741\":2,\"742\":2,\"746\":4,\"748\":1,\"754\":1,\"765\":4,\"768\":1,\"774\":5,\"776\":8,\"779\":3,\"780\":3,\"784\":1,\"794\":3,\"795\":2,\"799\":6,\"805\":2,\"809\":1,\"820\":4,\"821\":2,\"822\":6,\"823\":3,\"826\":1,\"834\":3,\"836\":1,\"839\":1,\"840\":1,\"843\":4,\"848\":1,\"857\":1,\"858\":1,\"859\":5,\"875\":1,\"962\":2,\"972\":1,\"973\":1,\"974\":2,\"985\":1,\"986\":1,\"988\":2,\"991\":1,\"999\":8,\"1046\":2,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":3,\"1132\":4,\"1150\":1,\"1162\":1,\"1167\":1,\"1197\":1,\"1213\":3,\"1221\":1,\"1223\":2,\"1224\":1,\"1244\":3,\"1257\":5,\"1294\":2,\"1304\":3,\"1306\":3,\"1309\":4,\"1317\":2,\"1416\":1,\"1441\":1,\"1526\":1}}],[\"syn锁失效的原因\",{\"1\":{\"1138\":1}}],[\"syn\",{\"1\":{\"726\":5}}],[\"syntax\",{\"1\":{\"442\":1}}],[\"syncookies\",{\"1\":{\"726\":1}}],[\"synchronousqueue是一种特殊的队列\",{\"1\":{\"574\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"574\":1}}],[\"synchronizedqueue\",{\"1\":{\"572\":1}}],[\"synchronized是基于悲观锁的思想\",{\"1\":{\"561\":1}}],[\"synchronized代码块内部是不能保证指令重排的\",{\"1\":{\"559\":1}}],[\"synchronized的有序性是持有相同锁的两个同步块只能串行的进入\",{\"1\":{\"559\":1}}],[\"synchronized还可以修饰方法\",{\"1\":{\"558\":1}}],[\"synchronized语句块既能保证代码块的原子性\",{\"1\":{\"558\":1}}],[\"synchronized必须是进入同一个锁对象的monitor才有上述的效果\",{\"1\":{\"541\":1}}],[\"synchronized\",{\"1\":{\"22\":2,\"66\":3,\"68\":1,\"69\":1,\"541\":1,\"549\":1,\"551\":4,\"554\":2,\"555\":2,\"579\":1,\"737\":1,\"740\":4,\"999\":1,\"1137\":4,\"1149\":2,\"1151\":1}}],[\"sync\",{\"1\":{\"280\":1,\"591\":2,\"592\":2,\"692\":4,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"702\":4,\"710\":2,\"711\":2,\"725\":2,\"726\":3,\"733\":4,\"735\":2,\"737\":1,\"748\":2,\"752\":1,\"753\":5,\"754\":2,\"756\":1,\"762\":2,\"763\":1,\"785\":2,\"794\":1,\"1049\":2}}],[\"s\",{\"0\":{\"10\":3,\"1535\":1},\"1\":{\"171\":2,\"172\":2,\"279\":5,\"508\":3,\"510\":1,\"614\":4,\"619\":2,\"702\":11,\"716\":2,\"726\":3,\"795\":6,\"839\":2,\"857\":2,\"859\":6,\"988\":4,\"1368\":1}}],[\"session的工作原理和使用经验\",{\"1\":{\"1532\":1}}],[\"session共享一个bean\",{\"1\":{\"1504\":1}}],[\"session共享问题\",{\"0\":{\"1102\":1}}],[\"session他是每个用户都有自己的session\",{\"1\":{\"1105\":1}}],[\"session拷贝数据时\",{\"1\":{\"1102\":1}}],[\"sessionfactory\",{\"1\":{\"703\":2,\"705\":2}}],[\"session\",{\"0\":{\"1291\":1},\"1\":{\"701\":1,\"1099\":6,\"1100\":2,\"1101\":1,\"1107\":1,\"1290\":1,\"1293\":2,\"1504\":2}}],[\"sent\",{\"1\":{\"1021\":1}}],[\"sentinel\",{\"1\":{\"526\":1,\"1193\":1}}],[\"sendcode\",{\"1\":{\"1099\":1}}],[\"sendfile\",{\"1\":{\"855\":1}}],[\"send\",{\"1\":{\"696\":2,\"702\":2,\"726\":1,\"848\":1,\"1023\":2,\"1025\":1}}],[\"sending\",{\"1\":{\"692\":1,\"696\":1,\"697\":2,\"698\":2,\"699\":2}}],[\"searchhits\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"searchresponse\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1}}],[\"searchrequest\",{\"1\":{\"1075\":2,\"1076\":2,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2}}],[\"searchsourcebuilder\",{\"1\":{\"1075\":1,\"1076\":1,\"1077\":2,\"1078\":2,\"1079\":2,\"1080\":2,\"1081\":2,\"1082\":2,\"1083\":2,\"1084\":2,\"1085\":2}}],[\"searchprefix\",{\"1\":{\"668\":2}}],[\"search\",{\"1\":{\"668\":2,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1079\":1,\"1080\":1,\"1081\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1089\":1,\"1172\":1}}],[\"seat\",{\"1\":{\"14\":5}}],[\"segment端的后缀名会以\",{\"1\":{\"1056\":1}}],[\"segment\",{\"1\":{\"694\":2,\"1052\":1}}],[\"segmentfault\",{\"1\":{\"651\":2}}],[\"segment继承了reentrancelock\",{\"1\":{\"579\":1}}],[\"sequence\",{\"1\":{\"772\":1,\"906\":1,\"999\":13,\"1029\":2}}],[\"sequenceidgenerator\",{\"1\":{\"737\":1}}],[\"sequenceid\",{\"1\":{\"713\":2,\"714\":2,\"723\":4,\"733\":2,\"737\":3}}],[\"sequencefile文件也可以作为mapreduce作业的输入和输出\",{\"1\":{\"428\":1}}],[\"sequencefile是hadoop里用来存储序列化的键值对即二进制的一种文件格式\",{\"1\":{\"428\":1}}],[\"sequencefile\",{\"0\":{\"428\":1}}],[\"seq\",{\"1\":{\"363\":2}}],[\"seckillvoucherservice\",{\"1\":{\"1133\":1,\"1134\":2,\"1135\":1,\"1136\":2,\"1137\":4,\"1142\":1,\"1150\":1,\"1156\":1,\"1157\":1}}],[\"seckillvoucher\",{\"1\":{\"1133\":8,\"1134\":6,\"1137\":2,\"1142\":6,\"1150\":6,\"1156\":9,\"1157\":1}}],[\"seckill\",{\"1\":{\"1133\":3,\"1156\":9,\"1157\":3}}],[\"sec\",{\"1\":{\"1021\":2}}],[\"seconds\",{\"1\":{\"574\":1,\"751\":1,\"1127\":1,\"1129\":1,\"1142\":1,\"1144\":1,\"1150\":1}}],[\"second\",{\"1\":{\"337\":3}}],[\"security\",{\"1\":{\"110\":1,\"936\":2}}],[\"separator\",{\"1\":{\"336\":1}}],[\"semaphore等待\",{\"1\":{\"1212\":1}}],[\"semaphore传入的参数permits最终设置为state的个数\",{\"1\":{\"591\":1}}],[\"semaphore的构造函数\",{\"1\":{\"591\":1}}],[\"semaphore有一个构造函数\",{\"1\":{\"591\":1}}],[\"semaphore\",{\"0\":{\"591\":1},\"1\":{\"581\":1,\"591\":1}}],[\"semanticexception\",{\"1\":{\"271\":1}}],[\"semi\",{\"0\":{\"324\":1},\"1\":{\"324\":3}}],[\"sex\",{\"1\":{\"280\":1,\"287\":1,\"289\":3,\"303\":1,\"313\":1,\"340\":3,\"351\":11,\"1073\":2,\"1080\":1,\"1208\":7}}],[\"sexyyolo\",{\"1\":{\"145\":1}}],[\"selfinterrupt\",{\"1\":{\"585\":1}}],[\"selectimports\",{\"1\":{\"1464\":1,\"1465\":1}}],[\"selectionkey\",{\"1\":{\"740\":10,\"742\":5,\"743\":8,\"831\":1,\"834\":2,\"836\":3,\"840\":8,\"843\":9,\"846\":6}}],[\"selectlist\",{\"1\":{\"1234\":1}}],[\"select=\",{\"1\":{\"1230\":1}}],[\"select>\",{\"1\":{\"1230\":3}}],[\"selectedselectionkeyset\",{\"1\":{\"742\":2}}],[\"selectedkeys\",{\"1\":{\"742\":4,\"743\":1,\"834\":1,\"836\":2,\"837\":3,\"840\":3,\"843\":2,\"846\":2}}],[\"selectrebuildselector\",{\"1\":{\"742\":1}}],[\"selectdeadlinenanos\",{\"1\":{\"742\":2}}],[\"selectcnt\",{\"1\":{\"742\":11}}],[\"selectstrategy\",{\"1\":{\"741\":5}}],[\"selectnowsupplier\",{\"1\":{\"741\":1}}],[\"selectnow\",{\"1\":{\"741\":1,\"742\":2,\"832\":1,\"834\":1,\"836\":1,\"846\":1}}],[\"select低效是因为每次它都需要轮询\",{\"1\":{\"680\":1}}],[\"select和poll的性能可能比epoll好\",{\"1\":{\"680\":1}}],[\"select和poll都需要在返回后\",{\"1\":{\"680\":1}}],[\"select和recvfrom\",{\"1\":{\"679\":1}}],[\"select最大的缺陷就是单个进程所打开的fd数量是有一定限制的\",{\"1\":{\"680\":1}}],[\"select的一个缺点在于单个进程能够监视文件描述符的数量存在最大限制\",{\"1\":{\"680\":1}}],[\"select目前几乎在所有的平台上支持\",{\"1\":{\"680\":1}}],[\"select函数监视的文件描述符分3类\",{\"1\":{\"680\":1}}],[\"select函数就可以返回\",{\"1\":{\"679\":1}}],[\"select就会返回\",{\"1\":{\"679\":1}}],[\"selectorautorebuildthreshold\",{\"1\":{\"742\":1}}],[\"selector用于监听多个通道事件\",{\"1\":{\"612\":1}}],[\"selector能够检测到多个注册通道上是否有事件发生\",{\"1\":{\"610\":1}}],[\"selector会根据不同的事件\",{\"1\":{\"610\":1}}],[\"selector\",{\"0\":{\"829\":1,\"862\":1,\"867\":1},\"1\":{\"610\":2,\"740\":9,\"741\":2,\"742\":13,\"743\":3,\"746\":1,\"784\":1,\"828\":4,\"829\":1,\"830\":3,\"831\":3,\"832\":3,\"833\":3,\"834\":7,\"836\":8,\"838\":1,\"840\":10,\"843\":16,\"846\":4,\"850\":1,\"862\":1,\"867\":2}}],[\"select时不能包含其他字段\",{\"1\":{\"378\":1}}],[\"select时多个聚合函数一起使用\",{\"1\":{\"351\":1}}],[\"select语句只有zipcode命中了联合索引\",{\"1\":{\"495\":1}}],[\"select语句中的cte\",{\"1\":{\"318\":1}}],[\"select语句中使用\",{\"1\":{\"318\":1}}],[\"select语法树\",{\"1\":{\"300\":1}}],[\"select或create\",{\"1\":{\"318\":1}}],[\"select查询高阶语法\",{\"0\":{\"311\":1}}],[\"select查询基础语法\",{\"0\":{\"301\":1}}],[\"select\",{\"0\":{\"300\":1,\"302\":1,\"680\":1,\"833\":1},\"1\":{\"260\":1,\"261\":1,\"266\":1,\"271\":5,\"272\":2,\"276\":4,\"286\":2,\"287\":1,\"288\":2,\"289\":2,\"290\":6,\"300\":3,\"302\":5,\"303\":6,\"307\":3,\"310\":2,\"313\":2,\"315\":9,\"316\":5,\"317\":4,\"318\":19,\"320\":3,\"321\":2,\"322\":2,\"323\":2,\"324\":2,\"325\":4,\"326\":7,\"329\":1,\"330\":10,\"331\":8,\"332\":8,\"336\":25,\"337\":18,\"338\":11,\"339\":9,\"340\":17,\"341\":3,\"342\":7,\"343\":8,\"344\":1,\"347\":2,\"348\":2,\"349\":2,\"351\":16,\"353\":7,\"354\":5,\"355\":2,\"357\":2,\"360\":4,\"361\":2,\"363\":3,\"364\":3,\"365\":4,\"367\":2,\"368\":3,\"369\":2,\"377\":5,\"378\":3,\"382\":1,\"385\":1,\"388\":3,\"391\":1,\"395\":1,\"396\":2,\"400\":5,\"402\":1,\"404\":2,\"409\":2,\"410\":1,\"423\":1,\"437\":4,\"452\":1,\"455\":1,\"460\":3,\"465\":1,\"481\":2,\"482\":4,\"493\":1,\"495\":1,\"496\":4,\"675\":1,\"679\":2,\"680\":3,\"741\":9,\"742\":8,\"743\":1,\"832\":2,\"834\":2,\"836\":6,\"837\":1,\"840\":3,\"843\":2,\"846\":2,\"867\":2,\"985\":2,\"1107\":1,\"1167\":1,\"1202\":1,\"1213\":1,\"1216\":1,\"1230\":7}}],[\"sell\",{\"1\":{\"58\":5,\"59\":8,\"60\":2}}],[\"selltickets\",{\"1\":{\"58\":3,\"59\":17}}],[\"serial\",{\"1\":{\"638\":9,\"639\":1}}],[\"serialization\",{\"1\":{\"956\":1,\"1023\":2,\"1024\":2}}],[\"serializable\",{\"1\":{\"59\":1,\"68\":1,\"69\":1,\"723\":1,\"733\":1}}],[\"serialize\",{\"1\":{\"723\":4}}],[\"serializeralgorithm\",{\"1\":{\"723\":9}}],[\"serializertype\",{\"1\":{\"713\":2,\"714\":2,\"723\":1}}],[\"serializer\",{\"1\":{\"250\":1,\"723\":11,\"733\":1,\"1023\":4}}],[\"serde加载数据\",{\"1\":{\"393\":1}}],[\"serde2\",{\"1\":{\"374\":2}}],[\"serdeproperties\",{\"1\":{\"251\":1,\"279\":4,\"374\":2}}],[\"serde\",{\"0\":{\"397\":1},\"1\":{\"251\":3,\"279\":3,\"283\":2,\"374\":2,\"397\":1}}],[\"serde相关语法\",{\"0\":{\"251\":1}}],[\"serde是serializer\",{\"1\":{\"249\":1}}],[\"servertimezone=gmt\",{\"1\":{\"1236\":1}}],[\"server时的命令\",{\"1\":{\"1196\":1}}],[\"server命令即可启动redis\",{\"1\":{\"1195\":1}}],[\"servers=ip1\",{\"1\":{\"1021\":1}}],[\"servers=localhost\",{\"1\":{\"1021\":1}}],[\"servers\",{\"1\":{\"789\":1,\"1023\":2,\"1024\":1}}],[\"serversocket\",{\"1\":{\"726\":2,\"795\":2,\"837\":1,\"839\":2}}],[\"serversocketchannelimpl\",{\"1\":{\"836\":1}}],[\"serversocketchannel\",{\"1\":{\"740\":7,\"743\":1,\"748\":2,\"784\":2,\"826\":3,\"827\":4,\"834\":4,\"836\":4,\"840\":4,\"843\":2,\"846\":4,\"861\":1}}],[\"serversocketchannelconfig\",{\"1\":{\"726\":1}}],[\"serversocketchannal\",{\"1\":{\"726\":1,\"729\":2}}],[\"serverbootstrapacceptor\",{\"1\":{\"740\":3,\"743\":2}}],[\"serverbootstrap\",{\"1\":{\"692\":7,\"693\":2,\"702\":7,\"711\":7,\"733\":7,\"740\":2,\"743\":2,\"748\":2,\"766\":1,\"784\":1,\"794\":1}}],[\"server性能更好\",{\"1\":{\"679\":1}}],[\"server不一定比使用multi\",{\"1\":{\"679\":1}}],[\"server端\",{\"1\":{\"297\":1}}],[\"server\",{\"1\":{\"244\":2,\"522\":1,\"692\":1,\"702\":1,\"711\":1,\"723\":1,\"726\":7,\"733\":3,\"735\":1,\"740\":1,\"750\":2,\"751\":2,\"766\":3,\"785\":1,\"794\":2,\"839\":1,\"840\":1,\"848\":2,\"859\":1,\"878\":2,\"879\":1,\"910\":1,\"923\":2,\"933\":1,\"936\":4,\"949\":1,\"1012\":12,\"1015\":2,\"1017\":1,\"1045\":2,\"1046\":8,\"1050\":1,\"1190\":1,\"1193\":1,\"1195\":1,\"1196\":1,\"1197\":2,\"1293\":1,\"1411\":1,\"1447\":1,\"1462\":1}}],[\"server>\",{\"1\":{\"102\":1}}],[\"serve\",{\"1\":{\"167\":1}}],[\"service用于声明业务层的bean\",{\"1\":{\"1503\":1}}],[\"serviceimpl<usermapper\",{\"1\":{\"1236\":1}}],[\"serviceclass\",{\"1\":{\"737\":4}}],[\"servicesfactory\",{\"1\":{\"733\":1,\"734\":1}}],[\"service<\",{\"1\":{\"113\":1,\"114\":2,\"115\":5}}],[\"service\",{\"0\":{\"113\":1,\"114\":1,\"115\":1},\"1\":{\"110\":2,\"114\":1,\"115\":1,\"244\":1,\"733\":4,\"734\":3,\"735\":1,\"737\":4,\"757\":2,\"878\":2,\"923\":1,\"951\":1,\"1100\":1,\"1197\":2,\"1236\":1,\"1447\":1,\"1503\":1,\"1506\":1}}],[\"servletwebserverfactory\",{\"1\":{\"1457\":1}}],[\"servletwebserverfactoryautoconfiguration\",{\"0\":{\"1457\":1}}],[\"servletregistrationbean\",{\"1\":{\"1451\":3}}],[\"servletrequestdatabinderfactory\",{\"1\":{\"1376\":1}}],[\"servletrequestdatabinder\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"servletexception\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"servletcontext\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"servletcontextscope\",{\"1\":{\"1293\":1}}],[\"servletcontainerinitializer\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"servletinitializer\",{\"1\":{\"1442\":1}}],[\"servletinvocablehandlermethod\",{\"1\":{\"1384\":1,\"1438\":2}}],[\"servlet\",{\"1\":{\"100\":1,\"1245\":1,\"1293\":1,\"1428\":1,\"1438\":2,\"1447\":2,\"1449\":1,\"1451\":1,\"1462\":2,\"1499\":1}}],[\"seed2\",{\"1\":{\"81\":2}}],[\"seed1\",{\"1\":{\"81\":2}}],[\"seed\",{\"1\":{\"81\":4,\"338\":1}}],[\"setter\",{\"1\":{\"1525\":1}}],[\"setter方法注入\",{\"1\":{\"1500\":1}}],[\"settablenamehandler\",{\"1\":{\"1232\":1}}],[\"settimeout\",{\"1\":{\"1152\":1}}],[\"settings\",{\"1\":{\"92\":2}}],[\"setvalueserializer\",{\"1\":{\"1222\":1}}],[\"setvoucherid\",{\"1\":{\"1133\":1,\"1134\":1,\"1137\":3,\"1156\":1,\"1157\":1}}],[\"sethashvalueserializer\",{\"1\":{\"1222\":1}}],[\"sethashkeyserializer\",{\"1\":{\"1222\":1}}],[\"setharddisk\",{\"1\":{\"74\":3}}],[\"setkeyserializer\",{\"1\":{\"1222\":1}}],[\"set中的指定元素自增\",{\"1\":{\"1211\":1}}],[\"set中的指定元素的score值\",{\"1\":{\"1211\":1}}],[\"set中的元素个数\",{\"1\":{\"1211\":1}}],[\"set中的一个指定元素\",{\"1\":{\"1211\":1}}],[\"set类型的常见命令\",{\"1\":{\"1210\":1}}],[\"set命令\",{\"0\":{\"1210\":1}}],[\"setoffset\",{\"1\":{\"1168\":1}}],[\"setoutput\",{\"1\":{\"986\":1}}],[\"setoutputformatclass\",{\"1\":{\"986\":1}}],[\"setoutputvalueclass\",{\"1\":{\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setoutputkeyclass\",{\"1\":{\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setoutputpath\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"988\":1,\"991\":2}}],[\"setport\",{\"1\":{\"1449\":1}}],[\"setpolicy\",{\"1\":{\"875\":1}}],[\"setpassword\",{\"1\":{\"1150\":1}}],[\"setendtime\",{\"1\":{\"1133\":1,\"1156\":1}}],[\"setex\",{\"1\":{\"1206\":3}}],[\"setexpiretime\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"setexceptionvalue\",{\"1\":{\"734\":1}}],[\"setex等\",{\"1\":{\"515\":1}}],[\"setwithlogicexpire\",{\"1\":{\"1129\":2}}],[\"setdefaultencoding\",{\"1\":{\"1244\":1}}],[\"setdistance\",{\"1\":{\"1172\":1}}],[\"setdata\",{\"1\":{\"1128\":1,\"1129\":1}}],[\"setdouble\",{\"1\":{\"985\":2}}],[\"setislike\",{\"1\":{\"1161\":1,\"1162\":1}}],[\"seticon\",{\"1\":{\"1160\":1}}],[\"setid\",{\"1\":{\"1134\":1,\"1137\":3,\"1157\":1}}],[\"setifabsent\",{\"1\":{\"1127\":1,\"1129\":1,\"1142\":1,\"1144\":1}}],[\"setignorenullvalue\",{\"1\":{\"1107\":1}}],[\"setincludeexception\",{\"1\":{\"1416\":1}}],[\"setinput\",{\"1\":{\"985\":1}}],[\"setinputformatclass\",{\"1\":{\"985\":1}}],[\"setinputpaths\",{\"1\":{\"962\":2,\"986\":1,\"988\":1,\"991\":2}}],[\"setint\",{\"1\":{\"711\":1}}],[\"setjob\",{\"1\":{\"991\":2}}],[\"setjarbyclass\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setlist\",{\"1\":{\"1168\":1}}],[\"setlocations\",{\"1\":{\"1429\":2,\"1432\":1}}],[\"setlocation\",{\"1\":{\"1147\":1,\"1156\":1}}],[\"setlong\",{\"1\":{\"985\":2}}],[\"setlength\",{\"1\":{\"988\":1}}],[\"seturlmap\",{\"1\":{\"1429\":1}}],[\"setuserid\",{\"1\":{\"1134\":1,\"1137\":3,\"1157\":1,\"1159\":1,\"1164\":1,\"1165\":1,\"1167\":1}}],[\"setup\",{\"1\":{\"988\":1,\"990\":1,\"1213\":1,\"1216\":1}}],[\"setuncancellable\",{\"1\":{\"740\":2,\"743\":1}}],[\"setgroupingcomparatorclass\",{\"1\":{\"974\":1}}],[\"setnx\",{\"1\":{\"1141\":1,\"1149\":1,\"1206\":6}}],[\"setnumreducetask\",{\"1\":{\"977\":1}}],[\"setnumreducetasks\",{\"1\":{\"968\":1,\"973\":2,\"985\":1,\"986\":1,\"988\":1,\"990\":1,\"991\":1}}],[\"setname\",{\"1\":{\"52\":3,\"54\":3,\"1160\":1}}],[\"setresourceresolvers\",{\"1\":{\"1432\":1}}],[\"setresulttype\",{\"1\":{\"1147\":1,\"1156\":1}}],[\"setreducerclass\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setreturnvalue\",{\"1\":{\"734\":1}}],[\"setbasedir\",{\"1\":{\"1449\":1}}],[\"setbasename\",{\"1\":{\"1244\":1}}],[\"setbalancerbandwidth\",{\"1\":{\"873\":2,\"878\":1}}],[\"setbit\",{\"1\":{\"1174\":1,\"1175\":2}}],[\"setbegintime\",{\"1\":{\"1133\":1,\"1156\":1}}],[\"setbyte\",{\"1\":{\"776\":2}}],[\"setblockdatamode\",{\"1\":{\"69\":1}}],[\"set<class<\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"set<zsetoperations\",{\"1\":{\"1168\":1}}],[\"set<long>\",{\"1\":{\"999\":1}}],[\"set<selectionkey>\",{\"1\":{\"834\":1,\"836\":1,\"846\":1}}],[\"set<string>\",{\"1\":{\"701\":2,\"702\":1,\"704\":2,\"733\":1,\"1162\":1,\"1165\":1}}],[\"set<object>\",{\"1\":{\"42\":1}}],[\"set的底层实现\",{\"1\":{\"518\":1}}],[\"set等函数\",{\"1\":{\"383\":1}}],[\"set\",{\"1\":{\"261\":2,\"266\":1,\"268\":6,\"271\":1,\"276\":6,\"278\":3,\"279\":7,\"280\":2,\"289\":2,\"297\":6,\"298\":7,\"302\":1,\"313\":1,\"336\":3,\"373\":1,\"433\":7,\"435\":4,\"436\":1,\"437\":1,\"438\":2,\"444\":1,\"446\":2,\"450\":5,\"453\":1,\"457\":3,\"470\":5,\"483\":1,\"515\":3,\"519\":2,\"658\":1,\"701\":1,\"702\":4,\"710\":3,\"740\":1,\"743\":1,\"760\":2,\"761\":2,\"762\":2,\"763\":2,\"764\":2,\"772\":1,\"958\":1,\"960\":1,\"963\":2,\"972\":5,\"973\":1,\"974\":2,\"983\":1,\"985\":3,\"986\":1,\"988\":7,\"990\":1,\"999\":5,\"1046\":1,\"1101\":1,\"1122\":1,\"1124\":2,\"1127\":2,\"1128\":1,\"1129\":7,\"1133\":1,\"1136\":1,\"1137\":2,\"1141\":1,\"1146\":5,\"1155\":2,\"1156\":1,\"1157\":1,\"1205\":2,\"1206\":6,\"1211\":4,\"1213\":1,\"1221\":1,\"1223\":2,\"1294\":2}}],[\"set则是需要借助一个共享变量来实现互斥\",{\"1\":{\"170\":1}}],[\"setf\",{\"1\":{\"1294\":6}}],[\"setfollowuserid\",{\"1\":{\"1164\":1,\"1165\":1}}],[\"setfieldvalueeditor\",{\"1\":{\"1107\":1}}],[\"setfacl\",{\"1\":{\"926\":5}}],[\"setfailure\",{\"1\":{\"738\":1,\"740\":3,\"756\":1,\"759\":1,\"762\":1,\"763\":1,\"764\":1}}],[\"setfans\",{\"1\":{\"76\":1}}],[\"setframe\",{\"1\":{\"14\":3}}],[\"setapplicationcontext\",{\"1\":{\"1285\":1}}],[\"setattribute\",{\"1\":{\"701\":1,\"1099\":2,\"1101\":1}}],[\"setaccessible\",{\"1\":{\"68\":1,\"565\":1}}],[\"setaddress\",{\"1\":{\"54\":1,\"1150\":1}}],[\"setcharat\",{\"1\":{\"799\":2}}],[\"setchanneloptions\",{\"1\":{\"740\":1,\"743\":1}}],[\"setclosed\",{\"1\":{\"740\":2,\"743\":2}}],[\"setconnector\",{\"1\":{\"1449\":1}}],[\"setconnectionfactory\",{\"1\":{\"1222\":1}}],[\"setcontenttype\",{\"1\":{\"1416\":1}}],[\"setcombinerclass\",{\"1\":{\"970\":1}}],[\"setcompany\",{\"1\":{\"76\":1}}],[\"setcorepoolsize\",{\"1\":{\"574\":1}}],[\"setcallbacks\",{\"1\":{\"1317\":1}}],[\"setcallback\",{\"1\":{\"60\":1}}],[\"setcpu\",{\"1\":{\"17\":1,\"74\":3}}],[\"setminidle\",{\"1\":{\"1215\":1}}],[\"setmintime\",{\"1\":{\"1168\":1}}],[\"setmaxwaitmillis\",{\"1\":{\"1215\":1}}],[\"setmaxidle\",{\"1\":{\"1215\":1}}],[\"setmaxtotal\",{\"1\":{\"1215\":1}}],[\"setmapoutputvalueclass\",{\"1\":{\"962\":4,\"972\":1,\"973\":1,\"974\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setmapoutputkeyclass\",{\"1\":{\"962\":4,\"972\":1,\"973\":1,\"974\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setmapperclass\",{\"1\":{\"962\":2,\"972\":1,\"973\":1,\"974\":1,\"985\":1,\"986\":1,\"988\":1,\"991\":2}}],[\"setmainboard\",{\"1\":{\"17\":1}}],[\"setmemory\",{\"1\":{\"17\":1,\"74\":3}}],[\"setsql\",{\"1\":{\"1134\":1,\"1135\":1,\"1136\":2,\"1137\":3,\"1157\":1,\"1161\":3,\"1162\":2}}],[\"setsuccess\",{\"1\":{\"738\":1,\"756\":1,\"759\":1,\"760\":1,\"761\":1}}],[\"setsuperclass\",{\"1\":{\"60\":1}}],[\"setsequenceid\",{\"1\":{\"723\":1,\"733\":1,\"734\":1}}],[\"setseat\",{\"1\":{\"14\":3}}],[\"setsize宏定义\",{\"1\":{\"680\":1}}],[\"setsize设置\",{\"1\":{\"680\":1}}],[\"sets\",{\"0\":{\"353\":1},\"1\":{\"352\":1,\"353\":2}}],[\"setstock\",{\"1\":{\"1133\":1,\"1156\":1}}],[\"setstring\",{\"1\":{\"985\":2}}],[\"setstatus\",{\"1\":{\"1100\":1,\"1111\":1}}],[\"setstate\",{\"1\":{\"591\":1}}],[\"setstar\",{\"1\":{\"76\":1}}],[\"setstu\",{\"1\":{\"54\":3}}],[\"setscreen\",{\"1\":{\"17\":1}}],[\"se\",{\"1\":{\"9\":1}}],[\"st\",{\"1\":{\"923\":1}}],[\"sticky\",{\"1\":{\"920\":1}}],[\"stime的范围过滤可以走row\",{\"1\":{\"437\":1}}],[\"stime\",{\"1\":{\"374\":1,\"395\":1,\"396\":3,\"437\":9}}],[\"stdout=org\",{\"1\":{\"1022\":1}}],[\"stdout\",{\"1\":{\"1022\":3}}],[\"std\",{\"1\":{\"646\":1,\"669\":1}}],[\"stdc++\",{\"1\":{\"646\":1,\"669\":1}}],[\"stmtid\",{\"1\":{\"293\":1}}],[\"step7\",{\"1\":{\"1445\":1}}],[\"step6\",{\"1\":{\"1445\":1}}],[\"step5\",{\"1\":{\"1445\":1}}],[\"step4\",{\"1\":{\"281\":1,\"979\":1,\"1445\":1}}],[\"step3\",{\"1\":{\"266\":1,\"268\":1,\"280\":1,\"281\":2,\"979\":1,\"980\":1,\"1445\":1}}],[\"step2\",{\"1\":{\"266\":1,\"268\":1,\"280\":1,\"281\":2,\"348\":1,\"979\":2,\"980\":1}}],[\"step1\",{\"1\":{\"266\":1,\"268\":1,\"280\":1,\"281\":2,\"348\":1,\"979\":3,\"980\":1}}],[\"stockkey\",{\"1\":{\"1156\":5}}],[\"stock=\",{\"1\":{\"1135\":1,\"1136\":2,\"1137\":1}}],[\"stock\",{\"1\":{\"1133\":1,\"1134\":2,\"1135\":1,\"1136\":8,\"1137\":13,\"1156\":2,\"1157\":6}}],[\"storm\",{\"1\":{\"951\":1}}],[\"stored\",{\"1\":{\"267\":1,\"268\":1,\"276\":1,\"290\":2,\"296\":1,\"298\":1,\"374\":1,\"397\":1,\"437\":2}}],[\"store\",{\"0\":{\"225\":1},\"1\":{\"92\":1}}],[\"stoped\",{\"1\":{\"692\":1}}],[\"stop\",{\"1\":{\"536\":2,\"571\":1,\"878\":1,\"879\":1,\"910\":1,\"991\":1,\"1055\":1,\"1197\":1}}],[\"stop标志\",{\"1\":{\"147\":1}}],[\"stable\",{\"1\":{\"956\":1,\"968\":1}}],[\"standby\",{\"1\":{\"886\":1}}],[\"standardservletmultipartresolver\",{\"1\":{\"1461\":1}}],[\"standardopenoption\",{\"1\":{\"857\":1}}],[\"standardconfigdatalocationresolver\",{\"1\":{\"1444\":1}}],[\"standardcopyoption\",{\"1\":{\"822\":4}}],[\"standardcharsets\",{\"1\":{\"723\":2,\"805\":2,\"848\":1}}],[\"stamp别修改过了\",{\"1\":{\"590\":1}}],[\"stamp\",{\"1\":{\"590\":12}}],[\"stampedlock的缺点\",{\"1\":{\"590\":1}}],[\"stampedlock支持tryoptimisticread\",{\"1\":{\"590\":1}}],[\"stampedlock\",{\"0\":{\"590\":1}}],[\"stage内容\",{\"1\":{\"442\":1}}],[\"stage依赖关系\",{\"1\":{\"442\":1}}],[\"stages\",{\"1\":{\"442\":2}}],[\"stats\",{\"1\":{\"457\":1}}],[\"stats=true\",{\"1\":{\"457\":2}}],[\"stat\",{\"1\":{\"374\":1}}],[\"state=1\",{\"1\":{\"1151\":1}}],[\"state=0\",{\"1\":{\"1151\":1}}],[\"statemap\",{\"1\":{\"973\":7}}],[\"statementname\",{\"1\":{\"483\":1}}],[\"statement2\",{\"1\":{\"290\":1}}],[\"statement\",{\"1\":{\"286\":2,\"290\":1,\"293\":1,\"315\":3}}],[\"statement1\",{\"1\":{\"286\":2,\"290\":1}}],[\"statepartitioner\",{\"1\":{\"973\":2}}],[\"state再次设置为0\",{\"1\":{\"591\":1}}],[\"state枚举描述的\",{\"1\":{\"538\":1}}],[\"state\",{\"1\":{\"265\":3,\"266\":1,\"271\":2,\"303\":5,\"307\":6,\"310\":2,\"369\":1,\"588\":1,\"591\":1,\"707\":2,\"973\":1,\"974\":8,\"1151\":2}}],[\"statusenum\",{\"1\":{\"615\":6,\"619\":1}}],[\"status\",{\"1\":{\"132\":1,\"962\":2,\"988\":2,\"1197\":1}}],[\"statistics\",{\"1\":{\"458\":2}}],[\"station\",{\"1\":{\"58\":2,\"59\":8}}],[\"static\",{\"1\":{\"6\":1,\"7\":1,\"14\":2,\"17\":3,\"22\":8,\"30\":1,\"42\":3,\"43\":1,\"47\":1,\"51\":1,\"52\":1,\"54\":2,\"58\":1,\"59\":9,\"60\":1,\"66\":17,\"68\":9,\"69\":5,\"70\":3,\"73\":1,\"74\":1,\"81\":7,\"85\":1,\"344\":1,\"536\":1,\"541\":3,\"551\":1,\"554\":8,\"555\":13,\"562\":1,\"574\":3,\"579\":5,\"595\":1,\"614\":2,\"615\":1,\"617\":2,\"645\":2,\"648\":2,\"668\":5,\"692\":4,\"696\":3,\"697\":2,\"698\":2,\"699\":2,\"702\":2,\"717\":1,\"718\":2,\"723\":24,\"725\":1,\"726\":2,\"733\":9,\"735\":1,\"737\":6,\"738\":1,\"740\":1,\"748\":1,\"749\":1,\"754\":1,\"766\":2,\"768\":1,\"775\":1,\"776\":1,\"795\":2,\"796\":1,\"799\":12,\"809\":2,\"820\":1,\"822\":1,\"834\":2,\"836\":1,\"839\":2,\"840\":2,\"843\":2,\"846\":3,\"848\":2,\"857\":1,\"859\":5,\"958\":1,\"962\":2,\"972\":1,\"973\":3,\"974\":1,\"985\":1,\"986\":1,\"988\":3,\"991\":1,\"999\":11,\"1071\":5,\"1101\":4,\"1113\":3,\"1128\":1,\"1129\":1,\"1132\":2,\"1142\":1,\"1144\":1,\"1147\":2,\"1156\":2,\"1157\":1,\"1215\":3,\"1223\":1,\"1244\":1,\"1257\":3,\"1285\":1,\"1294\":2,\"1304\":2,\"1306\":2,\"1309\":4,\"1317\":1,\"1429\":1,\"1432\":1,\"1435\":1,\"1449\":1,\"1464\":4,\"1466\":2,\"1480\":1,\"1515\":1,\"1525\":1}}],[\"started\",{\"1\":{\"1444\":1}}],[\"starters提供的依赖\",{\"1\":{\"1524\":1}}],[\"starter导入包\",{\"1\":{\"1523\":1}}],[\"starter有什么用\",{\"0\":{\"1521\":1},\"1\":{\"1523\":1}}],[\"starter<\",{\"1\":{\"1070\":1,\"1236\":2}}],[\"starter\",{\"1\":{\"1022\":2,\"1070\":1,\"1087\":2,\"1172\":1,\"1219\":3,\"1221\":1,\"1521\":1}}],[\"startswith\",{\"1\":{\"988\":2}}],[\"startindex\",{\"1\":{\"799\":3}}],[\"starting\",{\"1\":{\"290\":1,\"1444\":1}}],[\"startthread\",{\"1\":{\"741\":1}}],[\"starttime\",{\"1\":{\"407\":1,\"408\":1,\"409\":4,\"999\":2}}],[\"start是启动线程作用是将线程变为就绪状态\",{\"1\":{\"532\":1}}],[\"start\",{\"0\":{\"532\":1},\"1\":{\"483\":3,\"532\":1,\"536\":3,\"551\":2,\"554\":6,\"555\":6,\"692\":2,\"702\":1,\"750\":2,\"751\":2,\"754\":1,\"759\":1,\"760\":2,\"761\":2,\"762\":2,\"763\":2,\"764\":2,\"794\":1,\"795\":4,\"799\":1,\"820\":2,\"823\":2,\"846\":9,\"878\":1,\"910\":1,\"936\":1,\"991\":1,\"1012\":2,\"1045\":1,\"1046\":1,\"1197\":1,\"1440\":2,\"1449\":1}}],[\"star\",{\"1\":{\"76\":11,\"1209\":1}}],[\"study\",{\"1\":{\"81\":5,\"985\":1,\"986\":1}}],[\"students\",{\"1\":{\"280\":1,\"287\":1,\"340\":1,\"351\":1}}],[\"student\",{\"1\":{\"54\":12,\"268\":2,\"276\":12,\"279\":3,\"287\":6,\"288\":5,\"289\":4,\"290\":3,\"298\":4,\"303\":1,\"313\":2,\"315\":4,\"316\":3,\"317\":3,\"318\":9,\"340\":4,\"351\":16,\"367\":2,\"368\":3,\"766\":17}}],[\"stu对象和stu1对象是同一个对象\",{\"1\":{\"54\":1}}],[\"stu和stu1是同一个对象\",{\"1\":{\"54\":2}}],[\"stu1\",{\"1\":{\"54\":6}}],[\"stu\",{\"1\":{\"54\":12,\"369\":1}}],[\"strutil\",{\"1\":{\"1111\":1,\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":3,\"1162\":1,\"1168\":1,\"1172\":1}}],[\"struct\",{\"1\":{\"351\":5,\"663\":5,\"669\":1}}],[\"structure\",{\"1\":{\"279\":2}}],[\"struct结构\",{\"1\":{\"248\":1}}],[\"strcat\",{\"1\":{\"662\":5,\"663\":1}}],[\"strhandler\",{\"1\":{\"614\":3}}],[\"strlen\",{\"1\":{\"515\":1,\"662\":3,\"663\":1}}],[\"strn\",{\"1\":{\"336\":1}}],[\"str2\",{\"1\":{\"336\":1}}],[\"str1\",{\"1\":{\"336\":1}}],[\"str\",{\"1\":{\"336\":9,\"342\":5,\"614\":7,\"617\":4,\"668\":12}}],[\"streaming\",{\"1\":{\"1055\":1}}],[\"streams\",{\"1\":{\"716\":1}}],[\"streams就是为了解决该问题\",{\"1\":{\"716\":1}}],[\"streams为我们提供了java中的reactive\",{\"1\":{\"716\":1}}],[\"streamstream\",{\"1\":{\"617\":2}}],[\"stream<character>\",{\"1\":{\"617\":2}}],[\"stream<stream<character>>\",{\"1\":{\"617\":1}}],[\"stream\",{\"0\":{\"615\":1,\"850\":1},\"1\":{\"616\":1,\"617\":3,\"618\":1,\"619\":2,\"620\":3,\"621\":6,\"717\":1,\"718\":1,\"850\":2,\"851\":1,\"861\":3,\"1162\":2,\"1165\":2,\"1171\":1,\"1172\":1,\"1482\":1}}],[\"streamtable\",{\"1\":{\"326\":1}}],[\"streamdecoder不是java\",{\"1\":{\"9\":1}}],[\"streamdecoder类的同名方法的调用封装\",{\"1\":{\"9\":1}}],[\"streamdecoder类对象\",{\"1\":{\"9\":1}}],[\"street\",{\"1\":{\"320\":3,\"323\":2}}],[\"striky\",{\"1\":{\"1042\":2}}],[\"strict\",{\"1\":{\"1236\":1}}],[\"strict严格模式要求至少有一个分区为静态分区\",{\"1\":{\"261\":1}}],[\"stricky\",{\"0\":{\"1042\":1}}],[\"string结构是将对象序列化为json字符串后存储\",{\"1\":{\"1208\":1}}],[\"string的常见命令有\",{\"1\":{\"1206\":1}}],[\"string类型\",{\"1\":{\"1206\":1}}],[\"string命令\",{\"0\":{\"1206\":1}}],[\"stringredistemplate\",{\"0\":{\"1223\":1},\"1\":{\"1100\":3,\"1107\":3,\"1111\":8,\"1129\":4,\"1132\":7,\"1133\":1,\"1162\":1,\"1167\":1,\"1223\":7,\"1224\":5}}],[\"stringdeserializer\",{\"1\":{\"1024\":2}}],[\"stringdecoder\",{\"1\":{\"784\":1}}],[\"stringserializer\",{\"1\":{\"1023\":2}}],[\"stringutil\",{\"1\":{\"799\":1}}],[\"stringutils\",{\"1\":{\"344\":1,\"1234\":1,\"1235\":2}}],[\"stringencoder\",{\"1\":{\"753\":4,\"754\":1,\"766\":1,\"785\":1,\"794\":1}}],[\"stringpropertynames\",{\"1\":{\"733\":1}}],[\"string>\",{\"1\":{\"718\":1,\"990\":1,\"1023\":1,\"1024\":2,\"1025\":2,\"1213\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"566\":3}}],[\"string|char|varchar\",{\"1\":{\"342\":1}}],[\"stringbuilder\",{\"1\":{\"47\":2,\"768\":2,\"799\":12,\"843\":2,\"988\":2,\"1232\":2}}],[\"string\",{\"1\":{\"6\":14,\"7\":3,\"14\":7,\"17\":32,\"23\":1,\"28\":1,\"30\":1,\"34\":2,\"42\":4,\"43\":2,\"47\":1,\"51\":1,\"52\":4,\"54\":10,\"58\":1,\"59\":4,\"60\":1,\"68\":2,\"70\":2,\"73\":1,\"74\":4,\"76\":9,\"81\":6,\"85\":1,\"256\":1,\"260\":5,\"261\":5,\"262\":3,\"265\":3,\"266\":3,\"268\":1,\"272\":9,\"276\":2,\"279\":4,\"280\":4,\"281\":5,\"287\":4,\"288\":1,\"289\":3,\"298\":1,\"329\":1,\"336\":3,\"340\":3,\"341\":1,\"342\":4,\"343\":3,\"344\":5,\"348\":1,\"351\":3,\"352\":3,\"357\":3,\"359\":5,\"373\":2,\"374\":13,\"378\":1,\"382\":2,\"385\":3,\"388\":1,\"391\":3,\"395\":1,\"397\":3,\"400\":2,\"402\":2,\"404\":6,\"407\":6,\"408\":6,\"409\":6,\"483\":1,\"515\":1,\"536\":1,\"541\":1,\"551\":1,\"554\":3,\"555\":3,\"562\":1,\"566\":2,\"614\":10,\"617\":2,\"623\":1,\"624\":1,\"645\":1,\"648\":2,\"661\":2,\"668\":4,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"701\":14,\"702\":8,\"703\":3,\"704\":1,\"717\":1,\"718\":3,\"723\":3,\"725\":1,\"726\":2,\"733\":7,\"735\":3,\"737\":1,\"748\":2,\"754\":2,\"766\":4,\"776\":1,\"784\":2,\"785\":1,\"794\":1,\"795\":4,\"796\":1,\"799\":8,\"809\":1,\"820\":3,\"822\":1,\"823\":3,\"834\":2,\"836\":1,\"839\":3,\"840\":1,\"843\":2,\"846\":1,\"848\":2,\"857\":1,\"859\":1,\"956\":1,\"958\":3,\"962\":3,\"972\":3,\"973\":2,\"974\":7,\"983\":3,\"985\":6,\"986\":2,\"988\":7,\"990\":4,\"991\":1,\"999\":4,\"1023\":1,\"1024\":3,\"1025\":2,\"1035\":1,\"1073\":3,\"1079\":2,\"1088\":1,\"1089\":3,\"1099\":4,\"1107\":5,\"1111\":2,\"1122\":1,\"1124\":1,\"1127\":3,\"1128\":2,\"1129\":15,\"1132\":2,\"1142\":2,\"1144\":4,\"1156\":3,\"1157\":1,\"1159\":2,\"1161\":3,\"1162\":4,\"1165\":5,\"1167\":1,\"1168\":2,\"1171\":1,\"1172\":3,\"1174\":1,\"1175\":2,\"1176\":2,\"1180\":2,\"1206\":2,\"1213\":2,\"1222\":2,\"1223\":2,\"1230\":2,\"1232\":1,\"1234\":1,\"1244\":1,\"1257\":1,\"1304\":1,\"1306\":1,\"1309\":1,\"1317\":1,\"1368\":2,\"1369\":1,\"1394\":1,\"1441\":1,\"1449\":1,\"1464\":3,\"1505\":6,\"1525\":10,\"1526\":1,\"1531\":1}}],[\"strat只能调用一次\",{\"1\":{\"532\":1}}],[\"strategy角色负责决定实现策略所必需的接口\",{\"1\":{\"80\":1}}],[\"strategy\",{\"1\":{\"80\":1,\"81\":13,\"1040\":1,\"1041\":1}}],[\"strategy模式却特意将算法与其他部分分离开\",{\"1\":{\"79\":1}}],[\"strategy模式篇\",{\"1\":{\"78\":1}}],[\"strangers\",{\"1\":{\"76\":1}}],[\"sdiff\",{\"1\":{\"1210\":3}}],[\"sdshdr64\",{\"1\":{\"663\":2}}],[\"sdshdr32\",{\"1\":{\"663\":5}}],[\"sdshdr16\",{\"1\":{\"663\":6}}],[\"sdshdr8\",{\"1\":{\"663\":2}}],[\"sdshdr5\",{\"1\":{\"663\":2}}],[\"sds\",{\"0\":{\"661\":1,\"663\":1},\"1\":{\"661\":3,\"662\":1,\"663\":28}}],[\"sdept\",{\"1\":{\"276\":10,\"289\":2}}],[\"sdadaptertf\",{\"1\":{\"6\":3,\"7\":5}}],[\"sd兼容tf\",{\"1\":{\"6\":1,\"7\":1}}],[\"sd\",{\"1\":{\"6\":4,\"9\":2}}],[\"sd卡实现类\",{\"1\":{\"6\":1}}],[\"sd卡的接口\",{\"1\":{\"6\":1}}],[\"sdcardimpl\",{\"1\":{\"6\":2,\"7\":1}}],[\"sdcard\",{\"1\":{\"6\":10,\"7\":4}}],[\"读流程\",{\"1\":{\"1051\":1}}],[\"读流程与写流程类型\",{\"1\":{\"935\":1}}],[\"读权限\",{\"1\":{\"918\":1}}],[\"读事件由\",{\"1\":{\"859\":1}}],[\"读指针向后走\",{\"1\":{\"803\":1}}],[\"读模式\",{\"1\":{\"796\":1}}],[\"读到字节数\",{\"1\":{\"796\":4}}],[\"读不会阻塞写\",{\"1\":{\"795\":1}}],[\"读和写是可以同时进行的\",{\"1\":{\"795\":1}}],[\"读和写的误解💡\",{\"0\":{\"795\":1}}],[\"读和写等\",{\"1\":{\"211\":1}}],[\"读\",{\"0\":{\"918\":1},\"1\":{\"787\":1,\"809\":1,\"840\":1}}],[\"读写数据\",{\"1\":{\"1048\":1}}],[\"读写\",{\"1\":{\"855\":1}}],[\"读写能力\",{\"1\":{\"854\":1}}],[\"读写效率高\",{\"1\":{\"801\":1}}],[\"读写效率较低\",{\"1\":{\"801\":1}}],[\"读写才不会相互阻塞\",{\"1\":{\"795\":1}}],[\"读写指针分离\",{\"1\":{\"781\":1}}],[\"读写锁之间\",{\"1\":{\"510\":1}}],[\"读过的内容\",{\"1\":{\"774\":1}}],[\"读空闲时间过长\",{\"1\":{\"707\":2}}],[\"读锁不能升级为写锁\",{\"1\":{\"589\":1}}],[\"读锁之间不互斥\",{\"1\":{\"510\":1}}],[\"读屏障会确保指令重排序时\",{\"1\":{\"557\":1}}],[\"读屏障保证在该屏障之后\",{\"1\":{\"557\":1}}],[\"读操作\",{\"1\":{\"209\":3}}],[\"读操作是线程安全的\",{\"1\":{\"66\":1}}],[\"读文件\",{\"1\":{\"199\":1}}],[\"读前须知\",{\"0\":{\"148\":1}}],[\"读取比较简单的配置信息\",{\"1\":{\"1525\":1}}],[\"读取自动配置类名\",{\"1\":{\"1464\":1}}],[\"读取redis时\",{\"1\":{\"1223\":1}}],[\"读取第二页传入的参数是page=2\",{\"1\":{\"1167\":1}}],[\"读取分布式缓存文件\",{\"1\":{\"990\":1}}],[\"读取的数据首先由mapper处理\",{\"1\":{\"984\":1}}],[\"读取的最小单位\",{\"1\":{\"693\":1}}],[\"读取split返回<key\",{\"1\":{\"979\":1}}],[\"读取sd卡方法\",{\"1\":{\"6\":1}}],[\"读取一行数据\",{\"1\":{\"979\":1}}],[\"读取一行数据进行切割\",{\"1\":{\"972\":1}}],[\"读取解密文件的过程\",{\"0\":{\"935\":1}}],[\"读取数据组件inputformat\",{\"1\":{\"979\":1}}],[\"读取数据填充\",{\"1\":{\"814\":1}}],[\"读取数据\",{\"0\":{\"803\":1},\"1\":{\"797\":1}}],[\"读取数据时\",{\"1\":{\"527\":1}}],[\"读取完成\",{\"1\":{\"787\":1}}],[\"读取完毕后需要做一次戳校验\",{\"1\":{\"590\":1}}],[\"读取\",{\"0\":{\"774\":1,\"814\":1},\"1\":{\"744\":1,\"798\":1}}],[\"读取1号盘面的0扇区时无法立即开始读\",{\"1\":{\"205\":1}}],[\"读取len个字节数据\",{\"1\":{\"88\":1}}],[\"读取对象\",{\"1\":{\"54\":1}}],[\"读取tf卡方法\",{\"1\":{\"6\":1}}],[\"读卡器\",{\"1\":{\"6\":1,\"7\":1}}],[\"读卡器等\",{\"1\":{\"4\":1}}],[\"而实现依赖注入的关键是ioc容器\",{\"1\":{\"1500\":1}}],[\"而实现了cloneable接口的子实现类就是具体的原型类\",{\"1\":{\"51\":1}}],[\"而内嵌\",{\"1\":{\"1442\":1}}],[\"而内存的扩大\",{\"1\":{\"637\":1}}],[\"而$\",{\"1\":{\"1230\":1}}],[\"而springdataredis又对这两种做了抽象和封装\",{\"1\":{\"1212\":1}}],[\"而synchronized关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"558\":1}}],[\"而value的形式多种多样\",{\"1\":{\"1182\":1}}],[\"而如果是普通的粉丝\",{\"1\":{\"1166\":1}}],[\"而如果使用建造者模式\",{\"1\":{\"19\":1}}],[\"而万一在同步过去之前\",{\"1\":{\"1149\":1}}],[\"而现在是插入数据\",{\"1\":{\"1137\":1}}],[\"而对于加锁\",{\"1\":{\"1135\":1}}],[\"而对象的创建是在静态代码块中\",{\"1\":{\"66\":1}}],[\"而特价券需要秒杀抢购\",{\"1\":{\"1133\":1}}],[\"而订单表如果使用数据库自增id就存在一些问题\",{\"1\":{\"1131\":1}}],[\"而线程1执行过程中\",{\"1\":{\"1143\":1}}],[\"而线程1直接进行返回\",{\"1\":{\"1126\":1}}],[\"而线程对象是通过强引用指向threadlocalmap\",{\"1\":{\"577\":1}}],[\"而缓存却没有同步\",{\"1\":{\"1120\":1}}],[\"而数据库的数据是会发生变化的\",{\"1\":{\"1120\":1}}],[\"而数据库字段必须加is\",{\"1\":{\"483\":1}}],[\"而代金券由于优惠力度大\",{\"1\":{\"1133\":1}}],[\"而代码运行在内存中\",{\"1\":{\"1114\":1}}],[\"而代理类是程序在运行过程中动态的在内存中生成的类\",{\"1\":{\"59\":1}}],[\"而代理模式\",{\"1\":{\"10\":1}}],[\"而任一节点都可能没有这样大的磁盘空间\",{\"1\":{\"1066\":1}}],[\"而json是一个到处存在的互联网数据交互格式\",{\"1\":{\"1063\":1}}],[\"而言\",{\"1\":{\"997\":1,\"1151\":1}}],[\"而dboutputformat负责把数据最终写入数据库中\",{\"1\":{\"984\":1}}],[\"而逻辑切片的大小默认与block\",{\"1\":{\"976\":1}}],[\"而逻辑上的对应物是用户感受到的\",{\"1\":{\"155\":1}}],[\"而它们本身作为一个框架提供了编程接口供用户使用\",{\"1\":{\"951\":1}}],[\"而hdfs服务端只能接触到edek\",{\"1\":{\"934\":1}}],[\"而hdfs上又不支持对文件的任意修改\",{\"1\":{\"292\":1}}],[\"而kms里存储的ez\",{\"1\":{\"934\":1}}],[\"而w权限才能写入或追加到文件\",{\"1\":{\"918\":1}}],[\"而wait\",{\"1\":{\"549\":1}}],[\"而发生变更的inode数据才会被快照额外拷贝\",{\"1\":{\"913\":1}}],[\"而较高的值表示节点具有更倾斜的数据分布\",{\"1\":{\"874\":1}}],[\"而之前的\",{\"1\":{\"861\":1}}],[\"而后面要讲的\",{\"1\":{\"766\":1}}],[\"而提交的任务会被包装为\",{\"1\":{\"765\":1}}],[\"而reactive\",{\"1\":{\"716\":1}}],[\"而redo\",{\"1\":{\"506\":1}}],[\"而reducejoin必须经过shuffle过程\",{\"1\":{\"418\":1}}],[\"而意思却是完全不同\",{\"1\":{\"709\":1}}],[\"而非真正的视图对象\",{\"1\":{\"1530\":1}}],[\"而非未来\",{\"1\":{\"1525\":1}}],[\"而非关系型数据库往往不支持事务\",{\"1\":{\"1188\":1}}],[\"而非关系型数据库不存在关联关系\",{\"1\":{\"1186\":1}}],[\"而非分\",{\"1\":{\"692\":1}}],[\"而非加强功能\",{\"1\":{\"10\":1}}],[\"而需把它们调入内存\",{\"1\":{\"690\":1}}],[\"而分页存储管理不能提供虚存\",{\"1\":{\"689\":1}}],[\"而分桶由于smb\",{\"1\":{\"420\":1}}],[\"而仅需将那些当前要运行的少数页面或段先装入内存便可运行\",{\"1\":{\"688\":1}}],[\"而物理地址指的是真实物理内存中的地址\",{\"1\":{\"684\":1}}],[\"而物化视图的目的是提高查询性能\",{\"1\":{\"275\":1}}],[\"而段的大小不固定\",{\"1\":{\"683\":1}}],[\"而跟连接总数无关\",{\"1\":{\"680\":1}}],[\"而异步io则无需自己负责进行读写\",{\"1\":{\"680\":1}}],[\"而另一方面\",{\"1\":{\"679\":1}}],[\"而这些文件描述符\",{\"1\":{\"679\":1}}],[\"而同时\",{\"1\":{\"679\":1}}],[\"而扩展功能受某些情况影响可能会失效\",{\"1\":{\"1284\":1}}],[\"而扩展\",{\"1\":{\"666\":1}}],[\"而当新插入的元素较大时\",{\"1\":{\"666\":1}}],[\"而查找其他元素时\",{\"1\":{\"665\":1}}],[\"而无须执行内存分配\",{\"1\":{\"663\":1}}],[\"而无须知道其内部的具体构造细节\",{\"1\":{\"12\":1}}],[\"而字符数组的结尾位置就用\",{\"1\":{\"662\":1}}],[\"而引导类加载器在加载的过程中会先加载jdk自带的文件\",{\"1\":{\"624\":1}}],[\"而抽象类的成员变量默认default\",{\"1\":{\"595\":1}}],[\"而抽象工厂模式可生产多个等级的产品\",{\"1\":{\"37\":1}}],[\"而thread\",{\"1\":{\"591\":1}}],[\"而test\",{\"1\":{\"170\":1}}],[\"而nosql则对数据库格式没有严格约束\",{\"1\":{\"1185\":1}}],[\"而nosql则是相对于传统关系型数据库而言\",{\"1\":{\"1182\":1}}],[\"而non\",{\"1\":{\"679\":1}}],[\"而notify只能随机唤醒一个等待线程\",{\"1\":{\"549\":1}}],[\"而nio基于channel和buffer进行操作\",{\"1\":{\"612\":1}}],[\"而nio是非阻塞的\",{\"1\":{\"612\":1}}],[\"而nio以块\",{\"1\":{\"612\":1}}],[\"而newsinglethreadexecutor线程池还会新建一个线程\",{\"1\":{\"574\":1}}],[\"而导致代码一直在运行\",{\"1\":{\"552\":1}}],[\"而park和unpark不必\",{\"1\":{\"549\":1}}],[\"而p0又不需要访问\",{\"1\":{\"169\":1}}],[\"而消费者专心处理结果数据\",{\"1\":{\"548\":1}}],[\"而键值对读写命令仍然是单线程处理的\",{\"1\":{\"516\":1}}],[\"而其他的持久化\",{\"1\":{\"516\":1}}],[\"而其中为每个stripe建立的包含min\",{\"1\":{\"437\":1}}],[\"而innodb同时支持表锁和行锁\",{\"1\":{\"506\":1}}],[\"而此时的\",{\"1\":{\"1285\":1}}],[\"而此时新的master中实际上并没有锁信息\",{\"1\":{\"1153\":1}}],[\"而此时buffer\",{\"1\":{\"506\":1}}],[\"而此时我们只需要继承该抽象类即可\",{\"1\":{\"7\":1}}],[\"而一旦命中后\",{\"1\":{\"1128\":1}}],[\"而一旦这个假定不成立\",{\"1\":{\"662\":1}}],[\"而一致性则由表级锁来保证\",{\"1\":{\"497\":1}}],[\"而一直没有使用就会造成内存的浪费\",{\"1\":{\"66\":1}}],[\"而树型的依然能够保持o\",{\"1\":{\"491\":1}}],[\"而blocking\",{\"1\":{\"679\":1}}],[\"而bio是单向的\",{\"1\":{\"610\":1}}],[\"而b\",{\"1\":{\"488\":1}}],[\"而只是叶子节点中关键字的索引\",{\"1\":{\"488\":1}}],[\"而count\",{\"1\":{\"482\":2}}],[\"而覆盖索引只是一种查询的一种效果\",{\"1\":{\"481\":1}}],[\"而矢量化查询执行是一种hive针对orc文件操作的特性\",{\"1\":{\"438\":1}}],[\"而在用户进程这边\",{\"1\":{\"679\":1}}],[\"而在b树中则需要通过中序遍历才能完成范围查询\",{\"1\":{\"488\":1}}],[\"而在jvm启动时内存开销大\",{\"1\":{\"445\":1}}],[\"而在第二个连接条件中使用了b中的key2列\",{\"1\":{\"326\":1}}],[\"而在微观上交替使用\",{\"1\":{\"213\":1}}],[\"而视图只是创建一个虚表\",{\"1\":{\"275\":1}}],[\"而外部表不会\",{\"1\":{\"258\":1}}],[\"而表相关的元数据是存储在rdbms中\",{\"1\":{\"235\":1}}],[\"而频繁的中断处理会消耗较多的cpu时间\",{\"1\":{\"209\":1}}],[\"而转速是硬件固有的属性\",{\"1\":{\"204\":1}}],[\"而读取又分为两个阶段\",{\"1\":{\"851\":1}}],[\"而读取配置文件以及创建对象写在静态代码块中\",{\"1\":{\"42\":1}}],[\"而读\",{\"1\":{\"204\":1}}],[\"而每一个分组调用一次reduce程序\",{\"1\":{\"968\":1}}],[\"而每条undo\",{\"1\":{\"503\":1}}],[\"而每次调页都要磁盘i\",{\"1\":{\"192\":1}}],[\"而每个具体的皮肤\",{\"1\":{\"72\":1}}],[\"而aspectj基于字节码操作\",{\"1\":{\"1509\":1}}],[\"而aspectj是编译时或者类加载时增强\",{\"1\":{\"1509\":1}}],[\"而a\",{\"1\":{\"190\":1}}],[\"而系统负荷降低就暂停\",{\"1\":{\"181\":1}}],[\"而该资源又被其他进程占有\",{\"1\":{\"175\":1}}],[\"而该安全门只具有防盗\",{\"1\":{\"75\":1}}],[\"而传统的进程只能串行的执行一系列程序\",{\"1\":{\"163\":1}}],[\"而暂时不能够运行\",{\"1\":{\"160\":1}}],[\"而我们自己的\",{\"1\":{\"748\":1}}],[\"而我们仅仅需要编写配置即可\",{\"1\":{\"91\":1}}],[\"而我们使用的插头如下图最右边的\",{\"1\":{\"4\":1}}],[\"而\",{\"1\":{\"88\":1,\"564\":1,\"663\":1,\"741\":1,\"752\":1,\"756\":1,\"766\":1,\"828\":1,\"1155\":1,\"1499\":1,\"1507\":1}}],[\"而将其他部分留在外存\",{\"1\":{\"689\":1}}],[\"而将较低的3g字节供各个进程使用\",{\"1\":{\"676\":1}}],[\"而将各段分页是对用户不可见的\",{\"1\":{\"188\":1}}],[\"而将不同的代码放入不同的子类中\",{\"1\":{\"86\":1}}],[\"而将算法的一些步骤延迟到子类中\",{\"1\":{\"83\":1}}],[\"而粉丝和媒体公司是陌生人\",{\"1\":{\"76\":1}}],[\"而软件中易变的细节可以从抽象派生来的实现类来进行扩展\",{\"1\":{\"72\":1}}],[\"而不用直接去new对象\",{\"1\":{\"1216\":1}}],[\"而不同的非关系数据库查询语法差异极大\",{\"1\":{\"1187\":1}}],[\"而不影响现有文件\",{\"1\":{\"875\":1}}],[\"而不继承其祖先的纠删码策略\",{\"1\":{\"875\":1}}],[\"而不管这样的复制是否有意义\",{\"1\":{\"680\":1}}],[\"而不能一个为\",{\"1\":{\"493\":1}}],[\"而不在hiveserver的jvm中运行\",{\"1\":{\"244\":1}}],[\"而不是期望的多例对象\",{\"1\":{\"1294\":1}}],[\"而不是直接返回nil\",{\"1\":{\"1209\":1}}],[\"而不是使用线程池或者是异步编排的方式来完成这个需求\",{\"1\":{\"1155\":1}}],[\"而不是让一个用户下多个单\",{\"1\":{\"1137\":1}}],[\"而不是让故障用不发生\",{\"1\":{\"882\":1}}],[\"而不是有数据分区导致了reducetask个数改变\",{\"1\":{\"968\":1}}],[\"而不是在多个接受者之间分配宽带\",{\"1\":{\"898\":1}}],[\"而不是一次给三个datanode拓扑式传输呢\",{\"1\":{\"898\":1}}],[\"而不是容器申请时的个数\",{\"1\":{\"847\":1}}],[\"而不是给\",{\"1\":{\"784\":1}}],[\"而不是等\",{\"1\":{\"775\":1}}],[\"而不是被socket\",{\"1\":{\"679\":1}}],[\"而不是\",{\"1\":{\"663\":1}}],[\"而不是非常准确的\",{\"1\":{\"658\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"605\":1}}],[\"而不是true\",{\"1\":{\"482\":2}}],[\"而不是false\",{\"1\":{\"482\":1}}],[\"而不是对单条记录\",{\"1\":{\"438\":1}}],[\"而不是操作系统\",{\"1\":{\"162\":1}}],[\"而不是依赖于各个组件具体的实现类\",{\"1\":{\"74\":1}}],[\"而不必关心应用程序的构建细节\",{\"1\":{\"94\":1}}],[\"而不必过多关心通信部分的细节\",{\"1\":{\"63\":1}}],[\"而不需要存储其所有值\",{\"1\":{\"1179\":1}}],[\"而不需要修改原代码\",{\"1\":{\"72\":1}}],[\"而不需要像静态代理那样每一个方法进行中转\",{\"1\":{\"61\":1}}],[\"而不需要在原代码中修改\",{\"1\":{\"29\":1}}],[\"而动态代理不会出现该问题\",{\"1\":{\"61\":1}}],[\"而动态代理代理类则是在java运行时动态生成\",{\"1\":{\"56\":1}}],[\"而是作为spring的脚手架框架\",{\"1\":{\"1520\":1}}],[\"而是用\",{\"1\":{\"1489\":1}}],[\"而是另一个\",{\"1\":{\"1472\":1}}],[\"而是每个接口会对应一个\",{\"1\":{\"1455\":1}}],[\"而是直接使用\",{\"1\":{\"1223\":1}}],[\"而是直接使用threadpoolexecutor构造方法\",{\"1\":{\"574\":1}}],[\"而是我们自己来控制序列化的动作\",{\"1\":{\"1223\":1}}],[\"而是我们后续通过逻辑去处理\",{\"1\":{\"1126\":1}}],[\"而是将jedis还回连接池的\",{\"1\":{\"1216\":1}}],[\"而是将\",{\"1\":{\"1177\":1}}],[\"而是将来由操作系统来通过回调方式由另外的线程来获得结果\",{\"1\":{\"856\":1}}],[\"而是很长的一个主键\",{\"1\":{\"1177\":1}}],[\"而是系统分析用户到底想要什么\",{\"1\":{\"1166\":1}}],[\"而是拼接一些其它信息\",{\"1\":{\"1131\":1}}],[\"而是需要当前服务器时间戳减去某一个初始时间戳值\",{\"1\":{\"1001\":1}}],[\"而是慎用\",{\"1\":{\"970\":1}}],[\"而是输出到多个文件中\",{\"1\":{\"968\":1}}],[\"而是在不会拷贝重复数据到\",{\"1\":{\"855\":1}}],[\"而是在于能处理更多的连接\",{\"1\":{\"679\":1}}],[\"而是缓存的复制\",{\"1\":{\"854\":1}}],[\"而是由其它线程送结果\",{\"1\":{\"851\":1}}],[\"而是马上就得到了一个结果\",{\"1\":{\"679\":1}}],[\"而是立刻返回一个error\",{\"1\":{\"679\":1}}],[\"而是有个专门的\",{\"1\":{\"663\":1}}],[\"而是自己封装了一个名为简单动态字符串\",{\"1\":{\"661\":1}}],[\"而是自己构建了一种简单动态字符串\",{\"1\":{\"515\":1}}],[\"而是把这个请求委托给父类的加载器去执行\",{\"1\":{\"623\":1}}],[\"而是把地址转换推迟到程序真正要执行时才进行\",{\"1\":{\"179\":1}}],[\"而是表示unsafe类中的操作不安全\",{\"1\":{\"565\":1}}],[\"而是通过\",{\"1\":{\"756\":1}}],[\"而是通过程序来实现\",{\"1\":{\"507\":1}}],[\"而是通过执行引擎处理\",{\"1\":{\"232\":1}}],[\"而是取offset+n行\",{\"1\":{\"481\":1}}],[\"而是继续供下一个task运行\",{\"1\":{\"445\":1}}],[\"而是传递给外部查询\",{\"1\":{\"317\":1}}],[\"而是允许在作业运行过程中\",{\"1\":{\"189\":1}}],[\"而是被允许分成多次调入内存\",{\"1\":{\"189\":1}}],[\"而是被动地接受来自subject角色的通知\",{\"1\":{\"45\":1}}],[\"而是会常驻内存\",{\"1\":{\"164\":1}}],[\"而是走走停停\",{\"1\":{\"155\":1}}],[\"而是首次使用该对象时才会创建\",{\"1\":{\"66\":1}}],[\"而是提供了一个创建代理对象的静态方法\",{\"1\":{\"59\":1}}],[\"而火车站在多个地方都有代售点\",{\"1\":{\"58\":1}}],[\"而进行深克隆需要使用对象流\",{\"1\":{\"54\":1}}],[\"而单列集合获取迭代器的方法就使用到了工厂方法模式\",{\"1\":{\"43\":1}}],[\"而且很多地方我们只能通过\",{\"1\":{\"1507\":1}}],[\"而且很容易引入错误\",{\"1\":{\"17\":1}}],[\"而且支持跨进程的同步机制\",{\"1\":{\"1212\":1}}],[\"而且redis官方也没有提供windows版本的安装包\",{\"1\":{\"1191\":1}}],[\"而且读取完之后可以把他的收件箱进行清楚\",{\"1\":{\"1166\":1}}],[\"而且也不用担心线程池消耗殆尽的问题\",{\"1\":{\"1155\":1}}],[\"而且你使用上述方案\",{\"1\":{\"1155\":1}}],[\"而且还是一个线程串行执行\",{\"1\":{\"1155\":1}}],[\"而且抢锁时间是默认看门狗时间\",{\"1\":{\"1152\":1}}],[\"而且已经走到了条件判断的过程中\",{\"1\":{\"1145\":1}}],[\"而且生产者生产的消息是需要在网络上传到的\",{\"1\":{\"1023\":1}}],[\"而且大数据量也导致分库分表的产生\",{\"1\":{\"997\":1}}],[\"而且分区数=reducetask数\",{\"1\":{\"973\":1}}],[\"而且脱离了任务独立存在\",{\"1\":{\"756\":1}}],[\"而且医生看病的过程中是以病人为单位的\",{\"1\":{\"755\":1}}],[\"而且无法\",{\"1\":{\"689\":1}}],[\"而且会针对不同长度的数据\",{\"1\":{\"664\":1}}],[\"而且\",{\"1\":{\"662\":1,\"663\":1,\"665\":1,\"970\":1}}],[\"而且非常消耗性能\",{\"1\":{\"606\":1}}],[\"而且哨兵模式只有一个主节点对外提供服务\",{\"1\":{\"526\":1}}],[\"而且容易产生数据倾斜\",{\"1\":{\"418\":1}}],[\"而且排序可以指定倒序排序\",{\"1\":{\"313\":1}}],[\"而且只能进行正序排序\",{\"1\":{\"313\":1}}],[\"而且这些客户端不需要知道mysql数据库的用户名和密码\",{\"1\":{\"240\":1}}],[\"而且确定了这些步骤的执行顺序\",{\"1\":{\"83\":1}}],[\"而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式\",{\"1\":{\"66\":1}}],[\"而且克服了它的缺点\",{\"1\":{\"34\":1}}],[\"而建造者模式注重的是部件构建的过程\",{\"1\":{\"19\":1}}],[\"而车架又有碳纤维\",{\"1\":{\"14\":1}}],[\"而从如上sun\",{\"1\":{\"9\":1}}],[\"而要读取tf卡中的内容的话就需要使用到适配器模式\",{\"1\":{\"6\":1}}],[\"例外\",{\"1\":{\"1325\":1}}],[\"例子中通过反射查看了它的成员变量\",{\"1\":{\"1243\":1}}],[\"例6\",{\"0\":{\"765\":1}}],[\"例5\",{\"0\":{\"764\":1}}],[\"例4\",{\"0\":{\"763\":1}}],[\"例3\",{\"0\":{\"762\":1},\"1\":{\"1113\":3}}],[\"例2\",{\"0\":{\"761\":1},\"1\":{\"1113\":1}}],[\"例1\",{\"0\":{\"760\":1},\"1\":{\"1113\":1}}],[\"例如根据\",{\"1\":{\"1438\":1}}],[\"例如控制器内\",{\"1\":{\"1411\":1}}],[\"例如有参构造\",{\"1\":{\"1376\":1}}],[\"例如有3张拆分表\",{\"1\":{\"997\":1}}],[\"例如对构造\",{\"1\":{\"1298\":1}}],[\"例如通过解析\",{\"1\":{\"1248\":1}}],[\"例如通过使用hadoop\",{\"1\":{\"281\":1}}],[\"例如select\",{\"1\":{\"1230\":1}}],[\"例如spark\",{\"1\":{\"474\":1}}],[\"例如map\",{\"1\":{\"1212\":1}}],[\"例如myisam只支持表锁\",{\"1\":{\"506\":1}}],[\"例如两个集合\",{\"1\":{\"1210\":1}}],[\"例如一个user对象\",{\"1\":{\"1207\":1}}],[\"例如我们的项目名称叫\",{\"1\":{\"1207\":1}}],[\"例如我们项目需要第三方依赖如\",{\"1\":{\"91\":1}}],[\"例如外键\",{\"1\":{\"1186\":1}}],[\"例如朋友圈\",{\"1\":{\"1166\":1}}],[\"例如提交订单\",{\"1\":{\"1005\":1}}],[\"例如防止表单重复提交\",{\"1\":{\"1005\":1}}],[\"例如机房号\",{\"1\":{\"1001\":1}}],[\"例如机房号+机器号\",{\"1\":{\"998\":1}}],[\"例如你的业务可能达不到69年之久\",{\"1\":{\"1001\":1}}],[\"例如目录结构如下\",{\"1\":{\"821\":1}}],[\"例如原始数据有3条为\",{\"1\":{\"809\":1}}],[\"例如调用\",{\"1\":{\"797\":2}}],[\"例如在这个位置加入\",{\"1\":{\"795\":1}}],[\"例如读了\",{\"1\":{\"774\":1}}],[\"例如写入后大小为\",{\"1\":{\"773\":2}}],[\"例如网卡\",{\"1\":{\"707\":1}}],[\"例如fork\",{\"1\":{\"676\":1}}],[\"例如计算\",{\"1\":{\"505\":1}}],[\"例如身份证\",{\"1\":{\"494\":1}}],[\"例如当前有一张表\",{\"1\":{\"455\":1}}],[\"例如适合小表join大表的map\",{\"1\":{\"447\":1}}],[\"例如union语句\",{\"1\":{\"446\":1}}],[\"例如数据所在的hdfs文件地址\",{\"1\":{\"421\":1}}],[\"例如17\",{\"1\":{\"331\":1}}],[\"例如cast\",{\"1\":{\"248\":1}}],[\"例如市场营销或销售\",{\"1\":{\"223\":1}}],[\"例如订单的创建\",{\"1\":{\"110\":1}}],[\"例如用户信息的管理\",{\"1\":{\"110\":1}}],[\"例如\",{\"1\":{\"83\":1,\"100\":4,\"101\":1,\"102\":1,\"181\":1,\"236\":1,\"237\":1,\"248\":1,\"369\":2,\"378\":1,\"452\":1,\"576\":1,\"683\":1,\"694\":1,\"695\":1,\"709\":2,\"712\":1,\"781\":1,\"795\":1,\"837\":1,\"841\":1,\"873\":1,\"927\":1,\"1008\":1,\"1013\":1,\"1034\":1,\"1037\":1,\"1042\":3,\"1050\":1,\"1113\":1,\"1115\":1,\"1146\":3,\"1193\":1,\"1194\":1,\"1199\":1,\"1205\":1,\"1206\":1,\"1207\":1,\"1209\":1,\"1211\":1,\"1248\":1,\"1284\":1,\"1438\":1}}],[\"例如使用strategy模式编写象棋程序时\",{\"1\":{\"79\":1}}],[\"例\",{\"1\":{\"6\":1,\"7\":1,\"58\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"85\":1,\"776\":1}}],[\"它用统一的接口对各种handler方法进行调用\",{\"1\":{\"1530\":1}}],[\"它用于指导具体构建者如何构建产品\",{\"1\":{\"14\":1}}],[\"它实现\",{\"1\":{\"1466\":1}}],[\"它实现了condition接口\",{\"1\":{\"584\":1}}],[\"它实现了读操作无锁\",{\"1\":{\"578\":1}}],[\"它只影响非\",{\"1\":{\"1462\":1}}],[\"它只能在目录上设置\",{\"1\":{\"875\":1}}],[\"它主要配置了两个\",{\"1\":{\"1455\":1}}],[\"它使用的是标准\",{\"1\":{\"1438\":1}}],[\"它使得同一个机器上的两个进程能以socket的方式通讯\",{\"1\":{\"872\":1}}],[\"它内置的\",{\"1\":{\"1436\":1}}],[\"它内部采用了条件装配\",{\"1\":{\"1454\":1}}],[\"它内部调用\",{\"1\":{\"1333\":1}}],[\"它内部维护了一个\",{\"1\":{\"779\":1}}],[\"它就是一个标准\",{\"1\":{\"1411\":1}}],[\"它就是读写数据的双向通道\",{\"1\":{\"861\":1}}],[\"它与之前\",{\"1\":{\"1325\":1}}],[\"它生成的代理类是目标的子类\",{\"1\":{\"1307\":1}}],[\"它才是\",{\"1\":{\"1243\":1}}],[\"它扩展了\",{\"1\":{\"1240\":1}}],[\"它不需要\",{\"1\":{\"1499\":1}}],[\"它不仅提供了一系列的分布式的\",{\"1\":{\"1149\":1}}],[\"它不会阻塞\",{\"1\":{\"840\":1}}],[\"它不会移动读指针\",{\"1\":{\"803\":1}}],[\"它将reduce输出发送到sql表\",{\"1\":{\"986\":1}}],[\"它将自己发布到namenode并汇报自己负责持有的块列表\",{\"1\":{\"903\":1}}],[\"它将自己尝试获取该锁\",{\"1\":{\"885\":1}}],[\"它封装了某个节点上的多维度资源\",{\"1\":{\"948\":1}}],[\"它接收并处理来自\",{\"1\":{\"946\":1}}],[\"它会返回一个布尔值\",{\"1\":{\"1532\":1}}],[\"它会读取配置文件中带\",{\"1\":{\"1455\":1}}],[\"它会正常\",{\"1\":{\"1317\":2}}],[\"它会定时地向\",{\"1\":{\"946\":1}}],[\"它会通知所有已经注册的observer角色\",{\"1\":{\"46\":1}}],[\"它旨在通过使用密钥加密技术为客户端\",{\"1\":{\"923\":1}}],[\"它还维护块的位置\",{\"1\":{\"888\":1}}],[\"它还声明了\",{\"1\":{\"46\":1}}],[\"它处理块报告并支持与块相关的操作\",{\"1\":{\"888\":1}}],[\"它通过对数据进行分块\",{\"1\":{\"875\":1}}],[\"它带来的另一大好处是\",{\"1\":{\"872\":1}}],[\"它即为通道抽象\",{\"1\":{\"785\":1}}],[\"它既可以由提交任务的线程来调用\",{\"1\":{\"742\":1}}],[\"它既是订阅者也是发布者\",{\"1\":{\"716\":1}}],[\"它取值为\",{\"1\":{\"741\":1}}],[\"它允许用户程序只要装入少数段的程序和数据即可启动运行\",{\"1\":{\"689\":1}}],[\"它允许用户程序只装入少数页面的程序\",{\"1\":{\"689\":1}}],[\"它同时具有两者的优点\",{\"1\":{\"683\":1}}],[\"它同具体工厂之间一一对应\",{\"1\":{\"33\":1}}],[\"它把用户程序的地址空间分为若干个大小不同的段\",{\"1\":{\"683\":1}}],[\"它由fd\",{\"1\":{\"680\":1}}],[\"它由一个模板方法和若干个基本方法构成\",{\"1\":{\"84\":1}}],[\"它发起一个read操作后\",{\"1\":{\"679\":1}}],[\"它占用了\",{\"1\":{\"663\":1}}],[\"它占用空间更少并且效率更高\",{\"1\":{\"658\":1}}],[\"它有两个成员变量\",{\"1\":{\"663\":1}}],[\"它有以下两种使用方法\",{\"1\":{\"582\":1}}],[\"它有以下优点\",{\"1\":{\"77\":1}}],[\"它被读取时就是什么样的\",{\"1\":{\"663\":1}}],[\"它里面的gc按照回收区域又分为两大种类型\",{\"1\":{\"628\":1}}],[\"它里面定义了一系列的模板方法\",{\"1\":{\"585\":1}}],[\"它并不会自己先去加载\",{\"1\":{\"623\":1}}],[\"它为java中大部分锁和同步器提供一个基础框架\",{\"1\":{\"581\":1}}],[\"它为没有实现接口的类提供代理\",{\"1\":{\"60\":1}}],[\"它也会得到一份集群的槽位配置信息并将其缓存在客户端本地\",{\"1\":{\"528\":1}}],[\"它也不是23种设计模式中的\",{\"1\":{\"30\":1}}],[\"它具有复制\",{\"1\":{\"527\":1}}],[\"它具有创建新进程\",{\"1\":{\"161\":1}}],[\"它记录的是sql执行相关的信息\",{\"1\":{\"506\":1}}],[\"它最大的优点就是读不加锁\",{\"1\":{\"503\":1}}],[\"它已经被多种查询引擎原生支持\",{\"1\":{\"429\":1}}],[\"它必须立即释放保持的所有资源\",{\"1\":{\"176\":1}}],[\"它要去管理子工程\",{\"1\":{\"107\":1}}],[\"它们都实现了\",{\"1\":{\"1370\":1}}],[\"它们都有两个重要方法\",{\"1\":{\"1362\":1}}],[\"它们都有\",{\"1\":{\"813\":1}}],[\"它们将被移动到回收站current目录中\",{\"1\":{\"909\":1}}],[\"它们的根本区别在于是否将程序所需的全部地址空间都装入主存\",{\"1\":{\"689\":1}}],[\"它们的定义分别如下\",{\"1\":{\"663\":1}}],[\"它们数据结构中的\",{\"1\":{\"663\":1}}],[\"它们应该是同一个版本\",{\"1\":{\"107\":1}}],[\"它们是一个顶级逻辑的组成步骤\",{\"1\":{\"84\":1}}],[\"它背后的需求是\",{\"1\":{\"107\":1}}],[\"它的内部可能会调用其他的业务方法\",{\"1\":{\"1514\":1}}],[\"它的本质就是一个工厂\",{\"1\":{\"1500\":1}}],[\"它的调用时机通常在原始对象初始化后执行\",{\"1\":{\"1333\":1}}],[\"它的key和value的序列化方式默认就是string方式\",{\"1\":{\"1223\":1}}],[\"它的基本语法大家可以参考网站\",{\"1\":{\"1146\":1}}],[\"它的文档怎样聚合和搜索请求\",{\"1\":{\"1066\":1}}],[\"它的优势是在读取过程\",{\"1\":{\"995\":1}}],[\"它的作用就是配置外置\",{\"1\":{\"1442\":1}}],[\"它的作用就是决定当前的这对输出数据最终应该交由哪个reduce\",{\"1\":{\"979\":1}}],[\"它的作用是用制造创建过程较为复杂的产品\",{\"1\":{\"1472\":1}}],[\"它的作用是待客户端\",{\"1\":{\"784\":1,\"785\":1}}],[\"它的作用是利用\",{\"1\":{\"753\":1}}],[\"它的作用是\",{\"1\":{\"663\":1}}],[\"它的\",{\"1\":{\"765\":1}}],[\"它的继承关系比较复杂\",{\"1\":{\"746\":1}}],[\"它的特点是在使用读锁和写锁时都必须配合\",{\"1\":{\"590\":1}}],[\"它的线程安全是由cas+volatile和synchronized来实现的\",{\"1\":{\"579\":1}}],[\"它的产生早在2013年初\",{\"1\":{\"430\":1}}],[\"它的背景是\",{\"1\":{\"107\":1}}],[\"它的主要目的是通过组装零配件而产生一个新产品\",{\"1\":{\"20\":1}}],[\"它能够找到容器中所有切面\",{\"1\":{\"1453\":1}}],[\"它能够支持嵌套异常\",{\"1\":{\"1406\":1}}],[\"它能够重用参数解析器\",{\"1\":{\"1406\":1}}],[\"它能够大大提高软件开发效率\",{\"1\":{\"94\":1}}],[\"它能保证客户端始终只使用同一个产品族中的对象\",{\"1\":{\"40\":1}}],[\"它提供了\",{\"1\":{\"1461\":1}}],[\"它提供了一种创建对象的最佳方式\",{\"1\":{\"64\":1}}],[\"它提高了代码阅读的难度\",{\"1\":{\"86\":1}}],[\"它可能是存款\",{\"1\":{\"83\":1}}],[\"它可以确保每个消费者消费的分区数量是均衡的\",{\"1\":{\"1040\":1}}],[\"它可以访问\",{\"1\":{\"57\":1}}],[\"它可以是抽象类或接口\",{\"1\":{\"5\":1}}],[\"它维持了类的封装性\",{\"1\":{\"77\":1}}],[\"它限制了复用的灵活性\",{\"1\":{\"77\":1}}],[\"它声明了update方法\",{\"1\":{\"46\":1}}],[\"它\",{\"1\":{\"38\":1}}],[\"它包含控制器的功能\",{\"1\":{\"1532\":1}}],[\"它包含多个创建产品的方法\",{\"1\":{\"38\":1}}],[\"它包含了车架\",{\"1\":{\"14\":1}}],[\"它是model和view这两层的桥梁\",{\"1\":{\"1528\":1}}],[\"它是一个动态资源划分单位\",{\"1\":{\"948\":1}}],[\"它是一个转换器\",{\"1\":{\"5\":1}}],[\"它是\",{\"1\":{\"694\":1,\"1243\":1}}],[\"它是由连续内存块组成的顺序型数据结构\",{\"1\":{\"665\":1}}],[\"它是指为完成某种任务而建立的两个或多个进程\",{\"1\":{\"168\":1}}],[\"它是可被复制的对象\",{\"1\":{\"50\":1}}],[\"它是被访问和适配的现存组件库中的组件接口\",{\"1\":{\"5\":1}}],[\"类路径下必须有\",{\"1\":{\"1466\":1}}],[\"类无法被\",{\"1\":{\"1307\":1}}],[\"类文件时\",{\"1\":{\"1298\":1}}],[\"类也有该方法\",{\"1\":{\"801\":1}}],[\"类如其名\",{\"1\":{\"780\":1}}],[\"类中编写方法使用接口作为参数\",{\"1\":{\"614\":1}}],[\"类中的\",{\"1\":{\"69\":1}}],[\"类用final修饰保证了类不能被继承\",{\"1\":{\"566\":1}}],[\"类以及代码块\",{\"1\":{\"558\":1}}],[\"类型数据结构实现\",{\"1\":{\"1174\":1}}],[\"类型相同的商户作为同一组\",{\"1\":{\"1171\":1}}],[\"类型发生了不同的变化\",{\"1\":{\"1062\":1}}],[\"类型和长度已知的情况下\",{\"1\":{\"840\":1}}],[\"类型分配内存时\",{\"1\":{\"663\":1}}],[\"类型分别是\",{\"1\":{\"663\":1}}],[\"类型只占一个字节\",{\"1\":{\"663\":1}}],[\"类型的唯一\",{\"1\":{\"998\":1}}],[\"类型的\",{\"1\":{\"663\":2}}],[\"类型指针\",{\"1\":{\"631\":1}}],[\"类型转换与数据绑定\",{\"0\":{\"1371\":1}}],[\"类型转换\",{\"1\":{\"505\":1,\"1384\":1}}],[\"类型转换函数\",{\"0\":{\"341\":1},\"1\":{\"341\":1}}],[\"类型必须一致\",{\"1\":{\"493\":1}}],[\"类型为unsigned\",{\"1\":{\"480\":1}}],[\"类型\",{\"0\":{\"1062\":1},\"1\":{\"239\":1,\"279\":1,\"480\":1,\"493\":2,\"663\":2,\"840\":1,\"1267\":1,\"1321\":1,\"1355\":2,\"1489\":1,\"1497\":1,\"1504\":1}}],[\"类似消息队列的方式来完成我们的需求\",{\"1\":{\"1155\":1}}],[\"类似\",{\"1\":{\"1151\":1,\"1321\":1,\"1455\":1}}],[\"类似的还有\",{\"1\":{\"1339\":1}}],[\"类似的内存分配算法提升分配效率\",{\"1\":{\"770\":1}}],[\"类似的\",{\"1\":{\"766\":1}}],[\"类似where\",{\"1\":{\"422\":1}}],[\"类似于拓扑或者dag\",{\"1\":{\"991\":1}}],[\"类似于\",{\"1\":{\"562\":4}}],[\"类似于java中的hashmap结构\",{\"1\":{\"1208\":1}}],[\"类似于java中的hashset\",{\"1\":{\"515\":1}}],[\"类似于jdk1\",{\"1\":{\"515\":1}}],[\"类似于jdk动态代理的proxy类\",{\"1\":{\"60\":1}}],[\"类似于jdbc或odbc协议\",{\"1\":{\"232\":1}}],[\"类似于group\",{\"1\":{\"358\":1}}],[\"类似内存分页\",{\"1\":{\"197\":1}}],[\"类似类\",{\"1\":{\"173\":1}}],[\"类的唯一性\",{\"1\":{\"66\":1}}],[\"类加载阶段\",{\"1\":{\"1508\":1}}],[\"类加载时可以通过\",{\"1\":{\"1302\":1}}],[\"类加载\",{\"0\":{\"1301\":1}}],[\"类加载不会导致该单实例对象被创建\",{\"1\":{\"66\":1}}],[\"类加载就会导致该单实例对象被创建\",{\"1\":{\"66\":1}}],[\"类加载器\",{\"1\":{\"59\":1}}],[\"类和接口一览表\",{\"1\":{\"47\":1}}],[\"类结构图如下\",{\"1\":{\"9\":1}}],[\"类适配器是客户类有一个接口规范的情况下可用\",{\"1\":{\"6\":1}}],[\"类适配器模式的代码\",{\"1\":{\"7\":1}}],[\"类适配器模式违背了合成复用原则\",{\"1\":{\"6\":1}}],[\"类适配器模式\",{\"0\":{\"6\":1}}],[\"类图如下\",{\"1\":{\"6\":1,\"7\":1,\"13\":1,\"14\":1,\"28\":1,\"34\":1,\"39\":1,\"52\":1,\"58\":1,\"74\":2,\"75\":1,\"76\":1,\"77\":1,\"85\":1}}],[\"类\",{\"1\":{\"5\":2,\"14\":2,\"57\":3,\"75\":2,\"821\":1,\"1321\":1}}],[\"tdd\",{\"1\":{\"1499\":1}}],[\"t分割\",{\"1\":{\"980\":1}}],[\"tgz\",{\"1\":{\"1012\":1}}],[\"tgt\",{\"1\":{\"923\":1}}],[\"tgs的作用是通过as发送给client的票\",{\"1\":{\"923\":1}}],[\"tl\",{\"1\":{\"1101\":4}}],[\"tlv\",{\"1\":{\"840\":2}}],[\"tlab是每个线程独享的\",{\"1\":{\"630\":1}}],[\"t为访问一次内存所需时间\",{\"1\":{\"683\":1}}],[\"t+λ\",{\"1\":{\"683\":1}}],[\"t0\",{\"1\":{\"545\":1}}],[\"t8\",{\"1\":{\"544\":1,\"549\":1}}],[\"t5\",{\"1\":{\"543\":1}}],[\"ttl的返回值就是\",{\"1\":{\"1205\":1}}],[\"ttlremaining\",{\"1\":{\"1152\":3}}],[\"ttlremainingfuture\",{\"1\":{\"1152\":4}}],[\"ttl\",{\"1\":{\"519\":2,\"522\":1,\"1107\":1,\"1111\":1,\"1122\":1,\"1124\":2,\"1127\":3,\"1128\":1,\"1129\":5,\"1152\":2,\"1205\":6,\"1206\":3}}],[\"tb\",{\"1\":{\"378\":5,\"395\":2,\"396\":2,\"397\":2,\"400\":4,\"402\":2,\"404\":2,\"423\":5,\"437\":6,\"458\":4,\"495\":1,\"1107\":1,\"1133\":2,\"1159\":2,\"1167\":1}}],[\"tblproperties\",{\"1\":{\"268\":1,\"271\":1,\"276\":1,\"279\":2,\"298\":1,\"437\":2}}],[\"t$\",{\"1\":{\"330\":2}}],[\"t2时刻发布了新的记录\",{\"1\":{\"1167\":1}}],[\"t2runned\",{\"1\":{\"554\":6,\"555\":12}}],[\"t2\",{\"1\":{\"317\":2,\"554\":9,\"555\":11,\"737\":1}}],[\"t1runned\",{\"1\":{\"555\":12}}],[\"t1\",{\"1\":{\"317\":2,\"400\":4,\"404\":2,\"554\":10,\"555\":11,\"737\":1}}],[\"t3\",{\"1\":{\"316\":2}}],[\"tx\",{\"1\":{\"1499\":1}}],[\"txn\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1}}],[\"txt到本程序自己创建的集合中\",{\"1\":{\"990\":1}}],[\"txt到dual表中\",{\"1\":{\"329\":1}}],[\"txt只有一行内容\",{\"1\":{\"329\":1}}],[\"txt具体内容如下所示\",{\"1\":{\"285\":1}}],[\"txt文件\",{\"1\":{\"195\":1}}],[\"txt\",{\"1\":{\"54\":2,\"68\":2,\"237\":4,\"261\":6,\"262\":3,\"280\":1,\"281\":2,\"285\":1,\"287\":1,\"329\":1,\"336\":1,\"340\":1,\"348\":2,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"796\":2,\"807\":2,\"808\":1,\"820\":4,\"821\":6,\"822\":6,\"854\":1,\"857\":1,\"910\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"tmp\",{\"1\":{\"261\":4,\"290\":2,\"316\":1,\"351\":4,\"363\":2,\"364\":1,\"409\":2,\"410\":1,\"645\":2,\"878\":1,\"910\":1}}],[\"ts​=s+m∗n\",{\"1\":{\"204\":1}}],[\"ts​\",{\"1\":{\"204\":1}}],[\"tsl指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作\",{\"1\":{\"170\":1}}],[\"tue\",{\"1\":{\"726\":4}}],[\"tuple是一个udtf\",{\"1\":{\"376\":1}}],[\"tuple\",{\"0\":{\"378\":1,\"396\":1},\"1\":{\"376\":1,\"378\":4,\"393\":1,\"396\":2,\"1168\":3}}],[\"tuple这个udtf函数\",{\"1\":{\"336\":1}}],[\"turn表示当前允许进入临界区的进程号\",{\"1\":{\"169\":1}}],[\"tutorials\",{\"1\":{\"133\":2,\"841\":1}}],[\"tutorial\",{\"1\":{\"126\":1,\"1146\":1}}],[\"title\",{\"1\":{\"1089\":1,\"1186\":2}}],[\"tilnextmillis\",{\"1\":{\"999\":2}}],[\"ticket\",{\"1\":{\"923\":5}}],[\"tidying\",{\"1\":{\"571\":1}}],[\"tim\",{\"1\":{\"340\":1}}],[\"timeline\",{\"1\":{\"1166\":1}}],[\"time`\",{\"1\":{\"1164\":1}}],[\"timertask\",{\"1\":{\"1152\":2}}],[\"timeindex\",{\"1\":{\"1052\":1}}],[\"timeout=30s\",{\"1\":{\"1293\":1}}],[\"timeoutsec\",{\"1\":{\"1142\":4,\"1144\":2}}],[\"timeoutmillis\",{\"1\":{\"742\":4}}],[\"timeout\",{\"0\":{\"725\":1},\"1\":{\"725\":5,\"726\":2,\"832\":1,\"1152\":3}}],[\"timeout指定等待时间\",{\"1\":{\"680\":1}}],[\"timeunit\",{\"1\":{\"572\":1,\"574\":3,\"725\":1,\"742\":1,\"751\":1,\"1107\":1,\"1111\":1,\"1122\":1,\"1124\":2,\"1127\":3,\"1129\":22,\"1142\":1,\"1144\":1,\"1150\":1,\"1152\":2}}],[\"timed\",{\"1\":{\"538\":1,\"725\":1,\"726\":1}}],[\"timestamp的所有调用均返回相同的值\",{\"1\":{\"337\":1}}],[\"timestamp\",{\"1\":{\"337\":11,\"999\":2,\"1132\":4,\"1164\":2}}],[\"time\",{\"1\":{\"167\":1,\"365\":4,\"395\":1,\"396\":2,\"683\":1,\"742\":3,\"1129\":6,\"1132\":1,\"1168\":3}}],[\"tinyint\",{\"1\":{\"248\":2,\"480\":2,\"1174\":2}}],[\"tiramisu\",{\"1\":{\"39\":1}}],[\"twitter\",{\"1\":{\"132\":1,\"998\":1}}],[\"teachers\",{\"1\":{\"1525\":2,\"1531\":1}}],[\"teardown\",{\"1\":{\"1213\":1,\"1216\":1}}],[\"team\",{\"1\":{\"348\":3,\"349\":3}}],[\"terms\",{\"1\":{\"1085\":1}}],[\"termsquery\",{\"1\":{\"1083\":3}}],[\"termsquerybuilder\",{\"1\":{\"1083\":1}}],[\"termquerybuilder\",{\"1\":{\"1089\":1}}],[\"termquerybypage\",{\"1\":{\"1089\":1}}],[\"termquery\",{\"1\":{\"1076\":1,\"1089\":3}}],[\"terminated\",{\"1\":{\"252\":4,\"256\":3,\"260\":1,\"261\":1,\"262\":1,\"266\":1,\"281\":1,\"285\":1,\"287\":1,\"290\":5,\"340\":1,\"348\":2,\"351\":1,\"352\":1,\"357\":1,\"359\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"538\":1,\"571\":1}}],[\"terminate\",{\"1\":{\"160\":1}}],[\"text>\",{\"1\":{\"973\":3,\"985\":2,\"988\":7}}],[\"textoutputformat默认是一次输出写一行\",{\"1\":{\"980\":1}}],[\"textoutputformat\",{\"1\":{\"962\":3,\"984\":1,\"988\":1,\"991\":2}}],[\"textfile是hive中默认的文件格式\",{\"1\":{\"427\":1}}],[\"textfile\",{\"0\":{\"427\":1},\"1\":{\"374\":1,\"397\":1}}],[\"text\",{\"1\":{\"373\":5,\"956\":1,\"958\":7,\"959\":2,\"960\":3,\"962\":4,\"972\":12,\"973\":18,\"974\":3,\"983\":3,\"985\":3,\"986\":3,\"988\":37,\"990\":9,\"991\":7,\"1089\":1,\"1411\":2,\"1416\":2}}],[\"textinputformat\",{\"1\":{\"250\":1,\"962\":2,\"965\":1,\"988\":1,\"991\":2}}],[\"temporary\",{\"1\":{\"344\":1}}],[\"template的示例ec策略xml文件\",{\"1\":{\"875\":1}}],[\"template\",{\"1\":{\"84\":1,\"1222\":7,\"1257\":1}}],[\"techops\",{\"1\":{\"272\":1}}],[\"tez\",{\"0\":{\"472\":1},\"1\":{\"232\":1}}],[\"tensorflow\",{\"1\":{\"133\":1}}],[\"testmethodinvoke\",{\"1\":{\"1312\":1}}],[\"testmethodtemplate\",{\"1\":{\"1257\":1}}],[\"testmessagesource\",{\"1\":{\"1244\":1}}],[\"testbeanfactory\",{\"1\":{\"1247\":1}}],[\"testhash\",{\"1\":{\"1213\":1,\"1224\":1}}],[\"testhyperloglog\",{\"1\":{\"1180\":1}}],[\"testredisson\",{\"1\":{\"1150\":1}}],[\"testidworker\",{\"1\":{\"1132\":1}}],[\"testing\",{\"1\":{\"1019\":1}}],[\"testprocessorder\",{\"1\":{\"1259\":1}}],[\"testproducer\",{\"1\":{\"1023\":1,\"1025\":1}}],[\"testpipeline\",{\"1\":{\"766\":1}}],[\"test<\",{\"1\":{\"1022\":1,\"1070\":1,\"1087\":3,\"1219\":1}}],[\"testfilechanneltransferto\",{\"1\":{\"820\":1}}],[\"testfinal\",{\"1\":{\"567\":1}}],[\"testclient\",{\"1\":{\"795\":1}}],[\"testconsumer\",{\"1\":{\"1024\":1}}],[\"testconnectiontimeout\",{\"1\":{\"725\":1}}],[\"testcondition\",{\"1\":{\"340\":1}}],[\"testcomputer\",{\"1\":{\"74\":2}}],[\"testservice\",{\"1\":{\"1526\":1,\"1531\":1}}],[\"testservletdatabinderfactory\",{\"1\":{\"1375\":1}}],[\"testserver\",{\"1\":{\"795\":1}}],[\"testsaveuser\",{\"1\":{\"1223\":1}}],[\"testsaveshop\",{\"1\":{\"1128\":1}}],[\"teststring\",{\"1\":{\"1213\":1,\"1221\":1,\"1223\":1}}],[\"testslice\",{\"1\":{\"776\":1}}],[\"test2\",{\"1\":{\"397\":2,\"617\":3,\"663\":3}}],[\"test1\",{\"1\":{\"395\":2,\"396\":2,\"663\":3}}],[\"testandset指令\",{\"1\":{\"170\":1}}],[\"test\",{\"1\":{\"68\":2,\"95\":1,\"100\":1,\"104\":1,\"279\":5,\"536\":1,\"554\":3,\"555\":3,\"614\":3,\"1015\":1,\"1016\":1,\"1017\":2,\"1021\":2,\"1023\":2,\"1024\":3,\"1025\":2,\"1050\":1,\"1089\":10,\"1128\":1,\"1132\":1,\"1150\":1,\"1171\":1,\"1180\":1,\"1213\":2,\"1221\":1,\"1223\":2,\"1224\":1,\"1230\":4,\"1236\":1,\"1292\":1,\"1499\":1}}],[\"test类\",{\"1\":{\"68\":2}}],[\"take\",{\"1\":{\"1157\":1}}],[\"tailcontext\",{\"1\":{\"775\":2}}],[\"tail\",{\"1\":{\"740\":1,\"743\":2,\"766\":1,\"775\":1}}],[\"task的输出结果还可以往剩下的20mb内存中写\",{\"1\":{\"979\":1}}],[\"task的输出结果很多时\",{\"1\":{\"979\":1}}],[\"task的个数只能为1或者0\",{\"1\":{\"444\":1}}],[\"task数量取模\",{\"1\":{\"979\":1}}],[\"task处理\",{\"1\":{\"979\":1}}],[\"task处理数据\",{\"1\":{\"351\":1}}],[\"taskmanager两类服务\",{\"1\":{\"951\":1}}],[\"task2\",{\"1\":{\"593\":4}}],[\"task1会优先运行2次\",{\"1\":{\"593\":1}}],[\"task1\",{\"1\":{\"593\":4}}],[\"task\",{\"1\":{\"480\":1,\"741\":6,\"742\":1,\"750\":2,\"846\":3,\"942\":1,\"1132\":2,\"1152\":2}}],[\"tasks\",{\"1\":{\"444\":1,\"846\":3}}],[\"task个数小于\",{\"1\":{\"444\":1}}],[\"task=256000000\",{\"1\":{\"435\":1}}],[\"tabat\",{\"1\":{\"579\":3}}],[\"tab\",{\"1\":{\"579\":14}}],[\"tab1\",{\"1\":{\"285\":4,\"422\":1}}],[\"tablefield\",{\"1\":{\"1161\":1}}],[\"table2\",{\"1\":{\"460\":2}}],[\"table总bucket数为4\",{\"1\":{\"369\":1}}],[\"table总共分了4份\",{\"1\":{\"369\":1}}],[\"table1\",{\"1\":{\"286\":1,\"460\":2}}],[\"table\",{\"0\":{\"279\":1,\"318\":1},\"1\":{\"239\":1,\"256\":1,\"258\":1,\"260\":1,\"261\":9,\"262\":4,\"265\":1,\"266\":1,\"268\":1,\"271\":2,\"272\":2,\"276\":3,\"278\":1,\"279\":28,\"280\":17,\"281\":5,\"283\":2,\"285\":2,\"286\":2,\"287\":4,\"288\":4,\"289\":2,\"298\":1,\"300\":1,\"318\":5,\"329\":2,\"334\":1,\"340\":2,\"348\":2,\"351\":4,\"352\":2,\"357\":2,\"359\":4,\"369\":1,\"374\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"395\":1,\"397\":2,\"400\":1,\"402\":1,\"404\":1,\"407\":1,\"408\":1,\"409\":2,\"410\":1,\"423\":1,\"437\":2,\"452\":1,\"455\":1,\"458\":2,\"465\":1,\"482\":4,\"483\":1,\"495\":1,\"579\":3,\"799\":8,\"1164\":1,\"1174\":1}}],[\"tablenamesuffix\",{\"1\":{\"1232\":3}}],[\"tablename1\",{\"1\":{\"286\":2}}],[\"tablename\",{\"1\":{\"235\":1,\"261\":1,\"283\":2,\"1230\":2,\"1232\":3}}],[\"tablesizefor\",{\"1\":{\"579\":1}}],[\"tablesizefor是为了保证计算的大小是2^n\",{\"1\":{\"579\":1}}],[\"tablesample\",{\"1\":{\"368\":3,\"369\":4}}],[\"tables\",{\"0\":{\"235\":1,\"259\":1,\"263\":1,\"267\":1},\"1\":{\"271\":1,\"276\":1}}],[\"table表目录下以子文件夹形式存在\",{\"1\":{\"236\":1}}],[\"table表\",{\"1\":{\"233\":1}}],[\"tanke\",{\"1\":{\"261\":1}}],[\"tank\",{\"1\":{\"261\":1,\"281\":1}}],[\"tachibanayoshino\",{\"1\":{\"125\":1}}],[\"tar\",{\"1\":{\"876\":2,\"1012\":1,\"1046\":5,\"1193\":2}}],[\"tara\",{\"1\":{\"81\":9}}],[\"targetfastclass\",{\"1\":{\"1320\":1,\"1321\":3}}],[\"targetname\",{\"1\":{\"823\":3}}],[\"target>\",{\"1\":{\"92\":1,\"102\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"957\":1,\"1022\":1}}],[\"target>17<\",{\"1\":{\"112\":1,\"113\":1,\"114\":1,\"115\":1}}],[\"target>1\",{\"1\":{\"92\":1}}],[\"target\",{\"1\":{\"5\":1,\"60\":2,\"271\":1,\"809\":4,\"822\":12,\"823\":2,\"840\":4,\"1197\":2,\"1290\":1,\"1297\":1,\"1304\":8,\"1306\":9,\"1309\":2,\"1317\":5,\"1321\":1,\"1340\":1,\"1525\":1}}],[\"talk\",{\"1\":{\"76\":1}}],[\"t\",{\"1\":{\"70\":1,\"214\":2,\"235\":1,\"236\":1,\"237\":2,\"256\":1,\"260\":4,\"261\":11,\"262\":4,\"265\":1,\"266\":4,\"271\":3,\"278\":1,\"280\":6,\"281\":10,\"302\":4,\"303\":5,\"307\":3,\"310\":1,\"340\":6,\"369\":2,\"378\":1,\"382\":1,\"385\":1,\"388\":1,\"391\":1,\"400\":1,\"402\":2,\"404\":1,\"407\":1,\"408\":1,\"409\":1,\"614\":13,\"616\":2,\"620\":1,\"663\":6,\"716\":6,\"723\":7,\"733\":2,\"737\":2,\"740\":8,\"741\":6,\"743\":8,\"744\":2,\"972\":1,\"974\":2,\"985\":5,\"986\":1,\"988\":8,\"990\":2,\"991\":2,\"1128\":1,\"1129\":2,\"1152\":1,\"1236\":1,\"1368\":1}}],[\"tcl\",{\"1\":{\"1192\":1}}],[\"tcp\",{\"0\":{\"728\":1},\"1\":{\"694\":8,\"707\":1,\"709\":1,\"726\":1,\"792\":1}}],[\"tcp连接\",{\"1\":{\"652\":1}}],[\"tcb\",{\"1\":{\"163\":1}}],[\"tc\",{\"1\":{\"69\":2}}],[\"trigger\",{\"1\":{\"680\":4}}],[\"trienode\",{\"1\":{\"668\":10}}],[\"trie\",{\"1\":{\"668\":1}}],[\"trim\",{\"1\":{\"336\":3,\"344\":2}}],[\"trx\",{\"1\":{\"503\":1}}],[\"tree下标从1开始\",{\"1\":{\"673\":1}}],[\"treearray\",{\"1\":{\"673\":2}}],[\"treenode\",{\"1\":{\"669\":12}}],[\"treenode<k\",{\"1\":{\"579\":1}}],[\"treeset<>\",{\"1\":{\"999\":1}}],[\"treeset\",{\"1\":{\"999\":1}}],[\"treeset用于支持元素的自定义排序场景\",{\"1\":{\"604\":1}}],[\"treeset底层采用红黑树\",{\"1\":{\"604\":1}}],[\"treeifybin\",{\"1\":{\"579\":1}}],[\"treeify\",{\"1\":{\"579\":1}}],[\"treebin\",{\"1\":{\"579\":1}}],[\"treebin<k\",{\"1\":{\"579\":2}}],[\"tree的最左前缀匹配特性\",{\"1\":{\"481\":1}}],[\"tree\",{\"1\":{\"442\":1,\"672\":1,\"673\":5}}],[\"truncate\",{\"1\":{\"258\":1,\"482\":2}}],[\"truth的iou不是最大的anchor既不是正样本也不是负样本\",{\"1\":{\"139\":1}}],[\"truth的iou最大的anchor为正样本\",{\"1\":{\"139\":1}}],[\"truth的iou最大的anchor负责预测这个ground\",{\"1\":{\"138\":1}}],[\"truth的iou小于阈值的anchor为负样本\",{\"1\":{\"139\":1}}],[\"truth\",{\"1\":{\"138\":1}}],[\"true未匹配到指定数据源时抛异常\",{\"1\":{\"1236\":1}}],[\"true代表获取锁成功\",{\"1\":{\"1142\":1}}],[\"true\",{\"1\":{\"68\":1,\"81\":1,\"169\":1,\"248\":36,\"268\":4,\"276\":4,\"289\":1,\"297\":3,\"298\":4,\"332\":1,\"340\":4,\"437\":2,\"438\":2,\"444\":1,\"450\":3,\"459\":1,\"536\":1,\"554\":2,\"555\":9,\"564\":1,\"565\":1,\"585\":2,\"694\":1,\"701\":1,\"702\":3,\"703\":1,\"704\":6,\"728\":1,\"733\":2,\"740\":4,\"741\":5,\"742\":2,\"743\":4,\"744\":3,\"754\":1,\"775\":1,\"779\":2,\"794\":1,\"795\":2,\"796\":1,\"819\":1,\"826\":1,\"827\":1,\"834\":1,\"836\":1,\"839\":2,\"840\":1,\"843\":2,\"846\":4,\"876\":7,\"962\":2,\"972\":2,\"973\":2,\"974\":3,\"985\":1,\"986\":1,\"988\":2,\"991\":1,\"1024\":2,\"1028\":1,\"1100\":1,\"1107\":2,\"1111\":4,\"1137\":1,\"1142\":1,\"1144\":2,\"1152\":1,\"1157\":1,\"1161\":1,\"1175\":1,\"1325\":1,\"1394\":3,\"1416\":1,\"1505\":1}}],[\"trash功能将被禁用\",{\"1\":{\"910\":1}}],[\"trash\",{\"1\":{\"909\":2,\"910\":3}}],[\"trash垃圾桶\",{\"0\":{\"908\":1}}],[\"traffic\",{\"1\":{\"867\":1}}],[\"trade\",{\"1\":{\"480\":1}}],[\"transferfrom\",{\"1\":{\"855\":1}}],[\"transferto\",{\"1\":{\"820\":4,\"855\":3,\"1159\":1}}],[\"transmission\",{\"1\":{\"694\":1}}],[\"transient\",{\"1\":{\"564\":3,\"579\":3}}],[\"trans查询\",{\"1\":{\"276\":1}}],[\"trans建立物化视图\",{\"1\":{\"276\":1}}],[\"trans中\",{\"1\":{\"276\":1}}],[\"trans\",{\"1\":{\"268\":2,\"276\":11,\"298\":4}}],[\"transaction注解属性propagation设置错误\",{\"1\":{\"1517\":1}}],[\"transaction应用再非public修饰的方法上\",{\"1\":{\"1517\":1}}],[\"transactioninterceptor\",{\"1\":{\"1456\":1}}],[\"transactionautoconfiguration\",{\"0\":{\"1456\":1},\"1\":{\"1456\":1}}],[\"transactional失效场景\",{\"0\":{\"1517\":1}}],[\"transactional注解属性rollbackfor设置错误\",{\"1\":{\"1517\":1}}],[\"transactional注解中如果不配置rollbackfor属性\",{\"1\":{\"1516\":1}}],[\"transactional注解上\",{\"1\":{\"1515\":1}}],[\"transactional注解就是通过aop实现的\",{\"1\":{\"1500\":1}}],[\"transactional进行标注的\",{\"1\":{\"1515\":1}}],[\"transactional的默认选项\",{\"1\":{\"1514\":1}}],[\"transactional的全注解方式使用最多\",{\"1\":{\"1513\":1}}],[\"transactional事务不要滥用\",{\"1\":{\"483\":1}}],[\"transactional\",{\"0\":{\"267\":1,\"1516\":1},\"1\":{\"268\":1,\"276\":1,\"298\":1,\"1122\":1,\"1133\":1,\"1137\":2,\"1156\":1,\"1157\":1,\"1329\":1,\"1456\":1}}],[\"transaction\",{\"0\":{\"291\":1},\"1\":{\"221\":1,\"1456\":1}}],[\"translation\",{\"1\":{\"117\":2,\"130\":1}}],[\"trainstation\",{\"1\":{\"58\":3,\"59\":6,\"60\":10}}],[\"trylockinnerasync\",{\"1\":{\"1152\":2}}],[\"trylock\",{\"1\":{\"1127\":2,\"1128\":1,\"1129\":3,\"1142\":3,\"1144\":1,\"1150\":2,\"1152\":1}}],[\"tryfailure\",{\"1\":{\"725\":1}}],[\"tryoptimisticread\",{\"1\":{\"590\":2}}],[\"tryreleaseshared\",{\"1\":{\"585\":3}}],[\"tryrelease\",{\"1\":{\"585\":3}}],[\"tryacquireshared\",{\"1\":{\"585\":5}}],[\"tryacquire\",{\"1\":{\"585\":5,\"1152\":3}}],[\"try\",{\"1\":{\"42\":1,\"47\":2,\"59\":5,\"69\":2,\"88\":1,\"536\":1,\"551\":2,\"554\":4,\"555\":4,\"590\":2,\"593\":4,\"692\":2,\"696\":1,\"697\":1,\"698\":1,\"699\":1,\"702\":3,\"710\":1,\"711\":1,\"717\":1,\"718\":1,\"723\":3,\"725\":1,\"726\":1,\"733\":3,\"734\":1,\"735\":1,\"737\":1,\"740\":5,\"741\":6,\"742\":2,\"743\":5,\"744\":1,\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":2,\"775\":2,\"795\":4,\"796\":1,\"807\":1,\"808\":1,\"820\":2,\"823\":1,\"834\":2,\"836\":1,\"840\":1,\"846\":4,\"848\":2,\"857\":1,\"859\":3,\"1023\":2,\"1024\":1,\"1025\":1,\"1071\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1142\":1,\"1150\":2,\"1157\":2,\"1159\":1,\"1309\":3}}],[\"type为application\",{\"1\":{\"1525\":1,\"1531\":1}}],[\"typeconvert\",{\"1\":{\"1485\":1}}],[\"typeconverter\",{\"1\":{\"1370\":2,\"1482\":1}}],[\"typeid一致的放到一个集合\",{\"1\":{\"1171\":1}}],[\"typeid\",{\"1\":{\"1171\":3,\"1172\":6}}],[\"typedtuple<string>\",{\"1\":{\"1168\":1}}],[\"typedtuple<string>>\",{\"1\":{\"1168\":1}}],[\"typedtuples\",{\"1\":{\"1168\":5}}],[\"type里面\",{\"1\":{\"1063\":1}}],[\"type<\",{\"1\":{\"936\":1}}],[\"type=web\",{\"1\":{\"1525\":2}}],[\"type=forking\",{\"1\":{\"1197\":1}}],[\"type=index\",{\"1\":{\"481\":1}}],[\"type=block\",{\"1\":{\"433\":1}}],[\"type=\",{\"1\":{\"395\":1,\"405\":1,\"770\":1,\"1230\":2}}],[\"type\",{\"0\":{\"1062\":1},\"1\":{\"28\":3,\"30\":3,\"248\":2,\"279\":2,\"341\":1,\"723\":4,\"733\":6,\"744\":1,\"840\":1,\"1050\":1,\"1062\":1,\"1089\":4,\"1100\":1,\"1129\":9,\"1171\":3,\"1172\":2,\"1454\":1,\"1525\":3,\"1531\":2}}],[\"tonumber\",{\"1\":{\"1156\":1}}],[\"tonanos\",{\"1\":{\"742\":1}}],[\"toepochsecond\",{\"1\":{\"1132\":1}}],[\"toseconds\",{\"1\":{\"1129\":1}}],[\"tostring\",{\"1\":{\"17\":2,\"59\":2,\"81\":2,\"373\":1,\"710\":1,\"733\":2,\"748\":2,\"762\":1,\"763\":2,\"764\":2,\"766\":5,\"768\":1,\"794\":2,\"799\":3,\"805\":1,\"823\":1,\"843\":1,\"958\":1,\"972\":2,\"973\":2,\"974\":2,\"983\":1,\"985\":2,\"986\":1,\"988\":8,\"990\":2,\"1089\":1,\"1099\":1,\"1107\":2,\"1133\":1,\"1137\":4,\"1144\":1,\"1157\":2,\"1161\":3,\"1162\":4,\"1167\":1,\"1171\":1,\"1172\":1,\"1525\":2}}],[\"tobean\",{\"1\":{\"1122\":1,\"1124\":1,\"1127\":1,\"1128\":2,\"1129\":4}}],[\"tobytearray\",{\"1\":{\"713\":1,\"714\":1,\"723\":2}}],[\"tokenargumentresolver\",{\"1\":{\"1357\":1}}],[\"tokenkey\",{\"1\":{\"1107\":3}}],[\"token刷新的拦截器\",{\"1\":{\"1100\":1}}],[\"token\",{\"1\":{\"1005\":1,\"1107\":3,\"1111\":3}}],[\"token机制实现接口幂等性\",{\"1\":{\"1005\":1}}],[\"token机制如何实现\",{\"1\":{\"1005\":1}}],[\"token机制\",{\"1\":{\"1005\":1}}],[\"top5\",{\"1\":{\"1162\":4}}],[\"topic的名字\",{\"1\":{\"1021\":1}}],[\"topic\",{\"0\":{\"1015\":1,\"1020\":1},\"1\":{\"1013\":1,\"1015\":1,\"1016\":1,\"1017\":1,\"1019\":1,\"1020\":1,\"1021\":2,\"1024\":4,\"1025\":5,\"1026\":8,\"1035\":2,\"1037\":3,\"1040\":1,\"1041\":2,\"1050\":1,\"1052\":1}}],[\"topics\",{\"1\":{\"1012\":1,\"1015\":2,\"1020\":1}}],[\"top1\",{\"1\":{\"974\":1}}],[\"topn函数\",{\"1\":{\"403\":1}}],[\"topn\",{\"0\":{\"362\":1,\"363\":1}}],[\"tools\",{\"0\":{\"1536\":1}}],[\"tools查看\",{\"1\":{\"293\":1}}],[\"toolrunner\",{\"1\":{\"962\":1,\"988\":1}}],[\"tool\",{\"0\":{\"1018\":1},\"1\":{\"962\":1,\"988\":1}}],[\"tofile\",{\"1\":{\"822\":1,\"1449\":1}}],[\"tohexstring\",{\"1\":{\"799\":2}}],[\"touch\",{\"1\":{\"749\":1}}],[\"touppercase\",{\"1\":{\"614\":1}}],[\"toarray\",{\"1\":{\"740\":2,\"1464\":1}}],[\"tojsonstr\",{\"1\":{\"1124\":1,\"1127\":1,\"1128\":1,\"1129\":3}}],[\"tojson\",{\"1\":{\"723\":1}}],[\"tocollection\",{\"1\":{\"621\":1}}],[\"tochararray\",{\"1\":{\"617\":1,\"668\":3,\"799\":1}}],[\"tolist\",{\"1\":{\"621\":1,\"1162\":2,\"1165\":2}}],[\"tomap\",{\"1\":{\"621\":1}}],[\"tom\",{\"1\":{\"340\":1}}],[\"tommyzihao\",{\"1\":{\"133\":1}}],[\"tomcat也不例外\",{\"1\":{\"1100\":1}}],[\"tomcat的运行原理\",{\"1\":{\"1100\":1}}],[\"tomcat\",{\"0\":{\"1411\":1,\"1447\":1,\"1448\":1},\"1\":{\"102\":1,\"791\":1,\"1155\":4,\"1355\":1,\"1411\":5,\"1413\":1,\"1414\":1,\"1442\":7,\"1447\":1,\"1449\":12,\"1454\":1}}],[\"tomcat插件\",{\"1\":{\"102\":2}}],[\"totalbytesread\",{\"1\":{\"744\":1}}],[\"totalmessages\",{\"1\":{\"744\":1}}],[\"totalmemory\",{\"1\":{\"70\":1}}],[\"total\",{\"1\":{\"81\":2,\"357\":2,\"360\":4,\"874\":2}}],[\"to\",{\"1\":{\"70\":1,\"76\":2,\"92\":3,\"117\":1,\"130\":1,\"190\":1,\"248\":8,\"279\":6,\"280\":3,\"337\":3,\"338\":1,\"579\":1,\"703\":2,\"718\":2,\"740\":1,\"799\":3,\"820\":8,\"968\":1,\"986\":2}}],[\"todo\",{\"0\":{\"1\":1,\"721\":1,\"938\":1,\"1047\":1,\"1058\":1},\"1\":{\"962\":3,\"972\":1,\"983\":1,\"985\":2,\"986\":4,\"988\":2,\"989\":1,\"990\":3,\"991\":4,\"1156\":1,\"1157\":1,\"1518\":1}}],[\"that\",{\"1\":{\"775\":1,\"876\":1}}],[\"than\",{\"1\":{\"369\":1,\"799\":1}}],[\"theunsafe\",{\"1\":{\"565\":4}}],[\"therad\",{\"1\":{\"564\":1}}],[\"then\",{\"1\":{\"279\":1,\"340\":7,\"351\":3,\"380\":2,\"382\":3,\"496\":2,\"1146\":1,\"1151\":4,\"1156\":2}}],[\"the\",{\"1\":{\"70\":6,\"92\":2,\"120\":1,\"127\":1,\"279\":3,\"348\":5,\"349\":2,\"442\":7,\"740\":1,\"775\":2,\"799\":8,\"1055\":1,\"1206\":2}}],[\"things\",{\"1\":{\"857\":2}}],[\"think\",{\"1\":{\"54\":2,\"68\":2}}],[\"thisiszhou\",{\"1\":{\"145\":1}}],[\"thisvesseldoesnotexist\",{\"1\":{\"125\":1}}],[\"thispersondoesnotexist\",{\"1\":{\"125\":1}}],[\"this\",{\"1\":{\"7\":1,\"14\":5,\"17\":13,\"34\":1,\"47\":1,\"52\":2,\"54\":5,\"59\":11,\"60\":1,\"70\":1,\"74\":6,\"76\":6,\"81\":5,\"85\":5,\"271\":1,\"278\":1,\"279\":1,\"373\":3,\"566\":1,\"579\":1,\"590\":1,\"592\":1,\"673\":2,\"717\":5,\"718\":10,\"725\":1,\"733\":5,\"740\":4,\"741\":2,\"742\":1,\"743\":2,\"846\":3,\"859\":5,\"972\":4,\"974\":8,\"985\":18,\"999\":2,\"1111\":1,\"1122\":2,\"1124\":1,\"1127\":1,\"1128\":2,\"1129\":6,\"1132\":1,\"1134\":1,\"1135\":2,\"1137\":1,\"1161\":4,\"1164\":3,\"1165\":2,\"1294\":2,\"1309\":3,\"1420\":1,\"1424\":1}}],[\"through\",{\"1\":{\"1120\":1}}],[\"throughput\",{\"1\":{\"1021\":2}}],[\"throwable\",{\"1\":{\"59\":22,\"60\":1,\"705\":1,\"716\":1,\"717\":3,\"718\":6,\"735\":1,\"740\":6,\"741\":3,\"743\":5,\"744\":1,\"857\":1,\"859\":3,\"1309\":2}}],[\"throws\",{\"1\":{\"9\":2,\"51\":2,\"52\":2,\"54\":3,\"59\":2,\"60\":1,\"68\":4,\"69\":3,\"70\":1,\"88\":3,\"373\":1,\"536\":1,\"585\":2,\"692\":5,\"696\":2,\"697\":2,\"698\":2,\"699\":2,\"702\":5,\"703\":2,\"704\":5,\"705\":2,\"707\":2,\"710\":1,\"711\":3,\"713\":2,\"714\":2,\"717\":1,\"718\":1,\"723\":2,\"726\":2,\"733\":2,\"735\":1,\"736\":1,\"737\":1,\"738\":1,\"740\":6,\"742\":1,\"743\":2,\"748\":5,\"753\":1,\"754\":3,\"757\":1,\"758\":2,\"766\":7,\"794\":1,\"795\":2,\"822\":6,\"839\":2,\"840\":1,\"843\":2,\"846\":3,\"857\":1,\"859\":1,\"958\":1,\"960\":1,\"962\":3,\"972\":7,\"973\":3,\"974\":5,\"983\":1,\"985\":6,\"986\":3,\"988\":7,\"990\":2,\"991\":1,\"1100\":1,\"1111\":3,\"1132\":1,\"1150\":1,\"1152\":1,\"1223\":1,\"1309\":2,\"1317\":1,\"1416\":1,\"1449\":2,\"1451\":1,\"1505\":6}}],[\"throw\",{\"1\":{\"6\":1,\"28\":1,\"47\":2,\"59\":10,\"69\":1,\"88\":2,\"566\":3,\"579\":2,\"585\":7,\"592\":1,\"717\":1,\"718\":1,\"723\":4,\"733\":1,\"737\":1,\"741\":1,\"799\":1,\"999\":3,\"1071\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1159\":1,\"1309\":5}}],[\"thresholod\",{\"1\":{\"873\":1}}],[\"threshold\",{\"1\":{\"579\":1,\"742\":2,\"870\":1,\"878\":1,\"879\":1}}],[\"threadid是自己\",{\"1\":{\"1151\":1}}],[\"threadid\",{\"1\":{\"1144\":4,\"1152\":8}}],[\"threading\",{\"1\":{\"679\":1}}],[\"thread1\",{\"1\":{\"1141\":2}}],[\"threadexecutormap\",{\"1\":{\"762\":1,\"765\":2}}],[\"threadexecutormap$2\",{\"1\":{\"762\":1,\"765\":2}}],[\"threadlocal中是否有用户\",{\"1\":{\"1111\":1}}],[\"threadlocal<>\",{\"1\":{\"1101\":1}}],[\"threadlocal<userdto>\",{\"1\":{\"1101\":1}}],[\"threadlocalmap也是通过强引用指向entry对象\",{\"1\":{\"577\":1}}],[\"threadlocal底层是通过threadlocalmap来实现的\",{\"1\":{\"577\":1}}],[\"threadlocal是java所提供的线程本地存储机制\",{\"1\":{\"577\":1}}],[\"threadlocal\",{\"0\":{\"577\":1},\"1\":{\"792\":1,\"1111\":1}}],[\"threadfactory\",{\"1\":{\"572\":3,\"574\":3}}],[\"threadpoolexecutor参数\",{\"0\":{\"572\":1}}],[\"threadpoolexecutor\",{\"1\":{\"571\":1,\"572\":1,\"574\":5}}],[\"thread中的方法\",{\"1\":{\"534\":1}}],[\"threads\",{\"1\":{\"268\":1,\"276\":1,\"297\":1,\"298\":1,\"579\":1}}],[\"thread\",{\"1\":{\"47\":2,\"446\":1,\"536\":6,\"541\":4,\"551\":4,\"554\":12,\"555\":12,\"564\":1,\"585\":2,\"591\":2,\"593\":2,\"702\":1,\"717\":2,\"718\":2,\"741\":4,\"742\":1,\"746\":2,\"748\":1,\"750\":1,\"751\":1,\"754\":1,\"757\":1,\"758\":1,\"759\":2,\"760\":1,\"761\":1,\"762\":4,\"763\":1,\"764\":1,\"765\":4,\"794\":1,\"795\":5,\"846\":2,\"857\":2,\"859\":3,\"867\":1,\"991\":2,\"1023\":1,\"1127\":2,\"1129\":1,\"1142\":1,\"1144\":2,\"1147\":1,\"1152\":1}}],[\"tf\",{\"1\":{\"6\":5,\"7\":2}}],[\"tf卡实现类\",{\"1\":{\"6\":1}}],[\"tf卡接口\",{\"1\":{\"6\":1}}],[\"tfcardimpl\",{\"1\":{\"6\":2,\"7\":1}}],[\"tfcard\",{\"1\":{\"6\":2,\"7\":11}}],[\"将返回一个modelandview给dispatcherservlet\",{\"1\":{\"1530\":1}}],[\"将返回值作为模型\",{\"1\":{\"1394\":2}}],[\"将返回值赋值给rep变量\",{\"1\":{\"69\":1}}],[\"将handler看作目标主机\",{\"1\":{\"1530\":1}}],[\"将hdfs与外部企业级密钥库\",{\"1\":{\"932\":1}}],[\"将根据请求的信息\",{\"1\":{\"1530\":1}}],[\"将软件分层的好处是\",{\"1\":{\"1528\":1}}],[\"将需要的可变成员变量保存在threadlocal中\",{\"1\":{\"1506\":1}}],[\"将需排序的元素与已排序序列进行比较\",{\"1\":{\"644\":1}}],[\"将那些与业务无关却为业务模块共同调用的逻辑或责任\",{\"1\":{\"1500\":1}}],[\"将结果返回给环绕通知2\",{\"1\":{\"1340\":1}}],[\"将结果为i的词存放到文件f\",{\"1\":{\"477\":1}}],[\"将高级\",{\"1\":{\"1333\":1}}],[\"将json格式数据封装成具体的vo或者po实体类\",{\"1\":{\"1229\":1}}],[\"将join好的数据集排序\",{\"1\":{\"991\":1}}],[\"将李四从张三的好友列表中移除\",{\"1\":{\"1210\":1}}],[\"将下列数据用redis的set集合来存储\",{\"1\":{\"1210\":1}}],[\"将操作不同数据类型的命令也做了分组\",{\"1\":{\"1204\":1}}],[\"将当前方法的返回值存入ioc容器\",{\"1\":{\"1507\":1}}],[\"将当前用户当天签到信息保存到\",{\"1\":{\"1175\":1}}],[\"将当前数据的时间戳和更新之前取得的时间戳进行比较\",{\"1\":{\"507\":1}}],[\"将多个\",{\"1\":{\"1174\":1}}],[\"将多个select合并成一个\",{\"1\":{\"386\":1}}],[\"将指定member的坐标转为hash字符串形式并返回\",{\"1\":{\"1170\":1}}],[\"将交集转换为list\",{\"1\":{\"1165\":1}}],[\"将优惠券id和用户id封装后存入阻塞队列\",{\"1\":{\"1156\":1}}],[\"将优惠券信息保存到redis中\",{\"1\":{\"1156\":1}}],[\"将逻辑进行封装\",{\"1\":{\"1129\":1}}],[\"将逻辑地址变换为物理地址\",{\"1\":{\"179\":1}}],[\"将任意java对象序列化为json并存储在string类型的key中\",{\"1\":{\"1129\":4}}],[\"将任务启动命令写到一个脚本中\",{\"1\":{\"953\":1}}],[\"将value取出\",{\"1\":{\"1128\":1}}],[\"将空值写入redis\",{\"1\":{\"1124\":1,\"1127\":1,\"1129\":2}}],[\"将缓存与数据库操作放在一个事务\",{\"1\":{\"1121\":1}}],[\"将缓存中的数据加载出来\",{\"1\":{\"1121\":1}}],[\"将缓冲第一个连接的结果\",{\"1\":{\"326\":1}}],[\"将查询到的hash数据转为userdto\",{\"1\":{\"1111\":1}}],[\"将查询回的数据\",{\"1\":{\"342\":1}}],[\"将user对象转换为userdto对象\",{\"1\":{\"1165\":1}}],[\"将user对象转为hashmap存储\",{\"1\":{\"1107\":1}}],[\"将user对象换成userdto\",{\"1\":{\"1101\":1}}],[\"将分片分配给某个节点的过程\",{\"1\":{\"1068\":1}}],[\"将分两个阶段运行该应用程序\",{\"1\":{\"952\":1}}],[\"将我们普通的作业包装成受控作业\",{\"1\":{\"991\":2}}],[\"将我们提供了的匿名内部类对象传递给了父类\",{\"1\":{\"59\":1}}],[\"将属于同一笔订单的所有商品信息汇聚在一起\",{\"1\":{\"988\":1}}],[\"将州state相同的分为一组\",{\"1\":{\"974\":1}}],[\"将美国疫情数据不同州的输出到不同文件中\",{\"1\":{\"973\":1}}],[\"将得到的任务进一步分配给内部的任务\",{\"1\":{\"947\":1}}],[\"将系统中的资源分配给各个正在运行的应用程序\",{\"1\":{\"945\":1}}],[\"将map的每条结果通过context\",{\"1\":{\"979\":1}}],[\"将maptask产生的所有小文件进行合并\",{\"1\":{\"435\":1}}],[\"将mysnap1重命名为mysnap2\",{\"1\":{\"914\":1}}],[\"将先前的active节点隔离\",{\"1\":{\"885\":1}}],[\"将以阈值5\",{\"1\":{\"873\":1}}],[\"将通知统一转为环绕通知\",{\"1\":{\"1322\":1}}],[\"将通知notempty条件\",{\"1\":{\"584\":1}}],[\"将通过磁盘均衡器来实现\",{\"1\":{\"873\":1}}],[\"将虚引用加入引用队列\",{\"1\":{\"855\":1}}],[\"将堆外内存映射到\",{\"1\":{\"855\":1}}],[\"将错乱的数据恢复成原始的按\",{\"1\":{\"809\":1}}],[\"将来此类被导入时就会做条件检查\",{\"1\":{\"1466\":1}}],[\"将来还可以使用其他的一些序列化框架\",{\"1\":{\"1023\":1}}],[\"将来\",{\"1\":{\"792\":1,\"1441\":1}}],[\"将原始\",{\"1\":{\"775\":1}}],[\"将原有的对象重新分配\",{\"1\":{\"606\":1}}],[\"将要执行的代码作为任务提交给下一个事件循环处理\",{\"1\":{\"749\":1}}],[\"将线程池的当前线程保存在成员变量中\",{\"1\":{\"741\":1}}],[\"将消息对象发送出去\",{\"1\":{\"737\":1}}],[\"将方法调用转换为\",{\"1\":{\"737\":1}}],[\"将发送一个拒绝连接的错误信息到\",{\"1\":{\"726\":1}}],[\"将该请求从\",{\"1\":{\"726\":1}}],[\"将该词出现的次数加1\",{\"1\":{\"477\":1}}],[\"将内存中暂时不用的页\",{\"1\":{\"688\":1}}],[\"将内存分为几个固定大校的块\",{\"1\":{\"683\":1}}],[\"将页表进行分页\",{\"1\":{\"683\":1}}],[\"将页表继续根据页框大小进行拆分\",{\"1\":{\"186\":1}}],[\"将用户的敏感信息进行隐藏\",{\"1\":{\"1101\":1}}],[\"将用户程序的地址空间分为若干个固定大小的区域\",{\"1\":{\"683\":1}}],[\"将用户关系的文件描述符的时间存放到内核的一个事件表中\",{\"1\":{\"680\":1}}],[\"将用户空间划分为若干个固定大小的分区\",{\"1\":{\"182\":1}}],[\"将最高的1g字节供内核使用\",{\"1\":{\"676\":1}}],[\"将\",{\"1\":{\"662\":1,\"841\":1,\"854\":1,\"855\":2,\"1012\":1,\"1046\":1,\"1343\":2,\"1438\":1}}],[\"将待排序元素插入到后移序列的前方\",{\"1\":{\"644\":1}}],[\"将此位置起的所有已排序序列后移一位\",{\"1\":{\"644\":1}}],[\"将流转换为其他形式\",{\"1\":{\"621\":1}}],[\"将流中的每个值都换成另一个流\",{\"1\":{\"617\":1}}],[\"将元素转换成其他形式或提取信息\",{\"1\":{\"617\":1}}],[\"将满足条件的字符串添加到集合中去\",{\"1\":{\"614\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"605\":1}}],[\"将链表转换成红黑树之前会判断\",{\"1\":{\"605\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"599\":1}}],[\"将基本类型用他们的引用类型包装起来\",{\"1\":{\"599\":1}}],[\"将其注入到类中使用\",{\"1\":{\"1525\":1}}],[\"将其他通知统一转换为\",{\"1\":{\"1343\":1,\"1350\":1}}],[\"将其前方的序列视为已排序序列\",{\"1\":{\"644\":1}}],[\"将其与最后一个元素进行交换\",{\"1\":{\"643\":1}}],[\"将其队列中的元素移动到aqs队列中等待被唤醒\",{\"1\":{\"584\":1}}],[\"将其移动到aqs的队列中\",{\"1\":{\"584\":1}}],[\"将有用户敏感信息的user对象转化成没有敏感信息的userdto对象\",{\"1\":{\"1101\":1}}],[\"将有相同key的key\",{\"1\":{\"979\":1}}],[\"将有来的引用指向新副本\",{\"1\":{\"578\":1}}],[\"将有序链表改造为支持类似\",{\"1\":{\"518\":1}}],[\"将之前的arraylist拷贝一份\",{\"1\":{\"578\":1}}],[\"将之前endtime的9999\",{\"1\":{\"409\":1}}],[\"将修改后的值存入静态变量i\",{\"1\":{\"560\":1}}],[\"将某一台slave作为master\",{\"1\":{\"526\":1}}],[\"将buffer\",{\"1\":{\"506\":2}}],[\"将文件按照顺序切分成大小不超过2m的小文件\",{\"1\":{\"478\":1}}],[\"将大数据变成小数据\",{\"0\":{\"468\":1}}],[\"将大表放置在最后有助于减少reducer阶段缓存数据所需要的内存\",{\"1\":{\"326\":1}}],[\"将过滤表达式尽可能移动至靠近数据源的位置\",{\"1\":{\"459\":1}}],[\"将两张表按照相同的规则将数据划分\",{\"1\":{\"450\":1}}],[\"将两张表的数据在shuffle阶段利用shuffle的分组来将数据按照关联字段进行合并\",{\"1\":{\"449\":1}}],[\"将小的那份数据给每个maptask的内存都放一份完整的数据\",{\"1\":{\"448\":1}}],[\"将整个hql语句的实现步骤\",{\"1\":{\"440\":1}}],[\"将reducetask产生的所有小文件进行合并\",{\"1\":{\"435\":1}}],[\"将row写入文件时\",{\"1\":{\"250\":1}}],[\"将各自的数据进行划分\",{\"1\":{\"418\":1}}],[\"将各个目标模块装入内存时\",{\"1\":{\"179\":1}}],[\"将各个目标模块连接到装入模块\",{\"1\":{\"179\":1}}],[\"将不同部分的数值移动到指定的位置\",{\"1\":{\"999\":1}}],[\"将不同分区的数据单独使用一个hdfs目录来进行存储\",{\"1\":{\"415\":1}}],[\"将不会意识到分区信息的这些更改\",{\"1\":{\"281\":1}}],[\"将里面的||转换为|\",{\"1\":{\"373\":1}}],[\"将每个分组内的数据分为指定的若干个桶里\",{\"1\":{\"364\":1}}],[\"将主查询的数据\",{\"1\":{\"332\":1}}],[\"将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性\",{\"1\":{\"15\":1}}],[\"将使用缓冲的行来计算联接\",{\"1\":{\"326\":2}}],[\"将会从以下几个方面介绍\",{\"1\":{\"1005\":1}}],[\"将会非常非常慢\",{\"1\":{\"325\":1}}],[\"将会返回被连接的两个表的笛卡尔积\",{\"1\":{\"325\":1}}],[\"将删除所有现有列\",{\"1\":{\"279\":1}}],[\"将真实表中特定的列数据提供给用户\",{\"1\":{\"272\":1}}],[\"将冻结视图的架构\",{\"1\":{\"270\":1}}],[\"将数据库表中的数据导入到\",{\"1\":{\"1171\":1}}],[\"将数据库结果写入缓存\",{\"1\":{\"1122\":1}}],[\"将数据集join\",{\"1\":{\"991\":1}}],[\"将数据读入\",{\"1\":{\"861\":1}}],[\"将数据读入内核缓冲区\",{\"1\":{\"854\":1}}],[\"将数据传递给下个\",{\"1\":{\"766\":1}}],[\"将数据从内核缓冲区读入用户缓冲区\",{\"1\":{\"854\":1}}],[\"将数据从内核拷贝到进程中\",{\"1\":{\"679\":1}}],[\"将数据从kernel拷贝到用户进程\",{\"1\":{\"679\":1}}],[\"将数据分片\",{\"1\":{\"527\":1}}],[\"将数据划分到不同的文件中进行存储\",{\"1\":{\"417\":1}}],[\"将数据按照查询的条件\",{\"1\":{\"415\":1}}],[\"将数据根据cookieid分\",{\"1\":{\"364\":1}}],[\"将数据文件移动到与hive表对应的位置\",{\"1\":{\"283\":1}}],[\"将数据缓存\",{\"1\":{\"275\":1}}],[\"将数据写入hdfs文件中\",{\"1\":{\"250\":1}}],[\"将数据结构化并转换为适合目标数据仓库系统的形式\",{\"1\":{\"228\":1}}],[\"将一条记录中的value根据分隔符切分为各个字段\",{\"1\":{\"250\":1}}],[\"将一个文件通过\",{\"1\":{\"854\":1}}],[\"将一个\",{\"1\":{\"840\":1}}],[\"将一个字符串转换成大写并作为方法的返回值\",{\"1\":{\"614\":1}}],[\"将一个复杂对象的构建与表示分离\",{\"1\":{\"12\":1}}],[\"将一个类的接口转换成客户希望的另外一个接口\",{\"1\":{\"4\":1}}],[\"将明细事实表的某些重要维度属性字段做适当冗余\",{\"1\":{\"226\":1}}],[\"将上层发出的一系列命令\",{\"1\":{\"210\":1}}],[\"将上面的\",{\"1\":{\"54\":1}}],[\"将磁头移动到指定磁盘所花的时间\",{\"1\":{\"204\":1}}],[\"将所有文件合并为一个大文件作为输入\",{\"1\":{\"436\":1}}],[\"将所有可能被置换的页面排成一个循环队列\",{\"1\":{\"191\":1}}],[\"将所缺页面装入该块\",{\"1\":{\"190\":1}}],[\"将调入内存的页面根据调入的先后顺序排成一个队列\",{\"1\":{\"191\":1}}],[\"将作业换入\",{\"1\":{\"189\":1}}],[\"将近期会频繁访问到的数据放到更高速的存储器中\",{\"1\":{\"189\":1}}],[\"将进程中的若干个页分别装入到多个可以不相邻接的物理块中\",{\"1\":{\"683\":1}}],[\"将进程按逻辑模块分段\",{\"1\":{\"188\":1}}],[\"将进程重新方法就绪队列队尾重新排队\",{\"1\":{\"167\":1}}],[\"将装入模块装入到内存的适当位置\",{\"1\":{\"179\":1}}],[\"将程序分为多个段\",{\"1\":{\"181\":1}}],[\"将程序和数据装入内存\",{\"1\":{\"179\":1}}],[\"将程序状态字\",{\"1\":{\"157\":1}}],[\"将这些资源分配给其他死锁进程\",{\"1\":{\"178\":1}}],[\"将想要的资源强行剥夺\",{\"1\":{\"176\":1}}],[\"将被强行剥夺处理机使用权\",{\"1\":{\"167\":1}}],[\"将cpu分给紧急的那个进程\",{\"1\":{\"165\":1}}],[\"将c1对象写出到文件中\",{\"1\":{\"54\":1}}],[\"将处理机分配给它\",{\"1\":{\"164\":1}}],[\"将n各用户及线程映射到m各内核级线程上\",{\"1\":{\"163\":1}}],[\"将pcb插入合适的队列\",{\"1\":{\"161\":1}}],[\"将运行环境保存到pcb\",{\"1\":{\"161\":1}}],[\"将裸机改造为功能更强\",{\"1\":{\"154\":1}}],[\"将相同尺度的特征沿通道方向摞起来\",{\"1\":{\"137\":1}}],[\"将相同部分的代码放在抽象的父类中\",{\"1\":{\"86\":1}}],[\"将容易变的部分抽象出来\",{\"1\":{\"87\":1}}],[\"将instance对象写出到文件中\",{\"1\":{\"68\":1}}],[\"将奖状的名字修改李四\",{\"1\":{\"52\":1}}],[\"将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族\",{\"1\":{\"36\":1}}],[\"将复杂产品的创建步骤分解在不同的方法中\",{\"1\":{\"15\":1}}],[\"将产品本身与产品的创建过程解耦\",{\"1\":{\"15\":1}}],[\"将tf卡中的内容读取出来\",{\"1\":{\"6\":1}}],[\"将220v转换为5v的电压\",{\"1\":{\"4\":1}}],[\"​​​\",{\"1\":{\"140\":1}}],[\"​\\t2\",{\"1\":{\"43\":1}}],[\"​\",{\"0\":{\"362\":1},\"1\":{\"4\":2,\"9\":1,\"43\":1,\"66\":3,\"122\":3,\"190\":1}}],[\"幻灯片页\",{\"0\":{\"2\":1}}],[\"介绍一下sprig\",{\"0\":{\"1532\":1}}],[\"介绍一下spring\",{\"0\":{\"1530\":1}}],[\"介绍spring\",{\"0\":{\"1522\":1}}],[\"介绍\",{\"0\":{\"0\":1},\"1\":{\"515\":5}}]],\"serializationVersion\":2}";