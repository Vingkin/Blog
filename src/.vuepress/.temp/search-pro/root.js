export default "{\"documentCount\":1061,\"nextId\":1061,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-2e3eac9e\",\"2\":\"v-dde31c18\",\"3\":\"v-dde31c18#附录\",\"4\":\"v-dde31c18#趣味应用\",\"5\":\"v-dde31c18#作者相关\",\"6\":\"v-dde31c18#博客\",\"7\":\"v-dde31c18#代码复现\",\"8\":\"v-b548c708\",\"9\":\"v-b548c708#附录\",\"10\":\"v-b548c708#生成对抗网络gan开山之作\",\"11\":\"v-b548c708#趣味demo\",\"12\":\"v-b548c708#作者相关\",\"13\":\"v-b548c708#博客\",\"14\":\"v-b548c708#代码复现\",\"15\":\"v-0a003464\",\"16\":\"v-0a003464#附录\",\"17\":\"v-0a003464#主页\",\"18\":\"v-0a003464#趣味案例\",\"19\":\"v-0a003464#代码\",\"20\":\"v-61b2520c\",\"21\":\"v-61b2520c#网络结构\",\"22\":\"v-61b2520c#backbone-darknet-53\",\"23\":\"v-61b2520c#neck\",\"24\":\"v-61b2520c#head\",\"25\":\"v-61b2520c#正负样本\",\"26\":\"v-61b2520c#损失函数\",\"27\":\"v-61b2520c#训练过程\",\"28\":\"v-61b2520c#测试过程\",\"29\":\"v-61b2520c#附录\",\"30\":\"v-61b2520c#官方\",\"31\":\"v-61b2520c#博客\",\"32\":\"v-61b2520c#代码复现\",\"33\":\"v-61b2520c#ms-coco目标检测数据集80个类别\",\"34\":\"v-2f366b20\",\"35\":\"v-2f366b20#_1\",\"36\":\"v-2f366b20#_2\",\"37\":\"v-2f366b20#_3\",\"38\":\"v-f66aca42\",\"39\":\"v-f66aca42#概述\",\"40\":\"v-f66aca42#结构\",\"41\":\"v-f66aca42#类适配器模式\",\"42\":\"v-f66aca42#对象适配器模式\",\"43\":\"v-f66aca42#应用场景\",\"44\":\"v-f66aca42#jdk源码解析\",\"45\":\"v-f66aca42#代理-v-s-桥接-v-s-装饰器-v-s-适配器\",\"46\":\"v-42d31e13\",\"47\":\"v-42d31e13#概述\",\"48\":\"v-42d31e13#结构\",\"49\":\"v-42d31e13#实例\",\"50\":\"v-42d31e13#优缺点\",\"51\":\"v-42d31e13#使用场景\",\"52\":\"v-42d31e13#模式扩展\",\"53\":\"v-42d31e13#创建者模式对比\",\"54\":\"v-42d31e13#工厂方法模式vs建造者模式\",\"55\":\"v-42d31e13#抽象工厂模式vs建造者模式\",\"56\":\"v-c683763a\",\"57\":\"v-c683763a#单例模式\",\"58\":\"v-c683763a#工厂模式\",\"59\":\"v-4b132bf8\",\"60\":\"v-4b132bf8#概述\",\"61\":\"v-4b132bf8#简单工厂模式\",\"62\":\"v-4b132bf8#结构\",\"63\":\"v-4b132bf8#实现\",\"64\":\"v-4b132bf8#优缺点\",\"65\":\"v-4b132bf8#扩展\",\"66\":\"v-4b132bf8#工厂方法模式\",\"67\":\"v-4b132bf8#概念\",\"68\":\"v-4b132bf8#结构-1\",\"69\":\"v-4b132bf8#实现-1\",\"70\":\"v-4b132bf8#优缺点-1\",\"71\":\"v-4b132bf8#抽象工厂模式\",\"72\":\"v-4b132bf8#概念-1\",\"73\":\"v-4b132bf8#结构-2\",\"74\":\"v-4b132bf8#实现-2\",\"75\":\"v-4b132bf8#优缺点-2\",\"76\":\"v-4b132bf8#使用场景\",\"77\":\"v-4b132bf8#模式扩展\",\"78\":\"v-4b132bf8#jdk源码解析-collection-iterator方法\",\"79\":\"v-f06d0324\",\"80\":\"v-f06d0324#概述\",\"81\":\"v-f06d0324#结构\",\"82\":\"v-f06d0324#示例\",\"83\":\"v-41c3c8a8\",\"84\":\"v-41c3c8a8#概述\",\"85\":\"v-41c3c8a8#结构\",\"86\":\"v-41c3c8a8#实现\",\"87\":\"v-41c3c8a8#案例\",\"88\":\"v-41c3c8a8#使用场景\",\"89\":\"v-41c3c8a8#扩展-深克隆\",\"90\":\"v-3b988860\",\"91\":\"v-3b988860#概述\",\"92\":\"v-3b988860#结构\",\"93\":\"v-3b988860#静态代理\",\"94\":\"v-3b988860#jdk动态代理\",\"95\":\"v-3b988860#cglib动态代理\",\"96\":\"v-3b988860#三种代理的对比\",\"97\":\"v-3b988860#优缺点\",\"98\":\"v-3b988860#使用场景\",\"99\":\"v-5e039b3a\",\"100\":\"v-5e039b3a#单例模式的结构\",\"101\":\"v-5e039b3a#单例模式的实现\",\"102\":\"v-5e039b3a#存在的问题\",\"103\":\"v-5e039b3a#问题演示\",\"104\":\"v-5e039b3a#问题的解决\",\"105\":\"v-5e039b3a#jdk源码解析-runtime类\",\"106\":\"v-75236f30\",\"107\":\"v-75236f30#开闭原则\",\"108\":\"v-75236f30#里氏代换原则\",\"109\":\"v-75236f30#依赖倒转原则\",\"110\":\"v-75236f30#接口隔离原则\",\"111\":\"v-75236f30#迪米特法则\",\"112\":\"v-75236f30#合成复用原则\",\"113\":\"v-1e9c07f1\",\"114\":\"v-1e9c07f1#概述\",\"115\":\"v-1e9c07f1#结构\",\"116\":\"v-1e9c07f1#示例\",\"117\":\"v-4d746b4a\",\"118\":\"v-4d746b4a#概述\",\"119\":\"v-4d746b4a#结构\",\"120\":\"v-4d746b4a#案例实现\",\"121\":\"v-4d746b4a#优缺点\",\"122\":\"v-4d746b4a#适用场景\",\"123\":\"v-4d746b4a#jdk源码解析\",\"124\":\"v-1d1fa55e\",\"125\":\"v-1d1fa55e#_1、操作系统的概念\",\"126\":\"v-1d1fa55e#_2、操作系统需要实现的功能\",\"127\":\"v-1d1fa55e#_3、操作系统的四个特征\",\"128\":\"v-1d1fa55e#_4、os的运行机制和体系结构\",\"129\":\"v-1d1fa55e#_5、中断\",\"130\":\"v-1d1fa55e#_6、系统调用\",\"131\":\"v-1d1fa55e#_7、进程\",\"132\":\"v-1d1fa55e#_8、进程的状态\",\"133\":\"v-1d1fa55e#_9、进程控制\",\"134\":\"v-1d1fa55e#_10、进程通信\",\"135\":\"v-1d1fa55e#_11、线程、多线程模型\",\"136\":\"v-1d1fa55e#_12、处理机的调度\",\"137\":\"v-1d1fa55e#_13、进程调度的时机、切换与过程的调度方式\",\"138\":\"v-1d1fa55e#_14、调度算法评价指标\",\"139\":\"v-1d1fa55e#_15、调度算法\",\"140\":\"v-1d1fa55e#_16、进程同步、进程互斥\",\"141\":\"v-1d1fa55e#_17、进程互斥的软件实现方法\",\"142\":\"v-1d1fa55e#_18、进程互斥的硬件实现方法\",\"143\":\"v-1d1fa55e#_19、信号量机制\",\"144\":\"v-1d1fa55e#_20、用信号量机制实现进程互斥、同步、前驱关系\",\"145\":\"v-1d1fa55e#_21、管程\",\"146\":\"v-1ed47dfd\",\"147\":\"v-1ed47dfd#_1、死锁的概念\",\"148\":\"v-1ed47dfd#_2、死锁的处理策略-预防死锁\",\"149\":\"v-1ed47dfd#_3、死锁的处理策略-避免死锁\",\"150\":\"v-1ed47dfd#_4、死锁的处理策略-检测和解除\",\"151\":\"v-1ed47dfd#_5、内存的基础知识\",\"152\":\"v-1ed47dfd#_6、内存管理的概念\",\"153\":\"v-1ed47dfd#_7、内存空间的扩充-覆盖与交换\",\"154\":\"v-1ed47dfd#_8、内存空间的分配-连续分配管理方式\",\"155\":\"v-1ed47dfd#_9、动态分区分配算法\",\"156\":\"v-1ed47dfd#_10、基本分页存储管理的基本概念\",\"157\":\"v-1ed47dfd#_11、基地址变换机构\",\"158\":\"v-1ed47dfd#_12、两级页表\",\"159\":\"v-1ed47dfd#_13、基本分段存储管理方式\",\"160\":\"v-1ed47dfd#_14、段页式管理方式\",\"161\":\"v-1ed47dfd#_15、虚拟内存的概念\",\"162\":\"v-1ed47dfd#_16、请求分页存储管理\",\"163\":\"v-1ed47dfd#_17、页面置换算法\",\"164\":\"v-1ed47dfd#_18、页面分配策略\",\"165\":\"v-2089569c\",\"166\":\"v-2089569c#_1、初识文件管理\",\"167\":\"v-2089569c#_2、文件的逻辑结构\",\"168\":\"v-2089569c#_3、文件目录\",\"169\":\"v-2089569c#_4、文件的物理结构\",\"170\":\"v-2089569c#_5、文件存储空间管理\",\"171\":\"v-2089569c#_6、文件的基本操作\",\"172\":\"v-2089569c#_7、文件共享\",\"173\":\"v-2089569c#_8、文件保护\",\"174\":\"v-2089569c#_9、文件系统的层次结构\",\"175\":\"v-2089569c#_10、磁盘的结构\",\"176\":\"v-2089569c#_11、磁盘调度算法\",\"177\":\"v-2089569c#_12、减少延迟时间的方法\",\"178\":\"v-2089569c#_13、磁盘的管理\",\"179\":\"v-2089569c#_14、i-o设备的基本概念和分类\",\"180\":\"v-2089569c#_15、i-o控制器\",\"181\":\"v-2089569c#_16、i-o控制方式\",\"182\":\"v-2089569c#_17、i-o软件层次结构\",\"183\":\"v-2089569c#_18、i-o核心子系统\",\"184\":\"v-2089569c#_19、假脱机技术\",\"185\":\"v-2089569c#_20、设备的分配与回收\",\"186\":\"v-2089569c#_21、缓冲区管理\",\"187\":\"v-7692a618\",\"188\":\"v-7692a618#排序\",\"189\":\"v-7692a618#选择排序\",\"190\":\"v-7692a618#插入排序\",\"191\":\"v-7692a618#快排\",\"192\":\"v-7692a618#埃氏筛\",\"193\":\"v-7692a618#背包\",\"194\":\"v-7692a618#_01背包\",\"195\":\"v-7692a618#完全背包\",\"196\":\"v-31c50a00\",\"197\":\"v-31c50a00#get和post的区别\",\"198\":\"v-31c50a00#输入网址到网页显示期间发生了什么\",\"199\":\"v-31c50a00@0\",\"200\":\"v-31c50a00@1\",\"201\":\"v-48882988\",\"202\":\"v-48882988#start-和run\",\"203\":\"v-48882988#sleep-与yield\",\"204\":\"v-48882988#interrupt\",\"205\":\"v-48882988#线程优先级\",\"206\":\"v-48882988#两阶段终止模式\",\"207\":\"v-48882988#守护线程\",\"208\":\"v-48882988#线程状态\",\"209\":\"v-48882988#变量的线程安全分析\",\"210\":\"v-48882988#对象头\",\"211\":\"v-48882988#monitor原理\",\"212\":\"v-48882988#自旋优化\",\"213\":\"v-48882988#轻量级锁\",\"214\":\"v-48882988#偏向锁\",\"215\":\"v-48882988#wait-和notify\",\"216\":\"v-48882988#sleep-和wait-的区别\",\"217\":\"v-48882988#保护性暂停模式\",\"218\":\"v-48882988#生产者消费者模式\",\"219\":\"v-48882988#park-和unpark\",\"220\":\"v-48882988#死锁-活锁-饥饿\",\"221\":\"v-48882988#死锁\",\"222\":\"v-48882988#活锁\",\"223\":\"v-48882988#饥饿\",\"224\":\"v-48882988#固定线程运行顺序\",\"225\":\"v-48882988#线程交替输出\",\"226\":\"v-48882988#并发编程的三大特性\",\"227\":\"v-48882988#volatile原理\",\"228\":\"v-48882988#volatile和synchronized\",\"229\":\"v-48882988#volatile和synchronized在有序性上的不同\",\"230\":\"v-48882988#i-是否线程安全\",\"231\":\"v-48882988#cas的特点\",\"232\":\"v-48882988#atomic原子类\",\"233\":\"v-48882988#原子引用aba问题\",\"234\":\"v-48882988#longadder原理\",\"235\":\"v-48882988#unsafe\",\"236\":\"v-48882988#不可变类\",\"237\":\"v-48882988#final原理\",\"238\":\"v-48882988#享元模式\",\"239\":\"v-48882988#线程池\",\"240\":\"v-48882988#线程池的好处\",\"241\":\"v-48882988#线程池状态\",\"242\":\"v-48882988#threadpoolexecutor参数\",\"243\":\"v-48882988#拒绝策略\",\"244\":\"v-48882988#executors创建的线程池\",\"245\":\"v-48882988#执行-execute-方法和-submit-方法的区别是什么呢\",\"246\":\"v-48882988#线程池创建多少线程合适\",\"247\":\"v-48882988#threadlocal\",\"248\":\"v-48882988#copyonwritearraylist\",\"249\":\"v-48882988#concurrenthashmap\",\"250\":\"v-48882988#aqs\",\"251\":\"v-48882988#aqs是什么\",\"252\":\"v-48882988#状态变量state\",\"253\":\"v-48882988#aqs队列\",\"254\":\"v-48882988#condition队列\",\"255\":\"v-48882988#模板方法\",\"256\":\"v-48882988#reentrantlock\",\"257\":\"v-48882988#reentrantlock与synchronized的区别\",\"258\":\"v-48882988#reentrantlock的公平锁和非公平锁\",\"259\":\"v-48882988#reentrantreadwritelock\",\"260\":\"v-48882988#stampedlock\",\"261\":\"v-48882988#semaphore\",\"262\":\"v-48882988#countdownlatch\",\"263\":\"v-48882988#cyclicbarrier\",\"264\":\"v-07eb9021\",\"265\":\"v-07eb9021#建表规约\",\"266\":\"v-07eb9021#索引规约\",\"267\":\"v-07eb9021#sql语句\",\"268\":\"v-07eb9021#orm映射\",\"269\":\"v-6c2eafea\",\"270\":\"v-6c2eafea#红黑树\",\"271\":\"v-6c2eafea#布隆过滤器\",\"272\":\"v-6c2eafea#什么是布隆过滤器\",\"273\":\"v-6c2eafea#布隆过滤器的原理介绍\",\"274\":\"v-6c2eafea#布隆过滤器使用场景\",\"275\":\"v-6c2eafea#sds\",\"276\":\"v-6c2eafea#c-语言字符串的缺陷\",\"277\":\"v-6c2eafea#sds-结构设计\",\"278\":\"v-6c2eafea#压缩列表\",\"279\":\"v-6c2eafea#压缩列表结构设计\",\"280\":\"v-6c2eafea#连锁更新\",\"281\":\"v-6c2eafea#压缩列表的缺陷\",\"282\":\"v-6c2eafea#前缀树-字典树\",\"283\":\"v-6c2eafea#二叉树构建\",\"284\":\"v-6c2eafea#图的构建\",\"285\":\"v-6c2eafea#并查集\",\"286\":\"v-6c2eafea#树状数组\",\"287\":\"v-6c2eafea#单点更新-区间求和\",\"288\":\"v-3bfb0196\",\"289\":\"v-3bfb0196#题目描述\",\"290\":\"v-3bfb0196#解法1-存在问题\",\"291\":\"v-3bfb0196#解法2\",\"292\":\"v-03d30350\",\"293\":\"v-03d30350#自我介绍\",\"294\":\"v-03d30350#项目名称\",\"295\":\"v-03d30350#项目描述\",\"296\":\"v-03d30350#负责模块\",\"297\":\"v-03d30350#项目的难点\",\"298\":\"v-03d30350#项目的创新点\",\"299\":\"v-03d30350#项目-实习中学到了什么\",\"300\":\"v-03d30350#课题是什么以及创新点\",\"301\":\"v-03d30350#自己的优点\",\"302\":\"v-03d30350#自己的缺点\",\"303\":\"v-03d30350#你自己最认可的一件事是什么\",\"304\":\"v-03d30350#为什么选择华为\",\"305\":\"v-03d30350#你对华为有什么了解\",\"306\":\"v-03d30350#最近在看什么书\",\"307\":\"v-03d30350#未来五年的职业规划\",\"308\":\"v-03d30350#在什么事情来临的时候-你会感到有些紧张\",\"309\":\"v-03d30350#请你讲一个最近比较烦心的事情。\",\"310\":\"v-03d30350#请举例讲述一次你失败的经历。\",\"311\":\"v-03d30350#请讲述这样一次经历-在任务完成的过程中遇到了困难-但通过你的积极应对-最终使问题得以成功解决。\",\"312\":\"v-60788202\",\"313\":\"v-60788202#为什么需要幂等性\",\"314\":\"v-60788202#http的幂等性\",\"315\":\"v-60788202#幂等性的实现方式\",\"316\":\"v-6e1ae746\",\"317\":\"v-6e1ae746#接口和抽象类有什么共同点和区别\",\"318\":\"v-6e1ae746#equals和hashcode\",\"319\":\"v-6e1ae746#与equals的区别\",\"320\":\"v-6e1ae746#包装类型的常量池技术\",\"321\":\"v-6e1ae746#自动装箱与自动拆箱\",\"322\":\"v-6e1ae746#arraylist和linkedlist的区别\",\"323\":\"v-6e1ae746#arraylist的扩容机制\",\"324\":\"v-6e1ae746#list删除元素问题\",\"325\":\"v-6e1ae746#comparable和comparator的区别\",\"326\":\"v-6e1ae746#hashset、linkedhashset和treeset三者的异同\",\"327\":\"v-6e1ae746#hashmap的底层实现\",\"328\":\"v-6e1ae746#hashmap的扩容机制\",\"329\":\"v-6e1ae746#hashmap在jdk-1-7的死链问题\",\"330\":\"v-6e1ae746#bio-nio-aio\",\"331\":\"v-6e1ae746#bio\",\"332\":\"v-6e1ae746#nio\",\"333\":\"v-6e1ae746#aio\",\"334\":\"v-6e1ae746#总结\",\"335\":\"v-48645c90\",\"336\":\"v-48645c90#lambda\",\"337\":\"v-48645c90#stream\",\"338\":\"v-48645c90#筛选与切片\",\"339\":\"v-48645c90#映射\",\"340\":\"v-48645c90#排序\",\"341\":\"v-48645c90#查找与匹配\",\"342\":\"v-48645c90#规约\",\"343\":\"v-48645c90#收集\",\"344\":\"v-ce17609c\",\"345\":\"v-ce17609c#双亲委派机制\",\"346\":\"v-ce17609c#沙箱安全机制\",\"347\":\"v-ce17609c#使用pc寄存器存储字节码指令地址有什么用呢\",\"348\":\"v-ce17609c#举例栈溢出的情况\",\"349\":\"v-ce17609c#方法中定义的局部变量是否线程安全\",\"350\":\"v-ce17609c#minor-gc、major-gc、full-gc\",\"351\":\"v-ce17609c#创建对象的方式\",\"352\":\"v-ce17609c#创建对象的步骤\",\"353\":\"v-ce17609c#对象的内存布局\",\"354\":\"v-ce17609c#字符串拼接\",\"355\":\"v-ce17609c#gc大厂面试题\",\"356\":\"v-ce17609c#增量收集算法\",\"357\":\"v-ce17609c#system-gc-的理解\",\"358\":\"v-ce17609c#内存溢出和内存泄漏的原因\",\"359\":\"v-ce17609c#评估gc的性能指标\",\"360\":\"v-ce17609c#_7种经典的垃圾回收器\",\"361\":\"v-ce17609c#垃圾回收器的选择\",\"362\":\"v-ce17609c#jdk-后续版本中-cms-的变化\",\"363\":\"v-7e82c0e0\",\"364\":\"v-7e82c0e0#mybatis\",\"365\":\"v-7e82c0e0#param-requestbody\",\"366\":\"v-7e82c0e0#和\",\"367\":\"v-7e82c0e0#mybatis分页操作\",\"368\":\"v-7e82c0e0#mybatis动态表模式实现\",\"369\":\"v-7e82c0e0#mybatis-plus\",\"370\":\"v-7e82c0e0#前端传来不定条件mybatis-plus的解决方案\",\"371\":\"v-7e82c0e0#函数式sql\",\"372\":\"v-7e82c0e0#mybatis-plus多数据源\",\"373\":\"v-7e82c0e0#通过mybatisx插件自动生成代码\",\"374\":\"v-d4089c5e\",\"375\":\"v-d4089c5e#说说对mysql索引的理解\",\"376\":\"v-d4089c5e#为了减少io-索引树会一次性加载吗\",\"377\":\"v-d4089c5e#b-树的存储能力如何-为何说一般查找行记录-最多只需1-3次磁盘io-为什么索引使用b-树\",\"378\":\"v-d4089c5e#为什么b-树比b树更适合做索引\",\"379\":\"v-d4089c5e#innodb为什么不建议用过长的字段作为主键\",\"380\":\"v-d4089c5e#innodb为什么使用自增主键是一个很好的选择\",\"381\":\"v-d4089c5e#hash结构效率高-那为什么还要使用b-树索引呢\",\"382\":\"v-d4089c5e#索引的分类\",\"383\":\"v-d4089c5e#哪些情况适合创建索引\",\"384\":\"v-d4089c5e#哪些情况不适合创建索引\",\"385\":\"v-d4089c5e#索引下推\",\"386\":\"v-d4089c5e#exists和in的区分\",\"387\":\"v-d4089c5e#count-count-1-和count-具体字段\",\"388\":\"v-d4089c5e#关于select\",\"389\":\"v-d4089c5e#多使用commit\",\"390\":\"v-d4089c5e#主键如何设计\",\"391\":\"v-d4089c5e#自增id的问题\",\"392\":\"v-d4089c5e#推荐的主键设计\",\"393\":\"v-d4089c5e#谈谈你对mvcc的了解\",\"394\":\"v-d4089c5e#where和having的区别\",\"395\":\"v-d4089c5e#数据库索引失效了怎么办\",\"396\":\"v-d4089c5e#事务的四大特性以及如何实现\",\"397\":\"v-d4089c5e#mysql的悲观锁和乐观锁\",\"398\":\"v-d4089c5e#根据锁的类型分类\",\"399\":\"v-d4089c5e#根据锁的粒度进行分类\",\"400\":\"v-d4089c5e#表锁\",\"401\":\"v-d4089c5e#行锁\",\"402\":\"v-d4089c5e#innodb中行级锁是怎么实现的\",\"403\":\"v-d4089c5e#数据库死锁问题以及解决办法\",\"404\":\"v-5107ff7b\",\"405\":\"v-5107ff7b#操作系统io介绍\",\"406\":\"v-5107ff7b#用户空间和内核空间-用户态和内核态\",\"407\":\"v-5107ff7b#文件描述符\",\"408\":\"v-5107ff7b#缓存-i-o\",\"409\":\"v-5107ff7b#i-o-模式\",\"410\":\"v-5107ff7b#select、poll和epoll的区别\",\"411\":\"v-5107ff7b#操作系统内存管理介绍\",\"412\":\"v-5107ff7b#内存管理主要是做什么\",\"413\":\"v-5107ff7b#常见的几种内存管理机制\",\"414\":\"v-5107ff7b#逻辑地址和物理地址\",\"415\":\"v-5107ff7b#为什么要有虚拟地址空间呢\",\"416\":\"v-5107ff7b#操作系统虚拟内存介绍\",\"417\":\"v-5107ff7b#局部性原理\",\"418\":\"v-5107ff7b#虚拟内存-虚拟存储器\",\"419\":\"v-5107ff7b#虚拟存储器的实现方法\",\"420\":\"v-5107ff7b#页面置换算法\",\"421\":\"v-14a0ac98\",\"422\":\"v-14a0ac98#redis常见数据结构以及使用场景\",\"423\":\"v-14a0ac98#redis到底是单线程还是多线程\",\"424\":\"v-14a0ac98#redis单线程为什么还快\",\"425\":\"v-14a0ac98#redis底层数据是如何用跳表来存储的\",\"426\":\"v-14a0ac98#redis-key过期了为什么内存没释放\",\"427\":\"v-14a0ac98#过期数据删除策略\",\"428\":\"v-14a0ac98#redis-key没设置过期时间为什么被redis主动删除了\",\"429\":\"v-14a0ac98#redis内存淘汰机制\",\"430\":\"v-14a0ac98#删除key的命令会阻塞redis吗\",\"431\":\"v-14a0ac98#redis高可用方案\",\"432\":\"v-14a0ac98#主从模式\",\"433\":\"v-14a0ac98#哨兵模式\",\"434\":\"v-14a0ac98#集群模式\",\"435\":\"v-14a0ac98#reids集群模式下数据hash分片算法\",\"436\":\"v-14a0ac98#redis执行命令出现死循环bug\",\"437\":\"v-14a0ac98#主从切换导致缓存雪崩具体场景\",\"438\":\"v-35efc841\",\"439\":\"v-35efc841#背景\",\"440\":\"v-35efc841#snowflake-雪花算法\",\"441\":\"v-35efc841#算法实现\",\"442\":\"v-35efc841#算法优缺点\",\"443\":\"v-35efc841#注意事项\",\"444\":\"v-71f302b2\",\"445\":\"v-71f302b2#容器与-bean\",\"446\":\"v-71f302b2#_1-容器接口\",\"447\":\"v-71f302b2#演示1-beanfactory-与-applicationcontext-的区别\",\"448\":\"v-71f302b2#代码参考\",\"449\":\"v-71f302b2#收获💡\",\"450\":\"v-71f302b2#演示2-国际化\",\"451\":\"v-71f302b2#_2-容器实现\",\"452\":\"v-71f302b2#演示1-defaultlistablebeanfactory\",\"453\":\"v-71f302b2#代码参考-1\",\"454\":\"v-71f302b2#收获💡-1\",\"455\":\"v-71f302b2#演示2-常见-applicationcontext-实现\",\"456\":\"v-71f302b2#代码参考-2\",\"457\":\"v-71f302b2#收获💡-2\",\"458\":\"v-71f302b2#_3-bean-的生命周期\",\"459\":\"v-71f302b2#演示1-bean-生命周期\",\"460\":\"v-71f302b2#代码参考-3\",\"461\":\"v-71f302b2#收获💡-3\",\"462\":\"v-71f302b2#演示2-模板方法设计模式\",\"463\":\"v-71f302b2#关键代码\",\"464\":\"v-71f302b2#演示3-bean-后处理器排序\",\"465\":\"v-71f302b2#代码参考-4\",\"466\":\"v-71f302b2#收获💡-4\",\"467\":\"v-71f302b2#_4-bean-后处理器\",\"468\":\"v-71f302b2#演示1-后处理器作用\",\"469\":\"v-71f302b2#代码参考-5\",\"470\":\"v-71f302b2#收获💡-5\",\"471\":\"v-71f302b2#演示2-autowired-bean-后处理器运行分析\",\"472\":\"v-71f302b2#代码参考-6\",\"473\":\"v-71f302b2#收获💡-6\",\"474\":\"v-71f302b2#_5-beanfactory-后处理器\",\"475\":\"v-71f302b2#演示1-beanfactory-后处理器的作用\",\"476\":\"v-71f302b2#代码参考-7\",\"477\":\"v-71f302b2#收获💡-7\",\"478\":\"v-71f302b2#演示2-模拟解析-componentscan\",\"479\":\"v-71f302b2#代码参考-8\",\"480\":\"v-71f302b2#收获💡-8\",\"481\":\"v-71f302b2#演示3-模拟解析-bean\",\"482\":\"v-71f302b2#代码参考-9\",\"483\":\"v-71f302b2#收获💡-9\",\"484\":\"v-71f302b2#演示4-模拟解析-mapper-接口\",\"485\":\"v-71f302b2#代码参考-10\",\"486\":\"v-71f302b2#收获💡-10\",\"487\":\"v-71f302b2#_6-aware-接口\",\"488\":\"v-71f302b2#演示-aware-接口及-initializingbean-接口\",\"489\":\"v-71f302b2#代码参考-11\",\"490\":\"v-71f302b2#收获💡-11\",\"491\":\"v-71f302b2#配置类-autowired-失效分析\",\"492\":\"v-71f302b2#_7-初始化与销毁\",\"493\":\"v-71f302b2#演示-初始化销毁顺序\",\"494\":\"v-71f302b2#代码参考-12\",\"495\":\"v-71f302b2#收获💡-12\",\"496\":\"v-71f302b2#_8-scope\",\"497\":\"v-71f302b2#演示1-request-session-application-作用域\",\"498\":\"v-71f302b2#代码参考-13\",\"499\":\"v-71f302b2#收获💡-13\",\"500\":\"v-71f302b2#分析-singleton-注入其它-scope-失效\",\"501\":\"v-71f302b2#演示2-4种解决方法\",\"502\":\"v-71f302b2#代码参考-14\",\"503\":\"v-71f302b2#收获💡-14\",\"504\":\"v-71f302b2#aop\",\"505\":\"v-71f302b2#_9-aop-实现之-ajc-编译器\",\"506\":\"v-71f302b2#收获💡-15\",\"507\":\"v-71f302b2#_10-aop-实现之-agent-类加载\",\"508\":\"v-71f302b2#收获💡-16\",\"509\":\"v-71f302b2#_11-aop-实现之-proxy\",\"510\":\"v-71f302b2#演示1-jdk-动态代理\",\"511\":\"v-71f302b2#收获💡-17\",\"512\":\"v-71f302b2#演示2-cglib-代理\",\"513\":\"v-71f302b2#收获💡-18\",\"514\":\"v-71f302b2#_12-jdk-动态代理进阶\",\"515\":\"v-71f302b2#演示1-模拟-jdk-动态代理\",\"516\":\"v-71f302b2#收获💡-19\",\"517\":\"v-71f302b2#演示2-方法反射优化\",\"518\":\"v-71f302b2#代码参考-15\",\"519\":\"v-71f302b2#收获💡-20\",\"520\":\"v-71f302b2#_13-cglib-代理进阶\",\"521\":\"v-71f302b2#演示-模拟-cglib-代理\",\"522\":\"v-71f302b2#代码参考-16\",\"523\":\"v-71f302b2#收获💡-21\",\"524\":\"v-71f302b2#_14-cglib-避免反射调用\",\"525\":\"v-71f302b2#演示-cglib-如何避免反射\",\"526\":\"v-71f302b2#代码参考-17\",\"527\":\"v-71f302b2#收获💡-22\",\"528\":\"v-71f302b2#_15-jdk-和-cglib-在-spring-中的统一\",\"529\":\"v-71f302b2#演示-底层切点、通知、切面\",\"530\":\"v-71f302b2#代码参考-18\",\"531\":\"v-71f302b2#收获💡-23\",\"532\":\"v-71f302b2#_16-切点匹配\",\"533\":\"v-71f302b2#演示-切点匹配\",\"534\":\"v-71f302b2#代码参考-19\",\"535\":\"v-71f302b2#收获💡-24\",\"536\":\"v-71f302b2#_17-从-aspect-到-advisor\",\"537\":\"v-71f302b2#演示1-代理创建器\",\"538\":\"v-71f302b2#代码参考-20\",\"539\":\"v-71f302b2#收获💡-25\",\"540\":\"v-71f302b2#演示2-代理创建时机\",\"541\":\"v-71f302b2#代码参考-21\",\"542\":\"v-71f302b2#收获💡-26\",\"543\":\"v-71f302b2#演示3-before-对应的低级通知\",\"544\":\"v-71f302b2#代码参考-22\",\"545\":\"v-71f302b2#收获💡-27\",\"546\":\"v-71f302b2#_18-静态通知调用\",\"547\":\"v-71f302b2#演示1-通知调用过程\",\"548\":\"v-71f302b2#代码参考-23\",\"549\":\"v-71f302b2#收获💡-28\",\"550\":\"v-71f302b2#演示2-模拟-methodinvocation\",\"551\":\"v-71f302b2#代码参考-24\",\"552\":\"v-71f302b2#收获💡-29\",\"553\":\"v-71f302b2#_19-动态通知调用\",\"554\":\"v-71f302b2#演示-带参数绑定的通知方法调用\",\"555\":\"v-71f302b2#代码参考-25\",\"556\":\"v-71f302b2#收获💡-30\",\"557\":\"v-71f302b2#web\",\"558\":\"v-71f302b2#_20-requestmappinghandlermapping-与-requestmappinghandleradapter\",\"559\":\"v-71f302b2#演示1-dispatcherservlet-初始化\",\"560\":\"v-71f302b2#代码参考-26\",\"561\":\"v-71f302b2#收获💡-31\",\"562\":\"v-71f302b2#演示2-自定义参数与返回值处理器\",\"563\":\"v-71f302b2#代码参考-27\",\"564\":\"v-71f302b2#收获💡-32\",\"565\":\"v-71f302b2#_21-参数解析器\",\"566\":\"v-71f302b2#演示-常见参数解析器\",\"567\":\"v-71f302b2#代码参考-28\",\"568\":\"v-71f302b2#收获💡-33\",\"569\":\"v-71f302b2#_22-参数名解析\",\"570\":\"v-71f302b2#演示-两种方法获取参数名\",\"571\":\"v-71f302b2#代码参考-29\",\"572\":\"v-71f302b2#收获💡-34\",\"573\":\"v-71f302b2#_23-对象绑定与类型转换\",\"574\":\"v-71f302b2#底层第一套转换接口与实现\",\"575\":\"v-71f302b2#底层第二套转换接口\",\"576\":\"v-71f302b2#高层接口与实现\",\"577\":\"v-71f302b2#演示1-类型转换与数据绑定\",\"578\":\"v-71f302b2#代码参考-30\",\"579\":\"v-71f302b2#收获💡-35\",\"580\":\"v-71f302b2#演示2-数据绑定工厂\",\"581\":\"v-71f302b2#代码参考-31\",\"582\":\"v-71f302b2#收获💡-36\",\"583\":\"v-71f302b2#演示3-获取泛型参数\",\"584\":\"v-71f302b2#代码参考-32\",\"585\":\"v-71f302b2#收获💡-37\",\"586\":\"v-71f302b2#_24-controlleradvice-之-initbinder\",\"587\":\"v-71f302b2#演示-准备-initbinder\",\"588\":\"v-71f302b2#收获💡-38\",\"589\":\"v-71f302b2#_25-控制器方法执行流程\",\"590\":\"v-71f302b2#图1\",\"591\":\"v-71f302b2#图2\",\"592\":\"v-71f302b2#图3\",\"593\":\"v-71f302b2#_26-controlleradvice-之-modelattribute\",\"594\":\"v-71f302b2#演示-准备-modelattribute\",\"595\":\"v-71f302b2#代码参考-33\",\"596\":\"v-71f302b2#收获💡-39\",\"597\":\"v-71f302b2#_27-返回值处理器\",\"598\":\"v-71f302b2#演示-常见返回值处理器\",\"599\":\"v-71f302b2#代码参考-34\",\"600\":\"v-71f302b2#收获💡-40\",\"601\":\"v-71f302b2#_28-messageconverter\",\"602\":\"v-71f302b2#演示-messageconverter-的作用\",\"603\":\"v-71f302b2#代码参考-35\",\"604\":\"v-71f302b2#收获💡-41\",\"605\":\"v-71f302b2#_29-controlleradvice-之-responsebodyadvice\",\"606\":\"v-71f302b2#演示-responsebodyadvice-增强\",\"607\":\"v-71f302b2#代码参考-36\",\"608\":\"v-71f302b2#收获💡-42\",\"609\":\"v-71f302b2#_30-异常解析器\",\"610\":\"v-71f302b2#演示-exceptionhandlerexceptionresolver\",\"611\":\"v-71f302b2#代码参考-37\",\"612\":\"v-71f302b2#收获💡-43\",\"613\":\"v-71f302b2#_31-controlleradvice-之-exceptionhandler\",\"614\":\"v-71f302b2#演示-准备-exceptionhandler\",\"615\":\"v-71f302b2#代码参考-38\",\"616\":\"v-71f302b2#收获💡-44\",\"617\":\"v-71f302b2#_32-tomcat-异常处理\",\"618\":\"v-71f302b2#演示1-错误页处理\",\"619\":\"v-71f302b2#关键代码-1\",\"620\":\"v-71f302b2#收获💡-45\",\"621\":\"v-71f302b2#演示2-basicerrorcontroller\",\"622\":\"v-71f302b2#关键代码-2\",\"623\":\"v-71f302b2#收获💡-46\",\"624\":\"v-71f302b2#_33-beannameurlhandlermapping-与-simplecontrollerhandleradapter\",\"625\":\"v-71f302b2#演示-本组映射器和适配器\",\"626\":\"v-71f302b2#关键代码-3\",\"627\":\"v-71f302b2#收获💡-47\",\"628\":\"v-71f302b2#_34-routerfunctionmapping-与-handlerfunctionadapter\",\"629\":\"v-71f302b2#演示-本组映射器和适配器-1\",\"630\":\"v-71f302b2#关键代码-4\",\"631\":\"v-71f302b2#收获💡-48\",\"632\":\"v-71f302b2#_35-simpleurlhandlermapping-与-httprequesthandleradapter\",\"633\":\"v-71f302b2#演示1-本组映射器和适配器\",\"634\":\"v-71f302b2#代码参考-39\",\"635\":\"v-71f302b2#关键代码-5\",\"636\":\"v-71f302b2#收获💡-49\",\"637\":\"v-71f302b2#演示2-静态资源解析优化\",\"638\":\"v-71f302b2#关键代码-6\",\"639\":\"v-71f302b2#收获💡-50\",\"640\":\"v-71f302b2#演示3-欢迎页\",\"641\":\"v-71f302b2#关键代码-7\",\"642\":\"v-71f302b2#收获💡-51\",\"643\":\"v-71f302b2#映射器与适配器小结\",\"644\":\"v-71f302b2#_36-mvc-处理流程\",\"645\":\"v-71f302b2#boot\",\"646\":\"v-71f302b2#_37-boot-骨架项目\",\"647\":\"v-71f302b2#_38-boot-war项目\",\"648\":\"v-71f302b2#测试\",\"649\":\"v-71f302b2#启示\",\"650\":\"v-71f302b2#_39-boot-启动过程\",\"651\":\"v-71f302b2#演示-启动过程\",\"652\":\"v-71f302b2#收获💡-52\",\"653\":\"v-71f302b2#_40-tomcat-内嵌容器\",\"654\":\"v-71f302b2#演示1-tomcat-内嵌容器\",\"655\":\"v-71f302b2#关键代码-8\",\"656\":\"v-71f302b2#演示2-集成-spring-容器\",\"657\":\"v-71f302b2#关键代码-9\",\"658\":\"v-71f302b2#_41-boot-自动配置\",\"659\":\"v-71f302b2#aopautoconfiguration\",\"660\":\"v-71f302b2#datasourceautoconfiguration\",\"661\":\"v-71f302b2#mybatisautoconfiguration\",\"662\":\"v-71f302b2#transactionautoconfiguration\",\"663\":\"v-71f302b2#servletwebserverfactoryautoconfiguration\",\"664\":\"v-71f302b2#dispatcherservletautoconfiguration\",\"665\":\"v-71f302b2#webmvcautoconfiguration\",\"666\":\"v-71f302b2#errormvcautoconfiguration\",\"667\":\"v-71f302b2#multipartautoconfiguration\",\"668\":\"v-71f302b2#httpencodingautoconfiguration\",\"669\":\"v-71f302b2#演示-自动配置类原理\",\"670\":\"v-71f302b2#关键代码-10\",\"671\":\"v-71f302b2#收获💡-53\",\"672\":\"v-71f302b2#_42-条件装配底层\",\"673\":\"v-71f302b2#收获💡-54\",\"674\":\"v-71f302b2#其它\",\"675\":\"v-71f302b2#_43-factorybean\",\"676\":\"v-71f302b2#演示-factorybean\",\"677\":\"v-71f302b2#代码参考-40\",\"678\":\"v-71f302b2#收获💡-55\",\"679\":\"v-71f302b2#_44-indexed-原理\",\"680\":\"v-71f302b2#演示-indexed\",\"681\":\"v-71f302b2#代码参考-41\",\"682\":\"v-71f302b2#收获💡-56\",\"683\":\"v-71f302b2#_45-代理进一步理解\",\"684\":\"v-71f302b2#演示-代理\",\"685\":\"v-71f302b2#代码参考-42\",\"686\":\"v-71f302b2#收获💡-57\",\"687\":\"v-71f302b2#_46-value-装配底层\",\"688\":\"v-71f302b2#按类型装配的步骤\",\"689\":\"v-71f302b2#演示-value-装配过程\",\"690\":\"v-71f302b2#代码参考-43\",\"691\":\"v-71f302b2#收获💡-58\",\"692\":\"v-71f302b2#_47-autowired-装配底层\",\"693\":\"v-71f302b2#演示-autowired-装配过程\",\"694\":\"v-71f302b2#代码参考-44\",\"695\":\"v-71f302b2#收获💡-59\",\"696\":\"v-71f302b2#_48-事件监听器\",\"697\":\"v-71f302b2#演示-事件监听器\",\"698\":\"v-71f302b2#代码参考-45\",\"699\":\"v-71f302b2#收获💡-60\",\"700\":\"v-71f302b2#_49-事件发布器\",\"701\":\"v-71f302b2#演示-事件发布器\",\"702\":\"v-71f302b2#代码参考-46\",\"703\":\"v-71f302b2#收获💡-61\",\"704\":\"v-04cdedd2\",\"705\":\"v-04cdedd2#列举一些重要的spring模块\",\"706\":\"v-04cdedd2#请你说说spring的核心是什么\",\"707\":\"v-04cdedd2#说一说对spring容器的了解\",\"708\":\"v-04cdedd2#说一说对beanfactory的了解\",\"709\":\"v-04cdedd2#spring是如何管理bean的\",\"710\":\"v-04cdedd2#bean的作用域\",\"711\":\"v-04cdedd2#bean的生命周期\",\"712\":\"v-04cdedd2#单例bean的线程安全问题了解吗\",\"713\":\"v-04cdedd2#component和-bean的区别是什么\",\"714\":\"v-04cdedd2#aspectj\",\"715\":\"v-04cdedd2#spring-aop和aspectj-aop的区别\",\"716\":\"v-04cdedd2#说说aop的应用场景\",\"717\":\"v-04cdedd2#spring-aop不能对哪些类进行增强\",\"718\":\"v-04cdedd2#既然没有接口都可以用cglib-为什么spring还要使用jdk动态代理\",\"719\":\"v-04cdedd2#spring是如何管理事务的\",\"720\":\"v-04cdedd2#spring中的事务传播行为\",\"721\":\"v-04cdedd2#spring的事务如何配置-常用注解有那些\",\"722\":\"v-04cdedd2#transactional-rollbackfor-exception-class-注解了解吗\",\"723\":\"v-04cdedd2#transactional失效场景\",\"724\":\"v-04cdedd2#spring是怎么解决循环依赖的\",\"725\":\"v-5a59b580\",\"726\":\"v-5a59b580#说说你对spring-boot的理解\",\"727\":\"v-5a59b580#spring-boot-starter有什么用\",\"728\":\"v-5a59b580#介绍spring-boot的启动流程\",\"729\":\"v-5a59b580#spring-boot项目是如何导入包的\",\"730\":\"v-5a59b580#spring-boot自动装配过程\",\"731\":\"v-5a59b580#说说你对spring-boot的注解的了解\",\"732\":\"v-5a59b580#spring-boot全局异常处理器\",\"733\":\"v-c5a54474\",\"734\":\"v-c5a54474#什么是mvc\",\"735\":\"v-c5a54474#dao层是做什么的\",\"736\":\"v-c5a54474#介绍一下spring-mvc的执行流程\",\"737\":\"v-c5a54474#说一说你知道的spring-mvc注解\",\"738\":\"v-c5a54474#介绍一下sprig-mvc的拦截器\",\"739\":\"v-252e238c\",\"740\":\"v-252e238c#_2022-6-2暑期实习一面\",\"741\":\"v-1c913b6f\",\"742\":\"v-1c913b6f#概念\",\"743\":\"v-1c913b6f#示例1\",\"744\":\"v-1c913b6f#示例2\",\"745\":\"v-1c913b6f#背压\",\"746\":\"v-69732fad\",\"747\":\"v-69732fad#todo\",\"748\":\"v-494a56f8\",\"749\":\"v-494a56f8#粘包现象\",\"750\":\"v-494a56f8#半包现象\",\"751\":\"v-494a56f8#现象分析\",\"752\":\"v-494a56f8#解决方案\",\"753\":\"v-494a56f8#方法1-短链接\",\"754\":\"v-494a56f8#方法2-固定长度\",\"755\":\"v-494a56f8#方法3-固定分隔符\",\"756\":\"v-494a56f8#方法4-预设长度\",\"757\":\"v-7621adb3\",\"758\":\"v-7621adb3#聊天室业务介绍\",\"759\":\"v-7621adb3#聊天室业务-登录\",\"760\":\"v-7621adb3#聊天室业务-单聊\",\"761\":\"v-7621adb3#聊天室业务-群聊\",\"762\":\"v-7621adb3#聊天室业务-退出\",\"763\":\"v-7621adb3#聊天室业务-空闲检测\",\"764\":\"v-7621adb3#连接假死\",\"765\":\"v-672afe6e\",\"766\":\"v-672afe6e#为什么需要协议\",\"767\":\"v-672afe6e#redis-协议举例\",\"768\":\"v-672afe6e#http-协议举例\",\"769\":\"v-672afe6e#自定义协议要素\",\"770\":\"v-672afe6e#编解码器\",\"771\":\"v-672afe6e#什么时候可以加-sharable💡\",\"772\":\"v-16d38cb0\",\"773\":\"v-16d38cb0#扩展序列化算法\",\"774\":\"v-16d38cb0#参数调优\",\"775\":\"v-16d38cb0#_1-connect-timeout-millis\",\"776\":\"v-16d38cb0#_2-so-backlog\",\"777\":\"v-16d38cb0#_3-ulimit-n\",\"778\":\"v-16d38cb0#_4-tcp-nodelay\",\"779\":\"v-16d38cb0#_5-so-sndbuf-so-rcvbuf\",\"780\":\"v-16d38cb0#_6-allocator\",\"781\":\"v-16d38cb0#_7-rcvbuf-allocator\",\"782\":\"v-16d38cb0#rpc-框架\",\"783\":\"v-16d38cb0#_1-准备工作\",\"784\":\"v-16d38cb0#_2-服务器-handler\",\"785\":\"v-16d38cb0#_3-客户端代码第一版\",\"786\":\"v-16d38cb0#_4-客户端-handler-第一版\",\"787\":\"v-16d38cb0#_5-客户端代码-第二版\",\"788\":\"v-16d38cb0#_6-客户端-handler-第二版\",\"789\":\"v-821a7378\",\"790\":\"v-821a7378#启动剖析\",\"791\":\"v-821a7378#nioeventloop-剖析\",\"792\":\"v-821a7378#注意⚠️\",\"793\":\"v-821a7378#accept-剖析\",\"794\":\"v-821a7378#read-剖析\",\"795\":\"v-54862980\",\"796\":\"v-54862980#eventloop\",\"797\":\"v-54862980#优雅关闭💡\",\"798\":\"v-54862980#演示-nioeventloop-处理-io-事件\",\"799\":\"v-54862980#handler-执行中如何换人-💡\",\"800\":\"v-54862980#演示-nioeventloop-处理普通任务\",\"801\":\"v-54862980#演示-nioeventloop-处理定时任务\",\"802\":\"v-54862980#channel\",\"803\":\"v-54862980#channelfuture\",\"804\":\"v-54862980#closefuture\",\"805\":\"v-54862980#异步提升的是什么💡\",\"806\":\"v-54862980#future-promise\",\"807\":\"v-54862980#jdk-future\",\"808\":\"v-54862980#netty-future\",\"809\":\"v-54862980#promise\",\"810\":\"v-54862980#例1\",\"811\":\"v-54862980#例2\",\"812\":\"v-54862980#例3\",\"813\":\"v-54862980#例4\",\"814\":\"v-54862980#例5\",\"815\":\"v-54862980#例6\",\"816\":\"v-54862980#handler-pipeline\",\"817\":\"v-54862980#bytebuf\",\"818\":\"v-54862980#_1-创建\",\"819\":\"v-54862980#_2-直接内存-vs-堆内存\",\"820\":\"v-54862980#_3-池化-vs-非池化\",\"821\":\"v-54862980#_4-组成\",\"822\":\"v-54862980#_5-写入\",\"823\":\"v-54862980#_6-扩容\",\"824\":\"v-54862980#_7-读取\",\"825\":\"v-54862980#_8-retain-release\",\"826\":\"v-54862980#_9-slice\",\"827\":\"v-54862980#_10-duplicate\",\"828\":\"v-54862980#_11-copy\",\"829\":\"v-54862980#_12-compositebytebuf\",\"830\":\"v-54862980#_13-unpooled\",\"831\":\"v-54862980#bytebuf-优势💡\",\"832\":\"v-75b94215\",\"833\":\"v-75b94215#目标\",\"834\":\"v-75b94215#服务器端\",\"835\":\"v-75b94215#客户端\",\"836\":\"v-75b94215#流程梳理\",\"837\":\"v-75b94215#提示💡\",\"838\":\"v-2f1bb992\",\"839\":\"v-2f1bb992#netty-是什么\",\"840\":\"v-2f1bb992#netty-的作者\",\"841\":\"v-2f1bb992#netty-的地位\",\"842\":\"v-2f1bb992#netty-的优势\",\"843\":\"v-079c0eac\",\"844\":\"v-079c0eac#练习\",\"845\":\"v-079c0eac#读和写的误解💡\",\"846\":\"v-151d81e0\",\"847\":\"v-151d81e0#bytebuffer-正确使用姿势\",\"848\":\"v-151d81e0#bytebuffer-结构\",\"849\":\"v-151d81e0#调试工具类💡\",\"850\":\"v-151d81e0#bytebuffer-常见方法\",\"851\":\"v-151d81e0#分配空间\",\"852\":\"v-151d81e0#向-buffer-写入数据\",\"853\":\"v-151d81e0#从-buffer-读取数据\",\"854\":\"v-151d81e0#mark-和-reset\",\"855\":\"v-151d81e0#字符串与-bytebuffer-互转\",\"856\":\"v-151d81e0#buffer-的线程安全⚠️\",\"857\":\"v-151d81e0#scattering-reads分散读\",\"858\":\"v-151d81e0#gathering-writes集中写\",\"859\":\"v-151d81e0#练习\",\"860\":\"v-26c53942\",\"861\":\"v-26c53942#filechannel\",\"862\":\"v-26c53942#filechannel-工作模式⚠️\",\"863\":\"v-26c53942#获取\",\"864\":\"v-26c53942#读取\",\"865\":\"v-26c53942#写入\",\"866\":\"v-26c53942#关闭\",\"867\":\"v-26c53942#位置\",\"868\":\"v-26c53942#大小\",\"869\":\"v-26c53942#强制写入\",\"870\":\"v-26c53942#两个-channel-传输数据\",\"871\":\"v-26c53942#path\",\"872\":\"v-26c53942#files\",\"873\":\"v-26c53942#删除很危险⚠️\",\"874\":\"v-04a5c7f2\",\"875\":\"v-04a5c7f2#非阻塞-vs-阻塞\",\"876\":\"v-04a5c7f2#阻塞\",\"877\":\"v-04a5c7f2#非阻塞\",\"878\":\"v-04a5c7f2#多路复用\",\"879\":\"v-04a5c7f2#selector\",\"880\":\"v-04a5c7f2#创建\",\"881\":\"v-04a5c7f2#绑定-channel-事件\",\"882\":\"v-04a5c7f2#监听-channel-事件\",\"883\":\"v-04a5c7f2#select-何时不阻塞💡\",\"884\":\"v-04a5c7f2#处理-accept-事件\",\"885\":\"v-04a5c7f2#事件发生后能否不处理💡\",\"886\":\"v-04a5c7f2#处理-read-事件\",\"887\":\"v-04a5c7f2#为何要-iter-remove-💡\",\"888\":\"v-04a5c7f2#cancel-的作用💡\",\"889\":\"v-04a5c7f2#不处理边界的问题⚠️\",\"890\":\"v-04a5c7f2#处理消息的边界\",\"891\":\"v-04a5c7f2#bytebuffer-大小分配\",\"892\":\"v-04a5c7f2#处理-write-事件\",\"893\":\"v-04a5c7f2#一次无法写完例子\",\"894\":\"v-04a5c7f2#write-为何要取消💡\",\"895\":\"v-04a5c7f2#更进一步\",\"896\":\"v-04a5c7f2#利用多线程优化💡\",\"897\":\"v-04a5c7f2#如何拿到-cpu-个数💡\",\"898\":\"v-04a5c7f2#udp\",\"899\":\"v-20d8b3e1\",\"900\":\"v-20d8b3e1#stream-vs-channel\",\"901\":\"v-20d8b3e1#io-模型\",\"902\":\"v-20d8b3e1#参考🔖\",\"903\":\"v-20d8b3e1#零拷贝\",\"904\":\"v-20d8b3e1#传统-io-问题\",\"905\":\"v-20d8b3e1#nio-优化\",\"906\":\"v-20d8b3e1#aio\",\"907\":\"v-20d8b3e1#文件-aio\",\"908\":\"v-20d8b3e1#守护线程💡\",\"909\":\"v-20d8b3e1#网络-aio\",\"910\":\"v-2ca4ecc4\",\"911\":\"v-2ca4ecc4#channel-buffer\",\"912\":\"v-2ca4ecc4#selector\",\"913\":\"v-2ca4ecc4#多线程版设计\",\"914\":\"v-2ca4ecc4#多线程版缺点⚠️\",\"915\":\"v-2ca4ecc4#线程池版设计\",\"916\":\"v-2ca4ecc4#线程池版缺点⚠️\",\"917\":\"v-2ca4ecc4#selector-版设计\",\"918\":\"v-810985aa\",\"919\":\"v-810985aa#todo\",\"920\":\"v-b1547596\",\"921\":\"v-b1547596#_1-基本概念\",\"922\":\"v-b1547596#_1-1-索引-index\",\"923\":\"v-b1547596#_1-2-类型-type\",\"924\":\"v-b1547596#_1-3-文档-document\",\"925\":\"v-b1547596#_1-4-字段-field\",\"926\":\"v-b1547596#_1-5-映射-mapping\",\"927\":\"v-b1547596#_1-6-分片-shards\",\"928\":\"v-b1547596#_1-7-副本-replicas\",\"929\":\"v-b1547596#_1-8-分配-allocation\",\"930\":\"v-b1547596#_2-入门操作\",\"931\":\"v-b1547596#_2-1-引入依赖\",\"932\":\"v-b1547596#_2-2-客户端对象\",\"933\":\"v-b1547596#_2-3-索引操作\",\"934\":\"v-b1547596#_2-4-文档操作\",\"935\":\"v-b1547596#_3-高级查询\",\"936\":\"v-b1547596#_3-1-查询索引中所有的数据\",\"937\":\"v-b1547596#_3-2-条件查询\",\"938\":\"v-b1547596#_3-3-分页查询\",\"939\":\"v-b1547596#_3-4-查询排序\",\"940\":\"v-b1547596#_3-5-查询字段过滤\",\"941\":\"v-b1547596#_3-6-组合查询\",\"942\":\"v-b1547596#_3-7-范围查询\",\"943\":\"v-b1547596#_3-8-模糊查询\",\"944\":\"v-b1547596#_3-9-高亮查询\",\"945\":\"v-b1547596#_3-10-聚合查询\",\"946\":\"v-b1547596#_3-11-分组查询\",\"947\":\"v-b1547596#_4-框架集成\",\"948\":\"v-b1547596#_4-1-引入依赖\",\"949\":\"v-b1547596#_4-2-配置类编写\",\"950\":\"v-b1547596#_4-3-实现\",\"951\":\"v-359fa3f2\",\"952\":\"v-359fa3f2#_1、短信登录\",\"953\":\"v-359fa3f2#_1-1、导入黑马点评项目\",\"954\":\"v-359fa3f2#_1-1-1-、导入sql\",\"955\":\"v-359fa3f2#_1-1-2、有关当前模型\",\"956\":\"v-359fa3f2#_1-1-3、导入后端项目\",\"957\":\"v-359fa3f2#_1-1-4、导入前端工程\",\"958\":\"v-359fa3f2#_1-1-5-运行前端项目\",\"959\":\"v-359fa3f2#_1-2-、基于session实现登录流程\",\"960\":\"v-359fa3f2#_1-3-、实现发送短信验证码功能\",\"961\":\"v-359fa3f2#_1-4、实现登录拦截功能\",\"962\":\"v-359fa3f2#_1-5、隐藏用户敏感信息\",\"963\":\"v-359fa3f2#_1-6、session共享问题\",\"964\":\"v-359fa3f2#_1-7、redis代替session的业务流程\",\"965\":\"v-359fa3f2#_1-7-1、设计key的结构\",\"966\":\"v-359fa3f2#_1-7-2、设计key的具体细节\",\"967\":\"v-359fa3f2#_1-7-3、整体访问流程\",\"968\":\"v-359fa3f2#_1-8、基于redis实现短信登录\",\"969\":\"v-359fa3f2#_1-9、解决状态登录刷新问题\",\"970\":\"v-359fa3f2#_1-9-1、初始方案思路总结\",\"971\":\"v-359fa3f2#_1-9-2、优化方案\",\"972\":\"v-359fa3f2#_1-9-3、代码\",\"973\":\"v-359fa3f2#_2、商户查询缓存\",\"974\":\"v-359fa3f2#_2-1、什么是缓存\",\"975\":\"v-359fa3f2#_2-1-1、为什么要使用缓存\",\"976\":\"v-359fa3f2#_2-1-2、如何使用缓存\",\"977\":\"v-359fa3f2#_2-2、添加商户缓存\",\"978\":\"v-359fa3f2#_2-2-1、缓存模型和思路\",\"979\":\"v-359fa3f2#_2-1-2、代码如下\",\"980\":\"v-359fa3f2#_2-3、缓存更新策略\",\"981\":\"v-359fa3f2#_2-3-1、数据库缓存不一致解决方案\",\"982\":\"v-359fa3f2#_2-3-2、数据库和缓存不一致采用什么方案\",\"983\":\"v-359fa3f2#_2-4、实现商铺和缓存与数据库双写一致\",\"984\":\"v-359fa3f2#_2-5、缓存穿透问题的解决思路\",\"985\":\"v-359fa3f2#_2-6、编码解决商品查询的缓存穿透问题\",\"986\":\"v-359fa3f2#_2-7、缓存雪崩问题及解决思路\",\"987\":\"v-359fa3f2#_2-8、缓存击穿问题及解决思路\",\"988\":\"v-359fa3f2#_2-9、利用互斥锁解决缓存击穿问题\",\"989\":\"v-359fa3f2#_2-10、利用逻辑过期解决缓存击穿问题\",\"990\":\"v-359fa3f2#_2-11、封装redis工具类\",\"991\":\"v-359fa3f2#_3、优惠卷秒杀\",\"992\":\"v-359fa3f2#_3-1、全局唯一id\",\"993\":\"v-359fa3f2#_3-2、redis实现全局唯一id\",\"994\":\"v-359fa3f2#_3-3、添加优惠卷\",\"995\":\"v-359fa3f2#_3-4、实现秒杀下单\",\"996\":\"v-359fa3f2#_3-5、库存超卖问题分析\",\"997\":\"v-359fa3f2#_3-6、乐观锁解决超卖问题\",\"998\":\"v-359fa3f2#_3-7、优惠券秒杀-一人一单\",\"999\":\"v-359fa3f2#_3-8、集群环境下的并发问题\",\"1000\":\"v-383eefd9\",\"1001\":\"v-383eefd9#_1、redis简单介绍\",\"1002\":\"v-383eefd9#_2、初始redis\",\"1003\":\"v-383eefd9#_2-1、认识nosql\",\"1004\":\"v-383eefd9#_2-1-1、结构化与非结构化\",\"1005\":\"v-383eefd9#_2-1-2、关联和非关联\",\"1006\":\"v-383eefd9#_2-1-3、查询方式\",\"1007\":\"v-383eefd9#_2-1-4、事务\",\"1008\":\"v-383eefd9#_2-1-5、总结\",\"1009\":\"v-383eefd9#_2-2、认识redis\",\"1010\":\"v-383eefd9#_2-3、安装redis\",\"1011\":\"v-383eefd9#_2-3-1、依赖库\",\"1012\":\"v-383eefd9#_2-3-2、上传安装包并解压\",\"1013\":\"v-383eefd9#_2-3-3、启动\",\"1014\":\"v-383eefd9#_2-3-4、默认启动\",\"1015\":\"v-383eefd9#_2-3-5、指定配置启动\",\"1016\":\"v-383eefd9#_2-3-6、开机自启\",\"1017\":\"v-383eefd9#_2-4、redis桌面客户端\",\"1018\":\"v-383eefd9#_2-4-1、redis命令行客户端\",\"1019\":\"v-383eefd9#_2-4-2、图形化桌面客户端\",\"1020\":\"v-383eefd9#_2-4-3、安装\",\"1021\":\"v-383eefd9#_2-4-4、建立连接\",\"1022\":\"v-383eefd9#_3、redis常见命令\",\"1023\":\"v-383eefd9#_3-1、redis数据结构介绍\",\"1024\":\"v-383eefd9#_3-2、redis-通用命令\",\"1025\":\"v-383eefd9#_3-3、redis命令-string命令\",\"1026\":\"v-383eefd9#_3-4、redis命令-key的层级结构\",\"1027\":\"v-383eefd9#_3-5、redis命令-hash命令\",\"1028\":\"v-383eefd9#_3-6、redis命令-list命令\",\"1029\":\"v-383eefd9#_3-7、redis命令-set命令\",\"1030\":\"v-383eefd9#_3-8、redis命令-sortedset类型\",\"1031\":\"v-383eefd9#_4、redis的java客户端-jedis\",\"1032\":\"v-383eefd9#_4-1、jedis快速入门\",\"1033\":\"v-383eefd9#_4-2、jedis连接池\",\"1034\":\"v-383eefd9#_4-2-1、创建jedis的连接池\",\"1035\":\"v-383eefd9#_4-2-2、改造原始代码\",\"1036\":\"v-383eefd9#_5、redis的java客户端-springdataredis\",\"1037\":\"v-383eefd9#_5-1、快速入门\",\"1038\":\"v-383eefd9#_5-1-1、导入pom坐标\",\"1039\":\"v-383eefd9#_5-1-2、配置文件\",\"1040\":\"v-383eefd9#_5-1-3、测试代码\",\"1041\":\"v-383eefd9#_5-2、数据序列化器\",\"1042\":\"v-383eefd9#_5-3、stringredistemplate\",\"1043\":\"v-383eefd9#_5-4、hash结构操作\",\"1044\":\"v-383eefd9@0\",\"1045\":\"v-383eefd9@1\",\"1046\":\"v-2d0aa4d7\",\"1047\":\"v-04b17156\",\"1048\":\"v-2d0a3132\",\"1049\":\"v-5de33e8c\",\"1050\":\"v-fffb8e28\",\"1051\":\"v-7e2e1571\",\"1052\":\"v-0314b485\",\"1053\":\"v-4fdba49a\",\"1054\":\"v-e9d02874\",\"1055\":\"v-66fcfb48\",\"1056\":\"v-1590f844\",\"1057\":\"v-22443161\",\"1058\":\"v-ab01ff6c\",\"1059\":\"v-0a634f38\",\"1060\":\"v-49e06168\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[1],\"2\":[1],\"3\":[1,49],\"4\":[1,8],\"5\":[1,10],\"6\":[1,23],\"7\":[1,10],\"8\":[1,6],\"9\":[1],\"10\":[1,42],\"11\":[1,45],\"12\":[1,12],\"13\":[1,23],\"14\":[1,30],\"15\":[1],\"16\":[1,23],\"17\":[1,27],\"18\":[1,16],\"19\":[1,22],\"20\":[1,1],\"21\":[1,2],\"22\":[4,3],\"23\":[1,5],\"24\":[1,22],\"25\":[1,11],\"26\":[1,35],\"27\":[1,2],\"28\":[1,2],\"29\":[1],\"30\":[1,17],\"31\":[1,33],\"32\":[1,20],\"33\":[2,88],\"34\":[1],\"35\":[1,1],\"36\":[1,1],\"37\":[1,52],\"38\":[1,2],\"39\":[1,24],\"40\":[1,18],\"41\":[1,73],\"42\":[1,57],\"43\":[1,5],\"44\":[1,45],\"45\":[6,21],\"46\":[1],\"47\":[1,23],\"48\":[1,25],\"49\":[1,90],\"50\":[1,28],\"51\":[1,13],\"52\":[1,66],\"53\":[1],\"54\":[1,17],\"55\":[1,12],\"56\":[1],\"57\":[1,29],\"58\":[1,63],\"59\":[1],\"60\":[1,35],\"61\":[1,3],\"62\":[1,10],\"63\":[1,45],\"64\":[1,14],\"65\":[1,27],\"66\":[1,4],\"67\":[1,4],\"68\":[1,20],\"69\":[1,53],\"70\":[1,10],\"71\":[1,22],\"72\":[1,6],\"73\":[1,23],\"74\":[1,48],\"75\":[1,7],\"76\":[1,15],\"77\":[1,76],\"78\":[3,48],\"79\":[5,3],\"80\":[1,15],\"81\":[1,24],\"82\":[1,86],\"83\":[1],\"84\":[1,3],\"85\":[1,13],\"86\":[1,47],\"87\":[1,53],\"88\":[1,4],\"89\":[3,94],\"90\":[1],\"91\":[1,9],\"92\":[1,17],\"93\":[1,48],\"94\":[1,162],\"95\":[1,90],\"96\":[1,37],\"97\":[1,8],\"98\":[1,26],\"99\":[1,16],\"100\":[1,5],\"101\":[1,136],\"102\":[1],\"103\":[1,86],\"104\":[1,100],\"105\":[2,82],\"106\":[1,7],\"107\":[1,37],\"108\":[1,70],\"109\":[1,98],\"110\":[1,44],\"111\":[1,77],\"112\":[1,52],\"113\":[1,3],\"114\":[1,13],\"115\":[1,14],\"116\":[1,126],\"117\":[1],\"118\":[1,24],\"119\":[1,33],\"120\":[1,68],\"121\":[1,19],\"122\":[1,8],\"123\":[1,64],\"124\":[1],\"125\":[2,11],\"126\":[2,44],\"127\":[2,65],\"128\":[2,41],\"129\":[2,42],\"130\":[2,23],\"131\":[2,72],\"132\":[2,50],\"133\":[2,44],\"134\":[2,64],\"135\":[3,131],\"136\":[2,44],\"137\":[3,42],\"138\":[2,45],\"139\":[2,213],\"140\":[3,60],\"141\":[2,48],\"142\":[2,44],\"143\":[2,41],\"144\":[4,28],\"145\":[2,18],\"146\":[1],\"147\":[2,78],\"148\":[3,61],\"149\":[3,22],\"150\":[3,37],\"151\":[2,121],\"152\":[2,25],\"153\":[3,61],\"154\":[3,113],\"155\":[2,39],\"156\":[2,53],\"157\":[2,16],\"158\":[2,34],\"159\":[2,47],\"160\":[2,54],\"161\":[2,70],\"162\":[2,45],\"163\":[2,135],\"164\":[2,67],\"165\":[1],\"166\":[2,20],\"167\":[2,56],\"168\":[2,52],\"169\":[2,96],\"170\":[2,42],\"171\":[2,15],\"172\":[2,17],\"173\":[2,35],\"174\":[2,3],\"175\":[2,15],\"176\":[2,67],\"177\":[2,19],\"178\":[2,32],\"179\":[3,11],\"180\":[3,28],\"181\":[3,89],\"182\":[3,39],\"183\":[3,31],\"184\":[2,44],\"185\":[2,58],\"186\":[2,31],\"187\":[1],\"188\":[1,1],\"189\":[1,5],\"190\":[1,7],\"191\":[1,48],\"192\":[1,33],\"193\":[1],\"194\":[1,86],\"195\":[1,60],\"196\":[1],\"197\":[1,14],\"198\":[1,9],\"199\":[null,null,1],\"200\":[null,null,1],\"201\":[1],\"202\":[3,14],\"203\":[3,20],\"204\":[2,10],\"205\":[1,10],\"206\":[1,59],\"207\":[1,7],\"208\":[1,54],\"209\":[1,15],\"210\":[1,13],\"211\":[1,59],\"212\":[1,18],\"213\":[1,11],\"214\":[1,11],\"215\":[3,11],\"216\":[3,8],\"217\":[1,14],\"218\":[1,11],\"219\":[3,51],\"220\":[3],\"221\":[1,57],\"222\":[1,16],\"223\":[1,4],\"224\":[1,50],\"225\":[1,60],\"226\":[1,15],\"227\":[1,15],\"228\":[1,18],\"229\":[1,8],\"230\":[1,39],\"231\":[1,24],\"232\":[1,98],\"233\":[1,13],\"234\":[1,40],\"235\":[1,23],\"236\":[1,53],\"237\":[1,40],\"238\":[1,5],\"239\":[1],\"240\":[1,14],\"241\":[1,34],\"242\":[1,37],\"243\":[1,16],\"244\":[1,90],\"245\":[6,6],\"246\":[1,36],\"247\":[1,25],\"248\":[1,15],\"249\":[1,241],\"250\":[1,3],\"251\":[1,9],\"252\":[1,27],\"253\":[1,14],\"254\":[1,16],\"255\":[1,69],\"256\":[1,2],\"257\":[1],\"258\":[1,33],\"259\":[1,5],\"260\":[1,57],\"261\":[1,54],\"262\":[1,26],\"263\":[1,58],\"264\":[1,2],\"265\":[1,147],\"266\":[1,157],\"267\":[1,111],\"268\":[1,88],\"269\":[1],\"270\":[1,8],\"271\":[1,1],\"272\":[1,54],\"273\":[1,39],\"274\":[1,14],\"275\":[1,36],\"276\":[2,118],\"277\":[2,248],\"278\":[1,30],\"279\":[1,83],\"280\":[1,81],\"281\":[1,34],\"282\":[3,68],\"283\":[1,60],\"284\":[1],\"285\":[1,32],\"286\":[1,4],\"287\":[2,42],\"288\":[2,2],\"289\":[1,5],\"290\":[3,64],\"291\":[1,44],\"292\":[1],\"293\":[1,20],\"294\":[1,2],\"295\":[1,4],\"296\":[1,70],\"297\":[1,11],\"298\":[1,5],\"299\":[2,5],\"300\":[1,36],\"301\":[1,3],\"302\":[1,10],\"303\":[1,4],\"304\":[1,14],\"305\":[1,58],\"306\":[1,13],\"307\":[1,9],\"308\":[3,13],\"309\":[2,23],\"310\":[2,12],\"311\":[5,17],\"312\":[1,8],\"313\":[1,32],\"314\":[1,29],\"315\":[1,57],\"316\":[1],\"317\":[1,21],\"318\":[1,17],\"319\":[1,9],\"320\":[1,12],\"321\":[1,16],\"322\":[1,13],\"323\":[1,19],\"324\":[1,21],\"325\":[1,13],\"326\":[2,14],\"327\":[1,28],\"328\":[1,37],\"329\":[3,4],\"330\":[3,3],\"331\":[1,28],\"332\":[1,120],\"333\":[1,22],\"334\":[1,30],\"335\":[1],\"336\":[1,79],\"337\":[1,27],\"338\":[1,32],\"339\":[1,52],\"340\":[1,15],\"341\":[1,39],\"342\":[1,42],\"343\":[1,45],\"344\":[1],\"345\":[1,22],\"346\":[1,14],\"347\":[2,6],\"348\":[1,5],\"349\":[1,14],\"350\":[4,41],\"351\":[1,17],\"352\":[1,68],\"353\":[1,21],\"354\":[1,16],\"355\":[1,56],\"356\":[1,19],\"357\":[3,11],\"358\":[1,12],\"359\":[1,36],\"360\":[1,62],\"361\":[1,16],\"362\":[4,18],\"363\":[2],\"364\":[1],\"365\":[3,15],\"366\":[2,137],\"367\":[1,1],\"368\":[1,60],\"369\":[2],\"370\":[2,30],\"371\":[1,25],\"372\":[2,79],\"373\":[1,1],\"374\":[1],\"375\":[1,29],\"376\":[2,9],\"377\":[5,18],\"378\":[1,24],\"379\":[1,2],\"380\":[1,5],\"381\":[2,22],\"382\":[1,9],\"383\":[1,134],\"384\":[1,15],\"385\":[1,42],\"386\":[1,24],\"387\":[5,38],\"388\":[2,11],\"389\":[1,12],\"390\":[1],\"391\":[1,19],\"392\":[1,18],\"393\":[1,58],\"394\":[1,15],\"395\":[1,22],\"396\":[1,153],\"397\":[1,27],\"398\":[1,18],\"399\":[1,2],\"400\":[1,46],\"401\":[1,22],\"402\":[1,2],\"403\":[1,26],\"404\":[1],\"405\":[1,6],\"406\":[3,60],\"407\":[1,16],\"408\":[3,19],\"409\":[3,151],\"410\":[2,203],\"411\":[1],\"412\":[1,5],\"413\":[1,161],\"414\":[1,6],\"415\":[2,11],\"416\":[1,5],\"417\":[1,27],\"418\":[3,38],\"419\":[1,54],\"420\":[1,44],\"421\":[1],\"422\":[1,61],\"423\":[1,12],\"424\":[1,13],\"425\":[1,8],\"426\":[2,17],\"427\":[1,10],\"428\":[2,4],\"429\":[1,50],\"430\":[1,17],\"431\":[1],\"432\":[1,3],\"433\":[1,51],\"434\":[1,32],\"435\":[1,19],\"436\":[1,34],\"437\":[1,22],\"438\":[1,2],\"439\":[1,40],\"440\":[2,49],\"441\":[1,153],\"442\":[1,21],\"443\":[1,20],\"444\":[1],\"445\":[2],\"446\":[2,26],\"447\":[5],\"448\":[1,4],\"449\":[1,74],\"450\":[2,58],\"451\":[2,48],\"452\":[2],\"453\":[1,4],\"454\":[1,43],\"455\":[4],\"456\":[1,4],\"457\":[1,7],\"458\":[3,37],\"459\":[3],\"460\":[1,32],\"461\":[1,8],\"462\":[2],\"463\":[1,44],\"464\":[3],\"465\":[1,4],\"466\":[1,9],\"467\":[3],\"468\":[2],\"469\":[1,4],\"470\":[1,29],\"471\":[4],\"472\":[1,4],\"473\":[1,21],\"474\":[3],\"475\":[3],\"476\":[1,13],\"477\":[1,13],\"478\":[3],\"479\":[1,4],\"480\":[1,16],\"481\":[3],\"482\":[1,4],\"483\":[1,3],\"484\":[4],\"485\":[1,4],\"486\":[1,13],\"487\":[3],\"488\":[5],\"489\":[1,4],\"490\":[1,26],\"491\":[3,50],\"492\":[2],\"493\":[2],\"494\":[1,4],\"495\":[1,28],\"496\":[2,51],\"497\":[5],\"498\":[1,22],\"499\":[1,18],\"500\":[5,72],\"501\":[2],\"502\":[1,16],\"503\":[1,19],\"504\":[1,38],\"505\":[5,5],\"506\":[1,27],\"507\":[5,5],\"508\":[1,5],\"509\":[4],\"510\":[3,39],\"511\":[1,4],\"512\":[3,40],\"513\":[1,9],\"514\":[3],\"515\":[4,72],\"516\":[1,24],\"517\":[2],\"518\":[1,4],\"519\":[1,24],\"520\":[3],\"521\":[4],\"522\":[1,4],\"523\":[1,79],\"524\":[3],\"525\":[3],\"526\":[1,5],\"527\":[1,55],\"528\":[7,39],\"529\":[4],\"530\":[1,4],\"531\":[1,27],\"532\":[2],\"533\":[2],\"534\":[1,4],\"535\":[1,7],\"536\":[5],\"537\":[2],\"538\":[1,6],\"539\":[1,29],\"540\":[2],\"541\":[1,7],\"542\":[1,9],\"543\":[3],\"544\":[1,7],\"545\":[1,20],\"546\":[2,34],\"547\":[2],\"548\":[1,5],\"549\":[1,30],\"550\":[3],\"551\":[1,6],\"552\":[1,8],\"553\":[2],\"554\":[2],\"555\":[1,6],\"556\":[1,15],\"557\":[1],\"558\":[4,10],\"559\":[3],\"560\":[1,4],\"561\":[1,45],\"562\":[2],\"563\":[1,5],\"564\":[1,2],\"565\":[2],\"566\":[2],\"567\":[1,4],\"568\":[1,40],\"569\":[2],\"570\":[2],\"571\":[1,4],\"572\":[1,22],\"573\":[2],\"574\":[1,22],\"575\":[1,10],\"576\":[1,42],\"577\":[2],\"578\":[1,4],\"579\":[1,5],\"580\":[2],\"581\":[1,4],\"582\":[1,23],\"583\":[2],\"584\":[1,5],\"585\":[1,4],\"586\":[4],\"587\":[3,11],\"588\":[1,15],\"589\":[2],\"590\":[1,18],\"591\":[1],\"592\":[1],\"593\":[4],\"594\":[3],\"595\":[1,9],\"596\":[1,15],\"597\":[2],\"598\":[2],\"599\":[1,4],\"600\":[1,31],\"601\":[2],\"602\":[3],\"603\":[1,4],\"604\":[1,19],\"605\":[4],\"606\":[3],\"607\":[1,9],\"608\":[1,2],\"609\":[2],\"610\":[2],\"611\":[1,4],\"612\":[1,4],\"613\":[4],\"614\":[3],\"615\":[1,4],\"616\":[1,11],\"617\":[3,88],\"618\":[2],\"619\":[1,21],\"620\":[1,2],\"621\":[2],\"622\":[1,55],\"623\":[1,5],\"624\":[4],\"625\":[2],\"626\":[1,20],\"627\":[1,14],\"628\":[4],\"629\":[2],\"630\":[1,21],\"631\":[1,10],\"632\":[4],\"633\":[2],\"634\":[1,7],\"635\":[1,30],\"636\":[1,9],\"637\":[2],\"638\":[1,23],\"639\":[1,2],\"640\":[2],\"641\":[1,20],\"642\":[1,18],\"643\":[1,41],\"644\":[3,118],\"645\":[1],\"646\":[3,25],\"647\":[3,53],\"648\":[1,45],\"649\":[1,13],\"650\":[3,70],\"651\":[2,24],\"652\":[1,39],\"653\":[3,42],\"654\":[3],\"655\":[1,70],\"656\":[4],\"657\":[1,35],\"658\":[3],\"659\":[1,31],\"660\":[1,43],\"661\":[1,57],\"662\":[1,31],\"663\":[1,2],\"664\":[1,3],\"665\":[1,10],\"666\":[1,4],\"667\":[1,13],\"668\":[1,25],\"669\":[2],\"670\":[1,51],\"671\":[1,18],\"672\":[2,71],\"673\":[1,3],\"674\":[1],\"675\":[2],\"676\":[2],\"677\":[1,4],\"678\":[1,31],\"679\":[3,15],\"680\":[2],\"681\":[1,4],\"682\":[1,27],\"683\":[2],\"684\":[2],\"685\":[1,4],\"686\":[1,16],\"687\":[3],\"688\":[1,59],\"689\":[3],\"690\":[1,4],\"691\":[1,10],\"692\":[3],\"693\":[3],\"694\":[1,4],\"695\":[1,65],\"696\":[2],\"697\":[2],\"698\":[1,4],\"699\":[1,14],\"700\":[2],\"701\":[2],\"702\":[1,4],\"703\":[1,22],\"704\":[1],\"705\":[1,80],\"706\":[2,36],\"707\":[1,38],\"708\":[1,20],\"709\":[1,34],\"710\":[1,31],\"711\":[1,84],\"712\":[1,17],\"713\":[3,15],\"714\":[1,14],\"715\":[4,6],\"716\":[1,12],\"717\":[2,6],\"718\":[2,11],\"719\":[1,11],\"720\":[1,47],\"721\":[3,27],\"722\":[7,8],\"723\":[2,7],\"724\":[1,1],\"725\":[1],\"726\":[2,24],\"727\":[3,19],\"728\":[2,23],\"729\":[2,8],\"730\":[2,24],\"731\":[2,210],\"732\":[2,47],\"733\":[1],\"734\":[1,16],\"735\":[1,7],\"736\":[2,54],\"737\":[2,48],\"738\":[2,47],\"739\":[1],\"740\":[3,13],\"741\":[1],\"742\":[1,46],\"743\":[1,91],\"744\":[1,123],\"745\":[1,32],\"746\":[1],\"747\":[1],\"748\":[1],\"749\":[1,168],\"750\":[1,121],\"751\":[1,145],\"752\":[1,16],\"753\":[2,96],\"754\":[2,171],\"755\":[2,182],\"756\":[2,199],\"757\":[1],\"758\":[1,78],\"759\":[2,166],\"760\":[2,61],\"761\":[2,82],\"762\":[2,33],\"763\":[2],\"764\":[1,88],\"765\":[1],\"766\":[2,82],\"767\":[2,78],\"768\":[2,86],\"769\":[1,23],\"770\":[1,109],\"771\":[2,103],\"772\":[1],\"773\":[1,238],\"774\":[1],\"775\":[4,103],\"776\":[3,160],\"777\":[3,1],\"778\":[3,9],\"779\":[4,14],\"780\":[2,8],\"781\":[3,15],\"782\":[2],\"783\":[2,175],\"784\":[3,53],\"785\":[2,76],\"786\":[4,21],\"787\":[3,142],\"788\":[4,47],\"789\":[1],\"790\":[1,324],\"791\":[2,194],\"792\":[1,189],\"793\":[2,235],\"794\":[2,102],\"795\":[1],\"796\":[1,76],\"797\":[1,9],\"798\":[5,193],\"799\":[3,44],\"800\":[3,35],\"801\":[3,35],\"802\":[1,19],\"803\":[1,93],\"804\":[1,81],\"805\":[1,63],\"806\":[2,73],\"807\":[2,35],\"808\":[2,39],\"809\":[1,44],\"810\":[1,43],\"811\":[1,48],\"812\":[1,83],\"813\":[1,55],\"814\":[1,49],\"815\":[1,78],\"816\":[2,173],\"817\":[1,1],\"818\":[2,46],\"819\":[4,21],\"820\":[4,36],\"821\":[2,7],\"822\":[2,100],\"823\":[2,64],\"824\":[2,59],\"825\":[3,172],\"826\":[2,113],\"827\":[2,13],\"828\":[2,5],\"829\":[2,94],\"830\":[2,72],\"831\":[2,18],\"832\":[2],\"833\":[1,22],\"834\":[1,71],\"835\":[1,84],\"836\":[1],\"837\":[1,51],\"838\":[1],\"839\":[3,23],\"840\":[2,3],\"841\":[2,37],\"842\":[2,53],\"843\":[1],\"844\":[1,81],\"845\":[1,84],\"846\":[1,77],\"847\":[2,19],\"848\":[2,24],\"849\":[1,147],\"850\":[2],\"851\":[1,23],\"852\":[3,17],\"853\":[3,30],\"854\":[3,16],\"855\":[3,50],\"856\":[2,2],\"857\":[2,57],\"858\":[2,65],\"859\":[1,70],\"860\":[1],\"861\":[1],\"862\":[2,2],\"863\":[1,18],\"864\":[1,13],\"865\":[1,18],\"866\":[1,11],\"867\":[1,19],\"868\":[1,3],\"869\":[1,9],\"870\":[3,64],\"871\":[1,41],\"872\":[1,99],\"873\":[1,45],\"874\":[1],\"875\":[3],\"876\":[1,95],\"877\":[1,91],\"878\":[1,24],\"879\":[1,11],\"880\":[1,5],\"881\":[3,30],\"882\":[3,24],\"883\":[2,29],\"884\":[3,80],\"885\":[1,9],\"886\":[3,131],\"887\":[4,27],\"888\":[2,10],\"889\":[1,66],\"890\":[1,191],\"891\":[2,44],\"892\":[3],\"893\":[1,131],\"894\":[2,9],\"895\":[1],\"896\":[1,134],\"897\":[3,21],\"898\":[1,82],\"899\":[3],\"900\":[3,16],\"901\":[2,30],\"902\":[1,4],\"903\":[1],\"904\":[3,78],\"905\":[2,89],\"906\":[1,25],\"907\":[2,84],\"908\":[1,8],\"909\":[2,93],\"910\":[1],\"911\":[2,32],\"912\":[1,3],\"913\":[1],\"914\":[1,3],\"915\":[1],\"916\":[1,5],\"917\":[2,22],\"918\":[2],\"919\":[1],\"920\":[2],\"921\":[2],\"922\":[4,19],\"923\":[5,21],\"924\":[5,17],\"925\":[5,3],\"926\":[5,12],\"927\":[5,30],\"928\":[5,50],\"929\":[5,6],\"930\":[2],\"931\":[3,51],\"932\":[2,34],\"933\":[3,43],\"934\":[3,73],\"935\":[2],\"936\":[3,34],\"937\":[3,34],\"938\":[2,39],\"939\":[3,39],\"940\":[3,40],\"941\":[3,43],\"942\":[3,41],\"943\":[3,42],\"944\":[3,49],\"945\":[3,40],\"946\":[3,40],\"947\":[2],\"948\":[3,31],\"949\":[3,34],\"950\":[3,127],\"951\":[2,1],\"952\":[2],\"953\":[2],\"954\":[2,1],\"955\":[3,38],\"956\":[3,2],\"957\":[3,1],\"958\":[3,1],\"959\":[3,34],\"960\":[3,76],\"961\":[3,122],\"962\":[3,44],\"963\":[3,28],\"964\":[3],\"965\":[3,14],\"966\":[4,18],\"967\":[4,16],\"968\":[3,106],\"969\":[3],\"970\":[4,9],\"971\":[4,9],\"972\":[4,89],\"973\":[2],\"974\":[4,65],\"975\":[3,18],\"976\":[3,23],\"977\":[2,17],\"978\":[3,7],\"979\":[3,7],\"980\":[3,21],\"981\":[5,30],\"982\":[3,45],\"983\":[3,90],\"984\":[3,52],\"985\":[4,85],\"986\":[3,9],\"987\":[3,101],\"988\":[3,124],\"989\":[3,149],\"990\":[3,220],\"991\":[2],\"992\":[3,45],\"993\":[3,127],\"994\":[2,68],\"995\":[3,92],\"996\":[3,115],\"997\":[3,60],\"998\":[4,186],\"999\":[3,33],\"1000\":[2,3],\"1001\":[2,21],\"1002\":[2],\"1003\":[3,11],\"1004\":[3,13],\"1005\":[3,29],\"1006\":[4,5],\"1007\":[4,5],\"1008\":[4,24],\"1009\":[2,30],\"1010\":[3,6],\"1011\":[4,8],\"1012\":[3,35],\"1013\":[3,5],\"1014\":[4,13],\"1015\":[4,80],\"1016\":[4,47],\"1017\":[3,8],\"1018\":[4,29],\"1019\":[3,13],\"1020\":[4,8],\"1021\":[3,18],\"1022\":[2],\"1023\":[3,19],\"1024\":[4,89],\"1025\":[3,124],\"1026\":[4,48],\"1027\":[4,72],\"1028\":[4,47],\"1029\":[4,79],\"1030\":[4,61],\"1031\":[3,26],\"1032\":[3,87],\"1033\":[3,10],\"1034\":[4,48],\"1035\":[3,33],\"1036\":[3,25],\"1037\":[3,3],\"1038\":[3,111],\"1039\":[4,26],\"1040\":[4,37],\"1041\":[3,49],\"1042\":[3,90],\"1043\":[3,32],\"1044\":[null,null,1],\"1045\":[null,null,1],\"1046\":[1],\"1047\":[1],\"1048\":[2],\"1049\":[1],\"1050\":[1],\"1051\":[1],\"1052\":[1],\"1053\":[1],\"1054\":[1],\"1055\":[1],\"1056\":[1],\"1057\":[1],\"1058\":[1],\"1059\":[1],\"1060\":[1]},\"averageFieldLength\":[1.774272868743892,38.509589133233945,0.01184326931309038],\"storedFields\":{\"0\":{\"h\":\"介绍页\",\"t\":[\"TODO\"]},\"1\":{\"h\":\"幻灯片页\"},\"2\":{\"h\":\"CycleGAN\"},\"3\":{\"h\":\"附录\",\"t\":[\"Unpaired Image-to-Image Translation using Cycle-Consistent Adversarial Networks\",\"ICCV 2017\",\"论文主页：https://junyanz.github.io/CycleGAN/\",\"原始论文：https://arxiv.org/pdf/1703.10593.pdf\",\"子豪兄精读论文视频：https://www.bilibili.com/video/BV1Ya411a78P\",\"代码实战，CycleGAN照片转梵高莫奈油画：https://www.bilibili.com/video/BV1wv4y1T71F\",\"CycleGAN是Image Translation（图像转译）领域的经典深度学习算法，巧妙实现了两个非配对图像域的相互迁移，通过构造两个GAN网络和两个Cycle-consistency自监督损失函数，在图像迁移之后仍保留原始输入图像信息，在防止模式崩溃的同时，间接实现了图像配对。\",\"CycleGAN在照片转莫奈油画、野马转斑马花纹、夏天转冬天景色、街景转语义分割标签等图像转译应用上表现出色。\",\"7991651743003_.pic_hd.jpg\"]},\"4\":{\"h\":\"趣味应用\",\"t\":[\"见论文主页\",\"人脸图像自动戴口罩：https://www.zhihu.com/zvideo/1284840958643646464\"]},\"5\":{\"h\":\"作者相关\",\"t\":[\"作者Jun-Yan Zhu主页：https://www.cs.cmu.edu/~junyanz/\"]},\"6\":{\"h\":\"博客\",\"t\":[\"李宏毅生成对抗网络公开课：https://www.bilibili.com/video/av24011528/\",\"理解生成对抗网络：https://danieltakeshi.github.io/2017/03/05/understanding-generative-adversarial-networks/\",\"GAN动物园：https://github.com/hindupuravinash/the-gan-zoo\"]},\"7\":{\"h\":\"代码复现\",\"t\":[\"官方Github：https://github.com/junyanz/CycleGAN\",\"OpenMMLab开源图像生成算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\"]},\"8\":{\"h\":\"GAN\",\"t\":[\"DG∗​(x)=pdata ​(x)+pg​(x)pdata ​(x)​\"]},\"9\":{\"h\":\"附录\"},\"10\":{\"h\":\"生成对抗网络GAN开山之作\",\"t\":[\"生成对抗神经网络GAN开山之作论文：Generative Adversarial Nets。\",\"论文作者为“生成对抗网络之父”Ian Goodfellow和图灵奖得主Youshua Bengio。\",\"GAN近年来成为人工智能和深度学习的热门研究领域。GAN广泛应用于图像生成、风格迁移、AI艺术、黑白老照片上色修复。你可以使用GAN实现照片转成油画、野马转成斑马、黑夜转成白天，简笔画的猫转成真猫，模糊图像转成高清图像等酷炫好玩的应用。\",\"子豪兄会带你逐句精读GAN开山之作经典论文，讲解GAN精巧的自监督对抗学习范式背后的算法和数学原理。\",\"OpenMMLab图像生成开源算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\",\"原始论文：https://proceedings.neurips.cc/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf\",\"论文主页：https://proceedings.neurips.cc/paper/2014/hash/5ca3e9b122f61f8f06494c97b1afccf3-Abstract.html\"]},\"11\":{\"h\":\"趣味demo\",\"t\":[\"交互式可视化GAN Lab：https://poloclub.github.io/ganlab\",\"交互式可视化GAN Lab视频讲解：https://www.bilibili.com/video/BV1R44y1377T\",\"照片转动漫AnimeGAN：https://github.com/TachibanaYoshino/AnimeGAN\",\"英伟达GauGAN2神笔马良：http://gaugan.org/gaugan2/\",\"不存在的人脸：https://thispersondoesnotexist.com/\",\"不存在的花瓶：https://thisvesseldoesnotexist.com\",\"不存在的梗图：https://imgflip.com/ai-meme\",\"黑白老照片上色：https://deepai.org/machine-learning-model/colorizer\",\"黑白老照片上色：https://github.com/jantic/DeOldify\",\"黑白老照片上色：https://www.myheritage.com/incolor\",\"OpenAI DALLE-2：https://openai.com/dall-e-2\"]},\"12\":{\"h\":\"作者相关\",\"t\":[\"Schmidhuber在2016年NIPS大会上打断Goodfellow的GAN Tutorial：https://zhuanlan.zhihu.com/p/27159510\",\"【AI大咖】扒一下低调的Yoshua Bengio大神\",\"https://zhuanlan.zhihu.com/p/66259338\"]},\"13\":{\"h\":\"博客\",\"t\":[\"李宏毅生成对抗网络公开课：https://www.bilibili.com/video/av24011528/\",\"理解生成对抗网络：https://danieltakeshi.github.io/2017/03/05/understanding-generative-adversarial-networks/\",\"GAN动物园：https://github.com/hindupuravinash/the-gan-zoo\"]},\"14\":{\"h\":\"代码复现\",\"t\":[\"官方论文复现：https://github.com/goodfeli/adversarial\",\"OpenMMLab开源图像生成算法库MMGeneration：https://github.com/open-mmlab/mmgeneration\",\"各种GAN的Keras实现：https://github.com/eriklindernoren/Keras-GAN\",\"GAN的推导及Keras手把手实现（老版本Keras）：http://srome.github.io/An-Annotated-Proof-of-Generative-Adversarial-Networks-with-Implementation-Notes/\"]},\"15\":{\"h\":\"CycleGAN\"},\"16\":{\"h\":\"附录\",\"t\":[\"图像转译和生成对抗网络GAN必读论文 pix2pix\",\"Image-to-Image Translation with Conditional Adversarial Nets\",\"CVPR 2017\",\"使用条件式生成对抗网络，提出图像转译的通用框架。生成器采用U-Net网络结构，融合底层细粒度特征和高层抽象语义特征。判别器采用patchGAN网络结构，在图块尺度提取纹理等高频信息。\",\"pix2pix在语义标签图转真实照片、简笔画转真图、黑白图像上色、卫星航拍图转地图等图像转译任务上表现优秀。\"]},\"17\":{\"h\":\"主页\",\"t\":[\"论文主页：https://phillipi.github.io/pix2pix/\",\"子豪兄论文精读视频：https://www.bilibili.com/video/BV1wY4y1k7Tc/\",\"论文：https://arxiv.org/abs/1611.07004\",\"代码：https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix\",\"交互式趣味Demo：https://affinelayer.com/pixsrv/\"]},\"18\":{\"h\":\"趣味案例\",\"t\":[\"床单充电线作画Gommy Sunday：https://vimeo.com/260612034\",\"调色板生成：http://colormind.io/blog/\",\"人脸简笔画转肖像画：https://twitter.com/quasimondo/status/826065030944870400\"]},\"19\":{\"h\":\"代码\",\"t\":[\"https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/generative/pix2pix.ipynb\",\"https://github.com/TommyZihao/MMGeneration_Tutorials/blob/main/【E】图像转译-pix2pix.ipynb\"]},\"20\":{\"h\":\"YOLOv3\",\"t\":[\"整理自同济子豪兄\"]},\"21\":{\"h\":\"网络结构\",\"t\":[\"image-20220518142711194\"]},\"22\":{\"h\":\"Backbone（Darknet-53）\",\"t\":[\"对于输入为256∗256的图像，其Backbone如下图所示：\"]},\"23\":{\"h\":\"Neck\",\"t\":[\"neck部分就是多尺度特征融合的过程。其中concat就是在上采样之后，将相同尺度的特征沿通道方向摞起来。就像将相同大小的作业本摞起来。\"]},\"24\":{\"h\":\"Head\",\"t\":[\"YOLOv3的head部分，受到了特征金字塔的启发，使用了多尺度特征。\",\"对于输入是416∗416的图像，产生13∗13,26∗26,52∗52三个尺度的特征。其中小尺度特征（比如13∗13）负责预测大物体，大尺度特征负责预测小物体。因为小尺度每个grid ceil对应更大的感受野。\",\"三个尺度的特征，每个特征的grid ceil都会生成3个anchor，一共9个anchor。其中在9个anchor中，与ground truth的IOU最大的anchor负责预测这个ground truth。\"]},\"25\":{\"h\":\"正负样本\",\"t\":[\"假设IOU阈值为0.5，其中与ground truth的IOU小于阈值的anchor为负样本。超过阈值，且与ground truth的IOU最大的anchor为正样本。查过阈值，但是与ground truth的IOU不是最大的anchor既不是正样本也不是负样本。\"]},\"26\":{\"h\":\"损失函数\",\"t\":[\"$$ \\\\begin{equation} \\\\lambda_{coord}\\\\sum_{i=0}^{S^2}\\\\sum_{j=0}^{B}\\\\mathbb{1}_{i,j}^{obj}\\\\cdot[(b_x-\\\\hat{b_x})^2 + (b_y-\\\\hat{b_y})^2 + (b_w-\\\\hat{b_w})^2 +(b_h-\\\\hat{b_h})^2] \\\\\\\\ \\\\\\\\ \\\\\\\\ + \\\\quad \\\\sum_{i=0}^{S^2}\\\\sum_{j=0}^{B}\\\\mathbb{1}_{i,j}^{obj}\\\\cdot[-log(p_c)+\\\\sum_{i=1}^{n}{BCE(\\\\hat{c_i},c_i)}] \\\\\\\\ \\\\\\\\ \\\\\\\\ + \\\\quad \\\\lambda_{noobj}\\\\sum_{i=0}^{S^2}\\\\sum_{j=0}^{B}\\\\mathbb{1}_{i,j}^{noobj}\\\\cdot[-log(1-p_c)] \\\\end{equation} $$ \"]},\"27\":{\"h\":\"训练过程\",\"t\":[\"image-20220518144159747\"]},\"28\":{\"h\":\"测试过程\",\"t\":[\"image-20220518144241994\"]},\"29\":{\"h\":\"附录\"},\"30\":{\"h\":\"官方\",\"t\":[\"YOLOV3目标检测Demo视频：https://www.youtube.com/watch?v=MPU2HistivI\",\"https://pjreddie.com/darknet/yolo/\",\"https://github.com/pjreddie/darknet\",\"论文地址：https://arxiv.org/abs/1804.02767\"]},\"31\":{\"h\":\"博客\",\"t\":[\"江大白：https://zhuanlan.zhihu.com/p/143747206\",\"郭冠华：https://zhuanlan.zhihu.com/p/40332004\",\"Netron可视化YOLOV3网络结构：https://blog.csdn.net/nan355655600/article/details/106246355\",\"木盏：https://blog.csdn.net/leviopku/article/details/82660381\",\"太阳花的小绿豆：https://blog.csdn.net/qq_37541097/article/details/81214953\",\"B站工程师Algernon鉴黄YOLO：https://github.com/thisiszhou/SexyYolo\",\"B站工程师Algernon博客：https://zhuanlan.zhihu.com/p/76802514\",\"损失函数：https://blog.csdn.net/qq_34795071/article/details/92803741\"]},\"32\":{\"h\":\"代码复现\",\"t\":[\"Ultralytics公司：https://github.com/ultralytics/yolov3\",\"https://github.com/qqwweee/keras-yolo3\",\"https://github.com/bubbliiiing/yolo3-pytorch\",\"cvpods：https://github.com/Megvii-BaseDetection/cvpods/blob/master/cvpods/modeling/meta_arch/yolov3.py\"]},\"33\":{\"h\":\"MS COCO目标检测数据集80个类别\",\"t\":[\"交通：人、自行车、汽车、摩托车、飞机、公交车、火车、卡车、船\",\"市政：红绿灯、消防栓、STOP标志、停车收费米表、长椅\",\"动物：鸟、猫、狗、马、绵羊、奶牛、大象、熊、斑马、长颈鹿\",\"随身物品：双肩背包、雨伞、手提包、领带、行李箱\",\"运动：飞盘、雪橇、滑雪板、篮球、风筝、棒球棒、棒球手套、滑板、冲浪板、网球拍\",\"器皿餐具：瓶子、玻璃酒杯、茶杯、叉子、餐刀、勺子、碗\",\"食物：香蕉、苹果、三明治、橘子、西兰花、胡萝卜、热狗、匹萨、甜甜圈、蛋糕\",\"家具：椅子、沙发、盆栽、床、餐桌、厕所、电视、笔记本电脑、鼠标、遥控器、键盘、手机、微波炉、烤箱、烤吐司炉、洗碗槽、冰箱、书、钟表、花瓶、剪刀、泰迪熊、电吹风、牙刷\"]},\"34\":{\"h\":\"读前须知\"},\"35\":{\"h\":\"1\",\"t\":[\"x→∞lim​x222​−∫15​xdx+n=1∑20​n2=j=1∏3​yj​+x→−2lim​xx−2​\"]},\"36\":{\"h\":\"2\",\"t\":[\"🤪😒🎈🔥😊😂💕😘👌😍❤️🤣👍✌️🤞🙌🤦‍♀️😉😎🤦‍♂️🤷‍♀️🎶🎆🎈🧨✨🎉🎎🎁🎀🎍🎋🧧🍟🌭🧇🍳🥗🍞🥨🥖🫓❤️🧡💛💚💙💜❤️‍🩹❤️‍🔥💔🤍🖤🤎🚗🚓🚘🚜🚎🚑🚑🚔\"]},\"37\":{\"h\":\"3\",\"t\":[\"《一往情深的恋人》\",\"如果不能陪你到最后\",\"是否后悔当初我们牵手\",\"如果当初没能遇见你\",\"现在的我在哪里逗留\",\"所有的爱都是冒险\",\"那就心甘情愿\",\"等待我们一生中\",\"所有悬念\",\"我一往情深的恋人\",\"她是我的爱人\",\"她给我的爱\",\"就像是带着露水的清晨\",\"我多想给她我的真\",\"我单纯的爱人\",\"我愿为她 等侯寂寞\",\"不管这夜晚 多深\",\"如果我能 陪你到最后\",\"是否原谅我 曾经放开的手\",\"如果当初 没能遇见你\",\"现在的我不会为谁停留\",\"所有的爱都是冒险\",\"那就心甘情愿\",\"等待我们一生中\",\"所有悬念\",\"我一往情深的恋人\",\"她是我的爱人\",\"我在和她相遇以前\",\"漫无目的地 浮沉\",\"我多想给她 我的真\",\"我心疼的 爱人\",\"我愿为她 守候寂寞\",\"就像 这夜晚 深沉\",\"我一往情深的恋人\",\"有美丽的 灵魂\",\"她向我 开放了所有\",\"付出 生命的热忱\",\"我一往情深的 恋人\",\"她是我的爱人\",\"她说与我相爱以后\",\"是她最美的年华\",\"我多想给她 我的真\",\"我心疼的爱人\",\"我愿和她 聆听寂静\",\"就在这夜晚 深沉\"]},\"38\":{\"h\":\"适配器模式\",\"t\":[\"程序媛教你一看就懂的适配器设计模式！\"]},\"39\":{\"h\":\"概述\",\"t\":[\"如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\",\"定义：\",\"​ 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\",\"​ 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\"]},\"40\":{\"h\":\"结构\",\"t\":[\"适配器模式（Adapter）包含以下主要角色：\",\"目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\",\"适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\",\"适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\"]},\"41\":{\"h\":\"类适配器模式\",\"t\":[\"实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。\",\"【例】读卡器\",\"现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。\",\"类图如下：\",\"代码如下：\",\"//SD卡的接口 public interface SDCard { //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg); } //SD卡实现类 public class SDCardImpl implements SDCard { public String readSD() { String msg = \\\"sd card read a msg :hello word SD\\\"; return msg; } public void writeSD(String msg) { System.out.println(\\\"sd card write msg : \\\" + msg); } } //电脑类 public class Computer { public String readSD(SDCard sdCard) { if(sdCard == null) { throw new NullPointerException(\\\"sd card null\\\"); } return sdCard.readSD(); } } //TF卡接口 public interface TFCard { //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg); } //TF卡实现类 public class TFCardImpl implements TFCard { public String readTF() { String msg =\\\"tf card read msg : hello word tf card\\\"; return msg; } public void writeTF(String msg) { System.out.println(\\\"tf card write a msg : \\\" + msg); } } //定义适配器类（SD兼容TF） public class SDAdapterTF extends TFCardImpl implements SDCard { public String readSD() { System.out.println(\\\"adapter read tf card \\\"); return readTF(); } public void writeSD(String msg) { System.out.println(\\\"adapter write tf card\\\"); writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\\\"------------\\\"); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); } } \",\"类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。\"]},\"42\":{\"h\":\"对象适配器模式\",\"t\":[\"实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。\",\"【例】读卡器\",\"我们使用对象适配器模式将读卡器的案例进行改写。类图如下：\",\"代码如下：\",\"类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。\",\"//创建适配器对象（SD兼容TF） public class SDAdapterTF implements SDCard { private TFCard tfCard; public SDAdapterTF(TFCard tfCard) { this.tfCard = tfCard; } public String readSD() { System.out.println(\\\"adapter read tf card \\\"); return tfCard.readTF(); } public void writeSD(String msg) { System.out.println(\\\"adapter write tf card\\\"); tfCard.writeTF(msg); } } //测试类 public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(\\\"------------\\\"); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); } } \",\"注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。\"]},\"43\":{\"h\":\"应用场景\",\"t\":[\"以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。\",\"使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。\"]},\"44\":{\"h\":\"JDK源码解析\",\"t\":[\"Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。\",\"InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：\",\"public int read() throws IOException { return sd.read(); } public int read(char cbuf[], int offset, int length) throws IOException { return sd.read(cbuf, offset, length); } \",\"如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：\",\"从上图可以看出：\",\"InputStreamReader是对同样实现了Reader的StreamDecoder的封装。\",\"StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。\",\"​ 从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。\"]},\"45\":{\"h\":\"代理 V.S 桥接 V.S 装饰器 V.S 适配器\",\"t\":[\"都可称为Wrapper模式，即通过Wrapper类二次封装原始类。代码结构相似，但要解决的问题、应用场景不同。\",\"代理模式不改变原始类接口的条件下，为原始类定义一个代理类，主要为控制访问，而非加强功能，这是和装饰器模式的最大不同\",\"桥接模式将接口部分和实现部分分离，让它们更容易、也相对独立地改变\",\"装饰器模式不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用\",\"适配器模式适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\"]},\"46\":{\"h\":\"建造者模式\"},\"47\":{\"h\":\"概述\",\"t\":[\"将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\",\"分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。\",\"由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。\",\"建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。\"]},\"48\":{\"h\":\"结构\",\"t\":[\"建造者（Builder）模式包含如下角色：\",\"抽象建造者类（Builder）：这个接口（可以是接口或者抽象类）规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建。\",\"具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。\",\"产品类（Product）：要创建的复杂对象。\",\"指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。\",\"类图如下：\"]},\"49\":{\"h\":\"实例\",\"t\":[\"创建共享单车\",\"生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\",\"这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\",\"具体的代码如下：\",\"//自行车类 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.seat = seat; } } // 抽象 builder 类 （定义各种抽象组件） public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); } //摩拜单车Builder类 public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\\\"铝合金车架\\\"); } @Override public void buildSeat() { mBike.setSeat(\\\"真皮车座\\\"); } @Override public Bike createBike() { return mBike; } } //ofo单车Builder类 public class OfoBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(\\\"碳纤维车架\\\"); } @Override public void buildSeat() { mBike.setSeat(\\\"橡胶车座\\\"); } @Override public Bike createBike() { return mBike; } } //指挥者类 （对组件进行一定顺序的组装） public class Director { private Builder mBuilder; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); } } //测试类 public class Client { public static void main(String[] args) { showBike(new OfoBuilder()); showBike(new MobikeBuilder()); } private static void showBike(Builder builder) { Director director = new Director(builder); Bike bike = director.construct(); System.out.println(bike.getFrame()); System.out.println(bike.getSeat()); } } \",\"注意：\",\"上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\",\"// 抽象 builder 类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() { this.buildFrame(); this.BuildSeat(); return this.createBike(); } } \",\"说明：\",\"这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\"]},\"50\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。\",\"在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\",\"可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\",\"建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。\",\"缺点：\",\"造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\"]},\"51\":{\"h\":\"使用场景\",\"t\":[\"建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\",\"创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。\",\"创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。\"]},\"52\":{\"h\":\"模式扩展\",\"t\":[\"建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\",\"重构前代码如下：\",\"public class Phone { private String cpu; private String screen; private String memory; private String mainboard; public Phone(String cpu, String screen, String memory, String mainboard) { this.cpu = cpu; this.screen = screen; this.memory = memory; this.mainboard = mainboard; } public String getCpu() { return cpu; } public void setCpu(String cpu) { this.cpu = cpu; } public String getScreen() { return screen; } public void setScreen(String screen) { this.screen = screen; } public String getMemory() { return memory; } public void setMemory(String memory) { this.memory = memory; } public String getMainboard() { return mainboard; } public void setMainboard(String mainboard) { this.mainboard = mainboard; } @Override public String toString() { return \\\"Phone{\\\" + \\\"cpu='\\\" + cpu + '\\\\'' + \\\", screen='\\\" + screen + '\\\\'' + \\\", memory='\\\" + memory + '\\\\'' + \\\", mainboard='\\\" + mainboard + '\\\\'' + '}'; } } public class Client { public static void main(String[] args) { //构建Phone对象 Phone phone = new Phone(\\\"intel\\\",\\\"三星屏幕\\\",\\\"金士顿\\\",\\\"华硕\\\"); System.out.println(phone); } } \",\"上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\",\"重构后代码：\",\"public class Phone { private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public Phone build() { return new Phone(this); } } @Override public String toString() { return \\\"Phone{\\\" + \\\"cpu='\\\" + cpu + '\\\\'' + \\\", screen='\\\" + screen + '\\\\'' + \\\", memory='\\\" + memory + '\\\\'' + \\\", mainboard='\\\" + mainboard + '\\\\'' + '}'; } } public class Client { public static void main(String[] args) { Phone phone = new Phone.Builder() .cpu(\\\"intel\\\") .mainboard(\\\"华硕\\\") .memory(\\\"金士顿\\\") .screen(\\\"三星\\\") .build(); System.out.println(phone); } } \",\"重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\"]},\"53\":{\"h\":\"创建者模式对比\"},\"54\":{\"h\":\"工厂方法模式VS建造者模式\",\"t\":[\"工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\",\"我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\"]},\"55\":{\"h\":\"抽象工厂模式VS建造者模式\",\"t\":[\"抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\",\"建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\",\"如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\"]},\"56\":{\"h\":\"设计模式\"},\"57\":{\"h\":\"单例模式\",\"t\":[\"单例模式的应用场景 | HefeiJoe Blog\",\"懒汉式线程不安全\",\"public class Singleton1 { private static Singleton1 instance; private Singleton1() { } public static Singleton1 getInstance() { if (instance == null) { instance = new Singleton1(); } return instance; } } \",\"懒汉式线程安全\",\"public class Singleton2 { public static Singleton2 instance; public Singleton2() { } public static synchronized Singleton2 getInstance() { if (instance == null) { instance = new Singleton2(); } return instance; } } \",\"饿汉式\",\"public class Singleton3 { private static Singleton3 instance = new Singleton3(); private Singleton3() { } public static Singleton3 getInstance() { return instance; } } \",\"懒汉式双重锁校验\",\"public class Singleton4 { private volatile static Singleton4 instance; private Singleton4() {} public static Singleton4 getInstance() { // instanceb if (instance == null) { // 首次创建会同步 synchronized (Singleton4.class) { if (instance == null) { instance = new Singleton4(); } } } return instance; } } \",\"双重校验锁\"]},\"58\":{\"h\":\"工厂模式\",\"t\":[\"意图： 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\",\"主要解决： 主要解决接口选择的问题。\",\"何时使用： 我们明确地计划不同条件下创建不同实例时。\",\"如何解决： 让其子类实现工厂接口，返回的也是一个抽象的产品。\",\"优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\",\"缺点： 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\",\"Shape.java\",\"public interface Shape { void draw(); } \",\"Rectangle.java\",\"public class Rectangle implements Shape { @Override public void draw() { System.out.println(\\\"Inside Rectangle::draw() method.\\\"); } } \",\"Square.java\",\"public class Square implements Shape { @Override public void draw() { System.out.println(\\\"Inside Square::draw() method.\\\"); } } \",\"Circle.java\",\"public class Circle implements Shape { @Override public void draw() { System.out.println(\\\"Inside Circle::draw() method.\\\"); } } \",\"ShapeFactory.java\",\"public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\\\"CIRCLE\\\")){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\\\"RECTANGLE\\\")){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\\\"SQUARE\\\")){ return new Square(); } return null; } } \"]},\"59\":{\"h\":\"工厂模式\"},\"60\":{\"h\":\"概述\",\"t\":[\"需求：设计一个咖啡店点餐系统。\",\"设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\",\"具体类的设计如下：\",\"在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。\",\"在本教程中会介绍三种工厂的使用\",\"简单工厂模式（不属于GoF的23种经典设计模式）\",\"工厂方法模式\",\"抽象工厂模式\"]},\"61\":{\"h\":\"简单工厂模式\",\"t\":[\"简单工厂不是一种设计模式，反而比较像是一种编程习惯。\"]},\"62\":{\"h\":\"结构\",\"t\":[\"简单工厂包含如下角色：\",\"抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\",\"具体产品 ：实现或者继承抽象产品的子类\",\"具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\"]},\"63\":{\"h\":\"实现\",\"t\":[\"现在使用简单工厂对上面案例进行改进，类图如下：\",\"工厂类代码如下：\",\"public class SimpleCoffeeFactory { public Coffee createCoffee(String type) { Coffee coffee = null; if(\\\"americano\\\".equals(type)) { coffee = new AmericanoCoffee(); } else if(\\\"latte\\\".equals(type)) { coffee = new LatteCoffee(); } else { throw new RuntimeException(\\\"对不起，您所点的咖啡没有\\\"); } return coffee; } } \",\"工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。\",\"后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。\"]},\"64\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\",\"缺点：\",\"增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\"]},\"65\":{\"h\":\"扩展\",\"t\":[\"静态工厂\",\"在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\",\"public class SimpleCoffeeFactory { public static Coffee createCoffee(String type) { Coffee coffee = null; if(\\\"americano\\\".equals(type)) { coffee = new AmericanoCoffee(); } else if(\\\"latte\\\".equals(type)) { coffee = new LatteCoffee(); } return coffe; } } \"]},\"66\":{\"h\":\"工厂方法模式\",\"t\":[\"针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。\"]},\"67\":{\"h\":\"概念\",\"t\":[\"定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\"]},\"68\":{\"h\":\"结构\",\"t\":[\"工厂方法模式的主要角色：\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\",\"具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\"]},\"69\":{\"h\":\"实现\",\"t\":[\"使用工厂方法模式对上例进行改进，类图如下：\",\"代码如下：\",\"咖啡抽象类：\",\"public abstract class Coffee { public abstract String getName(); public void addMilk() { System.out.println(\\\"add milk\\\"); } public void addSugar() { System.out.println(\\\"add sugar\\\"); } } \",\"咖啡具体类：\",\"public class LatteCoffee extends Coffee { @Override public String getName() { return \\\"latte coffee\\\"; } } \",\"抽象工厂：\",\"public interface CoffeeFactory { Coffee createCoffee(); } \",\"具体工厂：\",\"public class LatteCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new LatteCoffee(); } } public class AmericanCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new AmericanCoffee(); } } \",\"咖啡店类：\",\"public class CoffeeStore { private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) { this.factory = factory; } public Coffee orderCoffee() { Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; } } \",\"从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\",\"工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\"]},\"70\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；\",\"在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；\",\"缺点：\",\"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。\"]},\"71\":{\"h\":\"抽象工厂模式\",\"t\":[\"前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\",\"这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\",\"本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\"]},\"72\":{\"h\":\"概念\",\"t\":[\"是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\",\"抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\"]},\"73\":{\"h\":\"结构\",\"t\":[\"抽象工厂模式的主要角色如下：\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\",\"具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\"]},\"74\":{\"h\":\"实现\",\"t\":[\"现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\",\"代码如下：\",\"抽象工厂：\",\"public interface DessertFactory { Coffee createCoffee(); Dessert createDessert(); } \",\"具体工厂：\",\"//美式甜点工厂 public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); } } //意大利风味甜点工厂 public class ItalyDessertFactory implements DessertFactory { public Coffee createCoffee() { return new LatteCoffee(); } public Dessert createDessert() { return new Tiramisu(); } } \",\"如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\"]},\"75\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\",\"缺点：\",\"当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\"]},\"76\":{\"h\":\"使用场景\",\"t\":[\"当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\",\"系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\",\"系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\",\"如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。\"]},\"77\":{\"h\":\"模式扩展\",\"t\":[\"简单工厂+配置文件解除耦合\",\"可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\",\"第一步：定义配置文件\",\"为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\",\"american=com.itheima.pattern.factory.config_factory.AmericanCoffee latte=com.itheima.pattern.factory.config_factory.LatteCoffee \",\"第二步：改进工厂类\",\"public class CoffeeFactory { private static Map<String,Coffee> map = new HashMap(); static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\\\"bean.properties\\\"); try { p.load(is); // 遍历Properties集合对象 Set<Object> keys = p.keySet(); for (Object key : keys) { // 根据键获取值（全类名） String className = p.getProperty((String) key); // 获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); } } catch (Exception e) { e.printStackTrace(); } } public static Coffee createCoffee(String name) { return map.get(name); } } \",\"静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\"]},\"78\":{\"h\":\"JDK源码解析-Collection.iterator方法\",\"t\":[\"public class Demo { public static void main(String[] args) { List<String> list = new ArrayList<>(); list.add(\\\"令狐冲\\\"); list.add(\\\"风清扬\\\"); list.add(\\\"任我行\\\"); //获取迭代器对象 Iterator<String> it = list.iterator(); //使用迭代器遍历 while(it.hasNext()) { String ele = it.next(); System.out.println(ele); } } } \",\"对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：\",\"Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。\",\"另：\",\"​ 1,DateForamt类中的getInstance()方法使用的是工厂模式；\",\"​\\t2,Calendar类中的getInstance()方法使用的是工厂模式；\"]},\"79\":{\"h\":\"观察者模式 / 发布-订阅模式 / 生产-消费模式\",\"t\":[\"可见《图解设计模式》Observer模式篇\"]},\"80\":{\"h\":\"概述\",\"t\":[\"在Observer模式中，当观察对象的状态发生变化时，会通知给观察者。Observer模式适用于根据对象状态进行相应处理的场景。Observer本来的意思是“观察者”，但实际上Observer角色并非主动地去观察，而是被动地接受来自Subject角色的通知。因此，Observer模式也被称为Publish-Subscribe（发布-订阅） 模式。\"]},\"81\":{\"h\":\"结构\",\"t\":[\"Subject（观察对象）\",\"Subject角色表示观察对象。Subject角色定义了注册观察者和删除观察者的方法。此外，它还声明了“获取现在状态”的方法。\",\"ConcreteSubject（具体的观察对象）\",\"ConcreteSubject角色表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的Observer角色。\",\"Observer（观察者）\",\"Observer角色负责接收来自Subject角色的状态变化的通知。为此，它声明了update方法。\",\"ConcreteObserver（具体的观察者）\",\"ConcreteObserver角色表示具体的Observer。当它的update方法被调用后，会去获取要观察的对象的最新状态。\"]},\"82\":{\"h\":\"示例\",\"t\":[\"类和接口一览表：\",\"名字\",\"说明\",\"Observer\",\"表示观察者的接口（Observer）\",\"NunberGenerator\",\"表示生成数值的对象的抽象类（Subject）\",\"RandomNumberGenerator\",\"生成随机数的类（ConcreteSubject）\",\"DigitObserver\",\"表示以数字形式显示数值的类（ConcreteObserver）\",\"GraphObserver\",\"表示以简单图示形式显示熟知的类（ConcreteObserver）\",\"public interface Observer { void update(NumberGenerator generator); } \",\"public abstract class NumberGenerator { private final List<Observer> observers = new ArrayList<>(); public void addObserver(Observer o) { observers.add(o); } public void deleteObserver(Observer o) { observers.remove(o); } public void notifyObservers() { observers.forEach(o -> o.update(this)); } public abstract int getNumber(); public abstract void execute(); } \",\"public class RandomNumberGenerator extends NumberGenerator { private Random random = new Random(); private int number; @Override public int getNumber() { return number; } @Override public void execute() { for (int i = 0; i < 20; i++) { number = random.nextInt(50); notifyObservers(); } } } \",\"public class DigitObserver implements Observer { @Override public void update(NumberGenerator generator) { System.out.println(\\\"DigitObserver:\\\" + generator.getNumber()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } \",\"public class GraphObserver implements Observer { @Override public void update(NumberGenerator generator) { System.out.print(\\\"GraphObserver:\\\"); int count = generator.getNumber(); StringBuilder sb = new StringBuilder(); for (int i = 0; i < count; i++) { System.out.print(\\\"*\\\"); } System.out.println(); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } \",\"public class Main { public static void main(String[] args) { NumberGenerator generator = new RandomNumberGenerator(); Observer observer1 = new DigitObserver(); Observer observer2 = new GraphObserver(); generator.addObserver(observer1); generator.addObserver(observer2); generator.execute(); } } \",\"DigitObserver:38 GraphObserver:************************************** DigitObserver:17 GraphObserver:***************** DigitObserver:39 GraphObserver:*************************************** ... \"]},\"83\":{\"h\":\"原型模式\"},\"84\":{\"h\":\"概述\",\"t\":[\"用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\"]},\"85\":{\"h\":\"结构\",\"t\":[\"原型模式包含如下角色：\",\"抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\",\"具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\",\"访问类：使用具体原型类中的 clone() 方法来复制新的对象。\",\"接口类图如下：\"]},\"86\":{\"h\":\"实现\",\"t\":[\"原型模式的克隆分为浅克隆和深克隆。\",\"浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\",\"深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\",\"Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：\",\"Realizetype（具体的原型类）：\",\"public class Realizetype implements Cloneable { public Realizetype() { System.out.println(\\\"具体的原型对象创建完成！\\\"); } @Override protected Realizetype clone() throws CloneNotSupportedException { System.out.println(\\\"具体原型复制成功！\\\"); return (Realizetype) super.clone(); } } \",\"PrototypeTest（测试访问类）：\",\"public class PrototypeTest { public static void main(String[] args) throws CloneNotSupportedException { Realizetype r1 = new Realizetype(); Realizetype r2 = r1.clone(); System.out.println(\\\"对象r1和r2是同一个对象？\\\" + (r1 == r2)); } } \"]},\"87\":{\"h\":\"案例\",\"t\":[\"用原型模式生成“三好学生”奖状\",\"同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\",\"类图如下：\",\"代码如下：\",\"//奖状类 public class Citation implements Cloneable { private String name; public void setName(String name) { this.name = name; } public String getName() { return (this.name); } public void show() { System.out.println(name + \\\"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\\\"); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //测试访问类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); c1.setName(\\\"张三\\\"); //复制奖状 Citation c2 = c1.clone(); //将奖状的名字修改李四 c2.setName(\\\"李四\\\"); c1.show(); c2.show(); } } \"]},\"88\":{\"h\":\"使用场景\",\"t\":[\"对象的创建非常复杂，可以使用原型模式快捷的创建对象。\",\"性能和安全要求比较高。\"]},\"89\":{\"h\":\"扩展（深克隆）\",\"t\":[\"将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\",\"//奖状类 public class Citation implements Cloneable { private Student stu; public Student getStu() { return stu; } public void setStu(Student stu) { this.stu = stu; } void show() { System.out.println(stu.getName() + \\\"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\\\"); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); } } //学生类 public class Student { private String name; private String address; public Student(String name, String address) { this.name = name; this.address = address; } public Student() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } //测试类 public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); Student stu = new Student(\\\"张三\\\", \\\"西安\\\"); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\\\"李四\\\"); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\\\"stu和stu1是同一个对象？\\\" + (stu == stu1)); c1.show(); c2.show(); } } \",\"运行结果为：\",\"stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\",\"public class CitationTest1 { public static void main(String[] args) throws Exception { Citation c1 = new Citation(); Student stu = new Student(\\\"张三\\\", \\\"西安\\\"); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\b.txt\\\")); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\b.txt\\\")); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(\\\"李四\\\"); //判断stu对象和stu1对象是否是同一个对象 System.out.println(\\\"stu和stu1是同一个对象？\\\" + (stu == stu1)); c1.show(); c2.show(); } } \",\"运行结果为：\",\"注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\"]},\"90\":{\"h\":\"代理模式\"},\"91\":{\"h\":\"概述\",\"t\":[\"由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\",\"Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\"]},\"92\":{\"h\":\"结构\",\"t\":[\"代理（Proxy）模式分为三种角色：\",\"抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\",\"真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\",\"代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\"]},\"93\":{\"h\":\"静态代理\",\"t\":[\"我们通过案例来感受一下静态代理。\",\"【例】火车站卖票\",\"如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\",\"代码如下：\",\"//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代售点 public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); public void sell() { System.out.println(\\\"代理点收取一些服务费用\\\"); station.sell(); } } //测试类 public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); } } \",\"从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\"]},\"94\":{\"h\":\"JDK动态代理\",\"t\":[\"接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\",\"代码如下：\",\"//卖票接口 public interface SellTickets { void sell(); } //火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代理工厂，用来创建代理对象 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { //使用Proxy获取代理对象 /* newProxyInstance()方法参数说明： ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可 Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口 InvocationHandler h ： 代理对象的调用处理程序 */ SellTickets proxyObject = (SellTickets) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { /* InvocationHandler中invoke方法参数说明： proxy ： 代理对象，和proxyObject是同一个对象，在invoke方法中基本不用 method ： 对应于在代理对象上调用的接口方法的 Method 实例 args ： 代理对象调用接口方法时传递的实际参数 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(JDK动态代理方式)\\\"); //执行真实对象 Object result = method.invoke(station, args); return result; } }); return proxyObject; } } //测试类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \",\"ProxyFactory是代理类吗？\",\"ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：\",\"package com.sun.proxy; import com.itheima.proxy.dynamic.jdk.SellTickets; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements SellTickets { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { try { m1 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"equals\\\", Class.forName(\\\"java.lang.Object\\\")); m2 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"toString\\\", new Class[0]); m3 = Class.forName(\\\"com.itheima.proxy.dynamic.jdk.SellTickets\\\").getMethod(\\\"sell\\\", new Class[0]); m0 = Class.forName(\\\"java.lang.Object\\\").getMethod(\\\"hashCode\\\", new Class[0]); return; } catch (NoSuchMethodException noSuchMethodException) { throw new NoSuchMethodError(noSuchMethodException.getMessage()); } catch (ClassNotFoundException classNotFoundException) { throw new NoClassDefFoundError(classNotFoundException.getMessage()); } } public final boolean equals(Object object) { try { return (Boolean)this.h.invoke(this, m1, new Object[]{object}); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final String toString() { try { return (String)this.h.invoke(this, m2, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final int hashCode() { try { return (Integer)this.h.invoke(this, m0, null); } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } public final void sell() { try { this.h.invoke(this, m3, null); // 调用的就是自己实现的invoke方法 return; } catch (Error | RuntimeException throwable) { throw throwable; } catch (Throwable throwable) { throw new UndeclaredThrowableException(throwable); } } } \",\"从上面的类中，我们可以看到以下几个信息：\",\"代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。\",\"代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。\",\"动态代理的执行流程是什么样？\",\"下面是摘取的重点代码：\",\"//程序运行过程中动态生成的代理类 public final class $Proxy0 extends Proxy implements SellTickets { private static Method m3; public $Proxy0(InvocationHandler invocationHandler) { super(invocationHandler); } static { m3 = Class.forName(\\\"com.itheima.proxy.dynamic.jdk.SellTickets\\\").getMethod(\\\"sell\\\", new Class[0]); } public final void sell() { this.h.invoke(this, m3, null); } } //Java提供的动态代理相关类 public class Proxy implements java.io.Serializable { protected InvocationHandler h; protected Proxy(InvocationHandler h) { this.h = h; } } //代理工厂类 public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(JDK动态代理方式)\\\"); Object result = method.invoke(station, args); return result; } }); return sellTickets; } } //测试访问类 public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \",\"执行流程如下：\",\"在测试类中通过代理对象调用sell()方法\",\"根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\",\"代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\",\"invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\"]},\"95\":{\"h\":\"CGLIB动态代理\",\"t\":[\"同样是上面的案例，我们再次使用CGLIB代理实现。\",\"如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\",\"CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\",\"CGLIB是第三方提供的包，所以需要引入jar包的坐标：\",\"<dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> <version>2.2.2</version> </dependency> \",\"代码如下：\",\"//火车站 public class TrainStation { public void sell() { System.out.println(\\\"火车站卖票\\\"); } } //代理工厂 public class ProxyFactory implements MethodInterceptor { private TrainStation target = new TrainStation(); public TrainStation getProxyObject() { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; } /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"代理点收取一些服务费用(CGLIB动态代理方式)\\\"); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; } } //测试类 public class Client { public static void main(String[] args) { //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); } } \"]},\"96\":{\"h\":\"三种代理的对比\",\"t\":[\"jdk代理和CGLIB代理\",\"使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\",\"在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\",\"动态代理和静态代理\",\"动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\",\"如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\"]},\"97\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\",\"代理对象可以扩展目标对象的功能；\",\"代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\",\"缺点：\",\"增加了系统的复杂度；\"]},\"98\":{\"h\":\"使用场景\",\"t\":[\"远程（Remote）代理\",\"本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\",\"防火墙（Firewall）代理\",\"当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\",\"保护（Protect or Access）代理\",\"控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\"]},\"99\":{\"h\":\"单例模式\",\"t\":[\"为什么要使用单例模式详解\",\"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\",\"这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\"]},\"100\":{\"h\":\"单例模式的结构\",\"t\":[\"单例模式的主要有以下角色：\",\"单例类。只能创建一个实例的类\",\"访问类。使用单例类\"]},\"101\":{\"h\":\"单例模式的实现\",\"t\":[\"单例设计模式分类两种：\",\"​ 饿汉式：类加载就会导致该单实例对象被创建\",\"​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\",\"饿汉式-方式1（静态变量方式）\",\"/** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } \",\"​ 该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\",\"饿汉式-方式2（静态代码块方式）\",\"/** * 恶汉式 * 在静态代码块中创建该类对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } \",\"该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\",\"懒汉式-方式1（线程不安全）\",\"/** * 懒汉式 * 线程不安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\",\"懒汉式-方式2（线程安全）\",\"/** * 懒汉式 * 线程安全 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; //对外提供静态方法获取该对象 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\",\"懒汉式-方式3（双重检查锁）\",\"再来讨论一下懒汉模式中加锁的问题，对于 getInstance() 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\",\"/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为null if(instance == null) { instance = new Singleton(); } } } return instance; } } \",\"双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题（此处会问Java对象的创建过程），出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\",\"要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关键字可以保证可见性和有序性。\",\"/** * 双重检查方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { //第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际 if(instance == null) { synchronized (Singleton.class) { //抢到锁之后再次判断是否为空 if(instance == null) { instance = new Singleton(); } } } return instance; } } \",\"添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\",\"懒汉式-方式4（静态内部类方式）\",\"静态内部类单例模式中实例由内部类创建（静态内部类的初始化时机），由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。\",\"/** * 静态内部类方式 */ public class Singleton { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } \",\"第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder\",\"并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\",\"静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\",\"枚举方式\",\"枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\",\"/** * 枚举方式 */ public enum Singleton { INSTANCE; } \",\"枚举方式属于饿汉式方式。\"]},\"102\":{\"h\":\"存在的问题\"},\"103\":{\"h\":\"问题演示\",\"t\":[\"破坏单例模式：\",\"使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。\",\"序列化反序列化\",\"Singleton类：\",\"public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } \",\"Test类：\",\"public class Test { public static void main(String[] args) throws Exception { //往文件中写对象 //writeObject2File(); //从文件中读取对象 Singleton s1 = readObjectFromFile(); Singleton s2 = readObjectFromFile(); //判断两个反序列化后的对象是否是同一个对象 System.out.println(s1 == s2); } private static Singleton readObjectFromFile() throws Exception { //创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\a.txt\\\")); //第一个读取Singleton对象 Singleton instance = (Singleton) ois.readObject(); return instance; } public static void writeObject2File() throws Exception { //获取Singleton类的对象 Singleton instance = Singleton.getInstance(); //创建对象输出流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\\\"C:\\\\\\\\Users\\\\\\\\Think\\\\\\\\Desktop\\\\\\\\a.txt\\\")); //将instance对象写出到文件中 oos.writeObject(instance); } } \",\"上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式。\",\"反射\",\"Singleton类：\",\"public class Singleton { //私有构造方法 private Singleton() {} private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } \",\"Test类：\",\"public class Test { public static void main(String[] args) throws Exception { //获取Singleton类的字节码对象 Class clazz = Singleton.class; //获取Singleton类的私有无参构造方法对象 Constructor constructor = clazz.getDeclaredConstructor(); //取消访问检查 constructor.setAccessible(true); //创建Singleton类的对象s1 Singleton s1 = (Singleton) constructor.newInstance(); //创建Singleton类的对象s2 Singleton s2 = (Singleton) constructor.newInstance(); //判断通过反射创建的两个Singleton对象是否是同一个对象 System.out.println(s1 == s2); } } \",\"上面代码运行结果是false，表明序列化和反序列化已经破坏了单例设计模式\",\"枚举方式不会出现这两个问题。\"]},\"104\":{\"h\":\"问题的解决\",\"t\":[\"序列化、反序列方式破坏单例模式的解决方法\",\"在Singleton类中添加readResolve()方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。\",\"Singleton类：\",\"public class Singleton implements Serializable { //私有构造方法 private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** * 下面是为了解决序列化反序列化破解单例模式 */ private Object readResolve() { return SingletonHolder.INSTANCE; } } \",\"源码解析：\",\"ObjectInputStream类\",\"public final Object readObject() throws IOException, ClassNotFoundException{ ... // if nested read, passHandle contains handle of enclosing object int outerHandle = passHandle; try { Object obj = readObject0(false);//重点查看readObject0方法 ..... } private Object readObject0(boolean unshared) throws IOException { ... try { switch (tc) { ... case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法 ... } } finally { depth--; bin.setBlockDataMode(oldMode); } } private Object readOrdinaryObject(boolean unshared) throws IOException { ... //isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类， obj = desc.isInstantiable() ? desc.newInstance() : null; ... // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) { // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量 // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。 Object rep = desc.invokeReadResolve(obj); ... } return obj; } \",\"反射方式破解单例的解决方法\",\"public class Singleton { //私有构造方法 private Singleton() { /* 反射破解单例模式需要添加的代码 */ if(instance != null) { throw new RuntimeException(); } } private static volatile Singleton instance; //对外提供静态方法获取该对象 public static Singleton getInstance() { if(instance != null) { return instance; } synchronized (Singleton.class) { if(instance != null) { return instance; } instance = new Singleton(); return instance; } } } \",\"这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。\"]},\"105\":{\"h\":\"JDK源码解析-Runtime类\",\"t\":[\"Runtime类就是使用的单例设计模式。\",\"通过源代码查看使用的是哪儿种单例模式\",\"public class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class <code>Runtime</code> are instance * methods and must be invoked with respect to the current runtime object. * * @return the <code>Runtime</code> object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don't let anyone else instantiate this class */ private Runtime() {} ... } \",\"从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。\",\"使用Runtime类中的方法\",\"public class RuntimeDemo { public static void main(String[] args) throws IOException { //获取Runtime类对象 Runtime runtime = Runtime.getRuntime(); //返回 Java 虚拟机中的内存总量。 System.out.println(runtime.totalMemory()); //返回 Java 虚拟机试图使用的最大内存量。 System.out.println(runtime.maxMemory()); //创建一个新的进程执行指定的字符串命令，返回进程对象 Process process = runtime.exec(\\\"ipconfig\\\"); //获取命令执行后的结果，通过输入流获取 InputStream inputStream = process.getInputStream(); byte[] arr = new byte[1024 * 1024* 100]; int b = inputStream.read(arr); System.out.println(new String(arr,0,b,\\\"gbk\\\")); } } \"]},\"106\":{\"h\":\"软件设计原则\",\"t\":[\"在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\"]},\"107\":{\"h\":\"开闭原则\",\"t\":[\"对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\",\"想要达到这样的效果，我们需要使用接口和抽象类。\",\"因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\",\"下面以 搜狗输入法 的皮肤为例介绍开闭原则的应用。\",\"【例】搜狗输入法 的皮肤设计。\",\"分析：搜狗输入法 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\"]},\"108\":{\"h\":\"里氏代换原则\",\"t\":[\"面向对象中的继承性的思考和说明\",\"继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\",\"继承在 给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障\",\"问题提出：在编程中，如何正确的使用继承 ? => 里氏替换原则\",\"在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方 法\",\"里氏替换原则告诉我们，继承实际上让两个类耦合性增强了， 在适当的情况下，可以通过聚合，组合，依赖 来解决问题。\",\"class Base { // 把更基础的方法和成员写到Base类 } class A extends Base { public int func1(int a, int b) { return a - b; } } class B extends Base { // 需要在B中使用A类的方法，使用组合关系 private A a = new A(); @Override public int func1(int a, int b) { return a + b; } public int func2(int a, int b) { return func1(a, b) + 9; } // 在B中使用A中的方法 public int func3(int a, int b) { return a.func1(a, b); } } public class Client { public static void main(String[] args) { A a = new A(); System.out.println(\\\"11-3=\\\" + a.func1(11, 3)); B b = new B(); System.out.println(\\\"11-3=\\\" + b.func3(11, 3)); } } \"]},\"109\":{\"h\":\"依赖倒转原则\",\"t\":[\"高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\",\"下面看一个例子来理解依赖倒转原则\",\"【例】组装电脑\",\"现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\",\"类图如下：\",\"代码如下：\",\"希捷硬盘类（XiJieHardDisk）:\",\"public class XiJieHardDisk implements HardDisk { public void save(String data) { System.out.println(\\\"使用希捷硬盘存储数据\\\" + data); } public String get() { System.out.println(\\\"使用希捷希捷硬盘取数据\\\"); return \\\"数据\\\"; } } \",\"Intel处理器（IntelCpu）：\",\"public class IntelCpu implements Cpu { public void run() { System.out.println(\\\"使用Intel处理器\\\"); } } \",\"金士顿内存条（KingstonMemory）：\",\"public class KingstonMemory implements Memory { public void save() { System.out.println(\\\"使用金士顿作为内存条\\\"); } } \",\"电脑（Computer）：\",\"public class Computer { private XiJieHardDisk hardDisk; private IntelCpu cpu; private KingstonMemory memory; public IntelCpu getCpu() { return cpu; } public void setCpu(IntelCpu cpu) { this.cpu = cpu; } public KingstonMemory getMemory() { return memory; } public void setMemory(KingstonMemory memory) { this.memory = memory; } public XiJieHardDisk getHardDisk() { return hardDisk; } public void setHardDisk(XiJieHardDisk hardDisk) { this.hardDisk = hardDisk; } public void run() { System.out.println(\\\"计算机工作\\\"); cpu.run(); memory.save(); String data = hardDisk.get(); System.out.println(\\\"从硬盘中获取的数据为：\\\" + data); } } \",\"测试类（TestComputer）：\",\"测试类用来组装电脑。\",\"public class TestComputer { public static void main(String[] args) { Computer computer = new Computer(); computer.setHardDisk(new XiJieHardDisk()); computer.setCpu(new IntelCpu()); computer.setMemory(new KingstonMemory()); computer.run(); } } \",\"上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\",\"根据依赖倒转原则进行改进：\",\"代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\",\"类图如下：\",\"电脑（Computer）：\",\"public class Computer { private HardDisk hardDisk; private Cpu cpu; private Memory memory; public HardDisk getHardDisk() { return hardDisk; } public void setHardDisk(HardDisk hardDisk) { this.hardDisk = hardDisk; } public Cpu getCpu() { return cpu; } public void setCpu(Cpu cpu) { this.cpu = cpu; } public Memory getMemory() { return memory; } public void setMemory(Memory memory) { this.memory = memory; } public void run() { System.out.println(\\\"计算机工作\\\"); } } \",\"面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\"]},\"110\":{\"h\":\"接口隔离原则\",\"t\":[\"客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\",\"下面看一个例子来理解接口隔离原则\",\"【例】安全门案例\",\"我们需要创建一个黑马品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\",\"上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：\",\"代码如下：\",\"AntiTheft（接口）：\",\"public interface AntiTheft { void antiTheft(); } \",\"Fireproof（接口）：\",\"public interface Fireproof { void fireproof(); } \",\"Waterproof（接口）：\",\"public interface Waterproof { void waterproof(); } \",\"HeiMaSafetyDoor（类）：\",\"public class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof { public void antiTheft() { System.out.println(\\\"防盗\\\"); } public void fireproof() { System.out.println(\\\"防火\\\"); } public void waterproof() { System.out.println(\\\"防水\\\"); } } \",\"ItcastSafetyDoor（类）：\",\"public class ItcastSafetyDoor implements AntiTheft,Fireproof { public void antiTheft() { System.out.println(\\\"防盗\\\"); } public void fireproof() { System.out.println(\\\"防火\\\"); } } \"]},\"111\":{\"h\":\"迪米特法则\",\"t\":[\"迪米特法则又叫最少知识原则。\",\"只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。\",\"其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\",\"迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\",\"下面看一个例子来理解迪米特法则\",\"【例】明星与经纪人的关系实例\",\"明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\",\"类图如下：\",\"代码如下：\",\"明星类（Star）\",\"public class Star { private String name; public Star(String name) { this.name=name; } public String getName() { return name; } } \",\"粉丝类（Fans）\",\"public class Fans { private String name; public Fans(String name) { this.name=name; } public String getName() { return name; } } \",\"媒体公司类（Company）\",\"public class Company { private String name; public Company(String name) { this.name=name; } public String getName() { return name; } } \",\"经纪人类（Agent）\",\"public class Agent { private Star star; private Fans fans; private Company company; public void setStar(Star star) { this.star = star; } public void setFans(Fans fans) { this.fans = fans; } public void setCompany(Company company) { this.company = company; } public void meeting() { System.out.println(fans.getName() + \\\"与明星\\\" + star.getName() + \\\"见面了。\\\"); } public void business() { System.out.println(company.getName() + \\\"与明星\\\" + star.getName() + \\\"洽淡业务。\\\"); } } \"]},\"112\":{\"h\":\"合成复用原则\",\"t\":[\"合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\",\"通常类的复用分为继承复用和合成复用两种。\",\"继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\",\"继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。\",\"子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\",\"它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运 行时不可能发生变化。\",\"采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\",\"它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\",\"对象间的耦合度低。可以在类的成员位置声明抽象。\",\"复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\",\"下面看一个例子来理解合成复用原则\",\"【例】汽车分类管理程序\",\"汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：\",\"从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\"]},\"113\":{\"h\":\"策略模式\",\"t\":[\"可见《图解设计模式》Strategy模式篇\"]},\"114\":{\"h\":\"概述\",\"t\":[\"使用Strategy模式可以整体地替换算法的实现部分。能够整体地替换算法，能让我们轻松地以不同的算法去解决同一个问题，这种模式就是Strategy模式。\",\"通常在编程时算法会被写在具体的方法中。Strategy模式却特意将算法与其他部分分离开，只是定义了与算法相关的接口（API），然后再程序中以委托的方式来使用算法。**使用委托这种弱关联关系可以很方便地整体替换算法。**例如使用Strategy模式编写象棋程序时，可以方便地根据棋手的选择切换AI例程的水平。\"]},\"115\":{\"h\":\"结构\",\"t\":[\"Strategy（策略）\",\"Strategy角色负责决定实现策略所必需的接口（API）。\",\"ConcreteStrategy（具体的策略）\",\"ConcreteStrategy角色负责实现Strategy角色的接口（API），即负责实现具体的策略。\",\"Context（上下文）\",\"负责使用Strategy角色。Context角色保存了ConcreteStrategy角色的实例，并使用ConcreteStrategy角色去实现需求。\"]},\"116\":{\"h\":\"示例\",\"t\":[\"名字\",\"说明\",\"Hand\",\"表示猜拳中的”手势“的类\",\"Strategy\",\"表示猜拳游戏中的策略的类\",\"WinningStrategy\",\"表示“如果这局猜拳获胜，那么下一局也出一样的手势”这一策略的类\",\"ProbStrategy\",\"表示“根据上一局的手势从概率上计算出下一局的手势从这前的猜拳结果计算下一局出各种拳的概率”这一策略的类\",\"Player\",\"表示进行猜拳游戏的选手类\",\"public class Hand { public static final int HANDVALUE_GUU = 0; public static final int HANDVALUE_CHO = 1; public static final int HANDVALUE_PAA = 2; public static final Hand[] hand = { new Hand(HANDVALUE_GUU), new Hand(HANDVALUE_CHO), new Hand(HANDVALUE_PAA) }; private static final String[] name = { \\\"石头\\\", \\\"剪刀\\\", \\\"布\\\" }; // 表示猜拳中出的手势值 private int handvalue; private Hand(int handvalue) { this.handvalue = handvalue; } public static Hand getHand(int handvalue) { return hand[handvalue]; } // 如果this战胜了h返回true public boolean isStrongerThan(Hand h) { return fight(h) == 1; } // 如果this输给了h返回true public boolean isWeakerThan(Hand h) { return fight(h) == -1; } // 计分：平 0，胜 1，负-1 private int fight(Hand h) { if (this == h) { return 0; } else if ((this.handvalue + 1) % 3 == h.handvalue) { return 1; } else { return -1; } } @Override public String toString() { return name[handvalue]; } } \",\"public interface Strategy { // 获取下一局要出的手势 Hand nextHand(); // 上一局的手势是否获胜 void study(boolean win); } \",\"public class WinningStrategy implements Strategy { private Random random; private boolean won = false; private Hand prevHand; public WinningStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { if (!won) { prevHand = Hand.getHand(random.nextInt(3)); } return prevHand; } @Override public void study(boolean win) { won = win; } } \",\"public class ProbStrategy implements Strategy { private Random random; private int preHandValue = 0; private int currentHandValue = 0; private int[][] history = { {1, 1, 1,}, {1, 1, 1,}, {1, 1, 1,} }; public ProbStrategy(int seed) { random = new Random(seed); } @Override public Hand nextHand() { int bet = random.nextInt(getSum(currentHandValue)); int handvalue = 0; if (bet < history[currentHandValue][0]) { handvalue = 0; } else if (bet < history[currentHandValue][0] + history[currentHandValue][1]) { handvalue = 1; } else { handvalue = 2; } preHandValue = currentHandValue; currentHandValue = handvalue; return Hand.getHand(handvalue); } private int getSum(int hv) { int sum = 0; for (int i = 0; i < 3; i++) { sum += history[hv][i]; } return sum; } @Override public void study(boolean win) { if (win) { history[preHandValue][(currentHandValue + 1) % 3]++; history[preHandValue][(currentHandValue + 2) % 3]++; } } } \",\"public class Player { private String name; private Strategy strategy; private int wincount; private int losecount; private int gamecount; public Player(String name, Strategy strategy) { this.name = name; this.strategy = strategy; } public Hand nextHand() { return strategy.nextHand(); } public void win() { strategy.study(true); wincount++; gamecount++; } public void lose() { strategy.study(false); losecount++; gamecount++; } public void even() { gamecount++; } @Override public String toString() { return \\\"[\\\" + name + \\\":\\\" + gamecount + \\\" games, \\\" + wincount + \\\" win, \\\" + losecount + \\\" lose\\\" + \\\"]\\\"; } } \",\"public class Main { public static void main(String[] args) { int seed1 = 314; int seed2 = 15; Player tara = new Player(\\\"Tara\\\", new WinningStrategy(seed1)); Player hana = new Player(\\\"Hana\\\", new ProbStrategy(seed2)); for (int i = 0; i < 10000; i++) { Hand nextHand1 = tara.nextHand(); Hand nextHand2 = hana.nextHand(); if (nextHand1.isStrongerThan(nextHand2)) { System.out.println(\\\"Winner:\\\" + tara); tara.win(); hana.lose(); } else if (nextHand2.isStrongerThan(nextHand1)) { System.out.println(\\\"Winner:\\\" + hana); tara.lose(); hana.win(); } else { System.out.println(\\\"Even...\\\"); tara.even(); hana.even(); } System.out.println(\\\"Total result:\\\"); System.out.println(tara); System.out.println(hana); } } } \",\"... Winner:[Hana:9999 games, 3079 win, 3493 lose] Total result: [Tara:10000 games, 3493 win, 3080 lose] [Hana:10000 games, 3080 win, 3493 lose] \"]},\"117\":{\"h\":\"模板方法模式\"},\"118\":{\"h\":\"概述\",\"t\":[\"在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\",\"例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\",\"定义：\",\"定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\"]},\"119\":{\"h\":\"结构\",\"t\":[\"模板方法（Template Method）模式包含以下主要角色：\",\"抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\",\"模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\",\"基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\",\"抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\",\"具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\",\"钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\",\"一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\",\"具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\"]},\"120\":{\"h\":\"案例实现\",\"t\":[\"【例】炒菜\",\"炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：\",\"代码如下：\",\"public abstract class AbstractClass { public final void cookProcess() { //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); } public void pourOil() { System.out.println(\\\"倒油\\\"); } //第二步：热油是一样的，所以直接实现 public void heatOil() { System.out.println(\\\"热油\\\"); } //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry(){ System.out.println(\\\"炒啊炒啊炒到熟啊\\\"); } } public class ConcreteClass_BaoCai extends AbstractClass { @Override public void pourVegetable() { System.out.println(\\\"下锅的蔬菜是包菜\\\"); } @Override public void pourSauce() { System.out.println(\\\"下锅的酱料是辣椒\\\"); } } public class ConcreteClass_CaiXin extends AbstractClass { @Override public void pourVegetable() { System.out.println(\\\"下锅的蔬菜是菜心\\\"); } @Override public void pourSauce() { System.out.println(\\\"下锅的酱料是蒜蓉\\\"); } } public class Client { public static void main(String[] args) { //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); } } \",\"注意：为防止恶意操作，一般模板方法都加上 final 关键词。\"]},\"121\":{\"h\":\"优缺点\",\"t\":[\"优点：\",\"提高代码复用性\",\"将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\",\"实现了反向控制\",\"通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\",\"缺点：\",\"对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\",\"父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\"]},\"122\":{\"h\":\"适用场景\",\"t\":[\"算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\",\"需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\"]},\"123\":{\"h\":\"JDK源码解析\",\"t\":[\"InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法，如下：\",\"public abstract class InputStream implements Closeable { //抽象方法，要求子类必须重写 public abstract int read() throws IOException; public int read(byte b[]) throws IOException { return read(b, 0, b.length); } public int read(byte b[], int off, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (off < 0 || len < 0 || len > b.length - off) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据 if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i < len ; i++) { c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; } } \",\"从上面代码可以看到，无参的 read() 方法是抽象方法，要求子类必须实现。而 read(byte b[]) 方法调用了 read(byte b[], int off, int len) 方法，所以在此处重点看的方法是带三个参数的方法。\",\"在该方法中第18行、27行，可以看到调用了无参的抽象的 read() 方法。\",\"总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\"]},\"124\":{\"h\":\"操作系统上\"},\"125\":{\"h\":\"1、操作系统的概念\",\"t\":[\"操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境(从下往上看)，他是计算机系统中最基本的系统软件(从上往下看)\",\"从任务管理器可以看出操作系统对硬件和软件资源的分配\"]},\"126\":{\"h\":\"2、操作系统需要实现的功能\",\"t\":[\"操作系统作为系统资源的管理者需要实现的功能和目标\",\"补充：进程是一个程序的执行过程，执行前需要将该程序放到内存中，才能被CPU处理\",\"需要实现的功能和目标：\",\"文件管理\",\"存储器管理\",\"处理机管理\",\"设备管理\",\"目标：安全、高效\",\"操作系统作为用户和计算机硬件之间的接口(从下往上看)需要实现的功能\",\"用户接口：\",\"命令接口：允许用户直接使用\",\"联机命令接口 = 交互式命令接口\",\"脱机命令接口 = 批处理命令接口\",\"程序接口：允许用户通过程序间接使用，由一组系统调用组成\",\"GUI：图形用户接口\",\"用户可以通过使用形象的图形界面进行操作，不需要记忆复杂的指令 、参数。比如将文件拖拽到垃圾箱\",\"目标：方便用户使用\",\"操作系统作为最接近硬件的层次(从上往下看)需要实现的功能和目标\",\"功能和目标：实现对硬件机器的拓展\",\"没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造为功能更强、使用更方便的机器\",\"通常把覆盖了软件的机器称为扩充机器，又称为虚拟机\"]},\"127\":{\"h\":\"3、操作系统的四个特征\",\"t\":[\"四个特征：并发，共享，虚拟，异步。其中并发和共享是两个最基本的特征，二者互为存在的条件\",\"并发：指两个或多个事件在同一个时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。\",\"并行：指两个或多个事件在同一时刻同时发生\",\"操作系统的并发性：计算机系统中同时存在着多个运行着程序\",\"一个单核CPU同一时刻只能执行一个程序\",\"共享：资源共享，系统中的资源可供内存中多个并发执行的进程共同使用\",\"资源共享分为：互斥共享方式和同时共享方式\",\"互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。比如：摄像头\",\"同时共享方式：系统中的某些资源，允许一个时间段内由多个进程同时对他们进行访问(此处的同时往往是宏观上的，微观上可能是交替访问，比如扬声器可以同时播放两个地方的)。比如：发送文件\",\"并发和共享的关系：互为存在的条件\",\"如果失去并发性，系统中只有一个程序正在执行，则共享性失去存在的意义\",\"如果失去共享性，如果提供vx和qq同时发送文件则不能实现，因为不能同时访问硬盘资源，也就无法并发\",\"虚拟：一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物是用户感受到的(后续讲解)\",\"虚拟技术分为：空分复用技术(比如虚拟存储技术，一个电脑供4G运行内存，运行一个GTA需要4G内存，但我们能够同时运行GTA和其他软件)和时分复用技术(虚拟处理器，比如：我们同时运行多个程序)\",\"如果没有并发性，则一个时间段内只有一个程序运行，那么也就失去实现虚拟性的意义，没有并发性就谈不上虚拟性\",\"异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进\",\"只有系统拥有并发性，才可能导致异步性\"]},\"128\":{\"h\":\"4、OS的运行机制和体系结构\",\"t\":[\"两种指令\",\"指令：就是让CPU能够识别、执行的最基本命令\",\"两种指令：\",\"特权指令：如内存清零指令，此指令不允许用户程序使用\",\"非特权指令：普通的运算指令\",\"两种处理器状态\",\"CPU如何判断当前是否可以执行特权指令？\",\"CPU有两种处理器状态(用程序状态字寄存器(PSW)中的某标志位来表示当前处理器处于什么状态，如0表示用户态，1表示核心态)\",\"用户态(目态)：此时CPU只能执行非特权指令\",\"核心态(管态)：特权指令和非特权指令都可执行\",\"两种程序\",\"内核程序：是系统的管理者，可以执行特权和非特权指令，运行在核心态\",\"应用程序：为了保证系统能够安全运行，普通应用程序只能执行非特权指令，运行在用户态\",\"操作系统的内核\",\"内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分，实现操作系统的内核功能的程序就是内核程序\",\"操作系统的体系结构\",\"操作系统的体系结构分为大内核和微内核\",\"小结：\"]},\"129\":{\"h\":\"5、中断\",\"t\":[\"当中断发生时，CPU立即进入核心态\",\"当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理\",\"对于不同的中断信号，会进行不同的处理\",\"发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行\",\"用户态 → 核心态：通过中断\",\"核心态 → 用户态：执行一个特权指令，将程序状态字(PSW)的标志位设置为用户态\",\"中断的分类\",\"外中断的处理过程\",\"执行完每个指令之后，CPU都要检查当前是否有外部中断的信号\",\"如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字、程序计数器、通用寄存器)\",\"根据中断信号类型转入相应的中断处理程序(此时进入核心态)\",\"恢复原进程的CPU环境并退出中断，返回原进程继续往下执行\",\"小结：\"]},\"130\":{\"h\":\"6、系统调用\",\"t\":[\"系统调用概念：系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。\",\"应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作\",\"系统调用和库函数的区别\",\"库函数在应用程序和系统调用之间，在系统函数之上，内部有一些系统调用的封装\",\"系统调用的过程\",\"小结：\"]},\"131\":{\"h\":\"7、进程\",\"t\":[\"进程的定义\",\"程序：就是一个指令序列\",\"进程实体：\",\"问题：在有了并发之后，在CPU中运行不止一个程序。在内存中放入多个程序，各个程序的代码、运算数据存放的位置不同，操作系统如何找到各个程序代码以及数据存储的位置？\",\"解决：系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(比如代码和数据存储的位置)\",\"为了方便操作系统管理、完成各程序并发执行，引入了进程、进程实体的概念\",\"进程实体(进程映像)的组成\",\"PCB：操作系统通过PCB来管理进程，存储管理所需要的各种信息\",\"程序段：程序代码存放的位置\",\"数据段：程序运行时产生的数据存储的位置\",\"PCB的组成\",\"进程：是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。可以说进程是由PCB，程序段和数据段组成的。所谓创建进程就是创建PCB，撤销进程，就是撤销进程实体中的PCB。\",\"区别：进程实体是静态的，进程是动态的\",\"进程的组织\",\"一个系统中有很多个PCB，为了能够进行有效的管理，应该采取适当的方式将这些PCB组织起来\",\"链接方式\",\"索引方式\",\"进程特征\",\"动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的，是进程最基本的特征\",\"并发性：内存中有多个进程实体，各进程可以并发的执行\",\"独立性：进程是能够独立运行，独立获得资源、独立接收调度的基本单位\",\"异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统需要提供进程同步机制来解决异步问题，进程是资源分配、接收调度的基本单位\",\"结构性：每个进程配置一个PCB。结构上看进程由PCB、程序段、数据段组成\",\"小结：\"]},\"132\":{\"h\":\"8、进程的状态\",\"t\":[\"进程的基本状态\",\"进程是程序的一次执行，在这个执行过程中，有时进程正在被CPU处理，有时候等待CPU的服务，为了对各个进程进行管理，操作系统将进程划分为几种状态\",\"1、运行态(Running)：占有CPU，并在CPU运行(单核CP每次最多处理一个进程)\",\"2、就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能够运行(除了CPU以外，其他条件全部具备，比如获取打印机等)\",\"3、阻塞态(Waiting/Blocked)：因等待某一事件而暂时不能运行(比如：等待分配打印机、等待读取磁盘。CPU最昂贵的部件，为了提高CPU的利用率，需要先将其他资源分配到位，才能得到CPU的服务)\",\"4、创建态(New)：进程正在被创建，操作系统为进程分配资源、初始化PCB\",\"5、终止态(Terminate)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB\",\"前三个是基本状态\",\"进程状态的转换\",\"小结：\"]},\"133\":{\"h\":\"9、进程控制\",\"t\":[\"进程控制\",\"进程控制的主要功能就是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换\",\"如何实现进程控制\",\"问题：是否会发生从一个事件到另一个事件转换的时候出现中断，导致状态转移不完整？\",\"答：不会，进程控制是使用原语进行的\",\"用原语实现进程控制\",\"原语的特点是执行期间不允许中断，1只能一气呵成，这种不可被中断的操作就是原子操作\",\"原语使用\\\"关中断指令\\\"和\\\"开中断指令\\\"实现，开关中断权限非常大，所以只允许在核心态下执行特权指令\",\"进程控制相关的原语。无论哪个原语，要做的无非三类事情\",\"1、更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境) \",\"a、修改进程状态标志\",\"b、保存其运行环境\",\"c、恢复运行环境\",\"2、将PCB插入合适的队列\",\"3、分配/回收资源\",\"小结：\"]},\"134\":{\"h\":\"10、进程通信\",\"t\":[\"进程通信概念\",\"进程通信是指进程之间信息交换，进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立\",\"进程通信方法\",\"为了保证安全，一个进程不能直接访问另一个进程的地址空间，但各个进程之间信息交换又是必须的，为了保证进程间的安全通信，操作系统提供了一些方法\",\"1、共享存储：操作系统在内存中开辟一个区域供进程间共同使用，两个进程对共享空间的访问必须是互斥的(一个操作时另一个不能够访问)。操作系统只负责提供共享空间和同步互斥工具(如P,V操作)。有两种共享存储的方式\",\"1、基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种方式速度慢、限制多、是一种低级通信方式\",\"2、基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置都由进程控制，而不是操作系统。这种方式速度更快，是一种高级通信的方式\",\"2、管道通信：\",\"1、管道只能采用半双工通信，在某一时间段内只能实现单向传输，如果需要实现双向同时通信，则需要设置两个管道\",\"2、各进程要互斥的访问管道\",\"3、数据以字符流的形式写入管道，当管道写满的时候，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走以后，管道变空，此时读进程的read()系统调用将被阻塞\",\"4、如果管道没写满，就不允许读。如果没读空，就不允许写\",\"5、数据一旦被读出，就从管道中被抛弃，故读进程最多只能有一个\",\"3、消息传递：进程之间的数据交换以格式化消息为单位，进程通过操作系统提供的\\\"发送消息/接收消息\\\"两个原语进行数据交换\",\"小结：\"]},\"135\":{\"h\":\"11、线程、多线程模型\",\"t\":[\"线程概念\",\"有的进程可能需要同时做很多事情，比如qq要发送文件、要视频，而传统的进程只能串行的执行一系列程序，为此引入线程来增加并发度。即将进程再细分为很多的线程。\",\"传统的进程是程序执行流的最小单位，引入线程后，线程是程序执行流的最小单位\",\"线程是一个基本的CPU执行单位，也是程序执行流的最小单位\",\"引入线程之后，不仅是进程之间可以并发，进程内各线程也可以并发，进一步提高了系统的并发度，使得一个进程内可以并发处理各种任务\",\"引入线程之后，进程只作为除CPU之外的系统资源的分配单元(比如打印机、内存地址空间是分配给进程的)\",\"引入线程之后的变化\",\"1、对于资源的分配、调度 \",\"传统进程中、进程是资源分配和调度的基本单位\",\"引入线程之后，进程是资源分配的基本单位，线程是调度的基本单位\",\"2、对于并发性 \",\"传统进程中，只能进程间并发\",\"引入线程之后，各线程间也能并发，提升了并发度\",\"3、对于系统开销 \",\"传统进程间并发，需要切换进程的运行环境，系统开销大\",\"线程间并发，如果是同一进程内的线程切换，不需要切换进程环境，系统开销小\",\"引入线程后，系统的开销减小\",\"线程的属性\",\"1、线程是处理机调度的单位\",\"2、在多CPU的计算机中，各个线程可占用不同的CPU\",\"3、每个线程都有一个线程ID、线程控制块(TCB)\",\"4、线程也有就绪、阻塞、运行三种基本状态\",\"5、线程几乎不拥有系统资源，系统资源是分配给进程的\",\"6、同一进程的不同线程间可以共享进程的资源\",\"7、由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预\",\"8、同一进程中的线程切换，不会引起进程切换\",\"9、不同进程中的线程切换，会引起进程切换\",\"10、切换同进程内的线程，系统开销很小\",\"11、切换进程，系统开销大\",\"线程的实现方式\",\"1、用户级线程：由应用程序提供线程库实现\",\"所有的线程管理工作都是由应用程序负责(包括线程切换)\",\"用户级线程中，线程切换可以在用户态下完成，无需操作系统干预\",\"在用户看来是有多个线程，在操作系统内核看来，并不意识到线程的存在(即用户级线程对用户不透明(不透明就是能看见)，对操作系统透明)\",\"2、内核级线程\",\"线程的管理工作是操作系统内核完成，因此线程调度、切换的工作都是由内核负责，所以内核级线程的切换必须要在核心态下完成\",\"对操作系统不透明\",\"3、支持用户级线程和内核级线程的系统中，可采用上述二者组合的方式：将n各用户及线程映射到m各内核级线程上(n > m)\",\"操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位\",\"由几个用户级线程映射到几个内核级线程可引出多线程模型\",\"1、多对一模型：多个用户级线程映射到一个内核级线程\",\"优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\",\"缺点：当一个用户级线程被阻塞以后，整个进程都会被阻塞，并发度不高。多个线程不可以在多核处理机上并行运行\",\"2、一对一模型：一个用户级线程映射到一个内核级线程\",\"优点：当一个线程被阻塞以后，别的线程还可以执行。多线程可以在多核处理机上执行\",\"缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大\",\"3、多对多模型：n个用户级线程映射到m个内核级线程(n > m)，每个用户进程对应m个内核级线程\",\"优点：集上面二者的优点，客服了他们的缺点\",\"小结：\"]},\"136\":{\"h\":\"12、处理机的调度\",\"t\":[\"处理机调度的概念：从就绪队列中按照一定的算法选中一个进程并将处理机分配给它运行，以实现进程的并发执行\",\"调度的三个层次：\",\"高级调度(作业调度)：按一定的原则从外存上处于后备队列的作业中选中一个或多个作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使他们获得竞争处理机的权利。高级调度是外存和内存之间的调度，每个作业只调入一次，调出一次，作业调入时创建PCB，作业调出时撤销PCB。高级调度主要指的是调入问题，只有调入的时机是由操作系统来确定，调出必然是作业运行结束\",\"中级调度：\",\"挂起介绍：在引入虚拟存储技术以后，可以将暂时不能运行的进程调至外存等待，等它重新具备运行条件并且内存有空闲，再重新调入内存。这样做的目的是提高内存的利用率和系统吞吐量。暂时调到外存的进程状态为挂起状态，其中PCB不会被调到外存，而是会常驻内存，PCB记录进程数据。被挂起的进程PCB会被放到挂起队列中。\",\"中级调度就是决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会多次调入，调出，所以中级调度发生的频率比高级调度高\",\"低级调度(进程调度)：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，其频率很高，一般几十毫秒一次\",\"小结：\"]},\"137\":{\"h\":\"13、进程调度的时机、切换与过程的调度方式\",\"t\":[\"进程调度的时机\",\"进程调度的方式\",\"非剥夺调度方式：又称非抢占方式。即，只允许进程主动放弃处理机。在允许过程中即便有更紧迫的任务到达，也不会放弃处理器\",\"特点：实现简单，系统开销小但是无法及时处理紧急任务，适合早期批处理系统\",\"剥夺调度方式，又称抢占方式。当一个进程正在CPU上执行的时候，如果有更加紧急的进程需要CPU，则立即暂停正在执行的，将CPU分给紧急的那个进程\",\"特点：可以优先处理紧急的，也可以让各进程按时间片轮流执行。适合分时操作系统、实时操作系统\",\"进程切换\",\"进程调度指的是从就绪队列中选中一个要执行的进程，这个进程可以是刚刚被暂停执行的进程，也可以是另一个进程，后一种情况就需要进程切换\",\"进程切换主要完成了： \",\"1、对原来运行进程各种数据的保存\",\"2、对新的进程各种数据的恢复(如：程序计数器、各种数据寄存器等，这些信息一般保存在进程控制块中)\",\"进程切换是有代价的，因此过于频繁的进行进程调度、切换，会使整个系统的效率降低\",\"小结：\"]},\"138\":{\"h\":\"14、调度算法评价指标\",\"t\":[\"CPU利用率：指CPU\\\"忙碌\\\" 的时间占总时间的比例\",\"系统吞吐量：单位时间内完成的作业的数量\",\"周转时间、平均周转时间、带权周转时间、平均带权周转时间 \",\"周转时间：从作业被提交到系统开始，到作业完成为止的这段时间间隔。 \",\"周转时间包括四个部分：高级调度时间、低级调度的时间、进程在CPU执行的时间、进程等待I/O操作完成的时间\",\"周转时间 = 作业完成时间 - 作业提交时间\",\"平均周转时间 = (各作业周转时间之和) / 作业数\",\"带权周转时间 = (作业周转时间 / 作业实际运行的时间) = (作业完成时间 - 作业提交时间) / 作业实际运行时间 \",\"带权周转时间肯定是大于1的，带权周转时间与周转时间都是越小越好\",\"平均带权周转时间 = (各作业带权周转时间之和) / 作业数\",\"等待时间：指进程/作业处于等待处理机状态时间之和 \",\"对于进程来说，等待时间就是进程建立以后等待被服务的时间之和，在等待IO完成期间进程也是在被服务的，所以不计入等待时间\",\"对于作业来说，等待时间为：建立进程后的等待时间 + 作业在外存后备队列中等待的时间\",\"响应时间：用户提交请求到首次产生响应所用时间\",\"小结：\"]},\"139\":{\"h\":\"15、调度算法\",\"t\":[\"先来先服务算法(FCFS,First Come First Serve)\",\"算法规则：按照作业/进程到达的先后顺序进行服务\",\"用于作业/进程调度： \",\"作业调度：考虑哪个作业先到达后备队列\",\"进程调度：考虑哪个进程先达到就绪队列\",\"是否可抢占？非抢占式算法\",\"优缺点： \",\"优点：公平、算法实现简单\",\"缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利\",\"是否会导致饥饿：不会\",\"短作业优先算法(SJF，Shortest Job First)\",\"算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间\",\"算法规则：每次调度时选中最短的作业/进程优先得到服务(所谓最短，就是服务时间最短)\",\"用于作业/进程调度：可用于作业调度也可用于进程调度，用于进程调度时候称为\\\"短进程优先(SPF，Shortest Process First)\\\"\",\"是否可抢占？SJF和SPF都是非抢占式算法。但是也有抢占式的版本----最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)，每当有进程加入的时候，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列\",\"优缺点 \",\"优点：最短的平均等待时间、平均周转时间(SRNT)\",\"缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先\",\"是否会导致饥饿：会。如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生\\\"饥饿\\\"现象。如果一直得不到服务，就称为饿死\",\"高响应比优先(HRRN,Highest Response Ratio Next)\",\"算法思想：综合考虑作业/进程的等待时间和要求服务的时间\",\"算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比 = (等待时间 + 要求服务时间) / 要求服务时间\",\"用于作业/进程调度：可\",\"是否可抢占？非抢占式算法\",\"优缺点：综合考虑了等待时间和运行时间。等待时间相同时，要求服务时间短的优先(SJF优点)。要求服务时间相同时，等待时间长的邮箱(FCFS优点)。对于长作业来说，随着等待时间越来越长，其响应比也会越来越大，从而避免了长作业饥饿问题\",\"是否会导致饥饿：否\",\"上述算法一般适合用于早期的批处理系统\",\"时间片轮转算法(RR,Round - Robin)\",\"算法思想：公平的，轮流的为各个进程服务，让每一个进程在一定时间间隔内都可以得到响应\",\"算法规则：按照各个进程到达就绪队列的顺序，轮流的让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完毕，则剥夺处理机，将进程重新方法就绪队列队尾重新排队\",\"用于作业/进程调度：可用于进程调度\",\"是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片RR属于抢占式算法，由时钟装置发出时钟中断来通知CPU时间片已到\",\"优缺点： \",\"优点：公平；响应快，适用于分时操作系统\",\"缺点：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度\",\"是否会导致饥饿：不会\",\"补充关于时间片的大小 \",\"如果时间片太大，使得每个进程都可以在一个时间片内完成，则RR退化为FCFS调度算法，并且会增大进程的响应时间，因此时间片不能太大\",\"如果时间片太小，进程切换比较频繁，系统开销会增大\",\"优先级调度算法\",\"算法思想：随着分时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理的顺序\",\"算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程\",\"用于作业/进程调度：都可\",\"是否可抢占：抢占式和非抢占式都有。对于非抢占式只需要在进程主动放弃处理机时进程调度即可，对于抢占式还需要在就绪队列变化时，检查是否会发生抢占\",\"优缺点： \",\"优点：用优先级区分紧急程度、重要程度，适用于分时操作系统，可灵活地的调整对各种作业/进程的偏好程度\",\"缺点：若源源不断的有高优先级进程到来，则可能会导致饥饿\",\"是否会导致饥饿：会\",\"补充 \",\"根据优先级是否可以动态改变，可以将优先级分为静态优先级和动态优先级两种 \",\"采用动态优先级，什么时候调整？ \",\"如果进程在就绪队列中等待了很长时间，可以适当提升优先级\",\"如果进程占用处理机很长时间，可以适当降低其优先级\",\"如果一个进程频繁的进行I/O操作，可以适当提升其优先级\",\"如何合理的设置各类进程的优先级： \",\"系统进程优先级高于用于进程\",\"前台进程优先级高于后台进程\",\"操作系统更偏向I/O型进程(或称I/O繁忙型进程)，因为I/O设备可以和CPU并行工作。如果让I/O繁忙型进程优先运行，则I/O设备可以尽早投入使用\",\"多级反馈队列调度算法\",\"算法思想：对其他调度算法的折中权衡\",\"算法规则：\",\"1、设置多级就绪队列，各级队列优先级从高到低，时间片从小到大\",\"2、新进程到达时先进入第一级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还没有结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾\",\"3、只有第k级队列为空时，才会为K + 1级队头的进程分配时间片\",\"用于作业/进程调度：用于进程调度\",\"是否可抢占式：抢占式算法。在k级队列的进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾\",\"优缺点：上述算法优点的集合\",\"是否会导致饥饿：会，如果源源不断的有短进程到达，就会饥饿\",\"上面的三种更加适合于交互式系统\"]},\"140\":{\"h\":\"16、进程同步、进程互斥\",\"t\":[\"进程同步：\",\"同步也称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程为了完成某种任务，需要协调他们工作的次序。进程同步是为了结局进程异步的问题(进程异步是指：各并发执行的进程以各自独立的、不可预知的速度向前推进)。比如：管道通信中，写数据必须在读数据之前完成\",\"进程互斥\",\"临界资源：一个时间段内只允许一个进程使用的资源。比如摄像头，打印机、内存缓冲区等\",\"对于临界资源的访问，必须是互斥的进程。互斥，也称为间接制约关系\",\"进程互斥：当一个进程访问某临界资源的时候，另一个访问该临界资源的进程必须等待。等待当前访问临界资源的进程结束才可以访问\",\"对于临界资源的互斥访问可以分为四个部分\",\"1、进入区：负责检查是否可以进入临界区，如果可以进入，则设置正在访问临界资源的标志(上锁)，以阻止其他进程同时进入临界区\",\"2、临界区：访问临界资源的那段代码\",\"3、退出区：负责接触正在访问临界资源的标志(解锁)\",\"4、剩余区：做其他处理\",\"进程互斥需要遵循的原则：\",\"1、空闲让进。当临界区空闲的时候，可以允许一个请求进入临界区的进程立即进入临界区\",\"2、忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待\",\"3、有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)\",\"4、让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待\",\"小结：\"]},\"141\":{\"h\":\"17、进程互斥的软件实现方法\",\"t\":[\"单标志法\",\"算法思想：当前有两个进程都要访问临界资源，在一个进程访问完临界资源以后会把使用临界区的权限转交给另一个进程。即：每个进程访问临界资源的权限只能被另一个进程赋予\",\"turn表示当前允许进入临界区的进程号，也就是只有一个进程访问临界资源后，才会修改turn。这违背了空闲让进的原则，因为当P1进程想访问资源，需要P0进程先访问才行，而P0又不需要访问\",\"双标志先检查法\",\"算法思想：试着一个boolean类型的数组flag[],数组中的各个元素用来标志各进程想进入临界区的意愿，比如flag[0] = true，表示0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程进入临界区，如果没有就把自身的标志位置为true，之后开始访问临界区\",\"按照152637....的顺序执行，P0和P1将会同时访问临界区，违背了忙则等待的原则。产生的原因：进入区的检查和上锁两个处理不是一气呵成的，检查后，上锁前可能会发生进程切换\",\"双标志后检查法\",\"算法思想：是双标志先检查法的改良版本，先上锁后检查\",\"按照152637顺序执行，P0和P1都无法进入临界区\",\"双标志发虽然解决了忙则等待的问题，但是又违背了空闲让进以及有限等待原则，因此会产生饥饿现象\",\"Peterson算法\",\"算法思想：如果两个进程都想着进入临界区，可以让进程尝试让对方先使用临界区\",\"该算法解决了进程互斥问题，遵循了空闲让进，忙则等待，有限等待三个原则，但是没有遵循让权等待\"]},\"142\":{\"h\":\"18、进程互斥的硬件实现方法\",\"t\":[\"中断屏蔽方法\",\"利用\\\"开/关中断指令\\\"实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也就不会发生两个同时访问临界区的情况)\",\"优点：简单、高效\",\"缺点：不适用在多处理机，因为开关中断只是相对一个处理机来说的；只适用于操作系统内核进程，不适用于用户进程(开关中断权限比较大，需要在内核态)\",\"TestAndSet指令\",\"简称TS或TSL指令，指令是用硬件实现的\",\"相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作\",\"优点：实现简单，适用于多处理机环境\",\"缺点：不满足让权等待\",\"Swap指令\",\"也称为Exchange指令，或简称XCHG指令，也是用硬件实现，执行过程中不允许中断，只能一气呵成\",\"优点：实现简单，适用于多处理机环境\",\"缺点：不满足让权等待\",\"Swap指令和Swap指令的区别\",\"在实现上，swap需要两个参数，不需要返回值，而test_and_set则是需要借助一个共享变量来实现互斥\",\"进程互斥的实现方式：四种软件实现方式 + 三种硬件实现方式\"]},\"143\":{\"h\":\"19、信号量机制\",\"t\":[\"用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步\",\"信号量就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示当前系统中某种资源的数量。比如：系统中打印机的数量为1，可以设置一个初值为1的信号量\",\"原语：是一段特殊的程序段，使用开关中断实现，执行只能一气呵成，不可中断\",\"一对原语：wait(S)原语和signal(S)原语，这就是两个函数，信号量S就是传入的参数\",\"wait、signal原语简称为P、V操作\",\"整型信号量 \",\"用一个整数型变量作为信号量，用来表示系统中某种资源的数量。对信号量的操作只有三种：初始化、P操作、V操作\",\"问题：不满足让权等待\",\"记录型信号量 \",\"是为了解决让权等待问题，用记录型数据结构表示信号量\",\"当资源已经分配完毕，进程会调用wait里面的block原语进行自我阻塞，由运行态到阻塞态，主动放弃处理机，因此该机制遵循了让权等待\",\"小结：\"]},\"144\":{\"h\":\"20、用信号量机制实现进程互斥、同步、前驱关系\",\"t\":[\"信号量机制实现进程互斥\",\"设置互斥信号量，初值为1\",\"在临界区之前执行P，减少信号量的数目，并且小于0的时候需要阻塞\",\"在临界区之后执行V，释放资源\",\"对不同的临界资源需要设置不同的互斥信号量，并且P,V必须成对的出现\",\"信号量机制实现进程同步\",\"进程同步：即必须保证\\\"一前一后\\\"执行两个操作\",\"设置同步信号量S，初始值为0\",\"在前操作之后执行V(S)\",\"在后操作之前执行P(S)\",\"信号量机制实现前驱关系\",\"步骤：\",\"要为每一对前驱关系各设置一个同步变量\",\"在前操作之后对相应的同步变量执行V操作\",\"在后操作之前对相应的同步变量执行P操作\",\"小结：\"]},\"145\":{\"h\":\"21、管程\",\"t\":[\"为什么要引入管程 \",\"信号量机制存在的问题：编写程序困难、易出错\",\"管程的定义和基本特征 \",\"管程作用：实现进程同步与互斥\",\"管程的组成：(类似类) \",\"共享的数据结构\",\"对数据结构操作的一组过程(函数)\",\"对共享数据设置初始值\",\"管程有一个名字\",\"管程的基本特征 \",\"管程中定义的数据结构，只能被管程中定义的过程访问\",\"每次仅允许一个进程在管程内执行某个内部过程\"]},\"146\":{\"h\":\"操作系统中\"},\"147\":{\"h\":\"1、死锁的概念\",\"t\":[\"什么是死锁\",\"在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象\",\"发生死锁至少有两个或两个以上的进程同时发生死锁，发生死锁后，若无外力干涉，这些进程都无法向前推进，发生死锁的进程一定是在阻塞态\",\"饥饿的概念： \",\"由于长期得不到想要的资源，某进程无法向前推进的现象，比如SPF如果有源源不断的短进程到来，则长进程一直无法获得处理机\",\"死循环的概念 \",\"某进程在执行的过程中一直跳不出某个循环的现象，有时是因为程序bug导致的，有时是程序员故意为之\",\"死锁、饥饿、死循环的异同 \",\"异如上\",\"同：都是进程无法顺利向前推进的现象(故意设计的死循环除外)\",\"死锁产生的条件\",\"1、互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁\",\"2、不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放\",\"3、请求和保持条件：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放\",\"4、循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求\",\"注意：发生死锁的时候一定有循环等待，但是发生循环等待的时候未必死锁，因为如果同类资源的数量大于1，当该类资源又进程释放的时候，死锁结束。如果每类资源只有1个，那就是充分必要条件了\",\"什么时候会发生死锁\",\"1、对系统资源的竞争。对不可剥夺资源的竞争可能会引起死锁，对可剥夺的资源不会产生\",\"2、进程推进顺序非法。请求和释放资源的顺序不当，比如，并发执行的进程P1、P2分别申请并占有了资源R1,R2,但是之后P1进程又申请资源R2，P2进程申请资源R1，这样会导致死锁\",\"3、信号量的使用不当。比如，实现互斥的P操作在实现同步的P操作之前\",\"死锁的处理策略\",\"1、预防死锁：破坏死锁产生的四个必要条件中的一个或几个\",\"2、避免死锁：用某种方法阻止系统进入不安全的状态\",\"3、死锁的检测和解除：允许死锁的产生，不过操作系统会负责检测出死锁的产生，然后采取某种措施解除死锁\"]},\"148\":{\"h\":\"2、死锁的处理策略----预防死锁\",\"t\":[\"破坏互斥条件\",\"把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如使用SPOOLing技术。\",\"缺点：并不是所有的资源都可以改造成可共享使用资源，并且为了系统安全，在很多地方还必须保护这种互斥性，无法破坏\",\"破坏不剥夺条件\",\"方案一：当某个进程请求的资源得不到满足的时候，它必须立即释放保持的所有资源，待以后需要的时候再重新申请一下\",\"方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺，这种方式需要考虑进程的优先级\",\"缺点： \",\"1、实现起来比较复杂\",\"2、释放已经获得的资源可能造成前一阶段工作的失效，因此一般只适用于易保存和恢复状态的资源，如CPU\",\"3、反复的申请和释放资源会增加系统的开销，降低系统吞吐量\",\"4、如果采用方案一，如果一直重复这样会导致饥饿\",\"破坏请求和保持条件\",\"采用静态分配方法：进程在运行前一次申请完它所需要的全部资源\",\"缺点：会造成严重的资源浪费，资源利用率低，也有可能导致饥饿(比如有三个进程A,B,C，其中A，B分别使用资源1,2，进程C需要用到A资源1和2，如果有源源不断的进程使用1或者2，则C一直不执行 )\",\"破坏循环等待条件\",\"采用顺序资源分配法：首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，编号相同资源一次申请完\",\"原理分析：一个进程只有已经占有小编号的资源时，才有资格申请更大编号的资源，不可以大编号资源的进程逆向申请小编号的资源，这样就不会产生循环等待\",\"缺点： \",\"1、不方便增加新设备，因为可能需要重新分配所有的编号\",\"2、进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费\",\"3、必须按规定次序申请资源，用户编程麻烦\"]},\"149\":{\"h\":\"3、死锁的处理策略----避免死锁\",\"t\":[\"什么是安全序列 \",\"所谓安全序列，就是指系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找到一个安全序列，系统就是安全状态。当然安全序列可能有多个\",\"如果分配资源后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利执行下去。如果有进程提前归还了一些资源，系统还是有可能重新回到安全状态\",\"如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必发生了死锁，但发生死锁的时候就一定是处于不安全状态)\",\"可以在资源分配之前预先判断这次分配会不会导致系统进入不安全状态，以此决定是否答应资源分配请求，这是银行家算法核心思想\"]},\"150\":{\"h\":\"4、死锁的处理策略----检测和解除\",\"t\":[\"为了能对系统死锁进行检测需要满足的条件\",\"1、用某种数据结构来保存资源的请求和分配信息\",\"上图中绿色表示已经分配的资源，蓝色表示正在请求的资源。按照上述过程，最终能够消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁。比如P2中申请一个R1，但是此时R1已经分配出去三个了，所以P2进入阻塞的状态，要等P1释放资源\",\"解除死锁\",\"用死锁检测算法化简资源分配图之后，还连着的边的那些进程就是死锁进程，解除死锁的主要方法：\",\"1、资源剥夺法：挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程\",\"2、撤销进程法(或终止进程法)：强制撤销部分、甚至全部死锁的进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但代价有点大，撤销进程之前的运行都芜湖了\",\"3、进程回退法：让一个或多个死锁进程回退到避免死锁的地步。这要求系统记录进程的历史信息，设置还原点\"]},\"151\":{\"h\":\"5、内存的基础知识\",\"t\":[\"什么是内存？有何作用？\",\"内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理\",\"如何区分各个程序的数据在内存的什么地方？ \",\"给内存的存储单元编地址 \",\"内存地址从0开始，每个单元对应一个存储单元(相当于宾馆的房间)\",\"如果计算机按字节编址，则每个存储单元大小为1字节，即1B，即8个二进制位\",\"如果字长为16位的计算机按字编址，则每个存储单元大小为1个字，每个字的大小为16个二进制位(取决于计算机的字长)\",\"几个常用的数量单位\",\"2^10 = 1K (千)\",\"2^20 = 1M (兆，百万)\",\"2^30 = 1G (亿，千兆)\",\"一台手机有4GB内存，是什么意思？ \",\"指该手机内存可以存放4 * 2^30 个字节，如果按照字节编址的话，也就是有4 * 2^30 = 2^32 个存储单元(个房间)\",\"需要 2^32个地址才能一一标识，也就是地址需要用32个二进制位来表示\",\"进程的运行原理 --- 指令\",\"我们写的代码最终被翻译成CPU能够识别的指令，这些指令会告诉CPU去内存的哪个地址存/取数据，这个数据应该做什么样的处理。在编译生成的指令中一般使用的是逻辑地址(相对地址)\",\"逻辑地址(相对地址) VS 物理地址(绝对地址) \",\"逻辑地址就是相对初始位置的距离，在内存中实际存放的位置 = 起始位置 + 逻辑地址\",\"物理地址即绝对地址，就是数据存放在内存中的实际位置\",\"从写程序到程序运行\",\"装入的三种方式(逻辑地址 -> 物理地址的转换)\",\"1、绝对装入：在编译的时候就知道程序存放在内存的哪个位置，编译程序产生绝对地址的目标代码(目标模块中的指令就是内存中的绝对地址)，装入程序按照装入模块中的地址，将程序和数据装入内存。\",\"绝对装入只适用于单道程序的环境(因为地址已经写死，如果多道程序的话会冲突)。程序中使用的绝对地址，可以在编译或者汇编的时候给出，也可由程序员直接赋予，但通常都是编译或汇编时在转换为绝对地址\",\"2、静态重定位：又称可重定位装入，编译和链接之后指令中的地址都是从0开始的逻辑地址，根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变换为物理地址(地址变换是在装入的时候一次性完成的)\",\"特点：一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存空间，就不能装入该作业，作业一旦进入内存之后，在运行期间不能再移动，也不能再申请内存空间\",\"3、动态重定位(现在使用)：又称为动态运行时装入。编译和链接之后装入模块的地址都是从0开始，装入程序将装入模块装入到内存之后也不会立即将逻辑地址变换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入到内存中的地址依旧是逻辑地址，这种方式需要一个重定位寄存器(存放起始地址)的支持\",\"特点：动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区，在程序运行前只需要装入它的部分代码就可以运行，在程序运行期间，可以动态申请内存分配\",\"链接的三种方式\",\"1、静态链接：在程序运行之前，将各个目标模块连接到装入模块\",\"2、装入时动态链接：将各个目标模块装入内存时，边装入边链接\",\"3、运行时动态链接：在程序执行中需要改目标模块时，才对他进行连接\"]},\"152\":{\"h\":\"6、内存管理的概念\",\"t\":[\"操作系统负责内存空间的分配和回收\",\"操作系统需要提供某种技术从逻辑上对内存空间进程扩充-----覆盖技术、交换技术、虚拟存储技术\",\"操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换----三种装入方式\",\"操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行互不干扰 \",\"方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址的时候，CPU检查是否越界\",\"方法二：采用**重定位寄存器(又称为基址寄存器)和界地址寄存器(又称限长寄存器)**进行越界检查。\"]},\"153\":{\"h\":\"7、内存空间的扩充-----覆盖与交换\",\"t\":[\"覆盖技术：用来解决程序大小超过物理内存总和的问题\",\"思想：将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存\",\"内存中分为一个固定区和若干个覆盖区\",\"需要常驻内存的段放入固定区，调入后就不再调出(除非运行结束)\",\"不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存\",\"特点：必须由程序员声明覆盖结构，操作系统完成自动覆盖，缺点：对用户不透明，增加了用户编程的负担，现在不使用了\",\"交换技术\",\"设计思想：内存空间紧张的时候，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)。就是将某些进程挂起。中级调度：就是决定将哪个处于挂起状态的进程重新调入内存。(PCB会常驻内存，不会被换出内存)\",\"应该在外存(磁盘)的什么位置保存被换出的进程？ \",\"具有对换功能的操作系统中，通常将磁盘空间分为文件区和对换区两部分。文件区主要存放文件，主要追求存储空间的利用率，因此文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区，因为需要对换的速度，所以对换区空间的管理主要追求换入换出速度，通常采用连续分配方式。总之对换区的I/O速度比文件区的更快\",\"什么时候应该交换？ \",\"交换通常发生在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程，如果缺页率明显下降，就可以暂停换出\",\"应该换出哪些进程？ \",\"可优先换出阻塞进程；可换出低优先级的进程；为了防止低优先级进程发生饥饿，有的系统还会考虑进程在内存中的驻留时间\"]},\"154\":{\"h\":\"8、内存空间的分配-----连续分配管理方式\",\"t\":[\"连续分配：就是为用户进程分配的必须是一个连续的内存空间\",\"单一连续分配方式\",\"内存被分为系统区和用户区，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据，用户区用于存放用户进程的相关数据\",\"内存中只能有一道用户程序，用户程序独占整个用户区空间\",\"特点： \",\"优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护\",\"缺点：只能用于单用户、单任务的操作系统中；有内部碎片(分配给某进程的内存区域中，如果有些部分没有用上，就是内部碎片)；存储器利用率极低\",\"固定分区分配\",\"将用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的多道程序的内存管理方式。\",\"固定分区分配分为两种：\",\"分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合\",\"分区大小不等：增加了灵活性，可以满足不同大小的进程的需求。根据常在系统中运行的作业大小情况进行划分(比如：划分多个小分区、适量中等分区、少量大分区)\",\"操作系统如何记录各个分区空闲或者分配的情况？\",\"操作系统需要建立一个数据结构---分区说明表，来实现各个分区的分配和回收。每个表项对应一个分区，包括分区号、对应分区的大小、起始地址、状态(是否已分配)\",\"当用户进程要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个满足条件的分区，然后修改分区状态\",\"特点：\",\"优点：实现简单；无外部碎片\",\"缺点： \",\"1、当用户程序太大时，可能所有的分区都不能满足，此时不得不采取覆盖技术来解决，但是这回降低系统性能\",\"2、会产生内部碎片，内存利用率低\",\"动态分区分配(可变分区分配)\",\"原理：在线程装入内存时，根据进程的大小动态建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的\",\"系统要用什么样的数据结构记录内存的使用情况？\",\"空闲分区表：每个空闲分区对应一个表项。表项中包含分区、分区信息、分区起始地址、状态等信息\",\"空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。\",\"当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？\",\"按照动态分区分配算法\",\"如何进行分区的分配和回收操作？\",\"如何进行分配：假设采用的数据结构是空闲分区表，则修改对应分区号，以及剩余的分区大小和起始地址等信息\",\"如何进行回收： \",\"情况一：回收区的前或后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个\",\"情况二：回收区的前、后各有一个相邻的空闲分区，需要将一整块的空闲分区合并\",\"情况三：回收区的前、后都没有相邻的空闲分区，需要新增一个空闲分区\",\"注意：各表项的顺序不一定按照地址递增的顺序排序，具体的排序方式需要依据动态分配算法来确定\",\"特点：没有内部碎片，但是有外部碎片\",\"内部碎片：分配给某进程的内存区域中，如果有些部分没有用上\",\"外部碎片：内存中的某些空闲分区由于太小难以利用\",\"如果内存中空闲空间的总和本来可以满足某进程的要求，但由于该进程需要连续的内存空间，因此这些碎片不能满足进程的需求，可以通过紧凑(拼凑) 的技术来解决(把已占的内存挪位)\"]},\"155\":{\"h\":\"9、动态分区分配算法\",\"t\":[\"首次适应算法\",\"算法思想：每次从低地址开始查找，找到第一个能满足大小的空闲分区\",\"实现：**空闲分区以地址递增的次序排列。**每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：导致低地址出现很多小的难以利用的空闲区\",\"最佳适应算法(先用小的)\",\"算法思想：优先使用更小的空闲区，尽可能更多的留下大片的空闲区\",\"实现：空闲分区按照容量递增次序链接。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：每次都选最小的分区，会留下越来越多的又小又难利用的内存块，会产生很多的外部碎片\",\"最坏适应算法(先用大的)\",\"算法思想：优先使用最大的连续空闲区，这样留下的空闲区就不会太小，更方便使用\",\"实现：空闲分区按照容量递减的次序链接。每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能够满足要求的第一个空闲分区。\",\"缺点：每次都选最大的分区，会导致大的空闲区迅速被用完，如果还有大进程到来，就没有内存分区可以用了\",\"邻近适应算法\",\"算法思想：每次查找从上次使用地址的下一个开始\",\"实现：空闲分区以地址递增的次序排列(第一次排，后面不需要再排)，每次分配内存时从上次查找结束的位置开始查找空闲分区，找到大小能够满足要求的第一个空闲分区\",\"缺点：每个空闲分区都用相同的概率被使用，也就导致高地址的大分区更可能被使用。划分为小分区，最后也就导致无大分区可用\",\"image-20220508143045462\"]},\"156\":{\"h\":\"10、基本分页存储管理的基本概念\",\"t\":[\"内存空间非连续分配管理方式\",\"基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分为一个个小部分\",\"内存拆分为一个个大小相等的分区,每个分区就是一个页框(或称为页帧)。每个页框有一个编号，就是页框号，页框号从0开始\",\"进程根据页框大小拆分为一个个区域，称为页(或页面)。每个页面也有一个编号，即页号，页号也是从0开始(进程的最后一个页面可能没有一个页框那么大，页框不能太大，否则会产生过大的内部碎片)\",\"页面与页框有一一对应关系，页面不必连续存放，可以放到不相邻的页框中\",\"逻辑地址如何转换为物理地址 \",\"1、算出逻辑地址对应的页号：页号 = 逻辑地址 / 页面长度\",\"2、页号在内存中的起始地址：操作系统用某种数据结构记录\",\"3、逻辑地址在页面的偏移量：页内偏移量 = 逻辑地址 % 页面长度\",\"4、物理地址= 起始地址 + 偏移量\",\"结论：如果每个页面大小是2^k,用二进制表示逻辑地址，则末尾K位标识页内偏移量，其余部分就是页号\",\"页表：为了能够知道进程的每一个页面在内存中的存放位置\",\"1、一个进程对应一个页表\",\"2、页表由页号和块号(页框号)组成\",\"页表项：页表中的一条记录\"]},\"157\":{\"h\":\"11、基地址变换机构\",\"t\":[\"基地址变换机构可以借助页表将逻辑地址变换为物理地址\",\"系统中设置一个页表寄存器，存放页表的起始地址(页表的开始地址)和页表长度(页表项的个数)，进程未执行时，页表起始地址和长度放在PCB在，当进程被调度时，才会放入页表寄存器\",\"08589340b276ee29a357f080ed4012b\",\"快表(联想寄存器)：访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项。\",\"541a75aa1efce984b24df67aea29aa4\"]},\"158\":{\"h\":\"12、两级页表\",\"t\":[\"单级页表的问题\",\"页表必须连续存放，当页表很大的时候，需要占用很多个连续的页框\",\"没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面(后面讲解)\",\"两级页表的原理---- 解决上面第一个问题\",\"为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶级页表(套娃)\",\"将页表继续根据页框大小进行拆分\",\"f7cd987ba102ecf12110ee6a4416034\",\"根据拆分的很多个页表建立页目录表\",\"3361d94ab3623353f7997137296d8eb\",\"案例\",\"484c54717461b527d7e199d942448f1\",\"注意：\",\"各级页表的大小不能超过一个面\",\"两级页表访问内存的次数 \",\"1、第一次：访问页目录表\",\"2、第二次：访问二级页表\",\"3、第三次：访问目标单元\",\"小结：\"]},\"159\":{\"h\":\"13、基本分段存储管理方式\",\"t\":[\"与分页的最大区别：离散分配时所分配地址空间的基本单位不同\",\"分段：程序按照自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编程\",\"内存分配规则：**以段为单位进行分配，每个段在内存中占据连续空间，**但各段之间可以不相邻\",\"f6fbed833a9af8b9e4df67b0c17c3fc\",\"分段系统的逻辑地址结构由**段号(段名)和段内地址(段内偏移量)**所组成\",\"段号的位数决定了每个进程最多可以分几个段\",\"段内地址位数决定了每个段的最大长度是多少\",\"段表：能够从物理内存中找到各个逻辑段的存放位置\",\"31fd5ca9ccd980db93b6088ea0e1d58\",\"每个段对应一个段表项，其中记录了该段在内存中的起始位置(基址)和段的长度\",\"各个段表项的长度是相同的，段号是可以隐含的，不占存储空间\",\"段表寄存器：在PCB中存放段表始址和段表长度\",\"19fda1f5ff23a13b9e546eba14effc6\",\"分页与分段的区别\",\"3dd975466ed41bb250ad2f71beec3fb\",\"分段比分页相比更容易实现信息的共享和保护\",\"实现共享：只需要让各个进程的段表项执行同一个段即可实现共享。不能被修改的代码称为纯代码或可重入代码，这样的代码可实现共享。可修改的代码不能实现共享(比如：有一个代码段中有很多变量，各进程并发同时访问可能造成数据不一致)。\",\"实现保护与实现共享的原因相似：允许访问的部分应该隔离出来可以访问\",\"小结：\"]},\"160\":{\"h\":\"14、段页式管理方式\",\"t\":[\"分页和分段的优缺点\",\"优点\",\"缺点\",\"分页管理\",\"内存空间利用率高，不会产生外部碎片，只会产生少量的页内碎片\",\"不方便实现信息的共享和保护\",\"分段管理\",\"很方便实现信息的共享和保护\",\"如果段过大，为其分配很大的连续空间会很不方便，会产生外部碎片(产生原因与动态分区分配相似)\",\"段页式管理 = 分段 + 分页\",\"将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同的页框，进程前将各页面装入各内存块中\",\"9b68045565ab516f5f3e723c7b11f0c\",\"段页式系统的逻辑地址结构由段号、页号、页内地址组成\",\"image-20220513152328116\",\"分段对用户是可见的，程序员编程时需要显示的给出段号、段内地址。而将各段分页是对用户不可见的。系统会根据段内地址自动划分页号和页内偏移地址\",\"段表、页表\",\"每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表的起始地址)组成。每个段表项的长度相等，段号是隐含的\",\"每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含。\",\"image-20220513153925493\",\"逻辑地址转物理地址\",\"image-20220513154609606\",\"也可以引入快表机构\",\"image-20220513193835377\"]},\"161\":{\"h\":\"15、虚拟内存的概念\",\"t\":[\"也是为了进行内存空间的扩充\",\"传统存储管理方式的问题\",\"作业很大时，不能全部装入内存，导致大作业无法运行\",\"当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降\",\"一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源\",\"局部性原理\",\"时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久后该数据很可能再次被访问(因为程序中存在着大量的循环)\",\"空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序的在内存中存放)\",\"高速缓冲技术\",\"将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速的存储器中\",\"虚拟内存\",\"在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。\",\"在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行\",\"若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存\",\"虚拟内存实际的物理内存大小没有变，只是在逻辑上进行了扩充\",\"虚拟内存的三个主要特征\",\"多次性：无需在作业运行时一次性全部装入内存，而是被允许分成多次调入内存\",\"对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出\",\"虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量\",\"如何实现虚拟内存技术\",\"虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配的方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上\",\"image-20220515155525114\",\"image-20220515155622275\"]},\"162\":{\"h\":\"16、请求分页存储管理\",\"t\":[\"请求分页存储管理与基本分页存储管理的主要区别：\",\"在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行\",\"若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存\",\"请求分页管理的方式\",\"页表机制\",\"缺页中断机构\",\"地址变换机构\",\"页表机制\",\"image-20220515160709826\",\"缺页中断机构\",\"在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断\",\"此时缺页的进程阻塞，放入阻塞队列，调页完成之后再将其唤醒，放回就绪队列\",\"如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项\",\"如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存\",\"​ 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。一条指令在执行期间，可能产生多次缺页中断(比如copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)\",\"地址变换机构\",\"image-20220515204309592\",\"image-20220515204850109\"]},\"163\":{\"h\":\"17、页面置换算法\",\"t\":[\"算法种类：最佳置换算法(OPT)，先进先出置换算法(FIFO)，最近最久未使用置换算法(LRU)，时钟置换算法(CLOCK)，改进型的时钟置换算法\",\"页面的换入、换出需要磁盘的I/O，会有较大的开销，因此页面置换算法应该追求更少的缺页率。\",\"最佳置换算法(OPT)\",\"每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。追求的是最低的缺页率，但在实际过程中，只有在进程执行的过程中才能知道接下来会访问的是哪个页面，操作系统无法提前预判页面访问序列。因此最佳置换算法是无法实现的\",\"image-20220521130218677\",\"上图缺页中断发生了9次，页面置换发生了6次(注意：缺页时未必发生页面置换，若还有可用的空闲内存块，就不用进行页面置换)\",\"缺页率 = 9 / 20 = 45%\",\"先进先出置换算法(FIFO)\",\"每次选择淘汰的页面是最早进入内存的页面\",\"实现方法：将调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。\",\"先进入的页面在之后也有可能经常的访问到，所以算法性能较差\",\"image-20220521131041972\",\"缺页9次。当分配四个内存块的时候，缺页发生10次，分配三个内存块时，缺页发生9次\",\"Belady异常---当为进程分配的物理块数增大时，缺页次数不减反增的异常现象\",\"最近最久未使用置换算法(LRU)\",\"每次淘汰的页面是最近最久未使用的页面\",\"页表项中的访问字段记录页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值的最大的，即最近最久未使用的页面\",\"image-20220521132954826\",\"找最晚出现的淘汰掉\",\"算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大\",\"时钟置换算法(CLOCK)\",\"时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未使用算法(NRU)\",\"简单的CLOCK算法实现方法：为每一个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描所有页面都是1，则将这些页面的访问依次置为0，再进行第二轮扫描(第二轮扫描一定会有访问位为0的页面)\",\"image-20220521133823507\",\"改进型时钟置换算法思想：简单的时钟置换算法仅仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。因此，在其他条件都相同时，应该优先淘汰没有修改过的页面，避免I/O操作。修改为=0，表示页面没有被修改过；修改为=1，表示页面被修改过，用**(访问位，修改位)**的形式表示各页面的状态，比如(1,1)表示一个页面近期被访问过，且被修改过。\",\"算法规则：将所有可能被置换的页面排成一个循环队列 \",\"第一轮：从当前位置开始扫描到第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近没有访问且没有修改过的页面)\",\"第二轮：若第一轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (最近没访问，但修改过的页面)\",\"第三轮：若第二轮扫描失败，则重新扫描，查找第一个(0,0)的帧用于替换。本轮扫描不修改任何标志位(最近访问过，但没有修改过的页面)\",\"第四轮：若第三轮扫描失败，则重新扫描，查找第一个(0,1)的帧用于替换(最近访问过，且修改过的页面)\",\"由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，所有淘汰一个页面最多进行四轮扫描\",\"image-20220521141844658\"]},\"164\":{\"h\":\"18、页面分配策略\",\"t\":[\"驻留集：指请求分页存储管理中给进程分配的物理块的集合，采用虚拟内存技术的系统中，驻留集大小一般小于进程的总大小\",\"驻留集太小，会导致缺页频繁，系统要花大量的时间来处理分页，实际用于进程推进的时间很少\",\"驻留集太大，又会导致多道程序并发度下降，资源利用率低\",\"固定分配：操作系统为每一个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变\",\"可变分配：先为进程分配一定数目的物理块，在进程运行期间，可以根据情况做出适当的增加或减少。即，驻留集大小可变\",\"局部置换：发生缺页时只能选进程自己的物理块进行置换\",\"全局置换：可将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程\",\"局部置换\",\"全局置换\",\"固定分配\",\"√\",\"---\",\"可变分配\",\"√\",\"√\",\"image-20220521200544645\",\"何时调入页面\",\"1、预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更加高效。但如果提前调入的页面大多数都没被访问过，则又是低效的。故这种策略主要用于进程首次调入，由程序员指出应该先调入哪些部分(运行前调入)\",\"2、请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由于这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大(运行时调入)\",\"从何处调入页面\",\"image-20220521202834105\",\"抖动(颠簸)现象\",\"刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)\",\"工作集：指在某段时间间隔里，进程实际访问页面的集合\",\"驻留集的大小不能小于工作集的大小，否则进程运行过程中将频繁缺页\",\"image-20220521203500688\"]},\"165\":{\"h\":\"操作系统下\"},\"166\":{\"h\":\"1、初识文件管理\",\"t\":[\"文件内部的数据组织形式\",\"image-20220521220755154\",\"文件组织形式\",\"image-20220521220941143\",\"操作系统向上提供的功能\",\"image-20220521221245106\",\"可以使用几个基本操作完成更加复杂的操作，比如：复制文件：先创建一个新的空文件夹，再把源文件读入内存，再将内存中的数据写入到新文件中\",\"文件如何存放在外存？\",\"image-20220521221810990\",\"其他需要操作系统实现的文件管理功能\",\"文件共享：使多个用户可以共享使用一个文件\",\"文件保护：如何保证不同的用户对文件由不同的操作权限\"]},\"167\":{\"h\":\"2、文件的逻辑结构\",\"t\":[\"文件逻辑结构：指在用户看来，文件内部的数据应该是如何组织起来的\",\"文件的物理结构：在操作系统看来，文件的数据是如何存放在外存中的\",\"image-20220522125526046\",\"无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。比如：.txt文件\",\"有结构文件：由一组相似的记录组成，又称为“记录式文件”。每条记录又由若干个数据项组成。如\",\"image-20220522125936141\",\"根据各条记录的长度(占用的存储空间)是否相等，又可以分为定长记录和可变长记录\",\"定长记录\",\"image-20220522131645588\",\"可变长记录\",\"image-20220522131805969\",\"顺序文件\",\"文件中的记录一个接一个的顺序排列(逻辑上)，记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储\",\"image-20220522132423543\",\"已经知道文件的起始地址，能否找到第i个记录对应的地址即能否实现随机存储，能否根据关键字实现随机查找？\",\"image-20220522134405761\",\"索引文件\",\"解决的问题：对于可变长记录文件，要找到第i个记录，必须先顺序查找第i - 1个记录。\",\"image-20220522135220091\",\"索引顺序文件\",\"解决问题：每个记录对应一个索引表项，因此索引表可能会很大\",\"image-20220522141420657\",\"文件检索效率\",\"image-20220522142220989\",\"多级索引顺序文件\",\"image-20220522142404913\",\"image-20220522142638847\"]},\"168\":{\"h\":\"3、文件目录\",\"t\":[\"image-20220522143959739\",\"文件控制块\",\"image-20220522144708324\",\"image-20220522144900273\",\"需要对目录进行哪些操作？\",\"搜索：当用户需要使用一个文件的时候，系统要根据文件名搜索目录，找到该文件对应的目录项\",\"创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项\",\"删除文件：当删除一个文件时，需要在目录中删除相应的目录项\",\"显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应的属性\",\"修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项\",\"目录结构----单级目录结构\",\"整个系统只建立一张目录表，每个文件占一个目录项\",\"image-20220522202312578\",\"目录结构---两级目录结构\",\"早期的多用户操作系统，采用两级目录结构。分为主文件目录(MFD)和用户文件目录(UFD)\",\"image-20220522203520109\",\"目录结构---多级目录结构(又称树形目录结构)\",\"image-20220522203842838\",\"image-20220522204512602\",\"目录结构---无环图目录结构\",\"解决的问题：树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。\",\"image-20220522213646590\",\"索引结点(FCB的改进)\",\"image-20220522213950345\",\"image-20220522214100918\",\"image-20220522214148310\"]},\"169\":{\"h\":\"4、文件的物理结构\",\"t\":[\"类似内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”，磁盘块的大小与内存块、页面的大小相同\",\"内存与磁盘之间的数据交换(即读/写操作、磁盘I/O)都是以块为单位进行的，即每次读入一块，或每次写出一块\",\"image-20220524133535599\",\"文件分配方式----连续分配\",\"连续分配方式要求每个文件在磁盘上占有一组连续的块\",\"优点：支持顺序访问和直接访问(即随机访问)；连续分配的文件在顺序访问时速度最快\",\"image-20220524134337470\",\"image-20220524134541056\",\"缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片\",\" ![image-20220524142132631](https://picture2-1310712259.cos.ap-nanjing.myqcloud.com/img/image-20220524142132631.png) \",\"文件分配方式---链接分配\",\"链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种\",\"隐式链接\",\"image-20220529212115224\",\"image-20220529212212817\",\"隐式链接：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块指针\",\"优点：方便文件拓展，不会有碎片问题，外存利用率高\",\"缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。\",\"显示链接\",\"image-20220529212901703\",\"image-20220529213416885\",\"显示链接---把用于链接文件各个物理块的指针显示的存放在一张表中，即文件分配表(FAT)。一个磁盘只会建立一张文件分配表，开机时文件分配表放入内存，并常驻内存。\",\"优点：方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问，相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高\",\"缺点：文件分配表需要占用一定的内存\",\"索引分配\",\"image-20220529214611813\",\"如何实现文件的逻辑块号到物理块号的转换？\",\"image-20220529215048681\",\"若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放256个索引项，如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决？\",\"①链接方案\",\"②多层索引\",\"③混合索引\",\"链接方案\",\"image-20220529222421721\",\"多层索引\",\"image-20220530143548528\",\"采用k层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要k + 1次读磁盘操作\",\"混合索引\",\"image-20220530144020397\"]},\"170\":{\"h\":\"5、文件存储空间管理\",\"t\":[\"存储空间的划分与初始化\",\"image-20220530144632343\",\"存储空间管理---空闲表法\",\"适用于连续分配方式\",\"image-20220530145112083\",\"存储空间管理---空闲链表法\",\"image-20220530145400964\",\"空闲盘块链\",\"image-20220530145536142\",\"空闲盘区链\",\"image-20220530145757007\",\"存储空间管理---位视图法\",\"image-20220530193310886\",\"image-20220530193511600\",\"连续分配、离散分配都适用\",\"存储空间管理---成组链接法\",\"image-20220530193750402\",\"image-20220530194728231\",\"如何进行空闲块的分配？\",\"比如：需要100个空闲块\",\"①检查第一个分组的块数是否足够。100 = 100，足够。\",\"②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中\",\"image-20220530195251537\",\"image-20220530195308743\",\"如何回收？\",\"假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组\",\"image-20220530195708965\",\"image-20220530195918540\"]},\"171\":{\"h\":\"6、文件的基本操作\",\"t\":[\"创建文件\",\"image-20220530201101036\",\"删除文件\",\"image-20220530201342594\",\"打开文件\",\"image-20220530201818071\",\"打开文件\",\"image-20220530202619445\",\"关闭文件\",\"image-20220530202718681\",\"读文件\",\"image-20220530204655334\",\"写文件\",\"image-20220530204953730\",\"image-20220530205021424\"]},\"172\":{\"h\":\"7、文件共享\",\"t\":[\"文件共享是操作系统为用户提供文件共享功能，可以让多个用户共享的适用同一个文件，多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件数据，其他用户也可以看到文件数据的变化\",\"基于索引节点的共享方式(硬链接)\",\"image-20220530205956876\",\"基于符号链的共享方式(软链接)\",\"image-20220530210148637\",\"image-20220530210336394\",\"image-20220530210456044\"]},\"173\":{\"h\":\"8、文件保护\",\"t\":[\"口令保护\",\"image-20220530210706405\",\"加密保护\",\"image-20220530210923203\",\"每五位就与01001进行异或操作\",\"优点：保密性强，不需要再系统中存储“密码”\",\"缺点：编码/译码(加密/解密)要花费一定时间\",\"访问控制\",\"image-20220530212222775\",\"精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。比如：分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组\",\"当用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限\",\"image-20220530212539209\",\"image-20220530212817688\"]},\"174\":{\"h\":\"9、文件系统的层次结构\",\"t\":[\"image-20220530213756966\",\"image-20220530214006044\"]},\"175\":{\"h\":\"10、磁盘的结构\",\"t\":[\"磁盘、磁道、扇区\",\"image-20220530214532180\",\"如何在磁盘中读/写数据\",\"盘面/柱面\",\"image-20220530220243511\",\"柱面：具有相同编号的磁道形成的圆柱\",\"磁盘的分类\",\"image-20220530220354717\",\"image-20220530220421638\",\"image-20220530220453740\"]},\"176\":{\"h\":\"11、磁盘调度算法\",\"t\":[\"一次磁盘读/写操作需要的时间\",\"寻找时间(寻道时间)Ts​ :在读/写数据前，将磁头移动到指定磁盘所花的时间\",\"启动磁头臂时间为s\",\"移动磁头时间，假设是匀速移动，每跨越一个磁道耗时为m，总共需要跨越n个磁道\",\"寻道时间 Ts​=s+m∗n\",\"延迟时间TR​ :通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r，则平均所需的延迟时间$T_R = \\\\frac{1}{2} * \\\\frac{1}{r} = \\\\frac{1}{2r} $ (r1​ 是转动一圈需要的时间，找到目标扇区平均需要转半圈，因此乘21​)\",\"传输时间Ts​ :从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁盘上的字节数为N。则\",\"传输时间Ts​=r1​∗Nb​=rNb​ (每个磁道可存N字节的数据，因此b字节的数据需要b/N个磁道才能存储，而读/写一个磁道所需的时间刚好又是转一圈所需要的时间r1​ )\",\"总的平均存储时间Ta​=Ts​+2r1​+rNb​\",\"延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件固有的属性，因此操作系统也无法优化延迟时间和传输时间。\",\"磁盘调度算法\",\"先来先服务算法(FCFS)\",\"image-20220530224610670\",\"最短寻找时间优先(SSTF)\",\"image-20220531113725569\",\"扫描算法(SCAN)\",\"image-20220531114050634\",\"LOOK调度算法\",\"image-20220531114605608\",\"循环扫描算法(C-SCAN)\",\"image-20220531114848212\",\"C-LOOK调度算法\",\"image-20220531115047482\",\"image-20220531115101881\"]},\"177\":{\"h\":\"12、减少延迟时间的方法\",\"t\":[\"image-20220531200459574\",\"减少延迟时间的方法：交替编号\",\"image-20220531201414435\",\"image-20220531223117841\",\"转两圈读完的原因：因为要一个隔着一个的读，所以需要两圈\",\"image-20220531223412094\",\"减少延迟时间的方法：错位命名\",\"image-20220607112210165\",\"0号盘面是在1号盘面上面的，扇区都一一对应，转两圈读取完0号盘面的数据以后，读取1号盘面的0扇区时无法立即开始读，增加了延迟时间\",\"image-20220607112458312\",\"image-20220607112703160\"]},\"178\":{\"h\":\"13、磁盘的管理\",\"t\":[\"磁盘初始化\",\"image-20220607113400305\",\"引导块\",\"计算机开机时需要进行一系列初始化工作，这些初始化工作是通过执行**初始化程序(自举程序)**完成的\",\"在ROM中存放了很小的\\\"自举装入程序\\\"，开机时计算机先运行\\\"自举装入程序\\\"，通过执行该程序就可以找到引导块，并将完整的自举程序读入内存，完成初始化\",\"完整的自举程序放在磁盘的启动块(即引导块/启动分区)上，启动块位于磁盘的固定位置，拥有启动分区的磁盘为启动磁盘或系统磁盘(C:盘)\",\"坏块管理\",\"坏块：无法正常使用的扇区，属于硬件故障，操作系统是无法修复的，应该将坏块标记出来，以免错误的使用到它\",\"image-20220608103307481\",\"image-20220608103332891\"]},\"179\":{\"h\":\"14、I/O设备的基本概念和分类\",\"t\":[\"I/O设备介绍\",\"image-20220608104012756\",\"I/O设备的分类\",\"按照使用特性分类\",\"按照传输速率分类\",\"image-20220608104500993\",\"按信息交换的单位分类\",\"image-20220608104632049\",\"image-20220608104719687\"]},\"180\":{\"h\":\"15、I/O控制器\",\"t\":[\"I/O设备的机械部件\",\"I/O设备的电子部件(I/O控制器)\",\"image-20220608105259812\",\"I/O控制器的组成\",\"image-20220608105835197\",\"注意：\",\"一个I/O控制器可能会对应多个设备\",\"数据寄存器、控制寄存器、状态寄存器可能也有多个，每个控制/状态寄存器对应一个具体的设备，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O;另一些计算机则采用I/O专用地址，即寄存器独立编址\",\"内存映像I/O与寄存器独立编址\",\"image-20220608110542490\",\"image-20220608110604462\"]},\"181\":{\"h\":\"16、I/O控制方式\",\"t\":[\"程序直接控制方式\",\"完成一次读/写操作的流程(轮询)\",\"image-20220608132930223\",\"image-20220608133444265\",\"CPU干预的频率\",\"很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断的轮询检查\",\"数据传送的单位\",\"每次读/写一个字\",\"数据的流向\",\"读操作(数据输入)：I/O设备 ---> CPU --> 内存\",\"写操作(数据输出)：内存 ---> CPU ---> I/O设备\",\"每个字的读/写都需要CPU的帮助\",\"优缺点\",\"优点：实现简单，在读/写指令之后，加上实现循环检查的一系列指令即可\",\"缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低\",\"中断驱动方式\",\"完成一次读/写操作的流程\",\"CPU干预的频率\",\"每次I/O操作开始之前、完成之后需要CPU介入\",\"等待I/O完成的过程中CPU可以切换到别的进程执行\",\"数据传送单位\",\"每次读/写一个字\",\"数据的流向\",\"读操作(数据输入)：I/O设备 ---> CPU --> 内存\",\"写操作(数据输出)：内存 ---> CPU ---> I/O设备\",\"优缺点\",\"优点：与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停的轮询。CPU与I/O设备可并行工作，CPU利用率得到明显的提升\",\"缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间，每次中断只能传输一个字\",\"DMA方式(直接存储器存取)\",\"完成一次读/写操作的流程\",\"DMA控制器\",\"image-20220608140914035\",\"CPU干预的频率\",\"在传送一个或多个数据块的开始和结束时，才需要CPU的干预\",\"数据传送的单位\",\"每次读/写一个或多个块(注意每次读写的只能是连续的多个块，且这些块读入内存后在)\",\"数据的流向(不再需要经过CPU)\",\"读操作(数据输入)：I/O设备 ---> 内存\",\"写操作(数据输出)：内存 ---> I/O设备\",\"优缺点\",\"优点：数据传输以\\\"块\\\"为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升\",\"缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读写多个离散存储的数据块，或者要将数据分别写到不同内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成\",\"通道控制方式\",\"image-20220608144106793\",\"image-20220608144250495\",\"image-20220608144448647\"]},\"182\":{\"h\":\"17、I/O软件层次结构\",\"t\":[\"用户层系统\",\"image-20220608145040522\",\"设备独立性软件\",\"设备独立性软件，又称设备无关性软件，与设备的硬件特性无关的功能都几乎在这一层实现。\",\"主要实现的功能：\",\"向上层提供统一的调用接口(如read/write系统调用)\",\"设备的保护：设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样\",\"差错处理：对一些设备的错误进行处理\",\"设备的分配与回收\",\"数据缓冲区管理：通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\",\"建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序\",\"image-20220608150454000\",\"image-20220608150624784\",\"image-20220608150637422\",\"设备驱动程序\",\"负责对硬件设备的具体控制，将上层发出的一系列命令(如read/write)转化成特定设备能听得懂的一些列操作，包括设置设备寄存器，检查设备状态等。不同的I/O设备有不同的硬件特性，具体细节只有设备厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序\",\"中断处理程序\",\"image-20220608152211751\",\"image-20220608153523239\"]},\"183\":{\"h\":\"18、I/O核心子系统\",\"t\":[\"I/O系统(I/O核心子系统)属于操作系统的内核部分，主要包括：设备独立性软件、设备驱动程序、中断处理程序\",\"image-20220608154426249\",\"I/O调度：用某种算法确定一个好的顺序来处理各个I/O请求\",\"比如：磁盘调度 ，当多个磁盘I/O请求到来时，用某种调度算法来确定满足I/O请求的顺序\",\"设备保护：\",\"操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限(如：只读、读和写等)\",\"在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现设备保护功能\"]},\"184\":{\"h\":\"19、假脱机技术\",\"t\":[\"脱机技术简介\",\"手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快，人机速度矛盾明显，主机要浪费很多时间来等待设备\",\"image-20220609095039255\",\"批处理阶段引入了脱机输入/输出技术(用磁带完成)：\",\"image-20220609095427515\",\"假脱机技术，又称\\\"SPOOLing技术\\\"是用软件的方式模拟脱机技术。系统的组成如下：\",\"image-20220609095722677\",\"输入井：模拟脱机输入时的磁带，用于收容I/O设备输入的数据\",\"输出井：模拟脱机输出时的磁带，用于收容用户进程输出的数据\",\"输入进程：模拟脱机输入时的外围控制机\",\"输出进程：模拟脱机输出时的外围控制机\",\"输入缓冲区：在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后在转存到输入井中\",\"输出缓冲区：在输出进程的控制下，用于暂存从输出井传来的数据，之后再传送到输出设备上\",\"共享打印机原理分析\",\"image-20220609100750640\",\"image-20220609101627441\",\"image-20220609101720564\",\"image-20220609101958603\"]},\"185\":{\"h\":\"20、设备的分配与回收\",\"t\":[\"设备分配时应考虑的因素\",\"设备的固有属性：\",\"独占设备—一个时段只能分配一个进程\",\"共享设备—可同时分配给多个进程使用，各进程往往是宏观上同时共享使用设备，而在微观上交替使用\",\"虚拟设备—采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用\",\"设备的分配算法：\",\"先来先服务、优先级高者优先、短任务优先.....\",\"设备分配中的安全性：\",\"image-20220609103338474\",\"静态分配和动态分配\",\"静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源，不会发生死锁\",\"动态分配：进程运行过程中动态申请设备资源\",\"设备分配管理中的数据结构\",\"image-20220609103645775\",\"image-20220609103942129\",\"image-20220609104134198\",\"image-20220609104233122\",\"image-20220609104330037\",\"设备分配的步骤\",\"根据进程请求的物理设备名查找SDT(物理设备名是进程请求分配时提供的参数)\",\"根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程\",\"根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程\",\"根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配个进程\",\"缺点：\",\"用户编程时必须使用\\\"物理设备名\\\"，底层细节对用户不透明，不方便编程\",\"若换了一个物理设备，则程序无法运行\",\"若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待\",\"改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名\",\"设备分配改进\",\"image-20220610212414867\",\"image-20220610212527979\"]},\"186\":{\"h\":\"21、缓冲区管理\",\"t\":[\"缓冲区介绍以及作用\",\"image-20220610212917960\",\"image-20220610213119470\",\"单缓冲\",\"image-20220610213442230\",\"image-20220610213728733\",\"image-20220610214210814\",\"结论：采用单缓冲策略，处理一块数据平均耗时Max(C,T) + M\",\"双缓冲\",\"image-20220610214717158\",\"image-20220610215055371\",\"结论：采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)\",\"使用单/双缓冲在通信时的区别\",\"image-20220610215815431\",\"image-20220610215848171\",\"image-20220610220013207\",\"循环缓冲区\",\"image-20220610220150678\",\"缓冲池\",\"image-20220610221353573\",\"image-20220610221431032\"]},\"187\":{\"h\":\"代码模板\"},\"188\":{\"h\":\"排序\",\"t\":[\"img\"]},\"189\":{\"h\":\"选择排序\",\"t\":[\"找到最大（小）的元素\",\"将其与最后一个元素进行交换\",\"重复\"]},\"190\":{\"h\":\"插入排序\",\"t\":[\"标注需排序的元素，将其前方的序列视为已排序序列(从0开始)\",\"将需排序的元素与已排序序列进行比较，找到合适的插入位置，将此位置起的所有已排序序列后移一位\",\"将待排序元素插入到后移序列的前方\"]},\"191\":{\"h\":\"快排\",\"t\":[\"确定分界点x\",\"调整区间：小于等于x的放在区间左边，大于等于x的放在区间右边\",\"分治递归处理子问题\",\"public class Main { public static void quick_sort(int[] q, int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; while (i < j) { do i++; while (q[i] < x); do j--; while (q[j] > x); if (i < j) { int tmp = q[i]; q[i] = q[j]; q[j] = tmp; } } quick_sort(q, l, j); quick_sort(q, j + 1, r); } public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] q = new int [100005]; for (int i = 0; i < n; i++) { q[i] = sc.nextInt(); } quick_sort(q, 0, n - 1); for (int i = 0; i < n; i++) { System.out.println(q[i] + \\\" \\\"); } } } \"]},\"192\":{\"h\":\"埃氏筛\",\"t\":[\"#include<bits/stdc++.h> using namespace std; const int MAXN = 5e6+5; int isPrime[MAXN]; void getPrime() { memset(isPrime, -1, sizeof isPrime); isPrime[1] = 0; for (int i = 2; i * i <= MAXN; i++) { if (isPrime[i]) { for (int j = i * i; j <= MAXN; j += i) { isPrime[j] = 0; } } } } int main () { getPrime(); for (int i = 2; i <= 100; i++) { if (isPrime[i]) { cout << i << endl; } } return 0; } \"]},\"193\":{\"h\":\"背包\"},\"194\":{\"h\":\"01背包\",\"t\":[\"【动态规划/背包问题】那就从 0-1 背包问题开始讲起吧 ... (qq.com)\",\"import java.util.Scanner; /** * @author Vingkin * @since 2022/5/8 20:33 */ public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); // 物品个数 int V = sc.nextInt(); // 背包体积 int[] v = new int[N]; // 体积 int[] w = new int[N]; // 价值 for (int i = 0; i < N; i++) { v[i] = sc.nextInt(); w[i] = sc.nextInt(); } int[][] f = new int[N][V + 1]; // 先处理「考虑第一件物品」的情况 for (int i = 0; i <= V; i++) { f[0][i] = i >= v[0] ? w[0] : 0; } // 再处理「考虑其余物品」的情况 for (int i = 1; i < N; i++) { for (int j = 0; j <= V; j++) { if (j >= v[i]) { // f[i - 1][j]表示不选第i个物品，f[i - 1][j - v[i]] + w[i]表示选择第i个物品 f[i][j] = Math.max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } else { f[i][j] = f[i - 1][j]; } } } System.out.println(f[N - 1][V]); } } \",\"空间优化\",\"求第 i 行第 c 个格子的值时，只依赖于第 i−1 行的第 c 个格子和 c−v[i] 个格子。\",\"问题来自于上一行 c 以及前面的区域，我们必须让 c 以递减的形式更新，以保证能够取到上一行的前面的值（因为 c 递减更新的话前面是旧值，我们恰恰需要上一行的旧值）\",\"import java.util.Scanner; /** * @author Vingkin * @since 2022/5/8 20:33 */ public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int V = sc.nextInt(); int[] v = new int[N]; // 体积 int[] w = new int[N]; // 价值 for (int i = 0; i < N; i++) { v[i] = sc.nextInt(); w[i] = sc.nextInt(); } int[] f = new int[V + 1]; for (int i = 0; i < N; i++) { for (int j = V; j >= v[i]; j--) { f[j] = Math.max(f[j], f[j - v[i]] + w[i]); } } System.out.println(f[V]); } } \"]},\"195\":{\"h\":\"完全背包\",\"t\":[\"完全背包和01背包相比就是每件物品数量无限\",\"【动态规划/背包问题】从数学角度推导「完全背包」与「01 背包」之间的遍历顺序关系 (qq.com)\",\"状态转移方程：dp[i][j]=max(dp[i−1][j],dp[i−1][j−k∗v[i]]+k∗w[i])\",\"class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[][] dp = new int[N][C + 1]; // 先预处理第一件物品 for (int j = 0; j <= C; j++) { // 显然当只有一件物品的时候，在容量允许的情况下，能选多少件就选多少件 int maxK = j / v[0]; dp[0][j] = maxK * w[0]; } // 处理剩余物品 for (int i = 1; i < N; i++) { for (int j = 0; j <= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[i - 1][j]; // 考虑第 i 件物品的情况 int y = 0; for (int k = 1 ;; k++) { if (j < v[i] * k) { break; } y = Math.max(y, dp[i - 1][j - k * v[i]] + k * w[i]); } dp[i][j] = Math.max(n, y); } } return dp[N - 1][C]; } } \",\"class Solution { public int maxValue(int N, int C, int[] v, int[] w) { int[] dp = new int[C + 1]; for (int i = 0; i < N; i++) { for (int j = 0; j <= C; j++) { // 不考虑第 i 件物品的情况（选择 0 件物品 i） int n = dp[j]; // 考虑第 i 件物品的情况 int y = j - v[i] >= 0 ? dp[j - v[i]] + w[i] : 0; dp[j] = Math.max(n, y); } } return dp[C]; } } \"]},\"196\":{\"h\":\"计算机网络\"},\"197\":{\"h\":\"Get和Post的区别\",\"t\":[\"【网络协议】彻底弄清POST和GET请求的区别，这次你GET了么 - SegmentFault 思否\",\"【前端 · 面试 】HTTP 总结（五）—— GET 和 POST - SegmentFault 思否\"]},\"198\":{\"h\":\"输入网址到网页显示期间发生了什么\",\"t\":[\"键入网址到网页显示，期间发生了什么？\",\"解析URL，生成HTTP请求信息\",\"DNS解析\",\"TCP连接（三次握手）\",\"建立连接\",\"四次挥手\"]},\"199\":{\"c\":[\"interview\"]},\"200\":{\"c\":[\"interview\"]},\"201\":{\"h\":\"Java并发\"},\"202\":{\"h\":\"start()和run()\",\"t\":[\"start()和run()都是Thread类的方法（如果用的是Runnable则执行的是Runnable中的run方法，注意Callable中的是call方法）\",\"start是启动线程作用是将线程变为就绪状态，至于是否调用还是得看CPU的分配。run是一个线程的具体执行内容，线程启动后自动调用。\",\"如果在main线程中调用了t1线程的run方法，就相当于main线程运行了一个普通的run方法，并没能达到多线程的效果\",\"strat只能调用一次，多次调用会抛IllegalThreadStateException异常\"]},\"203\":{\"h\":\"sleep()与yield()\",\"t\":[\"sleep\",\"调用sleep会让当前线程从Running进入Timed Waiting（阻塞状态）状态\",\"其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException\",\"睡眠结束后的线程未必会立刻得到执行\",\"yield\",\"调用yield会让当前线程从Running进入Runnalbe（就绪状态）状态，然后调度执行其他同优先级的线程。如果这时没有同优先级的线程，那么不能保证让当前线程暂停的效果\",\"具体的实现依赖于操作系统的任务调度器\",\"区别\",\"就绪状态有机会被任务调度器调用，阻塞状态不会。\",\"sleep有休眠时间，yield没有时间参数\"]},\"204\":{\"h\":\"interrupt()\",\"t\":[\"Thread中的方法\",\"如果打断的是阻塞线程(sleep, wait, join)，则打断标记(isInterrupted())会在打断后清为False\",\"如果打断的是正常运行的线程，则不会清空打断状态\"]},\"205\":{\"h\":\"线程优先级\",\"t\":[\"Java中优先级最大10，最小1，默认为5，仅仅是一个提示，调度器甚至可以忽略。\",\"只有在cpu比较忙的时候，优先级较高的线程会获得更多的时间片，cpu空闲时，优先级几乎没什么用。\"]},\"206\":{\"h\":\"两阶段终止模式\",\"t\":[\"在线程T1中如何优雅地终止另一个线程T2？这里的优雅指的是给T2一个处理其他事情的机会（如释放锁）\",\"如果调用线程的stop()方法，如果此时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其他线程永远无法获取锁。\",\"public class Test { public static void main(String[] args) throws InterruptedException { Monitor monitor = new Monitor(); monitor.start(); Thread.sleep(3500); monitor.stop(); } } class Monitor { Thread monitor; /** * 启动监控器线程 */ public void start() { //设置线控器线程，用于监控线程状态 monitor = new Thread() { @Override public void run() { //开始不停的监控 while (true) { //判断当前线程是否被打断了 if(Thread.currentThread().isInterrupted()) { System.out.println(\\\"处理后续任务\\\"); //终止线程执行 break; } System.out.println(\\\"监控器运行中...\\\"); try { //线程休眠 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); //如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记 Thread.currentThread().interrupt(); } } } }; monitor.start(); } /** * 用于停止监控器线程 */ public void stop() { //打断线程 monitor.interrupt(); } } \"]},\"207\":{\"h\":\"守护线程\",\"t\":[\"当Java进程中有多个线程执行时，只有当所有非守护线程执行完毕后，Java进程才会结束。但当非守护线程执行完毕后，守护线程无论是否执行完毕，都会一同结束。\",\"垃圾回收器就是一个守护线程\"]},\"208\":{\"h\":\"线程状态\",\"t\":[\"五种状态\",\"操作系统层面\",\"初始状态：仅在语言层面创建了线程对象，还未与操作系统线程关联\",\"可运行状态（就绪状态）：指该线程已经被创建（与操作系统线程相关），可以由CPU调度使用\",\"运行状态：指获取了CPU时间片运行中的状态\",\"阻塞状态： \",\"如果调用了阻塞API，如读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态\",\"等读写完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态\",\"与可运行状态的区别是，对阻塞状态的线程来说只要他们一直不唤醒，调度器就一直不会考虑调度他们。\",\"终止状态：表示线程执行已经完毕，生命周期已经结束，不会再转换为其他状态\",\"六种状态\",\"Java中Thread.State枚举描述的\",\"下图RUNNABLE中的阻塞状态应该去除\",\"线程的状态转换\",\"NEW：线程刚被创建，但是还没有调用start()方法\",\"RUNNABLE：当调用了start()方法之后的状态。涵盖了操作系统层面的【可运行状态】、【运行状态】和【阻塞状态】（在Java中无法区分运行状态和可运行状态）\",\"BLOCKED、WAITING、TIMED_WAITING：都是Java API层面对【阻塞状态】的细分\",\"TERMINATED：当前线程运行结束\",\"Java 线程的状态 \"]},\"209\":{\"h\":\"变量的线程安全分析\",\"t\":[\"成员变量和静态变量的线程安全分析\",\"如果变量没有在线程间共享，那么变量是安全的\",\"如果变量在线程中共享 \",\"如果只有读操作，则线程安全\",\"如果有写操作，则该变量属于临界资源，需要考虑线程安全问题\",\"局部变量线程安全分析\",\"局部变量被初始化为基本数据类型则是安全的\",\"当局部变量是引用变量时则需要进行逃逸分析判断 \",\"如果该对象没有逃离方法的作用范围，则线程安全\",\"如果该对象逃离了方法的作用范围，则线程不安全\"]},\"210\":{\"h\":\"对象头\",\"t\":[\"Java对象头详细信息在JVM中有描述，简要来说包含Mark Word(32bit)和Klass Word(32bit)。如果是数组的话还会包含数组长度(32bit)。\",\"下图描述的是不同锁状态下Mark Word的形式，其中后几位为001表示无锁，101表示偏向锁，00表示轻量级锁，10表示重量级锁，11表示标记GC\"]},\"211\":{\"h\":\"Monitor原理\",\"t\":[\"Monitor被翻译成监视器或管程\",\"每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁之后，该对象头的Mark Word中就被设置成指向Monitor对象的指针\",\"Monitor的结构如下：\",\"刚开始Monitor中的Owner为null\",\"当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner\",\"在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED\",\"Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时候是非公平的\",\"途中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程\",\"注意：\",\"synchronized必须是进入同一个锁对象的monitor才有上述的效果（一个锁对象对应着一个monitor）\",\"不加synchronized的对象不会关联监视器，不遵从上述规则\",\"字节码层面分析synchronized\",\"monitorenter是进入synchronized语句\",\"monitorexit是退出synchronized语句\",\"6 - 14行是synchronized中执行的部分，如果其中出现了错误也会释放锁，因为异常表中当在6 - 16行出现异常时，会跳到19行执行异常处理部分。\",\"static final Object lock = new Object(); static int counter = 0; public static void main(String[] args) { synchronized (lock) { counter++; } } \"]},\"212\":{\"h\":\"自旋优化\",\"t\":[\"优化重量级锁竞争\",\"当发生重量级锁竞争的时候，还可以使用自旋来进行优化（不加入Monitor的阻塞队列EntryList中），如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换（持锁线程执行完synchronized同步块后，释放锁，Owner为空，唤醒阻塞队列来竞争，胜出的线程获取cpu执行权的过程）就获得了锁\",\"成功演示：\",\"失败演示：\",\"自旋会占用CPU时间，单核CPU自选就是浪费，多核CPU自旋才能发挥优势\"]},\"213\":{\"h\":\"轻量级锁\",\"t\":[\"用于优化重量级锁\",\"https://blog.csdn.net/m0_37989980/article/details/111408759#t5\"]},\"214\":{\"h\":\"偏向锁\",\"t\":[\"用于优化轻量级锁重入\",\"https://blog.csdn.net/m0_37989980/article/details/111408759#t8\"]},\"215\":{\"h\":\"wait()和notify()\",\"t\":[\"Object类中的方法\",\"https://blog.csdn.net/m0_37989980/article/details/111412907#t0\"]},\"216\":{\"h\":\"sleep()和wait()的区别\",\"t\":[\"sleep是Thread方法，wait是Object方法\",\"sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起使用\",\"sleep不会释放锁对象，wait会释放锁对象\",\"他们的线程状态都是TIMED_WAITING\"]},\"217\":{\"h\":\"保护性暂停模式\",\"t\":[\"用于一个线程等待另一个线程的执行结果\",\"join()内部采用的就是这个原理，不过join()中是一个线程等待另一个线程结束\",\"有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject\",\"如果有结果不断从一个线程到另一个线程，那么可以使用消息队列（生产者消费者模式）\",\"JDK中，join和future采用的就是该模式\",\"因为一个线程需要等待另一个线程的执行结果，所以归结于同步模式\"]},\"218\":{\"h\":\"生产者消费者模式\",\"t\":[\"与前面的保护性暂停中的GuardObjct不同，不需要产生结果和消费结果的线程一一对应\",\"消费队列可以用来平衡生产和消费的线程资源\",\"生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据\",\"消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据\",\"JDK中各种阻塞队列，采用的就是这种模式\"]},\"219\":{\"h\":\"park()和unpark()\",\"t\":[\"https://blog.csdn.net/m0_37989980/article/details/111412907#t8\",\"park和unpark是LockSupport类中的方法，运行时会调用Unsafe类中的native方法\",\"每个线程都会和一个park对象关联起来，由三部分组成_counter,_cond,_mutex_。核心部分是counter，可以理解为一个标记位。\",\"当调用park时会查看counter是否为0，为0则进入cond阻塞。为1则继续运行并将counter置为0。\",\"当调用unpark时，会将counter置为1，若之前的counter值为0，还会唤醒阻塞的线程。\",\"如果先调用unpark再调用park不会阻塞线程。调用unpark后将counter置为1，再调用park线程发现counter为1继续运行并将counter置为0。\",\"park()&unpark()与wait()&notify()对比\",\"wait，notify和notifyAll必须配合Object Monitor(synchronized)一起使用，而park和unpark不必\",\"park，unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，无法唤醒指定的线程。\",\"park，unpark可以先unpark，而wait，notify不能先notify\"]},\"220\":{\"h\":\"死锁，活锁，饥饿\"},\"221\":{\"h\":\"死锁\",\"t\":[\"代码演示：\",\"public static void main(String[] args) { final Object A = new Object(); final Object B = new Object(); new Thread(()->{ synchronized (A) { try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (B) { } } }).start(); new Thread(()->{ synchronized (B) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (A) { } } }).start(); } \",\"发生死锁的必要条件：\",\"互斥条件：在一段时间内，一种资源只能被一个线程所使用\",\"请求和保持条件：线程已经拥有了至少一种资 源，同时又去申请其他资源。因为其他资源被别的线程所使用。该线程进入阻塞状态同时不释放自己已有的资源。\",\"不可抢占条件：进程对已获得的资源在未使用完成前不能被抢占，之后能在线程使用完后自己释放。\",\"循环等待条件：发生死锁时，必然存在一个线程---资源的循环链\",\"定位死锁的方法：\",\"jstack + 进程id命令查看线程状态有Java层面死锁线程信息\",\"jconsole有死锁检测功能\",\"避免死锁的方法：\",\"在线程使用锁对象时, 采用固定加锁的顺序, 可以使用Hash值的大小来确定加锁的先后\",\"尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁\",\"使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)\"]},\"222\":{\"h\":\"活锁\",\"t\":[\"活锁出现在两个线程 互相改变对方的结束条件，谁也无法结束。\",\"避免活锁的方法：\",\"在线程执行时，中途给予不同的间隔时间, 让某个线程先结束即可。\",\"死锁与活锁的区别：\",\"死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。\",\"活锁是因为线程间修改了对方的结束条件，而导致代码一直在运行，却一直运行不完的现象。\"]},\"223\":{\"h\":\"饥饿\",\"t\":[\"某些线程因为优先级太低，导致一直无法获得资源的现象。\",\"在使用顺序加锁时，可能会出现饥饿现象\"]},\"224\":{\"h\":\"固定线程运行顺序\",\"t\":[\"wait()&notify()\",\"public class Test { static final Object lock = new Object(); static boolean t2runned = false; public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (lock) { while (!t2runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"1\\\"); } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized(lock) { log.debug(\\\"2\\\"); t2runned = true; lock.notify(); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"park()&unpark()\",\"public class Test { public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { LockSupport.park(); log.debug(\\\"1\\\"); } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { log.debug(\\\"2\\\"); LockSupport.unpark(t1); } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"await()&signal()\",\"public class Test { private static ReentrantLock lock = new ReentrantLock(); private static boolean t2runned = false; static Condition condition1 = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { lock.lock(); try { while (!t2runned) { try { condition1.await(); log.debug(\\\"1\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { lock.unlock(); } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { lock.lock(); try { log.debug(\\\"2\\\"); t2runned = true; condition1.signal(); } finally { lock.unlock(); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \"]},\"225\":{\"h\":\"线程交替输出\",\"t\":[\"wait()&notify()\",\"public class Test { static boolean t1runned = false; static boolean t2runned = true; static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { synchronized (lock) { while (!t2runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"1\\\"); t1runned = true; t2runned = false; lock.notify(); } } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { synchronized (lock) { while (!t1runned) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.debug(\\\"2\\\"); t1runned = false; t2runned = true; lock.notify(); } } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"park()&unpark()\",\"public class Test { volatile static boolean t1runned = false; volatile static boolean t2runned = true; static final Object lock = new Object(); static Thread t1; static Thread t2; public static void main(String[] args) { t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { if (!t2runned) { LockSupport.park(); } log.debug(\\\"1\\\"); t2runned = false; t1runned = true; LockSupport.unpark(t2); } } }, \\\"t1\\\"); t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { if (!t1runned) { LockSupport.park(); } log.debug(\\\"2\\\"); t2runned = true; t1runned = false; LockSupport.unpark(t1); } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \",\"await()&signal()\",\"public class Test { static boolean t1runned = false; static boolean t2runned = true; public static void main(String[] args) { ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition(); Thread t1 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { reentrantLock.lock(); try { while (!t2runned) { condition.await(); } log.debug(\\\"1\\\"); t1runned = true; t2runned = false; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { reentrantLock.unlock(); } } } }, \\\"t1\\\"); Thread t2 = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 10; i++) { reentrantLock.lock(); try { while (!t1runned) { condition.await(); } log.debug(\\\"2\\\"); t1runned = false; t2runned = true; condition.signal(); } catch (InterruptedException e) { e.printStackTrace(); } finally { reentrantLock.unlock(); } } } }, \\\"t2\\\"); t1.start(); t2.start(); } } \"]},\"226\":{\"h\":\"并发编程的三大特性\",\"t\":[\"原子性：保证指令不会受到线程上下文切换的影响。程序的原子性是指整个程序中的所有操作，要么全部完成，要么全部失败，不可能滞留在中间某个环节；在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所打断。\",\"可见性：保证指令不会受cpu缓存的影响。一个线程对共享变量值的修改，能够及时地被其他线程看到\",\"有序性：保证指令不会受到cpu指令并行优化的影响\"]},\"227\":{\"h\":\"volatile原理\",\"t\":[\"volatile的底层实现原理是内存屏障\",\"保证可见性 \",\"对volatile变量的写指令后会加入写屏障。写屏障保证该屏障之前的，对共享变量的改动都会同步到主存中。\",\"对volatile变量之间会加入读屏障。读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据。\",\"保证有序性（禁止指令重排） \",\"写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\",\"读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前\"]},\"228\":{\"h\":\"volatile和synchronized\",\"t\":[\"一个线程对volatile变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。（比如volatile修饰的i，两个线程一个i++一个i--，只能保证看到最新值，不能解决指令交错的问题。）\",\"synchronized语句块既能保证代码块的原子性，也同时能保证代码块内变量的可见性。但缺点是synchronized属于重量级锁，性能相对较低。\",\"volatile关键字只能修饰变量，synchronized还可以修饰方法，类以及代码块。\",\"volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。\"]},\"229\":{\"h\":\"volatile和synchronized在有序性上的不同\",\"t\":[\"synchronized的有序性是持有相同锁的两个同步块只能串行的进入，即被加锁的内容要按照顺序被多个线程执行，但是其内部的同步代码还是会发生重排序。\",\"volatile的有序性是通过插入内存屏障来保证指令按照顺序执行。不会存在后面的指令跑到前面的指令之前来执行。是保证编译器优化的时候不会让指令乱序。\",\"synchronized代码块内部是不能保证指令重排的。\"]},\"230\":{\"h\":\"i++是否线程安全\",\"t\":[\"提到这个问题得区分i是成员变量/静态变量还是局部变量，如果是前者需要考虑，对于局部变量不管是基本类型还是包装类型都不需要考虑，包装类型比如Integer是不可变类，是线程安全的。\",\"假设有1000个线程对i执行++操作，理论上ide结果应该是1000，实际并不是\",\"// i++ 的字节码指令，此时i是一个静态变量 getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 iadd // 自增 putstatic i // 将修改后的值存入静态变量i \",\"每个线程都有自己的工作内存，每个线程需要用共享变量时必须先把共享变量从主存load到自己的工作内存，等完成对共享变量的操作时再save到主内存。\",\"问题就出在一个线程读取主存的值后运算完还未刷回主存就被其他线程从主存中读取到了，这时候其他线程读取的数据就是脏数据了。\",\"这也是经典的内存不可见问题，把count加上volatile也不能解决这个问题。因为volatile只能保证可见性并不能保证原子性。多个线程同时读取这个共享变量的值，就算保证其他线程的可见性，也不能保证线程之间读取到同样的值然后互相覆盖对方值的情况。\",\"解决方案\",\"对i++操作的方法加同步锁，同时只能由一个线程执行i++\",\"使用支持原子类型操作的类，比如AtomicInteger，内部使用的是CAS\"]},\"231\":{\"h\":\"CAS的特点\",\"t\":[\"结合CAS和volatile可以实现无锁并发，适用于线程数少、多核CPU的场景下。\",\"CAS是基于乐观锁的思想~~（实际上并不是锁）~~：最乐观的估计，不怕别的线程来修复共享变量，就算改了也没关系，重试即可\",\"synchronized是基于悲观锁的思想：最悲观的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会\",\"CAS体现的是无锁并发，无阻塞并发\",\"因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一\",\"但是如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响\"]},\"232\":{\"h\":\"Atomic原子类\",\"t\":[\"并发编程面试必备：JUC 中的 Atomic 原子类总结 (qq.com)\",\"原子整数\",\"AtomicInteger\",\"AtomicLong\",\"AtomicBoolean\",\"public static void main(String[] args) { AtomicInteger i = new AtomicInteger(0); // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement()); // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet()); // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet()); // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i-- System.out.println(i.getAndDecrement()); // 获取并加值（i = 0, 结果 i = 5, 返回 0） System.out.println(i.getAndAdd(5)); // 加值并获取（i = 5, 结果 i = 0, 返回 0） System.out.println(i.addAndGet(-5)); // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.getAndUpdate(p -> p - 2)); // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.updateAndGet(p -> p + 2)); // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final System.out.println(i.getAndAccumulate(10, (p, x) -> p + x)); // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0） // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用 System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x)); } \",\"原子引用\",\"原子引用的作用: 保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)\",\"AtomicReference\",\"AtomicStampedReference\",\"AtomicMarkableReference\",\"原子数组\",\"保证数组内元素的线程安全\",\"AtomicIntegerArray\",\"AtomicLongArray\",\"AtomicReferenceArray\",\"字段更新器\",\"保证多线程访问同一个对象的成员变量时, 成员变量的线程安全性。\",\"AtomicIntegerFieldUpdater\",\"AtomicLongFieldUpdater\",\"AtomicReferenceFieldUpdater\",\"原子累加器\",\"LongAdder\",\"LongAccumulator\",\"DoubleAdder\",\"DoubleAccumulator\"]},\"233\":{\"h\":\"原子引用ABA问题\",\"t\":[\"采用CAS主线程仅能判断出共享变量的值与初值A是否相同，不能感知到这种从A改为B又改回A的情况，如果主线程希望：\",\"只要有其他线程【动过了】共享变量，那么自己的cas就算失败，这时仅比较值是不够的，还需要再加一个版本号\",\"通过AtomicStampedReference判断是否更改了版本号，传入的是整型变量\",\"通过AtomicMarkableReference判断是否被修改，传入的是布尔变量\"]},\"234\":{\"h\":\"LongAdder原理\",\"t\":[\"// 累加单元数组，懒惰初始化 transient volatile Cell[] cells; // 基础值，如果没有竞争，则用cas累加这个域 transient volatile long base; // 在cells创建或扩容时，置为1，表示加锁 transient volatile int cellsBusy; \",\"性能提升的原因很简单，就是在有竞争时，设置多个累加单元(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。\",\"之前AtomicLong等都是在一个共享资源变量上进行竞争, while(true)循环进行CAS重试, 性能没有LongAdder高\"]},\"235\":{\"h\":\"Unsafe\",\"t\":[\"Unsafe并不是表示线程不安全，而是表示Unsafe类中的操作不安全，因为是对于底层的操作。\",\"Unsafe对象提供了非常底层的，操作系内存、线程的方法，Unsafe对象不能直接调用，只能通过反射获得\",\"Field theUnsafe = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); System.out.println(unsafe); \"]},\"236\":{\"h\":\"不可变类\",\"t\":[\"final的使用\",\"属性用final修饰保证该属性是只读的，不能修改\",\"类用final修饰保证了类不能被继承，该类中的方法不能被重写，防止子类无意间破坏不变性\",\"保护性拷贝\",\"使用字符串时，也有一些跟修改相关的方法啊，比如substring、replace 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：\",\"public String substring(int beginIndex, int endIndex) { if (beginIndex < 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex > value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen < 0) { throw new StringIndexOutOfBoundsException(subLen); } // 上面是一些校验，下面才是真正的创建新的String对象 return ((beginIndex == 0) && (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } \",\"发现其方法最后是调用String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制。 这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】\"]},\"237\":{\"h\":\"final原理\",\"t\":[\"public class TestFinal { final int a = 20; } \",\"0: aload_0 1: invokespecial #1 // Method java/lang/Object.\\\"<init>\\\":()V 4: aload_0 5: bipush 20 7: putfield #2 // Field a:I <-- 写屏障 10: retu \",\"发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况。\",\"写屏障保证该屏障之前的，对共享变量的改动都会同步到主存中。\",\"写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后\"]},\"238\":{\"h\":\"享元模式\",\"t\":[\"享元模式简单理解就是重用数量有限的同一对象，比如字符串常量池，包装类常量池，线程池以及字符串连接池都运用了享元模式的思想。\"]},\"239\":{\"h\":\"线程池\"},\"240\":{\"h\":\"线程池的好处\",\"t\":[\"降低资源消耗。通过重复利用已创建的线程来降低线程创建和销毁所带来的消耗。\",\"提高响应速度。当任务到达时，如果有空闲线程，任务可以不需要等到线程创建就直接运行。\",\"提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\"]},\"241\":{\"h\":\"线程池状态\",\"t\":[\"ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量。使用一个AtomicInteger来表示状态和数量，可以通过一次CAS同时更改两个属性的值。\",\"状态名称\",\"高3位的值\",\"描述\",\"RUNNING\",\"111\",\"接收新任务，同时处理任务队列中的任务\",\"SHUTDOWN\",\"000\",\"不接受新任务，但是处理任务队列中的任务\",\"STOP\",\"001\",\"中断正在执行的任务，同时抛弃阻塞队列中的任务\",\"TIDYING\",\"010\",\"任务执行完毕，活动线程为0时，即将进入TERMINATED状态\",\"TERMINATED\",\"011\",\"终结状态\"]},\"242\":{\"h\":\"ThreadPoolExecutor参数\",\"t\":[\"public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) \",\"corePoolSize：核心线程数\",\"maximumPoolSize：最大线程数 \",\"maximumPoolSize - corePoolSize = 救急线程数\",\"救急线程在没有空闲核心线程和任务队列满了的情况下才会创建使用\",\"keepAliveTime：救急线程空闲时的最大空闲时间\",\"unit：时间单位，针对救急线程\",\"workQueue：阻塞队列 \",\"有界阻塞队列：ArrayBlockingQueue\",\"无界阻塞队列：LinkedBlockingQueue\",\"最多只有一个任务的阻塞队列：SynchronizedQueue\",\"优先队列：PriorityBlockingQueue\",\"ThreadFactory：线程工厂（给线程取名字）\",\"handler：拒绝策略（当活动线程数==最大线程数且阻塞队列满的情况下采取的策略）\"]},\"243\":{\"h\":\"拒绝策略\",\"t\":[\"当活动线程数等于最大线程数且阻塞队列满的情况下采取的策略\",\"JDK提供了四种实现\",\"AbortPolicy终止策略：丢弃该任务并抛出RejectedExecutionException异常。这是默认策略\",\"DiscardPolicy丢弃策略：丢弃任务，但是不抛出异常。如果任务队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。\",\"DiscardOldestPolicy弃老策略：丢弃队列最前面的任务，然后重新提交被拒绝的任务\",\"CallerRunsPolicy调用者运行策略：由调用者线程自行处理该任务\"]},\"244\":{\"h\":\"Executors创建的线程池\",\"t\":[\"由Executors类提供的工厂方法来创建线程池！Executors 是Executor 框架的工具类\",\"一般不适用，而是直接使用ThreadPoolExecutor构造方法\",\"newFixedThreadPool\",\"public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(), threadFactory); } \",\"特点\",\"核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间\",\"阻塞队列是无界的，可以放任意数量的任务\",\"适用于任务量已知，相对耗时的任务\",\"newCachedThreadPool\",\"public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"特点\",\"没有核心线程，最大线程数为Integer.MAX_VALUE，所有创建的线程都是救急线程 (可以无限创建)，空闲时生存时间为60秒\",\"阻塞队列使用的是SynchronousQueue \",\"SynchronousQueue是一种特殊的队列 \",\"没有容量，没有线程来取是放不进去的\",\"只有当线程取任务时，才会将任务放入该阻塞队列中\",\"整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况\",\"newSingleThreadExecutor\",\"public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"使用场景：\",\"希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。 任务执行完毕，这唯一的线程也不会被释放。\",\"区别： \",\"和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而newSingleThreadExecutor线程池还会新建一个线程，保证池的正常工作\",\"Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 \",\"FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法\",\"和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改\"]},\"245\":{\"h\":\"执行 execute()方法和 submit()方法的区别是什么呢？\",\"t\":[\"就像runnable()和callable()的区别，submit()有返回值返回一个Future的对象。\"]},\"246\":{\"h\":\"线程池创建多少线程合适\",\"t\":[\"下面两点只是纯理论说法，具体个数要是需要测试得到\",\"CPU密集型\",\"通常采用 cpu 核数 + 1 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费\",\"IO密集型\",\"CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。通过CPU的利用率计算得到。\"]},\"247\":{\"h\":\"ThreadLocal\",\"t\":[\"ThreadLocal是Java所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任何时刻，任意方法中获取缓存的数据\",\"ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值\",\"如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key，value也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象就不会被回收，从而出现内存泄漏，解决办法是，当使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。\"]},\"248\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"CopyOnWriteArrayList是java.util.concurrent包提供的方法，它实现了读操作无锁，写操作则通过操作操作底层数组的新副本来实现（将之前的ArrayList拷贝一份，写操作在该副本上进行，在完成写之前，需要对写加锁，写操作完成后，将有来的引用指向新副本），是一种读写分离的并发策略。\",\"CopyOnWrite并发容器适用于对于绝大部分访问都是读，且只是偶尔写的并发场景。\",\"get弱一致性\"]},\"249\":{\"h\":\"ConcurrentHashMap\",\"t\":[\"一下都是基于JDK 8\",\"对于JDK 1.7而言，ConcurrentHashMap和HashMap都是基于数组和链表实现的。不同在于ConcurrentHashMap有大数组和小数组，大数组就是Segment数组，小数组是HashEntry数组。Segment继承了ReentranceLock，因此具有可重入锁的特性，这样的话就可以保证多线程同时访问的线程安全问题。ConcurrentHashMap的线程安全是基于Segment加锁的基础上。\",\"对于JDK 1.8而言，CoucurrentHashMap和HashMap的实现方式都是一样的，都是基于Node数组+链表+红黑树。当链表长度大于8并且Node数组长度大于64的时候，链表就会转换为红黑树。它的线程安全是由CAS+volatile和synchronized来实现的。比如在put操作中，如果链表头节点为空，则通过CAS创建链表头节点，如果链表头节点不为空则通过synchronized来加锁遍历链表。这样加锁的好处是对于链表头节点加锁，相比于对Segment加锁，锁的粒度更小，并发性能大大提升。\",\"重要属性和内部类\",\"// 默认为0 // 当初始化时，为-1 // 当扩容是，为-(1 + 扩容线程数) // 当初始化或扩容完成后，为下一次扩容的阈值大小 private transient volatile in sizeCtl; // 整个ConcurrentHashMap就是一个Node[] static class Node<K, V> implements Map.Entry<K, V> {} // hash表 transient volatile Node<K, V>[] table; // 扩容时 新的 hash表 private transient volatile Node<K, V>[] nextTable; // 扩容时如果某个bin迁移完毕，用FordwardingNode作为旧table bin的头节点 static final class ForwardingNode<K, V> extends Node<K, V> {} // 用在compute以及computeIfAbsent时，用来占位，计算完成后替换为普通Node static final class ReservationNode<K, V> extends Node<K, V> {} // 作为treebin（红黑树）的头节点，存储root和first static final class TreeBin<K, V> extends Node<K, V> {} // 作为treebin的节点，存储parent，left，right static final class TreeNode<K, V> extends Node<K, V> {} \",\"ForwardingNode的理解\",\"ForwardingNode出现在扩容时，下图是旧的hash表，从右向左迁移bin，该节点迁移完成后加入ForwardingNode作为当前节点的头节点。如果在扩容过程中其他线程来get，get到了ForwardingNode，那么这个线程就回到新的链表中get。如果扩容过程中，其他线程来put，put到了ForwardingNode，此时会帮忙扩容。\",\"构造器分析\",\"实现了懒惰初始化，在构造方法中仅仅计算了table的大小，以后在第一次使用时才会真正创建。\",\"public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) { if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0) throw new IllegalArgumentException(); if (initialCapacity < concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); // tableSizeFor是为了保证计算的大小是2^n int cap = (size >= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap; } \",\"get流程\",\"全程没有加锁\",\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // spread方法能保证返回结果是正数 int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 如果头节点已经是要查找的key if ((eh = e.hash) == h) { if ((ek = e.key) == key || (ek != null && key.equals(ek))) return e.val; } // hash为负数表示该bin在扩容中或是treebin，这时调用find方法来查找 else if (eh < 0) return (p = e.find(h, key)) != null ? p.val : null; // 正常遍历链表，用equals来比较 while ((e = e.next) != null) { if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; } \",\"put流程\",\"public V put(K key, V value) { return putVal(key, value, false); } /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // spread方法会综合高位地位，具有更好的hash性 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { // f是链表头节点 // fh是链表头结点的hash // i是链表在table中的下标 Node<K,V> f; int n, i, fh; //要创建table if (tab == null || (n = tab.length) == 0) // 初始化table使用了cas，无需synchronized创建成功，进入下一轮循环 tab = initTable(); // 要创建链表头节点 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 添加链表头节点使用了cas，无需synchronized if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) break; // no lock when adding to empty bin } // 帮忙扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else { V oldVal = null; // 锁住链表头节点 synchronized (f) { // 再次确认链表头节点没有被移动 if (tabAt(tab, i) == f) { // 链表 if (fh >= 0) { binCount = 1; // 遍历链表 for (Node<K,V> e = f;; ++binCount) { K ek; // 找到相同的key if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { oldVal = e.val; // 更新 if (!onlyIfAbsent) e.val = value; break; } Node<K,V> pred = e; // 已经是最后的节点了，新增Node，追加至链表尾 if ((e = e.next) == null) { pred.next = new Node<K,V>(hash, key, value, null); break; } } } // 红黑树 else if (f instanceof TreeBin) { Node<K,V> p; binCount = 2; // putTreeVal会看key是否已经在树中，是，则返回对应的TreeNode if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { oldVal = p.val; if (!onlyIfAbsent) p.val = value; } } } } if (binCount != 0) { if (binCount >= TREEIFY_THRESHOLD) // 如果链表长度大于等于阈值8，进行链表转为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; } } } // 增加size计数，其中用到的原理和LongAdder差不多使用了Cell[]，设置了多个累加单元 addCount(1L, binCount); return null; } \",\"size计算流程\",\"size计算实际发生在put，remove改变集合元素的操作之中\",\"没有竞争发生，向baseCount累加计数\",\"有竞争发生，新建counterCells，象棋中的一个cell累加计数 \",\"counterCells初始有两个cell\",\"如果技术竞争比较激烈，会创建新的cell来累加计数\"]},\"250\":{\"h\":\"AQS\",\"t\":[\"以下是面向面试\",\"基于死磕 java同步系列之AQS终篇改编\"]},\"251\":{\"h\":\"AQS是什么\",\"t\":[\"AQS的全称是AbstractQueuedSynchronizer，是一个抽象类。它为Java中大部分锁和同步器提供一个基础框架，其中运用了设计模式中的模板方法。像ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch都继承了该抽象类。\"]},\"252\":{\"h\":\"状态变量state\",\"t\":[\"AQS中定义了一个状态变量state，它有以下两种使用方法：\",\"互斥锁\",\"当AQS只实现为互斥锁的时候，只要成功地通过CAS操作将state的值从0变为1就获取了锁，可重入是通过不断通过CAS操作将state的值+1实现的。当可重入时，释放锁的时候也需要将state减为0。\",\"互斥锁+共享锁\",\"当AQS需要同时实现为互斥锁+共享锁的时候，低16为存储互斥锁状态，高16位存储共享锁的状态，主要用于实现读写锁，比如ReentrantReadWriteLock。\",\"互斥锁是一种独占锁，每次只允许一个线程独占，且当一个线程独占时，其他线程将无法再获取互斥锁及共享锁，但是它自己可以获取共享锁（意思是互斥锁可以降级为共享锁，比如ReentrantReadWriteLock中的写锁可以降级为读锁）。\",\"共享锁允许同时多个线程占有，只要有一个线程占有了共享锁，所有线程（包括自己）都将无法再获取互斥锁，但是可以获取共享锁\"]},\"253\":{\"h\":\"AQS队列\",\"t\":[\"AQS中维护了一个队列，获取锁失败的线程都将进入到这个队列中排队，等待所释放后唤醒下一个排队的线程。\",\"在互斥模式下唤醒的是下一个线程，如果是互斥锁+共享锁的情况下，比如ReentrantReadWriteLock，唤醒下一个线程后如果发现该线程占有的是共享锁，那么会在队列中再往后判断下一个节点的线程时候占有的是共享锁，如果是共享锁的话会将连着的占有共享锁的线程一同释放，达到一种并发读的效果。\",\"比如下图中t2和t3就占有共享锁，当t1释放锁t2被唤醒后，会连同t3一起唤醒。\"]},\"254\":{\"h\":\"Condition队列\",\"t\":[\"AQS中还有一个非常重要的内部类ConditionObject，它实现了Condition接口，主要用于实现条件锁。\",\"ConditionObject中也维护了一个队列，这个队列主要用于等待条件的成立，当条件成立时，其他线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放后被唤醒。\",\"Condition典型的运用场景是在BlockingQueue中的实现，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。\"]},\"255\":{\"h\":\"模板方法\",\"t\":[\"AQS这个抽象类把模板方法运用地炉火纯青，它里面定义了一系列的模板方法，比如下面这些：\",\"// 获取互斥锁 public final void acquire(int arg) { // tryAcquire(arg)需要子类实现 if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } // 获取互斥锁可中断 public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // tryAcquire(arg)需要子类实现 if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } // 获取共享锁 public final void acquireShared(int arg) { // tryAcquireShared(arg)需要子类实现 if (tryAcquireShared(arg) < 0) doAcquireShared(arg); } // 获取共享锁可中断 public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // tryAcquireShared(arg)需要子类实现 if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); } // 释放互斥锁 public final boolean release(int arg) { // tryRelease(arg)需要子类实现 if (tryRelease(arg)) { Node h = head; if (h != null && h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } // 释放共享锁 public final boolean releaseShared(int arg) { // tryReleaseShared(arg)需要子类实现 if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } \",\"需要子类实现的方法\",\"上面一起学习了AQS中几个重要的模板方法，下面我们再一起学习下几个需要子类实现的方法：\",\"// 互斥模式下使用：尝试获取锁 protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } // 互斥模式下使用：尝试释放锁 protected boolean tryRelease(int arg) { throw new UnsupportedOperationException(); } // 共享模式下使用：尝试获取锁 protected int tryAcquireShared(int arg) { throw new UnsupportedOperationException(); } // 共享模式下使用：尝试释放锁 protected boolean tryReleaseShared(int arg) { throw new UnsupportedOperationException(); } // 如果当前线程独占着锁，返回true protected boolean isHeldExclusively() { throw new UnsupportedOperationException(); } \",\"这几个方法为什么不直接定义成抽象方法呢？\",\"因为子类只要实现这几个方法中的一部分就可以实现一个同步器了，所以不需要定义成抽象方法。\"]},\"256\":{\"h\":\"ReentrantLock\",\"t\":[\"ReentrantLock是基于Lock接口和AQS抽象类实现的可重入锁。\"]},\"257\":{\"h\":\"ReentrantLock与Synchronized的区别\"},\"258\":{\"h\":\"ReentrantLock的公平锁和非公平锁\",\"t\":[\"ReentrantLock的非公平体现在，当线程想要获取锁时，先通过两次CAS操作去争抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。对于队列中的线程是公平的，因为AQS中队列满足FIFO的特性。\",\"非公平锁在调用lock方法后，首先会调用CAS进行一次抢锁，如果这个时候锁恰好没有被占用，那么就直接获取到锁返回了\",\"非公平锁在CAS失败后，和公平锁一样都会进入到tryAcquire方法，在tryAcquire方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接CAS抢锁，但是公平锁会判断队列中是否有线程处于等待状态，如果有则不去抢锁，主动加入到队列等待唤醒。\",\"公平锁和非公平锁就这两点区别，如果两次CAS都不成功，那么后面公平锁和非公平锁是一样的，都要进入队列等待唤醒。\",\"相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获得锁的时间变得更加不确定，可能导致队列中的线程长期处于饥饿状态。\"]},\"259\":{\"h\":\"ReentrantReadWriteLock\",\"t\":[\"ReentrantReadWriteLock是一种读写锁，用于实现并发读。\",\"写锁可以降级为读锁，读锁不能升级为写锁。\"]},\"260\":{\"h\":\"StampedLock\",\"t\":[\"该类自JDK 8加入，是为了进一步优化读性能，它的特点是在使用读锁和写锁时都必须配合**【戳】**来使用\",\"加解读锁\",\"long stamp = lock.readLock(); lock.unlockRead(stamp); \",\"加解写锁\",\"long stamp = lock.writeLock(); lock.unlockWrite(stamp); \",\"乐观读，StampedLock支持tryOptimisticRead()方法（乐观读），读取完毕后需要做一次戳校验，如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果检验没通过，需要重新获取读锁，保证数据安全。\",\"long stamp = lock.tryOptimisticRead(); // 验戳 if (!lock.validate(stamp)) { // 锁升级 } \",\"代码模拟StampedLock读和写的过程\",\"// 写过程和普通锁没什么区别，都需要全程加锁 public void write(int new Data) { long stamp = lock.writeLock(); try { // do something this.data = newData; } finally { lock.unlockWrite(stamp); } } \",\"public void read(int readTime) { long stamp = lock.tryOptimisticRead(); // do something if (lock.validate(stamp)) { return data; } // stamp别修改过了，需要进行加读锁 try { stamp = lock.readLock(); // do something return data; } finally { lock.unlockRead(stamp); } } \",\"StampedLock的缺点\",\"为什么StampedLock可以提升并发度的性能，但是不能取代ReentrantLock\",\"不支持条件变量\",\"不支持可重入\"]},\"261\":{\"h\":\"Semaphore\",\"t\":[\"信号量，用来限制能同时访问共享资源的线程上限\",\"Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多可以有n个线程同时访问。\",\"应用：使用Semaphore限流，在访问高峰期，限制请求线程数量，让请求线程阻塞，高峰期过去再释放许可。\",\"Semaphore的构造函数\",\"public Semaphore(int permits) { sync = new NonfairSync(permits); } NonfairSync(int permits) { super(permits); } Sync(int permits) { setState(permits); } \",\"由代码可以看出，Semaphore传入的参数permits最终设置为state的个数\",\"加锁解锁流程\",\"刚开始，permits(state)为3，并且同时5个线程来获取资源\",\"假设Thread-1，Thread-2，Thread-4 cas 竞争成功，而Thread-0和Thread-3竞争失败，进入AQS队列park阻塞\",\"这时Thread-4释放了锁，状态如下：\",\"接下来Thread-0竞争成功，state再次设置为0，设置自己的head节点，断开原来的head节点，unpark接下来的Thread-3节点，但是由于state=0，因此Thread-3在尝试不成功后再次进入park状态\"]},\"262\":{\"h\":\"CountdownLatch\",\"t\":[\"用来进行线程同步协作，等待所有线程完成倒计时后再恢复运行。\",\"和Semaphore类似，构造函数传入的count值最终都会赋值给state。\",\"public CountDownLatch(int count) { if (count < 0) throw new IllegalArgumentException(\\\"count < 0\\\"); this.sync = new Sync(count); } \",\"比如可以用于王者荣耀玩家加载，只有所有玩家都加载到100%才能开始游戏。\",\"如果需要主线程汇总结果，CountdownLatch就不如future了，主线程通过get方法可以等待其他线程的运行结果，所有线程都运行完了进行汇总。\"]},\"263\":{\"h\":\"Cyclicbarrier\",\"t\":[\"循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置计数个数，每个线程执行到某个需要**“同步”的时刻调用await()方法进行等待，当等待的线程数满足计数个数**时，继续执行。\",\"和CountdownLatch和类似，区别就是在于Cyclibarrier计数变为0后下次再调用可以恢复到初始设定的值。CountdownLatch要想恢复设定值只能重新创建新的CountdownLatch对象。\",\"ExecutorService executorService = Executors.newFixedThreadPool(2); CyclicBarrier bar = new CyclicBarrier(2, () -> { log.debug(\\\"task1 task2 finished\\\"); }); for (int i = 0; i < 3; i++) { // 计数变为0后，下次循环计数重置 executorService.submit(() -> { log.debug(\\\"task1 begin...\\\"); try { bar.await(); // 2 - 1 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); executorService.submit(() -> { log.debug(\\\"task2 begin...\\\"); try { bar.await(); // 1 - 1 } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); } \",\"注意线程池线程数和CyclicBarrier的计数要一样\",\"比如下面这种情况，task1会优先运行2次，这样就不会达到等待统计两个线程运行结束的预期了\",\"ExecutorService executorService = Executors.newFixedThreadPool(3); CyclicBarrier bar = new CyclicBarrier(2, () -> { log.debug(\\\"task1 task2 finished\\\"); }); for (int i = 0; i < 3; i++) { executorService.submit(() -> { log.debug(\\\"task1 begin...\\\"); try { bar.await(); // 2 - 1 Thread.sleep(1000); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); executorService.submit(() -> { log.debug(\\\"task2 begin...\\\"); try { bar.await(); // 1 - 1 Thread.sleep(3000); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } }); } \"]},\"264\":{\"h\":\"数据库开发规范\",\"t\":[\"本文摘录自阿里巴巴Java开发手册MySQL数据库篇，目的是为了加强记忆方便查询\"]},\"265\":{\"h\":\"建表规约\",\"t\":[\"【强制】\",\"表达是否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。\",\"说明：任何字段如果为非负数，必须是unsigned。\",\"正例：表达逻辑删除的字段名is_deleted，1表示删除，0表示未删除。\",\"【强制】\",\"表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\",\"说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。\",\"正例：aliyun_admin, rdc_config, level3_name\",\"反例：AliyunAdmin, rdcConfig, level_3_name\",\"【强制】\",\"表名不使用复数名词。\",\"说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。\",\"【强制】\",\"禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。\",\"【强制】\",\"主键索引名为pk字段名；唯一索引名为uk字段名；普通索引名则为idx字段名。\",\"说明：pk即primary key；uk即unique key；idx即index\",\"【强制】\",\"小数类型为decimal，禁止使用float和double。\",\"说明：float和double在存储的时候，存在精度损失问题，很可能在值比较时，得到不正确的结果。如果存储的数据范围查过decimal的范围，建议将数据拆成整数和小数分开存储。\",\"【强制】\",\"如果存储的字符串长度几乎相等，使用char定长字符串类型。\",\"【强制】\",\"varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它索引效率。\",\"【强制】\",\"表必备三字段：id, gmt_create, gmt_modified。\",\"说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。（其实得根据主键类型进行动态判断）。gmt_create, gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。\",\"【推荐】\",\"表的命名最好是加上“业务名称_表的作用\\\"。\",\"正例：alipay_task / force_project / trade_config\",\"【推荐】\",\"库名与应用名称尽量一致。\",\"【推荐】\",\"如果修改字段含义或对应字段表示的状态追加时，需要及时更新字段注释。\",\"【推荐】\",\"字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\",\"1）不是频繁修改的字段。\",\"2） 不是varchar超长字段，更不能是text字段。\",\"正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。\",\"【推荐】\",\"单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。\",\"说明：如果预计三年后数据量根本达不到这个级别，请不要在创建表时就分库分表。\",\"【参考】\",\"合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\",\"正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。\",\"对象\",\"年龄区间\",\"类型\",\"字节\",\"人\",\"150岁之内\",\"unsigned tinyint\",\"1\",\"龟\",\"数百岁\",\"unsigned smallint\",\"2\",\"恐龙化石\",\"数千万岁\",\"unsigned int\",\"4\",\"太阳\",\"约50亿年\",\"unsigned bigint\",\"8\"]},\"266\":{\"h\":\"索引规约\",\"t\":[\"【强制】\",\"业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。\",\"说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\",\"【强制】\",\"超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。\",\"说明：即使双表join也要注意表索引、SQL性能。\",\"【强制】\",\"在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。\",\"说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\",\"【强制】\",\"页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\",\"说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\",\"【推荐】\",\"如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。\",\"正例：where a=? and b=? order by c; 索引：a_b_c\",\"反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b无法排序。\",\"【推荐】\",\"利用覆盖索引来进行查询操作，避免回表。\",\"说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。\",\"正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。\",\"【推荐】\",\"利用延迟关联或者子查询优化超多分页场景。\",\"说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。\",\"正例：先快速定位需要获取的id段，然后再关联：\",\"SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id \",\"【推荐】\",\"SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。\",\"说明：\",\"1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2）ref 指的是使用普通的索引（normal index）。 3）range 对索引进行范围检索。\",\"反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。\",\"【推荐】\",\"建组合索引的时候，区分度最高的在最左边。\",\"正例：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。\",\"说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。\",\"【推荐】\",\"防止因字段类型不同造成的隐式转换，导致索引失效。\",\"【参考】\",\"创建索引时避免有如下极端误解： 1）宁滥勿缺。认为一个查询就需要建一个索引。 2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。\"]},\"267\":{\"h\":\"SQL语句\",\"t\":[\"【强制】\",\"不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。\",\"说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。\",\"【强制】\",\"count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。\",\"说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。\",\"【强制】\",\"当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。\",\"正例：可以使用如下方式来避免sum的NPE问题：\",\"SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; \",\"【强制】\",\"使用ISNULL()来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL。\",\"1） NULL<>NULL的返回结果是NULL，而不是false。 2） NULL=NULL的返回结果是NULL，而不是true。 3） NULL<>1的返回结果是NULL，而不是true。\",\"正例：可以使用如下方式来避免sum的NPE问题：\",\"SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; \",\"【强制】\",\"在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。\",\"【强制】\",\"不得使用外键与级联，一切外键概念必须在应用层解决。\",\"说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\",\"【强制】\",\"禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\",\"【强制】\",\"数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。\",\"【推荐】\",\"in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。\",\"【参考】\",\"如果有全球化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。\",\"说明：\",\"SELECT LENGTH(“轻松工作”)； 返回为12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为4 \",\"【参考】\",\"TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。\",\"说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。\"]},\"268\":{\"h\":\"ORM映射\",\"t\":[\"【强制】\",\"在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。\",\"说明：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。\",\"【强制】\",\"POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。\",\"说明：参见定义POJO类以及数据库字段定义规定第8条，在POJO类中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。\",\"【强制】\",\"不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。\",\"说明：配置映射关系，使字段与DO类解耦，方便维护。\",\"【强制】\",\"sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。\",\"【强制】\",\"iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。\",\"说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。\",\"正例：\",\" Map<String, Object> map = new HashMap<String, Object>(); map.put(\\\"start\\\", start); map.put(\\\"size\\\", size); \",\"【强制】\",\"不允许直接拿HashMap与Hashtable作为查询结果集的输出。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【强制】\",\"更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【推荐】\",\"不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。\",\"说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。\",\"【参考】\",\"@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\",\"【参考】\",\"<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。\"]},\"269\":{\"h\":\"数据结构\"},\"270\":{\"h\":\"红黑树\",\"t\":[\"节点是红色或黑色\",\"根节点是黑色\",\"每个叶子节点都是黑色的空节点（NIL节点）\",\"每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红节点）\",\"从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\",\"img\"]},\"271\":{\"h\":\"布隆过滤器\",\"t\":[\"布隆过滤器\"]},\"272\":{\"h\":\"什么是布隆过滤器\",\"t\":[\"首先，我们需要了解布隆过滤器的概念。\",\"布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。\",\"布隆过滤器示意图\",\"位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\",\"总结：一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。\"]},\"273\":{\"h\":\"布隆过滤器的原理介绍\",\"t\":[\"当一个元素加入布隆过滤器中的时候，会进行如下操作：\",\"使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\",\"根据得到的哈希值，在位数组中把对应下标的值置为 1。\",\"当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：\",\"对给定元素再次进行相同的哈希计算；\",\"得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"举个简单的例子：\",\"布隆过滤器hash计算\",\"如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。\",\"如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\",\"不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。\",\"综上，我们可以得出：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\"]},\"274\":{\"h\":\"布隆过滤器使用场景\",\"t\":[\"判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。\",\"去重：比如爬给定网址的时候对已经爬取过的 URL 去重。\"]},\"275\":{\"h\":\"SDS\",\"t\":[\"Redis 数据结构 | 小林coding (xiaolincoding.com)\",\"字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。\",\"Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。\",\"既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。\",\"要了解这一点，得先来看看 char* 字符数组的结构。\"]},\"276\":{\"h\":\"C 语言字符串的缺陷\",\"t\":[\"C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。\",\"比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：\",\"img\",\"没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\\\\0”？\",\"在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\\\\0”表示，意思是指字符串的结束。\",\"因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\\\\0” 来决定要不要停止操作，如果当前字符不是 “\\\\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\\\\0” 是则说明字符串结束了，就要停止操作。\",\"举个例子，C 语言获取字符串长度的函数 strlen，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\\\\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：\",\"img\",\"很明显，C 语言获取字符串长度的时间复杂度是 O（N）（*这是一个可以改进的地方*）\",\"C 语言字符串用 “\\\\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\\\\0” 字符，这时在操作这个字符串时就会提早结束，比如 “xiao\\\\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：\",\"img\",\"因此，除了字符串的末尾之外，字符串里面不能含有 “\\\\0” 字符，否则最先被程序读入的 “\\\\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，不能保存像图片、音频、视频文化这样的二进制数据（*这也是一个可以改进的地方*）\",\"另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。\",\"举个例子，strcat 函数是可以将两个字符串拼接在一起。\",\"//将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src); \",\"C 语言的字符串是不会记录自身的缓冲区大小的，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（*这是一个可以改进的地方*）。\",\"而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，对字符串的操作效率不高。\",\"好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：\",\"获取字符串长度的时间复杂度为 O（N）；\",\"字符串的结尾是以 “\\\\0” 字符标识，字符串里面不能包含有 “\\\\0” 字符，因此不能保存二进制数据；\",\"字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；\",\"Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。\"]},\"277\":{\"h\":\"SDS 结构设计\",\"t\":[\"下图就是 Redis 5.0 的 SDS 的数据结构：\",\"img\",\"结构中的每个成员变量分别介绍下：\",\"len，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。\",\"alloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。\",\"flags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。\",\"buf[]，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。\",\"总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。\",\"O（1）复杂度获取字符串长度（这也可以说是Redis为什么快的一个原因）\",\"C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。\",\"而 Redis 的 SDS 结构因为加入了 len 成员变量，那么获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）。\",\"二进制安全\",\"因为 SDS 不需要用 “\\\\0” 字符来标识字符串结尾了，而是有个专门的 len 成员变量来记录长度，所以可存储包含 “\\\\0” 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\\\\0” 字符。\",\"因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。\",\"通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。\",\"不会发生缓冲区溢出\",\"C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。\",\"所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 alloc - len 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。\",\"而且，当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容），以满足修改所需的大小。\",\"在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。\",\"这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，有效的减少内存分配次数。\",\"所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。\",\"节省内存空间\",\"SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。\",\"Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。\",\"这 5 种类型的主要区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同。\",\"比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：\",\"struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; uint16_t alloc; unsigned char flags; char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; uint32_t alloc; unsigned char flags; char buf[]; }; \",\"可以看到：\",\"sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。\",\"sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。\",\"之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间。比如，在保存小字符串时，结构头占用空间也比较少。\",\"除了设计不同类型的结构体，Redis 在编程上还使用了专门的编译优化来节省内存空间，即在 struct 声明了 __attribute__ ((packed)) ，它的作用是：告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐。\",\"比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。\",\"举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：\",\"#include <stdio.h> struct test1 { char a; int b; } test1; int main() { printf(\\\"%lu\\\\n\\\", sizeof(test1)); return 0; } \",\"大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。\",\"img\",\"这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。\",\"如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 __attribute__ ((packed)) 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。\",\"比如，我用 __attribute__ ((packed)) 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：\",\"#include <stdio.h> struct __attribute__((packed)) test2 { char a; int b; } test2; int main() { printf(\\\"%lu\\\\n\\\", sizeof(test2)); return 0; } \",\"这时打印的结果是 5（1 个字节 char + 4 字节 int）。\",\"img\",\"可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。\"]},\"278\":{\"h\":\"压缩列表\",\"t\":[\"Redis 数据结构 | 小林coding (xiaolincoding.com)\",\"压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。\",\"但是，压缩列表的缺陷也是有的：\",\"不能保存过多的元素，否则查询效率就会降低；\",\"新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。\",\"因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。\"]},\"279\":{\"h\":\"压缩列表结构设计\",\"t\":[\"压缩列表是 Redis 为了节约内存而开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。\",\"img\",\"压缩列表在表头有三个字段：\",\"zlbytes，记录整个压缩列表占用对内存字节数；\",\"zltail，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；\",\"zllen，记录压缩列表包含的节点数量；\",\"zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。\",\"在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素。\",\"另外，压缩列表节点（entry）的构成如下：\",\"img\",\"压缩列表节点包含三部分内容：\",\"prevlen，记录了「前一个节点」的长度；\",\"encoding，记录了当前节点实际数据的类型以及长度；\",\"data，记录了当前节点的实际数据；\",\"当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的。\",\"分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。\",\"压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：\",\"如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；\",\"如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；\",\"encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：\",\"如果当前节点的数据是整数，则 encoding 会使用 1 字节的空间进行编码。\",\"如果当前节点的数据是字符串，根据字符串的长度大小，encoding 会使用 1 字节/2字节/5字节的空间进行编码。\"]},\"280\":{\"h\":\"连锁更新\",\"t\":[\"压缩列表除了查找复杂度高的问题，还有一个问题。\",\"压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。\",\"前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：\",\"如果前一个节点的长度小于 254 字节，那么 prevlen 属性需要用 1 字节的空间来保存这个长度值；\",\"如果前一个节点的长度大于等于 254 字节，那么 prevlen 属性需要用 5 字节的空间来保存这个长度值；\",\"现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：\",\"img\",\"因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。\",\"这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：\",\"img\",\"因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。\",\"多米诺牌的效应就此开始。\",\"img\",\"e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。\",\"正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展.... 一直持续到结尾。\",\"这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下....，\"]},\"281\":{\"h\":\"压缩列表的缺陷\",\"t\":[\"空间扩展操作也就是重新分配内存，因此连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能。\",\"所以说，虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题。\",\"因此，压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的。\",\"虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。\"]},\"282\":{\"h\":\"前缀树（字典树）\",\"t\":[\"public class Trie { public static class TrieNode { // count表示以当前单词结尾的单词数量 int count; // prefix表示以该处节点之前的字符串为前缀的单词数量（包括当前节点） int prefix; TrieNode[] nextNode = new TrieNode[26]; public TrieNode() { count = 0; prefix = 0; } } //插入一个新单词 public static void insert(TrieNode root, String str) { if (root == null || str.length() == 0) { return; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，创建一个新节点 if (root.nextNode[c[i] - 'a'] == null) { root.nextNode[c[i] - 'a'] = new TrieNode(); } root = root.nextNode[c[i] - 'a']; root.prefix++;//注意，应该加在后面 } //以该节点结尾的单词数+1 root.count++; } //查找该单词是否存在，如果存在返回数量，不存在返回-1 public static int search(TrieNode root, String str) { if (root == null || str.length() == 0) { return -1; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，表名该单词不存在 if (root.nextNode[c[i] - 'a'] == null) { return -1; } //如果存在，则继续向下遍历 root = root.nextNode[c[i] - 'a']; } //如果count==0,也说明该单词不存在 if (root.count == 0) { return -1; } return root.count; } //查询以str为前缀的单词数量 public static int searchPrefix(TrieNode root, String str) { if (root == null || str.length() == 0) { return -1; } char[] c = str.toCharArray(); for (int i = 0; i < str.length(); i++) { //如果该分支不存在，表名该单词不存在 if (root.nextNode[c[i] - 'a'] == null) { return -1; } //如果存在，则继续向下遍历 root = root.nextNode[c[i] - 'a']; } return root.prefix; } public static void main(String[] args) { TrieNode newNode = new TrieNode(); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"hello\\\"); insert(newNode, \\\"helloworld\\\"); System.out.println(search(newNode, \\\"hello\\\")); System.out.println(searchPrefix(newNode, \\\"h\\\")); } /** 输出：3 4 **/ } \"]},\"283\":{\"h\":\"二叉树构建\",\"t\":[\"数组转换为二叉树\",\"#include<bits/stdc++.h> using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) { val = x; left = NULL; right = NULL; } }; TreeNode* createTree(vector<int>& vec) { vector<TreeNode*> vecNode; TreeNode* root = NULL; for (int i = 0; i < vec.size(); i++) { TreeNode* node = new TreeNode(vec[i]); if (vec[i] != -1) vecNode.push_back(node); else vecNode.push_back(NULL); if (i == 0) root = node; } for (int i = 0; i * 2 + 2 < vecNode.size(); i++) { if (vecNode[i] != NULL) { vecNode[i] -> left = vecNode[2 * i + 1]; vecNode[i] -> right = vecNode[2 * i + 2]; } } return root; } void preOrder(TreeNode *root) { if (!root) return; cout << root -> val << ' '; preOrder(root -> left); preOrder(root -> right); } void l(TreeNode *root) { if (!root) return; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int len = q.size(); for (int i = 0; i < len; i++) { TreeNode* node = q.front(); q.pop(); cout << node -> val << ' '; if (node -> left) { q.push(node -> left); } if (node -> right) { q.push(node -> right); } } } } int main () { vector<int> vec; int n; cin >> n; for (int i = 0; i < n; i++) { int a; cin >> a; vec.push_back(a); } TreeNode* root = createTree(vec); preOrder(root); cout << endl; print(root); return 0; } \"]},\"284\":{\"h\":\"图的构建\"},\"285\":{\"h\":\"并查集\",\"t\":[\"class UnionFind { private Map<Integer,Integer> father; public UnionFind() { father = new HashMap<>(); } public void add(int x) { if (!father.containsKey(x)) { father.put(x, null); } } public void merge(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY){ father.put(rootX,rootY); } } public int find(int x) { int root = x; while(father.get(root) != null){ root = father.get(root); } while(x != root){ int original_father = father.get(x); father.put(x,root); x = original_father; } return root; } public boolean isConnected(int x, int y) { return find(x) == find(y); } } \"]},\"286\":{\"h\":\"树状数组\",\"t\":[\"聊聊树状数组 Binary Indexed Tree\"]},\"287\":{\"h\":\"单点更新，区间求和\",\"t\":[\"class TreeArray { private int[] tree; private int[] nums; // nums下标从0开始，tree下标从1开始 // 初始化 public TreeArray(int[] nums) { this.tree = new int[nums.length + 1]; this.nums = nums; for (int i = 0; i < nums.length; i++) { add(i + 1, nums[i]); } } // 单点修改 public void update(int index, int val) { add(index + 1, val - nums[index]); nums[index] = val; } // 区间查询 public int sumRange(int left, int right) { return prefixSum(right + 1) - prefixSum(left); } private int lowBit(int x) { return x & -x; } // index位置增加val private void add(int index, int val) { while (index < tree.length) { tree[index] += val; index += lowBit(index); } } // 查询前index位置的前缀和 private int prefixSum(int index) { int sum = 0; while (index > 0) { sum += tree[index]; index -= lowBit(index); } return sum; } } \"]},\"288\":{\"h\":\"如何从海量数据中找出高频词？\",\"t\":[\"如何从海量数据中找出高频词？\"]},\"289\":{\"h\":\"题目描述\",\"t\":[\"假如有一个1G大小的文件，文件里每一行是一个词，每个词的大小不超过16byte，要求返回出现频率最高的100个词。内存大小限制是10M\"]},\"290\":{\"h\":\"解法1（存在问题）\",\"t\":[\"由于内存限制，我们无法直接将大文件的所有词一次性读到内存中。\",\"可以使用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于10M，进而直接将单个小文件读取到内存中处理。\",\"第一步，首先遍历大文件，对遍历到的每个词x，执行 hash(x) % 500，将结果为i的词存放到文件f(i)中，遍历结束后，可以得到500个小文件，每个小文件的大小为2M左右；\",\"第二步，接着统计每个小文件中出现频数最高的100个词。可以使用HashMap来实现，其中key是词，value是该词出现的频率。\",\"对于遍历到的词x，如果在map中不存在，则执行 map.put(x, 1)。\",\"若存在，则执行 map.put(x, map.get(x)+1)，将该词出现的次数加1。\",\"第三步，在第二步中找出了每个文件出现频率最高的100个词之后，通过维护一个小顶堆来找出所有小文件中出现频率最高的100词。\",\"具体方法是，遍历第一个文件，把第一个文件中出现频率最高的100个词构造成小顶堆。\",\"如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构造好有100个结点的小顶堆为止。\",\"继续遍历其他小文件，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整此堆为小顶堆。\",\"当遍历完所有小文件后，这个小顶堆中的词就是出现频率最高的100词。\",\"总结一下，这种解法的主要思路如下：\",\"采用分治的思想，进行哈希取余\",\"使用HashMap统计每个小文件单词出现的频次\",\"使用小顶堆，遍历步骤2中的小文件，找出词频top100的词\",\"但是很容易可以发现问题，在第二步中，如果这个1G的大文件中有某个词词频过高，可能导致小文件大小超过10m。这种情况下该怎么处理呢？\",\"接下来看另外一种解法。\"]},\"291\":{\"h\":\"解法2\",\"t\":[\"第一步：使用多路归并排序对大文件进行排序，这样相同的单词肯定是紧挨着的\",\"多路归并排序对大文件进行排序的步骤如下：\",\"将文件按照顺序切分成大小不超过2m的小文件，总共500个小文件\",\"使用10MB内存分别对 500 个小文件中的单词进行排序\",\"使用一个大小为500大小的堆，对500个小文件进行多路排序，结果写到一个大文件中\",\"其中第三步，对500个小文件进行多路排序的思路如下：\",\"初始化一个小顶堆，大小就是有序小文件的个数500。堆中的每个节点存放每个有序小文件对应的输入流。\",\"按照每个有序文件中的下一行数据对所有文件输入流进行排序，单词小的输入文件流放在堆顶。\",\"拿出堆顶的输入流，并其下一行数据写入到最终排序的文件中，如果拿出来的输入流中还有数据的话，那么将这个输入流再一次添加到栈中。否则说明该文件输入流中没有数据了，那么可以关闭这个流。\",\"循环这个过程，直到所有文件输入流都没有数据为止。\",\"第二步：\",\"初始化一个100个节点的小顶堆，用于保存100个出现频率最多的单词\",\"遍历整个文件，一个单词一个单词的从文件中取出来，并计数\",\"等到遍历的单词和上一个单词不同的话，那么上一个单词及其频率如果大于堆顶的词的频率，那么放在堆中，否则不放\",\"最终，小顶堆中就是出现频率前100的单词了。\",\"解法2相对解法1，更加严谨，如果某个词词频过高或者整个文件都是同一个词的话，解法1不适用。\"]},\"292\":{\"h\":\"华为面经总结\"},\"293\":{\"h\":\"自我介绍\",\"t\":[\"面试官好，我叫赵和月，是南京邮电大学物联网学院的一名研二的学生。就是平时在学习的时候喜欢捣鼓一些东西，就比如自己搭博客并且给博客上了自己的域名，还有在学习大数据的时候自己在电脑上用虚拟机搭了一个有三个节点的Hadoop集群，所以我觉得我的动手能力还算可以。除此之外，我对于知识也有着蛮强烈的好奇心，就比如我除了学习一些Java的相关知识外，像前端方面我也系统了解过JavaScript和Vue以及Vue的组件框架element-ui，像大数据方面我也对Hadoop，MapReduce和Hive等有相关了解。 我也是个很乐观的热，平时喜欢运动，像乒乓球和羽毛球都打得不错。我的自我介绍结束了，很希望在贵公司得到一次实习的机会。\"]},\"294\":{\"h\":\"项目名称\",\"t\":[\"《地质灾害影响人群分析系统》\"]},\"295\":{\"h\":\"项目描述\",\"t\":[\"这个项目就是选择人流复杂类型的点位，分析出各类型人员行动规律，对人员行为进行统计分析。\"]},\"296\":{\"h\":\"负责模块\",\"t\":[\"登录模块：实现用户登陆的验证接口。具体实现方式是客户端第一次登陆时输入账号密码以及验证码进行登录，服务端进行账号密码校验，如果校验不通过则会返回账号或密码错误信息。如果成功登陆了就会生成sessionId存在客户端的cookie中，并且在服务器的session对象中存储当前用户登录信息。当客户端下次访问服务器端时，cookie会被自动发送给服务器端，服务器端在cookie中拿到sessionId然后再服务器的session对象中查找sessionId进行验证，验证成功则会直接保持登陆状态。\",\"常驻人口分析模块：统计设备范围内常驻人口数量，并分别按归属地、运营商进行组成数量统计。 \",\"从原始人口数据表中筛选出符合常驻人口条件的去重数据到常住人口表中。就是什么意思呢，就是每天早上6点启动定时任务（定时任务通过@Scheduled注解实现的），假设常驻人口的定义为30天出现20天及以上，就取最近30天的数据进行分析，当IMSI满足最近30天出现20天及以上,计为常驻人口，30、20为初始化数字，可在参数配置模块中进行修改，刚刚说的IMSI就相当于身份证号，对于每个人都是唯一的。\",\"对常驻人口统计完成后需要基于常住人口表统计常驻人口总人数，归属地和运营商数量统计接口，这些具体数据传向前端，前端通过echarts向用户进行可视化展示，比如归属地就选择top10进行饼状图展示，运营商就计算出3个运营商所占比例，也是通过饼状图展示。\",\"除此之外还要实现常驻人口展示的接口，以及常驻人口多条件复合查询接口，比如根据网络制式查询对应的常驻人口或者说更具设备名称以及时间段复合查询满足条件的常驻人口\",\"设备管理模块：支持查看系统已接入设备。当有设备接入时，系统会自动将该设备信息加入数据库，而我做的部分就是进行编写设备展示接口以及设备按条件复合查询接口，具体的实现方式和常驻人口展示类似。\",\"参数配置模块：进行一些定义参数的配置。比如常驻人口定义参数（像可以设置两个参数30天出现20天及以上的，这个30和20就是可以设置的点，前端更改会自动更新数据库的值）还有首页定位参数（就是根据前端select表单的省市区选择，将参数更新至数据库），前端首页的GIS插件的中心点也会自动更新到定位参数的位置。\",\"常驻人口表字段包括：IMSI、设备编号、设备名称、采集时间、归属地、运营商、网络制式等\",\"设备表字段：设备名称、设备类型、设备型号、设备编号、设备位置、所属地区、设备状态、最后一次上号时间\"]},\"297\":{\"h\":\"项目的难点\",\"t\":[\"这是我第一次系统进行合作开发也是第一个Java项目，我觉得我最大的难点就是业务操作不熟练，没有人带，理论知识和实践操作不能有效统一\",\"解决方法就是pull下来别人的代码，看别人代码的编写思路，从别人的代码中进行学习，比如controller层发送给前端的参数如何包装等等~~（用的是mybatisplus的wrapper）~~。\"]},\"298\":{\"h\":\"项目的创新点\",\"t\":[\"从应用角度来说，这个系统就是一个创新，实现了对各类型人员行动规律的分析，在具体的实现技术栈或者实现方法上并没有创新点。\"]},\"299\":{\"h\":\"项目/实习中学到了什么\",\"t\":[\"这种项目就是理论与实践结合的桥梁，通过项目可以有效地将之前学过的知识运用于代码实践。除此之外，业务表达能力以及团队沟通都是能够锻炼的点。\"]},\"300\":{\"h\":\"课题是什么以及创新点\",\"t\":[\"我的课题是将目标检测用于垃圾分类，从2020年开始国家开始逐步推行强制垃圾分类，实施垃圾分类也是为了响应低碳减排的号召。\",\"具体的相关步骤是：输入是与垃圾相关的图片，经过模型，输出带有定位框和具体分类的图片，这只是静态图片阶段，在视频阶段也是一样的，视频的每一帧就相当于一张图片，通过摄像头，可以在屏幕显示实时的定位框和具体分类。目前的一个创新点就是针对锚框anchor提出了一个改进方案，利用基于k-means++的遗传算法生成与真实框更贴切的anchor。（如果再问就说目前正在针对这点写个小论文）\",\"目前一个缺点就是摄像头前面的所有东西都会当成垃圾，目前正在对垃圾和非垃圾的一个阈值判断进行改进。\",\"自己正也开发一个简易的一个系统来实现这么个功能，系统也能作为最后论文的创新点或贡献之一，目前是在web进行的开发，后期可以开发小程序或者app，使之能够在手机等终端上使用。\",\"k-means++：原始K-means算法最开始随机选取数据集中K个点作为聚类中心，而K-means++按照如下的思想选取K个聚类中心：假设已经选取了n个初始聚类中心(0<n<K)，则在选取第n+1个聚类中心时：距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。从原理上也解释的通：聚类中心当然是互相离得越远越好。\"]},\"301\":{\"h\":\"自己的优点\",\"t\":[\"从动手能力和自学能力上入手，还可以从性格冷静，热爱运动等方面拓展\"]},\"302\":{\"h\":\"自己的缺点\",\"t\":[\"之前我在写项目的时候还发现了我没有写注释的习惯，我觉得这是一个挺致命的缺点，这其实也是急功近利的表现，我目前有注意到这点，凡事还是得按部就班来，最近写代码也会刻意注意到这点。\",\"我觉得我的一个缺点就是在学习知识的时候必要要有一个拓扑顺序，就是我在学习一个知识时必须要知道底层原理，不然就记不住。\"]},\"303\":{\"h\":\"你自己最认可的一件事是什么\",\"t\":[\"说优点（对知识的好奇心以及动手能力，知识的广度）\"]},\"304\":{\"h\":\"为什么选择华为\",\"t\":[\"首先是一种由心而生的认同感，华为这个品牌的国民认可度还是很高的。\",\"南邮和华为的渊源，华为最开始是做交换机的，华为的第一台交换机就是看南邮的教科书实现的，每次谈到这点，都会让我这个南邮学子引以为傲。\",\"对华为价值观的认同：华为这个名字的由来是“心系中华，有所作为”也是表现出了华为这种大格局，正向的价值观。\"]},\"305\":{\"h\":\"你对华为有什么了解\",\"t\":[\"华为这个名字的由来是“心系中华，有所作为”也是表现出了华为这种大格局，正向积极的价值观。\",\"华为最开始是做交换机的，华为的第一台交换机就是看南邮的教科书实现的，每次谈到这点，都会让我这个南邮学子引以为傲。\",\"我记得没错的话“艰苦奋斗”是华为的企业价值观之一。其实对于现在，这是个很敏感的话题，尤其是最近几年爆火的996ICU的话题，955也并没有什么错，可我却觉得有点精致利己主义的倾向。这其中其实涉及到了生存和发展的问题，我们大多数人其实都是普通人，如果每周只工作40小时，那么我们只能停留在普通工人的层面，这只是生存，但是想要进一步发展，想要在某个行业有所成就，投入大量时间是必不可少的。\",\"鸿蒙（可以作为一个感兴趣的点）\",\"华为在19年也发布了自己的操作系统鸿蒙，其中涉及到了万物互联，one as all all as on。像平板，手表，手机，智能家电都能配置鸿蒙系统，这也是万物互联的初步实现把。其中我印象比较深的就是鸿蒙的分布式软总线：\",\"分布式软总线是在1+8+N的框架下所提出的，所谓的1+8+N，1指的是手机，8指的是是车机、音箱、耳机、手表/手环、平板、大屏、PC、AR/VR，N指的是其他IOT设备，分布式软总线的提出就是为了解决所有1+8+N设备之间的互联问题。\",\"分布式软总线可以保证设备之间的高可靠和低延迟等等。就比如前两天毕业生照片采集的时候，手机上的小程序可以调用电脑的摄像头和麦克风实现拍照，我觉得这十分有趣。\"]},\"306\":{\"h\":\"最近在看什么书\",\"t\":[\"最近在看《乔布斯传》，看到乔布斯被苹果踢出董事会成立Next和皮克斯那了。不仅仅是乔布斯，技术大佬沃兹我也很喜欢。比如沃兹想让乔布斯在发布会上感谢AppleⅡ团队，可以看出他是个很感性，很看重团队的人。我是最近才喜欢上自传的，可以在自己的生活中体验别人的一生，从主人公的起起落落，其实会有很多感悟。\"]},\"307\":{\"h\":\"未来五年的职业规划\",\"t\":[\"因为我是南京人，很喜欢南京这个地方，未来五年我希望能够留在南京。进入华为也是我一直以来的一个梦想，如果有机会进入华为的话，我会秉持华为艰苦奋斗的企业价值观努力工作，努力向上爬，和贵司一起成长。\"]},\"308\":{\"h\":\"在什么事情来临的时候，你会感到有些紧张？\",\"t\":[\"重大考试或者面试 追问问题 这件事情为什么会让你如此紧张？因为很重视重大考试或者面试当然也重视其结果 面对紧张时，你是如何处理的？ 走到窗边看看风景，想想自己最近的努力，听听音乐。 你都会有哪些行为表现？ 事情的结果如何？ 你现在如何看待此事?\"]},\"309\":{\"h\":\"请你讲一个最近比较烦心的事情。\",\"t\":[\"面试以及课题所带来的压力\",\"追问问题 这件事情的具体情况如何？ 你通过什么方法来调节自己的情绪？ 我从这学期每天都有运动，比如羽毛球，乒乓球和篮球等等，我觉得这不仅可以锻炼身体，还是缓解压力的一个好办法，除此之外听音乐也能舒缓我的情绪。之前没有封校的时候我还会去爬紫金山，这些都是我调节情绪的方式 哪些因素导致你如此担心这件事情？ 担心找不到面试，担心课题出现问题 。 你是否与他人谈论过对此事的担忧，为什么？ 偶尔也会谈起，因为我觉得这能稍微减缓我的压力以及所带来的负面情绪。 其他人对此事的看法是什么？ 或多或少都会感到压力把 你如何看待他们的想法？\"]},\"310\":{\"h\":\"请举例讲述一次你失败的经历。\",\"t\":[\"去年找实习一面被刷 追问问题 当时的具体情况是怎样的？ 说说知识的深度与广度，以及后面看底层啥啥啥的。 你的感受如何？ 为应对当时的局面你做了什么努力？ 你认为是什么原因造成了这样的结果？ 你是如何重建自信的？ 现在回顾此事，你有什么样的总结和反思？\"]},\"311\":{\"h\":\"请讲述这样一次经历：在任务完成的过程中遇到了困难，但通过你的积极应对，最终使问题得以成功解决。\",\"t\":[\"之前的项目因为是第一次啥啥啥的\",\"追问问题\\n当时的情况是怎么样的？ 没有人带，公司也没有人带，靠自己\\n你认为解决困难的关键是什么？ 将理论应用于实践，还有对于项目的理解。\\n你当时是怎样想的？ pull下来别人的代码，看看别人其他模块的思路\\n你采取了哪些具体措施？\\n你的行为对他人有怎样的影响？\\n现在回顾此事，你有什么样的总结和反思？理论与实践以及动手能力\"]},\"312\":{\"h\":\"幂等性\",\"t\":[\"幂等性如何实现？带你了解一波！！！\",\"所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用。用数学语言表达就是f(x)=f(f(x))。\"]},\"313\":{\"h\":\"为什么需要幂等性\",\"t\":[\"在系统高并发的环境下，很有可能因为网络，阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题。总之，就是请求方调用了你的服务，但是没有收到任何的信息，完全懵逼的状态。比如订单的问题，可能会遇到如下的几个问题：\",\"创建订单时，第一次调用服务超时，再次调用是否产生两笔订单？\",\"订单创建成功去减库存时，第一次减库存超时，是否会多扣一次？\",\"订单支付时，服务端扣钱成功，但是接口反馈超时，此时再次调用支付，是否会多扣一笔呢？\",\"作为消费者，前两种能接受，第三种情况就MMP了，哈哈哈！！！这种情况一般有如下两种解决方式：\",\"服务方提供一个查询操作是否成功的api，第一次超时之后，调用方调用查询接口，如果查到了就走成功的流程，失败了就走失败的流程。\",\"另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致。\"]},\"314\":{\"h\":\"HTTP的幂等性\",\"t\":[\"GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。\",\"HEAD：本质上和GET一样，获取头信息，主要是探活的作用，具有幂等性。\",\"OPTIONS：获取当前URL所支持的方法，因此也是具有幂等性的。\",\"DELETE：用于删除资源，有副作用，但是它应该满足幂等性，比如根据id删除某一个资源，调用方可以调用N次而不用担心引起的错误（根据业务需求而变）。\",\"PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据id更新数据，调用多次和N次的作用是相同的（根据业务需求而变）。\",\"POST：用于添加资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。\"]},\"315\":{\"h\":\"幂等性的实现方式\",\"t\":[\"对于客户端交互的接口，可以在前端拦截一部分，例如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是前端进行拦截器显然是针对普通用户，懂点技术的都可以模拟请求调用接口，所以后端幂等性很重要。\",\"后端的幂等性如何实现？将会从以下几个方面介绍。\",\"数据库去重表\",\"在往数据库中插入数据的时候，利用数据库唯一索引特性，保证数据唯一。比如订单的流水号，也可以是多个字段的组合。\",\"状态机\",\"很多业务中多有多个状态，比如订单的状态有提交、待支付、已支付、取消、退款等等状态。后端可以根据不同的状态去保证幂等性，比如在退款的时候，一定要保证这笔订单是已支付的状态。\",\"TOKEN机制\",\"针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用Token的机制实现防止重复提交。\",\"TOKEN机制如何实现？简单的说就是调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作，流程如下图：\",\"TOKEN机制实现接口幂等性\",\"主要的流程步骤如下：\",\"客户端先发送获取token的请求，服务端会生成一个全局唯一的ID保存在redis中，同时把这个ID返回给客户端。\",\"客户端调用业务请求的时候必须携带这个token，一般放在请求头上。\",\"服务端会校验这个Token，如果校验成功，则执行业务。\",\"如果校验失败，则表示重复操作，直接返回指定的结果给客户端。\",\"通过以上的流程分析，唯一的重点就是这个全局唯一ID如何生成，在分布式服务中往往都会有一个生成全局ID的服务来保证ID的唯一性，但是工程量和实现难度比较大，UUID的数据量相对有些大，可以选择雪花算法生成全局唯一ID。\"]},\"316\":{\"h\":\"Java基础\"},\"317\":{\"h\":\"接口和抽象类有什么共同点和区别\",\"t\":[\"共同点：\",\"都不能被实例化\",\"都可以包含抽象方法\",\"都可以有默认的实现方法（Java 8可以用default关键字在接口中定义默认方法）\",\"区别：\",\"接口主要用于对类的行为进行约束，实现了某个接口就有了相应的行为。抽象类主要用于代码复用，强调的是所属关系\",\"一个类只能继承一个抽象类，但是能实现多个接口\",\"接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值。\"]},\"318\":{\"h\":\"equals和hashcode\",\"t\":[\"equals和hashCode都是Object类中的方法。hashCode是为了获取对象的哈希码，这个哈希码的作用是确定对象在哈希表中的索引位置\",\"举个HashSet插入对象的例子，HashSet首先会根据对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值进行比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。我们这样可以大大减少了equals的次数，相应就大大提高了执行速度。\"]},\"319\":{\"h\":\"==与equals的区别\",\"t\":[\"对于基本类型来说，==比较的是值是否相等\",\"对于引用类型来说，==比较的是两个引用是否指向同一个对象地址\",\"对于引用类型来说，equals方法如果没有被重写，equals与==作用一样，如果重写了，比如String则比较的具体内容是否相等。\"]},\"320\":{\"h\":\"包装类型的常量池技术\",\"t\":[\"Byte,Short,Integer,Long这四种包装类默认创建了数值[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True/False\"]},\"321\":{\"h\":\"自动装箱与自动拆箱\",\"t\":[\"装箱： 将基本类型用他们的引用类型包装起来，调用包装类的valueOf()方法\",\"拆箱： 将包装类型转换为基本数据类型，调用了xxxValue()方法\",\"Integer i = 10; // 自动装箱 int n = i; // 自动拆箱 \"]},\"322\":{\"h\":\"ArrayList和LinkedList的区别\",\"t\":[\"是否保证线程安全：ArrayList和LinkedList都是不同步的，也就是都不保证线程安全\",\"ArrayList底层采用的是Object数组，LinkedList采用的是双向链表（JDK 1.6之前采用的是双向循环链表，JDK 1.7取消了循环）\",\"数组和链表在插入删除方面的区别（注意两种结构都需要考虑是在中间操作还是在两端操作）\",\"数组支持随机访问，链表不支持随机访问\"]},\"323\":{\"h\":\"ArrayList的扩容机制\",\"t\":[\"new的时候可以给ArrayList设置数组的长度值，也可以不设置，不设置的情况下，在第一次add时会默认赋值长度为10\",\"每次add操作都会对比add后的长度值与数组原有的长度值，判断是否要扩容\",\"如果需要扩容，默认1.5倍长度进行扩容，先会去创造一个新的长度的数组，再将原来数组赋值过去，完成扩容操作\",\"扩容的时候还是会将扩容后的数据长度与Integer.MAX_VALUE进行对比，以防越界\",\"工作时，我们尽可能给ArrayList一个初始长度，避免扩容操作\"]},\"324\":{\"h\":\"List删除元素问题\",\"t\":[\"java中的fast-fail机制 - r1-12king - 博客园 (cnblogs.com)\",\"List移除元素_肆虐的毛豆的博客-CSDN博客_list删除元素\",\"fail-fast 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。或者一个线程对集合进行删除时也可能会产生。\"]},\"325\":{\"h\":\"Comparable和Comparator的区别\",\"t\":[\"两者都是用于自定义排序的接口\",\"Comparable接口出自java.lang，用compareTo(Object obj)方法来排序\",\"Comparator接口出自java.util，通过compare(Object obj1, Object obj2)来进行排序\"]},\"326\":{\"h\":\"HashSet、LinkedHashSet和TreeSet三者的异同\",\"t\":[\"HashSet、LinkedHashSet和TreeSet都是Set接口的实现类，都能保证数据的唯一性，并且都不是线程安全的\",\"三者的主要区别在于底层数据结构不同，HashSet底层采用的时哈希表（基于HashMap实现），LinkedHashSet底层采用的是链表和哈希表，TreeSet底层采用红黑树\",\"底层数据结构的不同导致应用场景也有所不同。HashSet用于不需要保证元素插入和取出顺序的场景，LinkedHashSet用于保证元素的插入和取出满足FIFO场景，TreeSet用于支持元素的自定义排序场景。\"]},\"327\":{\"h\":\"HashMap的底层实现\",\"t\":[\"JDK 1.8之前链表采用头插法，1.8采用了尾插法\",\"JDK 1.8之前HashMap底层采用的是数组和链表。HashMap通过key的hashcode经过扰动函数后得到hash值，然后通过(n-1)&hash判断当前元素的存放位置（这里n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的hash以及key是否相同，如果相同的话直接覆盖，不相同就通过拉链表解决冲突。\",\"所谓扰动函数指的就是HashMap中的hash方法。目的是为了防止一些实现比较差的hashcode方法，换句话说使用扰动函数之后可以减少碰撞\",\"JDK 1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树之前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\",\"(n-1)&hash的规则决定在扩容后需要对已有元素进行重新hash\"]},\"328\":{\"h\":\"HashMap的扩容机制\",\"t\":[\"针对JDK 1.8\",\"容量（capacity）：hash表数组的大小，默认为16\",\"初始化容量（initial capacity）：创建hash表时指定的初始容量\",\"尺寸（size）：当前hash表中的元素数量\",\"负载（load）：load = size / capacity。负载为0时，表示空的hash表。轻负载的hash表具有冲突少、适宜插入和查询的特点\",\"负载因子（load factor）：决定hash表的最大填满程度（范围是0-1，默认为0.75）\",\"当hash表的负载达到了指定的“负载因子”值时，hash表就会加倍扩容，将原有的对象重新分配，放入新的hash表中，这成为rehashing。rehashing过程很复杂，而且非常消耗性能，所以指定一个合适的“负载因子”值很重要。\"]},\"329\":{\"h\":\"HashMap在JDK 1.7的死链问题\",\"t\":[\"jdk1.7中 hashmap为什么会发生死链?\",\"发生在多线程数组扩容的的情况下\"]},\"330\":{\"h\":\"BIO，NIO，AIO\",\"t\":[\"理解什么是BIO/NIO/AIO\"]},\"331\":{\"h\":\"BIO\",\"t\":[\"BIO基本介绍\",\"Java BIO就是传统的Java IO编程，其相关的类和接口在java.io包下\",\"BIO(Blocking I/O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就会需要启动一个线程来进行处理。如果这个连接不做任何事情就会造成不必要的开销。可以通过线程池进行改善。\",\"BIO模型\",\"BIO问题分析\",\"每个请求都需要创建独立的线程，与对应的客户端进行数据处理\",\"当并发数很大时，需要创建大量的线程来处理连接，系统资源占用较大\",\"连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在Read操作上。或者说连接后无事可做，这些都会造成线程资源的浪费\"]},\"332\":{\"h\":\"NIO\",\"t\":[\"NIO基本介绍\",\"Java NIO全称Java non-blocking IO，指的是JDK提供的新的API。从JDK1.4开始，JAVA提供了一系列改进的I/O的新特性，被统称为NIO，是同步非阻塞的。\",\"NIO相关类都放在了java.nio包下，并对原java.io包中很多类进行了改写\",\"NIO有三大核心部分：Channel（管道）、Buffer（缓冲区）、Selector（选择器）\",\"NIO是面向缓冲区编程的。数据读取到了一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络。\",\"Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到当前可用数据，如果目前没有可用数据时，不会保持线程阻塞，直到数据变为可以读取之前，该线程可以做其他事情。非阻塞写入同理。\",\"BIO模型\",\"NIO三大核心组件\",\"每个Channel对应一个Buffer\",\"一个线程对应一个Selector，一个Selector对应多个Channel\",\"上图反应了有三个Channel注册到了该Selector\",\"程序切换到哪个Channel是由**事件（event）**决定的\",\"Selector会根据不同的事件，在各个通道上切换\",\"Buffer就是一个内存块，底层是有一个数组\",\"数据的读取和写入是通过Buffer（双向的），但是需要flip()切换读写模式。而BIO是单向的，要么是输入流要么是输出流\",\"NIO三大核心组件\",\"Buffer\",\"缓冲区本质上是一个可以读写数据的内存块，可以理解为是一个容器对象（数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录了缓冲区的状态变化情况。\",\"Channel读取或者写入数据必须通过Buffer\",\"Buffer的子类中通过一个对应类型的数组用来存放数据\",\"Buffer常用子类：ByteBuffer,ShortBuffer,CharBuffer,IntBuffer,LongBuffer,DoubleBuffer,FloatBuffer\",\"属性\",\"描述\",\"capacity\",\"容量，即可以容纳的最大数据量；在缓冲区被创建的时候就被指定，无法修改\",\"limit\",\"表示缓冲区的当前终点，不能对缓冲区超过limit的位置进行读写操作，但是limit是可以修改的\",\"position\",\"当前位置，下一个要被读或者写的索引，每次读写缓冲区数据都会改变该值，为下次读写做准备\",\"mark\",\"标记当前position位置，让reset后回到标记位置\",\"Channel\",\"NIO的通道类似于流，但是有如下区别：\",\"通道是双向的可以进行读写，但是流是单向的只能读或者写\",\"通道可以实现异步读写数据\",\"通道可以从缓冲区读取数据，也可以写入数据到缓冲区\",\"常用的Channel有：FileChannel，DatagramChannel，SocketChannel，SocketServerChannel\",\"Selector\",\"Java的NIO使用了非阻塞的I/O方式。可以用一个线程处理若干个客户端连接，就会使用到Selector\",\"Selector能够检测到多个注册通道上是否有事件发生（多个Channel以事件的形式注册到同一个Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理\",\"只有在连接真正有读写事件发生时，才会进行读写，减少了系统开销，并且不必为每个连接都创建一个线程，不用维护多个线程。\",\"避免了多线程之间上下文切换导致的开销。\"]},\"333\":{\"h\":\"AIO\",\"t\":[\"JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程时，通常用到两种模式：Reactor和Proactor。Java的NIO就是Reactor，当有事件触发时，服务器得到通知，进行相应的处理。\",\"AIO叫做异步非阻塞IO，引入了异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才会启动线程，特点就是先由操作系统完成后才通知服务端程序启动线程去处理，一般用于连接数较多且连接时长较长的应用。\",\"Reactor和Proactor\",\"两种IO多路复用方案：Reactor和Proactor\",\"Reactor模式是基于同步IO，Proactor模式是和异步IO相关的\"]},\"334\":{\"h\":\"总结\",\"t\":[\"BIO、NIO、AIO使用场景分析\",\"BIO方式适用于连接数较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4之前唯一的选择，程序较为简单容易实现\",\"NIO方式适用于连接数目多且连接比较短的架构，比如聊天服务器等等，JDK1.4开始支持\",\"AIO方式适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用OS参与并发操作，JDK1.7开始支持\",\"NIO、BIO对比\",\"BIO是以流的形式处理数据，而NIO以块（Buffer）的方式处理数据，块IO的效率比流IO高很多\",\"BIO是阻塞的，而NIO是非阻塞的\",\"BIO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector用于监听多个通道事件，因此使用单个线程可以监听多个客户端通道\"]},\"335\":{\"h\":\"JDK8新特性\"},\"336\":{\"h\":\"Lambda\",\"t\":[\"lambda针对函数式接口进行简化编程，相对还算比较容易。\",\"在排序方面比较常用，示例如下：\",\"Collections.sort(employees, (e1, e2) -> { if (e1.getAge() == e2.getAge()) { return e2.getName().compareTo(e1.getName()); } return Integer.compare(e1.getAge(), e2.getAge()); }); \",\"我们还可以自己定义函数式接口完成相关操作，示例如下：\",\"/** * 1 声明函数式接口，接口中声明抽象方法，public String getValue(String str); * 2 声明类 Test，类中编写方法使用接口作为参数，将一个字符串转换成大写并作为方法的返回值。 * 3 再将一个字符串的第 2个和第 4 个索引位置进行截取子串。 **/ public class Test { public static String strHandler(String str, MyFunction t) { return t.getValue(str); } public static void main(String[] args) { String str = \\\"abcdEfG\\\"; String s1 = strHandler(str, s -> s.toUpperCase()); System.out.println(s1); String s2 = strHandler(str, s -> s.substring(2, 5)); System.out.println(s2); } } @FunctionalInterface interface MyFunction { String getValue(String str); } \",\"除此之外，Java拥有四大内置函数式接口，其区别在于参数和返回值有所区别：\",\"Consumer< T > : 消费型接口 void accept(T t); // 产生指定个数整数并放入集合中 Supplier< T > : 供给型接口 T get(); // 处理字符串 Function< T, R > : 函数型接口 R apply(T t); // 将满足条件的字符串添加到集合中去 Predicate< T > : 断言型接口 boolean test(T t); \"]},\"337\":{\"h\":\"Stream\",\"t\":[\"默认有如下数据：\",\"static List<Employee> employees = Arrays.asList( new Employee(\\\"张三\\\", 33, 6666.66, StatusEnum.BUSY), new Employee(\\\"李四\\\", 23, 5555.66, StatusEnum.BUSY), new Employee(\\\"王五\\\", 33, 4444.66, StatusEnum.BUSY), new Employee(\\\"赵六\\\", 43, 3333.66, StatusEnum.BUSY), new Employee(\\\"田七\\\", 53, 2222.66, StatusEnum.BUSY), new Employee(\\\"田七\\\", 53, 2222.66, StatusEnum.BUSY) ); \"]},\"338\":{\"h\":\"筛选与切片\",\"t\":[\"filter-- 接收 Lambda，从流中排除某些元素。\",\"limit-- 截断流，使其元素不超过给定数量。\",\"skip(n)-- 跳过元素，返同一个扔了前n个元素的流。若流中元素不足n个，则返回一个空流。与与limit(n)互补\",\"distinct-- 筛选，通过流所生成元素的hashCode()和equals()去除重复元素\",\"employees.stream() .filter(t -> t.getAge() > 30) .limit(2) .distinct() .forEach(System.out::println); \"]},\"339\":{\"h\":\"映射\",\"t\":[\"map-- 接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素\",\"flatMap-- 接收一个的函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流\",\"public class Test2 { public static void main(String[] args) { List<String> list = Arrays.asList(\\\"aaa\\\", \\\"bbb\\\", \\\"ccc\\\", \\\"ddd\\\"); Stream<Stream<Character>> streamStream = list.stream() .map(Test2::filterCharacters); // {{a,a,a},{b,b,b}...} streamStream.forEach(str -> str.forEach(System.out::println)); System.out.println(\\\"---------------------\\\"); Stream<Character> characterStream = list.stream() .flatMap(Test2::filterCharacters); // {a,a,a,b,b,b...} characterStream.forEach(System.out::println); } private static Stream<Character> filterCharacters(String str) { List<Character> list = new ArrayList<>(); for (Character c : str.toCharArray()) { list.add(c); } return list.stream(); } } \"]},\"340\":{\"h\":\"排序\",\"t\":[\"sorted()-- 自然排序\",\"sorted(Comparator com)-- 定制排序\",\"employees.stream() .sorted(Comparator.comparingInt(Employee::getAge)) .forEach(System.out::println); \"]},\"341\":{\"h\":\"查找与匹配\",\"t\":[\"allMatch-- 检查是否匹配所有元素\",\"anyMatch-- 检查是否至少匹配一个元素\",\"noneMatch-- 检查是否没有匹配所有元素\",\"findFirst-- 返回第一个元素\",\"findAny-- 返回当前流中的任意元素\",\"count-- 返回流中元泰的总个数\",\"max-- 返回流中最大值\",\"min-- 返回流中最小值\",\"boolean b = employees.stream() .noneMatch(s -> s.getStatus().equals(StatusEnum.VOCATION)); System.out.println(b); Optional<Employee> first = employees.stream() .sorted(Comparator.comparingInt(Employee::getAge)) .findFirst(); System.out.println(first.get()); \"]},\"342\":{\"h\":\"规约\",\"t\":[\"reduce(T identity, BinaryOperator) / reduce(BinaryOperator)：可以将流中元素反复结合起来，得到一个值。\",\"List<Integer> list = Arrays.asList(1, 3, 4, 5, 6, 7, 8, 9); // 累加 Integer sum = list.stream() .reduce(0, Integer::sum); System.out.println(sum); // 工资总和 Double allSalary = employees.stream() .map(Employee::getSalary) .reduce(0D, Double::sum); System.out.println(allSalary); DoubleSummaryStatistics dss = employees.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getSum()); \"]},\"343\":{\"h\":\"收集\",\"t\":[\"collect-- 将流转换为其他形式。接收一个Collector接口的实现，用于Stream中元素做汇总的方法。\",\"List<String> names = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); names.forEach(System.out::println); System.out.println(\\\"--------------------------------\\\"); HashSet<String> collect = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); System.out.println(\\\"--------------------------------\\\"); employees.stream() .collect(Collectors.toMap(Employee::getName, Function.identity())) .forEach((k, v) -> { System.out.println(k + \\\" \\\" + v); }); System.out.println(\\\"--------------------------------\\\"); Employee employee = employees.stream() .max(Comparator.comparingDouble(Employee::getSalary)) .get(); System.out.println(employee); Double aDouble = employees.stream() .map(Employee::getSalary) .min(Double::compare) .get(); System.out.println(aDouble); System.out.println(\\\"--------------------------------\\\"); Map<StatusEnum, List<Employee>> collect1 = employees.stream() .collect(Collectors.groupingBy(Employee::getStatus)); System.out.println(collect1); \"]},\"344\":{\"h\":\"JVM\"},\"345\":{\"h\":\"双亲委派机制\",\"t\":[\"工作原理\",\"如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行\",\"如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器\",\"如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制\",\"优点\",\"避免类的重复加载\",\"保护程序安全，防止核心API被随意篡改（比如：java.lang.String)\"]},\"346\":{\"h\":\"沙箱安全机制\",\"t\":[\"比如自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器进行加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java/lang/String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\"]},\"347\":{\"h\":\"使用PC寄存器存储字节码指令地址有什么用呢？\",\"t\":[\"为什么用PC寄存器记录当前线程的执行地址呢\",\"因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪条指令开始继续执行（PC寄存器为什么要设定为线程私有）\",\"JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令\"]},\"348\":{\"h\":\"举例栈溢出的情况\",\"t\":[\"栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM\"]},\"349\":{\"h\":\"方法中定义的局部变量是否线程安全\",\"t\":[\"还得根据变量是基本类型和引用类型两种情况分类讨论\",\"如果只有一个线程操作此数据，则必是线程安全的\",\"如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 \",\"如果对象是在内部产生，并在内部消亡，没有返回到外部，那么他是线程安全的，反之则是线程不安全的。（逃逸分析）\"]},\"350\":{\"h\":\"Minor GC、Major GC、Full GC\",\"t\":[\"JVM在进行GC时，并非每次都对三个内存（新生代、老年代；方法区）区域一起回收，大部分时候回收的都是指新生代\",\"针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）\",\"部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： \",\"新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集\",\"老年代收集（Major GC / Old GC）：只是老年代的垃圾收集 \",\"目前，只有CMS GC会有单独收集老年代的行为\",\"注意，很多时候Major GC会和Full GC混淆使用，需要具体分析是老年代回收还是整堆回收\",\"混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 \",\"目前只有G1 GC会有这种行为\",\"整堆收集（Full GC)：收集整个Java堆和方法区的垃圾收集\"]},\"351\":{\"h\":\"创建对象的方式\",\"t\":[\"new\",\"Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public\",\"Constructor的newInstance(Xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求\",\"使用clone()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()\",\"使用反序列化：从文件中、网络中获取一个对象的二进制流\"]},\"352\":{\"h\":\"创建对象的步骤\",\"t\":[\"判断对象对应的类是否加载、链接、初始化 \",\"虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。\",\"为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。\",\"如果内存规整：指针碰撞\",\"不规整：空闲列表\",\"处理并发安全问题 \",\"采用CAS失败重试、区域加锁保证更新的原子性\",\"每个线程先分配一块TLAB\",\"初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用\",\"设置对象的对象头\",\"执行init方法进行初始化 \",\"在Java程序员的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。因此一般来说（由字节码中是否跟随由invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。\",\"判断对象所对应的类是否加载链接初始化，如果没有则需要在双亲委派模式下对相应的类进行加载。\",\"为对象分配内存。分配内存的方式有碰撞指针和空闲列表，具体使用哪种方式得看内存是否规整，规整的话使用碰撞指针否则使用空闲列表。\",\"内存分配的并发问题 \",\"采用CAS配上失败重试的方式保证操作的原子性。CAS是乐观锁的一种实现方式。\",\"为每个线程分配一块TLAB，TLAB是每个线程独享的，不存在线程安全问题\",\"初始化零值：内存分配完成后虚拟机需要将分配到内存的空间都初始化零值，这一操作保证了对象的实例字段在Java代码中不赋值就可以使用。\",\"设置对象的对象头\",\"执行init方法：在上面的工作都完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但是从Java程序的视角来看，对象创建才刚刚开始。\"]},\"353\":{\"h\":\"对象的内存布局\",\"t\":[\"对象头 \",\"运行时元数据（Mark Word） \",\"哈希值\",\"GC分代年龄\",\"锁状态标志\",\"线程持有的锁\",\"偏向线程ID\",\"偏向时间戳\",\"类型指针（Klass Word）：指向类元数据InstanceKlass，确定该对象所属类型\",\"说明：如果是数组，还需记录数组的长度\",\"实例数据 \",\"说明：对象真正存储的有效数据，包括程序代码中定义的各种类型的字段\",\"对齐填充\"]},\"354\":{\"h\":\"字符串拼接\",\"t\":[\"常量与常量引用的拼接结果在常量池，原理是编译期优化\",\"常量池中不会存在相同内容的变量\",\"拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder\",\"如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为： \",\"如果存在，则返回字符串在常量池中的地址\",\"如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址\"]},\"355\":{\"h\":\"GC大厂面试题\",\"t\":[\"蚂蚁金服\",\"你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？\",\"JVM GC算法有哪些，目前的JDK版本采用什么回收算法？\",\"G1回收器讲下回收过程GC是什么？为什么要有GC？\",\"GC的两种判定方法？CMS收集器与G1收集器的特点\",\"百度\",\"说一下GC算法，分代回收说下\",\"垃圾收集策略和算法\",\"天猫\",\"JVM GC原理，JVM怎么回收内存\",\"CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？\",\"滴滴\",\"Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的\",\"京东\",\"你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，\",\"包括原理，流程，优缺点。垃圾回收算法的实现原理\",\"阿里\",\"讲一讲垃圾回收算法。\",\"什么情况下触发垃圾回收？\",\"如何选择合适的垃圾收集算法？\",\"JVM有哪三种垃圾回收器？\",\"字节跳动\",\"常见的垃圾回收器算法有哪些，各有什么优劣？\",\"System.gc()和Runtime.gc()会做什么事情？\",\"Java GC机制？GC Roots有哪些？\",\"Java对象的回收方式，回收算法。\",\"CMS和G1了解么，CMS解决什么问题，说一下回收的过程。\",\"CMS回收停顿了几次，为什么要停顿两次?\"]},\"356\":{\"h\":\"增量收集算法\",\"t\":[\"基本思想\",\"如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，知道垃圾收集完成。\",\"缺点\",\"使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程和上下文切换的消耗，会使得垃圾回收的总成本上升，造成系统吞吐量的下降。\"]},\"357\":{\"h\":\"System.gc()的理解\",\"t\":[\"在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。\"]},\"358\":{\"h\":\"内存溢出和内存泄漏的原因\",\"t\":[\"内存溢出\",\"Java虚拟机的堆内存设置不够\",\"代码中创建了大量大对象，并且长时间不能被垃圾收集器收集\",\"内存泄漏\",\"单例对象：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。\",\"一些提供close的资源未关闭导致内存泄漏\"]},\"359\":{\"h\":\"评估GC的性能指标\",\"t\":[\"吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间a + 内存回收的时间b）a/(a+b)\",\"垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。\",\"暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。\",\"收集频率：相对于应用程序的执行，收集操作发生的频率。\",\"内存占用：Java堆区所占的内存大小。\",\"快速：一个对象从诞生到被回收所经历的时间。\",\"吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。\",\"这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。\",\"简单来说，主要抓住两点：\",\"吞吐量\",\"暂停时间\"]},\"360\":{\"h\":\"7种经典的垃圾回收器\",\"t\":[\"以串并行分类：\",\"串行回收器：Serial、Serial old\",\"并行回收器：ParNew、Parallel Scavenge、Parallel old\",\"并发回收器：CMS、G1\",\"分代分类：\",\"新生代收集器：Serial、ParNew、Parallel Scavenge；\",\"老年代收集器：Serial old、Parallel old、CMS；\",\"整堆收集器：G1；\",\"垃圾收集器组合关系：\",\"两个收集器间有连线，表明它们可以搭配使用：\",\"Serial/Serial old\",\"Serial/CMS （JDK9废弃）\",\"ParNew/Serial Old （JDK9废弃）\",\"ParNew/CMS\",\"Parallel Scavenge/Serial Old （预计废弃）\",\"Parallel Scavenge/Parallel Old\",\"G1\",\"其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。\",\"（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。\",\"（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）\",\"（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）\",\"为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。\",\"虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。\"]},\"361\":{\"h\":\"垃圾回收器的选择\",\"t\":[\"HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？\",\"如果你想要最小化地使用内存和并行开销，请选Serial GC；\",\"如果你想要最大化应用程序的吞吐量，请选Parallel GC；\",\"如果你想要最小化GC的中断或停顿时间，请选CMS GC。\"]},\"362\":{\"h\":\"JDK 后续版本中 CMS 的变化\",\"t\":[\"JDK9新特性：CMS被标记为Deprecate了（JEP291） \",\"如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。\",\"JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器， \",\"如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM\"]},\"363\":{\"h\":\"MyBatis / MyBatis-Plus\"},\"364\":{\"h\":\"Mybatis\"},\"365\":{\"h\":\"@Param / @RequestBody\",\"t\":[\"发现在dao层方法接口的参数中不用@Param指定参数名称，在xml中也是可以直接用#{}来对参数进行引用，查了很多资料解释是idea进行了预处理，所以即使不报错，也需要在dao层参数名称位置指定具体名称，以免其他开发环境下出现bug。\",\"@RequestBody是对json格式的入参进行处理，将json格式数据封装成具体的vo或者po实体类，目前现在都是前后端分离的项目，前端传过来的参数都是json格式的，所以在controller层实体类型的参数前需要加上@RequestBody注解。\"]},\"366\":{\"h\":\"$和#\",\"t\":[\"#{}相当于占位符，编译时会进行预处理用?替换原来的位置。而${}相当于字符串拼接，不到万不得已不要使用，因为有sql注入的风险。\",\"两种必须要使用${}的情况：\",\"采用in来进行批量删除时只能采用${}进行字符串拼接\",\"String ids = \\\"1,2,3\\\"; \",\"delete from user where id in (${ids}) # 正确写法 # delete from user where id in (#{ids})会被解析成 # delete from user where id in ('1,2,3')，虽然spring执行不报错，但是并不能正确删除 \",\"动态设置表名的问题\",\"select * from #{tableName} # 错误的，表名不能有单引号 # 只能使用${} select * from ${tableName} # 正确写法 \",\"模糊查询时如果使用了#进行sql编写，例如select * from user where name = '%#{name}%'，这种情况占位符?会被当成字符串来处理，sql会变成select * from user where name = '%?%'，因此出现错误。\",\"解决方案：\",\"采用${}来拼接sql\",\"采用mysql自带的concat函数进行拼接\",\"select * from user where name like concat('%', #{name}, '%') \",\"采用双引号进行拼接（最常使用）\",\"select * from user where name like \\\"%\\\"#{name}\\\"%\\\" \",\"如果dao层查询出来的数据没有一个实体类对象与之一一对应，则ResultType可以设置成map，最终将结果相应给前端。\",\"通过association解决多对一映射关系\",\"一般都可以使用分布查询来解决，先通过user_id查询出User完整信息以及role_id，之后通过role_id查询出Role的完整信息，只需要在service中将查询出来的Role封装到User实体类中即可。\",\"假设有如下两张表：\",\" user表 | Role表 ------------------------ user_id | role_id user_name | role_name role_id | \",\"但是User实体类中具有Role实体类：\",\"public class User { private Long userId; private String userName; private Role role; } \",\"通过级联查询将结果直接映射在User实体类中，则需要ResultMap来手动指定映射关系\",\"<ResultMap id=\\\"test\\\" type=\\\"User\\\"> <id properties=\\\"userId\\\" column=\\\"user_id\\\"></id> <id properties=\\\"userName\\\" column=\\\"user_name\\\"></id> <association property=\\\"role\\\" javaType=\\\"Role\\\"> <id properties=\\\"roleId\\\" column=\\\"role_id\\\"></id> <id properties=\\\"roleName\\\" column=\\\"role_name\\\"></id> </association> </ResultMap> <select id=\\\"getUserAndRole\\\" resultMap=\\\"test\\\"> select * from user left join role on user.role_id = role.role_id where user.user_id = #{id} </select> \",\"通过分步查询解决多对一映射关系\",\"优点是可以开启延迟加载\",\"通过在配置文件中指定mybatis.configuration.lazy-loading-enabled=true来手动开启，如果mybatis版本低于3.4.1还需要手动设置mybatis.configuration.aggressiveLazyLoading=false。\",\"当延迟加载开启后，当我们只查询user信息时，调用<select id=\\\"getUserAndRole\\\">则只会执行select * from user where user_id = #{id}的部分，否则级联部分sql语句也会执行。\",\"延迟加载配置是全局开启的，如果想要细粒度控制则需要设置association的fetchType=\\\"eager\\\"，表明该association不开启延迟加载\",\"其中association中的select对应RoleMapper.java的全类名加上对应的方法名，column是分步查询的条件\",\"<!-- RoleMapper.xml --> <select id=\\\"getRole\\\" resultType=\\\"Role\\\"> select * from role where role_id = #{id} </select> <!-- UserMapper.xml --> <ResultMap id=\\\"test\\\" type=\\\"User\\\"> <id properties=\\\"userId\\\" column=\\\"user_id\\\"></id> <id properties=\\\"userName\\\" column=\\\"user_name\\\"></id> <association property=\\\"role\\\" select=\\\"com.vingkin.role.dao.RoleMapper.getRole\\\" column=\\\"role_id\\\"> </association> </ResultMap> <select id=\\\"getUserAndRole\\\" resultMap=\\\"test\\\"> select * from user where user_id = #{id} </select> \",\"通过collection解决一对多映射关系和通过分步查询解决一对多映射关系如上述代码相差不大，故不细加阐述。\"]},\"367\":{\"h\":\"Mybatis分页操作\",\"t\":[\"Mybatis+PageHelper插件即可实现分页操作\"]},\"368\":{\"h\":\"Mybatis动态表模式实现\",\"t\":[\"关键点在于如下拦截器的编写，需要先在业务层中向线程变量存入province属性，然后在拦截其中进行拦截处理。对拦截器代码进行了相关优化，可以自定义属性。比如下面代码，线程变量中如果有province字段，则会与原表名t_user进行拼接，以t_user_province格式回调，以达到动态表名的效果，province字段需要从前端传过来。如果未来业务有其他拼接字段，也都可以进行简单修改即可使用。\",\"@Configuration @MapperScan(\\\"com.vingkin.dynamictable.mapper\\\") public class MybatisPlusConfig { /** * 添加动态表名插件 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor(); dynamicTableNameInnerInterceptor.setTableNameHandler((sql, tableName) -> { // 获取参数方法 Map<String, Object> paramMap = RequestDataHelper.getRequestData(); if (CollectionUtils.isNotEmpty(paramMap)) { // 获取传递的参数 StringBuilder tableNameSuffix = new StringBuilder(); if (ObjectUtils.isNotEmpty(paramMap.get(\\\"province\\\"))) { tableNameSuffix.append(\\\"_\\\").append((String) paramMap.get(\\\"province\\\")); } // 组装动态表名 return tableName + tableNameSuffix; } return tableName; }); interceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor); return interceptor; } } \"]},\"369\":{\"h\":\"Mybatis Plus\"},\"370\":{\"h\":\"前端传来不定条件Mybatis-Plus的解决方案\",\"t\":[\"其wrapper方法中第一个参数为condition，返回true即拼接否则不拼接。\",\"/** * String name; * Integer age; */ public void radomCondition(User user) { QueryWrapper<User> wrapper = new QueryWrapper<>(); // Mybatis-Plus包中的StringUtils wrapper.like(StringUtils.isNotBlank(name), \\\"name\\\", user.getName()) .eq(age != null, \\\"age\\\", user.getAge()); List<User> users = userMapper.selectList(wrapper); } \"]},\"371\":{\"h\":\"函数式SQL\",\"t\":[\"使用LambdaQueryWrapper和LambdaUpdateWrapper替代QueryWrapper和UpdateWrapper。\",\"前两者采用函数式方法获取列名，避免列名出错的情况\",\"// 使用QueryWrapper的情况 QueryWrapper<User> wrapper = new QueryWrapper<>(); queryWrapper.like(StringUtils.isNotBlank(name), \\\"name\\\", user.getName()) .ge(age != null, \\\"age\\\", user.getAge()); // 使用LambdaQueryWrapper的情况 LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>(); queryWrapper.like(StringUtils.isNotBlank(name), User::getName, user.getName()) .ge(age != null, User::getAge, user.getAge()); \"]},\"372\":{\"h\":\"Mybatis-Plus多数据源\",\"t\":[\"引入依赖\",\"<mybatisplus.version>3.5.1</mybatisplus.version> <!-- mybatis-plus --> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>${mybatisplus.version}</version> </dependency> <!-- mybatis-plus多数据源 --> <dependency> <groupId>com.baomidou</groupId> <artifactId>dynamic-datasource-spring-boot-starter</artifactId> <version>${mybatisplus.version}</version> </dependency> \",\"在配置文件中进行配置\",\"spring: # 配置数据源信息 datasource: dynamic: # 设置默认的数据源或者数据源组,datasource1 primary: datasource-mysql # 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: datasource-mysql: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/t_user?serverTimeZone=GMT%2B8&characterEncoding=utf-8&useSSL=false username: root password: 123456 datasource-pgsql: driver-class-name: org.postgresql.Driver url: jdbc:postgresql://localhost:58063/test username: postgres password: 123456 \",\"在业务层实现类方法的类名或方法名上通过@DS(\\\"datasource\\\")指定访问数据源。\",\"@Service @DS(\\\"datasource-mysql\\\") // 在类名上指定使用数据源 public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService{ } \"]},\"373\":{\"h\":\"通过MybatisX插件自动生成代码\",\"t\":[\"MybatisX\"]},\"374\":{\"h\":\"MySQL\"},\"375\":{\"h\":\"说说对MySQL索引的理解\",\"t\":[\"索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有的索引类型。MySQL中索引的存储类型有两种，即BTREE和HASH，具体和表的存储引擎相关。MyISAM和InnoDB的存储引擎只支持BTREE索引，MEMORY存储引擎支持HASH和BTREE索引。\",\"优点：\",\"通过创建唯一索引，可以保证数据库表中每一行数据的唯一性\",\"可以大大加快查询速度，这也是创建索引的主要原因\",\"在实现数据的参考完整性方面，可以加速表和表之间的连接\",\"在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间\",\"缺点：\",\"创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加\",\"索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸\",\"当对表中的数据进行增删改操作的时候，索引也要进行动态维护，这样降低了数据的维护速度\"]},\"376\":{\"h\":\"为了减少IO，索引树会一次性加载吗\",\"t\":[\"数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G\",\"当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的就是逐一加载每个磁盘页（数据页），因为数据页对应着索引树的节点\"]},\"377\":{\"h\":\"B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO（为什么索引使用B+树）\",\"t\":[\"InnoDB存储引擎中页的大小为16 KB，一般表的逐渐类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4-8个字节，也就是说一个页（B+tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值，换算出一页大概能存储1000条数据，深度为3可以存储1000*1000*1000=10亿条数据。。。\"]},\"378\":{\"h\":\"为什么B+树比B树更适合做索引\",\"t\":[\"B+树的磁盘读写代价更低\",\"B+树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。\",\"B+树的查询效率更加稳定\",\"由于非叶节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一数据的查询效率相当。而B-树非叶子节点也存储数据，可能需要中序遍历。\",\"在范围查询上，B+树的效率也比B树高\",\"B+树的关键字都出现在叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成范围查询。\"]},\"379\":{\"h\":\"InnoDB为什么不建议用过长的字段作为主键\",\"t\":[\"所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大\"]},\"380\":{\"h\":\"InnoDB为什么使用自增主键是一个很好的选择\",\"t\":[\"InnoDB数据文件本身是一颗B+树，非单调的主键会造成在插入新纪录时，数据文件为了维持B+树的特性而频繁的分裂调整（页分裂）\"]},\"381\":{\"h\":\"Hash结构效率高，那为什么还要使用B+树索引呢\",\"t\":[\"Hash索引仅能满足 = , <> , IN 查询。如果进行范围查询，哈希索引的时间复杂度会退化为O(n)。而树型的依然能够保持O(log2N)\",\"Hash索引数据存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。\",\"对于联合索引的情况，Hash值是将联合索引键合并起来一起计算的，无法对单独的一个键或者几个索引键进行判断。\",\"对于等值查询来说，通常Hash索引的效率更高，不过当索引列的重复值过多，由于Hash冲突效率就会降低。\"]},\"382\":{\"h\":\"索引的分类\",\"t\":[\"从功能逻辑上说，索引主要有4种，分别是普通索引、唯一索引、主键索引和全文索引\",\"从物理实现方式：聚簇索引和非聚簇索引\",\"作用字段个数：单列索引和联合索引\"]},\"383\":{\"h\":\"哪些情况适合创建索引\",\"t\":[\"字段的数值有唯一性的限制\",\"业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。\",\"频繁作为 WHERE 查询条件的字段\",\"某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。 尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\",\"经常 GROUP BY 和 ORDER BY 的列\",\"索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 对分组或者排序的字段进行索引 。 如果待排序的列有多个，那么可以在这些列上建立 组合索引 。\",\"UPDATE、DELETE 的 WHERE 条件列\",\"对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。 如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\",\"DISTINCT 字段需要创建索引\",\"有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\",\"索引列按递增的顺序 进行排序。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\",\"多表 JOIN 连接操作时，创建索引注意事项\",\"首先， 连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\",\"其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\",\"最后， 对用于连接的字段创建索引，并且该字段在多张表中的 类型必须一致 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\",\"使用列数据类型小的字段创建索引\",\"使用字符串前缀创建索引\",\"【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。\",\"说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。\",\"区分度（散列性）高的适合作为索引\",\"数据相似性大的就不适合建立索引，如：男女性别\",\"使用最频繁的字段放到联合索引左侧\",\"这样也可以较少的建立一些索引。同时，由于\\\"最左前缀原则\\\"，可以增加联合索引的使用率。\",\"在多个字段需要创建索引的情况下，联合索引优于单值\"]},\"384\":{\"h\":\"哪些情况不适合创建索引\",\"t\":[\"在where中使用不到的字段\",\"数据量小的表\",\"有大量重复数据的列\",\"避免经常更新的表创建过多的索引\",\"不建议使用无序的值作为索引\",\"例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。\",\"删除不再使用或很少使用的索引\",\"不要定义冗余或重复的索引。\"]},\"385\":{\"h\":\"索引下推\",\"t\":[\"Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。\",\"示例：\",\"alert table tb_people add index `zip_last_first` (`zipcode`, `lastname`, `firstname`) select * from people where zipcode = '000001' and lastname like '%张%' and address like '%北京市%' \",\"上述添加了一个联合索引。select语句只有zipcode命中了联合索引，lastname因为%开头并不能命中，但是因为联合索引中有lastname，所以会先在联合索引中通过lastname进行过滤，然后再进行回表操作。这就是索引下推。\"]},\"386\":{\"h\":\"EXISTS和IN的区分\",\"t\":[\"如何选择需要看表的大小。小表驱动大表。\",\"比如\",\"select * from A where cc in (select cc from B) select * from A where exists (select cc from B where B.cc = A.cc) \",\"当A小于B时，用EXISTS。因为EXISTS的实现，相当于外表循环，\",\"for i in A for j in B if j.cc == i.cc then... \",\"IN的逻辑\",\"for i in B for j in A if j.cc == i.cc then... \"]},\"387\":{\"h\":\"COUNT(*), COUNT(1)和COUNT(具体字段)\",\"t\":[\"COUNT(*)和COUNT(1)都是对结果进行COUNT，COUNT(*)和COUNT(1)本质上并没有区别。\",\"如果采用的是MyISAM存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张MyISAM的数据表都有一个meta信息存储了row_count的值，而一致性则由表级锁来保证。如果是InnoDB，因为InnoDB支持事务，采用行级锁和MVCC机制，所以无法像MyISAM一样，维护一个row_count变量，因此需要采用扫描全表，O(n)的复杂度。\",\"在InnoDB中如果采用COUNT(具体字段)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引。对于COUNT(*)和COUNT(1)来说，他们不需要查找具体的行，只是统计行数，系统会自动采用占用空间小的二级索引来进行统计。如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。\"]},\"388\":{\"h\":\"关于SELECT(*)\",\"t\":[\"在表查询中，建议明确字段，不要使用 *作为查询的字段列表，推荐受用具体字段查询。\",\"原因：\",\"mysql在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大消耗资源和时间。\",\"无法使用覆盖索引\"]},\"389\":{\"h\":\"多使用COMMIT\",\"t\":[\"只要有可能，在程序中尽量多使用COMMIT，这样程序的性能能够得到提高，需求也会因为COMMIT所释放的资源而减少。\",\"COMMIT所释放的资源：\",\"回滚段上用于恢复数据的信息\",\"被程序语句获得的锁\",\"redo / undo log buffer中的空间\",\"管理上述3种资源种的内部花费\"]},\"390\":{\"h\":\"主键如何设计\"},\"391\":{\"h\":\"自增ID的问题\",\"t\":[\"可靠性不高：存在自增ID回溯的问题，这个问题直到8.0才解决\",\"安全性不高：对外暴露的接口容易暴露信息。比如/User/1\",\"性能差：自增ID的性能较差，需要在数据库服务器端生成\",\"交互多：业务需要二外执行一次类似last_insert_id()的函数才能知道插入的子增值。\",\"局部唯一性：分布式问题\"]},\"392\":{\"h\":\"推荐的主键设计\",\"t\":[\"对于核心业务，主键的设计至少应该是全局唯一且是单调递增。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。推荐使用UUID。\",\"UUID的特点：\",\"全局唯一，占用36字节，数据无序，插入性能差。\",\"UUID如下图所示：\",\"改造UUID\",\"若将时间高低位互换，则时间就是单调递增的了。MySQL8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。\"]},\"393\":{\"h\":\"谈谈你对MVCC的了解\",\"t\":[\"MVCC只存在读已提交和可重复读的情况下，两种情况下生成ReadView的机制不一样。\",\"在读已提交中，每次读操作都会生成一个ReadView所以会出现不可重复读的情况。对于可重复读，在一次事务中，只有第一次读操作会生成ReadView，所以不会出现可重复读，也不会出现幻读。\",\"MySQL事务隔离级别和MVCC - 掘金 (juejin.cn)\",\"InnoDB的默认隔离级别是REPEATABLE READ，RR解决了脏读、不可重复读和幻读的问题。注意不是到了串行化才解决了幻读， RR通过MVCC快照读的思想就已经解决了幻读的问题。（这点有待商榷） MVCC的意思是多版本并发控制。它最大的优点就是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下奇数以及数据结构：\",\"隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id，指向undo log的指针等。\",\"基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。\",\"ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记作事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。\"]},\"394\":{\"h\":\"WHERE和HAVING的区别\",\"t\":[\"WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数\",\"HAVING是一个过滤声明，是在查询结果返回集以后对查询结果进行过滤的操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。\",\"从性能上来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。\"]},\"395\":{\"h\":\"数据库索引失效了怎么办\",\"t\":[\"可以采用一下几种方式，来避免索引失效\",\"使用联合索引时，要遵循“最左前缀”原则\",\"不在索引列上做任何操作，例如计算、函数、类型转换，会导致索引失效而转向全表扫描\",\"尽量使用覆盖索引，减少select *使用能减少回表的次数\",\"MySQL在使用不等于的时候无法使用索引会导致全表扫描\",\"LIKE以通配符开头（%abc）MySQL索引会失效变成全表扫描\",\"字符串不加单引号会导致索引失效（发生了索引列的隐式转换）\",\"少用or，用or会导致索引失效\"]},\"396\":{\"h\":\"事务的四大特性以及如何实现\",\"t\":[\"原子性：原子性指整个数据库事务是不可分割的工作单位。只有事务中的数据库操作都执行成功，整个事务才算执行成功。事务中任何一个SQL语句执行失败，那么之前已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。\",\"一致性：一致性是指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\",\"隔离性：事务与事务之间的操作时互相隔离互不干扰的。\",\"持久性：事务一旦提交，其结果就是永久的，即使发生宕机等故障，数据库也能将数据恢复。\",\"原子性实现原理\",\"实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的SQL语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或者调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。\",\"undo log属于逻辑日志，它记录的是SQL执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。\",\"持久性实现原理\",\"InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，首先会从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中。\",\"Buffer Pool的使用大大提高了读写数据的效率，但是也带来了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。\",\"于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证数据不在因MySQL宕机而丢失，从而满足了持久性要求。\",\"既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘要快呢?\",\"将Buffer Pool中的数据写入磁盘属于随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO\",\"将Buffer Pool中的数据写入磁盘是以数据页为单位进行的，MySQL默认页为16KB，一个页上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。\",\"隔离性实现原理\",\"隔离性追求的是并发情形下事务之间互不干扰。\",\"第一方面，两个事务同时写：锁机制保证隔离性\",\"隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务执行期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。\",\"按照粒度，锁可以分为表锁、行锁以及其他位于二至之间的锁（页锁）。表锁在操作数据时会锁定整张表，并发性能较差。行锁则之锁定需要操作的数据，并发性能好。但是由于加锁本身也需要消耗资源，因此在锁定数据较多的情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且处于性能考虑，绝大多数情况下使用的是行锁。\",\"第二方面，一个事务读，一个事务写时，MVCC保证隔离性\",\"[0x10. 谈谈你对MVCC的了解](#0x10. 谈谈你对MVCC的了解)\",\"一致性实现原理\",\"一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性都是为了保证数据库状态的一致性。此外，除数据库层面的保障，一致性的实现也需要在应用层面进行保障。\"]},\"397\":{\"h\":\"MySQL的悲观锁和乐观锁\",\"t\":[\"悲观锁\",\"悲观锁是一种思想，对数据被其他事务修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排他性。\",\"乐观锁\",\"乐观锁也是一种思想，对数据被其他事务修改持乐观态度，属于小概率事件，不采用数据库本身的锁机制，而是通过程序来实现（CAS）。在程序上，我们可以使用版本号机制或时间戳机制来实现\",\"乐观锁的版本号机制\",\"在表中设计一个版本号字段version，第一次读的时候会获取version的取值。然后对数据进行更新或删除操作时会对当前字段的version进行加一操作。如果此时已经有事务对这条数据进行了更改，修改就不会成功。\",\"乐观锁的时间戳机制\",\"时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。\"]},\"398\":{\"h\":\"根据锁的类型分类\",\"t\":[\"需要注意的是对于InnoDB引擎来说，共享锁和排他锁既可以加在表上，也可以加在行上\",\"共享锁（S Lock）：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，互相不阻塞\",\"排他锁（X Lock）：当前写操作没有完成前，他会阻断其他共享锁和排他锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源\",\"X\",\"S\",\"X\",\"不兼容\",\"不兼容\",\"S\",\"不兼容\",\"兼容\"]},\"399\":{\"h\":\"根据锁的粒度进行分类\",\"t\":[\"可以分为表锁，页锁和行锁\"]},\"400\":{\"h\":\"表锁\",\"t\":[\"意向锁\",\"如果我们给某一行数据加上了排他锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人给它上过排他锁了。\",\"不这么做的话，想上锁的那个事务需要遍历有没有行锁。\",\"意向共享锁：事务有意向对表中的某些行加共享锁，就会在更大一级的空间加上意向共享锁。\",\"意向排他锁：事务有意向对表中的某些行加排他锁，就会在更大一级的空间加上意向排他锁。\",\"意向共享锁（IS）\",\"意向排他锁（IX）\",\"意向共享锁（IS）\",\"兼容\",\"兼容\",\"意向排他锁（IX）\",\"兼容\",\"兼容\",\"意向共享锁（IS）\",\"意向排他锁（IX）\",\"共享锁（S）\",\"兼容\",\"不兼容\",\"排他锁（X）\",\"不兼容\",\"不兼容\",\"自增锁\",\"AUTO-INC锁是当想使用含有AUTO-INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。\",\"元数据锁\",\"当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。\",\"读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显示使用，在访问一个表的时候会被自动加上。\"]},\"401\":{\"h\":\"行锁\",\"t\":[\"行锁又称为记录锁，顾名思义就是锁住某一行。需要注意的是，MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。\",\"记录锁（Record Locks）\",\"可以理解为行级别的共享锁和排他锁\",\"间隙锁（Gap Locks）\",\"锁定一个范围，不包含记录本身（开区间），为了防止插入幻影记录而提出的\",\"临键锁（Next-Key Locks）\",\"Record Locks + Gap Locks\",\"锁定一个范围包含记录本身（闭区间）\"]},\"402\":{\"h\":\"InnoDB中行级锁是怎么实现的\",\"t\":[\"InnoDB行级锁是通过给索引上的索引项加锁来实现的。\"]},\"403\":{\"h\":\"数据库死锁问题以及解决办法\",\"t\":[\"死锁是指两个或两个以上的事务在执行过程中，因争夺所资源而造成的一种相互等待的现象。若无外力作用，事务都无法推进下去。\",\"解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续运行。\",\"除了超时机制，当前数据库还普遍采用wait-for graph（等待图）的方式来进行死锁检测。较之被动的超时方案，这时一种主动的死锁检测方法。InnoDB引擎也采用这种方法。wait-for graph要求数据库保存一下两种信息：\",\"锁的信息链表\",\"事务等待链表\",\"通过上述链表可以构造出一张图，若这个途中存在回路，就代表存在死锁。\"]},\"404\":{\"h\":\"操作系统\"},\"405\":{\"h\":\"操作系统IO介绍\",\"t\":[\"再过60分钟你就能了解同步异步、阻塞非阻塞、IO多路复用、select、poll、epoll等概念啦\"]},\"406\":{\"h\":\"用户空间和内核空间（用户态和内核态）\",\"t\":[\"现在的操作系统都是采用虚拟存储器，对于32位操作系统而言，他的寻址空间（虚拟存储空间）为4G(232)。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作系统内核（kernel），保证内核的安全，操作系统将虚拟空间划分成两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节供内核使用，成为内核空间，而将较低的3G字节供各个进程使用，称为用户空间。\",\"什么时候会从用户态切换到内核态？\",\"系统调用：用户进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如fork()就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现，如Linux的 int 80H 中断，也可以称为软中断。\",\"异常：当CPU在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程，也就是切换到了内核态，如缺页异常。\",\"中断：当CPU在执行用户态的进程时，外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂时执行下一个即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。\",\"为什么用户态与内核态的转换开销大？\",\"保留用户态现场（上下文、寄存器、用户栈等）\",\"复制用户态参数，用户栈切换到内核栈，进入内核态\",\"额外的检查（内核代码对用户不信任）\",\"执行内核态代码\",\"复制内核态代码执行结果，回到用户态\",\"恢复用户态现场（上下文、寄存器、用户栈等）\"]},\"407\":{\"h\":\"文件描述符\",\"t\":[\"文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\",\"文件描述符在形式上是一个非负整数。实际上，他是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一个概念往往只适用于UNIX、Linux这样的操作系统。\"]},\"408\":{\"h\":\"缓存 I/O\",\"t\":[\"缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会被拷贝到操作系统内核的缓冲区中，然后才会从操作系统的内核缓冲区拷贝到应用程序的地址空间。\",\"缓存I/O的缺点：\",\"数据在传输过程中需要在应用程序地址空间和内核之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。\"]},\"409\":{\"h\":\"I/O 模式\",\"t\":[\"对于缓存I/O，对于一次I/O访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，他会经历两个阶段：\",\"等待数据准备\",\"将数据从内核拷贝到进程中\",\"正是因为这两个阶段，linux系统产生了下面五种网络模式的方案\",\"阻塞I/O（blocking IO）\",\"非阻塞I/O（nonblocking IO）\",\"I/O多路复用（IO multiplexing）\",\"信号驱动I/O（signal driven IO）\",\"异步I/O（asynchronous IO）\",\"阻塞I/O\",\"阻塞IO\",\"在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程如上图所示。\",\"当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，他就会将数据从kernel中拷贝到用户内存中，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\",\"blocking IO的特点就是IO执行的两个阶段都会被block\",\"非阻塞I/O\",\"非阻塞IO\",\"在linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程如上图所示。\",\"当用户发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，他就知道数据还没有准备好，于是他可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么他马上就将数据拷贝到了用户内存，然后返回。\",\"nonblocking IO的特点是用户进程需要不断地主动询问kernel数据好了没有\",\"I/O多路复用\",\"IO多路复用\",\"IO multiplexing就是我们说的select，poll和epoll，有些地方也称这种IO方式为事件驱动IO（event driven IO）。select/epoll的好处就在于单个process就可以同时处理多个网络的IO。他的基本原理就是select，poll和epoll。不断地轮询所负责的所有socket，当某个socket有数据到达了就通知用户进程。\",\"当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。\",\"IO多路复用的特点是通过一种机制使得一个进程能够同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select函数就可以返回\",\"这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call（select和recvfrom），而blocking IO只调用了一个system call（recvfrom）。但是，用select的优势在于它可以同时处理多个connection\",\"所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。\",\"在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。\",\"异步I/O\",\"异步IO\",\"Linux下的asynchronous IO其实用的很少。流程如上图所示。\",\"用户进程发起read操作之后，立刻就可以开始去做其他事。而另一方面，从kernel的角度，当它收到一个asynchronous read之后，首先他会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉他read操作完成了。\",\"blocking和non-blocking的区别？\",\"调用blocking IO会一直block住对应的进程知道操作完成，而non-blocking IO在kernel准备数据的情况下会立刻返回。\",\"不同I/O对比\",\"IO对比\"]},\"410\":{\"h\":\"select、poll和epoll的区别\",\"t\":[\"select，poll和epoll都是IO多路复用的机制。IO多路复用就是通过一种机制使得一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步IO，因为他们需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步IO则无需自己负责进行读写，异步IO的实现会负责把数据从内核空间拷贝到用户空间。\",\"select\",\"select函数监视的文件描述符分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据可读、可写或者except）或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\",\"select目前几乎在所有的平台上支持，其良好跨平台支持也是他的一个优点。select的一个缺点在于单个进程能够监视文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。\",\"本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：\",\"select最大的缺陷就是单个进程所打开的fd数量是有一定限制的，它由FD_SETSIZE设置，默认值是1024.一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max查看。32位机默认是1024个，64位机默认是2048个。\",\"对socket进行扫描时是线性扫描，采用轮询方式，效率较低。\",\"需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。\",\"poll\",\"poll本质上和select没有区别。他将用户传入的fd数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前线程，知道设备就绪或者主动超时，被唤醒后他又要再次遍历fd。他没有最大连接数的限制，原因是他是基于链表来存储的，但是同样有缺点：\",\"大量的fd数组被整体复制于用户空间和内核空间，而不管这样的复制是否有意义\",\"poll还有一个特点就是“水平触发”，如果报告了fd后没有被处理，那么下次poll时会再次报告该fd\",\"从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态，因此随着监视的文件描述符数量的增长，其效率也会线性下降。\",\"epoll\",\"epoll是select和poll的增强版本。相对于select和poll而言，epoll更加灵活，没有文件描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。\",\"epoll支持水平触发和边缘触发，最大的特点就在于边缘触发，他只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。\",\"epoll的优点\",\"没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存大约能监听10万个端口）\",\"效率提升，不是轮询的方式，不会随着fd数目的增加使得效率降低。只有活跃可用的fd才会调用callback函数。即epoll最大的优点就在于他只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll\",\"内存拷贝，利用mmap()文件映射内存加速和内核空间的消息传递。即epoll使用mmap减少复制开销\",\"水平触发和边缘触发(Level trigger / edge trigger)\",\"epoll对文件描述符的操作有两种模式：LT(Level Trigger)和ET(Edge Trigger)。LT模式是默认模式，LT和ET的区别如下：\",\"LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件下次调用epoll_wait时，会再次相应应用程序并通知此事件。\",\"ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次相应应用程序并通知此事件。\",\"ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，防止由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\",\"总结\",\"在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描。\",\"epoll实现通过epoll_ctl()来注册一个文件扫描符，一旦基于某个文件扫描符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。\",\"如果没有大量的闲置连接和死亡连接，那么epoll的效率并不会比select/poll高很多，但是如果很多的话，就会发现epoll的效率大大高于select/poll。\",\"支持一个进程所能打开的最大连接数\",\"fd剧增后带来的IO效率问题\",\"消息传递方式\",\"select\",\"单个进程所能打开的最大连接数由FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上大小就是32*32，64位机器上就是32*64），当然我们可以对其进行修改，然后重新编译内核但是性能可能受到影响，这需要进一步测试\",\"因为每次调用时都会对连接进行线性遍历，所以随着fd的增加会造成遍历速度慢的“线性下降性能问题”\",\"内核需要将消息传递到用户空间，都需要内核的拷贝动作\",\"poll\",\"poll本质上和select没有区别，但是他没有最大连接数的限制，原因是他是基于链表来存储的\",\"同上\",\"同上\",\"epoll\",\"虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接\",\"因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃的socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能有性能问题\",\"epoll通过内核空间和用户空间共享一块内存来实现\",\"在选择select，poll和epoll时要根据具体的使用场合以及这三种方式的自身特点：\",\"表面上epoll的性能更好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调\",\"select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善\"]},\"411\":{\"h\":\"操作系统内存管理介绍\"},\"412\":{\"h\":\"内存管理主要是做什么\",\"t\":[\"操作系统的内存管理主要负责内存的分配与回收（malloc函数申请内存，free函数释放内存），另外地址转换也就是将逻辑地址转换为相应物理地址等功能也是操作系统内存管理做的事情。\"]},\"413\":{\"h\":\"常见的几种内存管理机制\",\"t\":[\"简单分为连续分配管理方式和非连续分配管理方式。连续分配管理方式是指为一个程序分配一个连续的内存空间，常见的如块式管理。同样地，非连续分配管理方式允许一个程序员使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理和段式管理。\",\"块式管理\",\"远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大校的块，每个块只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每块中未被利用的空间，我们称之为碎片。\",\"页式管理\",\"在该方式中，将用户程序的地址空间分为若干个固定大小的区域，称为“页”或“页面”。相应地，也将内存空间分为若干个物理块或页框，页和块的大小相同。这样可将用户程序的任一页放入任一物理块中，实现离散分配。\",\"页（页面）和物理块（页框）\",\"页面对应着逻辑地址，物理块对应着物理地址\",\"页式管理中将进程的逻辑地址空间分成若干个页，并为每个页加以编号。相应地将内存的物理地址空间分成若干个块，同样加以编号。在为进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块，从而会形成碎片。\",\"页的地址结构：\",\"页表\",\"页表的作用是实现页号到物理块号的地址映射\",\"如何将逻辑地址转换为物理地址？\",\"通过页号去页表查找该页号对应的块号，然后将物理块号与页内偏移地址拼接成实际物理地址\",\"访问内存的有效时间\",\"从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元并取出数据，所要花费的总时间，称为内存的有效访问时间(Effective Access Time, EAT)。\",\"假设访问一次内存的时间为t，在基本分页存储管理方式中，有效访问时间为第一次访间（即通过页号访问页表得到物理块号）与第二次访问内存时间（即将页表项中的物理块号与页内偏移地址拼接成实际物理地址后访问实际物理地址所耗费的时间）之和：EAT=t+t=2t\",\"快表和多级页表\",\"虚拟地址到物理地址的转换要快（快表解决）\",\"虚拟地址空间大，页表也会很大的问题（多级页表解决）\",\"快表\",\"快表的作用和缓存很类似\",\"在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器（快表），并将此页号与高速缓冲中的所有页号进行比较，若其中有与此相匹配地页号，便表示所要访问的页表项在快表中。如果在快表中未找到对应地页表项，则还需再次访问内存中的页表，在内存中找到后将该页表项存入快表的一个寄存器单元中。\",\"在引入快表的分页存储管理方式中，访问内存的有效时间为：EAT=a×λ+(t+λ)(1−a)+t，其中λ为访问快表所需时间，t为访问一次内存所需时间，a为快表的命中率。\",\"多级页表\",\"以二级页表而言，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散的存储在不同的物理块中（二级页表）。同样为离散分配的页表在建立一张页表，称为外层页表（一级页表）。\",\"多级页表的提出主要是解决下面两个问题：\",\"对于页表所需的内存空间，可采用离散分配的方式，以解决难以找到一块连续的大内存空间的问题。\",\"只将当前需要的部分页表项调入内存，其余的页表项仍然驻留在磁盘上，需要时再调入。\",\"总结\",\"为了提高内存的空间性能，提出了多级页表的概念；但是空间性能的提升是以时间为代价的，因此为了补充损失的时间性能，提出了快表的概念。不论使快表还是多级页表实际上都利用到了程序的局部性原理。\",\"段式管理\",\"这是为了满足用户要求而形成的一种存储管理方式。它把用户程序的地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。在存储器分配时，以段为单位，这些段在内存中可以不相邻接，所以也同样实现了离散分配。\",\"页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D和栈段S等。段式管理通过段表对应逻辑地址和物理地址。\",\"段页式管理\",\"这是分页和分段两种存储管理方式相结合的产物。它同时具有两者的优点，是目前应用较广泛的一种存储管理方式。\",\"段页式存储管理结合了页式管理和段式管理的优点。简单来说段页式管理机制就是先把用户程序分成若干个段，再把每个段分成若干个页。也就是说段页式管理机制中段与段之间以及段的内部都是离散的。（对于段式管理，一个段就是一个连续的物理地址空间）\",\"分段和分页的共同点与区别\",\"共同点 \",\"分页机制和分段机制都是为了提高内存利用率，减少内存碎片\",\"页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的\",\"区别 \",\"页的大小是固定的，由操作系统决定；而段的大小不固定，取决于具体程序\",\"分页仅仅是为了满足操作系统内存管理的需求，是物理单位。分段则是信息的逻辑单位，在程序中体现为主程序段，数据段等等，其目的是为了更好地满足用户的需求\"]},\"414\":{\"h\":\"逻辑地址和物理地址\",\"t\":[\"程序员一般只能和逻辑地址打交道，像C语言中指针存储的数值就可以理解为逻辑地址。而物理地址指的是真实物理内存中的地址，是内存单元真正的地址。\",\"CPU中的内存管理单元就是用于将逻辑地址翻译成物理地址。\"]},\"415\":{\"h\":\"为什么要有虚拟地址空间呢？\",\"t\":[\"如果直接把物理地址暴露出来的话会带来严重的问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难\",\"使用虚拟地址访问内存有以下优势：\",\"程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区\",\"程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动（虚拟内存）\",\"不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存\"]},\"416\":{\"h\":\"操作系统虚拟内存介绍\",\"t\":[\"在说操作系统虚拟内存之前有必要说一下局部性原理。局部性原理是虚拟内存技术的基础，正是因为程序具有局部性原理，才可以只装入部分程序到内存就开始运行。\"]},\"417\":{\"h\":\"局部性原理\",\"t\":[\"局部性原理有表现在下述两个方面：\",\"时间局部性：如果程序中的某条指令被执行，则不久后该指令可能再次执行；如果某数据被访问过，则不久后该数据可能再次被访问。产生时间局部性的典型原因是程序中存在着大量的循环操作。\",\"空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\",\"时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了“内存-外存”的两级存储器的结构，利用局部性原理实现高速缓存。\"]},\"418\":{\"h\":\"虚拟内存（虚拟存储器）\",\"t\":[\"基于局部性原理可知，应用程序在运行之前没有必要将之全部装入内存，而仅需将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。程序在运行时，如果他所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页（段），OS还须再利用页（段）的置换功能，将内存中暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去。这样，便可使一个大的用户程序在较小的内存空间中运行，也可在内存中同时装入更多的进程，使它们并发执行。\",\"虚拟内存类似于时间换空间，用CPU的计算，页的调入调出，换来了一个更大的空间来支持程序的运行。其重要意义在于定义了一个连续的虚拟地址空间，并且把内存扩展到磁盘空间。\"]},\"419\":{\"h\":\"虚拟存储器的实现方法\",\"t\":[\"虚拟存储器允许将一个作业分多次调入内存。如果采用连续分配的方式，要求必须将作业装入一个连续的内存区域中，则必须事先为作业一次性地申请一个足以容纳整个作业的内存空间，以便能将作业分先后地多次装入内存。这不仅会使相当一部分内存空间都处于暂时或“永久”地空闲状态，造成内存资源的严重浪费，而且无法、也无意义再从逻辑上扩大内存容量。所以，虚拟存储器地实现，都毫无例外地建立在离散分配存储管理方式的基础上。\",\"虚拟内存的实现有以下三种方式：\",\"请求分页存储管理：分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许用户程序只装入少数页面的程序（及数据）即可启动运行。以后，再通过调页功能及页面置换功能陆续地把即将运行的页面调入内存，同时把暂时不运行的页面换出到外存上。\",\"请求分段存储管理：请求分段系统是在分段系统的基础上，增加了请求调段及分段置换功能后形成的段式虚拟存储系统。它允许用户程序只要装入少数段的程序和数据即可启动运行。以后通过调段功能和段的置换功能将暂时不运行的段调出，再调入即将运行的段。\",\"请求段页式存储管理\",\"不管是上面那种实现方式，我们都需要：\",\"一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了\",\"缺页（段）中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序\",\"虚拟地址空间：实现虚拟地址向物理地址的转换\",\"这边说的请求分页存储管理和操作系统内存管理中的分页存储管理有何不同？\",\"请求分页存储管理建立在分页存储管理之上。它们的根本区别在于是否将程序所需的全部地址空间都装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚拟内存，而分页存储管理不能提供虚存。\"]},\"420\":{\"h\":\"页面置换算法\",\"t\":[\"在进程运行过程中，若其所要访问的页面不在内存，而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，操作系统必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，通常可以把页面置换算法看成是淘汰页面的规则\",\"最佳页面置换算法（OPT）：\",\"最佳页面置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法\",\"先进先出页面置换算法（FIFO）：\",\"总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰\",\"最近最久未使用页面置换算法（LRU）：\",\"LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需淘汰一个页面时，选择现有页面中其t值最大的淘汰，即选择最近最久未使用的页面进行淘汰。\",\"假设有一进程，有五个物理块，所访问的页面的页面序号为：4,7,0,7,1,0,1,2,1,2,6，其演示图如下：（其实并没有用到栈的特性）\",\"最少使用页面置换算法（LFU）：\",\"该置换算法选择在之前时期使用最少的也页面作为淘汰页\"]},\"421\":{\"h\":\"Redis\"},\"422\":{\"h\":\"Redis常见数据结构以及使用场景\",\"t\":[\"string\",\"介绍：虽然Reids是C语言编写的，但是其string底层并没有采用C的字符串，而是自己构建了一种简单动态字符串\",\"常用命令：set，get，strlen，exists，decr，incr，setex等\",\"应用场景：一般用于需要计数的场景，比如用户的访问次数，热点文章的点赞数和转发数等等\",\"list\",\"介绍：底层为双向链表\",\"常用命令：rpush，lpush，rpop，lpop，lrange，llen等\",\"应用场景：消息队列\",\"hash\",\"介绍：类似于JDK1.8之前的HashMap，内部实现也差不多是数组+链表。\",\"常用命令：hset，hmset，hexists，hget，hgetall，hkeys，hvals等\",\"应用场景：系统中对象数据的存储\",\"set\",\"介绍：类似于Java中的HashSet\",\"常用命令：sadd，spop，smembers，sismember，scard，sinterstore，sunion等\",\"应用场景：集合运算，比如集合的交集和并集\",\"sorted set\",\"介绍：基于跳表实现，和set相比增加了一个权重参数score，使得集合中的元素可以根据score进行有序排列。\",\"常用命令：zadd，zcard，zscore，zrange，zrevrange，zrem等\",\"应用场景：需要对数据根据某个权重进行排序的场景。比如直播间礼物排行 。\"]},\"423\":{\"h\":\"Redis到底是单线程还是多线程\",\"t\":[\"Redis 6.0版本之前的单线程指的是其网络I/O和键值对读写是有一个线程完成的。也就是只有网络请求模块和数据操作模块是单线程的，而其他的持久化、集群数据同步等，其实是由额外的线程执行的\",\"Redis 6.0引入的多线程指的是网络I/O采用了多线程，而键值对读写命令仍然是单线程处理的，所以Redis仍然是并发安全的\"]},\"424\":{\"h\":\"Redis单线程为什么还快\",\"t\":[\"命令执行基于内存操作\",\"命令执行是单线程操作，没有线程切换开销\",\"基于IO多路复用机制（epoll）提升Redis的I/O利用率\",\"高效的数据存储结构：全局hash表以及多种高效数据结构，比如：跳表，压缩列表，链表等等\"]},\"425\":{\"h\":\"Redis底层数据是如何用跳表来存储的\",\"t\":[\"将有序链表改造为支持类似“折半查找”的算法，可以让链表可以快速的插入、删除和查找。常用于Sorted Set的底层实现。\"]},\"426\":{\"h\":\"Redis Key过期了为什么内存没释放\",\"t\":[\"设置了过期时间的key被没有设置过期时间的相同key覆盖了\",\"127.0.0.1:6379> set name vingkin ex 120 OK 127.0.0.1:6379> ttl name (integer) 119 127.0.0.1:6379> set name vingkin OK 127.0.0.1:6379> ttl name (integer) -1 # name被覆盖，永不过时 \",\"与过期数据删除策略有关\"]},\"427\":{\"h\":\"过期数据删除策略\",\"t\":[\"惰性删除： 在取出key的时候对数据进行过期检查。这样对CPU友好，但是会造成太多过期key没有被删除\",\"定期删除： 每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作的时常和频率来减少删除操作对CPU的影响\",\"定期删除对内存更加友好，惰性删除对CPU更加友好。所以Redis采用两者结合的方式进行过期数据删除\"]},\"428\":{\"h\":\"Redis Key没设置过期时间为什么被Redis主动删除了\",\"t\":[\"Redis的内存淘汰机制使用了allkeys-lru或者allkeys-random或者allkeys-lfu\"]},\"429\":{\"h\":\"Redis内存淘汰机制\",\"t\":[\"当Redis已用内存超过maxmemory限定时，触动主动清理策略。\",\"主动清理策略再Redis4.0 之前一共实现了6中内存淘汰机制，在4.0之后，又增加了2种策略，总共8种：\",\"针对设置了过期时间的key做处理：\",\"volatile-lru（least recently used）： 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰（最常用）\",\"volatile-ttl： 从已设置过期时间的数据集中挑选即将要过期的数据淘汰\",\"volatile-random： 从已设置过期时间的数据集中任意选择数据淘汰\",\"volatile-lfu（least frequently used）： 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰（访问次数最少）\",\"针对所有的key做处理：\",\"allkeys-lru：（least recently used）： 当内存不足以容纳新写入数据时，在键空间中，移出最近最少使用的key（最常用）\",\"allkeys-random： 从数据集中任意选择数据淘汰\",\"allkeys-lfu（least frequently used）： 当内存不足以容纳新写入的数据时，在键空间中移出最不经常使用的key\",\"不处理：\",\"no-eviction： 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。（基本不使用）\",\"绝大多数情况都是用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点，以访问次数的多少作为参考点。\"]},\"430\":{\"h\":\"删除Key的命令会阻塞Redis吗\",\"t\":[\"DEL key [key ...]\",\"时间复杂度：\",\"O(N)，其中N为被删除key的数量\",\"删除单个字符串类型的key，时间复杂度为O(1)\",\"删除单个列表、集合、有序集合或哈希表类型的key，时间复杂度为O(M)，其中M为以上数据类型种元素的数量。\",\"当删除的key是所占内存很大时，不管是string还是其他的数据类型，都有可能会阻塞Redis\"]},\"431\":{\"h\":\"Redis高可用方案\"},\"432\":{\"h\":\"主从模式\",\"t\":[\"不能保证高可用，当master节点挂掉后需要运维介入切换节点，一般不使用\"]},\"433\":{\"h\":\"哨兵模式\",\"t\":[\"在redis 3.0以前的版本要实现集群一般时借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做出主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别时主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发（单节点理论支持最高并发量为10万），且单个主节点内存也不宜设的过大（一般为10G），否则会导致持久化文件过大，影响数据恢复或主从同步的效率。\",\"sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：\",\"集群监控：负责监控redis master和slave进程是否正常工作\",\"消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员\",\"故障转移：如果master node挂掉了，会自动转移到slave node上。故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举。\",\"配置中心：如果故障转移发生了，通知client客户端新的master地址\",\"哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。\",\"即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的\",\"哨兵通常需要3个实例，来保证自己的健壮性\",\"哨兵 + redis主从的部署架构，是不保证数据零丢失的，只能保证redis集群的高可用性\"]},\"434\":{\"h\":\"集群模式\",\"t\":[\"Redis集群是由多个主从节点群组成的分布式服务器群，它具有复制，高可用和分片的特性。Redis集群不需要sentine哨兵也能完成节点移出和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点（官方推荐不超过1000个）。Redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。\",\"通过hash的方式，将数据分片，每个节点均衡存储一定哈希槽（哈希值）区间的数据\",\"每份数据分片会存储在多个互为主从的多节点上\",\"数据先写入主节点，再同步到从节点（支持配置为阻塞同步）\",\"同一分片多个节点间的数据不保持强一致性\",\"读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，转向正确的节点\",\"扩容时，需要把旧节点的数据迁移一部分到新节点\",\"在redis cluster架构下，每个redis节点都要开放两个端口号，一个用于连接，一个用于节点间通信\"]},\"435\":{\"h\":\"Reids集群模式下数据hash分片算法\",\"t\":[\"Redis Cluster将所有数据划分为16384个槽位，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。\",\"当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个key时，可以根据槽位定位算法定位到目标节点。\",\"槽位定位算法\",\"Cluster默认会对key使用crc16算法进行hash得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。\",\"HASH_SLOT = CRC16(key) % 16384\",\"再根据槽位值和Redis节点的对应关系就可以定位到key具体是落在哪个Redis节点上\"]},\"436\":{\"h\":\"Redis执行命令出现死循环Bug\",\"t\":[\"如果想随机查看Redis中的一个key，Redis里面有一个RANDOMKEY命令可以从Redis中随机取出一个key，这个命令可能导致Redis死循环阻塞。\",\"出现这个问题的原因主要还是在于Redis的过期数据删除策略\",\"RANDOMKEY随机拿出一个key后，首先会检查该key是否过期，如果过期，则会先删除这个key然后重新选取，直到找到一个未过期的key返回。如果Redis中有大量的key已经过期，但是没有被即使清理，那么这个循环会持续很久才结束。这个流程是发生在master节点中的。\",\"如果发生在slave节点中，那么问题会更严重。slave是不会主动清理过期key的，当一个key过期时，master会先清理删除它，然后向slave发送一个DEL命令，告知slave也删除这个key，以此达到主从库的数据一致性。\",\"假设Redis中存在大量已过期但是未被清理的key，在slave中执行RANDOMKEY时，因为不会删除过期key，则有可能无限制的命中过期key，陷入死循环，导致Redis实例卡死。\",\"这其实是Redis 5.0之前的一个Bug，修复方案就是给RANDOMKEY增加最多执行次数，无论是否找到key，都返回。\"]},\"437\":{\"h\":\"主从切换导致缓存雪崩具体场景\",\"t\":[\"为什么要保证主从节点机器时钟一致\",\"我们假设，slave的机器时钟比master走得快很多\",\"此时，Redis master里设置了过期时间的key，从slave角度来看，可能会有很多在master里没过期的数据其实已经过期了\",\"如果此时操作主从切换，把slave提升为新的master\",\"slave成为新的master后，就会开始大量清理过期key，此时就会导致以下结果：\",\"master大量清理过期key，主线程可能会发生阻塞，无法及时处理客户端请求\",\"Redis中数据大量过期，引发缓存雪崩甚至系统崩溃\",\"当master和slave机器始终严重不一致时，对业务的影响非常大。所以一定要保证主从节点的机器时钟一致性。\"]},\"438\":{\"h\":\"雪花算法\",\"t\":[\"SnowFlake 雪花算法详解与实现\"]},\"439\":{\"h\":\"背景\",\"t\":[\"现在的服务基本是分布式，微服务形式的，而且大数据量也导致分库分表的产生，对于水平分表就需要保证表中 id 的全局唯一性。\",\"对于 MySQL 而言，一个表中的主键 id 一般使用自增的方式，但是如果进行水平分表之后，多个表中会生成重复的 id 值。那么如何保证水平分表后的多张表中的 id 是全局唯一性的呢？\",\"如果还是借助数据库主键自增的形式，那么可以让不同表初始化一个不同的初始值，然后按指定的步长进行自增。例如有3张拆分表，初始主键值为1，2，3，自增步长为3。\",\"当然也有人使用 UUID 来作为主键，但是 UUID 生成的是一个无序的字符串，对于 MySQL 推荐使用增长的数值类型值作为主键来说不适合。\",\"也可以使用 Redis 的自增原子性来生成唯一 id，但是这种方式业内比较少用。\",\"当然还有其他解决方案，不同互联网公司也有自己内部的实现方案。雪花算法是其中一个用于解决分布式 id 的高效方案，也是许多互联网公司在推荐使用的。\"]},\"440\":{\"h\":\"SnowFlake 雪花算法\",\"t\":[\"SnowFlake 中文意思为雪花，故称为雪花算法。最早是 Twitter 公司在其内部用于分布式环境下生成唯一 ID。在2014年开源 scala 语言版本。\",\"雪花算法\",\"雪花算法原理就是生成一个的64位比特位的 long 类型的唯一 id。\",\"最高1位固定值0，因为生成的 id 是正整数，如果是1就是负数了。\",\"接下来41位存储毫秒级时间戳，241/(1000∗60∗60∗24∗365)=69，大概可以使用69年。\",\"再接下10位存储机器码，包括5位 datacenterId 和5位 workerId。最多可以部署210=1024台机器。\",\"最后12位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成212=4096个不重复 id。\",\"可以将雪花算法作为一个单独的服务进行部署，然后需要全局唯一 id 的系统，请求雪花算法服务获取 id 即可。\",\"对于每一个雪花算法服务，需要先指定10位的机器码（机器id+服务id），这个根据自身业务进行设定即可。例如机房号+机器号，机器号+服务号，或者是其他可区别标识的10位比特位的整数值都行。\"]},\"441\":{\"h\":\"算法实现\",\"t\":[\"import java.util.Set; import java.util.TreeSet; public class SnowflakeIdGenerator { // 初始时间戳(纪年)，可用雪花算法服务上线时间戳的值 // 1649059688068：2022-04-04 16:08:08 private static final long INIT_EPOCH = 1649059688068L; // 记录最后使用的毫秒时间戳，主要用于判断是否同一毫秒，以及用于服务器时钟回拨判断 private long lastTimeMillis = -1L; // dataCenterId占用的位数 private static final long DATA_CENTER_ID_BITS = 5L; // dataCenterId占用5个比特位，最大值31 // 0000000000000000000000000000000000000000000000000000000000011111 private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS); // datacenterId private long datacenterId; // workId占用的位数 private static final long WORKER_ID_BITS = 5L; // workId占用5个比特位，最大值31 // 0000000000000000000000000000000000000000000000000000000000011111 private static final long MAX_WORKER_ID = ~(-1L << WORKER_ID_BITS); // workId private long workerId; // 最后12位，代表每毫秒内可产生最大序列号，即 2^12 - 1 = 4095 private static final long SEQUENCE_BITS = 12L; // 掩码（最低12位为1，高位都为0），主要用于与自增后的序列号进行位与，如果值为0，则代表自增后的序列号超过了4095 // 0000000000000000000000000000000000000000000000000000111111111111 private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS); // 同一毫秒内的最新序号，最大值可为 2^12 - 1 = 4095 private long sequence; // workId位需要左移的位数 12 private static final long WORK_ID_SHIFT = SEQUENCE_BITS; // dataCenterId位需要左移的位数 12+5 private static final long DATA_CENTER_ID_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS; // 时间戳需要左移的位数 12+5+5 private static final long TIMESTAMP_SHIFT = SEQUENCE_BITS + WORKER_ID_BITS + DATA_CENTER_ID_BITS; public SnowflakeIdGenerator(long datacenterId, long workerId) { // 检查datacenterId的合法值 if (datacenterId < 0 || datacenterId > MAX_DATA_CENTER_ID) { throw new IllegalArgumentException( String.format(\\\"datacenterId值必须大于0并且小于%d\\\", MAX_DATA_CENTER_ID)); } // 检查workId的合法值 if (workerId < 0 || workerId > MAX_WORKER_ID) { throw new IllegalArgumentException(String.format(\\\"workId值必须大于0并且小于%d\\\", MAX_WORKER_ID)); } this.workerId = workerId; this.datacenterId = datacenterId; } /** * 通过雪花算法生成下一个id，注意这里使用synchronized同步 * * @return 唯一id */ public synchronized long nextId() { long currentTimeMillis = System.currentTimeMillis(); // 当前时间小于上一次生成id使用的时间，可能出现服务器时钟回拨问题 if (currentTimeMillis < lastTimeMillis) { throw new RuntimeException( String.format(\\\"可能出现服务器时钟回拨问题，请检查服务器时间。当前服务器时间戳：%d，上一次使用时间戳：%d\\\", currentTimeMillis, lastTimeMillis)); } if (currentTimeMillis == lastTimeMillis) { // 还是在同一毫秒内，则将序列号递增1，序列号最大值为4095 // 序列号的最大值是4095，使用掩码（最低12位为1，高位都为0）进行位与运行后如果值为0，则自增后的序列号超过了4095 // 那么就使用新的时间戳 sequence = (sequence + 1) & SEQUENCE_MASK; if (sequence == 0) { currentTimeMillis = tilNextMillis(lastTimeMillis); } } else { // 不在同一毫秒内，则序列号重新从0开始，序列号最大值为4095 sequence = 0; } // 记录最后一次使用的毫秒时间戳 lastTimeMillis = currentTimeMillis; // 核心算法，将不同部分的数值移动到指定的位置，然后进行或运行 return ((currentTimeMillis - INIT_EPOCH) << TIMESTAMP_SHIFT) | (datacenterId << DATA_CENTER_ID_SHIFT) | (workerId << WORK_ID_SHIFT) | sequence; } /** * 获取指定时间戳的接下来的时间戳，也可以说是下一毫秒 * * @param lastTimeMillis 指定毫秒时间戳 * @return 时间戳 */ private long tilNextMillis(long lastTimeMillis) { long currentTimeMillis = System.currentTimeMillis(); while (currentTimeMillis <= lastTimeMillis) { currentTimeMillis = System.currentTimeMillis(); } return currentTimeMillis; } public static void main(String[] args) { SnowflakeIdGenerator snowflakeIdGenerator = new SnowflakeIdGenerator(1, 2); // 生成50个id Set<Long> set = new TreeSet<>(); for (int i = 0; i < 50; i++) { set.add(snowflakeIdGenerator.nextId()); } System.out.println(set.size()); System.out.println(set); // 验证生成100万个id需要多久 long startTime = System.currentTimeMillis(); for (int i = 0; i < 1000000; i++) { snowflakeIdGenerator.nextId(); } System.out.println(System.currentTimeMillis() - startTime); } } \"]},\"442\":{\"h\":\"算法优缺点\",\"t\":[\"雪花算法有以下几个优点：\",\"高并发分布式环境下生成不重复 id，每秒可生成百万个不重复 id。\",\"基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。\",\"不依赖第三方库或者中间件。\",\"算法简单，在内存中进行，效率高。\",\"雪花算法有如下缺点：\",\"依赖服务器时间，服务器时钟回拨时可能会生成重复 id。算法中可通过记录最后一个生成 id 时的时间戳来解决，每次生成 id 之前比较当前服务器时钟是否被回拨，避免生成重复 id。\"]},\"443\":{\"h\":\"注意事项\",\"t\":[\"其实雪花算法每一部分占用的比特位数量并不是固定死的。例如你的业务可能达不到69年之久，那么可用减少时间戳占用的位数，雪花算法服务需要部署的节点超过1024台，那么可将减少的位数补充给机器码用。\",\"注意，雪花算法中41位比特位不是直接用来存储当前服务器毫秒时间戳的，而是需要当前服务器时间戳减去某一个初始时间戳值，一般可以使用服务上线时间作为初始时间戳值。\",\"对于机器码，可根据自身情况做调整，例如机房号，服务器号，业务号，机器 IP 等都是可使用的。对于部署的不同雪花算法服务中，最后计算出来的机器码能区分开来即可。\"]},\"444\":{\"h\":\"\"},\"445\":{\"h\":\"容器与 bean\"},\"446\":{\"h\":\"1) 容器接口\",\"t\":[\"BeanFactory 接口，典型功能有：\",\"getBean\",\"ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：\",\"国际化\",\"通配符方式获取一组 Resource 资源\",\"整合 Environment 环境（能通过它获取各种来源的配置信息）\",\"事件发布与监听，实现组件之间的解耦\",\"可以看到，我们课上讲的，都是 BeanFactory 提供的基本功能，ApplicationContext 中的扩展功能都没有用到。\"]},\"447\":{\"h\":\"演示1 - BeanFactory 与 ApplicationContext 的区别\"},\"448\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a01 包\"]},\"449\":{\"h\":\"收获💡\",\"t\":[\"通过这个示例结合 debug 查看 ApplicationContext 对象的内部结构，学到：\",\"到底什么是 BeanFactory\",\"它是 ApplicationContext 的父接口\",\"它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能，【组合】是指 ApplicationContext 的一个重要成员变量就是 BeanFactory\",\"BeanFactory 能干点啥\",\"表面上只有 getBean\",\"实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能，都由它的实现类提供\",\"例子中通过反射查看了它的成员变量 singletonObjects，内部包含了所有的单例 bean\",\"ApplicationContext 比 BeanFactory 多点啥\",\"ApplicationContext 组合并扩展了 BeanFactory 的功能\",\"国际化、通配符方式获取一组 Resource 资源、整合 Environment 环境、事件发布与监听\",\"新学一种代码之间解耦途径，事件解耦\",\"建议练习：完成用户注册与发送短信之间的解耦，用事件方式、和 AOP 方式分别实现\",\"注意\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED，这是因为这些版本的 jdk 默认不允许跨 module 反射\",\"事件发布还可以异步，这个视频中没有展示，请自行查阅 @EnableAsync，@Async 的用法\"]},\"450\":{\"h\":\"演示2 - 国际化\",\"t\":[\"public class TestMessageSource { public static void main(String[] args) { GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(\\\"messageSource\\\", MessageSource.class, () -> { ResourceBundleMessageSource ms = new ResourceBundleMessageSource(); ms.setDefaultEncoding(\\\"utf-8\\\"); ms.setBasename(\\\"messages\\\"); return ms; }); context.refresh(); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.ENGLISH)); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.CHINESE)); System.out.println(context.getMessage(\\\"hi\\\", null, Locale.JAPANESE)); } } \",\"国际化文件均在 src/resources 目录下\",\"messages.properties（空）\",\"messages_en.properties\",\"hi=Hello \",\"messages_ja.properties\",\"hi=こんにちは \",\"messages_zh.properties\",\"hi=你好 \",\"注意\",\"ApplicationContext 中 MessageSource bean 的名字固定为 messageSource\",\"使用 SpringBoot 时，国际化文件名固定为 messages\",\"空的 messages.properties 也必须存在\"]},\"451\":{\"h\":\"2) 容器实现\",\"t\":[\"Spring 的发展历史较为悠久，因此很多资料还在讲解它较旧的实现，这里出于怀旧的原因，把它们都列出来，供大家参考\",\"DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像控制反转和依赖注入功能，都是它来实现\",\"ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）\",\"FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）\",\"XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）\",\"AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）\",\"AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）\",\"AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）\",\"AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器（新）\",\"另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是组合了 DefaultListableBeanFactory 的功能，并非继承而来\"]},\"452\":{\"h\":\"演示1 - DefaultListableBeanFactory\"},\"453\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a02.TestBeanFactory\"]},\"454\":{\"h\":\"收获💡\",\"t\":[\"beanFactory 可以通过 registerBeanDefinition 注册一个 bean definition 对象 \",\"我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中\",\"bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等\",\"beanFactory 需要手动调用 beanFactory 后处理器对它做增强 \",\"例如通过解析 @Bean、@ComponentScan 等注解，来补充一些 bean definition\",\"beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强 \",\"例如 @Autowired，@Resource 等注解的解析都是 bean 后处理器完成的\",\"bean 后处理的添加顺序会对解析结果有影响，见视频中同时加 @Autowired，@Resource 的例子\",\"beanFactory 需要手动调用方法来初始化单例\",\"beanFactory 需要额外设置才能解析 ${} 与 #{}\"]},\"455\":{\"h\":\"演示2 - 常见 ApplicationContext 实现\"},\"456\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a02.A02\"]},\"457\":{\"h\":\"收获💡\",\"t\":[\"常见的 ApplicationContext 容器实现\",\"内嵌容器、DispatcherServlet 的创建方法、作用\"]},\"458\":{\"h\":\"3) Bean 的生命周期\",\"t\":[\"一个受 Spring 管理的 bean，生命周期主要阶段有\",\"创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象\",\"依赖注入：根据 @Autowired，@Value 或其它一些手段，为 bean 的成员变量填充值、建立关系\",\"初始化：回调各种 Aware 接口，调用对象的各种初始化方法\",\"销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法） \",\"prototype 对象也能够销毁，不过需要容器这边主动调用\",\"一些资料会提到，生命周期中还有一类 bean 后处理器：BeanPostProcessor，会在 bean 的初始化的前后，提供一些扩展逻辑。但这种说法是不完整的，见下面的演示1\"]},\"459\":{\"h\":\"演示1 - bean 生命周期\"},\"460\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a03 包\",\"创建前后的增强\",\"postProcessBeforeInstantiation \",\"这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程\",\"postProcessAfterInstantiation \",\"这里如果返回 false 会跳过依赖注入阶段\",\"依赖注入前的增强\",\"postProcessProperties \",\"如 @Autowired、@Value、@Resource\",\"初始化前后的增强\",\"postProcessBeforeInitialization \",\"这里返回的对象会替换掉原本的 bean\",\"如 @PostConstruct、@ConfigurationProperties\",\"postProcessAfterInitialization \",\"这里返回的对象会替换掉原本的 bean\",\"如代理增强\",\"销毁之前的增强\",\"postProcessBeforeDestruction \",\"如 @PreDestroy\"]},\"461\":{\"h\":\"收获💡\",\"t\":[\"Spring bean 生命周期各个阶段\",\"模板设计模式, 指大流程已经固定好了, 通过接口回调（bean 后处理器）在一些关键点前后提供扩展\"]},\"462\":{\"h\":\"演示2 - 模板方法设计模式\"},\"463\":{\"h\":\"关键代码\",\"t\":[\"public class TestMethodTemplate { public static void main(String[] args) { MyBeanFactory beanFactory = new MyBeanFactory(); beanFactory.addBeanPostProcessor(bean -> System.out.println(\\\"解析 @Autowired\\\")); beanFactory.addBeanPostProcessor(bean -> System.out.println(\\\"解析 @Resource\\\")); beanFactory.getBean(); } // 模板方法 Template Method Pattern static class MyBeanFactory { public Object getBean() { Object bean = new Object(); System.out.println(\\\"构造 \\\" + bean); System.out.println(\\\"依赖注入 \\\" + bean); // @Autowired, @Resource for (BeanPostProcessor processor : processors) { processor.inject(bean); } System.out.println(\\\"初始化 \\\" + bean); return bean; } private List<BeanPostProcessor> processors = new ArrayList<>(); public void addBeanPostProcessor(BeanPostProcessor processor) { processors.add(processor); } } static interface BeanPostProcessor { public void inject(Object bean); // 对依赖注入阶段的扩展 } } \"]},\"464\":{\"h\":\"演示3 - bean 后处理器排序\"},\"465\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a03.TestProcessOrder\"]},\"466\":{\"h\":\"收获💡\",\"t\":[\"实现了 PriorityOrdered 接口的优先级最高\",\"实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序\",\"其它的排在最后\"]},\"467\":{\"h\":\"4) Bean 后处理器\"},\"468\":{\"h\":\"演示1 - 后处理器作用\"},\"469\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a04 包\"]},\"470\":{\"h\":\"收获💡\",\"t\":[\"@Autowired 等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成\",\"每个后处理器各自增强什么功能 \",\"AutowiredAnnotationBeanPostProcessor 解析 @Autowired 与 @Value\",\"CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy\",\"ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties\",\"另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value 的值，解析 @Qualifier、泛型、@Lazy 等\"]},\"471\":{\"h\":\"演示2 - @Autowired bean 后处理器运行分析\"},\"472\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a04.DigInAutowired\"]},\"473\":{\"h\":\"收获💡\",\"t\":[\"AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata\",\"InjectionMetadata 可以完成依赖注入\",\"InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型\",\"有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找\"]},\"474\":{\"h\":\"5) BeanFactory 后处理器\"},\"475\":{\"h\":\"演示1 - BeanFactory 后处理器的作用\"},\"476\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05 包\",\"ConfigurationClassPostProcessor 可以解析 \",\"@ComponentScan\",\"@Bean\",\"@Import\",\"@ImportResource\",\"MapperScannerConfigurer 可以解析 \",\"Mapper 接口\"]},\"477\":{\"h\":\"收获💡\",\"t\":[\"@ComponentScan, @Bean, @Mapper 等注解的解析属于核心容器（即 BeanFactory）的扩展功能\",\"这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义\"]},\"478\":{\"h\":\"演示2 - 模拟解析 @ComponentScan\"},\"479\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.ComponentScanPostProcessor\"]},\"480\":{\"h\":\"收获💡\",\"t\":[\"Spring 操作元数据的工具类 CachingMetadataReaderFactory\",\"通过注解元数据（AnnotationMetadata）获取直接或间接标注的注解信息\",\"通过类元数据（ClassMetadata）获取类名，AnnotationBeanNameGenerator 生成 bean 名\",\"解析元数据是基于 ASM 技术\"]},\"481\":{\"h\":\"演示3 - 模拟解析 @Bean\"},\"482\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.AtBeanPostProcessor\"]},\"483\":{\"h\":\"收获💡\",\"t\":[\"进一步熟悉注解元数据（AnnotationMetadata）获取方法上注解信息\"]},\"484\":{\"h\":\"演示4 - 模拟解析 Mapper 接口\"},\"485\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a05.MapperPostProcessor\"]},\"486\":{\"h\":\"收获💡\",\"t\":[\"Mapper 接口被 Spring 管理的本质：实际是被作为 MapperFactoryBean 注册到容器中\",\"Spring 的诡异做法，根据接口生成的 BeanDefinition 仅为根据接口名生成 bean 名\"]},\"487\":{\"h\":\"6) Aware 接口\"},\"488\":{\"h\":\"演示 - Aware 接口及 InitializingBean 接口\"},\"489\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a06 包\"]},\"490\":{\"h\":\"收获💡\",\"t\":[\"Aware 接口提供了一种【内置】 的注入手段，例如 \",\"BeanNameAware 注入 bean 的名字\",\"BeanFactoryAware 注入 BeanFactory 容器\",\"ApplicationContextAware 注入 ApplicationContext 容器\",\"EmbeddedValueResolverAware 注入 ${} 解析器\",\"InitializingBean 接口提供了一种【内置】的初始化手段\",\"对比 \",\"内置的注入和初始化不受扩展功能的影响，总会被执行\",\"而扩展功能受某些情况影响可能会失效\",\"因此 Spring 框架内部的类常用内置注入和初始化\"]},\"491\":{\"h\":\"配置类 @Autowired 失效分析\",\"t\":[\"Java 配置类不包含 BeanFactoryPostProcessor 的情况\",\"Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效\",\"对应代码\",\"@Configuration public class MyConfig1 { private static final Logger log = LoggerFactory.getLogger(MyConfig1.class); @Autowired public void setApplicationContext(ApplicationContext applicationContext) { log.debug(\\\"注入 ApplicationContext\\\"); } @PostConstruct public void init() { log.debug(\\\"初始化\\\"); } @Bean // ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况 public BeanFactoryPostProcessor processor1() { return beanFactory -> { log.debug(\\\"执行 processor1\\\"); }; } } \",\"注意\",\"解决方法：\",\"用内置依赖注入和初始化取代扩展依赖注入和初始化\",\"用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建\"]},\"492\":{\"h\":\"7) 初始化与销毁\"},\"493\":{\"h\":\"演示 - 初始化销毁顺序\"},\"494\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a07 包\"]},\"495\":{\"h\":\"收获💡\",\"t\":[\"Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是\",\"@PostConstruct 标注的初始化方法\",\"InitializingBean 接口的初始化方法\",\"@Bean(initMethod) 指定的初始化方法\",\"与初始化类似，Spring 也提供了多种销毁手段，执行顺序为\",\"@PreDestroy 标注的销毁方法\",\"DisposableBean 接口的销毁方法\",\"@Bean(destroyMethod) 指定的销毁方法\"]},\"496\":{\"h\":\"8) Scope\",\"t\":[\"在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope\",\"singleton，容器启动时创建（未设置延迟），容器关闭时销毁\",\"prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁\",\"request，每次请求用到此 bean 时创建，请求结束时销毁\",\"session，每个会话用到此 bean 时创建，会话结束时销毁\",\"application，web 容器用到此 bean 时创建，容器停止时销毁\",\"有些文章提到有 globalSession 这一 Scope，也是陈旧的说法，目前 Spring 中已废弃\",\"但要注意，如果在 singleton 注入其它 scope 都会有问题，解决方法有\",\"@Lazy\",\"@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)\",\"ObjectFactory\",\"ApplicationContext.getBean\"]},\"497\":{\"h\":\"演示1 - request, session, application 作用域\"},\"498\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a08 包\",\"打开不同的浏览器, 刷新 http://localhost:8080/test 即可查看效果\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"499\":{\"h\":\"收获💡\",\"t\":[\"有几种 scope\",\"在 singleton 中使用其它几种 scope 的方法\",\"其它 scope 的销毁时机 \",\"可以将通过 server.servlet.session.timeout=30s 观察 session bean 的销毁\",\"ServletContextScope 销毁机制疑似实现有误\"]},\"500\":{\"h\":\"分析 - singleton 注入其它 scope 失效\",\"t\":[\"以单例注入多例为例\",\"有一个单例对象 E\",\"@Component public class E { private static final Logger log = LoggerFactory.getLogger(E.class); private F f; public E() { log.info(\\\"E()\\\"); } @Autowired public void setF(F f) { this.f = f; log.info(\\\"setF(F f) {}\\\", f.getClass()); } public F getF() { return f; } } \",\"要注入的对象 F 期望是多例\",\"@Component @Scope(\\\"prototype\\\") public class F { private static final Logger log = LoggerFactory.getLogger(F.class); public F() { log.info(\\\"F()\\\"); } } \",\"测试\",\"E e = context.getBean(E.class); F f1 = e.getF(); F f2 = e.getF(); System.out.println(f1); System.out.println(f2); \",\"输出\",\"com.itheima.demo.cycle.F@6622fc65 com.itheima.demo.cycle.F@6622fc65 \",\"发现它们是同一个对象，而不是期望的多例对象\",\"对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F\",\"解决\",\"仍然使用 @Lazy 生成代理\",\"代理对象虽然还是同一个，但当每次使用代理对象的任意方法时，由代理创建新的 f 对象\",\"@Component public class E { @Autowired @Lazy public void setF(F f) { this.f = f; log.info(\\\"setF(F f) {}\\\", f.getClass()); } // ... } \",\"注意\",\"@Lazy 加在也可以加在成员变量上，但加在 set 方法上的目的是可以观察输出，加在成员变量上就不行了\",\"@Autowired 加在 set 方法的目的类似\",\"输出\",\"E: setF(F f) class com.itheima.demo.cycle.F$$EnhancerBySpringCGLIB$$8b54f2bc F: F() com.itheima.demo.cycle.F@3a6f2de3 F: F() com.itheima.demo.cycle.F@56303b57 \",\"从输出日志可以看到调用 setF 方法时，f 对象的类型是代理类型\"]},\"501\":{\"h\":\"演示2 - 4种解决方法\"},\"502\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a08.sub 包\",\"如果 jdk > 8, 运行时请添加 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"503\":{\"h\":\"收获💡\",\"t\":[\"单例注入其它 scope 的四种解决方法 \",\"@Lazy\",\"@Scope(value = \\\"prototype\\\", proxyMode = ScopedProxyMode.TARGET_CLASS)\",\"ObjectFactory\",\"ApplicationContext\",\"解决方法虽然不同，但理念上殊途同归: 都是推迟其它 scope bean 的获取\"]},\"504\":{\"h\":\"AOP\",\"t\":[\"AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能\",\"除此以外，aspectj 提供了两种另外的 AOP 底层实现：\",\"第一种是通过 ajc 编译器在编译 class 类文件时，就把通知的增强功能，织入到目标类的字节码中\",\"第二种是通过 agent 在加载目标类时，修改目标类的字节码，织入增强功能\",\"作为对比，之前学习的代理是运行时生成新的字节码\",\"简单比较的话：\",\"aspectj 在编译和加载时，修改目标字节码，性能较高\",\"aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强\",\"但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行\"]},\"505\":{\"h\":\"9) AOP 实现之 ajc 编译器\",\"t\":[\"代码参考项目 demo6_advanced_aspectj_01\"]},\"506\":{\"h\":\"收获💡\",\"t\":[\"编译器也能修改 class 实现增强\",\"编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强\",\"注意\",\"版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16\",\"一定要用 maven 的 compile 来编译, idea 不会调用 ajc 编译器\"]},\"507\":{\"h\":\"10) AOP 实现之 agent 类加载\",\"t\":[\"代码参考项目 demo6_advanced_aspectj_02\"]},\"508\":{\"h\":\"收获💡\",\"t\":[\"类加载时可以通过 agent 修改 class 实现增强\"]},\"509\":{\"h\":\"11) AOP 实现之 proxy\"},\"510\":{\"h\":\"演示1 - jdk 动态代理\",\"t\":[\"public class JdkProxyDemo { interface Foo { void foo(); } static class Target implements Foo { public void foo() { System.out.println(\\\"target foo\\\"); } } public static void main(String[] param) { // 目标对象 Target target = new Target(); // 代理对象 Foo proxy = (Foo) Proxy.newProxyInstance( Target.class.getClassLoader(), new Class[]{Foo.class}, (p, method, args) -> { System.out.println(\\\"proxy before...\\\"); Object result = method.invoke(target, args); System.out.println(\\\"proxy after...\\\"); return result; }); // 调用代理 proxy.foo(); } } \",\"运行结果\",\"proxy before... target foo proxy after... \"]},\"511\":{\"h\":\"收获💡\",\"t\":[\"jdk 动态代理要求目标必须实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系\"]},\"512\":{\"h\":\"演示2 - cglib 代理\",\"t\":[\"public class CglibProxyDemo { static class Target { public void foo() { System.out.println(\\\"target foo\\\"); } } public static void main(String[] param) { // 目标对象 Target target = new Target(); // 代理对象 Target proxy = (Target) Enhancer.create(Target.class, (MethodInterceptor) (p, method, args, methodProxy) -> { System.out.println(\\\"proxy before...\\\"); Object result = methodProxy.invoke(target, args); // 另一种调用方法，不需要目标对象实例 // Object result = methodProxy.invokeSuper(p, args); System.out.println(\\\"proxy after...\\\"); return result; }); // 调用代理 proxy.foo(); } } \",\"运行结果与 jdk 动态代理相同\"]},\"513\":{\"h\":\"收获💡\",\"t\":[\"cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系\",\"限制⛔：根据上述分析 final 类无法被 cglib 增强\"]},\"514\":{\"h\":\"12) jdk 动态代理进阶\"},\"515\":{\"h\":\"演示1 - 模拟 jdk 动态代理\",\"t\":[\"目标接口Foo.java\",\"public interface Foo { void foo(); int bar(); } \",\"目标类Target.java\",\"public class Target implements Foo { @Override public void foo() { System.out.println(\\\"foo\\\"); } @Override public int bar() { System.out.println(\\\"bar\\\"); return 100; } }; } \",\"InvocationHandler接口\",\"public interface InvocationHandler { Object invoke(Object proxy, Method method, Object[] args) throws Exception; } \",\"代理类$Proxy0\",\"// ⬇️这就是 jdk 代理类的源码, 秘密都在里面 public class $Proxy0 implements Foo { private final InvocationHandler h; public $Proxy0(InvocationHandler h) { this.h = h; } // ⬇️3. 进入代理方法 public void foo() { try { // ⬇️4. 回调 InvocationHandler h.invoke(this, foo, new Object[0]); } catch (RuntimeException | Error e) { throw e; } catch (Throwable e) { throw new UndeclaredThrowableException(e); } } @Override public int bar() { try { Object result = h.invoke(this, bar, new Object[0]); return (int) result; } catch (RuntimeException | Error e) { throw e; } catch (Throwable e) { throw new UndeclaredThrowableException(e); } } static Method foo; static Method bar; static { try { foo = A12.Foo.class.getMethod(\\\"foo\\\"); bar = A12.Foo.class.getMethod(\\\"bar\\\"); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } } \",\"测试方法\",\"public class Client { public static void main(String[] args) { $Proxy0 proxy = new $Proxy0(new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\\\"before...\\\"); // 发射调用目标方法 Object result = method.invoke(new Target(), args); System.out.println(\\\"after...\\\"); return result; } }); proxy.foo(); proxy.bar(); } } \"]},\"516\":{\"h\":\"收获💡\",\"t\":[\"代理一点都不难，无非就是利用了多态、反射的知识\",\"方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部\",\"通过接口回调将【增强逻辑】置于代理类之外\",\"配合接口方法反射（是多态调用），就可以再联动调用目标方法\",\"会用 arthas 的 jad 工具反编译代理类\",\"限制⛔：代理增强是借助多态来实现，因此成员变量、静态方法、final 方法均不能通过代理实现\"]},\"517\":{\"h\":\"演示2 - 方法反射优化\"},\"518\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a12.TestMethodInvoke\"]},\"519\":{\"h\":\"收获💡\",\"t\":[\"前 16 次反射性能较低\",\"第 17 次调用会生成代理类，优化为非反射调用\",\"会用 arthas 的 jad 工具反编译第 17 次调用生成的代理类\",\"注意\",\"运行时请添加 --add-opens java.base/java.lang.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED\"]},\"520\":{\"h\":\"13) cglib 代理进阶\"},\"521\":{\"h\":\"演示 - 模拟 cglib 代理\"},\"522\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a13 包\"]},\"523\":{\"h\":\"收获💡\",\"t\":[\"和 jdk 动态代理原理查不多\",\"回调的接口换了一下，InvocationHandler 改成了 MethodInterceptor\",\"调用目标时有所改进，见下面代码片段 \",\"method.invoke 是反射调用，必须调用到足够次数才会进行优化\",\"methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）\",\"methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象\",\"public class A14Application { public static void main(String[] args) throws InvocationTargetException { Target target = new Target(); Proxy proxy = new Proxy(); proxy.setCallbacks(new Callback[]{(MethodInterceptor) (p, m, a, mp) -> { System.out.println(\\\"proxy before...\\\" + mp.getSignature()); // ⬇️调用目标方法(三种) // Object result = m.invoke(target, a); // ⬅️反射调用 // Object result = mp.invoke(target, a); // ⬅️非反射调用, 结合目标用 Object result = mp.invokeSuper(p, a); // ⬅️非反射调用, 结合代理用 System.out.println(\\\"proxy after...\\\" + mp.getSignature()); return result; }}); // ⬇️调用代理方法 proxy.save(); } } \",\"注意\",\"调用 Object 的方法, 后两种在 jdk >= 9 时都有问题, 需要 --add-opens java.base/java.lang=ALL-UNNAMED\"]},\"524\":{\"h\":\"14) cglib 避免反射调用\"},\"525\":{\"h\":\"演示 - cglib 如何避免反射\"},\"526\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a13.ProxyFastClass，com.itheima.a13.TargetFastClass\"]},\"527\":{\"h\":\"收获💡\",\"t\":[\"当调用 MethodProxy 的 invoke 或 invokeSuper 方法时, 会动态生成两个类 \",\"ProxyFastClass 配合代理对象一起使用, 避免反射\",\"TargetFastClass 配合目标对象一起使用, 避免反射 (Spring 用的这种)\",\"TargetFastClass 记录了 Target 中方法与编号的对应关系 \",\"save(long) 编号 2\",\"save(int) 编号 1\",\"save() 编号 0\",\"首先根据方法名和参数个数、类型, 用 switch 和 if 找到这些方法编号\",\"然后再根据编号去调用目标方法, 又用了一大堆 switch 和 if, 但避免了反射\",\"ProxyFastClass 记录了 Proxy 中方法与编号的对应关系，不过 Proxy 额外提供了下面几个方法 \",\"saveSuper(long) 编号 2，不增强，仅是调用 super.save(long)\",\"saveSuper(int) 编号 1，不增强, 仅是调用 super.save(int)\",\"saveSuper() 编号 0，不增强, 仅是调用 super.save()\",\"查找方式与 TargetFastClass 类似\",\"为什么有这么麻烦的一套东西呢？ \",\"避免反射, 提高性能, 代价是一个代理类配两个 FastClass 类, 代理类中还得增加仅调用 super 的一堆方法\",\"用编号处理方法对应关系比较省内存, 另外, 最初获得方法顺序是不确定的, 这个过程没法固定死\"]},\"528\":{\"h\":\"15) jdk 和 cglib 在 Spring 中的统一\",\"t\":[\"Spring 中对切点、通知、切面的抽象如下\",\"切点：接口 Pointcut，典型实现 AspectJExpressionPointcut\",\"通知：典型接口为 MethodInterceptor 代表环绕通知\",\"切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut\",\"代理相关类图\",\"AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现\",\"AopProxy 通过 getProxy 创建代理对象\",\"图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）\",\"调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor\"]},\"529\":{\"h\":\"演示 - 底层切点、通知、切面\"},\"530\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a15.A15\"]},\"531\":{\"h\":\"收获💡\",\"t\":[\"底层的切点实现\",\"底层的通知实现\",\"底层的切面实现\",\"ProxyFactory 用来创建代理 \",\"如果指定了接口，且 proxyTargetClass = false，使用 JdkDynamicAopProxy\",\"如果没有指定接口，或者 proxyTargetClass = true，使用 ObjenesisCglibAopProxy \",\"例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy\",\"注意\",\"要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口\"]},\"532\":{\"h\":\"16) 切点匹配\"},\"533\":{\"h\":\"演示 - 切点匹配\"},\"534\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a16.A16\"]},\"535\":{\"h\":\"收获💡\",\"t\":[\"常见 aspectj 切点用法\",\"aspectj 切点的局限性，实际的 @Transactional 切点实现\"]},\"536\":{\"h\":\"17) 从 @Aspect 到 Advisor\"},\"537\":{\"h\":\"演示1 - 代理创建器\"},\"538\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy 包\"]},\"539\":{\"h\":\"收获💡\",\"t\":[\"AnnotationAwareAspectJAutoProxyCreator 的作用 \",\"将高级 @Aspect 切面统一为低级 Advisor 切面\",\"在合适的时机创建代理\",\"findEligibleAdvisors 找到有【资格】的 Advisors \",\"有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3\",\"有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect 后获得\",\"wrapIfNecessary \",\"它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理\",\"它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行\"]},\"540\":{\"h\":\"演示2 - 代理创建时机\"},\"541\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A17_1\"]},\"542\":{\"h\":\"收获💡\",\"t\":[\"代理的创建时机 \",\"初始化之后 (无循环依赖时)\",\"实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存\",\"依赖注入与初始化不应该被增强, 仍应被施加于原始对象\"]},\"543\":{\"h\":\"演示3 - @Before 对应的低级通知\"},\"544\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A17_2\"]},\"545\":{\"h\":\"收获💡\",\"t\":[\"@Before 前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息 \",\"通知代码从哪儿来\",\"切点是什么(这里为啥要切点, 后面解释)\",\"通知对象如何创建, 本例共用同一个 Aspect 对象\",\"类似的还有 \",\"AspectJAroundAdvice (环绕通知)\",\"AspectJAfterReturningAdvice\",\"AspectJAfterThrowingAdvice (环绕通知)\",\"AspectJAfterAdvice (环绕通知)\"]},\"546\":{\"h\":\"18) 静态通知调用\",\"t\":[\"代理对象调用流程如下（以 JDK 动态代理实现为例）\",\"从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi\",\"首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)\",\"进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)\",\"进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法\",\"目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强\",\"环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强\",\"环绕通知1返回最终的结果\",\"图中不同颜色对应一次环绕通知或目标的调用起始至终结\"]},\"547\":{\"h\":\"演示1 - 通知调用过程\"},\"548\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.A18\"]},\"549\":{\"h\":\"收获💡\",\"t\":[\"代理方法执行时会做如下工作\",\"通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知 \",\"MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor\",\"AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor\",\"这体现的是适配器设计模式\",\"所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可\",\"结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用\"]},\"550\":{\"h\":\"演示2 - 模拟 MethodInvocation\"},\"551\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.A18_1\"]},\"552\":{\"h\":\"收获💡\",\"t\":[\"proceed() 方法调用链中下一个环绕通知\",\"每个环绕通知内部继续调用 proceed()\",\"调用到没有更多通知了, 就调用目标方法\",\"MethodInvocation 的编程技巧在实现拦截器、过滤器时能用上\"]},\"553\":{\"h\":\"19) 动态通知调用\"},\"554\":{\"h\":\"演示 - 带参数绑定的通知方法调用\"},\"555\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.aop.framework.autoproxy.A19\"]},\"556\":{\"h\":\"收获💡\",\"t\":[\"通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知\",\"所谓动态通知，体现在上面方法的 DynamicInterceptionAdvice 部分，这些通知调用时因为要为通知方法绑定参数，还需再次利用切点表达式\",\"动态通知调用复杂程度高，性能较低\"]},\"557\":{\"h\":\"WEB\"},\"558\":{\"h\":\"20) RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter\",\"t\":[\"RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter 俩是一对，分别用来\",\"处理 @RequestMapping 映射\",\"调用控制器方法、并处理方法参数与方法返回值\"]},\"559\":{\"h\":\"演示1 - DispatcherServlet 初始化\"},\"560\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a20 包\"]},\"561\":{\"h\":\"收获💡\",\"t\":[\"DispatcherServlet 是在第一次被访问时执行初始化, 也可以通过配置修改为 Tomcat 启动后就初始化\",\"在初始化时会从 Spring 容器中找一些 Web 需要的组件, 如 HandlerMapping、HandlerAdapter 等，并逐一调用它们的初始化\",\"RequestMappingHandlerMapping 初始化时，会收集所有 @RequestMapping 映射信息，封装为 Map，其中 \",\"key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息\",\"value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象\",\"有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet\",\"RequestMappingHandlerAdapter 初始化时，会准备 HandlerMethod 调用时需要的各个组件，如： \",\"HandlerMethodArgumentResolver 解析控制器方法参数\",\"HandlerMethodReturnValueHandler 处理控制器方法返回值\"]},\"562\":{\"h\":\"演示2 - 自定义参数与返回值处理器\"},\"563\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a20.TokenArgumentResolver ，com.itheima.a20.YmlReturnValueHandler\"]},\"564\":{\"h\":\"收获💡\",\"t\":[\"体会参数解析器的作用\",\"体会返回值处理器的作用\"]},\"565\":{\"h\":\"21) 参数解析器\"},\"566\":{\"h\":\"演示 - 常见参数解析器\"},\"567\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a21 包\"]},\"568\":{\"h\":\"收获💡\",\"t\":[\"初步了解 RequestMappingHandlerAdapter 的调用过程 \",\"控制器方法被封装为 HandlerMethod\",\"准备对象绑定与类型转换\",\"准备 ModelAndViewContainer 用来存储中间 Model 结果\",\"解析每个参数值\",\"解析参数依赖的就是各种参数解析器，它们都有两个重要方法 \",\"supportsParameter 判断是否支持方法参数\",\"resolveArgument 解析方法参数\",\"常见参数的解析 \",\"@RequestParam\",\"省略 @RequestParam\",\"@RequestParam(defaultValue)\",\"MultipartFile\",\"@PathVariable\",\"@RequestHeader\",\"@CookieValue\",\"@Value\",\"HttpServletRequest 等\",\"@ModelAttribute\",\"省略 @ModelAttribute\",\"@RequestBody\",\"组合模式在 Spring 中的体现\",\"@RequestParam, @CookieValue 等注解中的参数名、默认值, 都可以写成活的, 即从 ${ } #{ }中获取\"]},\"569\":{\"h\":\"22) 参数名解析\"},\"570\":{\"h\":\"演示 - 两种方法获取参数名\"},\"571\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a22.A22\"]},\"572\":{\"h\":\"收获💡\",\"t\":[\"如果编译时添加了 -parameters 可以生成参数表, 反射时就可以拿到参数名\",\"如果编译时添加了 -g 可以生成调试信息, 但分为两种情况 \",\"普通类, 会包含局部变量表, 用 asm 可以拿到参数名\",\"接口, 不会包含局部变量表, 无法获得参数名 \",\"这也是 MyBatis 在实现 Mapper 接口时为何要提供 @Param 注解来辅助获得参数名\"]},\"573\":{\"h\":\"23) 对象绑定与类型转换\"},\"574\":{\"h\":\"底层第一套转换接口与实现\",\"t\":[\"Printer 把其它类型转为 String\",\"Parser 把 String 转为其它类型\",\"Formatter 综合 Printer 与 Parser 功能\",\"Converter 把类型 S 转为类型 T\",\"Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合\",\"FormattingConversionService 利用其它们实现转换\"]},\"575\":{\"h\":\"底层第二套转换接口\",\"t\":[\"PropertyEditor 把 String 与其它类型相互转换\",\"PropertyEditorRegistry 可以注册多个 PropertyEditor 对象\",\"与第一套接口直接可以通过 FormatterPropertyEditorAdapter 来进行适配\"]},\"576\":{\"h\":\"高层接口与实现\",\"t\":[\"它们都实现了 TypeConverter 这个高层转换接口，在转换时，会用到 TypeConverter Delegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（Facade 门面模式） \",\"首先看是否有自定义转换器, @InitBinder 添加的即属于这种 (用了适配器模式把 Formatter 转为需要的 PropertyEditor)\",\"再看有没有 ConversionService 转换\",\"再利用默认的 PropertyEditor 转换\",\"最后有一些特殊处理\",\"SimpleTypeConverter 仅做类型转换\",\"BeanWrapperImpl 为 bean 的属性赋值，当需要时做类型转换，走 Property\",\"DirectFieldAccessor 为 bean 的属性赋值，当需要时做类型转换，走 Field\",\"ServletRequestDataBinder 为 bean 的属性执行绑定，当需要时做类型转换，根据 directFieldAccess 选择走 Property 还是 Field，具备校验与获取校验结果功能\"]},\"577\":{\"h\":\"演示1 - 类型转换与数据绑定\"},\"578\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23 包\"]},\"579\":{\"h\":\"收获💡\",\"t\":[\"基本的类型转换与数据绑定用法\",\"SimpleTypeConverter\",\"BeanWrapperImpl\",\"DirectFieldAccessor\",\"ServletRequestDataBinder\"]},\"580\":{\"h\":\"演示2 - 数据绑定工厂\"},\"581\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23.TestServletDataBinderFactory\"]},\"582\":{\"h\":\"收获💡\",\"t\":[\"ServletRequestDataBinderFactory 的用法和扩展点\",\"可以解析控制器的 @InitBinder 标注方法作为扩展点，添加自定义转换器 \",\"控制器私有范围\",\"可以通过 ConfigurableWebBindingInitializer 配置 ConversionService 作为扩展点，添加自定义转换器 \",\"公共范围\",\"同时加了 @InitBinder 和 ConversionService 的转换优先级 \",\"优先采用 @InitBinder 的转换器\",\"其次使用 ConversionService 的转换器\",\"使用默认转换器\",\"特殊处理（例如有参构造）\"]},\"583\":{\"h\":\"演示3 - 获取泛型参数\"},\"584\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a23.sub 包\"]},\"585\":{\"h\":\"收获💡\",\"t\":[\"java api 获取泛型参数\",\"spring api 获取泛型参数\"]},\"586\":{\"h\":\"24) @ControllerAdvice 之 @InitBinder\"},\"587\":{\"h\":\"演示 - 准备 @InitBinder\",\"t\":[\"准备 @InitBinder 在整个 HandlerAdapter 调用过程中所处的位置\",\"RequestMappingHandlerAdapter 在图中缩写为 HandlerAdapter\",\"HandlerMethodArgumentResolverComposite 在图中缩写为 ArgumentResolvers\",\"HandlerMethodReturnValueHandlerComposite 在图中缩写为 ReturnValueHandlers\"]},\"588\":{\"h\":\"收获💡\",\"t\":[\"RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @InitBinder 方法\",\"RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @InitBinder 方法\",\"以上两种 @InitBinder 的解析结果都会缓存来避免重复解析\",\"控制器方法调用时，会综合利用本类的 @InitBinder 方法和 @ControllerAdvice 中的 @InitBinder 方法创建绑定工厂\"]},\"589\":{\"h\":\"25) 控制器方法执行流程\"},\"590\":{\"h\":\"图1\",\"t\":[\"HandlerMethod 需要\",\"bean 即是哪个 Controller\",\"method 即是 Controller 中的哪个方法\",\"ServletInvocableHandlerMethod 需要\",\"WebDataBinderFactory 负责对象绑定、类型转换\",\"ParameterNameDiscoverer 负责参数名解析\",\"HandlerMethodArgumentResolverComposite 负责解析参数\",\"HandlerMethodReturnValueHandlerComposite 负责处理返回值\"]},\"591\":{\"h\":\"图2\"},\"592\":{\"h\":\"图3\"},\"593\":{\"h\":\"26) @ControllerAdvice 之 @ModelAttribute\"},\"594\":{\"h\":\"演示 - 准备 @ModelAttribute\"},\"595\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a26 包\",\"准备 @ModelAttribute 在整个 HandlerAdapter 调用过程中所处的位置\"]},\"596\":{\"h\":\"收获💡\",\"t\":[\"RequestMappingHandlerAdapter 初始化时会解析 @ControllerAdvice 中的 @ModelAttribute 方法\",\"RequestMappingHandlerAdapter 会以类为单位，在该类首次使用时，解析此类的 @ModelAttribute 方法\",\"以上两种 @ModelAttribute 的解析结果都会缓存来避免重复解析\",\"控制器方法调用时，会综合利用本类的 @ModelAttribute 方法和 @ControllerAdvice 中的 @ModelAttribute 方法创建模型工厂\"]},\"597\":{\"h\":\"27) 返回值处理器\"},\"598\":{\"h\":\"演示 - 常见返回值处理器\"},\"599\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a27 包\"]},\"600\":{\"h\":\"收获💡\",\"t\":[\"常见的返回值处理器 \",\"ModelAndView，分别获取其模型和视图名，放入 ModelAndViewContainer\",\"返回值类型为 String 时，把它当做视图名，放入 ModelAndViewContainer\",\"返回值添加了 @ModelAttribute 注解时，将返回值作为模型，放入 ModelAndViewContainer \",\"此时需找到默认视图名\",\"返回值省略 @ModelAttribute 注解且返回非简单类型时，将返回值作为模型，放入 ModelAndViewContainer \",\"此时需找到默认视图名\",\"返回值类型为 ResponseEntity 时 \",\"此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true\",\"返回值类型为 HttpHeaders 时 \",\"会设置 ModelAndViewContainer.requestHandled 为 true\",\"返回值添加了 @ResponseBody 注解时 \",\"此时走 MessageConverter，并设置 ModelAndViewContainer.requestHandled 为 true\",\"组合模式在 Spring 中的体现 + 1\"]},\"601\":{\"h\":\"28) MessageConverter\"},\"602\":{\"h\":\"演示 - MessageConverter 的作用\"},\"603\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a28.A28\"]},\"604\":{\"h\":\"收获💡\",\"t\":[\"MessageConverter 的作用 \",\"@ResponseBody 是返回值处理器解析的\",\"但具体转换工作是 MessageConverter 做的\",\"如何选择 MediaType \",\"首先看 @RequestMapping 上有没有指定\",\"其次看 request 的 Accept 头有没有指定\",\"最后按 MessageConverter 的顺序, 谁能谁先转换\"]},\"605\":{\"h\":\"29) @ControllerAdvice 之 ResponseBodyAdvice\"},\"606\":{\"h\":\"演示 - ResponseBodyAdvice 增强\"},\"607\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a29 包\",\"ResponseBodyAdvice 增强 在整个 HandlerAdapter 调用过程中所处的位置\"]},\"608\":{\"h\":\"收获💡\",\"t\":[\"ResponseBodyAdvice 返回响应体前包装\"]},\"609\":{\"h\":\"30) 异常解析器\"},\"610\":{\"h\":\"演示 - ExceptionHandlerExceptionResolver\"},\"611\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a30.A30\"]},\"612\":{\"h\":\"收获💡\",\"t\":[\"它能够重用参数解析器、返回值处理器，实现组件重用\",\"它能够支持嵌套异常\"]},\"613\":{\"h\":\"31) @ControllerAdvice 之 @ExceptionHandler\"},\"614\":{\"h\":\"演示 - 准备 @ExceptionHandler\"},\"615\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a31 包\"]},\"616\":{\"h\":\"收获💡\",\"t\":[\"ExceptionHandlerExceptionResolver 初始化时会解析 @ControllerAdvice 中的 @ExceptionHandler 方法\",\"ExceptionHandlerExceptionResolver 会以类为单位，在该类首次处理异常时，解析此类的 @ExceptionHandler 方法\",\"以上两种 @ExceptionHandler 的解析结果都会缓存来避免重复解析\"]},\"617\":{\"h\":\"32) Tomcat 异常处理\",\"t\":[\"我们知道 @ExceptionHandler 只能处理发生在 mvc 流程中的异常，例如控制器内、拦截器内，那么如果是 Filter 出现了异常，如何进行处理呢？\",\"在 Spring Boot 中，是这么实现的：\",\"因为内嵌了 Tomcat 容器，因此可以配置 Tomcat 的错误页面，Filter 与 错误页面之间是通过请求转发跳转的，可以在这里做手脚\",\"先通过 ErrorPageRegistrarBeanPostProcessor 这个后处理器配置错误页面地址，默认为 /error 也可以通过 ${server.error.path} 进行配置\",\"当 Filter 发生异常时，不会走 Spring 流程，但会走 Tomcat 的错误处理，于是就希望转发至 /error 这个地址 \",\"当然，如果没有 @ExceptionHandler，那么最终也会走到 Tomcat 的错误处理\",\"Spring Boot 又提供了一个 BasicErrorController，它就是一个标准 @Controller，@RequestMapping 配置为 /error，所以处理异常的职责就又回到了 Spring\",\"异常信息由于会被 Tomcat 放入 request 作用域，因此 BasicErrorController 里也能获取到\",\"具体异常信息会由 DefaultErrorAttributes 封装好\",\"BasicErrorController 通过 Accept 头判断需要生成哪种 MediaType 的响应 \",\"如果要的不是 text/html，走 MessageConverter 流程\",\"如果需要 text/html，走 mvc 流程，此时又分两种情况 \",\"配置了 ErrorViewResolver，根据状态码去找 View\",\"没配置或没找到，用 BeanNameViewResolver 根据一个固定为 error 的名字找到 View，即所谓的 WhitelabelErrorView\",\"评价\",\"一个错误处理搞得这么复杂，就问恶心不？\"]},\"618\":{\"h\":\"演示1 - 错误页处理\"},\"619\":{\"h\":\"关键代码\",\"t\":[\"@Bean // ⬅️修改了 Tomcat 服务器默认错误地址, 出错时使用请求转发方式跳转 public ErrorPageRegistrar errorPageRegistrar() { return webServerFactory -> webServerFactory.addErrorPages(new ErrorPage(\\\"/error\\\")); } @Bean // ⬅️TomcatServletWebServerFactory 初始化前用它增强, 注册所有 ErrorPageRegistrar public ErrorPageRegistrarBeanPostProcessor errorPageRegistrarBeanPostProcessor() { return new ErrorPageRegistrarBeanPostProcessor(); } \"]},\"620\":{\"h\":\"收获💡\",\"t\":[\"Tomcat 的错误页处理手段\"]},\"621\":{\"h\":\"演示2 - BasicErrorController\"},\"622\":{\"h\":\"关键代码\",\"t\":[\"@Bean // ⬅️ErrorProperties 封装环境键值, ErrorAttributes 控制有哪些错误信息 public BasicErrorController basicErrorController() { ErrorProperties errorProperties = new ErrorProperties(); errorProperties.setIncludeException(true); return new BasicErrorController(new DefaultErrorAttributes(), errorProperties); } @Bean // ⬅️名称为 error 的视图, 作为 BasicErrorController 的 text/html 响应结果 public View error() { return new View() { @Override public void render( Map<String, ?> model, HttpServletRequest request, HttpServletResponse response ) throws Exception { System.out.println(model); response.setContentType(\\\"text/html;charset=utf-8\\\"); response.getWriter().print(\\\"\\\"\\\" <h3>服务器内部错误</h3> \\\"\\\"\\\"); } }; } @Bean // ⬅️收集容器中所有 View 对象, bean 的名字作为视图名 public ViewResolver viewResolver() { return new BeanNameViewResolver(); } \"]},\"623\":{\"h\":\"收获💡\",\"t\":[\"Spring Boot 中 BasicErrorController 如何工作\"]},\"624\":{\"h\":\"33) BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter\"},\"625\":{\"h\":\"演示 - 本组映射器和适配器\"},\"626\":{\"h\":\"关键代码\",\"t\":[\"@Bean public BeanNameUrlHandlerMapping beanNameUrlHandlerMapping() { return new BeanNameUrlHandlerMapping(); } @Bean public SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() { return new SimpleControllerHandlerAdapter(); } @Bean(\\\"/c3\\\") public Controller controller3() { return (request, response) -> { response.getWriter().print(\\\"this is c3\\\"); return null; }; } \"]},\"627\":{\"h\":\"收获💡\",\"t\":[\"BeanNameUrlHandlerMapping，以 / 开头的 bean 的名字会被当作映射路径\",\"这些 bean 本身当作 handler，要求实现 Controller 接口\",\"SimpleControllerHandlerAdapter，调用 handler\",\"模拟实现这组映射器和适配器\"]},\"628\":{\"h\":\"34) RouterFunctionMapping 与 HandlerFunctionAdapter\"},\"629\":{\"h\":\"演示 - 本组映射器和适配器\"},\"630\":{\"h\":\"关键代码\",\"t\":[\"@Bean public RouterFunctionMapping routerFunctionMapping() { return new RouterFunctionMapping(); } @Bean public HandlerFunctionAdapter handlerFunctionAdapter() { return new HandlerFunctionAdapter(); } @Bean public RouterFunction<ServerResponse> r1() { // ⬇️映射条件 ⬇️handler return route(GET(\\\"/r1\\\"), request -> ok().body(\\\"this is r1\\\")); } \"]},\"631\":{\"h\":\"收获💡\",\"t\":[\"RouterFunctionMapping, 通过 RequestPredicate 条件映射\",\"handler 要实现 HandlerFunction 接口\",\"HandlerFunctionAdapter, 调用 handler\"]},\"632\":{\"h\":\"35) SimpleUrlHandlerMapping 与 HttpRequestHandlerAdapter\"},\"633\":{\"h\":\"演示1 - 本组映射器和适配器\"},\"634\":{\"h\":\"代码参考\",\"t\":[\"org.springframework.boot.autoconfigure.web.servlet.A35\"]},\"635\":{\"h\":\"关键代码\",\"t\":[\"@Bean public SimpleUrlHandlerMapping simpleUrlHandlerMapping(ApplicationContext context) { SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping(); Map<String, ResourceHttpRequestHandler> map = context.getBeansOfType(ResourceHttpRequestHandler.class); handlerMapping.setUrlMap(map); return handlerMapping; } @Bean public HttpRequestHandlerAdapter httpRequestHandlerAdapter() { return new HttpRequestHandlerAdapter(); } @Bean(\\\"/**\\\") public ResourceHttpRequestHandler handler1() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"static/\\\"))); return handler; } @Bean(\\\"/img/**\\\") public ResourceHttpRequestHandler handler2() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"images/\\\"))); return handler; } \"]},\"636\":{\"h\":\"收获💡\",\"t\":[\"SimpleUrlHandlerMapping 不会在初始化时收集映射信息，需要手动收集\",\"SimpleUrlHandlerMapping 映射路径\",\"ResourceHttpRequestHandler 作为静态资源 handler\",\"HttpRequestHandlerAdapter, 调用此 handler\"]},\"637\":{\"h\":\"演示2 - 静态资源解析优化\"},\"638\":{\"h\":\"关键代码\",\"t\":[\"@Bean(\\\"/**\\\") public ResourceHttpRequestHandler handler1() { ResourceHttpRequestHandler handler = new ResourceHttpRequestHandler(); handler.setLocations(List.of(new ClassPathResource(\\\"static/\\\"))); handler.setResourceResolvers(List.of( // ⬇️缓存优化 new CachingResourceResolver(new ConcurrentMapCache(\\\"cache1\\\")), // ⬇️压缩优化 new EncodedResourceResolver(), // ⬇️原始资源解析 new PathResourceResolver() )); return handler; } \"]},\"639\":{\"h\":\"收获💡\",\"t\":[\"责任链模式体现\",\"压缩文件需要手动生成\"]},\"640\":{\"h\":\"演示3 - 欢迎页\"},\"641\":{\"h\":\"关键代码\",\"t\":[\"@Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext context) { Resource resource = context.getResource(\\\"classpath:static/index.html\\\"); return new WelcomePageHandlerMapping(null, context, resource, \\\"/**\\\"); } @Bean public SimpleControllerHandlerAdapter simpleControllerHandlerAdapter() { return new SimpleControllerHandlerAdapter(); } \"]},\"642\":{\"h\":\"收获💡\",\"t\":[\"欢迎页支持静态欢迎页与动态欢迎页\",\"WelcomePageHandlerMapping 映射欢迎页（即只映射 '/'） \",\"它内置的 handler ParameterizableViewController 作用是不执行逻辑，仅根据视图名找视图\",\"视图名固定为 forward:index.html\",\"SimpleControllerHandlerAdapter, 调用 handler \",\"转发至 /index.html\",\"处理 /index.html 又会走上面的静态资源处理流程\"]},\"643\":{\"h\":\"映射器与适配器小结\",\"t\":[\"HandlerMapping 负责建立请求与控制器之间的映射关系 \",\"RequestMappingHandlerMapping (与 @RequestMapping 匹配)\",\"WelcomePageHandlerMapping (/)\",\"BeanNameUrlHandlerMapping (与 bean 的名字匹配 以 / 开头)\",\"RouterFunctionMapping (函数式 RequestPredicate, HandlerFunction)\",\"SimpleUrlHandlerMapping (静态资源 通配符 /** /img/**)\",\"之间也会有顺序问题, boot 中默认顺序如上\",\"HandlerAdapter 负责实现对各种各样的 handler 的适配调用 \",\"RequestMappingHandlerAdapter 处理：@RequestMapping 方法 \",\"参数解析器、返回值处理器体现了组合模式\",\"SimpleControllerHandlerAdapter 处理：Controller 接口\",\"HandlerFunctionAdapter 处理：HandlerFunction 函数式接口\",\"HttpRequestHandlerAdapter 处理：HttpRequestHandler 接口 (静态资源处理)\",\"这也是典型适配器模式体现\"]},\"644\":{\"h\":\"36) mvc 处理流程\",\"t\":[\"当浏览器发送一个请求 http://localhost:8080/hello 后，请求到达服务器，其处理流程是：\",\"服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术\",\"路径：默认映射路径为 /，即会匹配到所有请求 URL，可作为请求的统一入口，也被称之为前控制器\",\"jsp 不会匹配到 DispatcherServlet\",\"其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet\",\"创建：在 Boot 中，由 DispatcherServletAutoConfiguration 这个自动配置类提供 DispatcherServlet 的 bean\",\"初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量 \",\"HandlerMapping，初始化时记录映射关系\",\"HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器\",\"HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器\",\"ViewResolver\",\"DispatcherServlet 会利用 RequestMappingHandlerMapping 查找控制器方法\",\"例如根据 /hello 路径找到 @RequestMapping(\\\"/hello\\\") 对应的控制器方法\",\"控制器方法会被封装为 HandlerMethod 对象，并结合匹配到的拦截器一起返回给 DispatcherServlet\",\"HandlerMethod 和拦截器合在一起称为 HandlerExecutionChain（调用链）对象\",\"DispatcherServlet 接下来会：\",\"调用拦截器的 preHandle 方法\",\"RequestMappingHandlerAdapter 调用 handle 方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod \",\"@ControllerAdvice 全局增强点1️⃣：补充模型数据\",\"@ControllerAdvice 全局增强点2️⃣：补充自定义类型转换器\",\"使用 HandlerMethodArgumentResolver 准备参数 \",\"@ControllerAdvice 全局增强点3️⃣：RequestBody 增强\",\"调用 ServletInvocableHandlerMethod\",\"使用 HandlerMethodReturnValueHandler 处理返回值 \",\"@ControllerAdvice 全局增强点4️⃣：ResponseBody 增强\",\"根据 ModelAndViewContainer 获取 ModelAndView \",\"如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程 \",\"例如，有的返回值处理器调用了 HttpMessageConverter 来将结果转换为 JSON，这时 ModelAndView 就为 null\",\"如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程\",\"调用拦截器的 postHandle 方法\",\"处理异常或视图渲染 \",\"如果 1~3 出现异常，走 ExceptionHandlerExceptionResolver 处理异常流程 \",\"@ControllerAdvice 全局增强点5️⃣：@ExceptionHandler 异常处理\",\"正常，走视图解析及渲染流程\",\"调用拦截器的 afterCompletion 方法\"]},\"645\":{\"h\":\"Boot\"},\"646\":{\"h\":\"37) Boot 骨架项目\",\"t\":[\"如果是 linux 环境，用以下命令即可获取 spring boot 的骨架 pom.xml\",\"curl -G https://start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml \",\"也可以使用 Postman 等工具实现\",\"若想获取更多用法，请参考\",\"curl https://start.spring.io \"]},\"647\":{\"h\":\"38) Boot War项目\",\"t\":[\"步骤1：创建模块，区别在于打包方式选择 war\",\"接下来勾选 Spring Web 支持\",\"步骤2：编写控制器\",\"@Controller public class MyController { @RequestMapping(\\\"/hello\\\") public String abc() { System.out.println(\\\"进入了控制器\\\"); return \\\"hello\\\"; } } \",\"步骤3：编写 jsp 视图，新建 webapp 目录和一个 hello.jsp 文件，注意文件名与控制器方法返回的视图逻辑名一致\",\"src |- main |- java |- resources |- webapp |- hello.jsp \",\"步骤4：配置视图路径，打开 application.properties 文件\",\"spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp \",\"将来 prefix + 控制器方法返回值 + suffix 即为视图完整路径\"]},\"648\":{\"h\":\"测试\",\"t\":[\"如果用 mvn 插件 mvn spring-boot:run 或 main 方法测试\",\"必须添加如下依赖，因为此时用的还是内嵌 tomcat，而内嵌 tomcat 默认不带 jasper（用来解析 jsp）\",\"<dependency> <groupId>org.apache.tomcat.embed</groupId> <artifactId>tomcat-embed-jasper</artifactId> <scope>provided</scope> </dependency> \",\"也可以使用 Idea 配置 tomcat 来测试，此时用的是外置 tomcat\",\"骨架生成的代码中，多了一个 ServletInitializer，它的作用就是配置外置 Tomcat 使用的，在外置 Tomcat 启动后，去调用它创建和运行 SpringApplication\"]},\"649\":{\"h\":\"启示\",\"t\":[\"对于 jar 项目，若要支持 jsp，也可以在加入 jasper 依赖的前提下，把 jsp 文件置入 META-INF/resources\"]},\"650\":{\"h\":\"39) Boot 启动过程\",\"t\":[\"阶段一：SpringApplication 构造\",\"记录 BeanDefinition 源\",\"推断应用类型\",\"记录 ApplicationContext 初始化器\",\"记录监听器\",\"推断主启动类\",\"阶段二：执行 run 方法\",\"得到 SpringApplicationRunListeners，名字取得不好，实际是事件发布器\",\"发布 application starting 事件1️⃣\",\"封装启动 args\",\"准备 Environment 添加命令行参数（*）\",\"ConfigurationPropertySources 处理（*）\",\"发布 application environment 已准备事件2️⃣\",\"通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理（*）\",\"application.properties，由 StandardConfigDataLocationResolver 解析\",\"spring.application.json\",\"绑定 spring.main 到 SpringApplication 对象（*）\",\"打印 banner（*）\",\"创建容器\",\"准备容器\",\"发布 application context 已初始化事件3️⃣\",\"加载 bean 定义\",\"发布 application prepared 事件4️⃣\",\"refresh 容器\",\"发布 application started 事件5️⃣\",\"执行 runner\",\"发布 application ready 事件6️⃣\",\"这其中有异常，发布 application failed 事件7️⃣\",\"带 * 的有独立的示例\"]},\"651\":{\"h\":\"演示 - 启动过程\",\"t\":[\"com.itheima.a39.A39_1 对应 SpringApplication 构造\",\"com.itheima.a39.A39_2 对应第1步，并演示 7 个事件\",\"com.itheima.a39.A39_3 对应第2、8到12步\",\"org.springframework.boot.Step3\",\"org.springframework.boot.Step4\",\"org.springframework.boot.Step5\",\"org.springframework.boot.Step6\",\"org.springframework.boot.Step7\"]},\"652\":{\"h\":\"收获💡\",\"t\":[\"SpringApplication 构造方法中所做的操作 \",\"可以有多种源用来加载 bean 定义\",\"应用类型推断\",\"添加容器初始化器\",\"添加监听器\",\"演示主类推断\",\"如何读取 spring.factories 中的配置\",\"从配置中获取重要的事件发布器：SpringApplicationRunListeners\",\"容器的创建、初始化器增强、加载 bean 定义等\",\"CommandLineRunner、ApplicationRunner 的作用\",\"环境对象 \",\"命令行 PropertySource\",\"ConfigurationPropertySources 规范环境键名称\",\"EnvironmentPostProcessor 后处理增强 \",\"由 EventPublishingRunListener 通过监听事件2️⃣来调用\",\"绑定 spring.main 前缀的 key value 至 SpringApplication\",\"Banner\"]},\"653\":{\"h\":\"40) Tomcat 内嵌容器\",\"t\":[\"Tomcat 基本结构\",\"Server └───Service ├───Connector (协议, 端口) └───Engine └───Host(虚拟主机 localhost) ├───Context1 (应用1, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase ) │ │ index.html │ └───WEB-INF │ │ web.xml (servlet, filter, listener) 3.0 │ ├───classes (servlet, controller, service ...) │ ├───jsp │ └───lib (第三方 jar 包) └───Context2 (应用2) │ index.html └───WEB-INF web.xml \"]},\"654\":{\"h\":\"演示1 - Tomcat 内嵌容器\"},\"655\":{\"h\":\"关键代码\",\"t\":[\"public static void main(String[] args) throws LifecycleException, IOException { // 1.创建 Tomcat 对象 Tomcat tomcat = new Tomcat(); tomcat.setBaseDir(\\\"tomcat\\\"); // 2.创建项目文件夹, 即 docBase 文件夹 File docBase = Files.createTempDirectory(\\\"boot.\\\").toFile(); docBase.deleteOnExit(); // 3.创建 Tomcat 项目, 在 Tomcat 中称为 Context Context context = tomcat.addContext(\\\"\\\", docBase.getAbsolutePath()); // 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() { @Override public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException { HelloServlet helloServlet = new HelloServlet(); ctx.addServlet(\\\"aaa\\\", helloServlet).addMapping(\\\"/hello\\\"); } }, Collections.emptySet()); // 5.启动 Tomcat tomcat.start(); // 6.创建连接器, 设置监听端口 Connector connector = new Connector(new Http11Nio2Protocol()); connector.setPort(8080); tomcat.setConnector(connector); } \"]},\"656\":{\"h\":\"演示2 - 集成 Spring 容器\"},\"657\":{\"h\":\"关键代码\",\"t\":[\"WebApplicationContext springContext = getApplicationContext(); // 4.编程添加 Servlet context.addServletContainerInitializer(new ServletContainerInitializer() { @Override public void onStartup(Set<Class<?>> c, ServletContext ctx) throws ServletException { // ⬇️通过 ServletRegistrationBean 添加 DispatcherServlet 等 for (ServletRegistrationBean registrationBean : springContext.getBeansOfType(ServletRegistrationBean.class).values()) { registrationBean.onStartup(ctx); } } }, Collections.emptySet()); \"]},\"658\":{\"h\":\"41) Boot 自动配置\"},\"659\":{\"h\":\"AopAutoConfiguration\",\"t\":[\"Spring Boot 是利用了自动配置类来简化了 aop 相关配置\",\"AOP 自动配置类为 org.springframework.boot.autoconfigure.aop.AopAutoConfiguration\",\"可以通过 spring.aop.auto=false 禁用 aop 自动配置\",\"AOP 自动配置的本质是通过 @EnableAspectJAutoProxy 来开启了自动代理，如果在引导类上自己添加了 @EnableAspectJAutoProxy 那么以自己添加的为准\",\"@EnableAspectJAutoProxy 的本质是向容器中添加了 AnnotationAwareAspectJAutoProxyCreator 这个 bean 后处理器，它能够找到容器中所有切面，并为匹配切点的目标类创建代理，创建代理的工作一般是在 bean 的初始化阶段完成的\"]},\"660\":{\"h\":\"DataSourceAutoConfiguration\",\"t\":[\"对应的自动配置类为：org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\",\"它内部采用了条件装配，通过检查容器的 bean，以及类路径下的 class，来决定该 @Bean 是否生效\",\"简单说明一下，Spring Boot 支持两大类数据源：\",\"EmbeddedDatabase - 内嵌数据库连接池\",\"PooledDataSource - 非内嵌数据库连接池\",\"PooledDataSource 又支持如下数据源\",\"hikari 提供的 HikariDataSource\",\"tomcat-jdbc 提供的 DataSource\",\"dbcp2 提供的 BasicDataSource\",\"oracle 提供的 PoolDataSourceImpl\",\"如果知道数据源的实现类类型，即指定了 spring.datasource.type，理论上可以支持所有数据源，但这样做的一个最大问题是无法订制每种数据源的详细配置（如最大、最小连接数等）\"]},\"661\":{\"h\":\"MybatisAutoConfiguration\",\"t\":[\"MyBatis 自动配置类为 org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\",\"它主要配置了两个 bean \",\"SqlSessionFactory - MyBatis 核心对象，用来创建 SqlSession\",\"SqlSessionTemplate - SqlSession 的实现，此实现会与当前线程绑定\",\"用 ImportBeanDefinitionRegistrar 的方式扫描所有标注了 @Mapper 注解的接口\",\"用 AutoConfigurationPackages 来确定扫描的包\",\"还有一个相关的 bean：MybatisProperties，它会读取配置文件中带 mybatis. 前缀的配置项进行定制配置\",\"@MapperScan 注解的作用与 MybatisAutoConfiguration 类似，会注册 MapperScannerConfigurer 有如下区别\",\"@MapperScan 扫描具体包（当然也可以配置关注哪个注解）\",\"@MapperScan 如果不指定扫描具体包，则会把引导类范围内，所有接口当做 Mapper 接口\",\"MybatisAutoConfiguration 关注的是所有标注 @Mapper 注解的接口，会忽略掉非 @Mapper 标注的接口\",\"这里有同学有疑问，之前介绍的都是将具体类交给 Spring 管理，怎么到了 MyBatis 这儿，接口就可以被管理呢？\",\"其实并非将接口交给 Spring 管理，而是每个接口会对应一个 MapperFactoryBean，是后者被 Spring 所管理，接口只是作为 MapperFactoryBean 的一个属性来配置\"]},\"662\":{\"h\":\"TransactionAutoConfiguration\",\"t\":[\"事务自动配置类有两个：\",\"org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration\",\"org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration\",\"前者配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作\",\"后者功能上对标 @EnableTransactionManagement，包含以下三个 bean\",\"BeanFactoryTransactionAttributeSourceAdvisor 事务切面类，包含通知和切点\",\"TransactionInterceptor 事务通知类，由它在目标方法调用前后加入事务操作\",\"AnnotationTransactionAttributeSource 会解析 @Transactional 及事务属性，也包含了切点功能\",\"如果自己配置了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自己配置的为准\"]},\"663\":{\"h\":\"ServletWebServerFactoryAutoConfiguration\",\"t\":[\"提供 ServletWebServerFactory\"]},\"664\":{\"h\":\"DispatcherServletAutoConfiguration\",\"t\":[\"提供 DispatcherServlet\",\"提供 DispatcherServletRegistrationBean\"]},\"665\":{\"h\":\"WebMvcAutoConfiguration\",\"t\":[\"配置 DispatcherServlet 的各项组件，提供的 bean 见过的有 \",\"多项 HandlerMapping\",\"多项 HandlerAdapter\",\"HandlerExceptionResolver\"]},\"666\":{\"h\":\"ErrorMvcAutoConfiguration\",\"t\":[\"提供的 bean 有 BasicErrorController\"]},\"667\":{\"h\":\"MultipartAutoConfiguration\",\"t\":[\"它提供了 org.springframework.web.multipart.support.StandardServletMultipartResolver\",\"该 bean 用来解析 multipart/form-data 格式的数据\"]},\"668\":{\"h\":\"HttpEncodingAutoConfiguration\",\"t\":[\"POST 请求参数如果有中文，无需特殊设置，这是因为 Spring Boot 已经配置了 org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter\",\"对应配置 server.servlet.encoding.charset=UTF-8，默认就是 UTF-8\",\"当然，它只影响非 json 格式的数据\"]},\"669\":{\"h\":\"演示 - 自动配置类原理\"},\"670\":{\"h\":\"关键代码\",\"t\":[\"假设已有第三方的两个自动配置类\",\"@Configuration // ⬅️第三方的配置类 static class AutoConfiguration1 { @Bean public Bean1 bean1() { return new Bean1(); } } @Configuration // ⬅️第三方的配置类 static class AutoConfiguration2 { @Bean public Bean2 bean2() { return new Bean2(); } } \",\"提供一个配置文件 META-INF/spring.factories，key 为导入器类名，值为多个自动配置类名，用逗号分隔\",\"MyImportSelector=\\\\ AutoConfiguration1,\\\\ AutoConfiguration2 \",\"注意\",\"上述配置文件中 MyImportSelector 与 AutoConfiguration1，AutoConfiguration2 为简洁均省略了包名，自己测试时请将包名根据情况补全\",\"引入自动配置\",\"@Configuration // ⬅️本项目的配置类 @Import(MyImportSelector.class) static class Config { } static class MyImportSelector implements DeferredImportSelector { // ⬇️该方法从 META-INF/spring.factories 读取自动配置类名，返回的 String[] 即为要导入的配置类 public String[] selectImports(AnnotationMetadata importingClassMetadata) { return SpringFactoriesLoader .loadFactoryNames(MyImportSelector.class, null).toArray(new String[0]); } } \"]},\"671\":{\"h\":\"收获💡\",\"t\":[\"自动配置类本质上就是一个配置类而已，只是用 META-INF/spring.factories 管理，与应用配置类解耦\",\"@Enable 打头的注解本质是利用了 @Import\",\"@Import 配合 DeferredImportSelector 即可实现导入，selectImports 方法的返回值即为要导入的配置类名\",\"DeferredImportSelector 的导入会在最后执行，为的是让其它配置优先解析\"]},\"672\":{\"h\":\"42) 条件装配底层\",\"t\":[\"条件装配的底层是本质上是 @Conditional 与 Condition，这两个注解。引入自动配置类时，期望满足一定条件才能被 Spring 管理，不满足则不管理，怎么做呢？\",\"比如条件是【类路径下必须有 dataSource】这个 bean ，怎么做呢？\",\"首先编写条件判断类，它实现 Condition 接口，编写条件判断逻辑\",\"static class MyCondition1 implements Condition { // ⬇️如果存在 Druid 依赖，条件成立 public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return ClassUtils.isPresent(\\\"com.alibaba.druid.pool.DruidDataSource\\\", null); } } \",\"其次，在要导入的自动配置类上添加 @Conditional(MyCondition1.class)，将来此类被导入时就会做条件检查\",\"@Configuration // 第三方的配置类 @Conditional(MyCondition1.class) // ⬅️加入条件 static class AutoConfiguration1 { @Bean public Bean1 bean1() { return new Bean1(); } } \",\"分别测试加入和去除 druid 依赖，观察 bean1 是否存在于容器\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.17</version> </dependency> \"]},\"673\":{\"h\":\"收获💡\",\"t\":[\"学习一种特殊的 if - else\"]},\"674\":{\"h\":\"其它\"},\"675\":{\"h\":\"43) FactoryBean\"},\"676\":{\"h\":\"演示 - FactoryBean\"},\"677\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a43 包\"]},\"678\":{\"h\":\"收获💡\",\"t\":[\"它的作用是用制造创建过程较为复杂的产品, 如 SqlSessionFactory, 但 @Bean 已具备等价功能\",\"使用上较为古怪, 一不留神就会用错 \",\"被 FactoryBean 创建的产品 \",\"会认为创建、依赖注入、Aware 接口回调、前初始化这些都是 FactoryBean 的职责, 这些流程都不会走\",\"唯有后初始化的流程会走, 也就是产品可以被代理增强\",\"单例的产品不会存储于 BeanFactory 的 singletonObjects 成员中, 而是另一个 factoryBeanObjectCache 成员中\",\"按名字去获取时, 拿到的是产品对象, 名字前面加 & 获取的是工厂对象\"]},\"679\":{\"h\":\"44) @Indexed 原理\",\"t\":[\"真实项目中，只需要加入以下依赖即可\",\"<dependency> <groupId>org.springframework</groupId> <artifactId>spring-context-indexer</artifactId> <optional>true</optional> </dependency> \"]},\"680\":{\"h\":\"演示 - @Indexed\"},\"681\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a44 包\"]},\"682\":{\"h\":\"收获💡\",\"t\":[\"在编译时就根据 @Indexed 生成 META-INF/spring.components 文件\",\"扫描时 \",\"如果发现 META-INF/spring.components 存在, 以它为准加载 bean definition\",\"否则, 会遍历包下所有 class 资源 (包括 jar 内的)\",\"解决的问题，在编译期就找到 @Component 组件，节省运行期间扫描 @Component 的时间\"]},\"683\":{\"h\":\"45) 代理进一步理解\"},\"684\":{\"h\":\"演示 - 代理\"},\"685\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a45 包\"]},\"686\":{\"h\":\"收获💡\",\"t\":[\"spring 代理的设计特点\",\"依赖注入和初始化影响的是原始对象\",\"因此 cglib 不能用 MethodProxy.invokeSuper()\",\"代理与目标是两个对象，二者成员变量并不共用数据\",\"static 方法、final 方法、private 方法均无法增强\",\"进一步理解代理增强基于方法重写\"]},\"687\":{\"h\":\"46) @Value 装配底层\"},\"688\":{\"h\":\"按类型装配的步骤\",\"t\":[\"查看需要的类型是否为 Optional，是，则进行封装（非延迟），否则向下走\",\"查看需要的类型是否为 ObjectFactory 或 ObjectProvider，是，则进行封装（延迟），否则向下走\",\"查看需要的类型（成员或参数）上是否用 @Lazy 修饰，是，则返回代理，否则向下走\",\"解析 @Value 的值 \",\"如果需要的值是字符串，先解析 ${ }，再解析 #\",\"不是字符串，需要用 TypeConverter 转换\",\"看需要的类型是否为 Stream、Array、Collection、Map，是，则按集合处理，否则向下走\",\"在 BeanFactory 的 resolvableDependencies 中找有没有类型合适的对象注入，没有向下走\",\"在 BeanFactory 及父工厂中找类型匹配的 bean 进行筛选，筛选时会考虑 @Qualifier 及泛型\",\"结果个数为 0 抛出 NoSuchBeanDefinitionException 异常\",\"如果结果 > 1，再根据 @Primary 进行筛选\",\"如果结果仍 > 1，再根据成员名或变量名进行筛选\",\"结果仍 > 1，抛出 NoUniqueBeanDefinitionException 异常\"]},\"689\":{\"h\":\"演示 - @Value 装配过程\"},\"690\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a46 包\"]},\"691\":{\"h\":\"收获💡\",\"t\":[\"ContextAnnotationAutowireCandidateResolver 作用之一，获取 @Value 的值\",\"了解 ${ } 对应的解析器\",\"了解 #{ } 对应的解析器\",\"TypeConvert 的一项体现\"]},\"692\":{\"h\":\"47) @Autowired 装配底层\"},\"693\":{\"h\":\"演示 - @Autowired 装配过程\"},\"694\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a47 包\"]},\"695\":{\"h\":\"收获💡\",\"t\":[\"@Autowired 本质上是根据成员变量或方法参数的类型进行装配\",\"如果待装配类型是 Optional，需要根据 Optional 泛型找到 bean，再封装为 Optional 对象装配\",\"如果待装配的类型是 ObjectFactory，需要根据 ObjectFactory 泛型创建 ObjectFactory 对象装配 \",\"此方法可以延迟 bean 的获取\",\"如果待装配的成员变量或方法参数上用 @Lazy 标注，会创建代理对象装配 \",\"此方法可以延迟真实 bean 的获取\",\"被装配的代理不作为 bean\",\"如果待装配类型是数组，需要获取数组元素类型，根据此类型找到多个 bean 进行装配\",\"如果待装配类型是 Collection 或其子接口，需要获取 Collection 泛型，根据此类型找到多个 bean\",\"如果待装配类型是 ApplicationContext 等特殊类型 \",\"会在 BeanFactory 的 resolvableDependencies 成员按类型查找装配\",\"resolvableDependencies 是 map 集合，key 是特殊类型，value 是其对应对象\",\"不能直接根据 key 进行查找，而是用 isAssignableFrom 逐一尝试右边类型是否可以被赋值给左边的 key 类型\",\"如果待装配类型有泛型参数 \",\"需要利用 ContextAnnotationAutowireCandidateResolver 按泛型参数类型筛选\",\"如果待装配类型有 @Qualifier \",\"需要利用 ContextAnnotationAutowireCandidateResolver 按注解提供的 bean 名称筛选\",\"有 @Primary 标注的 @Component 或 @Bean 的处理\",\"与成员变量名或方法参数名同名 bean 的处理\"]},\"696\":{\"h\":\"48) 事件监听器\"},\"697\":{\"h\":\"演示 - 事件监听器\"},\"698\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a48 包\"]},\"699\":{\"h\":\"收获💡\",\"t\":[\"事件监听器的两种方式\",\"实现 ApplicationListener 接口 \",\"根据接口泛型确定事件类型\",\"@EventListener 标注监听方法 \",\"根据监听器方法参数确定事件类型\",\"解析时机：在 SmartInitializingSingleton（所有单例初始化完成后），解析每个单例 bean\"]},\"700\":{\"h\":\"49) 事件发布器\"},\"701\":{\"h\":\"演示 - 事件发布器\"},\"702\":{\"h\":\"代码参考\",\"t\":[\"com.itheima.a49 包\"]},\"703\":{\"h\":\"收获💡\",\"t\":[\"事件发布器模拟实现\",\"addApplicationListenerBean 负责收集容器中的监听器 \",\"监听器会统一转换为 GenericApplicationListener 对象，以支持判断事件类型\",\"multicastEvent 遍历监听器集合，发布事件 \",\"发布前先通过 GenericApplicationListener.supportsEventType 判断支持该事件类型才发事件\",\"可以利用线程池进行异步发事件优化\",\"如果发送的事件对象不是 ApplicationEvent 类型，Spring 会把它包装为 PayloadApplicationEvent 并用泛型技术解析事件对象的原始类型 \",\"视频中未讲解\"]},\"704\":{\"h\":\"Spring\"},\"705\":{\"h\":\"列举一些重要的Spring模块\",\"t\":[\"下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。\",\"Spring Core：核心模块，Spring其他功能基本都需要依赖于该类库，主要提供IOC依赖注入功能的支持\",\"Spring Aspects：该模块为与AspectJ的集成提供支持\",\"Spring AOP：提供了面向切面编程的实现\",\"Spring Data Access / Integration \",\"spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。\",\"spring-tx : 提供对事务的支持。\",\"spring-orm : 提供对 Hibernate 等 ORM 框架的支持。\",\"spring-oxm ： 提供对 Castor 等 OXM 框架的支持。\",\"spring-jms : Java 消息服务。\",\"Spring Web \",\"spring-web ：对 Web 功能的实现提供一些最基础的支持。\",\"spring-webmvc ： 提供对 Spring MVC 的实现。\",\"spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。\",\"spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.\",\"Spring test：Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。\"]},\"706\":{\"h\":\"请你说说Spring的核心是什么？\",\"t\":[\"Spring的核心是IoC和AOP\",\"IoC叫反转控制，就是将对象的控制权交由Spring框架来管理。IOC可以帮助我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。\",\"说到IoC就不得不说DI，IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来替代它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。\",\"DI主要有两种注入方式：\",\"构造方法注入\",\"setter方法注入\",\"AOP是面向切面编程的意思。将那些与业务无关却为业务模块共同调用的逻辑或责任（如事务处理、日志管理和权限管理等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，也有利于未来的可拓展性和可维护性。比如@Transactional注解就是通过AOP实现的。\",\"Spring AOP是基于动态代理的。如果代理对象实现了某个接口，那么Spring AOP会使用JDK Proxy通过接口去创建代理对象，对于没有实现接口的对象，Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。\",\"当然也可以使用AspectJ！\"]},\"707\":{\"h\":\"说一说对Spring容器的了解\",\"t\":[\"Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext\",\"BeanFactory：是基础类型的IoC容器，是IoC的顶层接口，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个对象时，该对象才会进行初始化以及依赖注入的操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。\",\"ApplicationContext：他是在BeanFactory的基础上构建的，是BeanFactory的子接口，拥有BeanFactory的所有支持。除此之外，还支持比如事件发布、国际化信息支持（继承了MessageSource）等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并进行依赖注入。所以，对于BeanFactory而言，ApplicationContext要求更多的系统资源。同时，因为在启动时就完成所有初始化，容器启动的时间较BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。\"]},\"708\":{\"h\":\"说一说对BeanFactory的了解\",\"t\":[\"其实就是说上面的，包括ApplicationContext\",\"BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，可以创建并管理各种类的对象。这些被创建和管理的对象叫做Bean。\",\"BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了很多实现，比较常用的比如AnnotationConfigApplicationContext，常用的方法比如getBean()获取指定名称的Bean。\",\"BeanFactory本身并不会自动解析像@Bean,@Autowired,@Resources这些注解的功能，如果想要通过BeanFactory实现这些功能，则需要向BeanFactory添加一些后置处理器来解析这些注解，从而将相关Bean加入到IoC容器中。\"]},\"709\":{\"h\":\"Spring是如何管理Bean的\",\"t\":[\"Spring通过IoC来管理Bean，我们可以通过XML配置或者注解来进行配置。\",\"以下是管理Bean时常用的一些注解：\",\"@ComponentScan：用于声明扫描策略。通过它的声明，Spring就知道要哪些包下带声明的类需要被扫描。\",\"@Component，@Repository，@Service，@Controller用于类上声明Bean，他们的作用一样，只是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类当被扫描到时就会创建对应的Bean\",\"@Autowired，@Qualifier，@Resource，@Value用于注入Bean。@Autowired用于按类型注入，@Qualifier指定Bean名称注入需要与@Autowired一起使用，@Resource既可以按类型注入也可以指定Bean名称注入，@Value适用于注入基本类型。\",\"@Scope用于声明Bean的作用域。\",\"@PostConstruct，@PreDestory用于声明Bean的生命周期。其中被@PostConstruct修饰的发给发将在Bean实例化后被调用，@PreDestory修饰的方法将在容器销毁前调用。\"]},\"710\":{\"h\":\"Bean的作用域\",\"t\":[\"默认情况下，Bean在Spring容器中是单例的，可以通过@Scope注解修改Bean的作用域。\",\"类型\",\"说明\",\"singleton\",\"单例Bean，默认作用域，IoC容器启动时创建，IoC容器销毁时销毁\",\"prototype\",\"每次请求都会创建一个新的bean实例，每次使用时创建，销毁不归容器管，自行调用销毁方法\",\"request\",\"每一次HTTP请求（浏览器刷新页面）都会产生一个新的Bean\",\"session\",\"同一个HTTP Session共享一个Bean，不同的HTTP Session（不同的浏览器）使用不同的Bean\",\"application\",\"应用程序启动时bean创建，应用程序销毁时bean销毁，应用程序值得是ServletContext\"]},\"711\":{\"h\":\"Bean的生命周期\",\"t\":[\"解析类得到BeanDefinition\",\"通过构造方法实例化得到一个对象（如果有多个构造方法，则要推断使用）\",\"对加了@Autowired或者相关注解对对象进行依赖注入\",\"回调Aware接口的方法，比如BeanNameAware中setBeanName()方法，BeanFactoryAware中setBeanFactory()方法。\",\"调用BeanPostProcessor的初始化前的方法\",\"调用初始化方法\",\"调用BeanPostProcessor的初始化后的方法，这会进行AOP\",\"如果当前创建的Bean是单例的则会放入单例池\",\"使用Bean\",\"Spring容器关闭时调用DisposableBean中的destory()方法\",\"@Slf4j @Component public class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor { @Override // 实例化前（即调用构造方法前）执行的方法 public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 实例化前执行，如@PreDestroy\\\"); // 返回null保持原有对象不变，返回不为null，会替换掉原有对象 return null; } @Override // 实例化后执行的方法 public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) { log.debug(\\\"<<<<<<<<<<< 实例化后执行，这里如果返回 false 会跳过依赖注入阶段\\\"); // return false; } return true; } @Override // 依赖注入阶段执行的方法 public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException { if (beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 依赖注入阶段执行，如@Autowired、@Value、@Resource\\\"); return pvs; } @Override // 销毁前执行的方法 public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<<销毁之前执行\\\"); } @Override // 初始化之前执行的方法 public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 初始化之前执行，这里返回的对象会替换掉原本的bean，如 @PostConstruct、@ConfigurationProperties\\\"); return bean; } @Override // 初始化之后执行的方法 public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { if(beanName.equals(\\\"lifeCycleBean\\\")) log.debug(\\\"<<<<<<<<<<< 初始化之后执行，这里返回的对象会替换掉原本的bean，如 代理增强\\\"); return bean; } } \"]},\"712\":{\"h\":\"单例Bean的线程安全问题了解吗\",\"t\":[\"要是问Bean的线程安全问题需要考虑单例Bean还是多例Bean，多例Bean不存在线程安全问题\",\"单例Bean存在线程安全问题，主要是因为当多个线程操作同一个对象的时候存在共享资源竞争的问题。\",\"两种解决方法：\",\"在Bean中尽量避免定义可变的成员变量。\",\"在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中\",\"不过，大部分Bean实际都是无状态（没有实例变量）的（比如Dao、Service），这种情况下，Bean是线程安全的。\"]},\"713\":{\"h\":\"@Component和@Bean的区别是什么？\",\"t\":[\"@Component注解作用于类，通常是通过类路径扫描（@ComponentScan）自动侦测以及自动装配到Spring容器中。而@Bean注解作用于方法，将当前方法的返回值存入IOC容器。\",\"@Bean注解比@Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册Bean。比如当我们引用第三方库中的类需要装配到Spring容器中时，只能通过@Bean来实现。\"]},\"714\":{\"h\":\"AspectJ\",\"t\":[\"AspectJ与Spring AOP和Cglib实现AOP是有所不同的，AspectJ是在字节码的层面上实现的，另外两个是通过代理实现的。\",\"AspectJ相当于在被增强方法的class文件的对应位置调用增强方法实现AOP\",\"对于AspectJ的实现也有两种，一种在编译阶段实现，一种在类加载阶段实现\",\"编译阶段：通过在pom文件中配置AspectJ编译插件实现\",\"类加载阶段：通过配置虚拟机参数-javaagent实现，具体类的样式可以通过阿里巴巴的arthas插件看到\"]},\"715\":{\"h\":\"Spring AOP和AspectJ AOP的区别？\",\"t\":[\"Spring AOP输入运行时增强，而AspectJ是编译时或者类加载时增强。\",\"Spring AOP基于代理，而AspectJ基于字节码操作。\"]},\"716\":{\"h\":\"说说AOP的应用场景\",\"t\":[\"Spring AOP为IoC的使用提供了更多的便利。一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨应用的多个模块功能抽象出来，通过AOP编织到模块中，比如可以通过AOP实现应用程序中的日志功能。\",\"另一方面，在Spring内部，事务处理也是通过AOP实现的。\"]},\"717\":{\"h\":\"Spring AOP不能对哪些类进行增强\",\"t\":[\"Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。\",\"由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。\"]},\"718\":{\"h\":\"既然没有接口都可以用CGLib，为什么Spring还要使用JDK动态代理\",\"t\":[\"在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象无需频繁创建代理对象，采用CGLib比较合适。反之，对于多例的对象因为要频繁创建代理对象，则JDK动态代理更合适。\"]},\"719\":{\"h\":\"Spring是如何管理事务的\",\"t\":[\"编程式事务：Spring提供了TransactionTemplate和TransactionManager手动管理事务。这种方式相对麻烦，实际应用中很少使用。\",\"声明式事务：在XML配置文件中配置或者直接基于注解（推荐使用），实际是通过AOP实现的（基于@Transactional的全注解方式使用最多）\"]},\"720\":{\"h\":\"Spring中的事务传播行为\",\"t\":[\"当我们调用一个业务方法时，它的内部可能会调用其他的业务方法，以完成一个完整的业务操作。这种业务方法嵌套调用的时候，如果这两个方法都是要保证事务的，那么就要通过Spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中。\",\"Spring在TransactionDefinition接口中规定了其中类型的事务传播行为。\",\"事务传播类型\",\"说明\",\"PROPAGATION_REQUIRED\",\"如果当前没有事务，则新建一个事务；如果已存在一个事务，在加入到这个事务中。这时最常见的选择，也是@Transactional的默认选项。\",\"PROPAGATION_REQUIRED_NEW\",\"创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，REQUIRES_NEW修饰的内部方法都会开启自己的新事务，且开启的事务互相独立，互不干扰。\",\"PROPAGATION_NESTED\",\"如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则等价于PROPAGATION_REQUIRED（nested：嵌套的）\",\"PROPAGATION_MANDATORY\",\"如果当前存在事务，则加入该事务；如果不存在则抛出异常。（mandatory：强制性）\",\"PROPAGATION_SUPPORTS\",\"如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式继续运行\",\"PROPAGATION_NOT_SUPPORTED\",\"以非事务方式运行，如果当前存在事务，则把当前事务挂起\",\"PROPAGATION_NEVER\",\"以非事务方式运行，如果当前存在事务，则抛出异常\",\"若是错误的配置了以下三种事务传播行为，事务将不会发生回滚。\"]},\"721\":{\"h\":\"Spring的事务如何配置，常用注解有那些？\",\"t\":[\"事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器。在Spring Boot中，当你添加了数据库访问框架的起步依赖时，他就会进行自动配置，即自动实例化正确的事务管理器。\",\"对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。\",\"当他标注在类上时，代表着各类所有公共（public）非静态方法（static）都将启用事务功能\",\"当它标注在方法上时，代表这个方法将启用事务功能。\",\"另外，在@Transactional注解上，我们可以使用isolation属性声明事物的隔离级别，使用propagation属性声明事物的传播行为。\"]},\"722\":{\"h\":\"@Transactional(rollbackFor = Exception.class)注解了解吗\",\"t\":[\"Exception分为运行时异常和非运行时异常。\",\"在@Transactional注解中如果不配置rollbackFor属性，那么事务只会在遇到RuntimeException的时候才会回滚，加上rollbackFor=Exception.class，可以让事务在遇到非运行时异常时也会回滚。\"]},\"723\":{\"h\":\"@Transactional失效场景\",\"t\":[\"@Transaction应用再非public修饰的方法上\",\"@Transaction注解属性propagation设置错误，上面写的传播行为后三个会使之失效\",\"@Transactional注解属性rollbackFor设置错误\",\"数据库引擎不支持事务，只有InnoDB支持事务\"]},\"724\":{\"h\":\"Spring是怎么解决循环依赖的\",\"t\":[\"TODO\"]},\"725\":{\"h\":\"SpringBoot\"},\"726\":{\"h\":\"说说你对Spring Boot的理解\",\"t\":[\"从本质上来说，Spring Boot就是Spring。Spring Boot使用“约定大于配置”的理念让你的项目快速的运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。\",\"简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目。Spring Boot有如下优点：\",\"可以快速构建项目\",\"可以对主流开发框架的无配置集成\",\"项目可独立运行，无需外部依赖Servlet容器\",\"提供运行时的应用监控\",\"可以极大地提高开发、部署效率\",\"可以与云计算天然集成\"]},\"727\":{\"h\":\"Spring Boot Starter有什么用\",\"t\":[\"Spring Boot提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。\",\"举例来说，你打算做个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来的简单。你只要添加Spring Boot的Web起步依赖就好了。\"]},\"728\":{\"h\":\"介绍Spring Boot的启动流程\",\"t\":[\"首先，Spring Boot项目创建完成会默认生成一个名为*Application的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过run方法进行*Application类的初始化和启动。\",\"*Application调用run方法的大致流程如下图：\",\"其中，*Application在run方法中重点做了以下操作：\",\"获取监听器的参数配置\",\"打印Banner信息\",\"创建并初始化容器\",\"监听器发送通知\",\"当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。\"]},\"729\":{\"h\":\"Spring Boot项目是如何导入包的\",\"t\":[\"通过Spring Boot Starter导入包。其他详见[0x01](#0x01. Spring Boot Starter有什么用).\"]},\"730\":{\"h\":\"Spring Boot自动装配过程\",\"t\":[\"使用Spring Boot时，我们只需引入对应的Starter，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。\",\"整个自动配置的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean，并注入Spring容器，就可以完成依赖框架的自动配置。\"]},\"731\":{\"h\":\"说说你对Spring Boot的注解的了解\",\"t\":[\"@SpringBootApplication\",\"这个注解时Spring Boot项目的基石，创建Spring Boot项目之后会默认在主类加上。\",\"我们可以把@SpringBootApplication看作是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan注解的集合。\",\"@EnableAutoConfiguration：启用Spring Boot的自动装配机制\",\"@ComponentScan：包路径扫描，扫描被@Component注解修饰的Bean\",\"@SpringBootConfiguration：就是@Configuration的不同语义的版本，允许在该类中使用@Bean实修方法注册额外的Bean或导入其他配置类\",\"@Import\",\"@EnableAutoConfiguration的关键功能就是通过@Import注解导入的ImportSelector来完成的。从源码得知@Import({AutoConfigurationImportSelector.class})是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。\",\"@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \\\"spring.boot.enableautoconfiguration\\\"; Class<?>[] exclude() default {}; String[] excludeName() default {}; } \",\"@Conditional\",\"@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制实例化的行为。\",\"@Conditional衍生注解\",\"@ConditionalOnBean：在容器中有指定Bean的时候才会加载\",\"@ConditiaonOnMissingBean：在容器中没有指定Bean的时候才会加载\",\"等等\",\"@RestController\",\"@RestController是@Controller和@ResponseBody的合集，表示这是个控制器Bean，并且是将函数的返回值直接填入HTTP响应体中，返回JSON或XML形式数据，是REST风格的控制器。\",\"@Configuration\",\"一般用来声明配置类，可以用@Component注解替代，不过使用@Configuration注解声明配置类更加语义化。\",\"@PathVariable和@RequestParam\",\"@PathVariable：用于获取路径参数\",\"@RequestParam：用于获取查询参数\",\"@GetMapping(\\\"/klasses/{klassId}/teachers\\\") public List<Teacher> getKlassRelatedTeachers( @PathVariable(\\\"klassId\\\") Long klassId, @RequestParam(value = \\\"type\\\", required = false) String type ) { ... } \",\"如果我们请求的url是：/klasses/123456/teachers?type=web\",\"那么我们服务获取到的数据就是：klassId=123456,type=web\",\"@RequestBody\",\"用于读取Request请求的body部分，并且Content-Type为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的body中的json字符串转换成java对象。\",\"我们有个注册的接口：\",\"@PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) { userService.save(userRegisterRequest); return ResponseEntity.ok().build(); } \",\"UserRegisterRequest对象\",\"@Data @AllArgsConstructor @NoArgsConstructor public class UserRegisterRequest { @NotBlank private String userName; @NotBlank private String password; @NotBlank private String fullName; } \",\"我们发送post请求到这个接口，并且body携带JSON数据。这样我们的后端就可以直接把JSON格式的数据映射到我们的UserRegisterRequest类上。\",\"{\\\"userName\\\":\\\"coder\\\",\\\"fullName\\\":\\\"shuangkou\\\",\\\"password\\\":\\\"123456\\\"} \",\"需要注意的是：一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable。 如果你的方法必须要用两个 @RequestBody来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！\",\"@Value和@ConfigurationProperties\",\"wuhan2020: 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！ my-profile: name: Guide哥 email: koushuangbwcx@163.com library: location: 湖北武汉加油中国加油 books: - name: 天才基本法 description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。 - name: 时间的秩序 description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。 - name: 了不起的我 description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？ \",\"使用@Value(\\\"${property}\\\")读取比较简单的配置信息\",\"@Value(\\\"${wuhan2020}\\\") String wuhan2020; \",\"通过@ConfigurationProperties读取配置信息并于Bean绑定，就可以像使用普通的Bean一样，将其注入到类中使用\",\"@Component @ConfigurationProperties(prefix = \\\"library\\\") @Data @ToString public class LibraryProperties { private String location; private List<Book> books; @Setter @Getter @ToString static class Book { String name; String description; } } \",\"@Autowired private LibraryProperties libraryProperties; \"]},\"732\":{\"h\":\"Spring Boot全局异常处理器\",\"t\":[\"@ControllerAdvice开启全局异常处理，使用该注解表示开启了全局异常的捕获，我们只需再自定义一个方法使用@ExceptionHandler注解，然后自定义捕获异常类型即可对这些捕获的异常进行统一处理。\",\"// 全局异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) @ResponseBody public String globalExceptionHandler(Exception e) { System.out.println(\\\"全局异常捕获>>>:\\\" + e); return \\\"全局异常捕获,错误原因>>>\\\" + e.getMessage(); } } \",\"// controller中进行测试 @PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody UserRegisterRequest userRegisterRequest) { testService.save(userRegisterRequest); int i = 1 / 0; return ResponseEntity.ok(userRegisterRequest); } \",\"结果：\",\"全局异常捕获,错误原因>>>/ by zero \"]},\"733\":{\"h\":\"SpringMVC\"},\"734\":{\"h\":\"什么是MVC\",\"t\":[\"MVC是一种设计模式，在这种模式下软件被分为三层，及Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。\"]},\"735\":{\"h\":\"DAO层是做什么的\",\"t\":[\"DAO层是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。\"]},\"736\":{\"h\":\"介绍一下Spring MVC的执行流程\",\"t\":[\"整个过程开始于客户端发出一个HTTP请求，Web应用服务器接受到这个请求。如果匹配DispatcherServlet的请求路径，则Web容器将该请求转交给DispatcherServlet处理。\",\"DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看作路由控制器，将Handler看作目标主机。\",\"当DispatcherServlet根据HandlerMapping得到对应请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架的接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。\",\"处理器完成业务逻辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。\",\"ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。\",\"当得到真实的视图对象View后，DispatcherServlet就用这个View对象对ModelAndView中的模型数据进行视图渲染。\",\"最终客户端得到的响应消息可能是有一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。\",\"简略版本：\",\"用户发送请求至前端控制器DispatcherServlet\",\"DispatcherServlet收到请求调用HandllerMapping处理器映射器\",\"处理器映射器找到具体的处理器（Handler）（可以根据xml配置，注解进行查找），生成处理器对象以及处理器拦截器（如果有拦截器则生成）一并返回给DispatcherServlet\",\"DispatcherServlet调用HandlerAdapter处理器适配器\",\"HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）\",\"Controller执行完成后返回ModelAndView\",\"HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet\",\"DispatcherServlet将ModelAndView传给ViewReslover视图解析器\",\"ViewReslover解析后返回具体View\",\"DispatcherServlet根据View进行渲染视图。（最终客户端得到的响应消息可能是有一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。）\"]},\"737\":{\"h\":\"说一说你知道的Spring MVC注解\",\"t\":[\"@RequestMapping\",\"该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上\",\"属性：\",\"mothod：请求类型，比如get和post\",\"value：请求地址\",\"@RequestParam\",\"是将请求参数绑定到控制器的方法参数上，是Spring MVC中的接收普通参数的注解\",\"@RequestBody\",\"用于读取Request请求的body部分，并且Content-Type为application/json格式的数据，接收到数据之后会自动将数据绑定到Java对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的body中的json字符串转换成java对象。\",\"@PostMapping(\\\"/sign-up\\\") public ResponseEntity signUp(@RequestBody UserRegisterRequest userRegisterRequest) { testService.save(userRegisterRequest); return ResponseEntity.ok(userRegisterRequest); } \",\"@PathVariable\",\"该注解适用于绑定url中的占位符。是Spring MVC支持rest风格的一个重要标志。\",\"@GetMapping(\\\"/klasses/{klassId}/teachers\\\") public List<Teacher> getKlassRelatedTeachers( @PathVariable(\\\"klassId\\\") Long klassId, @RequestParam(value = \\\"type\\\", required = false) String type ) { } \"]},\"738\":{\"h\":\"介绍一下Sprig MVC的拦截器\",\"t\":[\"可以拓展一下SSO单点登录来讲项目\",\"Session的工作原理和使用经验 - Ken的杂谈\",\"SSO 单点登录 | JavaGuide\",\"SpringBoot实现登录拦截器（实战版） - 掘金 (juejin.cn)\",\"拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口中包含如下三个方法：preHandle(),postHandle(),afterCompletion()。\",\"这些方法的执行流程如下图：\",\"通过上图可以看出，Spring MVC拦截器的执行流程如下：\",\"执行preHandle方法，它会返回一个布尔值。如果为false，则结束所有流程，如果为true，则执行下一步。\",\"执行处理器逻辑，它包含控制器的功能\",\"执行postHandler方法\",\"执行视图解析和视图渲染\",\"执行afterCompletion方法\",\"Spring MVC拦截器的开发步骤如下：\",\"开发拦截器：实现HandlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时需要执行的具体业务逻辑，一般使用preHandle方法。\",\"注册拦截器：定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配那些请求路径。\"]},\"739\":{\"h\":\"\"},\"740\":{\"h\":\"2022.6.2暑期实习一面\",\"t\":[\"自我介绍\",\"如何实现栈\",\"给定二叉树如何遍历（二叉树退化导致的递归爆栈问题）\",\"给定如何实现正整数的白名单\",\"list删除元素（fast-fail问题）\",\"get和post的区别\",\"了解什么设计模式？什么时候用单例什么时候用多例\",\"SQL汇总学生总成绩\",\"多线程汇总结果\"]},\"741\":{\"h\":\"响应式流\"},\"742\":{\"h\":\"概念\",\"t\":[\"Reactive Streams为我们提供了Java中的Reactive Programming的通用API。传统异步编程的写法，不同任务分别在不同的线程中执行，协调这些线程执行的先后顺序、线程间的依赖顺序是一件非常麻烦的事情，而Reactive Streams就是为了解决该问题。Reactive Streams API中仅仅包含了如下四个接口：\",\"//发布者 public interface Publisher < T > { public void subscribe（Subscriber <？super T > s）; } //订阅者 public interface Subscriber < T > { public void onSubscribe（Subscription s）; public void onNext（T t）; public void onError（Throwable t）; public void onComplete（）; } //表示Subscriber消费Publisher发布的一个消息的生命周期 public interface Subscription { public void request(long n); public void cancel(); } //处理器，表示一个处理阶段，它既是订阅者也是发布者，并且遵守两者的契约 public interface Processor<T, R> extends Subscriber<T>, Publisher<R> { } \"]},\"743\":{\"h\":\"示例1\",\"t\":[\"通过Publisher，Subscriber和Subscription完成一个发布-订阅模式\",\"public class ReactiveStreamDemo { public static void main(String[] args) throws InterruptedException { // 1、定义发布者，发布的数据类型是Integer SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(); // 2、定义订阅者 Subscriber<Integer> subscriber = new Subscriber<>() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { // 保存订阅关系，需要用它来给发布者响应 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); } @Override public void onNext(Integer item) { // 接收到一个数据，处理 System.out.println(\\\"接收到数据：\\\" + item); // 处理完调用request再请求一个数据 this.subscription.request(1); // 或者已经达到目标，调用cancel告诉发布者不在调用数据 // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"处理完了\\\"); } }; // 3、发布者订阅者之间建立订阅关系 publisher.subscribe(subscriber); // 4、生产数据并发布 Stream.of(1, 2, 3, 4, 5, 6, 7, 8) .forEach(i -> { publisher.submit(i); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } }); // 5、结束后 关闭发布者 // 正式环境应放在finally或者try-resource中确保关闭 publisher.close(); Thread.currentThread().join(1000); } } \"]},\"744\":{\"h\":\"示例2\",\"t\":[\"在示例1的基础上，添加了processor进行中间处理\",\"public class MyProcessor extends SubmissionPublisher<String> implements Processor<Integer, String> { private static final String[] NUMBER_TO_CHINESE = {\\\"零\\\", \\\"壹\\\", \\\"贰\\\", \\\"叁\\\", \\\"肆\\\", \\\"伍\\\", \\\"陆\\\", \\\"柒\\\", \\\"捌\\\", \\\"玖\\\"}; private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { // 保存订阅关系，需要用它来发布响应 this.subscription = subscription; // 请求一个数据 this.subscription.request(1); } @Override public void onNext(Integer item) { // 接收到一个数据，进行处理 System.out.println(\\\"处理器接收到的数据：\\\" + item); // 过滤掉小于0的，发布出去 if (item >= 0) { this.submit(NUMBER_TO_CHINESE[item]); } // 处理完调用request再请求一个数据 this.subscription.request(1); // 或者已经达到目标，调用cancel告诉发布者不在调用数据 // this.subscription.cancel(); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"处理器处理完了\\\"); } } \",\"public class ReactiveStreamDemo2 { public static void main(String[] args) throws InterruptedException { // 1、定义发布者，发布的数据类型是Integer SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>(); // 2、定义处理器，对数据进行过滤，并转换成String类型 MyProcessor processor = new MyProcessor(); // 3、发布者和处理器之间建立订阅关系 publisher.subscribe(processor); // 4、定义最终订阅者，消费String类型数据 Subscriber<String> subscriber = new Subscriber<>() { private Subscription subscription; @Override public void onSubscribe(Subscription subscription) { this.subscription = subscription; this.subscription.request(1); } @Override public void onNext(String item) { System.out.println(\\\"接收到处理后的数据：\\\" + item); this.subscription.request(1); } @Override public void onError(Throwable throwable) { // 出现了异常 throwable.printStackTrace(); // 告诉发布者后面不接受数据了 this.subscription.cancel(); } @Override public void onComplete() { // 全部数据处理完成（发布者关闭了） System.out.println(\\\"订阅者处理完了\\\"); } }; // 5、处理器和最终订阅者建立订阅关系 processor.subscribe(subscriber); // 6、生产数据并发布 // submit是一个阻塞式方法 Stream.of(-3, -2, -1, 0, 1, 2, 3, 4, 5) .forEach(i -> { publisher.submit(i); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } }); // 7、结束后 关闭发布者 // 正式环境应放在finally或者try-resource中确保关闭 publisher.close(); Thread.currentThread().join(1000); } } \"]},\"745\":{\"h\":\"背压\",\"t\":[\"背压可以理解为订阅者能和发布者交互（通过代码里面的调用request和cancel方法交互），可以调节发布者发布数据的速率，解决把订阅者压垮的问题。关键在于上面例子里面的订阅关系Subscription这个接口，他有request和cancel 2个方法，用于通知发布者需要数据和通知发布者不再接受数据。\",\"在JDK9zhong发布者Publisher的实现类SubmissionPublisher的submit方法是block方法。订阅者会有一个缓冲池，默认为Flow.defaultBufferSize() = 256。当订阅者的缓冲池满了之后，发布者调用submit方法发布数据就会被阻塞，发布者就会停（慢）下来；订阅者消费了数据之后（调用Subscription.request方法），缓冲池有位置了，submit方法就会继续执行下去，就是通过这样的机制，实现了调节发布者发布数据的速率，消费得快，生成就快，消费得慢，发布者就会被阻塞，当然就会慢下来了。\"]},\"746\":{\"h\":\"webflux\"},\"747\":{\"h\":\"TODO\"},\"748\":{\"h\":\"粘包与半包\"},\"749\":{\"h\":\"粘包现象\",\"t\":[\"服务端代码\",\"public class HelloWorldServer { static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class); void start() { NioEventLoopGroup boss = new NioEventLoopGroup(1); NioEventLoopGroup worker = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"connected {}\\\", ctx.channel()); super.channelActive(ctx); } @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"disconnect {}\\\", ctx.channel()); super.channelInactive(ctx); } }); } }); ChannelFuture channelFuture = serverBootstrap.bind(8080); log.debug(\\\"{} binding...\\\", channelFuture.channel()); channelFuture.sync(); log.debug(\\\"{} bound...\\\", channelFuture.channel()); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); log.debug(\\\"stoped\\\"); } } public static void main(String[] args) { new HelloWorldServer().start(); } } \",\"客户端代码希望发送 10 个消息，每个消息是 16 字节\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; for (int i = 0; i < 10; i++) { ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); ctx.writeAndFlush(buffer); } } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"127.0.0.1\\\", 8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\",\"08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding... 08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound... 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| +--------+-------------------------------------------------+----------------+ 08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE \"]},\"750\":{\"h\":\"半包现象\",\"t\":[\"客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\",\"ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); } ctx.writeAndFlush(buffer); \",\"为现象明显，服务端修改一下接收缓冲区，其它代码不变\",\"serverBootstrap.option(ChannelOption.SO_RCVBUF, 10); \",\"服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\",\"08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding... 08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound... 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE 08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................| |00000010| 00 01 02 03 |.... | +--------+-------------------------------------------------+----------------+ 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................| |00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |............ | +--------+-------------------------------------------------+----------------+ 08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE \",\"注意\",\"serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\"]},\"751\":{\"h\":\"现象分析\",\"t\":[\"粘包\",\"现象，发送 abc def，接收 abcdef\",\"原因 \",\"应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\",\"滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\",\"Nagle 算法：会造成粘包\",\"半包\",\"现象，发送 abcdef，接收 abc def\",\"原因 \",\"应用层：接收方 ByteBuf 小于实际发送数据量\",\"滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\",\"MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\",\"本质是因为 TCP 是流式协议，消息无边界\",\"滑动窗口\",\"TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\",\"为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\",\"窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\",\"图中深色的部分即要发送的数据，高亮的部分即窗口\",\"窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\",\"如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\",\"接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\",\"MSS 限制\",\"链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\",\"以太网的 MTU 是 1500\",\"FDDI（光纤分布式数据接口）的 MTU 是 4352\",\"本地回环地址的 MTU 是 65535 - 本地测试不走网卡\",\"MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\",\"ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\",\"TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\",\"MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\",\"Nagle 算法\",\"即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由\",\"该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送 \",\"如果 SO_SNDBUF 的数据达到 MSS，则需要发送\",\"如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\",\"如果 TCP_NODELAY = true，则需要发送\",\"已发送的数据都收到 ack 时，则需要发送\",\"上述条件不满足，但发生超时（一般为 200ms）则需要发送\",\"除上述情况，延迟发送\"]},\"752\":{\"h\":\"解决方案\",\"t\":[\"短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\",\"每一条消息采用固定长度，缺点浪费空间\",\"每一条消息采用分隔符，例如 \\\\n，缺点需要转义\",\"每一条消息分为 head 和 body，head 中包含 body 的长度\"]},\"753\":{\"h\":\"方法1：短链接\",\"t\":[\"以解决粘包为例\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { // 分 10 次发送 for (int i = 0; i < 10; i++) { send(); } } private static void send() { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"conneted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); ByteBuf buffer = ctx.alloc().buffer(); buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}); ctx.writeAndFlush(buffer); // 发完即关 ctx.close(); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"localhost\\\", 8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"输出，略\",\"半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\"]},\"754\":{\"h\":\"方法2：固定长度\",\"t\":[\"让所有数据包长度固定（假设长度为 8 字节），服务器端加入\",\"ch.pipeline().addLast(new FixedLengthFrameDecoder(8)); \",\"客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); // 发送内容随机的数据包 Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { byte[] bytes = new byte[8]; for (int j = 0; j < r.nextInt(8); j++) { bytes[j] = (byte) c; } c++; buffer.writeBytes(bytes); } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......| |00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......| |00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....| |00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......| |00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....| +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding... 12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound... 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 00 00 00 00 |aaaa.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 00 00 00 00 00 00 00 |b....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 00 00 00 00 00 00 |cc...... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 00 00 00 00 00 00 00 |d....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 00 00 00 00 00 |........ | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 66 66 00 00 00 00 |ffff.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 67 00 00 00 00 00 |ggg..... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 00 00 00 00 00 00 00 |h....... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 00 00 00 |iiiii... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 00 00 00 00 |jjjj.... | +--------+-------------------------------------------------+----------------+ 12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE \",\"缺点是，数据包的大小不好把握\",\"长度定的太大，浪费\",\"长度定的太小，对某些数据包又显得不够\"]},\"755\":{\"h\":\"方法3：固定分隔符\",\"t\":[\"服务端加入，默认以 \\\\n 或 \\\\r\\\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\",\"ch.pipeline().addLast(new LineBasedFrameDecoder(1024)); \",\"客户端在每条消息之后，加入 \\\\n 分隔符\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { for (int j = 1; j <= r.nextInt(16)+1; j++) { buffer.writeByte((byte) c); } buffer.writeByte(10); c++; } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee| |00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg| |00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.| |00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a |jjjjjjjjjjj. | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 |a | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 62 62 |bbb | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 63 |ccc | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 64 |dd | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 65 65 65 65 65 65 65 65 65 65 |eeeeeeeeee | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 |ff | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 67 67 67 67 67 |ggggggg | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 68 68 68 |hhhh | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 69 69 |iiiiiii | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a |jjjjjjjjjjj | +--------+-------------------------------------------------+----------------+ 14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE \",\"缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\"]},\"756\":{\"h\":\"方法4：预设长度\",\"t\":[\"在发送消息前，先约定用定长字节表示接下来数据的长度\",\"// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数 ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1)); \",\"客户端代码\",\"public class HelloWorldClient { static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class); public static void main(String[] args) { NioEventLoopGroup worker = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { log.debug(\\\"connetted...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { log.debug(\\\"sending...\\\"); Random r = new Random(); char c = 'a'; ByteBuf buffer = ctx.alloc().buffer(); for (int i = 0; i < 10; i++) { byte length = (byte) (r.nextInt(16) + 1); // 先写入长度 buffer.writeByte(length); // 再 for (int j = 1; j <= length; j++) { buffer.writeByte((byte) c); } c++; } ctx.writeAndFlush(buffer); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"192.168.0.103\\\", 9090).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } } } \",\"客户端输出\",\"14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted... 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending... 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb| |00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd| |00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee| |00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff| |00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii| |00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj| |00000060| 6a |j | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH \",\"服务端输出\",\"14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding... 14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound... 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 61 61 61 61 61 61 61 61 |aaaaaaaaa | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 62 62 62 62 62 62 62 62 62 |bbbbbbbbb | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 63 63 63 63 63 63 |cccccc | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 64 64 64 64 64 64 64 64 |dddddddd | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65 |eeeeeeeeeeeeeee | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66 |fffffffffffff | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 67 67 |gg | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 68 |hh | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69 |iiiiiiiiiiiiii | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a |jjjjjjjjj | +--------+-------------------------------------------------+----------------+ 14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETEd \"]},\"757\":{\"h\":\"聊天室案例\"},\"758\":{\"h\":\"聊天室业务介绍\",\"t\":[\"/** * 用户管理接口 */ public interface UserService { /** * 登录 * @param username 用户名 * @param password 密码 * @return 登录成功返回 true, 否则返回 false */ boolean login(String username, String password); } \",\"/** * 会话管理接口 */ public interface Session { /** * 绑定会话 * @param channel 哪个 channel 要绑定会话 * @param username 会话绑定用户 */ void bind(Channel channel, String username); /** * 解绑会话 * @param channel 哪个 channel 要解绑会话 */ void unbind(Channel channel); /** * 获取属性 * @param channel 哪个 channel * @param name 属性名 * @return 属性值 */ Object getAttribute(Channel channel, String name); /** * 设置属性 * @param channel 哪个 channel * @param name 属性名 * @param value 属性值 */ void setAttribute(Channel channel, String name, Object value); /** * 根据用户名获取 channel * @param username 用户名 * @return channel */ Channel getChannel(String username); } \",\"/** * 聊天组会话管理接口 */ public interface GroupSession { /** * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null * @param name 组名 * @param members 成员 * @return 成功时返回组对象, 失败返回 null */ Group createGroup(String name, Set<String> members); /** * 加入聊天组 * @param name 组名 * @param member 成员名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group joinMember(String name, String member); /** * 移除组成员 * @param name 组名 * @param member 成员名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group removeMember(String name, String member); /** * 移除聊天组 * @param name 组名 * @return 如果组不存在返回 null, 否则返回组对象 */ Group removeGroup(String name); /** * 获取组成员 * @param name 组名 * @return 成员集合, 没有成员会返回 empty set */ Set<String> getMembers(String name); /** * 获取组成员的 channel 集合, 只有在线的 channel 才会返回 * @param name 组名 * @return 成员 channel 集合 */ List<Channel> getMembersChannel(String name); } \"]},\"759\":{\"h\":\"聊天室业务-登录\",\"t\":[\"@Slf4j public class ChatServer { public static void main(String[] args) { NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() { @Override protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception { String username = msg.getUsername(); String password = msg.getPassword(); boolean login = UserServiceFactory.getUserService().login(username, password); LoginResponseMessage message; if(login) { message = new LoginResponseMessage(true, \\\"登录成功\\\"); } else { message = new LoginResponseMessage(false, \\\"用户名或密码不正确\\\"); } ctx.writeAndFlush(message); } }); } }); Channel channel = serverBootstrap.bind(8080).sync().channel(); channel.closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } } } \",\"@Slf4j public class ChatClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1); AtomicBoolean LOGIN = new AtomicBoolean(false); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); // ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(\\\"client handler\\\", new ChannelInboundHandlerAdapter() { // 接收响应消息 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"msg: {}\\\", msg); if ((msg instanceof LoginResponseMessage)) { LoginResponseMessage response = (LoginResponseMessage) msg; if (response.isSuccess()) { // 如果登录成功 LOGIN.set(true); } // 唤醒 system in 线程 WAIT_FOR_LOGIN.countDown(); } } // 在连接建立后触发 active 事件 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { // 负责接收用户在控制台的输入，负责向服务器发送各种消息 new Thread(() -> { Scanner scanner = new Scanner(System.in); System.out.println(\\\"请输入用户名:\\\"); String username = scanner.nextLine(); System.out.println(\\\"请输入密码:\\\"); String password = scanner.nextLine(); // 构造消息对象 LoginRequestMessage message = new LoginRequestMessage(username, password); // 发送消息 ctx.writeAndFlush(message); System.out.println(\\\"等待后续操作...\\\"); try { WAIT_FOR_LOGIN.await(); } catch (InterruptedException e) { e.printStackTrace(); } // 如果登录失败 if (!LOGIN.get()) { ctx.channel().close(); return; } while (true) { System.out.println(\\\"==================================\\\"); System.out.println(\\\"send [username] [content]\\\"); System.out.println(\\\"gsend [group name] [content]\\\"); System.out.println(\\\"gcreate [group name] [m1,m2,m3...]\\\"); System.out.println(\\\"gmembers [group name]\\\"); System.out.println(\\\"gjoin [group name]\\\"); System.out.println(\\\"gquit [group name]\\\"); System.out.println(\\\"quit\\\"); System.out.println(\\\"==================================\\\"); String command = scanner.nextLine(); String[] s = command.split(\\\" \\\"); switch (s[0]){ case \\\"send\\\": ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2])); break; case \\\"gsend\\\": ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2])); break; case \\\"gcreate\\\": Set<String> set = new HashSet<>(Arrays.asList(s[2].split(\\\",\\\"))); set.add(username); // 加入自己 ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set)); break; case \\\"gmembers\\\": ctx.writeAndFlush(new GroupMembersRequestMessage(s[1])); break; case \\\"gjoin\\\": ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1])); break; case \\\"gquit\\\": ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1])); break; case \\\"quit\\\": ctx.channel().close(); return; } } }, \\\"system in\\\").start(); } }); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \"]},\"760\":{\"h\":\"聊天室业务-单聊\",\"t\":[\"服务器端将 handler 独立出来\",\"登录 handler\",\"@ChannelHandler.Sharable public class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception { String username = msg.getUsername(); String password = msg.getPassword(); boolean login = UserServiceFactory.getUserService().login(username, password); LoginResponseMessage message; if(login) { SessionFactory.getSession().bind(ctx.channel(), username); message = new LoginResponseMessage(true, \\\"登录成功\\\"); } else { message = new LoginResponseMessage(false, \\\"用户名或密码不正确\\\"); } ctx.writeAndFlush(message); } } \",\"单聊 handler\",\"@ChannelHandler.Sharable public class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception { String to = msg.getTo(); Channel channel = SessionFactory.getSession().getChannel(to); // 在线 if(channel != null) { channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent())); } // 不在线 else { ctx.writeAndFlush(new ChatResponseMessage(false, \\\"对方用户不存在或者不在线\\\")); } } } \"]},\"761\":{\"h\":\"聊天室业务-群聊\",\"t\":[\"创建群聊\",\"@ChannelHandler.Sharable public class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception { String groupName = msg.getGroupName(); Set<String> members = msg.getMembers(); // 群管理器 GroupSession groupSession = GroupSessionFactory.getGroupSession(); Group group = groupSession.createGroup(groupName, members); if (group == null) { // 发生成功消息 ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + \\\"创建成功\\\")); // 发送拉群消息 List<Channel> channels = groupSession.getMembersChannel(groupName); for (Channel channel : channels) { channel.writeAndFlush(new GroupCreateResponseMessage(true, \\\"您已被拉入\\\" + groupName)); } } else { ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + \\\"已经存在\\\")); } } } \",\"群聊\",\"@ChannelHandler.Sharable public class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception { List<Channel> channels = GroupSessionFactory.getGroupSession() .getMembersChannel(msg.getGroupName()); for (Channel channel : channels) { channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent())); } } } \",\"加入群聊\",\"@ChannelHandler.Sharable public class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception { Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername()); if (group != null) { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群加入成功\\\")); } else { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群不存在\\\")); } } } \",\"退出群聊\",\"@ChannelHandler.Sharable public class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception { Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername()); if (group != null) { ctx.writeAndFlush(new GroupJoinResponseMessage(true, \\\"已退出群\\\" + msg.getGroupName())); } else { ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \\\"群不存在\\\")); } } } \",\"查看成员\",\"@ChannelHandler.Sharable public class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception { Set<String> members = GroupSessionFactory.getGroupSession() .getMembers(msg.getGroupName()); ctx.writeAndFlush(new GroupMembersResponseMessage(members)); } } \"]},\"762\":{\"h\":\"聊天室业务-退出\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class QuitHandler extends ChannelInboundHandlerAdapter { // 当连接断开时触发 inactive 事件 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { SessionFactory.getSession().unbind(ctx.channel()); log.debug(\\\"{} 已经断开\\\", ctx.channel()); } // 当出现异常时触发 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { SessionFactory.getSession().unbind(ctx.channel()); log.debug(\\\"{} 已经异常断开 异常是{}\\\", ctx.channel(), cause.getMessage()); } } \"]},\"763\":{\"h\":\"聊天室业务-空闲检测\"},\"764\":{\"h\":\"连接假死\",\"t\":[\"原因\",\"网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\",\"公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\",\"应用程序线程阻塞，无法进行数据读写\",\"问题\",\"假死的连接占用的资源不能自动释放\",\"向假死的连接发送数据，得到的反馈是发送超时\",\"服务器端解决\",\"怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\",\"// 用来判断是不是 读空闲时间过长，或 写空闲时间过长 // 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件 ch.pipeline().addLast(new IdleStateHandler(5, 0, 0)); // ChannelDuplexHandler 可以同时作为入站和出站处理器 ch.pipeline().addLast(new ChannelDuplexHandler() { // 用来触发特殊事件 @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{ IdleStateEvent event = (IdleStateEvent) evt; // 触发了读空闲事件 if (event.state() == IdleState.READER_IDLE) { log.debug(\\\"已经 5s 没有读到数据了\\\"); ctx.channel().close(); } } }); \",\"客户端定时心跳\",\"客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\",\"// 用来判断是不是 读空闲时间过长，或 写空闲时间过长 // 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件 ch.pipeline().addLast(new IdleStateHandler(0, 3, 0)); // ChannelDuplexHandler 可以同时作为入站和出站处理器 ch.pipeline().addLast(new ChannelDuplexHandler() { // 用来触发特殊事件 @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{ IdleStateEvent event = (IdleStateEvent) evt; // 触发了写空闲事件 if (event.state() == IdleState.WRITER_IDLE) { // log.debug(\\\"3s 没有写数据了，发送一个心跳包\\\"); ctx.writeAndFlush(new PingMessage()); } } }); \"]},\"765\":{\"h\":\"协议设计与解析\"},\"766\":{\"h\":\"为什么需要协议？\",\"t\":[\"TCP/IP 中消息传输基于流的方式，没有边界。\",\"协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\",\"例如：在网络上传输\",\"下雨天留客天留我不留 \",\"是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\",\"一种解读\",\"下雨天留客，天留，我不留 \",\"另一种解读\",\"下雨天，留客天，留我不？留 \",\"如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\",\"定长字节表示内容长度 + 实际内容 \",\"例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\",\"0f下雨天留客06天留09我不留 \",\"小故事\",\"很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\",\"年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\",\"私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\",\"双方唇枪舌战，你来我往，真个是不亦乐乎！\",\"这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\"]},\"767\":{\"h\":\"redis 协议举例\",\"t\":[\"NioEventLoopGroup worker = new NioEventLoopGroup(); byte[] LINE = {13, 10}; try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(worker); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) { ch.pipeline().addLast(new LoggingHandler()); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { // 会在连接 channel 建立成功后，会触发 active 事件 @Override public void channelActive(ChannelHandlerContext ctx) { set(ctx); get(ctx); } private void get(ChannelHandlerContext ctx) { ByteBuf buf = ctx.alloc().buffer(); buf.writeBytes(\\\"*2\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"get\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"aaa\\\".getBytes()); buf.writeBytes(LINE); ctx.writeAndFlush(buf); } private void set(ChannelHandlerContext ctx) { ByteBuf buf = ctx.alloc().buffer(); buf.writeBytes(\\\"*3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"set\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"aaa\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"$3\\\".getBytes()); buf.writeBytes(LINE); buf.writeBytes(\\\"bbb\\\".getBytes()); buf.writeBytes(LINE); ctx.writeAndFlush(buf); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; System.out.println(buf.toString(Charset.defaultCharset())); } }); } }); ChannelFuture channelFuture = bootstrap.connect(\\\"localhost\\\", 6379).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"client error\\\", e); } finally { worker.shutdownGracefully(); } \"]},\"768\":{\"h\":\"http 协议举例\",\"t\":[\"NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new HttpServerCodec()); ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() { @Override protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception { // 获取请求 log.debug(msg.uri()); // 返回响应 DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK); byte[] bytes = \\\"<h1>Hello, world!</h1>\\\".getBytes(); response.headers().setInt(CONTENT_LENGTH, bytes.length); response.content().writeBytes(bytes); // 写回响应 ctx.writeAndFlush(response); } }); /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"{}\\\", msg.getClass()); if (msg instanceof HttpRequest) { // 请求行，请求头 } else if (msg instanceof HttpContent) { //请求体 } } });*/ } }); ChannelFuture channelFuture = serverBootstrap.bind(8080).sync(); channelFuture.channel().closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } \"]},\"769\":{\"h\":\"自定义协议要素\",\"t\":[\"魔数，用来在第一时间判定是否是无效数据包\",\"版本号，可以支持协议的升级\",\"序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk\",\"指令类型，是登录、注册、单聊、群聊... 跟业务相关\",\"请求序号，为了双工通信，提供异步能力\",\"正文长度\",\"消息正文\"]},\"770\":{\"h\":\"编解码器\",\"t\":[\"根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\",\"@Slf4j public class MessageCodec extends ByteToMessageCodec<Message> { @Override protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception { // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(0); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(msg); byte[] bytes = bos.toByteArray(); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerType = in.readByte(); byte messageType = in.readByte(); int sequenceId = in.readInt(); in.readByte(); // 跳过对齐填充的一个字节 int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); Message message = (Message) ois.readObject(); log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); log.debug(\\\"{}\\\", message); out.add(message); } } \",\"测试\",\"EmbeddedChannel channel = new EmbeddedChannel( new LoggingHandler(), new LengthFieldBasedFrameDecoder( 1024, 12, 4, 0, 0), new MessageCodec() ); // encode LoginRequestMessage message = new LoginRequestMessage(\\\"zhangsan\\\", \\\"123\\\", \\\"张三\\\"); // channel.writeOutbound(message); // decode ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); new MessageCodec().encode(null, message, buf); ByteBuf s1 = buf.slice(0, 100); ByteBuf s2 = buf.slice(100, buf.readableBytes() - 100); s1.retain(); // 引用计数 2 channel.writeInbound(s1); // release 1 channel.writeInbound(s2); \",\"解读\"]},\"771\":{\"h\":\"什么时候可以加 @Sharable💡\",\"t\":[\"当 handler 不保存状态时，就可以安全地在多线程下被共享\",\"但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\",\"如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类\",\"@Slf4j @ChannelHandler.Sharable /** * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的 */ public class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> { @Override protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception { ByteBuf out = ctx.alloc().buffer(); // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(0); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(msg); byte[] bytes = bos.toByteArray(); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); outList.add(out); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerType = in.readByte(); byte messageType = in.readByte(); int sequenceId = in.readInt(); in.readByte(); int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes)); Message message = (Message) ois.readObject(); log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); log.debug(\\\"{}\\\", message); out.add(message); } } \"]},\"772\":{\"h\":\"Netty优化\"},\"773\":{\"h\":\"扩展序列化算法\",\"t\":[\"序列化，反序列化主要用在消息正文的转换上\",\"序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\",\"反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\",\"目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\",\"// 反序列化 byte[] body = new byte[bodyLength]; byteByf.readBytes(body); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body)); Message message = (Message) in.readObject(); message.setSequenceId(sequenceId); // 序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(message); byte[] bytes = out.toByteArray(); \",\"为了支持更多序列化算法，抽象一个 Serializer 接口\",\"public interface Serializer { // 反序列化方法 <T> T deserialize(Class<T> clazz, byte[] bytes); // 序列化方法 <T> byte[] serialize(T object); } \",\"提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\",\"enum SerializerAlgorithm implements Serializer { // Java 实现 Java { @Override public <T> T deserialize(Class<T> clazz, byte[] bytes) { try { ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes)); Object object = in.readObject(); return (T) object; } catch (IOException | ClassNotFoundException e) { throw new RuntimeException(\\\"SerializerAlgorithm.Java 反序列化错误\\\", e); } } @Override public <T> byte[] serialize(T object) { try { ByteArrayOutputStream out = new ByteArrayOutputStream(); new ObjectOutputStream(out).writeObject(object); return out.toByteArray(); } catch (IOException e) { throw new RuntimeException(\\\"SerializerAlgorithm.Java 序列化错误\\\", e); } } }, // Json 实现(引入了 Gson 依赖) Json { @Override public <T> T deserialize(Class<T> clazz, byte[] bytes) { return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz); } @Override public <T> byte[] serialize(T object) { return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8); } }; // 需要从协议的字节中得到是哪种序列化算法 public static SerializerAlgorithm getByInt(int type) { SerializerAlgorithm[] array = SerializerAlgorithm.values(); if (type < 0 || type > array.length - 1) { throw new IllegalArgumentException(\\\"超过 SerializerAlgorithm 范围\\\"); } return array[type]; } } \",\"增加配置类和配置文件\",\"public abstract class Config { static Properties properties; static { try (InputStream in = Config.class.getResourceAsStream(\\\"/application.properties\\\")) { properties = new Properties(); properties.load(in); } catch (IOException e) { throw new ExceptionInInitializerError(e); } } public static int getServerPort() { String value = properties.getProperty(\\\"server.port\\\"); if(value == null) { return 8080; } else { return Integer.parseInt(value); } } public static Serializer.Algorithm getSerializerAlgorithm() { String value = properties.getProperty(\\\"serializer.algorithm\\\"); if(value == null) { return Serializer.Algorithm.Java; } else { return Serializer.Algorithm.valueOf(value); } } } \",\"配置文件\",\"serializer.algorithm=Json \",\"修改编解码器\",\"/** * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的 */ public class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> { @Override public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception { ByteBuf out = ctx.alloc().buffer(); // 1. 4 字节的魔数 out.writeBytes(new byte[]{1, 2, 3, 4}); // 2. 1 字节的版本, out.writeByte(1); // 3. 1 字节的序列化方式 jdk 0 , json 1 out.writeByte(Config.getSerializerAlgorithm().ordinal()); // 4. 1 字节的指令类型 out.writeByte(msg.getMessageType()); // 5. 4 个字节 out.writeInt(msg.getSequenceId()); // 无意义，对齐填充 out.writeByte(0xff); // 6. 获取内容的字节数组 byte[] bytes = Config.getSerializerAlgorithm().serialize(msg); // 7. 长度 out.writeInt(bytes.length); // 8. 写入内容 out.writeBytes(bytes); outList.add(out); } @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception { int magicNum = in.readInt(); byte version = in.readByte(); byte serializerAlgorithm = in.readByte(); // 0 或 1 byte messageType = in.readByte(); // 0,1,2... int sequenceId = in.readInt(); in.readByte(); int length = in.readInt(); byte[] bytes = new byte[length]; in.readBytes(bytes, 0, length); // 找到反序列化算法 Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm]; // 确定具体消息类型 Class<? extends Message> messageClass = Message.getMessageClass(messageType); Message message = algorithm.deserialize(messageClass, bytes); // log.debug(\\\"{}, {}, {}, {}, {}, {}\\\", magicNum, version, serializerType, messageType, sequenceId, length); // log.debug(\\\"{}\\\", message); out.add(message); } } \",\"其中确定具体消息类型，可以根据 消息类型字节 获取到对应的 消息 class\",\"@Data public abstract class Message implements Serializable { /** * 根据消息类型字节，获得对应的消息 class * @param messageType 消息类型字节 * @return 消息 class */ public static Class<? extends Message> getMessageClass(int messageType) { return messageClasses.get(messageType); } private int sequenceId; private int messageType; public abstract int getMessageType(); public static final int LoginRequestMessage = 0; public static final int LoginResponseMessage = 1; public static final int ChatRequestMessage = 2; public static final int ChatResponseMessage = 3; public static final int GroupCreateRequestMessage = 4; public static final int GroupCreateResponseMessage = 5; public static final int GroupJoinRequestMessage = 6; public static final int GroupJoinResponseMessage = 7; public static final int GroupQuitRequestMessage = 8; public static final int GroupQuitResponseMessage = 9; public static final int GroupChatRequestMessage = 10; public static final int GroupChatResponseMessage = 11; public static final int GroupMembersRequestMessage = 12; public static final int GroupMembersResponseMessage = 13; public static final int PingMessage = 14; public static final int PongMessage = 15; private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>(); static { messageClasses.put(LoginRequestMessage, LoginRequestMessage.class); messageClasses.put(LoginResponseMessage, LoginResponseMessage.class); messageClasses.put(ChatRequestMessage, ChatRequestMessage.class); messageClasses.put(ChatResponseMessage, ChatResponseMessage.class); messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class); messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class); messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class); messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class); messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class); messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class); messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class); messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class); messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class); messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class); } } \"]},\"774\":{\"h\":\"参数调优\"},\"775\":{\"h\":\"1）CONNECT_TIMEOUT_MILLIS\",\"t\":[\"属于 SocketChannal 参数\",\"用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\",\"SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\",\"@Slf4j public class TestConnectionTimeout { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); try { Bootstrap bootstrap = new Bootstrap() .group(group) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300) .channel(NioSocketChannel.class) .handler(new LoggingHandler()); ChannelFuture future = bootstrap.connect(\\\"127.0.0.1\\\", 8080); future.sync().channel().closeFuture().sync(); // 断点1 } catch (Exception e) { e.printStackTrace(); log.debug(\\\"timeout\\\"); } finally { group.shutdownGracefully(); } } } \",\"另外源码部分 io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect\",\"@Override public final void connect( final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) { // ... // Schedule connect timeout. int connectTimeoutMillis = config().getConnectTimeoutMillis(); if (connectTimeoutMillis > 0) { connectTimeoutFuture = eventLoop().schedule(new Runnable() { @Override public void run() { ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise; ConnectTimeoutException cause = new ConnectTimeoutException(\\\"connection timed out: \\\" + remoteAddress); // 断点2 if (connectPromise != null && connectPromise.tryFailure(cause)) { close(voidPromise()); } } }, connectTimeoutMillis, TimeUnit.MILLISECONDS); } // ... } \"]},\"776\":{\"h\":\"2）SO_BACKLOG\",\"t\":[\"属于 ServerSocketChannal 参数\",\"第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\",\"第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\",\"第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\",\"其中\",\"在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\",\"sync queue - 半连接队列\",\"大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 syncookies 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\",\"accept queue - 全连接队列\",\"其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\",\"如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\",\"netty 中\",\"可以通过 option(ChannelOption.SO_BACKLOG, 值) 来设置大小\",\"可以通过下面源码查看默认大小\",\"public class DefaultServerSocketChannelConfig extends DefaultChannelConfig implements ServerSocketChannelConfig { private volatile int backlog = NetUtil.SOMAXCONN; // ... } \",\"课堂调试关键断点为：io.netty.channel.nio.NioEventLoop#processSelectedKey\",\"oio 中更容易说明，不用 debug 模式\",\"public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8888, 2); Socket accept = ss.accept(); System.out.println(accept); System.in.read(); } } \",\"客户端启动 4 个\",\"public class Client { public static void main(String[] args) throws IOException { try { Socket s = new Socket(); System.out.println(new Date()+\\\" connecting...\\\"); s.connect(new InetSocketAddress(\\\"localhost\\\", 8888),1000); System.out.println(new Date()+\\\" connected...\\\"); s.getOutputStream().write(1); System.in.read(); } catch (IOException e) { System.out.println(new Date()+\\\" connecting timeout...\\\"); e.printStackTrace(); } } } \",\"第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\",\"Tue Apr 21 20:30:28 CST 2020 connecting... Tue Apr 21 20:30:28 CST 2020 connected... \",\"第 4 个客户端连接时\",\"Tue Apr 21 20:53:58 CST 2020 connecting... Tue Apr 21 20:53:59 CST 2020 connecting timeout... java.net.SocketTimeoutException: connect timed out \"]},\"777\":{\"h\":\"3）ulimit -n\",\"t\":[\"属于操作系统参数\"]},\"778\":{\"h\":\"4）TCP_NODELAY\",\"t\":[\"属于 SocketChannal 参数\",\"false：开启了nagle算法\",\"true：关闭了nagle算法（推荐）\"]},\"779\":{\"h\":\"5）SO_SNDBUF & SO_RCVBUF\",\"t\":[\"发送缓冲区和接受缓冲区，最好别修改\",\"SO_SNDBUF 属于 SocketChannal 参数\",\"SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\"]},\"780\":{\"h\":\"6）ALLOCATOR\",\"t\":[\"属于 SocketChannal 参数\",\"用来分配 ByteBuf， ctx.alloc()\"]},\"781\":{\"h\":\"7）RCVBUF_ALLOCATOR\",\"t\":[\"属于 SocketChannal 参数\",\"控制 netty 接收缓冲区大小\",\"负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\"]},\"782\":{\"h\":\"RPC 框架\"},\"783\":{\"h\":\"1）准备工作\",\"t\":[\"这些代码可以认为是现成的，无需从头编写练习\",\"为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\",\"@Data public abstract class Message implements Serializable { // 省略旧的代码 public static final int RPC_MESSAGE_TYPE_REQUEST = 101; public static final int RPC_MESSAGE_TYPE_RESPONSE = 102; static { // ... messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class); messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class); } } \",\"请求消息\",\"@Getter @ToString(callSuper = true) public class RpcRequestMessage extends Message { /** * 调用的接口全限定名，服务端根据它找到实现 */ private String interfaceName; /** * 调用接口中的方法名 */ private String methodName; /** * 方法返回类型 */ private Class<?> returnType; /** * 方法参数类型数组 */ private Class[] parameterTypes; /** * 方法参数值数组 */ private Object[] parameterValue; public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) { super.setSequenceId(sequenceId); this.interfaceName = interfaceName; this.methodName = methodName; this.returnType = returnType; this.parameterTypes = parameterTypes; this.parameterValue = parameterValue; } @Override public int getMessageType() { return RPC_MESSAGE_TYPE_REQUEST; } } \",\"响应消息\",\"@Data @ToString(callSuper = true) public class RpcResponseMessage extends Message { /** * 返回值 */ private Object returnValue; /** * 异常值 */ private Exception exceptionValue; @Override public int getMessageType() { return RPC_MESSAGE_TYPE_RESPONSE; } } \",\"服务器架子\",\"@Slf4j public class RpcServer { public static void main(String[] args) { NioEventLoopGroup boss = new NioEventLoopGroup(); NioEventLoopGroup worker = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); // rpc 请求消息处理器，待实现 RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.channel(NioServerSocketChannel.class); serverBootstrap.group(boss, worker); serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = serverBootstrap.bind(8080).sync().channel(); channel.closeFuture().sync(); } catch (InterruptedException e) { log.error(\\\"server error\\\", e); } finally { boss.shutdownGracefully(); worker.shutdownGracefully(); } } } \",\"客户端架子\",\"public class RpcClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); // rpc 响应消息处理器，待实现 RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \",\"服务器端的 service 获取\",\"public class ServicesFactory { static Properties properties; static Map<Class<?>, Object> map = new ConcurrentHashMap<>(); static { try (InputStream in = Config.class.getResourceAsStream(\\\"/application.properties\\\")) { properties = new Properties(); properties.load(in); Set<String> names = properties.stringPropertyNames(); for (String name : names) { if (name.endsWith(\\\"Service\\\")) { Class<?> interfaceClass = Class.forName(name); Class<?> instanceClass = Class.forName(properties.getProperty(name)); map.put(interfaceClass, instanceClass.newInstance()); } } } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) { throw new ExceptionInInitializerError(e); } } public static <T> T getService(Class<T> interfaceClass) { return (T) map.get(interfaceClass); } } \",\"相关配置 application.properties\",\"serializer.algorithm=Json cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl \"]},\"784\":{\"h\":\"2）服务器 handler\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) { RpcResponseMessage response = new RpcResponseMessage(); response.setSequenceId(message.getSequenceId()); try { // 获取真正的实现对象 HelloService service = (HelloService) ServicesFactory.getService(Class.forName(message.getInterfaceName())); // 获取要调用的方法 Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes()); // 调用方法 Object invoke = method.invoke(service, message.getParameterValue()); // 调用成功 response.setReturnValue(invoke); } catch (Exception e) { e.printStackTrace(); // 调用异常 response.setExceptionValue(e); } // 返回结果 ctx.writeAndFlush(response); } } \"]},\"785\":{\"h\":\"3）客户端代码第一版\",\"t\":[\"只发消息\",\"@Slf4j public class RpcClient { public static void main(String[] args) { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); try { Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); Channel channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage( 1, \\\"cn.itcast.server.service.HelloService\\\", \\\"sayHello\\\", String.class, new Class[]{String.class}, new Object[]{\\\"张三\\\"} )).addListener(promise -> { if (!promise.isSuccess()) { Throwable cause = promise.cause(); log.error(\\\"error\\\", cause); } }); channel.closeFuture().sync(); } catch (Exception e) { log.error(\\\"client error\\\", e); } finally { group.shutdownGracefully(); } } } \"]},\"786\":{\"h\":\"4）客户端 handler 第一版\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> { @Override protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception { log.debug(\\\"{}\\\", msg); } } \"]},\"787\":{\"h\":\"5）客户端代码 第二版\",\"t\":[\"包括 channel 管理，代理，接收结果\",\"@Slf4j public class RpcClientManager { public static void main(String[] args) { HelloService service = getProxyService(HelloService.class); System.out.println(service.sayHello(\\\"zhangsan\\\")); // System.out.println(service.sayHello(\\\"lisi\\\")); // System.out.println(service.sayHello(\\\"wangwu\\\")); } // 创建代理类 public static <T> T getProxyService(Class<T> serviceClass) { ClassLoader loader = serviceClass.getClassLoader(); Class<?>[] interfaces = new Class[]{serviceClass}; // sayHello \\\"张三\\\" Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> { // 1. 将方法调用转换为 消息对象 int sequenceId = SequenceIdGenerator.nextId(); RpcRequestMessage msg = new RpcRequestMessage( sequenceId, serviceClass.getName(), method.getName(), method.getReturnType(), method.getParameterTypes(), args ); // 2. 将消息对象发送出去 getChannel().writeAndFlush(msg); // 3. 准备一个空 Promise 对象，来接收结果 指定 promise 对象异步接收结果线程 DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop()); RpcResponseMessageHandler.PROMISES.put(sequenceId, promise); // promise.addListener(future -> { // // 线程 // }); // 4. 等待 promise 结果 promise.await(); if(promise.isSuccess()) { // 调用正常 return promise.getNow(); } else { // 调用失败 throw new RuntimeException(promise.cause()); } }); return (T) o; } private static Channel channel = null; private static final Object LOCK = new Object(); // 获取唯一的 channel 对象 public static Channel getChannel() { if (channel != null) { return channel; } synchronized (LOCK) { // t2 if (channel != null) { // t1 return channel; } initChannel(); return channel; } } // 初始化 channel 方法 private static void initChannel() { NioEventLoopGroup group = new NioEventLoopGroup(); LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG); MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable(); RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler(); Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class); bootstrap.group(group); bootstrap.handler(new ChannelInitializer<SocketChannel>() { @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ProcotolFrameDecoder()); ch.pipeline().addLast(LOGGING_HANDLER); ch.pipeline().addLast(MESSAGE_CODEC); ch.pipeline().addLast(RPC_HANDLER); } }); try { channel = bootstrap.connect(\\\"localhost\\\", 8080).sync().channel(); channel.closeFuture().addListener(future -> { group.shutdownGracefully(); }); } catch (Exception e) { log.error(\\\"client error\\\", e); } } } \"]},\"788\":{\"h\":\"6）客户端 handler 第二版\",\"t\":[\"@Slf4j @ChannelHandler.Sharable public class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> { // 序号 用来接收结果的 promise 对象 public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>(); @Override protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception { log.debug(\\\"{}\\\", msg); // 拿到空的 promise Promise<Object> promise = PROMISES.remove(msg.getSequenceId()); if (promise != null) { Object returnValue = msg.getReturnValue(); Exception exceptionValue = msg.getExceptionValue(); if(exceptionValue != null) { promise.setFailure(exceptionValue); } else { promise.setSuccess(returnValue); } } } } \"]},\"789\":{\"h\":\"Netty源码分析\"},\"790\":{\"h\":\"启动剖析\",\"t\":[\"我们就来看看 netty 中对下面的代码是怎样进行处理的\",\"//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector Selector selector = Selector.open(); //2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config NioServerSocketChannel attachment = new NioServerSocketChannel(); //3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); //4 启动 nio boss 线程执行接下来的操作 //5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件 SelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment); //6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor //7 绑定端口 serverSocketChannel.bind(new InetSocketAddress(8080)); //8 触发 channel active 事件，在 head 中关注 op_accept 事件 selectionKey.interestOps(SelectionKey.OP_ACCEPT); \",\"入口 io.netty.bootstrap.ServerBootstrap#bind\",\"关键代码 io.netty.bootstrap.AbstractBootstrap#doBind\",\"private ChannelFuture doBind(final SocketAddress localAddress) { // 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码 final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) { return regFuture; } // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分 // 2.1 如果已经完成 if (regFuture.isDone()) { ChannelPromise promise = channel.newPromise(); // 3.1 立刻调用 doBind0 doBind0(regFuture, channel, localAddress, promise); return promise; } // 2.2 还没有完成 else { final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel); // 3.2 回调 doBind0 regFuture.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { Throwable cause = future.cause(); if (cause != null) { // 处理异常... promise.setFailure(cause); } else { promise.registered(); // 3. 由注册线程去执行 doBind0 doBind0(regFuture, channel, localAddress, promise); } } }); return promise; } } \",\"关键代码 io.netty.bootstrap.AbstractBootstrap#initAndRegister\",\"final ChannelFuture initAndRegister() { Channel channel = null; try { channel = channelFactory.newChannel(); // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer init(channel); } catch (Throwable t) { // 处理异常... return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t); } // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上 ChannelFuture regFuture = config().group().register(channel); if (regFuture.cause() != null) { // 处理异常... } return regFuture; } \",\"关键代码 io.netty.bootstrap.ServerBootstrap#init\",\"// 这里 channel 实际上是 NioServerSocketChannel void init(Channel channel) throws Exception { final Map<ChannelOption<?>, Object> options = options0(); synchronized (options) { setChannelOptions(channel, options, logger); } final Map<AttributeKey<?>, Object> attrs = attrs0(); synchronized (attrs) { for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) { @SuppressWarnings(\\\"unchecked\\\") AttributeKey<Object> key = (AttributeKey<Object>) e.getKey(); channel.attr(key).set(e.getValue()); } } ChannelPipeline p = channel.pipeline(); final EventLoopGroup currentChildGroup = childGroup; final ChannelHandler currentChildHandler = childHandler; final Entry<ChannelOption<?>, Object>[] currentChildOptions; final Entry<AttributeKey<?>, Object>[] currentChildAttrs; synchronized (childOptions) { currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0)); } synchronized (childAttrs) { currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0)); } // 为 NioServerSocketChannel 添加初始化器 p.addLast(new ChannelInitializer<Channel>() { @Override public void initChannel(final Channel ch) throws Exception { final ChannelPipeline pipeline = ch.pipeline(); ChannelHandler handler = config.handler(); if (handler != null) { pipeline.addLast(handler); } // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel ch.eventLoop().execute(new Runnable() { @Override public void run() { pipeline.addLast(new ServerBootstrapAcceptor( ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)); } }); } }); } \",\"关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#register\",\"public final void register(EventLoop eventLoop, final ChannelPromise promise) { // 一些检查，略... AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) { register0(promise); } else { try { // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行 // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程 // 这行代码完成的事实是 main -> nio boss 线程的切换 eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { // 日志记录... closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } } \",\"io.netty.channel.AbstractChannel.AbstractUnsafe#register0\",\"private void register0(ChannelPromise promise) { try { if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } boolean firstRegistration = neverRegistered; // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel doRegister(); neverRegistered = false; registered = true; // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel pipeline.invokeHandlerAddedIfNeeded(); // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0 safeSetSuccess(promise); pipeline.fireChannelRegistered(); // 对应 server socket channel 还未绑定，isActive 为 false if (isActive()) { if (firstRegistration) { pipeline.fireChannelActive(); } else if (config().isAutoRead()) { beginRead(); } } } catch (Throwable t) { // Close the channel directly to avoid FD leak. closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } \",\"关键代码 io.netty.channel.ChannelInitializer#initChannel\",\"private boolean initChannel(ChannelHandlerContext ctx) throws Exception { if (initMap.add(ctx)) { // Guard against re-entrance. try { // 1.2.2.1 执行初始化 initChannel((C) ctx.channel()); } catch (Throwable cause) { exceptionCaught(ctx, cause); } finally { // 1.2.2.2 移除初始化器 ChannelPipeline pipeline = ctx.pipeline(); if (pipeline.context(this) != null) { pipeline.remove(this); } } return true; } return false; } \",\"关键代码 io.netty.bootstrap.AbstractBootstrap#doBind0\",\"// 3.1 或 3.2 执行 doBind0 private static void doBind0( final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) { channel.eventLoop().execute(new Runnable() { @Override public void run() { if (regFuture.isSuccess()) { channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE); } else { promise.setFailure(regFuture.cause()); } } }); } \",\"关键代码 io.netty.channel.AbstractChannel.AbstractUnsafe#bind\",\"public final void bind(final SocketAddress localAddress, final ChannelPromise promise) { assertEventLoop(); if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) && localAddress instanceof InetSocketAddress && !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() && !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) { // 记录日志... } boolean wasActive = isActive(); try { // 3.3 执行端口绑定 doBind(localAddress); } catch (Throwable t) { safeSetFailure(promise, t); closeIfClosed(); return; } if (!wasActive && isActive()) { invokeLater(new Runnable() { @Override public void run() { // 3.4 触发 active 事件 pipeline.fireChannelActive(); } }); } safeSetSuccess(promise); } \",\"3.3 关键代码 io.netty.channel.socket.nio.NioServerSocketChannel#doBind\",\"protected void doBind(SocketAddress localAddress) throws Exception { if (PlatformDependent.javaVersion() >= 7) { javaChannel().bind(localAddress, config.getBacklog()); } else { javaChannel().socket().bind(localAddress, config.getBacklog()); } } \",\"3.4 关键代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\",\"public void channelActive(ChannelHandlerContext ctx) { ctx.fireChannelActive(); // 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册) readIfIsAutoRead(); } \",\"关键代码 io.netty.channel.nio.AbstractNioChannel#doBeginRead\",\"protected void doBeginRead() throws Exception { // Channel.read() or ChannelHandlerContext.read() was called final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) { return; } readPending = true; final int interestOps = selectionKey.interestOps(); // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件 if ((interestOps & readInterestOp) == 0) { selectionKey.interestOps(interestOps | readInterestOp); } } \"]},\"791\":{\"h\":\"NioEventLoop 剖析\",\"t\":[\"NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\",\"提交任务代码 io.netty.util.concurrent.SingleThreadEventExecutor#execute\",\"public void execute(Runnable task) { if (task == null) { throw new NullPointerException(\\\"task\\\"); } boolean inEventLoop = inEventLoop(); // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列 addTask(task); if (!inEventLoop) { // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread startThread(); if (isShutdown()) { // 如果已经 shutdown，做拒绝逻辑，代码略... } } if (!addTaskWakesUp && wakesUpForTask(task)) { // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程 wakeup(inEventLoop); } } \",\"唤醒 select 阻塞线程io.netty.channel.nio.NioEventLoop#wakeup\",\"@Override protected void wakeup(boolean inEventLoop) { if (!inEventLoop && wakenUp.compareAndSet(false, true)) { selector.wakeup(); } } \",\"启动 EventLoop 主循环 io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread\",\"private void doStartThread() { assert thread == null; executor.execute(new Runnable() { @Override public void run() { // 将线程池的当前线程保存在成员变量中，以便后续使用 thread = Thread.currentThread(); if (interrupted) { thread.interrupt(); } boolean success = false; updateLastExecutionTime(); try { // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下 SingleThreadEventExecutor.this.run(); success = true; } catch (Throwable t) { logger.warn(\\\"Unexpected exception from an event executor: \\\", t); } finally { // 清理工作，代码略... } } }); } \",\"io.netty.channel.nio.NioEventLoop#run 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\",\"protected void run() { for (;;) { try { try { // calculateStrategy 的逻辑如下： // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞 switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) { case SelectStrategy.CONTINUE: continue; case SelectStrategy.BUSY_WAIT: case SelectStrategy.SELECT: // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒 // 进行 select 阻塞，并设置唤醒状态为 false boolean oldWakenUp = wakenUp.getAndSet(false); // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup // 下面的 select 方法不会阻塞 // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢? // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时 // 才能执行，让 select 方法无谓阻塞 select(oldWakenUp); if (wakenUp.get()) { selector.wakeup(); } default: } } catch (IOException e) { rebuildSelector0(); handleLoopException(e); continue; } cancelledKeys = 0; needsToSelectAgain = false; // ioRatio 默认是 50 final int ioRatio = this.ioRatio; if (ioRatio == 100) { try { processSelectedKeys(); } finally { // ioRatio 为 100 时，总是运行完所有非 IO 任务 runAllTasks(); } } else { final long ioStartTime = System.nanoTime(); try { processSelectedKeys(); } finally { // 记录 io 事件处理耗时 final long ioTime = System.nanoTime() - ioStartTime; // 运行非 IO 任务，一旦超时会退出 runAllTasks runAllTasks(ioTime * (100 - ioRatio) / ioRatio); } } } catch (Throwable t) { handleLoopException(t); } try { if (isShuttingDown()) { closeAll(); if (confirmShutdown()) { return; } } } catch (Throwable t) { handleLoopException(t); } } } \"]},\"792\":{\"h\":\"注意⚠️\",\"t\":[\"这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\",\"由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\",\"由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\",\"参考下图\",\"io.netty.channel.nio.NioEventLoop#select\",\"private void select(boolean oldWakenUp) throws IOException { Selector selector = this.selector; try { int selectCnt = 0; long currentTimeNanos = System.nanoTime(); // 计算等待时间 // * 没有 scheduledTask，超时时间为 1s // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间` long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); for (;;) { long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L; // 如果超时，退出循环 if (timeoutMillis <= 0) { if (selectCnt == 0) { selector.selectNow(); selectCnt = 1; } break; } // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行 // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup if (hasTasks() && wakenUp.compareAndSet(false, true)) { selector.selectNow(); selectCnt = 1; break; } // select 有限时阻塞 // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100% int selectedKeys = selector.select(timeoutMillis); // 计数加 1 selectCnt ++; // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环 if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) { break; } if (Thread.interrupted()) { // 线程被打断，退出循环 // 记录日志 selectCnt = 1; break; } long time = System.nanoTime(); if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) { // 如果超时，计数重置为 1，下次循环就会 break selectCnt = 1; } // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512 // 这是为了解决 nio 空轮询 bug else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 && selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) { // 重建 selector selector = selectRebuildSelector(selectCnt); selectCnt = 1; break; } currentTimeNanos = time; } if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) { // 记录日志 } } catch (CancelledKeyException e) { // 记录日志 } } \",\"处理 keys io.netty.channel.nio.NioEventLoop#processSelectedKeys\",\"private void processSelectedKeys() { if (selectedKeys != null) { // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet） processSelectedKeysOptimized(); } else { processSelectedKeysPlain(selector.selectedKeys()); } } \",\"io.netty.channel.nio.NioEventLoop#processSelectedKey\",\"private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) { final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); // 当 key 取消或关闭时会导致这个 key 无效 if (!k.isValid()) { // 无效时处理... return; } try { int readyOps = k.readyOps(); // 连接事件 if ((readyOps & SelectionKey.OP_CONNECT) != 0) { int ops = k.interestOps(); ops &= ~SelectionKey.OP_CONNECT; k.interestOps(ops); unsafe.finishConnect(); } // 可写事件 if ((readyOps & SelectionKey.OP_WRITE) != 0) { ch.unsafe().forceFlush(); } // 可读或可接入事件 if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read unsafe.read(); } } catch (CancelledKeyException ignored) { unsafe.close(unsafe.voidPromise()); } } \"]},\"793\":{\"h\":\"accept 剖析\",\"t\":[\"nio 中如下代码，在 netty 中的流程\",\"//1 阻塞直到事件发生 selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { //2 拿到一个事件 SelectionKey key = iter.next(); //3 如果是 accept 事件 if (key.isAcceptable()) { //4 执行 accept SocketChannel channel = serverSocketChannel.accept(); channel.configureBlocking(false); //5 关注 read 事件 channel.register(selector, SelectionKey.OP_READ); } // ... } \",\"先来看可接入事件处理（accept）\",\"io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\",\"public void read() { assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try { try { do { // doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf // readBuf 是一个 ArrayList 用来缓存消息 int localRead = doReadMessages(readBuf); if (localRead == 0) { break; } if (localRead < 0) { closed = true; break; } // localRead 为 1，就一条消息，即接收一个客户端连接 allocHandle.incMessagesRead(localRead); } while (allocHandle.continueReading()); } catch (Throwable t) { exception = t; } int size = readBuf.size(); for (int i = 0; i < size; i ++) { readPending = false; // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead pipeline.fireChannelRead(readBuf.get(i)); } readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception != null) { closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); } if (closed) { inputShutdown = true; if (isOpen()) { close(voidPromise()); } } } finally { if (!readPending && !config.isAutoRead()) { removeReadOp(); } } } \",\"关键代码 io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\",\"public void channelRead(ChannelHandlerContext ctx, Object msg) { // 这时的 msg 是 NioSocketChannel final Channel child = (Channel) msg; // NioSocketChannel 添加 childHandler 即初始化器 child.pipeline().addLast(childHandler); // 设置选项 setChannelOptions(child, childOptions, logger); for (Entry<AttributeKey<?>, Object> e: childAttrs) { child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue()); } try { // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程 childGroup.register(child).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { forceClose(child, future.cause()); } } }); } catch (Throwable t) { forceClose(child, t); } } \",\"又回到了熟悉的 io.netty.channel.AbstractChannel.AbstractUnsafe#register 方法\",\"public final void register(EventLoop eventLoop, final ChannelPromise promise) { // 一些检查，略... AbstractChannel.this.eventLoop = eventLoop; if (eventLoop.inEventLoop()) { register0(promise); } else { try { // 这行代码完成的事实是 nio boss -> nio worker 线程的切换 eventLoop.execute(new Runnable() { @Override public void run() { register0(promise); } }); } catch (Throwable t) { // 日志记录... closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } } \",\"io.netty.channel.AbstractChannel.AbstractUnsafe#register0\",\"private void register0(ChannelPromise promise) { try { if (!promise.setUncancellable() || !ensureOpen(promise)) { return; } boolean firstRegistration = neverRegistered; doRegister(); neverRegistered = false; registered = true; // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail pipeline.invokeHandlerAddedIfNeeded(); // 执行后就是 head -> logging handler -> my handler -> tail safeSetSuccess(promise); pipeline.fireChannelRegistered(); if (isActive()) { if (firstRegistration) { // 触发 pipeline 上 active 事件 pipeline.fireChannelActive(); } else if (config().isAutoRead()) { beginRead(); } } } catch (Throwable t) { closeForcibly(); closeFuture.setClosed(); safeSetFailure(promise, t); } } \",\"回到了熟悉的代码 io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive\",\"public void channelActive(ChannelHandlerContext ctx) { ctx.fireChannelActive(); // 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取) readIfIsAutoRead(); } \",\"io.netty.channel.nio.AbstractNioChannel#doBeginRead\",\"protected void doBeginRead() throws Exception { // Channel.read() or ChannelHandlerContext.read() was called final SelectionKey selectionKey = this.selectionKey; if (!selectionKey.isValid()) { return; } readPending = true; // 这时候 interestOps 是 0 final int interestOps = selectionKey.interestOps(); if ((interestOps & readInterestOp) == 0) { // 关注 read 事件 selectionKey.interestOps(interestOps | readInterestOp); } } \"]},\"794\":{\"h\":\"read 剖析\",\"t\":[\"再来看可读事件 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\",\"public final void read() { final ChannelConfig config = config(); if (shouldBreakReadReady(config)) { clearReadPending(); return; } final ChannelPipeline pipeline = pipeline(); // io.netty.allocator.type 决定 allocator 的实现 final ByteBufAllocator allocator = config.getAllocator(); // 用来分配 byteBuf，确定单次读取大小 final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle(); allocHandle.reset(config); ByteBuf byteBuf = null; boolean close = false; try { do { byteBuf = allocHandle.allocate(allocator); // 读取 allocHandle.lastBytesRead(doReadBytes(byteBuf)); if (allocHandle.lastBytesRead() <= 0) { byteBuf.release(); byteBuf = null; close = allocHandle.lastBytesRead() < 0; if (close) { readPending = false; } break; } allocHandle.incMessagesRead(1); readPending = false; // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler pipeline.fireChannelRead(byteBuf); byteBuf = null; } // 是否要继续循环 while (allocHandle.continueReading()); allocHandle.readComplete(); // 触发 read complete 事件 pipeline.fireChannelReadComplete(); if (close) { closeOnRead(pipeline); } } catch (Throwable t) { handleReadException(pipeline, byteBuf, t, close, allocHandle); } finally { if (!readPending && !config.isAutoRead()) { removeReadOp(); } } } \",\"io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)\",\"public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) { return // 一般为 true config.isAutoRead() && // respectMaybeMoreData 默认为 true // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true (!respectMaybeMoreData || maybeMoreDataSupplier.get()) && // 小于最大次数，maxMessagePerRead 默认 16 totalMessages < maxMessagePerRead && // 实际读到了数据 totalBytesRead > 0; } \"]},\"795\":{\"h\":\"组件\"},\"796\":{\"h\":\"EventLoop\",\"t\":[\"事件循环对象\",\"EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\",\"它的继承关系比较复杂\",\"一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\",\"另一条线是继承自 netty 自己的 OrderedEventExecutor， \",\"提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\",\"提供了 parent 方法来看看自己属于哪个 EventLoopGroup\",\"事件循环组\",\"EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\",\"继承自 netty 自己的 EventExecutorGroup \",\"实现了 Iterable 接口提供遍历 EventLoop 的能力\",\"另有 next 方法获取集合中下一个 EventLoop\",\"以一个简单的实现为例：\",\"// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程 DefaultEventLoopGroup group = new DefaultEventLoopGroup(2); System.out.println(group.next()); System.out.println(group.next()); System.out.println(group.next()); \",\"输出\",\"io.netty.channel.DefaultEventLoop@60f82f98 io.netty.channel.DefaultEventLoop@35f983a6 io.netty.channel.DefaultEventLoop@60f82f98 \",\"也可以使用 for 循环\",\"DefaultEventLoopGroup group = new DefaultEventLoopGroup(2); for (EventExecutor eventLoop : group) { System.out.println(eventLoop); } \",\"输出\",\"io.netty.channel.DefaultEventLoop@60f82f98 io.netty.channel.DefaultEventLoop@35f983a6 \"]},\"797\":{\"h\":\"优雅关闭💡\",\"t\":[\"优雅关闭 shutdownGracefully 方法。该方法会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\"]},\"798\":{\"h\":\"演示 NioEventLoop 处理 io 事件\",\"t\":[\"服务器端两个 nio worker 工人\",\"new ServerBootstrap() // boss 和 worker // 细分1：boss 只负责 ServerSocketChannel 上 accept 事件 // worker 只负责 socketChannel 上的读写 .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2)) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null; if (byteBuf != null) { byte[] buf = new byte[16]; ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes()); log.debug(new String(buf)); } } }); } }).bind(8080).sync(); \",\"客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\",\"public static void main(String[] args) throws InterruptedException { Channel channel = new Bootstrap() .group(new NioEventLoopGroup(1)) .handler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { System.out.println(\\\"init...\\\"); ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); } }) .channel(NioSocketChannel.class).connect(\\\"localhost\\\", 8080) .sync() .channel(); channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\\\"wangwu\\\".getBytes())); Thread.sleep(2000); channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\\\"wangwu\\\".getBytes())); \",\"最后输出\",\"22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan 22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan 22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi 22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi 22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu 22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu \",\"可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定\",\"再增加两个非 nio 工人\",\"// 细分2：创建一个独立的 EventLoopGroup EventLoopGroup group = new DefaultEventLoopGroup(2); new ServerBootstrap() // boss 和 worker // 细分1：boss 只负责 ServerSocketChannel 上 accept 事件 worker 只负责 socketChannel 上的读写 .group(new NioEventLoopGroup(), new NioEventLoopGroup(2)) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(\\\"handler1\\\", new ChannelInboundHandlerAdapter() { @Override // ByteBuf public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; log.debug(buf.toString(Charset.defaultCharset())); ctx.fireChannelRead(msg); // 让消息传递给下一个handler } }).addLast(group, \\\"handler2\\\", new ChannelInboundHandlerAdapter() { @Override // ByteBuf public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; log.debug(buf.toString(Charset.defaultCharset())); } }); } }) .bind(8080); \",\"客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\",\"输出\",\"22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 7a 68 61 6e 67 73 61 6e |zhangsan | +--------+-------------------------------------------------+----------------+ 22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE 22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan 22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 7a 68 61 6e 67 73 61 6e |zhangsan | +--------+-------------------------------------------------+----------------+ 22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE 22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan 22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED 22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE 22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6c 69 73 69 |lisi | +--------+-------------------------------------------------+----------------+ 22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE 22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi 22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6c 69 73 69 |lisi | +--------+-------------------------------------------------+----------------+ 22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE 22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 61 6e 67 77 75 |wangwu | +--------+-------------------------------------------------+----------------+ 22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE 22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu 22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 61 6e 67 77 75 |wangwu | +--------+-------------------------------------------------+----------------+ 22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE 22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu \",\"可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\"]},\"799\":{\"h\":\"handler 执行中如何换人？💡\",\"t\":[\"关键代码 io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()\",\"static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \\\"msg\\\"), next); // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程 EventExecutor executor = next.executor(); // 是，直接调用 if (executor.inEventLoop()) { next.invokeChannelRead(m); } // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人） else { executor.execute(new Runnable() { @Override public void run() { next.invokeChannelRead(m); } }); } } \",\"如果两个 handler 绑定的是同一个线程，那么就直接调用\",\"否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\"]},\"800\":{\"h\":\"演示 NioEventLoop 处理普通任务\",\"t\":[\"NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\",\"NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2); log.debug(\\\"server start...\\\"); Thread.sleep(2000); nioWorkers.execute(()->{ log.debug(\\\"normal task...\\\"); }); \",\"输出\",\"22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start... 22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task... \",\"可以用来执行耗时较长的任务\"]},\"801\":{\"h\":\"演示 NioEventLoop 处理定时任务\",\"t\":[\"NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2); log.debug(\\\"server start...\\\"); Thread.sleep(2000); nioWorkers.scheduleAtFixedRate(() -> { log.debug(\\\"running...\\\"); }, 0, 1, TimeUnit.SECONDS); \",\"输出\",\"22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start... 22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... 22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running... ... \",\"可以用来执行定时任务\"]},\"802\":{\"h\":\"Channel\",\"t\":[\"channel 的主要作用\",\"close() 可以用来关闭 channel\",\"closeFuture() 用来处理 channel 的关闭 \",\"sync 方法作用是同步等待 channel 关闭\",\"而 addListener 方法是异步等待 channel 关闭\",\"pipeline() 方法添加处理器\",\"write() 方法将数据写入\",\"writeAndFlush() 方法将数据写入并刷出\"]},\"803\":{\"h\":\"ChannelFuture\",\"t\":[\"这时刚才的客户端代码\",\"new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080) .sync() .channel() .writeAndFlush(new Date() + \\\": hello world!\\\"); \",\"现在把它拆开来看\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) // 异步非阻塞, main 发起了调用，真正执行connect是NioEventLoopGroup中的线程 .connect(\\\"127.0.0.1\\\", 8080); // 1 channelFuture.sync().channel().writeAndFlush(new Date() + \\\": hello world!\\\"); \",\"1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\",\"注意 connect 方法是异步非阻塞的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象 （虽然有channel对象，但是channel对象并没有正确连接）\",\"实验如下：\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080); log.debug(\\\"{}\\\", channelFuture.channel()); // 1 channelFuture.sync(); // 2 log.debug(\\\"{}\\\", channelFuture.channel()); // 3 \",\"执行到 1 时，连接未建立，打印 [id: 0x2e1884dd]\",\"执行到 2 时，sync 方法是同步等待连接建立完成\",\"执行到 3 时，连接肯定建立了，打印 [id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]\",\"除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\",\"ChannelFuture channelFuture = new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080); log.debug(\\\"{}\\\", channelFuture.channel()); // 1 // 2.2 使用 addListener(回调对象) 方法异步处理结果 channelFuture.addListener(new ChannelFutureListener() { @Override // 在 nio 线程连接建立好之后，会回调 operationComplete，该方法的执行还是nio线程 public void operationComplete(ChannelFuture future) throws Exception { Channel channel = future.channel(); log.debug(\\\"{}\\\", channel); // 2 channel.writeAndFlush(\\\"hello, world\\\"); } }); \",\"执行到 1 时，连接未建立，打印 [id: 0x749124ba]\",\"ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 [id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]\"]},\"804\":{\"h\":\"CloseFuture\",\"t\":[\"@Slf4j public class CloseFutureClient { public static void main(String[] args) throws InterruptedException { NioEventLoopGroup group new NioEventLoopGroup(); ChannelFuture channelFuture = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<NioSocketChannel>() { @Override // 在连接建立后被调用 protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG)); ch.pipeline().addLast(new StringEncoder()); } }) .connect(new InetSocketAddress(\\\"localhost\\\", 8080)); Channel channel = channelFuture.sync().channel(); log.debug(\\\"{}\\\", channel); new Thread(()->{ Scanner scanner = new Scanner(System.in); while (true) { String line = scanner.nextLine(); if (\\\"q\\\".equals(line)) { channel.close(); // 该步是异步操作，所以不能在这里善后 // log.debug(\\\"处理关闭之后的操作\\\"); // 不能在这里善后 break; } channel.writeAndFlush(line); } }, \\\"input\\\").start(); // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭 ChannelFuture closeFuture = channel.closeFuture(); // 同步方式处理关闭 /*log.debug(\\\"waiting close...\\\"); closeFuture.sync(); log.debug(\\\"处理关闭之后的操作\\\");*/ // 异步方式处理关闭 closeFuture.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { log.debug(\\\"处理关闭之后的操作\\\"); group.shutdownGracefully(); } }); } } \"]},\"805\":{\"h\":\"异步提升的是什么💡\",\"t\":[\"有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\",\"还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\",\"思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：4 * 8 * 3 = 96\",\"经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\",\"因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 4 * 8 * 12 效率几乎是原来的四倍\",\"要点\",\"单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\",\"异步并没有缩短响应时间，反而有所增加，提高的是吞吐量（单位时间内能够处理请求的数量）\",\"合理进行任务拆分，也是利用异步的关键\"]},\"806\":{\"h\":\"Future & Promise\",\"t\":[\"在异步处理时，经常用到这两个接口\",\"首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 juc 的 Future，而 Promise 又对 netty Future 进行了扩展\",\"public interface Future<V> extends java.util.concurrent.Future<V> public interface Promise<V> extends Future<V> \",\"jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\",\"netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\",\"netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\",\"功能/名称\",\"jdk Future\",\"netty Future\",\"Promise\",\"cancel\",\"取消任务\",\"-\",\"-\",\"isCanceled\",\"任务是否取消\",\"-\",\"-\",\"isDone\",\"任务是否完成，不能区分成功失败\",\"-\",\"-\",\"get\",\"获取任务结果，阻塞等待\",\"-\",\"-\",\"getNow\",\"-\",\"获取任务结果，非阻塞，还未产生结果时返回 null\",\"-\",\"await\",\"-\",\"等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断\",\"-\",\"sync\",\"-\",\"等待任务结束，如果任务失败，抛出异常\",\"-\",\"isSuccess\",\"-\",\"判断任务是否成功\",\"-\",\"cause\",\"-\",\"获取失败信息，非阻塞，如果没有失败，返回null\",\"-\",\"addLinstener\",\"-\",\"添加回调，异步接收结果\",\"-\",\"setSuccess\",\"-\",\"-\",\"设置成功结果\",\"setFailure\",\"-\",\"-\",\"设置失败结果\"]},\"807\":{\"h\":\"JDK Future\",\"t\":[\"// 1. 线程池 ExecutorService service = Executors.newFixedThreadPool(2); // 2. 提交任务 Future<Integer> future = service.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { log.debug(\\\"执行计算\\\"); Thread.sleep(1000); return 50; } }); // 3. 主线程通过 future 来获取结果 log.debug(\\\"等待结果\\\"); log.debug(\\\"结果是 {}\\\", future.get()); \"]},\"808\":{\"h\":\"Netty Future\",\"t\":[\"NioEventLoopGroup group = new NioEventLoopGroup(); EventLoop eventLoop = group.next(); Future<Integer> future = eventLoop.submit(new Callable<Integer>() { @Override public Integer call() throws Exception { log.debug(\\\"执行计算\\\"); Thread.sleep(1000); return 70; } }); // log.debug(\\\"等待结果\\\"); // log.debug(\\\"结果是 {}\\\", future.get()); future.addListener(new GenericFutureListener<Future<? super Integer>>(){ @Override public void operationComplete(Future<? super Integer> future) throws Exception { log.debug(\\\"接收结果:{}\\\", future.getNow()); } }); \"]},\"809\":{\"h\":\"Promise\",\"t\":[\"// 1. 准备 EventLoop 对象 EventLoop eventLoop = new NioEventLoopGroup().next(); // 2. 可以主动创建 promise, 结果容器 DefaultPromise<Integer> promise = new DefaultPromise<>(eventLoop); new Thread(() -> { // 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果 log.debug(\\\"开始计算...\\\"); try { int i = 1 / 0; Thread.sleep(1000); promise.setSuccess(80); } catch (Exception e) { // e.printStackTrace(); promise.setFailure(e); } }).start(); // 4. 接收结果的线程 log.debug(\\\"等待结果...\\\"); log.debug(\\\"结果是: {}\\\", promise.get()); \"]},\"810\":{\"h\":\"例1\",\"t\":[\"同步处理任务成功\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(()->{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\\\"set success, {}\\\",10); promise.setSuccess(10); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\",promise.getNow()); // 还没有结果 log.debug(\\\"{}\\\",promise.get()); \",\"输出\",\"11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10 11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10 \"]},\"811\":{\"h\":\"例2\",\"t\":[\"异步处理任务成功\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); // 设置回调，异步接收结果 promise.addListener(future -> { // 这里的 future 就是上面的 promise log.debug(\\\"{}\\\",future.getNow()); }); // 等待 1000 后设置成功结果 eventExecutors.execute(()->{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.debug(\\\"set success, {}\\\",10); promise.setSuccess(10); }); log.debug(\\\"start...\\\"); \",\"输出\",\"11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10 11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10 \"]},\"812\":{\"h\":\"例3\",\"t\":[\"同步处理任务失败 - sync & get\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\", promise.getNow()); promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常 \",\"输出\",\"12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... Exception in thread \\\"main\\\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error... at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41) at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34) Caused by: java.lang.RuntimeException: error... at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) \"]},\"813\":{\"h\":\"例4\",\"t\":[\"同步处理任务失败 - await\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); log.debug(\\\"{}\\\", promise.getNow()); promise.await(); // 与 sync 和 get 区别在于，不会抛异常 log.debug(\\\"result {}\\\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString()); \",\"输出\",\"12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null 12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... 12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error... \"]},\"814\":{\"h\":\"例5\",\"t\":[\"异步处理任务失败\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); promise.addListener(future -> { log.debug(\\\"result {}\\\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString()); }); eventExecutors.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } RuntimeException e = new RuntimeException(\\\"error...\\\"); log.debug(\\\"set failure, {}\\\", e.toString()); promise.setFailure(e); }); log.debug(\\\"start...\\\"); \",\"输出\",\"12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start... 12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error... 12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error... \"]},\"815\":{\"h\":\"例6\",\"t\":[\"await 死锁检查\",\"DefaultEventLoop eventExecutors = new DefaultEventLoop(); DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors); eventExecutors.submit(()->{ System.out.println(\\\"1\\\"); try { promise.await(); // 注意不能仅捕获 InterruptedException 异常 // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播 // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出 } catch (Exception e) { e.printStackTrace(); } System.out.println(\\\"2\\\"); }); eventExecutors.submit(()->{ System.out.println(\\\"3\\\"); try { promise.await(); } catch (Exception e) { e.printStackTrace(); } System.out.println(\\\"4\\\"); }); \",\"输出\",\"1 2 3 4 io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete) at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384) at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212) at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27) at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete) at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384) at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212) at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36) at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38) at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73) at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) at java.lang.Thread.run(Thread.java:745) \"]},\"816\":{\"h\":\"Handler & Pipeline\",\"t\":[\"ChannelHandler 用来处理 Channel 上的各种事件，分为入站（数据读取）、出站（数据写出）两种。所有 ChannelHandler 被连成一串，就是 Pipeline\",\"入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\",\"出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\",\"打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\",\"先搞清楚顺序，服务端\",\"@Slf4j public class TestPipeline { public static void main(String[] args) { new ServerBootstrap() .group(new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { // 1. 通过 channel 拿到 pipeline ChannelPipeline pipeline = ch.pipeline(); // 2. 添加处理器 head -> h1 -> h2 -> h4 -> h3 -> h5 -> h6 -> tail pipeline.addLast(\\\"h1\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { log.debug(\\\"1\\\"); ByteBuf buf = (ByteBuf) msg; String name = buf.toString(Charset.defaultCharset()); super.channelRead(ctx, name); // name就是在handler处理链中传递的数据 } }); pipeline.addLast(\\\"h2\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object name) throws Exception { log.debug(\\\"2\\\"); Student student = new Student(name.toString()); super.channelRead(ctx, student); // 将数据传递给下个 handler，如果不调用，调用链会断开 或者调用 ctx.fireChannelRead(student); } }); pipeline.addLast(\\\"h3\\\", new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object student) throws Exception { log.debug(\\\"3, 结果是：{}\\\", student.toString()); // super.channelRead(ctx, student); // 从当前位置向上找出站处理器 // ctx.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes())); // 从tail向上找出站处理器 ch.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes())); } }); pipeline.addLast(\\\"h4\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { Student student = new Student(msg.toString()); log.debug(\\\"4\\\"); super.write(ctx, student, promise); } }); pipeline.addLast(\\\"h5\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object student, ChannelPromise promise) throws Exception { log.debug(\\\"5，结果是：{}\\\", student); super.write(ctx, student, promise); } }); pipeline.addLast(\\\"h6\\\", new ChannelOutboundHandlerAdapter(){ @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception { log.debug(\\\"6\\\"); super.write(ctx, msg, promise); } }); } }) .bind(8080); } @Data @AllArgsConstructor static class Student { private String name; @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + '}'; } } } \",\"客户端\",\"new Bootstrap() .group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<Channel>() { @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); } }) .connect(\\\"127.0.0.1\\\", 8080) .addListener((ChannelFutureListener) future -> { future.channel().writeAndFlush(\\\"hello,world\\\"); }); \",\"服务器端打印：\",\"1 2 3 6 5 4 \",\"可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\",\"入站处理器中，super.channelRead(ctx, name)是 调用下一个入站处理器\",\"如果注释掉 h1 处代码，则仅会打印 1\",\"如果注释掉 h2 处代码，则仅会打印 1 2\",\"h3 处的 ch.writeAndFlush(ctx.alloc().buffer().writeBytes(\\\"server...\\\".getBytes()))会 从尾部开始触发 后续出站处理器的执行 \",\"如果注释掉 3 处代码，则仅会打印 1 2 3\",\"类似的，出站处理器中，super.write(ctx, msg, promise); 的调用也会 触发上一个出站处理器\",\"如果注释掉 h6 处代码，则仅会打印 1 2 3 6\",\"ctx.channel().write(msg) vs ctx.write(msg) \",\"都是触发出站处理器的执行\",\"ctx.channel().write(msg) 从尾部开始查找出站处理器\",\"ctx.write(msg) 是从当前节点找上一个出站处理器\",\"3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\",\"6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\",\"图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\"]},\"817\":{\"h\":\"ByteBuf\",\"t\":[\"是对字节数据的封装\"]},\"818\":{\"h\":\"1）创建\",\"t\":[\"ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10); log(buffer); \",\"上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\",\"输出\",\"read index:0 write index:0 capacity:10 \",\"其中 log 方法参考如下\",\"private static void log(ByteBuf buffer) { int length = buffer.readableBytes(); int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4; StringBuilder buf = new StringBuilder(rows * 80 * 2) .append(\\\"read index:\\\").append(buffer.readerIndex()) .append(\\\" write index:\\\").append(buffer.writerIndex()) .append(\\\" capacity:\\\").append(buffer.capacity()) .append(NEWLINE); appendPrettyHexDump(buf, buffer); System.out.println(buf.toString()); } \"]},\"819\":{\"h\":\"2）直接内存 vs 堆内存\",\"t\":[\"可以使用下面的代码来创建池化基于堆的 ByteBuf\",\"ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10); \",\"也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\",\"ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10); \",\"直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\",\"直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\"]},\"820\":{\"h\":\"3）池化 vs 非池化\",\"t\":[\"池化的最大意义在于可以重用 ByteBuf，优点有\",\"没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\",\"有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\",\"高并发时，池化功能更节约内存，减少内存溢出的可能\",\"池化功能是否开启，可以通过下面的系统环境变量来设置\",\"-Dio.netty.allocator.type={unpooled|pooled} \",\"4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\",\"4.1 之前，池化功能还不成熟，默认是非池化实现\"]},\"821\":{\"h\":\"4）组成\",\"t\":[\"ByteBuf 由四部分组成\",\"废弃字节：已经读取过的部分\",\"最开始读写指针都在 0 位置\"]},\"822\":{\"h\":\"5）写入\",\"t\":[\"方法列表，省略一些不重要的方法\",\"方法签名\",\"含义\",\"备注\",\"writeBoolean(boolean value)\",\"写入 boolean 值\",\"用一字节 01 | 00代表true | false\",\"writeByte(int value)\",\"写入 byte 值\",\"writeShort(int value)\",\"写入 short 值\",\"writeInt(int value)\",\"写入 int 值\",\"Big Endian（大端写入），即 0x250，写入后 00 00 02 50\",\"writeIntLE(int value)\",\"写入 int 值\",\"Little Endian（小端写入），即 0x250，写入后 50 02 00 00\",\"writeLong(long value)\",\"写入 long 值\",\"writeChar(int value)\",\"写入 char 值\",\"writeFloat(float value)\",\"写入 float 值\",\"writeDouble(double value)\",\"写入 double 值\",\"writeBytes(ByteBuf src)\",\"写入 netty 的 ByteBuf\",\"writeBytes(byte[] src)\",\"写入 byte[]\",\"writeBytes(ByteBuffer src)\",\"写入 nio 的 ByteBuffer\",\"int writeCharSequence(CharSequence sequence, Charset charset)\",\"写入字符串\",\"注意\",\"这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\",\"网络传输，默认习惯是 Big Endian\",\"先写入 4 个字节\",\"buffer.writeBytes(new byte[]{1, 2, 3, 4}); log(buffer); \",\"结果是\",\"read index:0 write index:4 capacity:10 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 |.... | +--------+-------------------------------------------------+----------------+ \",\"再写入一个 int 整数，也是 4 个字节\",\"buffer.writeInt(5); log(buffer); \",\"结果是\",\"read index:0 write index:8 capacity:10 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 00 00 00 05 |........ | +--------+-------------------------------------------------+----------------+ \",\"还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\"]},\"823\":{\"h\":\"6）扩容\",\"t\":[\"再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\",\"buffer.writeInt(6); log(buffer); \",\"扩容规则是\",\"如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\",\"如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 210=1024（29=512 已经不够了）\",\"扩容超过 max capacity（Integer.MAX_VALUE）会报错\",\"结果是\",\"read index:0 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 00 00 00 05 00 00 00 06 |............ | +--------+-------------------------------------------------+----------------+ \"]},\"824\":{\"h\":\"7）读取\",\"t\":[\"例如读了 4 次，每次一个字节\",\"System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); System.out.println(buffer.readByte()); log(buffer); \",\"读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\",\"1 2 3 4 read index:4 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 05 00 00 00 06 |........ | +--------+-------------------------------------------------+----------------+ \",\"如果需要重复读取 int 整数 5，怎么办？\",\"可以在 read 前先做个标记 mark\",\"buffer.markReaderIndex(); System.out.println(buffer.readInt()); log(buffer); \",\"结果\",\"5 read index:8 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 06 |.... | +--------+-------------------------------------------------+----------------+ \",\"这时要重复读取的话，重置到标记位置 reset\",\"buffer.resetReaderIndex(); log(buffer); \",\"这时\",\"read index:4 write index:12 capacity:16 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 00 00 00 05 00 00 00 06 |........ | +--------+-------------------------------------------------+----------------+ \",\"还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\"]},\"825\":{\"h\":\"8）retain & release\",\"t\":[\"由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\",\"UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\",\"UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\",\"PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\",\"回收内存的源码实现，请关注下面方法的不同实现\",\"protected abstract void deallocate()\",\"Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\",\"每个 ByteBuf 对象的初始计数为 1\",\"调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\",\"调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\",\"当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\",\"谁来负责 release 呢？\",\"不是我们想象的（一般情况下）\",\"ByteBuf buf = ... try { ... } finally { buf.release(); } \",\"请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\",\"基本规则是，谁是最后使用者，谁负责 release，详细分析如下\",\"起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\",\"入站 ByteBuf 处理原则 \",\"对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\",\"将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\",\"如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\",\"注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\",\"假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\",\"出站 ByteBuf 处理原则 \",\"出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\",\"异常处理原则 \",\"有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\",\"TailContext 释放未处理消息逻辑\",\"// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object) protected void onUnhandledInboundMessage(Object msg) { try { logger.debug( \\\"Discarded inbound message {} that reached at the tail of the pipeline. \\\" + \\\"Please check your pipeline configuration.\\\", msg); } finally { ReferenceCountUtil.release(msg); } } \",\"具体代码\",\"// io.netty.util.ReferenceCountUtil#release(java.lang.Object) public static boolean release(Object msg) { if (msg instanceof ReferenceCounted) { return ((ReferenceCounted) msg).release(); } return false; } \"]},\"826\":{\"h\":\"9）slice\",\"t\":[\"【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\",\"public class TestSlice { public static void main(String[] args) { ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(10); buf.writeBytes(new byte[]{'a','b','c','d','e','f','g','h','i','j'}); log(buf); // 在切片过程中，没有发生数据复制 ByteBuf f1 = buf.slice(0, 5); f1.retain(); // 引用计数加一 // 'a','b','c','d','e', 'x' ByteBuf f2 = buf.slice(5, 5); f2.retain(); log(f1); log(f2); System.out.println(\\\"释放原有 byteBuf 内存\\\"); buf.release(); log(buf); // 此时buf没有被释放 log(f1); f1.release(); f2.release(); /*System.out.println(\\\"========================\\\"); f1.setByte(0, 'b'); log(f1); log(buf);*/ } } \",\"例，原始 ByteBuf 进行一些初始操作\",\"ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10); origin.writeBytes(new byte[]{1, 2, 3, 4}); origin.readByte(); System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write\",\"ByteBuf slice = origin.slice(); System.out.println(ByteBufUtil.prettyHexDump(slice)); // slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常 \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"如果原始 ByteBuf 再次读操作（又读了一个字节）\",\"origin.readByte(); System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 03 04 |.. | +--------+-------------------------------------------------+----------------+ \",\"这时的 slice 不受影响，因为它有独立的读写指针\",\"System.out.println(ByteBufUtil.prettyHexDump(slice)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 04 |... | +--------+-------------------------------------------------+----------------+ \",\"如果 slice 的内容发生了更改\",\"slice.setByte(2, 5); System.out.println(ByteBufUtil.prettyHexDump(slice)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 02 03 05 |... | +--------+-------------------------------------------------+----------------+ \",\"这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\",\"System.out.println(ByteBufUtil.prettyHexDump(origin)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 03 05 |.. | +--------+-------------------------------------------------+----------------+ \"]},\"827\":{\"h\":\"10）duplicate\",\"t\":[\"【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\"]},\"828\":{\"h\":\"11）copy\",\"t\":[\"会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\"]},\"829\":{\"h\":\"12）CompositeByteBuf\",\"t\":[\"【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\",\"有两个 ByteBuf 如下\",\"ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5); buf1.writeBytes(new byte[]{1, 2, 3, 4, 5}); ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5); buf2.writeBytes(new byte[]{6, 7, 8, 9, 10}); System.out.println(ByteBufUtil.prettyHexDump(buf1)); System.out.println(ByteBufUtil.prettyHexDump(buf2)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 |..... | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 06 07 08 09 0a |..... | +--------+-------------------------------------------------+----------------+ \",\"现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\",\"方法1：\",\"ByteBuf buf3 = ByteBufAllocator.DEFAULT .buffer(buf1.readableBytes()+buf2.readableBytes()); buf3.writeBytes(buf1); buf3.writeBytes(buf2); System.out.println(ByteBufUtil.prettyHexDump(buf3)); \",\"结果\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\",\"方法2：\",\"CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer(); // true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0 buf3.addComponents(true, buf1, buf2); \",\"结果是一样的\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\",\"优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\",\"缺点，复杂了很多，多次操作会带来性能的损耗\"]},\"830\":{\"h\":\"13）Unpooled\",\"t\":[\"Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\",\"这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\",\"ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5); buf1.writeBytes(new byte[]{1, 2, 3, 4, 5}); ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5); buf2.writeBytes(new byte[]{6, 7, 8, 9, 10}); // 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2); System.out.println(ByteBufUtil.prettyHexDump(buf3)); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 07 08 09 0a |.......... | +--------+-------------------------------------------------+----------------+ \",\"也可以用来包装普通字节数组，底层也不会有拷贝操作\",\"ByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6}); System.out.println(buf4.getClass()); System.out.println(ByteBufUtil.prettyHexDump(buf4)); \",\"输出\",\"class io.netty.buffer.CompositeByteBuf +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 01 02 03 04 05 06 |...... | +--------+-------------------------------------------------+----------------+ \"]},\"831\":{\"h\":\"ByteBuf 优势💡\",\"t\":[\"池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\",\"读写指针分离，不需要像 ByteBuffer 一样切换读写模式\",\"可以自动扩容\",\"支持链式调用，使用更流畅\",\"很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\"]},\"832\":{\"h\":\"Hello World\"},\"833\":{\"h\":\"目标\",\"t\":[\"开发一个简单的服务器端和客户端\",\"客户端向服务器端发送 hello, world\",\"服务器仅接收，不返回\",\"加入依赖\",\"<dependency> <groupId>io.netty</groupId> <artifactId>netty-all</artifactId> <version>4.1.39.Final</version> </dependency> \"]},\"834\":{\"h\":\"服务器端\",\"t\":[\"new ServerBootstrap() .group(new NioEventLoopGroup()) // 1 .channel(NioServerSocketChannel.class) // 2 .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3 protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new StringDecoder()); // 5 ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6 @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) { System.out.println(msg); } }); } }) .bind(8080); // 4 \",\"代码解读\",\"1 处，创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector 后面会详细展开\",\"2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\",\"3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\",\"4 处，ServerSocketChannel 绑定的监听端口\",\"5 处，SocketChannel 的处理器，解码 ByteBuf => String\",\"6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\"]},\"835\":{\"h\":\"客户端\",\"t\":[\"new Bootstrap() .group(new NioEventLoopGroup()) // 1 .channel(NioSocketChannel.class) // 2 .handler(new ChannelInitializer<Channel>() { // 3 @Override protected void initChannel(Channel ch) { ch.pipeline().addLast(new StringEncoder()); // 8 } }) .connect(\\\"127.0.0.1\\\", 8080) // 4 .sync() // 5 .channel() // 6 .writeAndFlush(new Date() + \\\": hello world!\\\"); // 7 \",\"代码解读\",\"1 处，创建 NioEventLoopGroup，同 Server\",\"2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\",\"3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\",\"4 处，指定要连接的服务器和端口\",\"5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\",\"6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\",\"7 处，写入消息并清空缓冲区\",\"8 处，消息会经过通道 handler 处理，这里是将 String => ByteBuf 发出\",\"数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\"]},\"836\":{\"h\":\"流程梳理\"},\"837\":{\"h\":\"提示💡\",\"t\":[\"一开始需要树立正确的观念\",\"把 channel 理解为数据的通道\",\"把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\",\"把 handler 理解为数据的处理工序 \",\"工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\",\"handler 分 Inbound 和 Outbound 两类\",\"把 eventLoop 理解为处理数据的工人 \",\"工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\",\"工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\",\"工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\"]},\"838\":{\"h\":\"Netty概述\"},\"839\":{\"h\":\"Netty 是什么？\",\"t\":[\"Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. \",\"Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\"]},\"840\":{\"h\":\"Netty 的作者\",\"t\":[\"他还是另一个著名网络应用框架 Mina 的重要贡献者\"]},\"841\":{\"h\":\"Netty 的地位\",\"t\":[\"Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\",\"以下的框架都使用了 Netty，因为它们有网络通信需求！\",\"Cassandra - nosql 数据库\",\"Spark - 大数据分布式计算框架\",\"Hadoop - 大数据分布式存储框架\",\"RocketMQ - ali 开源的消息队列\",\"ElasticSearch - 搜索引擎\",\"gRPC - rpc 框架\",\"Dubbo - rpc 框架\",\"Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\",\"Zookeeper - 分布式协调框架\"]},\"842\":{\"h\":\"Netty 的优势\",\"t\":[\"Netty vs NIO，工作量大，bug 多 \",\"需要自己构建协议\",\"解决 TCP 传输问题，如粘包、半包\",\"epoll 空轮询导致 CPU 100%\",\"对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal，ByteBuf => ByteBuffer\",\"Netty vs 其它网络应用框架 \",\"Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\",\"久经考验，16年，Netty 版本 \",\"2.x 2004\",\"3.x 2008\",\"4.x 2013\",\"5.x 已废弃（没有明显的性能提升，维护成本高）\"]},\"843\":{\"h\":\"双向通信\"},\"844\":{\"h\":\"练习\",\"t\":[\"实现一个 echo server\",\"编写 server\",\"new ServerBootstrap() .group(new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) { ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buffer = (ByteBuf) msg; System.out.println(buffer.toString(Charset.defaultCharset())); // 建议使用 ctx.alloc() 创建 ByteBuf ByteBuf response = ctx.alloc().buffer(); response.writeBytes(buffer); ctx.writeAndFlush(response); // 思考：需要释放 buffer 吗 // 思考：需要释放 response 吗 } }); } }).bind(8080); \",\"编写 client\",\"NioEventLoopGroup group = new NioEventLoopGroup(); Channel channel = new Bootstrap() .group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer<NioSocketChannel>() { @Override protected void initChannel(NioSocketChannel ch) throws Exception { ch.pipeline().addLast(new StringEncoder()); ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { ByteBuf buffer = (ByteBuf) msg; System.out.println(buffer.toString(Charset.defaultCharset())); // 思考：需要释放 buffer 吗 } }); } }).connect(\\\"127.0.0.1\\\", 8080).sync().channel(); channel.closeFuture().addListener(future -> { group.shutdownGracefully(); }); new Thread(() -> { Scanner scanner = new Scanner(System.in); while (true) { String line = scanner.nextLine(); if (\\\"q\\\".equals(line)) { channel.close(); break; } channel.writeAndFlush(line); } }).start(); \"]},\"845\":{\"h\":\"读和写的误解💡\",\"t\":[\"我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在A 到 B 和 B 到 A 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\",\"例如\",\"public class TestServer { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8888); Socket s = ss.accept(); new Thread(() -> { try { BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream())); while (true) { System.out.println(reader.readLine()); } } catch (IOException e) { e.printStackTrace(); } }).start(); new Thread(() -> { try { BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据 for (int i = 0; i < 100; i++) { writer.write(String.valueOf(i)); writer.newLine(); writer.flush(); } } catch (IOException e) { e.printStackTrace(); } }).start(); } } \",\"客户端\",\"public class TestClient { public static void main(String[] args) throws IOException { Socket s = new Socket(\\\"localhost\\\", 8888); new Thread(() -> { try { BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream())); while (true) { System.out.println(reader.readLine()); } } catch (IOException e) { e.printStackTrace(); } }).start(); new Thread(() -> { try { BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); for (int i = 0; i < 100; i++) { writer.write(String.valueOf(i)); writer.newLine(); writer.flush(); } } catch (IOException e) { e.printStackTrace(); } }).start(); } } \"]},\"846\":{\"h\":\"ByteBuffer\",\"t\":[\"有一普通文本文件 data.txt，内容为\",\"1234567890abcd \",\"使用 FileChannel 来读取文件内容\",\"@Slf4j public class ChannelDemo1 { public static void main(String[] args) { try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/data.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(10); do { // 向 buffer 写入 int len = channel.read(buffer); log.debug(\\\"读到字节数：{}\\\", len); if (len == -1) { break; } // 切换 buffer 读模式 buffer.flip(); while(buffer.hasRemaining()) { log.debug(\\\"{}\\\", (char)buffer.get()); } // 切换 buffer 写模式 buffer.clear(); } while (true); } catch (IOException e) { e.printStackTrace(); } } } \",\"输出\",\"10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d 10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1 \"]},\"847\":{\"h\":\"ByteBuffer 正确使用姿势\",\"t\":[\"向 buffer 写入数据，例如调用 channel.read(buffer)\",\"调用 flip() 切换至读模式\",\"从 buffer 读取数据，例如调用 buffer.get()\",\"调用 clear() 或 compact() 切换至写模式\",\"重复 1~4 步骤\"]},\"848\":{\"h\":\"ByteBuffer 结构\",\"t\":[\"ByteBuffer 有以下重要属性\",\"capacity\",\"position\",\"limit\",\"一开始\",\"写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\",\"flip 动作发生后，position 切换为读取位置，limit 切换为读取限制\",\"读取 4 个字节后，状态\",\"clear 动作发生后，状态\",\"compact 方法，是把未读完的部分向前压缩，然后切换至写模式\"]},\"849\":{\"h\":\"调试工具类💡\",\"t\":[\"public class ByteBufferUtil { private static final char[] BYTE2CHAR = new char[256]; private static final char[] HEXDUMP_TABLE = new char[256 * 4]; private static final String[] HEXPADDING = new String[16]; private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4]; private static final String[] BYTE2HEX = new String[256]; private static final String[] BYTEPADDING = new String[16]; static { final char[] DIGITS = \\\"0123456789abcdef\\\".toCharArray(); for (int i = 0; i < 256; i++) { HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F]; HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F]; } int i; // Generate the lookup table for hex dump paddings for (i = 0; i < HEXPADDING.length; i++) { int padding = HEXPADDING.length - i; StringBuilder buf = new StringBuilder(padding * 3); for (int j = 0; j < padding; j++) { buf.append(\\\" \\\"); } HEXPADDING[i] = buf.toString(); } // Generate the lookup table for the start-offset header in each row (up to 64KiB). for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) { StringBuilder buf = new StringBuilder(12); buf.append(NEWLINE); buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L)); buf.setCharAt(buf.length() - 9, '|'); buf.append('|'); HEXDUMP_ROWPREFIXES[i] = buf.toString(); } // Generate the lookup table for byte-to-hex-dump conversion for (i = 0; i < BYTE2HEX.length; i++) { BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i); } // Generate the lookup table for byte dump paddings for (i = 0; i < BYTEPADDING.length; i++) { int padding = BYTEPADDING.length - i; StringBuilder buf = new StringBuilder(padding); for (int j = 0; j < padding; j++) { buf.append(' '); } BYTEPADDING[i] = buf.toString(); } // Generate the lookup table for byte-to-char conversion for (i = 0; i < BYTE2CHAR.length; i++) { if (i <= 0x1f || i >= 0x7f) { BYTE2CHAR[i] = '.'; } else { BYTE2CHAR[i] = (char) i; } } } /** * 打印所有内容 * @param buffer */ public static void debugAll(ByteBuffer buffer) { int oldlimit = buffer.limit(); buffer.limit(buffer.capacity()); StringBuilder origin = new StringBuilder(256); appendPrettyHexDump(origin, buffer, 0, buffer.capacity()); System.out.println(\\\"+--------+-------------------- all ------------------------+----------------+\\\"); System.out.printf(\\\"position: [%d], limit: [%d]\\\\n\\\", buffer.position(), oldlimit); System.out.println(origin); buffer.limit(oldlimit); } /** * 打印可读取内容 * @param buffer */ public static void debugRead(ByteBuffer buffer) { StringBuilder builder = new StringBuilder(256); appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position()); System.out.println(\\\"+--------+-------------------- read -----------------------+----------------+\\\"); System.out.printf(\\\"position: [%d], limit: [%d]\\\\n\\\", buffer.position(), buffer.limit()); System.out.println(builder); } private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) { if (isOutOfBounds(offset, length, buf.capacity())) { throw new IndexOutOfBoundsException( \\\"expected: \\\" + \\\"0 <= offset(\\\" + offset + \\\") <= offset + length(\\\" + length + \\\") <= \\\" + \\\"buf.capacity(\\\" + buf.capacity() + ')'); } if (length == 0) { return; } dump.append( \\\" +-------------------------------------------------+\\\" + NEWLINE + \\\" | 0 1 2 3 4 5 6 7 8 9 a b c d e f |\\\" + NEWLINE + \\\"+--------+-------------------------------------------------+----------------+\\\"); final int startIndex = offset; final int fullRows = length >>> 4; final int remainder = length & 0xF; // Dump the rows which have 16 bytes. for (int row = 0; row < fullRows; row++) { int rowStartIndex = (row << 4) + startIndex; // Per-row prefix. appendHexDumpRowPrefix(dump, row, rowStartIndex); // Hex dump int rowEndIndex = rowStartIndex + 16; for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2HEX[getUnsignedByte(buf, j)]); } dump.append(\\\" |\\\"); // ASCII dump for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]); } dump.append('|'); } // Dump the last row which has less than 16 bytes. if (remainder != 0) { int rowStartIndex = (fullRows << 4) + startIndex; appendHexDumpRowPrefix(dump, fullRows, rowStartIndex); // Hex dump int rowEndIndex = rowStartIndex + remainder; for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2HEX[getUnsignedByte(buf, j)]); } dump.append(HEXPADDING[remainder]); dump.append(\\\" |\\\"); // Ascii dump for (int j = rowStartIndex; j < rowEndIndex; j++) { dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]); } dump.append(BYTEPADDING[remainder]); dump.append('|'); } dump.append(NEWLINE + \\\"+--------+-------------------------------------------------+----------------+\\\"); } private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) { if (row < HEXDUMP_ROWPREFIXES.length) { dump.append(HEXDUMP_ROWPREFIXES[row]); } else { dump.append(NEWLINE); dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L)); dump.setCharAt(dump.length() - 9, '|'); dump.append('|'); } } public static short getUnsignedByte(ByteBuffer buffer, int index) { return (short) (buffer.get(index) & 0xFF); } } \"]},\"850\":{\"h\":\"ByteBuffer 常见方法\"},\"851\":{\"h\":\"分配空间\",\"t\":[\"可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\",\"ByteBuffer buf = ByteBuffer.allocate(16); // -- java堆内存，读写效率较低，受GC影响 ByteBuffer buf2 = ByteBuffer.allocateDirect(16); // -- 直接内存，读写效率高（少一次拷贝），不受GC影响，分配的效率低，可能造成内存泄漏 \"]},\"852\":{\"h\":\"向 buffer 写入数据\",\"t\":[\"有两种办法\",\"调用 channel 的 read 方法\",\"调用 buffer 自己的 put 方法\",\"int readBytes = channel.read(buf); \",\"和\",\"buf.put((byte)127); \"]},\"853\":{\"h\":\"从 buffer 读取数据\",\"t\":[\"同样有两种办法\",\"调用 channel 的 write 方法\",\"调用 buffer 自己的 get 方法\",\"int writeBytes = channel.write(buf); \",\"和\",\"byte b = buf.get(); \",\"get 方法会让 position 读指针向后走，如果想重复读取数据\",\"可以调用 rewind 方法将 position 重新置为 0\",\"或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\"]},\"854\":{\"h\":\"mark 和 reset\",\"t\":[\"mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\",\"注意\",\"rewind 和 flip 都会清除 mark 位置\"]},\"855\":{\"h\":\"字符串与 ByteBuffer 互转\",\"t\":[\"ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\\\"你好\\\"); ByteBuffer buffer2 = Charset.forName(\\\"utf-8\\\").encode(\\\"你好\\\"); debug(buffer1); debug(buffer2); CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1); System.out.println(buffer3.getClass()); System.out.println(buffer3.toString()); \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| e4 bd a0 e5 a5 bd |...... | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| e4 bd a0 e5 a5 bd |...... | +--------+-------------------------------------------------+----------------+ class java.nio.HeapCharBuffer 你好 \"]},\"856\":{\"h\":\"Buffer 的线程安全⚠️\",\"t\":[\"Buffer 是非线程安全的\"]},\"857\":{\"h\":\"Scattering Reads分散读\",\"t\":[\"分散读取，有一个文本文件 3parts.txt\",\"onetwothree \",\"使用如下方式读取，可以将数据填充至多个 buffer\",\"try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/3parts.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer a = ByteBuffer.allocate(3); ByteBuffer b = ByteBuffer.allocate(3); ByteBuffer c = ByteBuffer.allocate(5); channel.read(new ByteBuffer[]{a, b, c}); a.flip(); b.flip(); c.flip(); debug(a); debug(b); debug(c); } catch (IOException e) { e.printStackTrace(); } \",\"结果\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 6f 6e 65 |one | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 74 77 6f |two | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 74 68 72 65 65 |three | +--------+-------------------------------------------------+----------------+ \"]},\"858\":{\"h\":\"Gathering Writes集中写\",\"t\":[\"使用如下方式写入，可以将多个 buffer 的数据填充至 channel\",\"try (RandomAccessFile file = new RandomAccessFile(\\\"helloword/3parts.txt\\\", \\\"rw\\\")) { FileChannel channel = file.getChannel(); ByteBuffer d = ByteBuffer.allocate(4); ByteBuffer e = ByteBuffer.allocate(4); channel.position(11); d.put(new byte[]{'f', 'o', 'u', 'r'}); e.put(new byte[]{'f', 'i', 'v', 'e'}); d.flip(); e.flip(); debug(d); debug(e); channel.write(new ByteBuffer[]{d, e}); } catch (IOException e) { e.printStackTrace(); } \",\"输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 6f 75 72 |four | +--------+-------------------------------------------------+----------------+ +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 66 69 76 65 |five | +--------+-------------------------------------------------+----------------+ \",\"文件内容\",\"onetwothreefourfive \"]},\"859\":{\"h\":\"练习\",\"t\":[\"网络上有多条数据发送给服务端，数据之间使用 \\\\n 进行分隔 但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\",\"Hello,world\\\\n\",\"I'm zhangsan\\\\n\",\"How are you?\\\\n\",\"变成了下面的两个 byteBuffer (黏包，半包)\",\"Hello,world\\\\nI'm zhangsan\\\\nHo\",\"w are you?\\\\n\",\"现在要求你编写程序，将错乱的数据恢复成原始的按 \\\\n 分隔的数据\",\"public static void main(String[] args) { ByteBuffer source = ByteBuffer.allocate(32); // 11 24 source.put(\\\"Hello,world\\\\nI'm zhangsan\\\\nHo\\\".getBytes()); split(source); source.put(\\\"w are you?\\\\nhaha!\\\\n\\\".getBytes()); split(source); } private static void split(ByteBuffer source) { source.flip(); int oldLimit = source.limit(); for (int i = 0; i < oldLimit; i++) { if (source.get(i) == '\\\\n') { System.out.println(i); ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position()); // 0 ~ limit source.limit(i + 1); target.put(source); // 从source 读，向 target 写 debugAll(target); source.limit(oldLimit); } } source.compact(); } \"]},\"860\":{\"h\":\"文件编程\"},\"861\":{\"h\":\"FileChannel\"},\"862\":{\"h\":\"FileChannel 工作模式⚠️\",\"t\":[\"FileChannel 只能工作在阻塞模式下\"]},\"863\":{\"h\":\"获取\",\"t\":[\"不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\",\"通过 FileInputStream 获取的 channel 只能读\",\"通过 FileOutputStream 获取的 channel 只能写\",\"通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\"]},\"864\":{\"h\":\"读取\",\"t\":[\"会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\",\"int readBytes = channel.read(buffer); \"]},\"865\":{\"h\":\"写入\",\"t\":[\"写入的正确姿势如下， SocketChannel\",\"ByteBuffer buffer = ...; buffer.put(...); // 存入数据 buffer.flip(); // 切换读模式 while(buffer.hasRemaining()) { channel.write(buffer); } \",\"在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\"]},\"866\":{\"h\":\"关闭\",\"t\":[\"channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\"]},\"867\":{\"h\":\"位置\",\"t\":[\"获取当前位置\",\"long pos = channel.position(); \",\"设置当前位置\",\"long newPos = ...; channel.position(newPos); \",\"设置当前位置时，如果设置为文件的末尾\",\"这时读取会返回 -1\",\"这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\"]},\"868\":{\"h\":\"大小\",\"t\":[\"使用 size 方法获取文件的大小\"]},\"869\":{\"h\":\"强制写入\",\"t\":[\"操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\"]},\"870\":{\"h\":\"两个 Channel 传输数据\",\"t\":[\"String FROM = \\\"helloword/data.txt\\\"; String TO = \\\"helloword/to.txt\\\"; long start = System.nanoTime(); try (FileChannel from = new FileInputStream(FROM).getChannel(); FileChannel to = new FileOutputStream(TO).getChannel(); ) { // 效率高，底层会用操作系统的零拷贝进行优化，一次只能穿2G from.transferTo(0, from.size(), to); } catch (IOException e) { e.printStackTrace(); } long end = System.nanoTime(); System.out.println(\\\"transferTo 用时：\\\" + (end - start) / 1000_000.0); \",\"输出\",\"transferTo 用时：8.2011 \",\"超过 2g 大小的文件传输\",\"public class TestFileChannelTransferTo { public static void main(String[] args) { try ( FileChannel from = new FileInputStream(\\\"data.txt\\\").getChannel(); FileChannel to = new FileOutputStream(\\\"to.txt\\\").getChannel(); ) { // 效率高，底层会利用操作系统的零拷贝进行优化 long size = from.size(); // left 变量代表还剩余多少字节 for (long left = size; left > 0; ) { System.out.println(\\\"position:\\\" + (size - left) + \\\" left:\\\" + left); left -= from.transferTo((size - left), left, to); } } catch (IOException e) { e.printStackTrace(); } } } \",\"实际传输一个超大文件\",\"position:0 left:7769948160 position:2147483647 left:5622464513 position:4294967294 left:3474980866 position:6442450941 left:1327497219 \"]},\"871\":{\"h\":\"Path\",\"t\":[\"jdk7 引入了 Path 和 Paths 类\",\"Path 用来表示文件路径\",\"Paths 是工具类，用来获取 Path 实例\",\"Path source = Paths.get(\\\"1.txt\\\"); // 相对路径 使用 user.dir 环境变量来定位 1.txt Path source = Paths.get(\\\"d:\\\\\\\\1.txt\\\"); // 绝对路径 代表了 d:\\\\1.txt Path source = Paths.get(\\\"d:/1.txt\\\"); // 绝对路径 同样代表了 d:\\\\1.txt Path projects = Paths.get(\\\"d:\\\\\\\\data\\\", \\\"projects\\\"); // 代表了 d:\\\\data\\\\projects \",\". 代表了当前路径\",\".. 代表了上一级路径\",\"例如目录结构如下\",\"d: |- data |- projects |- a |- b \",\"代码\",\"Path path = Paths.get(\\\"d:\\\\\\\\data\\\\\\\\projects\\\\\\\\a\\\\\\\\..\\\\\\\\b\\\"); System.out.println(path); System.out.println(path.normalize()); // 正常化路径 \",\"会输出\",\"d:\\\\data\\\\projects\\\\a\\\\..\\\\b d:\\\\data\\\\projects\\\\b \"]},\"872\":{\"h\":\"Files\",\"t\":[\"检查文件是否存在\",\"Path path = Paths.get(\\\"helloword/data.txt\\\"); System.out.println(Files.exists(path)); \",\"创建一级目录\",\"Path path = Paths.get(\\\"helloword/d1\\\"); Files.createDirectory(path); \",\"如果目录已存在，会抛异常 FileAlreadyExistsException\",\"不能一次创建多级目录，否则会抛异常 NoSuchFileException\",\"创建多级目录用\",\"Path path = Paths.get(\\\"helloword/d1/d2\\\"); Files.createDirectories(path); \",\"拷贝文件\",\"Path source = Paths.get(\\\"helloword/data.txt\\\"); Path target = Paths.get(\\\"helloword/target.txt\\\"); Files.copy(source, target); \",\"如果文件已存在，会抛异常 FileAlreadyExistsException\",\"如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\",\"Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING); \",\"移动文件\",\"Path source = Paths.get(\\\"helloword/data.txt\\\"); Path target = Paths.get(\\\"helloword/data.txt\\\"); Files.move(source, target, StandardCopyOption.ATOMIC_MOVE); \",\"StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\",\"删除文件\",\"Path target = Paths.get(\\\"helloword/target.txt\\\"); Files.delete(target); \",\"如果文件不存在，会抛异常 NoSuchFileException\",\"删除目录\",\"Path target = Paths.get(\\\"helloword/d1\\\"); Files.delete(target); \",\"如果目录还有内容，会抛异常 DirectoryNotEmptyException\",\"遍历目录文件\",\"// 统计文件夹和文件个数 public static void main(String[] args) throws IOException { Path path = Paths.get(\\\"C:\\\\\\\\Program Files\\\\\\\\Java\\\\\\\\jdk1.8.0_91\\\"); AtomicInteger dirCount = new AtomicInteger(); AtomicInteger fileCount = new AtomicInteger(); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException { System.out.println(dir); dirCount.incrementAndGet(); return super.preVisitDirectory(dir, attrs); } @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { System.out.println(file); fileCount.incrementAndGet(); return super.visitFile(file, attrs); } }); System.out.println(dirCount); // 133 System.out.println(fileCount); // 1479 } \",\"统计 jar 的数目\",\"Path path = Paths.get(\\\"C:\\\\\\\\Program Files\\\\\\\\Java\\\\\\\\jdk1.8.0_91\\\"); AtomicInteger fileCount = new AtomicInteger(); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { if (file.toFile().getName().endsWith(\\\".jar\\\")) { fileCount.incrementAndGet(); } return super.visitFile(file, attrs); } }); System.out.println(fileCount); // 724 \",\"删除多级目录\",\"Path path = Paths.get(\\\"d:\\\\\\\\a\\\"); Files.walkFileTree(path, new SimpleFileVisitor<Path>(){ @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException { Files.delete(file); return super.visitFile(file, attrs); } @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException { Files.delete(dir); return super.postVisitDirectory(dir, exc); } }); \"]},\"873\":{\"h\":\"删除很危险⚠️\",\"t\":[\"删除是危险操作，确保要递归删除的文件夹没有重要内容\",\"拷贝多级目录\",\"long start = System.currentTimeMillis(); String source = \\\"D:\\\\\\\\Snipaste-1.16.2-x64\\\"; String target = \\\"D:\\\\\\\\Snipaste-1.16.2-x64aaa\\\"; Files.walk(Paths.get(source)).forEach(path -> { try { String targetName = path.toString().replace(source, target); // 是目录 if (Files.isDirectory(path)) { Files.createDirectory(Paths.get(targetName)); } // 是普通文件 else if (Files.isRegularFile(path)) { Files.copy(path, Paths.get(targetName)); } } catch (IOException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(end - start); \"]},\"874\":{\"h\":\"网络编程\"},\"875\":{\"h\":\"非阻塞 vs 阻塞\"},\"876\":{\"h\":\"阻塞\",\"t\":[\"阻塞模式下，相关方法都会导致线程暂停 \",\"ServerSocketChannel.accept 会在没有连接建立时让线程暂停\",\"SocketChannel.read 会在没有数据可读时让线程暂停\",\"阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\",\"单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\",\"但多线程下，有新的问题，体现在以下方面 \",\"32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\",\"可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\",\"服务器端\",\"// 使用 nio 来理解阻塞模式, 单线程 // 0. ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(16); // 1. 创建了服务器 ServerSocketChannel ssc = ServerSocketChannel.open(); // 2. 绑定监听端口 ssc.bind(new InetSocketAddress(8080)); // 3. 连接集合 List<SocketChannel> channels = new ArrayList<>(); while (true) { // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信 log.debug(\\\"connecting...\\\"); SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行 log.debug(\\\"connected... {}\\\", sc); channels.add(sc); for (SocketChannel channel : channels) { // 5. 接收客户端发送的数据 log.debug(\\\"before read... {}\\\", channel); channel.read(buffer); // 阻塞方法，线程停止运行 buffer.flip(); debugRead(buffer); buffer.clear(); log.debug(\\\"after read...{}\\\", channel); } } \",\"客户端\",\"SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); System.out.println(\\\"waiting...\\\"); \"]},\"877\":{\"h\":\"非阻塞\",\"t\":[\"非阻塞模式下，相关方法都会不会让线程暂停 \",\"在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\",\"SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept\",\"写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\",\"但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\",\"数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\",\"服务器端，客户端代码不变\",\"// 使用 nio 来理解非阻塞模式, 单线程 // 0. ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(16); // 1. 创建了服务器 ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 非阻塞模式 // 2. 绑定监听端口 ssc.bind(new InetSocketAddress(8080)); // 3. 连接集合 List<SocketChannel> channels = new ArrayList<>(); while (true) { // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信 SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null if (sc != null) { log.debug(\\\"connected... {}\\\", sc); sc.configureBlocking(false); // 非阻塞模式 channels.add(sc); } for (SocketChannel channel : channels) { // 5. 接收客户端发送的数据 int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0 if (read > 0) { buffer.flip(); debugRead(buffer); buffer.clear(); log.debug(\\\"after read...{}\\\", channel); } } } \"]},\"878\":{\"h\":\"多路复用\",\"t\":[\"单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\",\"多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\",\"如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证 \",\"有可连接事件时才去连接\",\"有可读事件才去读取\",\"有可写事件才去写入 \",\"限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\"]},\"879\":{\"h\":\"Selector\",\"t\":[\"好处\",\"一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\",\"让这个线程能够被充分利用\",\"节约了线程的数量\",\"减少了线程上下文切换\"]},\"880\":{\"h\":\"创建\",\"t\":[\"Selector selector = Selector.open(); \"]},\"881\":{\"h\":\"绑定 Channel 事件\",\"t\":[\"也称之为注册事件，绑定的事件 selector 才会关心\",\"channel.configureBlocking(false); SelectionKey key = channel.register(selector, 绑定事件); \",\"channel 必须工作在非阻塞模式\",\"FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\",\"绑定的事件类型可以有 \",\"connect - 客户端连接成功时触发\",\"accept - 服务器端成功接受连接时触发\",\"read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\",\"write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\"]},\"882\":{\"h\":\"监听 Channel 事件\",\"t\":[\"可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\",\"方法1，阻塞直到绑定事件发生\",\"int count = selector.select(); \",\"方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\",\"int count = selector.select(long timeout); \",\"方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\",\"int count = selector.selectNow(); \"]},\"883\":{\"h\":\"select 何时不阻塞💡\",\"t\":[\"事件发生时 \",\"客户端发起连接请求，会触发 accept 事件\",\"客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\",\"channel 可写，会触发 write 事件\",\"在 linux 下 nio bug 发生时\",\"调用 selector.wakeup()\",\"调用 selector.close()\",\"selector 所在线程 interrupt\"]},\"884\":{\"h\":\"处理 accept 事件\",\"t\":[\"客户端代码为\",\"public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\\\"localhost\\\", 8080)) { System.out.println(socket); socket.getOutputStream().write(\\\"world\\\".getBytes()); System.in.read(); } catch (IOException e) { e.printStackTrace(); } } } \",\"服务器端代码为\",\"@Slf4j public class ChannelDemo6 { public static void main(String[] args) { try (ServerSocketChannel channel = ServerSocketChannel.open()) { channel.bind(new InetSocketAddress(8080)); System.out.println(channel); Selector selector = Selector.open(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_ACCEPT); while (true) { int count = selector.select(); // int count = selector.selectNow(); log.debug(\\\"select count: {}\\\", count); // if(count <= 0) { // continue; // } // 获取所有事件 Set<SelectionKey> keys = selector.selectedKeys(); // 遍历所有事件，逐一处理 Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); // 判断事件类型 if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); // 必须处理 SocketChannel sc = c.accept(); log.debug(\\\"{}\\\", sc); } // 处理完毕，必须将事件移除 iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } \"]},\"885\":{\"h\":\"事件发生后能否不处理💡\",\"t\":[\"事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\"]},\"886\":{\"h\":\"处理 read 事件\",\"t\":[\"@Slf4j public class ChannelDemo6 { public static void main(String[] args) { try (ServerSocketChannel channel = ServerSocketChannel.open()) { channel.bind(new InetSocketAddress(8080)); System.out.println(channel); Selector selector = Selector.open(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_ACCEPT); while (true) { int count = selector.select(); // int count = selector.selectNow(); log.debug(\\\"select count: {}\\\", count); // if(count <= 0) { // continue; // } // 获取所有事件 Set<SelectionKey> keys = selector.selectedKeys(); // 遍历所有事件，逐一处理 Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); // 判断事件类型 if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); // 必须处理 SocketChannel sc = c.accept(); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); log.debug(\\\"连接已建立: {}\\\", sc); } else if (key.isReadable()) { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(128); int read = sc.read(buffer); if(read == -1) { key.cancel(); sc.close(); } else { buffer.flip(); debug(buffer); } } // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题 iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } \",\"开启两个客户端，修改一下发送文字，输出\",\"sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080] 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367] 21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 65 6c 6c 6f |hello | +--------+-------------------------------------------------+----------------+ 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378] 21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 77 6f 72 6c 64 |world | +--------+-------------------------------------------------+----------------+ \"]},\"887\":{\"h\":\"为何要 iter.remove()💡\",\"t\":[\"因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\",\"第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey\",\"第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\"]},\"888\":{\"h\":\"cancel 的作用💡\",\"t\":[\"cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\"]},\"889\":{\"h\":\"不处理边界的问题⚠️\",\"t\":[\"以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\",\"public class Server { public static void main(String[] args) throws IOException { ServerSocket ss=new ServerSocket(9000); while (true) { Socket s = ss.accept(); InputStream in = s.getInputStream(); // 这里这么写，有没有问题 byte[] arr = new byte[4]; while(true) { int read = in.read(arr); // 这里这么写，有没有问题 if(read == -1) { break; } System.out.println(new String(arr, 0, read)); } } } } \",\"客户端\",\"public class Client { public static void main(String[] args) throws IOException { Socket max = new Socket(\\\"localhost\\\", 9000); OutputStream out = max.getOutputStream(); out.write(\\\"hello\\\".getBytes()); out.write(\\\"world\\\".getBytes()); out.write(\\\"你好\\\".getBytes()); max.close(); } } \",\"输出\",\"hell owor ld� �好 \",\"为什么？\"]},\"890\":{\"h\":\"处理消息的边界\",\"t\":[\"一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\",\"另一种思路是按分隔符拆分，缺点是效率低\",\"TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量 \",\"Http 1.1 是 TLV 格式\",\"Http 2.0 是 LTV 格式\",\"服务器端\",\"private static void split(ByteBuffer source) { source.flip(); for (int i = 0; i < source.limit(); i++) { // 找到一条完整消息 if (source.get(i) == '\\\\n') { int length = i + 1 - source.position(); // 把这条完整消息存入新的 ByteBuffer ByteBuffer target = ByteBuffer.allocate(length); // 从 source 读，向 target 写 for (int j = 0; j < length; j++) { target.put(source.get()); } debugAll(target); } } source.compact(); // 0123456789abcdef position 16 limit 16 } public static void main(String[] args) throws IOException { // 1. 创建 selector, 管理多个 channel Selector selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); // 2. 建立 selector 和 channel 的联系（注册） // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件 SelectionKey sscKey = ssc.register(selector, 0, null); // key 只关注 accept 事件 sscKey.interestOps(SelectionKey.OP_ACCEPT); log.debug(\\\"sscKey:{}\\\", sscKey); ssc.bind(new InetSocketAddress(8080)); while (true) { // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行 // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理 selector.select(); // 4. 处理事件, selectedKeys 内部包含了所有发生的事件 Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read while (iter.hasNext()) { SelectionKey key = iter.next(); // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题 iter.remove(); log.debug(\\\"key: {}\\\", key); // 5. 区分事件类型 if (key.isAcceptable()) { // 如果是 accept ServerSocketChannel channel = (ServerSocketChannel) key.channel(); SocketChannel sc = channel.accept(); sc.configureBlocking(false); ByteBuffer buffer = ByteBuffer.allocate(16); // attachment // 将一个 byteBuffer 作为附件关联到 selectionKey 上 SelectionKey scKey = sc.register(selector, 0, buffer); scKey.interestOps(SelectionKey.OP_READ); log.debug(\\\"{}\\\", sc); log.debug(\\\"scKey:{}\\\", scKey); } else if (key.isReadable()) { // 如果是 read try { SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel // 获取 selectionKey 上关联的附件 ByteBuffer buffer = (ByteBuffer) key.attachment(); int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1 if(read == -1) { key.cancel(); } else { split(buffer); // 需要扩容 if (buffer.position() == buffer.limit()) { ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2); buffer.flip(); newBuffer.put(buffer); // 0123456789abcdef3333\\\\n key.attach(newBuffer); } } } catch (IOException e) { e.printStackTrace(); key.cancel(); // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key） } } } } } \",\"客户端\",\"SocketChannel sc = SocketChannel.open(); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); SocketAddress address = sc.getLocalAddress(); // sc.write(Charset.defaultCharset().encode(\\\"hello\\\\nworld\\\\n\\\")); sc.write(Charset.defaultCharset().encode(\\\"0123\\\\n456789abcdef\\\")); sc.write(Charset.defaultCharset().encode(\\\"0123456789abcdef3333\\\\n\\\")); System.in.read(); \"]},\"891\":{\"h\":\"ByteBuffer 大小分配\",\"t\":[\"每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\",\"ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer \",\"一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 http://tutorials.jenkov.com/java-performance/resizable-array.html\",\"另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\"]},\"892\":{\"h\":\"处理 write 事件\"},\"893\":{\"h\":\"一次无法写完例子\",\"t\":[\"非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\",\"用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略 \",\"当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\",\"selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\",\"如果不取消，会每次可写均会触发 write 事件\",\"public class WriteServer { public static void main(String[] args) throws IOException { ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false); ssc.bind(new InetSocketAddress(8080)); Selector selector = Selector.open(); ssc.register(selector, SelectionKey.OP_ACCEPT); while(true) { selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { SocketChannel sc = ssc.accept(); sc.configureBlocking(false); SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ); // 1. 向客户端发送内容 StringBuilder sb = new StringBuilder(); for (int i = 0; i < 3000000; i++) { sb.append(\\\"a\\\"); } ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString()); int write = sc.write(buffer); // 3. write 表示实际写了多少字节 System.out.println(\\\"实际写入字节:\\\" + write); // 4. 如果有剩余未读字节，才需要关注写事件 if (buffer.hasRemaining()) { // read 1 write 4 // 在原有关注事件的基础上，多关注 写事件 sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE); // 把 buffer 作为附件加入 sckey sckey.attach(buffer); } } else if (key.isWritable()) { ByteBuffer buffer = (ByteBuffer) key.attachment(); SocketChannel sc = (SocketChannel) key.channel(); int write = sc.write(buffer); System.out.println(\\\"实际写入字节:\\\" + write); if (!buffer.hasRemaining()) { // 写完了 key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); key.attach(null); } } } } } } \",\"客户端\",\"public class WriteClient { public static void main(String[] args) throws IOException { Selector selector = Selector.open(); SocketChannel sc = SocketChannel.open(); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ); sc.connect(new InetSocketAddress(\\\"localhost\\\", 8080)); int count = 0; while (true) { selector.select(); Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isConnectable()) { System.out.println(sc.finishConnect()); } else if (key.isReadable()) { ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); count += sc.read(buffer); buffer.clear(); System.out.println(count); } } } } } \"]},\"894\":{\"h\":\"write 为何要取消💡\",\"t\":[\"只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\"]},\"895\":{\"h\":\"更进一步\"},\"896\":{\"h\":\"利用多线程优化💡\",\"t\":[\"现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\",\"前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\",\"分两组选择器\",\"单线程配一个选择器（boss），专门处理 accept 事件\",\"创建 cpu 核心数的线程，每个线程配一个选择器（worker），轮流处理 read 事件\",\"public class ChannelDemo7 { public static void main(String[] args) throws IOException { new BossEventLoop().register(); } @Slf4j static class BossEventLoop implements Runnable { private Selector boss; private WorkerEventLoop[] workers; private volatile boolean start = false; AtomicInteger index = new AtomicInteger(); public void register() throws IOException { if (!start) { start = true; ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.bind(new InetSocketAddress(8080)); ssc.configureBlocking(false); boss = Selector.open(); SelectionKey ssckey = ssc.register(boss, 0, null); ssckey.interestOps(SelectionKey.OP_ACCEPT); workers = initEventLoops(); new Thread(this, \\\"boss\\\").start(); log.debug(\\\"boss start...\\\"); } } public WorkerEventLoop[] initEventLoops() { // EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()]; WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2]; for (int i = 0; i < workerEventLoops.length; i++) { workerEventLoops[i] = new WorkerEventLoop(i); } return workerEventLoops; } @Override public void run() { while (true) { try { boss.select(); Iterator<SelectionKey> iter = boss.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); iter.remove(); if (key.isAcceptable()) { ServerSocketChannel c = (ServerSocketChannel) key.channel(); SocketChannel sc = c.accept(); sc.configureBlocking(false); log.debug(\\\"{} connected\\\", sc.getRemoteAddress()); workers[index.getAndIncrement() % workers.length].register(sc); } } } catch (IOException e) { e.printStackTrace(); } } } } @Slf4j static class WorkerEventLoop implements Runnable { private Selector worker; private volatile boolean start = false; private int index; private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>(); public WorkerEventLoop(int index) { this.index = index; } public void register(SocketChannel sc) throws IOException { if (!start) { worker = Selector.open(); new Thread(this, \\\"worker-\\\" + index).start(); start = true; } tasks.add(() -> { try { SelectionKey sckey = sc.register(worker, 0, null); sckey.interestOps(SelectionKey.OP_READ); worker.selectNow(); } catch (IOException e) { e.printStackTrace(); } }); worker.wakeup(); } @Override public void run() { while (true) { try { worker.select(); Runnable task = tasks.poll(); if (task != null) { task.run(); } Set<SelectionKey> keys = worker.selectedKeys(); Iterator<SelectionKey> iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); if (key.isReadable()) { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(128); try { int read = sc.read(buffer); if (read == -1) { key.cancel(); sc.close(); } else { buffer.flip(); log.debug(\\\"{} message:\\\", sc.getRemoteAddress()); debugAll(buffer); } } catch (IOException e) { e.printStackTrace(); key.cancel(); sc.close(); } } iter.remove(); } } catch (IOException e) { e.printStackTrace(); } } } } } \"]},\"897\":{\"h\":\"如何拿到 cpu 个数💡\",\"t\":[\"Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\",\"这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\"]},\"898\":{\"h\":\"UDP\",\"t\":[\"UDP 是无连接的，client 发送数据不会管 server 是否开启\",\"server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\",\"首先启动服务器端\",\"public class UdpServer { public static void main(String[] args) { try (DatagramChannel channel = DatagramChannel.open()) { channel.socket().bind(new InetSocketAddress(9999)); System.out.println(\\\"waiting...\\\"); ByteBuffer buffer = ByteBuffer.allocate(32); channel.receive(buffer); buffer.flip(); debug(buffer); } catch (IOException e) { e.printStackTrace(); } } } \",\"输出\",\"waiting... \",\"运行客户端\",\"public class UdpClient { public static void main(String[] args) { try (DatagramChannel channel = DatagramChannel.open()) { ByteBuffer buffer = StandardCharsets.UTF_8.encode(\\\"hello\\\"); InetSocketAddress address = new InetSocketAddress(\\\"localhost\\\", 9999); channel.send(buffer, address); } catch (Exception e) { e.printStackTrace(); } } } \",\"接下来服务器端输出\",\" +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 68 65 6c 6c 6f |hello | +--------+-------------------------------------------------+----------------+ \"]},\"899\":{\"h\":\"NIO vs. BIO\"},\"900\":{\"h\":\"stream vs channel\",\"t\":[\"stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\",\"stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\",\"二者均为全双工，即读写可以同时进行\"]},\"901\":{\"h\":\"IO 模型\",\"t\":[\"同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\",\"同步：线程自己去获取结果（一个线程）\",\"异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\",\"当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\",\"等待数据阶段\",\"复制数据阶段\",\"阻塞 IO\",\"非阻塞 IO\",\"多路复用\",\"信号驱动\",\"异步 IO\",\"阻塞 IO vs 多路复用\"]},\"902\":{\"h\":\"参考🔖\",\"t\":[\"UNIX 网络编程 - 卷 I\"]},\"903\":{\"h\":\"零拷贝\"},\"904\":{\"h\":\"传统 IO 问题\",\"t\":[\"传统的 IO 将一个文件通过 socket 写出\",\"File f = new File(\\\"helloword/data.txt\\\"); RandomAccessFile file = new RandomAccessFile(file, \\\"r\\\"); byte[] buf = new byte[(int)f.length()]; file.read(buf); Socket socket = ...; socket.getOutputStream().write(buf); \",\"内部工作流程是这样的：\",\"java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\",\"DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\",\"从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\",\"调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，cpu 会参与拷贝\",\"接下来要向网卡写数据，这项能力 java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\",\"可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\",\"用户态与内核态的切换发生了 3 次，这个操作比较重量级\",\"数据拷贝了共 4 次\"]},\"905\":{\"h\":\"NIO 优化\",\"t\":[\"通过 DirectByteBuf\",\"ByteBuffer.allocate(10) HeapByteBuffer 使用的还是 java 内存\",\"ByteBuffer.allocateDirect(10) DirectByteBuffer 使用的是操作系统内存\",\"大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\",\"这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\",\"java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步 \",\"DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\",\"通过专门线程访问引用队列，根据虚引用释放堆外内存\",\"减少了一次数据拷贝，用户态与内核态的切换次数没有减少\",\"进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\",\"java 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\",\"数据从内核缓冲区传输到 socket 缓冲区，cpu 会参与拷贝\",\"最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 cpu\",\"可以看到\",\"只发生了一次用户态与内核态的切换\",\"数据拷贝了 3 次\",\"进一步优化（linux 2.4）\",\"java 调用 transferTo 方法后，要从 java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 cpu\",\"只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗\",\"使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 cpu\",\"整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\",\"更少的用户态与内核态的切换\",\"不利用 cpu 计算，减少 cpu 缓存伪共享\",\"零拷贝适合小文件传输\"]},\"906\":{\"h\":\"AIO\",\"t\":[\"AIO 用来解决数据复制阶段的阻塞问题\",\"同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\",\"异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\",\"异步模型需要底层操作系统（Kernel）提供支持\",\"Windows 系统通过 IOCP 实现了真正的异步 IO\",\"Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\"]},\"907\":{\"h\":\"文件 AIO\",\"t\":[\"先来看看 AsynchronousFileChannel\",\"@Slf4j public class AioDemo1 { public static void main(String[] args) throws IOException { try{ AsynchronousFileChannel s = AsynchronousFileChannel.open( Paths.get(\\\"1.txt\\\"), StandardOpenOption.READ); ByteBuffer buffer = ByteBuffer.allocate(2); log.debug(\\\"begin...\\\"); s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() { @Override public void completed(Integer result, ByteBuffer attachment) { log.debug(\\\"read completed...{}\\\", result); buffer.flip(); debug(buffer); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.debug(\\\"read failed...\\\"); } }); } catch (IOException e) { e.printStackTrace(); } log.debug(\\\"do other things...\\\"); System.in.read(); } } \",\"输出\",\"13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin... 13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things... 13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2 +-------------------------------------------------+ | 0 1 2 3 4 5 6 7 8 9 a b c d e f | +--------+-------------------------------------------------+----------------+ |00000000| 61 0d |a. | +--------+-------------------------------------------------+----------------+ \",\"可以看到\",\"响应文件读取成功的是另一个线程 Thread-5\",\"主线程并没有 IO 操作阻塞\"]},\"908\":{\"h\":\"守护线程💡\",\"t\":[\"默认文件 AIO 使用的线程都是守护线程，所以最后要执行 System.in.read() 以避免守护线程意外结束\"]},\"909\":{\"h\":\"网络 AIO\",\"t\":[\"public class AioServer { public static void main(String[] args) throws IOException { AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open(); ssc.bind(new InetSocketAddress(8080)); ssc.accept(null, new AcceptHandler(ssc)); System.in.read(); } private static void closeChannel(AsynchronousSocketChannel sc) { try { System.out.printf(\\\"[%s] %s close\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); sc.close(); } catch (IOException e) { e.printStackTrace(); } } private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> { private final AsynchronousSocketChannel sc; public ReadHandler(AsynchronousSocketChannel sc) { this.sc = sc; } @Override public void completed(Integer result, ByteBuffer attachment) { try { if (result == -1) { closeChannel(sc); return; } System.out.printf(\\\"[%s] %s read\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); attachment.flip(); System.out.println(Charset.defaultCharset().decode(attachment)); attachment.clear(); // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件 sc.read(attachment, attachment, this); } catch (IOException e) { e.printStackTrace(); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { closeChannel(sc); exc.printStackTrace(); } } private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> { private final AsynchronousSocketChannel sc; private WriteHandler(AsynchronousSocketChannel sc) { this.sc = sc; } @Override public void completed(Integer result, ByteBuffer attachment) { // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容 if (attachment.hasRemaining()) { sc.write(attachment); } } @Override public void failed(Throwable exc, ByteBuffer attachment) { exc.printStackTrace(); closeChannel(sc); } } private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> { private final AsynchronousServerSocketChannel ssc; public AcceptHandler(AsynchronousServerSocketChannel ssc) { this.ssc = ssc; } @Override public void completed(AsynchronousSocketChannel sc, Object attachment) { try { System.out.printf(\\\"[%s] %s connected\\\\n\\\", Thread.currentThread().getName(), sc.getRemoteAddress()); } catch (IOException e) { e.printStackTrace(); } ByteBuffer buffer = ByteBuffer.allocate(16); // 读事件由 ReadHandler 处理 sc.read(buffer, buffer, new ReadHandler(sc)); // 写事件由 WriteHandler 处理 sc.write(Charset.defaultCharset().encode(\\\"server hello!\\\"), ByteBuffer.allocate(16), new WriteHandler(sc)); // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件 ssc.accept(null, this); } @Override public void failed(Throwable exc, Object attachment) { exc.printStackTrace(); } } } \"]},\"910\":{\"h\":\"三大组件\"},\"911\":{\"h\":\"Channel & Buffer\",\"t\":[\"channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\",\"常见的 Channel 有\",\"FileChannel\",\"DatagramChannel\",\"SocketChannel\",\"ServerSocketChannel\",\"buffer 则用来缓冲读写数据，常见的 buffer 有\",\"ByteBuffer \",\"MappedByteBuffer\",\"DirectByteBuffer\",\"HeapByteBuffer\",\"ShortBuffer\",\"IntBuffer\",\"LongBuffer\",\"FloatBuffer\",\"DoubleBuffer\",\"CharBuffer\"]},\"912\":{\"h\":\"Selector\",\"t\":[\"selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\"]},\"913\":{\"h\":\"多线程版设计\"},\"914\":{\"h\":\"多线程版缺点⚠️\",\"t\":[\"内存占用高\",\"线程上下文切换成本高\",\"只适合连接数少的场景\"]},\"915\":{\"h\":\"线程池版设计\"},\"916\":{\"h\":\"线程池版缺点⚠️\",\"t\":[\"阻塞模式下，线程仅能处理一个 socket 连接\",\"仅适合短连接场景\"]},\"917\":{\"h\":\"selector 版设计\",\"t\":[\"selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\",\"调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\"]},\"918\":{\"h\":\"ElasticSearch 应用\"},\"919\":{\"h\":\"TODO\"},\"920\":{\"h\":\"ElasticSearch 基础\"},\"921\":{\"h\":\"1. 基本概念\"},\"922\":{\"h\":\"1.1 索引（Index）\",\"t\":[\"一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。\",\"能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。\"]},\"923\":{\"h\":\"1.2 类型（Type）\",\"t\":[\"在一个索引中，你可以定义一种或多种类型。\",\"一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。\",\"版本\",\"Type\",\"5.x\",\"支持多种Type\",\"6.x\",\"只能有一种Type\",\"7.x\",\"默认不再支持自定义索引类型（默认类型为：_doc）\"]},\"924\":{\"h\":\"1.3 文档（Document）\",\"t\":[\"一个文档是一个可被索引的基础信息单元，也就是一条数据。\",\"比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。\",\"在一个index/type里面，你可以存储任意多的文档。\"]},\"925\":{\"h\":\"1.4 字段（Field）\",\"t\":[\"相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。\"]},\"926\":{\"h\":\"1.5 映射（Mapping）\",\"t\":[\"mapping是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\"]},\"927\":{\"h\":\"1.6 分片（Shards）\",\"t\":[\"一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档数据的索引占据1TB的磁盘空间，而任一节点都可能没有这样大的磁盘空间。或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。\",\"分片很重要，主要有两方面的原因：\",\"允许你水平分割 / 扩展你的内容容量。\",\"允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。\",\"至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。\"]},\"928\":{\"h\":\"1.7 副本（Replicas）\",\"t\":[\"在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。\",\"复制分片之所以重要，有两个主要原因：\",\"在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。\",\"扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。\",\"总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。默认情况下，Elasticsearch中的每个索引被分片1个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有1个主分片和另外1个复制分片（1个完全拷贝），这样的话每个索引总共就有2个分片，我们需要根据索引需要确定分片个数。\"]},\"929\":{\"h\":\"1.8 分配（Allocation）\",\"t\":[\"将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由master节点完成的。\"]},\"930\":{\"h\":\"2. 入门操作\"},\"931\":{\"h\":\"2.1 引入依赖\",\"t\":[\"<dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.elasticsearch</groupId> <artifactId>elasticsearch</artifactId> <version>7.8.0</version> </dependency> <dependency> <groupId>org.elasticsearch.client</groupId> <artifactId>elasticsearch-rest-high-level-client</artifactId> <version>7.8.0</version> </dependency> <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-api</artifactId> <version>2.8.2</version> </dependency> <dependency> <groupId>org.apache.logging.log4j</groupId> <artifactId>log4j-core</artifactId> <version>2.8.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.9</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> \"]},\"932\":{\"h\":\"2.2 客户端对象\",\"t\":[\"因为早期版本的客户端对象已经不再推荐使用，且在未来版本中会被删除，所以这里我们采用高级 REST 客户端对象。\",\"public class ESTestClient { private ESTestClient() { } private static class SingletonHolder { private static final RestHighLevelClient INSTANCE = new RestHighLevelClient( RestClient.builder(new HttpHost(\\\"localhost\\\", 9200, \\\"http\\\")) ); private static void close() { try { INSTANCE.close(); } catch (IOException e) { throw new RuntimeException(e); } } } public static RestHighLevelClient getInstance() { // 创建es客户端 return SingletonHolder.INSTANCE; } public static void close() { SingletonHolder.close(); } } \"]},\"933\":{\"h\":\"2.3 索引操作\",\"t\":[\"2.3.1 创建索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 创建索引 CreateIndexRequest request = new CreateIndexRequest(\\\"user\\\"); CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT); // 响应状态 boolean acknowledged = response.isAcknowledged(); log.info(\\\"索引操作：{}\\\", acknowledged); ESTestClient.close(); \",\"2.3.2 删除索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 删除索引 DeleteIndexRequest request = new DeleteIndexRequest(\\\"user\\\"); AcknowledgedResponse response = client.indices().delete(request, RequestOptions.DEFAULT); // 响应状态 log.info(\\\"索引删除：{}\\\", response.isAcknowledged()); ESTestClient.close(); \",\"2.3.3 查询索引\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 查询索引 GetIndexRequest request = new GetIndexRequest(\\\"user\\\"); GetIndexResponse response = client.indices().get(request, RequestOptions.DEFAULT); // 响应状态 log.info(\\\"索引查询getAliases：{}\\\", response.getAliases()); log.info(\\\"索引查询getMappings：{}\\\", response.getMappings()); log.info(\\\"索引查询getSettings：{}\\\", response.getSettings()); ESTestClient.close(); \"]},\"934\":{\"h\":\"2.4 文档操作\",\"t\":[\"2.4.1 创建数据模型\",\"public class User { private String name; private String sex; private Integer age; } \",\"2.4.2 新增文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 插入数据 IndexRequest request = new IndexRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); // 构建数据 User user = new User(\\\"zhangsan\\\", \\\"男\\\", 30); ObjectMapper mapper = new ObjectMapper(); String userJson = mapper.writeValueAsString(user); request.source(userJson, XContentType.JSON); IndexResponse response = client.index(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.3 修改文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 修改数据 UpdateRequest request = new UpdateRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); request.doc(XContentType.JSON, \\\"sex\\\", \\\"女\\\", \\\"age\\\" , 18); UpdateResponse response = client.update(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.4 查询文档\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 查询数据 GetRequest request = new GetRequest(); request.index(\\\"user\\\").id(\\\"1001\\\"); GetResponse response = client.get(request, RequestOptions.DEFAULT); ESTestClient.close(); \",\"2.4.5 批量新增\",\"RestHighLevelClient client = ESTestClient.getInstance(); // 批量插入数据 BulkRequest request = new BulkRequest(); User user1 = new User(\\\"zhangsan\\\", \\\"男\\\", 30); User user2 = new User(\\\"lisi\\\", \\\"男\\\", 18); User user3 = new User(\\\"wangwu\\\", \\\"女\\\", 20); ObjectMapper mapper = new ObjectMapper(); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1001\\\").source(mapper.writeValueAsString(user1), XContentType.JSON)); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1002\\\").source(mapper.writeValueAsString(user2), XContentType.JSON)); request.add(new IndexRequest().index(\\\"user\\\").id(\\\"1003\\\").source(mapper.writeValueAsString(user3), XContentType.JSON)); request.add(new BulkResponse response = client.bulk(request, RequestOptions.DEFAULT); ESTestClient.close(); \"]},\"935\":{\"h\":\"3. 高级查询\"},\"936\":{\"h\":\"3.1 查询索引中所有的数据\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 1、查询索引中所有的数据 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); request.source(new SearchSourceBuilder().query(QueryBuilders.matchAllQuery())); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"937\":{\"h\":\"3.2 条件查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 2、条件查询 SearchRequest request = new SearchRequest(); request.source(new SearchSourceBuilder().query(QueryBuilders.termQuery(\\\"age\\\", 30))); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"938\":{\"h\":\"3.3 分页查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 3、分页查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); builder.from(0); builder.size(2); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"939\":{\"h\":\"3.4 查询排序\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 4、查询排序 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); builder.sort(\\\"age\\\", SortOrder.ASC); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"940\":{\"h\":\"3.5 查询字段过滤\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 5、查询字段过滤 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder().query(QueryBuilders.matchAllQuery()); String[] include = {\\\"name\\\"}; String[] exclude = {}; builder.fetchSource(include, exclude); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"941\":{\"h\":\"3.6 组合查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 6、组合查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); BoolQueryBuilder query = QueryBuilders.boolQuery(); // query.must(QueryBuilders.matchQuery(\\\"sex\\\", \\\"女\\\")); query.should(QueryBuilders.matchQuery(\\\"age\\\", \\\"45\\\")); SearchSourceBuilder builder = new SearchSourceBuilder().query(query); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"942\":{\"h\":\"3.7 范围查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 7、范围查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(\\\"age\\\"); rangeQuery.gte(30); rangeQuery.lte(50); builder.query(rangeQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"943\":{\"h\":\"3.8 模糊查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 8、模糊查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); FuzzyQueryBuilder fuzzyQuery = QueryBuilders.fuzzyQuery(\\\"name\\\", \\\"wangwu\\\"); // 一个字符不同也能匹配成功 fuzzyQuery.fuzziness(Fuzziness.ONE); builder.query(fuzzyQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"944\":{\"h\":\"3.9 高亮查询\",\"t\":[\" RestHighLevelClient client = ESTestClient.getInstance(); // 9、高亮查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); TermsQueryBuilder termsQuery = QueryBuilders.termsQuery(\\\"name\\\", \\\"wangwu\\\"); HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.preTags(\\\"<font color='red'>\\\"); highlightBuilder.postTags(\\\"</font>\\\"); highlightBuilder.field(\\\"name\\\"); builder.highlighter(highlightBuilder); builder.query(termsQuery); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"945\":{\"h\":\"3.10 聚合查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 10、聚合查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); AggregationBuilder aggregationBuilder = AggregationBuilders.max(\\\"maxAge\\\").field(\\\"age\\\"); builder.aggregation(aggregationBuilder); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"946\":{\"h\":\"3.11 分组查询\",\"t\":[\"RestHighLevelClient client = ESTestClient.getInstance(); // 11、分组查询 SearchRequest request = new SearchRequest(); request.indices(\\\"user\\\"); SearchSourceBuilder builder = new SearchSourceBuilder(); AggregationBuilder aggregationBuilder = AggregationBuilders.terms(\\\"ageGroup\\\").field(\\\"age\\\"); builder.aggregation(aggregationBuilder); request.source(builder); SearchResponse response = client.search(request, RequestOptions.DEFAULT); SearchHits hits = response.getHits(); hits.forEach(hit -> { System.out.println(hit.getSourceAsString()); }); ESTestClient.close(); \"]},\"947\":{\"h\":\"4. 框架集成\"},\"948\":{\"h\":\"4.1 引入依赖\",\"t\":[\"<dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-elasticsearch</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-test</artifactId> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> </dependency> </dependencies> \"]},\"949\":{\"h\":\"4.2 配置类编写\",\"t\":[\"elasticsearch: host: localhost port: 9200 logging: level: com.vingkin.esspringboot: debug \",\"@ConfigurationProperties(prefix = \\\"elasticsearch\\\") @Configuration @Data public class ElasticsearchConfig extends AbstractElasticsearchConfiguration { private String host; private Integer port; @Override public RestHighLevelClient elasticsearchClient() { RestClientBuilder builder = RestClient.builder(new HttpHost(host, port)); return new RestHighLevelClient(builder); } } \"]},\"950\":{\"h\":\"4.3 实现\",\"t\":[\"@Data @NoArgsConstructor @AllArgsConstructor @ToString @Document(indexName = \\\"product\\\") public class Product { @Id private Long id; @Field(type = FieldType.Text) private String title; // keyword表示关键字不分开（不分词） @Field(type = FieldType.Keyword) private String category; @Field(type = FieldType.Double) private Double price; // index=false表示不做索引关联（不能用images来查询） @Field(type = FieldType.Keyword, index=false) private String images; } \",\"@Repository public interface ProductDao extends ElasticsearchRepository<Product, Long> { } \",\"@SpringBootTest @Slf4j class EsSpringbootApplicationTests { @Autowired private ElasticsearchRestTemplate elasticsearchRestTemplate; @Autowired private ProductDao productDao; // 创建索引 @Test public void createIndex() { // 系统会扫描@Document(indexName = \\\"product\\\")后自动创建索引 log.info(\\\"创建索引\\\"); } // 删除索引 @Test public void deleteIndex() { boolean b = elasticsearchRestTemplate.deleteIndex(Product.class); } // 新增文档 @Test public void docSave() { Product product = new Product(3L, \\\"华为手机\\\", \\\"手机\\\", 3999.0, \\\"http://www.images.com/valsdkf/1.jpg\\\"); productDao.save(product); } // 修改文档（和新增一致） @Test public void updateSave() { Product product = new Product(5L, \\\"ipad2018\\\", \\\"平板\\\", 4999.0, \\\"http://www.images.com/valsdkf/1.jpg\\\"); productDao.save(product); } // 文档根据id查询 @Test public void findById() { Product product = productDao.findById(2L).get(); log.info(\\\"查询结果：{}\\\", product); } // 文档查询所有 @Test public void findAll() { Iterable<Product> all = productDao.findAll(); all.forEach(System.out::println); } // 文档文档删除 @Test public void docDelete() { productDao.deleteById(2L); } // 文档批量新增 @Test public void saveAll() { List<Product> productList = new ArrayList<>(); // 省略创建productList过程 productDao.saveAll(productList); } // 文档分页查询 @Test public void findByPageable() { Sort sort = Sort.by(Sort.Direction.DESC, \\\"id\\\"); int currentPage = 0; int pageSize = 3; // 设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize, sort); // 分页查询 Page<Product> productPage = productDao.findAll(pageRequest); productPage.forEach(System.out::println); } // 条件查询+分页 @Test public void termQueryByPage() { int currentPage = 0; int pageSize = 3; // 设置查询分页 PageRequest pageRequest = PageRequest.of(currentPage, pageSize); // 设置查询条件 TermQueryBuilder termQuery = QueryBuilders.termQuery(\\\"category\\\", \\\"手机\\\"); Page<Product> products = productDao.search(termQuery, pageRequest); products.forEach(System.out::println); } } \"]},\"951\":{\"h\":\"Redis 实战\",\"t\":[\"目录\"]},\"952\":{\"h\":\"1、短信登录\"},\"953\":{\"h\":\"1.1、导入黑马点评项目\"},\"954\":{\"h\":\"1.1.1 、导入SQL\",\"t\":[\"1653057872536\"]},\"955\":{\"h\":\"1.1.2、有关当前模型\",\"t\":[\"手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。\",\"在tomcat支撑起并发流量后，我们如果让tomcat直接去访问Mysql，根据经验Mysql企业级服务器只要上点并发，一般是16或32 核心cpu，32 或64G内存，像企业级mysql加上固态硬盘能够支撑的并发，大概就是4000起~7000左右，上万并发， 瞬间就会让Mysql服务器的cpu，硬盘全部打满，容易崩溃，所以我们在高并发场景下，会选择使用mysql集群，同时为了进一步降低Mysql的压力，同时增加访问的性能，我们也会加入Redis，同时使用Redis集群使得Redis对外提供更好的服务。\",\"1653059409865\"]},\"956\":{\"h\":\"1.1.3、导入后端项目\",\"t\":[\"在资料中提供了一个项目源码：\",\"1653060237073\"]},\"957\":{\"h\":\"1.1.4、导入前端工程\",\"t\":[\"1653060337562\"]},\"958\":{\"h\":\"1.1.5 运行前端项目\",\"t\":[\"1653060588190\"]},\"959\":{\"h\":\"1.2 、基于Session实现登录流程\",\"t\":[\"发送验证码：\",\"用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号\",\"如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户\",\"短信验证码登录、注册：\",\"用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息\",\"校验登录状态:\",\"用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行\",\"1653066208144\"]},\"960\":{\"h\":\"1.3 、实现发送短信验证码功能\",\"t\":[\"页面流程\",\"1653067054461\",\"具体代码如下\",\"贴心小提示：\",\"具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。\",\"发送验证码\",\"@Override public Result sendCode(String phone, HttpSession session) { // 1.校验手机号 if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.符合，生成验证码 String code = RandomUtil.randomNumbers(6); // 4.保存验证码到 session session.setAttribute(\\\"code\\\",code); // 5.发送验证码 log.debug(\\\"发送短信验证码成功，验证码：{}\\\", code); // 返回ok return Result.ok(); } \",\"登录\",\"@Override public Result login(LoginFormDTO loginForm, HttpSession session) { // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.校验验证码 Object cacheCode = session.getAttribute(\\\"code\\\"); String code = loginForm.getCode(); if(cacheCode == null || !cacheCode.toString().equals(code)){ //3.不一致，报错 return Result.fail(\\\"验证码错误\\\"); } //一致，根据手机号查询用户 User user = query().eq(\\\"phone\\\", phone).one(); //5.判断用户是否存在 if(user == null){ //不存在，则创建 user = createUserWithPhone(phone); } //7.保存用户信息到session中 session.setAttribute(\\\"user\\\",user); return Result.ok(); } \"]},\"961\":{\"h\":\"1.4、实现登录拦截功能\",\"t\":[\"温馨小贴士：tomcat的运行原理\",\"1653068196656\",\"当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应\",\"通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据\",\"温馨小贴士：关于threadlocal\",\"如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离\",\"1653068874258\",\"拦截器代码\",\"public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1.获取session HttpSession session = request.getSession(); //2.获取session中的用户 Object user = session.getAttribute(\\\"user\\\"); //3.判断用户是否存在 if(user == null){ //4.不存在，拦截，返回401状态码 response.setStatus(401); return false; } //5.存在，保存用户信息到Threadlocal UserHolder.saveUser((User)user); //6.放行 return true; } } \",\"让拦截器生效\",\"@Configuration public class MvcConfig implements WebMvcConfigurer { @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) { // 登录拦截器 registry.addInterceptor(new LoginInterceptor()) .excludePathPatterns( \\\"/shop/**\\\", \\\"/voucher/**\\\", \\\"/shop-type/**\\\", \\\"/upload/**\\\", \\\"/blog/hot\\\", \\\"/user/code\\\", \\\"/user/login\\\" ).order(1); // token刷新的拦截器 registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(\\\"/**\\\").order(0); } } \"]},\"962\":{\"h\":\"1.5、隐藏用户敏感信息\",\"t\":[\"我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了\",\"在登录方法处修改\",\"//7.保存用户信息到session中 session.setAttribute(\\\"user\\\", BeanUtils.copyProperties(user,UserDTO.class)); \",\"在拦截器处：\",\"//5.存在，保存用户信息到Threadlocal UserHolder.saveUser((UserDTO) user); \",\"在UserHolder处：将user对象换成UserDTO\",\"public class UserHolder { private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>(); public static void saveUser(UserDTO user){ tl.set(user); } public static UserDTO getUser(){ return tl.get(); } public static void removeUser(){ tl.remove(); } } \"]},\"963\":{\"h\":\"1.6、session共享问题\",\"t\":[\"核心思路分析：\",\"每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了\",\"但是这种方案具有两个大问题\",\"1、每台服务器中都有完整的一份session数据，服务器压力过大。\",\"2、session拷贝数据时，可能会出现延迟\",\"所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了\",\"1653069893050\"]},\"964\":{\"h\":\"1.7、Redis代替session的业务流程\"},\"965\":{\"h\":\"1.7.1、设计key的结构\",\"t\":[\"首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。\",\"1653319261433\"]},\"966\":{\"h\":\"1.7.2、设计key的具体细节\",\"t\":[\"所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了\",\"在设计这个key的时候，我们之前讲过需要满足两点\",\"1、key要具有唯一性\",\"2、key要方便携带\",\"如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了\"]},\"967\":{\"h\":\"1.7.3、整体访问流程\",\"t\":[\"当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。\",\"1653319474181\"]},\"968\":{\"h\":\"1.8、基于Redis实现短信登录\",\"t\":[\"这里具体逻辑就不分析了，之前咱们已经重点分析过这个逻辑啦。\",\"UserServiceImpl代码\",\"@Override public Result login(LoginFormDTO loginForm, HttpSession session) { // 1.校验手机号 String phone = loginForm.getPhone(); if (RegexUtils.isPhoneInvalid(phone)) { // 2.如果不符合，返回错误信息 return Result.fail(\\\"手机号格式错误！\\\"); } // 3.从redis获取验证码并校验 String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone); String code = loginForm.getCode(); if (cacheCode == null || !cacheCode.equals(code)) { // 不一致，报错 return Result.fail(\\\"验证码错误\\\"); } // 4.一致，根据手机号查询用户 select * from tb_user where phone = ? User user = query().eq(\\\"phone\\\", phone).one(); // 5.判断用户是否存在 if (user == null) { // 6.不存在，创建新用户并保存 user = createUserWithPhone(phone); } // 7.保存用户信息到 redis中 // 7.1.随机生成token，作为登录令牌 String token = UUID.randomUUID().toString(true); // 7.2.将User对象转为HashMap存储 UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(), CopyOptions.create() .setIgnoreNullValue(true) .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString())); // 7.3.存储 String tokenKey = LOGIN_USER_KEY + token; stringRedisTemplate.opsForHash().putAll(tokenKey, userMap); // 7.4.设置token有效期 stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES); // 8.返回token return Result.ok(token); } \"]},\"969\":{\"h\":\"1.9、解决状态登录刷新问题\"},\"970\":{\"h\":\"1.9.1、初始方案思路总结：\",\"t\":[\"在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的\",\"1653320822964\"]},\"971\":{\"h\":\"1.9.2、优化方案\",\"t\":[\"既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。\",\"1653320764547\"]},\"972\":{\"h\":\"1.9.3、代码\",\"t\":[\"RefreshTokenInterceptor\",\"public class RefreshTokenInterceptor implements HandlerInterceptor { private StringRedisTemplate stringRedisTemplate; public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1.获取请求头中的token String token = request.getHeader(\\\"authorization\\\"); if (StrUtil.isBlank(token)) { return true; } // 2.基于TOKEN获取redis中的用户 String key = LOGIN_USER_KEY + token; Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key); // 3.判断用户是否存在 if (userMap.isEmpty()) { return true; } // 5.将查询到的hash数据转为UserDTO UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false); // 6.存在，保存用户信息到 ThreadLocal UserHolder.saveUser(userDTO); // 7.刷新token有效期 stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES); // 8.放行 return true; } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // 移除用户 UserHolder.removeUser(); } } \",\"LoginInterceptor\",\"public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 1.判断是否需要拦截（ThreadLocal中是否有用户） if (UserHolder.getUser() == null) { // 没有，需要拦截，设置状态码 response.setStatus(401); // 拦截 return false; } // 有用户，则放行 return true; } } \"]},\"973\":{\"h\":\"2、商户查询缓存\"},\"974\":{\"h\":\"2.1、什么是缓存?\",\"t\":[\"前言:什么是缓存?\",\"就像自行车,越野车的避震器\",\"举个例子:越野车,山地自行车,都拥有\\\"避震器\\\",防止车体加速后因惯性,在酷似\\\"U\\\"字母的地形上飞跃,硬着陆导致的损害,像个弹簧一样;\",\"同样,实际开发中,系统也需要\\\"避震器\\\",防止过高的数据访问猛冲系统,导致其操作线程无法及时处理信息而瘫痪;\",\"这在实际开发中对企业讲,对产品口碑,用户评价都是致命的;所以企业非常重视缓存技术;\",\"缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码(例如:\",\"例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发 例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存 例3:Static final Map<K,V> map = new HashMap(); 本地缓存 \",\"由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;\"]},\"975\":{\"h\":\"2.1.1、为什么要使用缓存\",\"t\":[\"一句话:因为速度快,好用\",\"缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低用户访问并发量带来的服务器读写压力\",\"实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为\\\"避震器\\\",系统是几乎撑不住的,所以企业会大量运用到缓存技术;\",\"但是缓存也会增加代码复杂度和运营的成本:\"]},\"976\":{\"h\":\"2.1.2、如何使用缓存\",\"t\":[\"实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用\",\"浏览器缓存：主要是存在于浏览器端的缓存\",\"**应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存\",\"**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中\",\"**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\"]},\"977\":{\"h\":\"2.2、添加商户缓存\",\"t\":[\"在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存\",\"@GetMapping(\\\"/{id}\\\") public Result queryShopById(@PathVariable(\\\"id\\\") Long id) { //这里是直接查询数据库 return shopService.queryById(id); } \"]},\"978\":{\"h\":\"2.2.1、缓存模型和思路\",\"t\":[\"标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。\",\"1653322097736\"]},\"979\":{\"h\":\"2.1.2、代码如下\",\"t\":[\"代码思路：如果缓存有，则直接返回，如果缓存不存在，则查询数据库，然后存入redis。\",\"1653322190155\"]},\"980\":{\"h\":\"2.3、缓存更新策略\",\"t\":[\"缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。\",\"**内存淘汰：**redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\",\"**超时剔除：**当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存\",\"**主动更新：**我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\",\"1653322506393\"]},\"981\":{\"h\":\"2.3.1、数据库缓存不一致解决方案：\",\"t\":[\"由于我们的缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:\",\"用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案\",\"Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\",\"Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理\",\"Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致\",\"1653322857620\"]},\"982\":{\"h\":\"2.3.2、数据库和缓存不一致采用什么方案\",\"t\":[\"综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题\",\"操作缓存和数据库时有三个问题需要考虑：\",\"如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来\",\"删除缓存还是更新缓存？\",\"更新缓存：每次更新数据库都更新缓存，无效写操作较多\",\"删除缓存：更新数据库时让缓存失效，查询时再更新缓存\",\"如何保证缓存与数据库的操作的同时成功或失败？\",\"单体系统，将缓存与数据库操作放在一个事务\",\"分布式系统，利用TCC等分布式事务方案\",\"应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。\",\"先操作缓存还是先操作数据库？ \",\"先删除缓存，再操作数据库\",\"先操作数据库，再删除缓存\",\"1653323595206\"]},\"983\":{\"h\":\"2.4、实现商铺和缓存与数据库双写一致\",\"t\":[\"核心思路如下：\",\"修改ShopController中的业务逻辑，满足下面的需求：\",\"根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间\",\"根据id修改店铺时，先修改数据库，再删除缓存\",\"修改重点代码1：修改ShopServiceImpl的queryById方法\",\"设置redis缓存时添加过期时间\",\"@Override public Result getByIdWithRedis(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); // 2、判断是否存在 if (StrUtil.isNotBlank(shopMap)) { // 3、不为null且存在，直接返回 Shop shop = JSONUtil.toBean(shopJson, Shop.class); return Result.ok(shop); } // 4、不存在，根据id查询数据库 Shop shop = this.getById(id); if (ObjectUtil.isEmpty(shop)) { // 4.1、数据库不存在返回错误 return Result.fail(\\\"店铺不存在！\\\"); } // 4.2、数据库存在，写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, BeanUtil.beanToMap(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); // 5、返回 return Result.ok(shop); } \",\"修改重点代码2\",\"代码分析：通过之前的淘汰，我们确定了采用删除策略，来解决双写问题，当我们修改了数据之后，然后把缓存中的数据进行删除，查询时发现缓存中没有数据，则会从mysql中加载最新的数据，从而避免数据库和缓存不一致的问题\",\"@Override @Transactional public Result update(Shop shop) { Long id = shop.getId(); if (id == null) { return Result.fail(\\\"店铺id不能为空！\\\"); } // 1、更新数据库 this.updateById(shop); // 2、删除缓存 redisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id); return Result.ok(); } \"]},\"984\":{\"h\":\"2.5、缓存穿透问题的解决思路\",\"t\":[\"缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。\",\"常见的解决方案有两种：\",\"缓存空对象 \",\"优点：实现简单，维护方便\",\"缺点： \",\"额外的内存消耗\",\"可能造成短期的不一致\",\"布隆过滤 \",\"优点：内存占用较少，没有多余key\",\"缺点： \",\"实现复杂\",\"存在误判可能\",\"缓存空对象思路分析： 当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了\",\"布隆过滤： 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，\",\"假设布隆过滤器判断这个数据不存在，则直接返回\",\"这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突\",\"1653326156516\"]},\"985\":{\"h\":\"2.6、编码解决商品查询的缓存穿透问题：\",\"t\":[\"核心思路如下：\",\"在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的\",\"现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。\",\"1653327124561\",\"private Shop queryWithPassThrough(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3、不为null且存在，直接返回 shop = JSONUtil.toBean(shopJson, Shop.class); return shop; } // 判断是否是key为\\\"\\\"的缓存（缓存穿透） if (shopJson != null) { return null; } // 4、不存在，根据id查询数据库 shop = this.getById(id); if (ObjectUtil.isEmpty(shop)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 4.1、数据库不存在返回错误 return null; } // 4.2、数据库存在，写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return shop; } \",\"小总结：\",\"缓存穿透产生的原因是什么？\",\"用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力\",\"缓存穿透的解决方案有哪些？\",\"缓存null值\",\"布隆过滤\",\"增强id的复杂度，避免被猜测id规律\",\"做好数据的基础格式校验\",\"加强用户权限校验\",\"做好热点参数的限流\"]},\"986\":{\"h\":\"2.7、缓存雪崩问题及解决思路\",\"t\":[\"缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\",\"解决方案：\",\"给不同的Key的TTL添加随机值\",\"利用Redis集群提高服务的可用性\",\"给缓存业务添加降级限流策略\",\"给业务添加多级缓存\",\"1653327884526\"]},\"987\":{\"h\":\"2.8、缓存击穿问题及解决思路\",\"t\":[\"缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。\",\"常见的解决方案有两种：\",\"互斥锁\",\"逻辑过期\",\"逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大\",\"1653328022622\",\"解决方案一、使用锁来解决：\",\"因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。\",\"假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\",\"1653328288627\",\"解决方案二、逻辑过期方案\",\"方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。\",\"我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\",\"这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\",\"1653328663897\",\"进行对比\",\"互斥锁方案： 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响\",\"逻辑过期方案： 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦\",\"1653357522914\"]},\"988\":{\"h\":\"2.9、利用互斥锁解决缓存击穿问题\",\"t\":[\"核心思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是 进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取，获取互斥锁后，判断是否获得到了锁，如果没有获得到，则休眠，过一会再进行尝试，直到获取到锁为止，才能进行查询\",\"如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿\",\"1653357860001\",\"操作锁的代码：\",\"核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true， 如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。\",\"private boolean tryLock(String key) { Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, \\\"1\\\", 10, TimeUnit.SECONDS); // 防止装包以及拆包引发bug return BooleanUtil.isTrue(flag); } private void unlock(String key) { redisTemplate.delete(key); } \",\"操作代码：\",\"private Shop queryWithMutex(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3、不为null且存在，直接返回 shop = JSONUtil.toBean(shopJson, Shop.class); return shop; } // 判断是否是\\\"\\\"的缓存（缓存穿透） if (shopJson != null) { return null; } try { // 4、互斥锁实现缓存重建 // 4.1、获取互斥锁 boolean hasLock = tryLock(RedisConstants.LOCK_SHOP_KEY + id, RedisConstants.LOCK_SHOP_TTL); // 4.2、判断是否获取成功 if (!hasLock) { // 4.3、如果失败，则失眠并重试 Thread.sleep(50); return queryWithMutex(id); } // 4.4、成功，根据id查询数据库 shop = this.getById(id); // 模拟缓存重建延迟 Thread.sleep(200); if (ObjectUtil.isEmpty(shop)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 数据库不存在返回错误 return null; } redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); // 数据库存在，写入redis } catch (InterruptedException e) { throw new RuntimeException(e); } finally { // 释放互斥锁 unlock(RedisConstants.LOCK_SHOP_KEY + id); } return shop; } \"]},\"989\":{\"h\":\"2.10、利用逻辑过期解决缓存击穿问题\",\"t\":[\"需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题\",\"思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。\",\"1653360308731\",\"如果封装数据：因为现在redis中存储的数据的value需要带上过期时间，此时要么你去修改原来的实体类，要么你\",\"步骤一、\",\"新建一个实体类，我们采用第二个方案，这个方案，对原来代码没有侵入性。\",\"@Data public class RedisData<T> { /** * 逻辑过期时间 */ private LocalDateTime expireTime; private T data; } \",\"步骤二、\",\"在ShopServiceImpl 新增此方法，利用单元测试进行缓存预热\",\"public void saveShop2Redis(Long id, Long expireSeconds) { // 1、查询店铺数据 Shop shop = this.getById(id); // 2、封装逻辑过期时间 RedisData<Shop> redisData = new RedisData<>(); redisData.setData(shop); redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds)); // 3、写入redis redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData)); } \",\"在测试类中\",\"@Test public void testSaveShop() { shopService.saveShop2Redis(1L, 10L); } \",\"步骤三：正式代码\",\"ShopServiceImpl\",\"private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); private Shop queryWithLogicalExpire(Long id) { // 1、从redis查询商铺缓存 String shopJson = redisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); Shop shop = null; // 2、判断缓存中是否存在 if (StrUtil.isBlank(shopJson)) { // 3、不存在，直接返回null return null; } // 4、命中，判断缓存是否过期（需要将json反序列化成对象） RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class); shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class); LocalDateTime expireTime = redisData.getExpireTime(); // 5、判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 5.1、未过期，返回shop信息 return shop; } // 5.2、已过期，需要缓存重建 // 6、缓存重建 // 6.1、获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey, RedisConstants.LOCK_SHOP_TTL); // 6.2、判断锁是否获取成功 if (isLock) { // 6.3、成功，开启独立线程，开启缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -> { try { // 重建缓存 this.saveShop2Redis(id, 20L); } catch (Exception e) { throw new RuntimeException(e); } finally { // 释放锁 unlock(lockKey); } }); } // 6.4、返回过期的商铺信息 return shop; } \"]},\"990\":{\"h\":\"2.11、封装Redis工具类\",\"t\":[\"基于StringRedisTemplate封装一个缓存工具类，满足下列需求：\",\"方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间\",\"方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓\",\"存击穿问题\",\"方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题\",\"方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题\",\"将逻辑进行封装\",\"@Slf4j @Component public class CacheClient { private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10); private final StringRedisTemplate redisTemplate; public CacheClient(StringRedisTemplate redisTemplate) { this.redisTemplate = redisTemplate; } /** * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间 * * @param key 存储的key * @param value 存储的value * @param expireTime 过期时间 * @param timeUnit 过期时间单位 */ public <T> void set(String key, T value, Long expireTime, TimeUnit timeUnit) { redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), expireTime, timeUnit); } /** * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题 * * @param key 存储的key * @param value 存储的data * @param expireTime 逻辑过期时间 * @param timeUnit 逻辑过期时间单位 */ public <T> void setWithLogicExpire(String key, T value, Long expireTime, TimeUnit timeUnit) { RedisData<T> redisData = new RedisData<>(); redisData.setData(value); redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(expireTime))); redisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData)); } /** * 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题 * * @param keyPrefix key前缀 * @param id id * @param expireTime 过期时间 * @param timeUnit 过期时间单位 * @param type 返回值class类型 * @param dbFallback 用于数据库操作的回调函数 * @param <R> 返回值数据类型 * @param <ID> id数据类型 * @return R */ public <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Long expireTime, TimeUnit timeUnit, Class<R> type, Function<ID, R> dbFallback) { // 1、从redis查询商铺缓存 String key = keyPrefix + id; String json = redisTemplate.opsForValue().get(key); // 2、判断缓存中是否存在 if (StrUtil.isNotBlank(json)) { // 3、不为null且存在，直接返回 return JSONUtil.toBean(json, type); } // 判断是否是key为\\\"\\\"的缓存（缓存穿透） if (json != null) { return null; } // 4、不存在，根据id查询数据库（通过定义回调函数，交给调用者自己处理） R r = dbFallback.apply(id); if (ObjectUtil.isEmpty(r)) { // 将空值写入redis（解决缓存穿透问题） redisTemplate.opsForValue().set(key, \\\"\\\", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES); // 4.1、数据库不存在返回错误 return null; } // 4.2、数据库存在，写入redis this.set(key, r, expireTime, timeUnit); return r; } /** * 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题将逻辑进行封装 * * @param keyPrefix key前缀 * @param id id * @param time 逻辑过期时间 * @param timeUnit 逻辑过期时间单位 * @param type 返回值数据class类型 * @param dbRollback 操作数据库的回调函数 * @param <R> 返回值数据类型 * @param <ID> id数据类型 * @return r */ public <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Long time, TimeUnit timeUnit, Class<R> type, Function<ID, R> dbRollback) { // 1、从redis查询商铺缓存 String key = keyPrefix + id; String json = redisTemplate.opsForValue().get(key); // 2、判断缓存中是否存在 if (StrUtil.isBlank(json)) { // 3、不存在，直接返回null return null; } // 4、命中，判断缓存是否过期（需要将json反序列化成对象） RedisData redisData = JSONUtil.toBean(json, RedisData.class); R r = JSONUtil.toBean(JSONUtil.toJsonStr(redisData.getData()), type); LocalDateTime expireTime = redisData.getExpireTime(); // 5、判断是否过期 if (expireTime.isAfter(LocalDateTime.now())) { // 5.1、未过期，返回shop信息 return r; } // 5.2、已过期，需要缓存重建 // 6、缓存重建 // 6.1、获取互斥锁 String lockKey = RedisConstants.LOCK_SHOP_KEY + id; boolean isLock = tryLock(lockKey); // 6.2、判断锁是否获取成功 if (isLock) { // 6.3、成功，开启独立线程，开启缓存重建 CACHE_REBUILD_EXECUTOR.submit(() -> { try { // 重建缓存 // 查数据库 R newR = dbRollback.apply(id); // 写入redis this.setWithLogicExpire(key, newR, time, timeUnit); } catch (Exception e) { throw new RuntimeException(e); } finally { // 释放锁 unlock(lockKey); } }); } // 6.4、返回过期的商铺信息 return r; } public <R, ID> R queryWithMutex( String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) { String key = keyPrefix + id; // 1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.opsForValue().get(key); // 2.判断是否存在 if (StrUtil.isNotBlank(shopJson)) { // 3.存在，直接返回 return JSONUtil.toBean(shopJson, type); } // 判断命中的是否是空值 if (shopJson != null) { // 返回一个错误信息 return null; } // 4.实现缓存重建 // 4.1.获取互斥锁 String lockKey = LOCK_SHOP_KEY + id; R r = null; try { boolean isLock = tryLock(lockKey); // 4.2.判断是否获取成功 if (!isLock) { // 4.3.获取锁失败，休眠并重试 Thread.sleep(50); return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit); } // 4.4.获取锁成功，根据id查询数据库 r = dbFallback.apply(id); // 5.不存在，返回错误 if (r == null) { // 将空值写入redis stringRedisTemplate.opsForValue().set(key, \\\"\\\", CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; } // 6.存在，写入redis this.set(key, r, time, unit); } catch (InterruptedException e) { throw new RuntimeException(e); }finally { // 7.释放锁 unlock(lockKey); } // 8.返回 return r; } private boolean tryLock(String key) { Boolean flag = redisTemplate.opsForValue().setIfAbsent(key, \\\"1\\\", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } private void unlock(String key) { redisTemplate.delete(key); } } \",\"在ShopServiceImpl 中\",\"@Override public Result getByIdWithRedis(Long id) { // 缓存穿透 // Shop shop = queryWithPassThrough(id); // Shop shop = cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, // RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES, // Shop.class, this::getById); // 缓存击穿 // Shop shop = queryWithMutex(id); // cacheClient. // 逻辑过期 Shop shop = cacheClient.queryWithLogicalExpire(RedisConstants.CACHE_SHOP_KEY, id, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES, Shop.class, this::getById); // Shop shop = queryWithLogicalExpire(id); if (shop == null) { return Result.fail(\\\"店铺不存在！\\\"); } return Result.ok(shop); } \"]},\"991\":{\"h\":\"3、优惠卷秒杀\"},\"992\":{\"h\":\"3.1、全局唯一ID\",\"t\":[\"每个店铺都可以发布优惠券：\",\"1653362612286\",\"当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：\",\"id的规律性太明显\",\"受单表数据量的限制\",\"场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。\",\"场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。\",\"全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：\",\"1653363100502\",\"为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：\",\"image-20230920153903868\",\"ID的组成部分：符号位：1bit，永远为0\",\"时间戳：31bit，以秒为单位，可以使用69年\",\"序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID\"]},\"993\":{\"h\":\"3.2、Redis实现全局唯一Id\",\"t\":[\"@Component public class RedisIdWorker { /** * 开始时间戳 2022-1-1 00:00:00 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } // 通过不同的前缀来区分不同业务的id public long nextId(String keyPrefix) { // 1.生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; // 2.生成序列号 // 2.1.获取当前日期，精确到天（每天使用一个key） String date = now.format(DateTimeFormatter.ofPattern(\\\"yyyy:MM:dd\\\")); // 2.2.自增长 long count = stringRedisTemplate.opsForValue().increment(\\\"icr:\\\" + keyPrefix + \\\":\\\" + date); // 3.拼接并返回 return timestamp << COUNT_BITS | count; } } \",\"测试类\",\"知识小贴士：关于countdownlatch\",\"countdownlatch名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题\",\"我们如果没有CountDownLatch ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch\",\"CountDownLatch 中有两个最重要的方法\",\"1、countDown\",\"2、await\",\"await 方法 是阻塞方法，我们担心分线程没有执行完时，main线程就先执行，所以使用await可以让main线程阻塞，那么什么时候main线程不再阻塞呢？当CountDownLatch 内部维护的 变量变为0时，就不再阻塞，直接放行，那么什么时候CountDownLatch 维护的变量变为0 呢，我们只需要调用一次countDown ，内部变量就减少1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，CountDownLatch 维护的变量就是0，此时await就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。\",\"@Test void testIdWorker() throws InterruptedException { CountDownLatch latch = new CountDownLatch(300); Runnable task = () -> { for (int i = 0; i < 100; i++) { long id = redisIdWorker.nextId(\\\"order\\\"); System.out.println(\\\"id = \\\" + id); } latch.countDown(); }; long begin = System.currentTimeMillis(); for (int i = 0; i < 300; i++) { es.submit(task); } latch.await(); long end = System.currentTimeMillis(); System.out.println(\\\"time = \\\" + (end - begin)); } \"]},\"994\":{\"h\":\"3.3、添加优惠卷\",\"t\":[\"每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：\",\"1653365145124\",\"tb_voucher：优惠券的基本信息，优惠金额、使用规则等 tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息\",\"平价卷由于优惠力度并不是很大，所以是可以任意领取\",\"而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段\",\"**新增普通卷代码： **VoucherController\",\"@PostMapping public Result addVoucher(@RequestBody Voucher voucher) { voucherService.save(voucher); return Result.ok(voucher.getId()); } \",\"新增秒杀卷代码：\",\"VoucherController\",\"@PostMapping(\\\"seckill\\\") public Result addSeckillVoucher(@RequestBody Voucher voucher) { voucherService.addSeckillVoucher(voucher); return Result.ok(voucher.getId()); } \",\"VoucherServiceImpl\",\"@Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); // 保存秒杀库存到Redis中 stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString()); } \"]},\"995\":{\"h\":\"3.4、实现秒杀下单\",\"t\":[\"下单核心思路：当我们点击抢购时，会触发右侧的请求，我们只需要编写对应的controller即可\",\"1653365839526\",\"秒杀下单应该思考的内容：\",\"下单时需要判断两点：\",\"秒杀是否开始或结束，如果尚未开始或已经结束则无法下单\",\"库存是否充足，不足则无法下单\",\"下单核心逻辑分析：\",\"当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件\",\"比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。\",\"1653366238564\",\"VoucherOrderServiceImpl\",\"@Override public Result seckillVoucher(Long voucherId) { // 1、查询优惠券 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); // 2、判断秒杀是否开始 if (LocalDateTime.now().isBefore(seckillVoucher.getBeginTime())) { return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3、判断秒杀是否已经结束 if (LocalDateTime.now().isAfter(seckillVoucher.getEndTime())) { return Result.fail(\\\"秒杀已经结束！\\\"); } // 4、判断库存是否充足 if (seckillVoucher.getStock() <= 0) { return Result.fail(\\\"库存不足！\\\"); } // 5、扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") .eq(\\\"voucher_id\\\", voucherId) .update(); if (!success) { return Result.fail(\\\"库存不足！\\\"); } // 6、创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 6.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 6.2.用户id Long userId = UserHolder.getUser().getId(); voucherOrder.setUserId(userId); // 6.3.代金券id voucherOrder.setVoucherId(voucherId); this.save(voucherOrder); return Result.ok(orderId); } \"]},\"996\":{\"h\":\"3.5、库存超卖问题分析\",\"t\":[\"有关超卖问题分析：在我们原有代码中是这么写的\",\" if (voucher.getStock() < 1) { // 库存不足 return Result.fail(\\\"库存不足！\\\"); } //5，扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update(); if (!success) { //扣减库存 return Result.fail(\\\"库存不足！\\\"); } \",\"假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。\",\"1653368335155\",\"超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：而对于加锁，我们通常有两种解决方案：见下图：\",\"1653368562591\",\"悲观锁：\",\"悲观锁可以实现对于数据的串行化执行，比如syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等\",\"乐观锁：\",\"乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas\",\"乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值\",\"其中do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。\",\"int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; \",\"课程中的使用方式：\",\"课程中的使用方式是没有像cas一样带自旋的操作，也没有对version的版本号+1 ，他的操作逻辑是在操作时，对版本号进行+1 操作，然后要求version 如果是1 的情况下，才能操作，那么第一个线程在操作后，数据库中的version变成了2，但是他自己满足version=1 ，所以没有问题，此时线程2执行，线程2 最后也需要加上条件version =1 ，但是现在由于线程1已经操作过了，所以线程2，操作时就不满足version=1 的条件了，所以线程2无法执行成功\",\"1653369268550\"]},\"997\":{\"h\":\"3.6、乐观锁解决超卖问题\",\"t\":[\"修改代码方案一、\",\"VoucherOrderServiceImpl 在扣减库存时，改为：\",\"boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") //set stock = stock -1 .eq(\\\"voucher_id\\\", voucherId).eq(\\\"stock\\\",voucher.getStock()).update(); //where id = ？ and stock = ? \",\"以上逻辑的核心含义是：只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败\",\"修改代码方案二、\",\"之前的方式要修改前后都保持一致，但是这样我们分析过，成功的概率太低，所以我们的乐观锁需要变一下，改成stock大于0 即可\",\"boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update().gt(\\\"stock\\\",0); //where id = ? and stock > 0 \",\"知识小扩展：\",\"针对cas中的自旋压力过大，我们可以使用Longaddr这个类去解决\",\"Java8 提供的一个对AtomicLong改进后的一个类，LongAdder\",\"大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用syn来的好\",\"所以利用这么一个类，LongAdder来进行优化\",\"如果获取某个值，则会对cell和base的值进行递增，最后返回一个完整的值\",\"1653370271627\"]},\"998\":{\"h\":\"3.7、优惠券秒杀-一人一单\",\"t\":[\"需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单\",\"现在的问题在于：\",\"优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单\",\"具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷id和用户id查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单\",\"1653371854389\",\"VoucherOrderServiceImpl\",\"初步代码：增加一人一单逻辑\",\"@Override public Result seckillVoucher(Long voucherId) { // 1.查询优惠券 SeckillVoucher voucher = seckillVoucherService.getById(voucherId); // 2.判断秒杀是否开始 if (voucher.getBeginTime().isAfter(LocalDateTime.now())) { // 尚未开始 return Result.fail(\\\"秒杀尚未开始！\\\"); } // 3.判断秒杀是否已经结束 if (voucher.getEndTime().isBefore(LocalDateTime.now())) { // 尚未开始 return Result.fail(\\\"秒杀已经结束！\\\"); } // 4.判断库存是否充足 if (voucher.getStock() < 1) { // 库存不足 return Result.fail(\\\"库存不足！\\\"); } // 5.一人一单逻辑 // 5.1.用户id Long userId = UserHolder.getUser().getId(); int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } //6，扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock= stock -1\\\") .eq(\\\"voucher_id\\\", voucherId).update(); if (!success) { //扣减库存 return Result.fail(\\\"库存不足！\\\"); } //7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); return Result.ok(orderId); } \",\"**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作\",\"**注意：**在这里提到了非常多的问题，我们需要慢慢的来思考，首先我们的初始方案是封装了一个createVoucherOrder方法，同时为了确保他线程安全，在方法上添加了一把synchronized 锁\",\"@Transactional public synchronized Result createVoucherOrder(Long voucherId) { Long userId = UserHolder.getUser().getId(); // 5.1.查询订单 int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") // set stock = stock - 1 .eq(\\\"voucher_id\\\", voucherId).gt(\\\"stock\\\", 0) // where id = ? and stock > 0 .update(); if (!success) { // 扣减失败 return Result.fail(\\\"库存不足！\\\"); } // 7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 7.2.用户id voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); // 7.返回订单id return Result.ok(orderId); } \",\"，但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制锁粒度 是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为： intern() 这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法\",\"@Transactional public Result createVoucherOrder(Long voucherId) { Long userId = UserHolder.getUser().getId(); synchronized(userId.toString().intern()){ // 5.1.查询订单 int count = query().eq(\\\"user_id\\\", userId).eq(\\\"voucher_id\\\", voucherId).count(); // 5.2.判断是否存在 if (count > 0) { // 用户已经购买过了 return Result.fail(\\\"用户已经购买过一次！\\\"); } // 6.扣减库存 boolean success = seckillVoucherService.update() .setSql(\\\"stock = stock - 1\\\") // set stock = stock - 1 .eq(\\\"voucher_id\\\", voucherId).gt(\\\"stock\\\", 0) // where id = ? and stock > 0 .update(); if (!success) { // 扣减失败 return Result.fail(\\\"库存不足！\\\"); } // 7.创建订单 VoucherOrder voucherOrder = new VoucherOrder(); // 7.1.订单id long orderId = redisIdWorker.nextId(\\\"order\\\"); voucherOrder.setId(orderId); // 7.2.用户id voucherOrder.setUserId(userId); // 7.3.代金券id voucherOrder.setVoucherId(voucherId); save(voucherOrder); // 7.返回订单id return Result.ok(orderId); } } \",\"但是以上代码还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：\",\"在seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度\",\"Long userId = UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { return this.createVoucherOrder(voucherId, userId); } \",\"但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务\",\"synchronized (userId.toString().intern()) { // 获取代理对象（事务） IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId, userId); } \",\"除此之外还需要引入aspectj依赖，以及在启动类添加配置\",\"<dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> </dependency> \",\"@EnableAspectJAutoProxy(exposeProxy = true) \"]},\"999\":{\"h\":\"3.8、集群环境下的并发问题\",\"t\":[\"通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。\",\"1、我们将服务启动两份，端口分别为8081和8082：\",\"1653373887844\",\"2、然后修改nginx的conf目录下的nginx.conf文件，配置反向代理和负载均衡：\",\"1653373908620\",\"具体操作(略)\",\"有关锁失效原因分析\",\"由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm，那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。\",\"1653374044740\"]},\"1000\":{\"h\":\"Redis 基础\",\"t\":[\"提示\",\"Redis系列整理学习自黑马程序员Redis相关课程\",\"目录\"]},\"1001\":{\"h\":\"1、Redis简单介绍\",\"t\":[\"Redis是一种键值型的NoSql数据库，这里有两个关键字：\",\"键值型\",\"NoSql\",\"其中键值型，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：\",\"1652882668159\",\"而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。\",\"对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。\"]},\"1002\":{\"h\":\"2、初始Redis\"},\"1003\":{\"h\":\"2.1、认识NoSQL\",\"t\":[\"NoSql可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为非关系型数据库。\"]},\"1004\":{\"h\":\"2.1.1、结构化与非结构化\",\"t\":[\"传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：\",\"而NoSql则对数据库格式没有严格约束，往往形式松散，自由。\",\"可以是键值型：\",\"也可以是文档型：\",\"甚至可以是图格式：\"]},\"1005\":{\"h\":\"2.1.2、关联和非关联\",\"t\":[\"传统数据库的表与表之间往往存在关联，例如外键：\",\"而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：\",\"{ \\\"id\\\": 1, \\\"name\\\": \\\"张三\\\", \\\"orders\\\": [ { \\\"id\\\": 1, \\\"item\\\": { \\\"id\\\": 10, \\\"title\\\": \\\"荣耀6\\\", \\\"price\\\": 4999 } }, { \\\"id\\\": 2, \\\"item\\\": { \\\"id\\\": 20, \\\"title\\\": \\\"小米11\\\", \\\"price\\\": 3999 } } ] } \",\"此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。\"]},\"1006\":{\"h\":\"2.1.3、查询方式\",\"t\":[\"传统关系型数据库会基于Sql语句做查询，语法有统一标准；\",\"而不同的非关系数据库查询语法差异极大，五花八门各种各样。\"]},\"1007\":{\"h\":\"2.1.4、事务\",\"t\":[\"传统关系型数据库能满足事务ACID的原则。\",\"而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。\"]},\"1008\":{\"h\":\"2.1.5、总结\",\"t\":[\"除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：\",\"存储方式 \",\"关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响\",\"非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些\",\"扩展性 \",\"关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。\",\"非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。\",\"关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦\"]},\"1009\":{\"h\":\"2.2、认识Redis\",\"t\":[\"Redis诞生于2009年全称是Remote Dictionary Server 远程词典服务器，是一个基于内存的键值型NoSQL数据库。\",\"特征：\",\"键值（key-value）型，value支持多种不同数据结构，功能丰富\",\"单线程，每个命令具备原子性\",\"低延迟，速度快（基于内存.IO多路复用.良好的编码）。\",\"支持数据持久化\",\"支持主从集群.分片集群\",\"支持多语言客户端\",\"作者：Antirez\",\"Redis的官方网站地址：https://redis.io/\"]},\"1010\":{\"h\":\"2.3、安装Redis\",\"t\":[\"大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.\",\"此处选择的Linux版本为CentOS 7.\"]},\"1011\":{\"h\":\"2.3.1、依赖库\",\"t\":[\"Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：\",\"yum install -y gcc tcl \"]},\"1012\":{\"h\":\"2.3.2、上传安装包并解压\",\"t\":[\"然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：\",\"例如，我放到了/usr/local/src 目录：\",\"解压缩：\",\"tar -xzf redis-6.2.6.tar.gz \",\"解压后：\",\"image-20211211080339076\",\"进入redis目录：\",\"cd redis-6.2.6 \",\"运行编译命令：\",\"make && make install \",\"如果没有出错，应该就安装成功了。\",\"默认的安装路径是在 /usr/local/bin目录下：\",\"该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：\",\"redis-cli：是redis提供的命令行客户端\",\"redis-server：是redis的服务端启动脚本\",\"redis-sentinel：是redis的哨兵启动脚本\"]},\"1013\":{\"h\":\"2.3.3、启动\",\"t\":[\"redis的启动方式有很多种，例如：\",\"默认启动\",\"指定配置启动\",\"开机自启\"]},\"1014\":{\"h\":\"2.3.4、默认启动\",\"t\":[\"安装完成后，在任意目录输入redis-server命令即可启动Redis：\",\"redis-server \",\"如图：\",\"这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。\"]},\"1015\":{\"h\":\"2.3.5、指定配置启动\",\"t\":[\"如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf：\",\"image-20211211082225509\",\"我们先将这个配置文件备份一份：\",\"cp redis.conf redis.conf.bck \",\"然后修改redis.conf文件中的一些配置：\",\"# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0 bind 0.0.0.0 # 守护进程，修改为yes后即可后台运行 daemonize yes # 密码，设置后访问Redis必须输入密码 requirepass 123321 \",\"Redis的其它常见配置：\",\"# 监听的端口 port 6379 # 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录 dir . # 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15 databases 1 # 设置redis能够使用的最大内存 maxmemory 512mb # 日志文件，默认为空，不记录日志，可以指定日志文件名 logfile \\\"redis.log\\\" \",\"启动Redis：\",\"# 进入redis安装目录 cd /usr/local/src/redis-6.2.6 # 启动 redis-server redis.conf \",\"停止服务：\",\"# 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务， # 因为之前配置了密码，因此需要通过 -u 来指定密码 redis-cli -u 123321 shutdown \"]},\"1016\":{\"h\":\"2.3.6、开机自启\",\"t\":[\"我们也可以通过配置来实现开机自启。\",\"首先，新建一个系统服务文件：\",\"vi /etc/systemd/system/redis.service \",\"内容如下：\",\"[Unit] Description=redis-server After=network.target [Service] Type=forking ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf PrivateTmp=true [Install] WantedBy=multi-user.target \",\"然后重载系统服务：\",\"systemctl daemon-reload \",\"现在，我们可以用下面这组命令来操作redis了：\",\"# 启动 systemctl start redis # 停止 systemctl stop redis # 重启 systemctl restart redis # 查看状态 systemctl status redis \",\"执行下面的命令，可以让redis开机自启：\",\"systemctl enable redis \"]},\"1017\":{\"h\":\"2.4、Redis桌面客户端\",\"t\":[\"安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：\",\"命令行客户端\",\"图形化桌面客户端\",\"编程客户端\"]},\"1018\":{\"h\":\"2.4.1、Redis命令行客户端\",\"t\":[\"Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：\",\"redis-cli [options] [commonds] \",\"其中常见的options有：\",\"-h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1\",\"-p 6379：指定要连接的redis节点的端口，默认是6379\",\"-a 123321：指定redis的访问密码\",\"其中的commonds就是Redis的操作命令，例如：\",\"ping：与redis服务端做心跳测试，服务端正常会返回pong\",\"不指定commond时，会进入redis-cli的交互控制台：\"]},\"1019\":{\"h\":\"2.4.2、图形化桌面客户端\",\"t\":[\"GitHub上的大神编写了Redis的图形化桌面客户端，地址：https://github.com/uglide/RedisDesktopManager\",\"不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。\",\"在下面这个仓库可以找到安装包：https://github.com/lework/RedisDesktopManager-Windows/releases\"]},\"1020\":{\"h\":\"2.4.3、安装\",\"t\":[\"在课前资料中可以找到Redis的图形化桌面客户端：\",\"解压缩后，运行安装程序即可安装：\",\"安装完成后，在安装目录下找到rdm.exe文件：\",\"双击即可运行：\"]},\"1021\":{\"h\":\"2.4.4、建立连接\",\"t\":[\"点击左上角的连接到Redis服务器按钮：\",\"在弹出的窗口中填写Redis服务信息：\",\"点击确定后，在左侧菜单会出现这个链接：\",\"点击即可建立连接了。\",\"Redis默认有16个仓库，编号从0至15. 通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。\",\"如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：\",\"# 选择 0号库 select 0 \"]},\"1022\":{\"h\":\"3、Redis常见命令\"},\"1023\":{\"h\":\"3.1、Redis数据结构介绍\",\"t\":[\"Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：\",\"1652887393157\",\"贴心小建议：命令不要死记，学会查询就好啦\",\"Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ https://redis.io/commands ）可以查看到不同的命令：\",\"1652887648826\",\"当然我们也可以通过Help命令来帮助我们去查看命令\",\"1652887748279\"]},\"1024\":{\"h\":\"3.2、Redis 通用命令\",\"t\":[\"通用指令是部分数据类型的，都可以使用的指令，常见的有：\",\"KEYS：查看符合模板的所有key\",\"DEL：删除一个指定的key\",\"EXISTS：判断key是否存在\",\"EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除\",\"TTL：查看一个KEY的剩余有效期\",\"通过help [command] 可以查看一个命令的具体用法，例如：\",\"1652887865189\",\"课堂代码如下\",\"KEYS\",\"127.0.0.1:6379> keys * 1) \\\"name\\\" 2) \\\"age\\\" 127.0.0.1:6379> # 查询以a开头的key 127.0.0.1:6379> keys a* 1) \\\"age\\\" 127.0.0.1:6379> \",\"贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高\",\"DEL\",\"127.0.0.1:6379> help del DEL key [key ...] summary: Delete a key since: 1.0.0 group: generic 127.0.0.1:6379> del name #删除单个 (integer) 1 #成功删除1个 127.0.0.1:6379> keys * 1) \\\"age\\\" 127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 #批量添加数据 OK 127.0.0.1:6379> keys * 1) \\\"k3\\\" 2) \\\"k2\\\" 3) \\\"k1\\\" 4) \\\"age\\\" 127.0.0.1:6379> del k1 k2 k3 k4 (integer) 3 #此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回 127.0.0.1:6379> 127.0.0.1:6379> keys * #再查询全部的key 1) \\\"age\\\" #只剩下一个了 127.0.0.1:6379> \",\"贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~\",\"EXISTS\",\"127.0.0.1:6379> help EXISTS EXISTS key [key ...] summary: Determine if a key exists since: 1.0.0 group: generic 127.0.0.1:6379> exists age (integer) 1 127.0.0.1:6379> exists name (integer) 0 \",\"EXPIRE\",\"贴心小提示：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~\",\"127.0.0.1:6379> expire age 10 (integer) 1 127.0.0.1:6379> ttl age (integer) 8 127.0.0.1:6379> ttl age (integer) 6 127.0.0.1:6379> ttl age (integer) -2 127.0.0.1:6379> ttl age (integer) -2 #当这个key过期了，那么此时查询出来就是-2 127.0.0.1:6379> keys * (empty list or set) 127.0.0.1:6379> set age 10 #如果没有设置过期时间 OK 127.0.0.1:6379> ttl age (integer) -1 # ttl的返回值就是-1 \"]},\"1025\":{\"h\":\"3.3、Redis命令-String命令\",\"t\":[\"String类型，也就是字符串类型，是Redis中最简单的存储类型。\",\"其value是字符串，不过根据字符串的格式不同，又可以分为3类：\",\"string：普通字符串\",\"int：整数类型，可以做自增.自减操作\",\"float：浮点类型，可以做自增.自减操作\",\"1652890121291\",\"String的常见命令有：\",\"SET：添加或者修改已经存在的一个String类型的键值对\",\"GET：根据key获取String类型的value\",\"MSET：批量添加多个String类型的键值对\",\"MGET：根据多个key获取多个String类型的value\",\"INCR：让一个整型的key自增1\",\"INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\",\"INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\",\"SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行\",\"SETEX：添加一个String类型的键值对，并且指定有效期\",\"贴心小提示：以上命令除了INCRBYFLOAT 都是常用命令\",\"SET 和GET: 如果key不存在则是新增，如果存在则是修改\",\"127.0.0.1:6379> set name Rose //原来不存在 OK 127.0.0.1:6379> get name \\\"Rose\\\" 127.0.0.1:6379> set name Jack //原来存在，就是修改 OK 127.0.0.1:6379> get name \\\"Jack\\\" \",\"MSET和MGET\",\"127.0.0.1:6379> MSET k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379> MGET name age k1 k2 k3 1) \\\"Jack\\\" //之前存在的name 2) \\\"10\\\" //之前存在的age 3) \\\"v1\\\" 4) \\\"v2\\\" 5) \\\"v3\\\" \",\"INCR和INCRBY和DECY\",\"127.0.0.1:6379> get age \\\"10\\\" 127.0.0.1:6379> incr age //增加1 (integer) 11 127.0.0.1:6379> get age //获得age \\\"11\\\" 127.0.0.1:6379> incrby age 2 //一次增加2 (integer) 13 //返回目前的age的值 127.0.0.1:6379> incrby age 2 (integer) 15 127.0.0.1:6379> incrby age -1 //也可以增加负数，相当于减 (integer) 14 127.0.0.1:6379> incrby age -2 //一次减少2个 (integer) 12 127.0.0.1:6379> DECR age //相当于 incr 负数，减少正常用法 (integer) 11 127.0.0.1:6379> get age \\\"11\\\" \",\"SETNX\",\"127.0.0.1:6379> help setnx SETNX key value summary: Set the value of a key, only if the key does not exist since: 1.0.0 group: string 127.0.0.1:6379> set name Jack //设置名称 OK 127.0.0.1:6379> setnx name lisi //如果key不存在，则添加成功 (integer) 0 127.0.0.1:6379> get name //由于name已经存在，所以lisi的操作失败 \\\"Jack\\\" 127.0.0.1:6379> setnx name2 lisi //name2 不存在，所以操作成功 (integer) 1 127.0.0.1:6379> get name2 \\\"lisi\\\" \",\"SETEX\",\"127.0.0.1:6379> setex name 10 jack OK 127.0.0.1:6379> ttl name (integer) 8 127.0.0.1:6379> ttl name (integer) 7 127.0.0.1:6379> ttl name (integer) 5 \"]},\"1026\":{\"h\":\"3.4、Redis命令-Key的层级结构\",\"t\":[\"Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？\",\"例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？\",\"我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：\",\"Redis的key允许有多个单词形成层级结构，多个单词之间用':'隔开，格式如下：\",\"1652941631682\",\"这个格式并非固定，也可以根据自己的需求来删除或添加词条。\",\"例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：\",\"user相关的key：heima:user:1\",\"product相关的key：heima:product:1\",\"如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：\",\"KEY\",\"VALUE\",\"heima:user:1\",\"{\\\"id\\\":1, \\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}\",\"heima:product:1\",\"{\\\"id\\\":1, \\\"name\\\": \\\"小米11\\\", \\\"price\\\": 4999}\",\"一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据\",\"1652941883537\"]},\"1027\":{\"h\":\"3.5、Redis命令-Hash命令\",\"t\":[\"Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。\",\"String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：\",\"1652941995945\",\"Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：\",\"1652942027719\",\"Hash类型的常见命令\",\"HSET key field value：添加或者修改hash类型key的field的值\",\"HGET key field：获取一个hash类型key的field的值\",\"HMSET：批量添加多个hash类型key的field的值\",\"HMGET：批量获取多个hash类型key的field的值\",\"HGETALL：获取一个hash类型的key中的所有的field和value\",\"HKEYS：获取一个hash类型的key中的所有的field\",\"HINCRBY:让一个hash类型key的字段值自增并指定步长\",\"HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\",\"贴心小提示：哈希结构也是我们以后实际开发中常用的命令哟\",\"HSET和HGET\",\"127.0.0.1:6379> HSET heima:user:3 name Lucy//大key是 heima:user:3 小key是name，小value是Lucy (integer) 1 127.0.0.1:6379> HSET heima:user:3 age 21// 如果操作不存在的数据，则是新增 (integer) 1 127.0.0.1:6379> HSET heima:user:3 age 17 //如果操作存在的数据，则是修改 (integer) 0 127.0.0.1:6379> HGET heima:user:3 name \\\"Lucy\\\" 127.0.0.1:6379> HGET heima:user:3 age \\\"17\\\" \",\"HMSET和HMGET\",\"127.0.0.1:6379> HMSET heima:user:4 name HanMeiMei OK 127.0.0.1:6379> HMSET heima:user:4 name LiLei age 20 sex man OK 127.0.0.1:6379> HMGET heima:user:4 name age sex 1) \\\"LiLei\\\" 2) \\\"20\\\" 3) \\\"man\\\" \",\"HGETALL\",\"127.0.0.1:6379> HGETALL heima:user:4 1) \\\"name\\\" 2) \\\"LiLei\\\" 3) \\\"age\\\" 4) \\\"20\\\" 5) \\\"sex\\\" 6) \\\"man\\\" \",\"HKEYS和HVALS\",\"127.0.0.1:6379> HKEYS heima:user:4 1) \\\"name\\\" 2) \\\"age\\\" 3) \\\"sex\\\" 127.0.0.1:6379> HVALS heima:user:4 1) \\\"LiLei\\\" 2) \\\"20\\\" 3) \\\"man\\\" \",\"HINCRBY\",\"127.0.0.1:6379> HINCRBY heima:user:4 age 2 (integer) 22 127.0.0.1:6379> HVALS heima:user:4 1) \\\"LiLei\\\" 2) \\\"22\\\" 3) \\\"man\\\" 127.0.0.1:6379> HINCRBY heima:user:4 age -2 (integer) 20 \",\"HSETNX\",\"127.0.0.1:6379> HSETNX heima:user4 sex woman (integer) 1 127.0.0.1:6379> HGETALL heima:user:3 1) \\\"name\\\" 2) \\\"Lucy\\\" 3) \\\"age\\\" 4) \\\"17\\\" 127.0.0.1:6379> HSETNX heima:user:3 sex woman (integer) 1 127.0.0.1:6379> HGETALL heima:user:3 1) \\\"name\\\" 2) \\\"Lucy\\\" 3) \\\"age\\\" 4) \\\"17\\\" 5) \\\"sex\\\" 6) \\\"woman\\\" \"]},\"1028\":{\"h\":\"3.6、Redis命令-List命令\",\"t\":[\"Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。\",\"特征也与LinkedList类似：\",\"有序\",\"元素可以重复\",\"插入和删除快\",\"查询速度一般\",\"常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。\",\"List的常见命令有：\",\"LPUSH key element ... ：向列表左侧插入一个或多个元素\",\"LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\",\"RPUSH key element ... ：向列表右侧插入一个或多个元素\",\"RPOP key：移除并返回列表右侧的第一个元素\",\"LRANGE key star end：返回一段角标范围内的所有元素\",\"BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\",\"1652943604992\",\"LPUSH和RPUSH\",\"127.0.0.1:6379> LPUSH users 1 2 3 (integer) 3 127.0.0.1:6379> RPUSH users 4 5 6 (integer) 6 \",\"LPOP和RPOP\",\"127.0.0.1:6379> LPOP users \\\"3\\\" 127.0.0.1:6379> RPOP users \\\"6\\\" \",\"LRANGE\",\"127.0.0.1:6379> LRANGE users 1 2 1) \\\"1\\\" 2) \\\"4\\\" \"]},\"1029\":{\"h\":\"3.7、Redis命令-Set命令\",\"t\":[\"Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：\",\"无序\",\"元素不可重复\",\"查找快\",\"支持交集.并集.差集等功能\",\"Set类型的常见命令\",\"SADD key member ... ：向set中添加一个或多个元素\",\"SREM key member ... : 移除set中的指定元素\",\"SCARD key： 返回set中元素的个数\",\"SISMEMBER key member：判断一个元素是否存在于set中\",\"SMEMBERS：获取set中的所有元素\",\"SINTER key1 key2 ... ：求key1与key2的交集\",\"SDIFF key1 key2 ... ：求key1与key2的差集\",\"SUNION key1 key2 ..：求key1和key2的并集\",\"例如两个集合：s1和s2:\",\"求交集：SINTER s1 s2\",\"求s1与s2的不同：SDIFF s1 s2\",\"具体命令\",\"127.0.0.1:6379> sadd s1 a b c (integer) 3 127.0.0.1:6379> smembers s1 1) \\\"c\\\" 2) \\\"b\\\" 3) \\\"a\\\" 127.0.0.1:6379> srem s1 a (integer) 1 127.0.0.1:6379> SISMEMBER s1 a (integer) 0 127.0.0.1:6379> SISMEMBER s1 b (integer) 1 127.0.0.1:6379> SCARD s1 (integer) 2 \",\"案例\",\"将下列数据用Redis的Set集合来存储：\",\"张三的好友有：李四.王五.赵六\",\"李四的好友有：王五.麻子.二狗\",\"利用Set的命令实现下列功能：\",\"计算张三的好友有几人\",\"计算张三和李四有哪些共同好友\",\"查询哪些人是张三的好友却不是李四的好友\",\"查询张三和李四的好友总共有哪些人\",\"判断李四是否是张三的好友\",\"判断张三是否是李四的好友\",\"将李四从张三的好友列表中移除\",\"127.0.0.1:6379> SADD zs lisi wangwu zhaoliu (integer) 3 127.0.0.1:6379> SADD ls wangwu mazi ergou (integer) 3 127.0.0.1:6379> SCARD zs (integer) 3 127.0.0.1:6379> SINTER zs ls 1) \\\"wangwu\\\" 127.0.0.1:6379> SDIFF zs ls 1) \\\"zhaoliu\\\" 2) \\\"lisi\\\" 127.0.0.1:6379> SUNION zs ls 1) \\\"wangwu\\\" 2) \\\"zhaoliu\\\" 3) \\\"lisi\\\" 4) \\\"mazi\\\" 5) \\\"ergou\\\" 127.0.0.1:6379> SISMEMBER zs lisi (integer) 1 127.0.0.1:6379> SISMEMBER ls zhangsan (integer) 0 127.0.0.1:6379> SREM zs lisi (integer) 1 127.0.0.1:6379> SMEMBERS zs 1) \\\"zhaoliu\\\" 2) \\\"wangwu\\\" \"]},\"1030\":{\"h\":\"3.8、Redis命令-SortedSet类型\",\"t\":[\"Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\",\"SortedSet具备下列特性：\",\"可排序\",\"元素不重复\",\"查询速度快\",\"因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。\",\"SortedSet的常见命令有：\",\"ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\",\"ZREM key member：删除sorted set中的一个指定元素\",\"ZSCORE key member : 获取sorted set中的指定元素的score值\",\"ZRANK key member：获取sorted set 中的指定元素的排名\",\"ZCARD key：获取sorted set中的元素个数\",\"ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\",\"ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\",\"ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\",\"ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\",\"ZDIFF.ZINTER.ZUNION：求差集.交集.并集\",\"注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：\",\"升序获取sorted set 中的指定元素的排名：ZRANK key member\",\"降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber\"]},\"1031\":{\"h\":\"4、Redis的Java客户端-Jedis\",\"t\":[\"在Redis官网中提供了各种语言的客户端，地址：https://redis.io/docs/clients/\",\"其中Java客户端也包含很多：\",\"image-20220609102817435\",\"标记为❤的就是推荐使用的java客户端，包括：\",\"Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。\",\"Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。\"]},\"1032\":{\"h\":\"4.1、Jedis快速入门\",\"t\":[\"入门案例详细步骤\",\"案例分析：\",\"0）创建工程\",\"1）引入依赖：\",\"<!--jedis--> <dependency> <groupId>redis.clients</groupId> <artifactId>jedis</artifactId> <version>3.7.0</version> </dependency> <!--单元测试--> <dependency> <groupId>org.junit.jupiter</groupId> <artifactId>junit-jupiter</artifactId> <version>5.7.0</version> <scope>test</scope> </dependency> \",\"2）建立连接\",\"新建一个单元测试类，内容如下：\",\"private Jedis jedis; @BeforeEach void setUp() { // 1.建立连接 // jedis = new Jedis(\\\"192.168.150.101\\\", 6379); jedis = JedisConnectionFactory.getJedis(); // 2.设置密码 jedis.auth(\\\"123321\\\"); // 3.选择库 jedis.select(0); } \",\"3）测试：\",\"@Test void testString() { // 存入数据 String result = jedis.set(\\\"name\\\", \\\"虎哥\\\"); System.out.println(\\\"result = \\\" + result); // 获取数据 String name = jedis.get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } @Test void testHash() { // 插入hash数据 jedis.hset(\\\"user:1\\\", \\\"name\\\", \\\"Jack\\\"); jedis.hset(\\\"user:1\\\", \\\"age\\\", \\\"21\\\"); // 获取 Map<String, String> map = jedis.hgetAll(\\\"user:1\\\"); System.out.println(map); } \",\"4）释放资源\",\"@AfterEach void tearDown() { if (jedis != null) { jedis.close(); } } \"]},\"1033\":{\"h\":\"4.2、Jedis连接池\",\"t\":[\"Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式\",\"有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。\"]},\"1034\":{\"h\":\"4.2.1、创建Jedis的连接池\",\"t\":[\"public class JedisConnectionFacotry { private static final JedisPool jedisPool; static { //配置连接池 JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(8); poolConfig.setMaxIdle(8); poolConfig.setMinIdle(0); poolConfig.setMaxWaitMillis(1000); //创建连接池对象 jedisPool = new JedisPool(poolConfig, \\\"192.168.150.101\\\",6379,1000,\\\"123321\\\"); } public static Jedis getJedis(){ return jedisPool.getResource(); } } \",\"代码说明：\",\"1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式\",\"2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化\",\"3）最后提供返回连接池中连接的方法.\"]},\"1035\":{\"h\":\"4.2.2、改造原始代码\",\"t\":[\"代码说明:\",\"1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。\",\"，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。\",\"2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。\",\" @BeforeEach void setUp(){ //建立连接 /*jedis = new Jedis(\\\"127.0.0.1\\\",6379);*/ jedis = JedisConnectionFacotry.getJedis(); //选择库 jedis.select(0); } @AfterEach void tearDown() { if (jedis != null) { jedis.close(); } } \"]},\"1036\":{\"h\":\"5、Redis的Java客户端-SpringDataRedis\",\"t\":[\"SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：https://spring.io/projects/spring-data-redis\",\"提供了对不同Redis客户端的整合（Lettuce和Jedis）\",\"提供了RedisTemplate统一API来操作Redis\",\"支持Redis的发布订阅模型\",\"支持Redis哨兵和Redis集群\",\"支持基于Lettuce的响应式编程\",\"支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化\",\"支持基于Redis的JDKCollection实现\",\"SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：\",\"1652976773295\"]},\"1037\":{\"h\":\"5.1、快速入门\",\"t\":[\"SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：\"]},\"1038\":{\"h\":\"5.1.1、导入pom坐标\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.5.7</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.heima</groupId> <artifactId>redis-demo</artifactId> <version>0.0.1-SNAPSHOT</version> <name>redis-demo</name> <description>Demo project for Spring Boot</description> <properties> <java.version>1.8</java.version> </properties> <dependencies> <!--redis依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> <!--common-pool--> <dependency> <groupId>org.apache.commons</groupId> <artifactId>commons-pool2</artifactId> </dependency> <!--Jackson依赖--> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project> \"]},\"1039\":{\"h\":\"5.1.2、配置文件\",\"t\":[\"spring: redis: host: 192.168.150.101 port: 6379 password: 123321 lettuce: pool: max-active: 8 #最大连接 max-idle: 8 #最大空闲连接 min-idle: 0 #最小空闲连接 max-wait: 100ms #连接等待时间 \"]},\"1040\":{\"h\":\"5.1.3、测试代码\",\"t\":[\"@SpringBootTest class RedisDemoApplicationTests { @Autowired private RedisTemplate<String, Object> redisTemplate; @Test void testString() { // 写入一条String数据 redisTemplate.opsForValue().set(\\\"name\\\", \\\"虎哥\\\"); // 获取string数据 Object name = redisTemplate.opsForValue().get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } } \",\"贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可\",\"SpringDataRedis的使用步骤：\",\"引入spring-boot-starter-data-redis依赖\",\"在application.yml配置Redis信息\",\"注入RedisTemplate\"]},\"1041\":{\"h\":\"5.2、数据序列化器\",\"t\":[\"RedisTemplate可以接收任意Object作为值写入Redis：\",\"只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：\",\"缺点：\",\"可读性差\",\"内存占用较大\",\"我们可以自定义RedisTemplate的序列化方式，代码如下：\",\"@Configuration public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){ // 创建RedisTemplate对象 RedisTemplate<String, Object> template = new RedisTemplate<>(); // 设置连接工厂 template.setConnectionFactory(connectionFactory); // 创建JSON序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // 设置Key的序列化 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // 设置Value的序列化 template.setValueSerializer(jsonRedisSerializer); template.setHashValueSerializer(jsonRedisSerializer); // 返回 return template; } } \",\"这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：\",\"整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。\"]},\"1042\":{\"h\":\"5.3、StringRedisTemplate\",\"t\":[\"尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：\",\"1653054602930\",\"为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。\",\"为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间\",\"1653054744832\",\"这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。\",\"省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：\",\"@SpringBootTest class RedisStringTests { @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testString() { // 写入一条String数据 stringRedisTemplate.opsForValue().set(\\\"verify:phone:13600527634\\\", \\\"124143\\\"); // 获取string数据 Object name = stringRedisTemplate.opsForValue().get(\\\"name\\\"); System.out.println(\\\"name = \\\" + name); } private static final ObjectMapper mapper = new ObjectMapper(); @Test void testSaveUser() throws JsonProcessingException { // 创建对象 User user = new User(\\\"虎哥\\\", 21); // 手动序列化 String json = mapper.writeValueAsString(user); // 写入数据 stringRedisTemplate.opsForValue().set(\\\"user:200\\\", json); // 获取数据 String jsonUser = stringRedisTemplate.opsForValue().get(\\\"user:200\\\"); // 手动反序列化 User user1 = mapper.readValue(jsonUser, User.class); System.out.println(\\\"user1 = \\\" + user1); } } \",\"此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~\",\"1653054945211\",\"最后小总结：\",\"RedisTemplate的两种序列化实践方案：\",\"方案一：\",\"自定义RedisTemplate\",\"修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer\",\"方案二：\",\"使用StringRedisTemplate\",\"写入Redis时，手动把对象序列化为JSON\",\"读取Redis时，手动把读取到的JSON反序列化为对象\"]},\"1043\":{\"h\":\"5.4、Hash结构操作\",\"t\":[\"在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦\",\"马上就开始新的篇章~~~进入到我们的Redis实战篇\",\"@SpringBootTest class RedisStringTests { @Autowired private StringRedisTemplate stringRedisTemplate; @Test void testHash() { stringRedisTemplate.opsForHash().put(\\\"user:400\\\", \\\"name\\\", \\\"虎哥\\\"); stringRedisTemplate.opsForHash().put(\\\"user:400\\\", \\\"age\\\", \\\"21\\\"); Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries(\\\"user:400\\\"); System.out.println(\\\"entries = \\\" + entries); } } \"]},\"1044\":{\"c\":[\"redis\"]},\"1045\":{\"c\":[\"redis\"]},\"1046\":{\"h\":\"Ml\"},\"1047\":{\"h\":\"Designmode\"},\"1048\":{\"h\":\"O S\"},\"1049\":{\"h\":\"Interview\"},\"1050\":{\"h\":\"Guide\"},\"1051\":{\"h\":\"Reactive\"},\"1052\":{\"h\":\"Microservice\"},\"1053\":{\"h\":\"Advance\"},\"1054\":{\"h\":\"Netty\"},\"1055\":{\"h\":\"Optimization\"},\"1056\":{\"h\":\"Basics\"},\"1057\":{\"h\":\"Nio\"},\"1058\":{\"h\":\"Elasticsearch\"},\"1059\":{\"h\":\"Middleware\"},\"1060\":{\"h\":\"Redis\"}},\"dirtCount\":0,\"index\":[[\"咱们对hash结构操作一下\",{\"1\":{\"1043\":1}}],[\"咱们就不能使用code了\",{\"1\":{\"966\":1}}],[\"官网地址\",{\"1\":{\"1036\":1}}],[\"官方推荐不超过1000个\",{\"1\":{\"434\":1}}],[\"官方\",{\"0\":{\"30\":1}}],[\"官方论文复现\",{\"1\":{\"14\":1}}],[\"官方github\",{\"1\":{\"7\":1}}],[\"虎哥\",{\"1\":{\"1032\":1,\"1040\":1,\"1042\":1,\"1043\":1}}],[\"降序获取sorted\",{\"1\":{\"1030\":1}}],[\"降低耦合\",{\"1\":{\"1035\":1}}],[\"降低项目依赖的复杂度\",{\"1\":{\"727\":1}}],[\"降低模块间的耦合度\",{\"1\":{\"706\":1}}],[\"降低对象之间的耦合度\",{\"1\":{\"706\":1}}],[\"降低资源消耗\",{\"1\":{\"240\":1}}],[\"降低系统吞吐量\",{\"1\":{\"148\":1}}],[\"升序获取sorted\",{\"1\":{\"1030\":1}}],[\"麻子\",{\"1\":{\"1029\":1}}],[\"求差集\",{\"1\":{\"1030\":1}}],[\"求s1与s2的不同\",{\"1\":{\"1029\":1}}],[\"求交集\",{\"1\":{\"1029\":1}}],[\"求key1和key2的并集\",{\"1\":{\"1029\":1}}],[\"求key1与key2的差集\",{\"1\":{\"1029\":1}}],[\"求key1与key2的交集\",{\"1\":{\"1029\":1}}],[\"求第\",{\"1\":{\"194\":1}}],[\"差集等功能\",{\"1\":{\"1029\":1}}],[\"差错处理\",{\"1\":{\"182\":1}}],[\"元素不重复\",{\"1\":{\"1030\":1}}],[\"元素不可重复\",{\"1\":{\"1029\":1}}],[\"元素可以重复\",{\"1\":{\"1028\":1}}],[\"元数据锁\",{\"1\":{\"400\":1}}],[\"隔开\",{\"1\":{\"1026\":1}}],[\"隔离性要求同一时刻只能有一个事务对数据进行写操作\",{\"1\":{\"396\":1}}],[\"隔离性追求的是并发情形下事务之间互不干扰\",{\"1\":{\"396\":1}}],[\"隔离性实现原理\",{\"1\":{\"396\":1}}],[\"隔离性\",{\"1\":{\"396\":1}}],[\"浮点类型\",{\"1\":{\"1025\":1}}],[\"浮沉\",{\"1\":{\"37\":1}}],[\"贴心小建议\",{\"1\":{\"1023\":1}}],[\"贴心小提示\",{\"1\":{\"960\":1,\"1024\":3,\"1025\":1,\"1027\":1,\"1040\":1}}],[\"点击即可建立连接了\",{\"1\":{\"1021\":1}}],[\"点击确定后\",{\"1\":{\"1021\":1}}],[\"点击左上角的连接到redis服务器按钮\",{\"1\":{\"1021\":1}}],[\"安装\",{\"0\":{\"1020\":1}}],[\"安装完成redis\",{\"1\":{\"1017\":1}}],[\"安装完成后\",{\"1\":{\"1014\":1,\"1020\":1}}],[\"安装redis\",{\"0\":{\"1010\":1}}],[\"安全性不高\",{\"1\":{\"391\":1}}],[\"安全\",{\"1\":{\"126\":1}}],[\"安全门案例\",{\"1\":{\"110\":1}}],[\"良好的编码\",{\"1\":{\"1009\":1}}],[\"型\",{\"1\":{\"1009\":1}}],[\"荣耀\",{\"1\":{\"1005\":1}}],[\"荣耀6\",{\"1\":{\"1005\":1}}],[\"往往形式松散\",{\"1\":{\"1004\":1}}],[\"往文件中写对象\",{\"1\":{\"103\":1}}],[\"认识redis\",{\"0\":{\"1009\":1}}],[\"认识nosql\",{\"0\":{\"1003\":1}}],[\"认为只有在\",{\"1\":{\"845\":1}}],[\"认为业务的惟一性一律需要在应用层通过\",{\"1\":{\"266\":1}}],[\"认为索引会消耗空间\",{\"1\":{\"266\":1}}],[\"认为一个查询就需要建一个索引\",{\"1\":{\"266\":1}}],[\"称之为nosql数据库\",{\"1\":{\"1001\":1}}],[\"称为水平扩展\",{\"1\":{\"1008\":1}}],[\"称为垂直扩展\",{\"1\":{\"1008\":1}}],[\"称为缺页或缺段\",{\"1\":{\"418\":1,\"419\":1}}],[\"称为外层页表\",{\"1\":{\"413\":1}}],[\"称为内存的有效访问时间\",{\"1\":{\"413\":1}}],[\"称为内存映像i\",{\"1\":{\"180\":1}}],[\"称为\",{\"1\":{\"413\":1}}],[\"称为用户空间\",{\"1\":{\"406\":1}}],[\"称为页目录表\",{\"1\":{\"158\":1}}],[\"称为页\",{\"1\":{\"156\":1}}],[\"称为进程控制块\",{\"1\":{\"131\":1}}],[\"扣减失败\",{\"1\":{\"998\":2}}],[\"扣减库存\",{\"1\":{\"995\":1,\"996\":2,\"998\":4}}],[\"尚未开始\",{\"1\":{\"998\":2}}],[\"尚未调入内存\",{\"1\":{\"418\":1}}],[\"秒杀已经结束\",{\"1\":{\"995\":1,\"998\":1}}],[\"秒杀尚未开始\",{\"1\":{\"995\":1,\"998\":1}}],[\"秒杀是否开始或结束\",{\"1\":{\"995\":1}}],[\"秒杀下单应该思考的内容\",{\"1\":{\"995\":1}}],[\"秒内的计数器\",{\"1\":{\"992\":1}}],[\"精确到天\",{\"1\":{\"993\":1}}],[\"精简的访问列表\",{\"1\":{\"173\":1}}],[\"符号位\",{\"1\":{\"992\":1}}],[\"符合\",{\"1\":{\"960\":1}}],[\"符合表达习惯\",{\"1\":{\"265\":1}}],[\"符合开闭原则\",{\"1\":{\"50\":1}}],[\"卖出了多少单\",{\"1\":{\"992\":1}}],[\"卖票接口\",{\"1\":{\"93\":1,\"94\":1}}],[\"场景分析二\",{\"1\":{\"992\":1}}],[\"场景分析\",{\"1\":{\"992\":1}}],[\"休眠并重试\",{\"1\":{\"990\":1}}],[\"命中\",{\"1\":{\"989\":1,\"990\":1}}],[\"命令不要死记\",{\"1\":{\"1023\":1}}],[\"命令\",{\"1\":{\"1015\":1,\"1024\":1}}],[\"命令行客户端\",{\"1\":{\"1017\":1}}],[\"命令行\",{\"1\":{\"652\":1}}],[\"命令执行是单线程操作\",{\"1\":{\"424\":1}}],[\"命令执行基于内存操作\",{\"1\":{\"424\":1}}],[\"命令接口\",{\"1\":{\"126\":1}}],[\"证明是缓存穿透数据\",{\"1\":{\"985\":1}}],[\"欧当再次发起查询时\",{\"1\":{\"985\":1}}],[\"误判原因在于\",{\"1\":{\"984\":1}}],[\"误报的可能性就越大\",{\"1\":{\"272\":2}}],[\"店铺id不能为空\",{\"1\":{\"983\":1}}],[\"店铺不存在\",{\"1\":{\"983\":1,\"990\":1}}],[\"淘汰掉一些不重要的数据\",{\"1\":{\"980\":1}}],[\"浏览器缓存\",{\"1\":{\"976\":1}}],[\"浏览器刷新页面\",{\"1\":{\"710\":1}}],[\"企业的数据量\",{\"1\":{\"975\":1}}],[\"俗称的缓存就是缓冲区内的数据\",{\"1\":{\"974\":1}}],[\"避震器\",{\"1\":{\"974\":2,\"975\":1}}],[\"避免被猜测id规律\",{\"1\":{\"985\":1}}],[\"避免非阻塞模式下所做无用功\",{\"1\":{\"879\":1}}],[\"避免拷贝\",{\"1\":{\"829\":1}}],[\"避免反射\",{\"1\":{\"527\":3}}],[\"避免反射调用\",{\"0\":{\"524\":1}}],[\"避免工厂对象提前被创建\",{\"1\":{\"491\":1}}],[\"避免生成重复\",{\"1\":{\"442\":1}}],[\"避免经常更新的表创建过多的索引\",{\"1\":{\"384\":1}}],[\"避免列名出错的情况\",{\"1\":{\"371\":1}}],[\"避免类的重复加载\",{\"1\":{\"345\":1}}],[\"避免了多线程之间上下文切换导致的开销\",{\"1\":{\"332\":1}}],[\"避免扩容操作\",{\"1\":{\"323\":1}}],[\"避免出现误删除\",{\"1\":{\"267\":1}}],[\"避免出现file\",{\"1\":{\"266\":1}}],[\"避免执行后面的分页语句\",{\"1\":{\"267\":1}}],[\"避免回表\",{\"1\":{\"266\":1}}],[\"避免关联查询\",{\"1\":{\"265\":1}}],[\"避免影响其它索引效率\",{\"1\":{\"265\":1}}],[\"避免节外生枝\",{\"1\":{\"265\":1}}],[\"避免活锁的方法\",{\"1\":{\"222\":1}}],[\"避免i\",{\"1\":{\"163\":1}}],[\"避免死锁的方法\",{\"1\":{\"221\":1}}],[\"避免死锁\",{\"0\":{\"149\":1},\"1\":{\"147\":1}}],[\"山地自行车\",{\"1\":{\"974\":1}}],[\"越野车\",{\"1\":{\"974\":1}}],[\"越野车的避震器\",{\"1\":{\"974\":1}}],[\"越来越多的应用场景需要根据任务的紧急程度来决定处理的顺序\",{\"1\":{\"139\":1}}],[\"商品信息到redis\",{\"1\":{\"1026\":1}}],[\"商品类目名称使用频率高\",{\"1\":{\"265\":1}}],[\"商户查询缓存\",{\"0\":{\"973\":1}}],[\"早期的方案是session拷贝\",{\"1\":{\"963\":1}}],[\"早期的多用户操作系统\",{\"1\":{\"168\":1}}],[\"肯定没有第一台服务器存放的session\",{\"1\":{\"963\":1}}],[\"肯定是\",{\"1\":{\"275\":1}}],[\"拦截\",{\"1\":{\"961\":1,\"972\":1}}],[\"拦截器代码\",{\"1\":{\"961\":1}}],[\"拦截器会对处理器进行拦截\",{\"1\":{\"738\":1}}],[\"拦截器内\",{\"1\":{\"617\":1}}],[\"温馨小贴士\",{\"1\":{\"961\":2}}],[\"报错\",{\"1\":{\"960\":1,\"968\":1}}],[\"报错信息说没有main方法\",{\"1\":{\"346\":1}}],[\"校验验证码\",{\"1\":{\"960\":1}}],[\"校验手机号\",{\"1\":{\"960\":2,\"968\":1}}],[\"校验登录状态\",{\"1\":{\"959\":1}}],[\"瞬间就会让mysql服务器的cpu\",{\"1\":{\"955\":1}}],[\"导入pom坐标\",{\"0\":{\"1038\":1}}],[\"导入前端工程\",{\"0\":{\"957\":1}}],[\"导入后端项目\",{\"0\":{\"956\":1}}],[\"导入sql\",{\"0\":{\"954\":1}}],[\"导入黑马点评项目\",{\"0\":{\"953\":1}}],[\"导致大量请求到达数据库\",{\"1\":{\"986\":1}}],[\"导致大作业无法运行\",{\"1\":{\"161\":1}}],[\"导致缓存失效\",{\"1\":{\"974\":1}}],[\"导致其操作线程无法及时处理信息而瘫痪\",{\"1\":{\"974\":1}}],[\"导致不断空轮询\",{\"1\":{\"792\":1}}],[\"导致\",{\"1\":{\"491\":1}}],[\"导致redis实例卡死\",{\"1\":{\"436\":1}}],[\"导致事务需要回滚\",{\"1\":{\"396\":1}}],[\"导致每一数据的查询效率相当\",{\"1\":{\"378\":1}}],[\"导致每个元素的空间都要重新分配\",{\"1\":{\"280\":1}}],[\"导致索引失效\",{\"1\":{\"266\":1}}],[\"导致一直无法获得资源的现象\",{\"1\":{\"223\":1}}],[\"导致多道程序并发度下降\",{\"1\":{\"161\":1}}],[\"导致低地址出现很多小的难以利用的空闲区\",{\"1\":{\"155\":1}}],[\"导致各进程都阻塞\",{\"1\":{\"147\":1}}],[\"导致状态转移不完整\",{\"1\":{\"133\":1}}],[\"导致该方法的执行效果特别低\",{\"1\":{\"101\":1}}],[\"批量获取多个hash类型key的field的值\",{\"1\":{\"1027\":1}}],[\"批量添加多个hash类型key的field的值\",{\"1\":{\"1027\":1}}],[\"批量添加多个string类型的键值对\",{\"1\":{\"1025\":1}}],[\"批量添加数据\",{\"1\":{\"1024\":1}}],[\"批量插入数据\",{\"1\":{\"934\":1}}],[\"批量新增\",{\"1\":{\"934\":1}}],[\"批处理阶段引入了脱机输入\",{\"1\":{\"184\":1}}],[\"批处理命令接口\",{\"1\":{\"126\":1}}],[\"女\",{\"1\":{\"934\":2,\"941\":1}}],[\"男\",{\"1\":{\"934\":3}}],[\"男女性别\",{\"1\":{\"383\":1}}],[\"云的环境里\",{\"1\":{\"928\":1}}],[\"副本\",{\"0\":{\"928\":1},\"1\":{\"928\":1}}],[\"版设计\",{\"0\":{\"917\":1}}],[\"版本引入\",{\"1\":{\"906\":1}}],[\"版本可能会有较大重构\",{\"1\":{\"842\":1}}],[\"版本号只比原来大1\",{\"1\":{\"996\":1}}],[\"版本号\",{\"1\":{\"769\":1}}],[\"版本中\",{\"1\":{\"705\":1}}],[\"版本\",{\"1\":{\"705\":1,\"842\":1,\"923\":1}}],[\"版本选择了\",{\"1\":{\"506\":1}}],[\"信息拷入\",{\"1\":{\"905\":1}}],[\"信号驱动\",{\"1\":{\"901\":1}}],[\"信号驱动i\",{\"1\":{\"409\":1}}],[\"信号量\",{\"1\":{\"261\":1}}],[\"信号量的使用不当\",{\"1\":{\"147\":1}}],[\"信号量s就是传入的参数\",{\"1\":{\"143\":1}}],[\"信号量就是一个变量\",{\"1\":{\"143\":1}}],[\"信号量机制存在的问题\",{\"1\":{\"145\":1}}],[\"信号量机制实现前驱关系\",{\"1\":{\"144\":1}}],[\"信号量机制实现进程同步\",{\"1\":{\"144\":1}}],[\"信号量机制实现进程互斥\",{\"1\":{\"144\":1}}],[\"信号量机制\",{\"0\":{\"143\":1}}],[\"卷\",{\"1\":{\"902\":1}}],[\"专门处理\",{\"1\":{\"896\":1}}],[\"专门用于访问数据库\",{\"1\":{\"735\":1}}],[\"格式如下\",{\"1\":{\"1026\":1}}],[\"格式来表示\",{\"1\":{\"924\":1}}],[\"格式\",{\"1\":{\"890\":3}}],[\"格式的数据\",{\"1\":{\"667\":1,\"668\":1}}],[\"�好\",{\"1\":{\"889\":1}}],[\"道理是一样的\",{\"1\":{\"889\":1}}],[\"逐一处理\",{\"1\":{\"884\":1,\"886\":1}}],[\"逐一尝试右边类型是否可以被赋值给左边的\",{\"1\":{\"695\":1}}],[\"好用\",{\"1\":{\"975\":1}}],[\"好处\",{\"1\":{\"879\":1}}],[\"好了\",{\"1\":{\"276\":1}}],[\"限于网络传输能力\",{\"1\":{\"878\":1}}],[\"限制后\",{\"1\":{\"751\":1}}],[\"限制\",{\"1\":{\"751\":2}}],[\"限制⛔\",{\"1\":{\"513\":1,\"516\":1}}],[\"限制请求线程数量\",{\"1\":{\"261\":1}}],[\"限制多\",{\"1\":{\"134\":1}}],[\"几乎无消耗\",{\"1\":{\"905\":1}}],[\"几乎不能正常工作\",{\"1\":{\"876\":1}}],[\"几个分组\",{\"1\":{\"173\":1}}],[\"几个常用的数量单位\",{\"1\":{\"151\":1}}],[\"拷贝多级目录\",{\"1\":{\"873\":1}}],[\"拷贝文件\",{\"1\":{\"872\":1}}],[\"黏包\",{\"1\":{\"859\":1}}],[\"受单表数据量的限制\",{\"1\":{\"992\":1}}],[\"受gc影响\",{\"1\":{\"851\":1}}],[\"受到了特征金字塔的启发\",{\"1\":{\"24\":1}}],[\"吗\",{\"1\":{\"844\":3}}],[\"练习\",{\"0\":{\"844\":1,\"859\":1}}],[\"久经考验\",{\"1\":{\"842\":1}}],[\"文档分页查询\",{\"1\":{\"950\":1}}],[\"文档批量新增\",{\"1\":{\"950\":1}}],[\"文档文档删除\",{\"1\":{\"950\":1}}],[\"文档查询所有\",{\"1\":{\"950\":1}}],[\"文档根据id查询\",{\"1\":{\"950\":1}}],[\"文档操作\",{\"0\":{\"934\":1}}],[\"文档以json\",{\"1\":{\"924\":1}}],[\"文档\",{\"0\":{\"924\":1}}],[\"文档更优秀\",{\"1\":{\"842\":1}}],[\"文件编程\",{\"0\":{\"860\":1}}],[\"文件内容\",{\"1\":{\"858\":1}}],[\"文件内部的数据就是一系列二进制流或字符流组成\",{\"1\":{\"167\":1}}],[\"文件内部的数据应该是如何组织起来的\",{\"1\":{\"167\":1}}],[\"文件内部的数据组织形式\",{\"1\":{\"166\":1}}],[\"文件夹\",{\"1\":{\"655\":1}}],[\"文件置入\",{\"1\":{\"649\":1}}],[\"文件\",{\"0\":{\"907\":1},\"1\":{\"647\":2,\"682\":1}}],[\"文件映射内存加速和内核空间的消息传递\",{\"1\":{\"410\":1}}],[\"文件描述符在形式上是一个非负整数\",{\"1\":{\"407\":1}}],[\"文件描述符\",{\"0\":{\"407\":1},\"1\":{\"407\":1}}],[\"文件里每一行是一个词\",{\"1\":{\"289\":1}}],[\"文件系统的层次结构\",{\"0\":{\"174\":1}}],[\"文件主的伙伴\",{\"1\":{\"173\":1}}],[\"文件主\",{\"1\":{\"173\":1}}],[\"文件数据\",{\"1\":{\"172\":1}}],[\"文件存储空间管理\",{\"0\":{\"170\":1}}],[\"文件分配表需要占用一定的内存\",{\"1\":{\"169\":1}}],[\"文件分配方式\",{\"1\":{\"169\":2}}],[\"文件控制块\",{\"1\":{\"168\":1}}],[\"文件目录包括文件第一块的指针和最后一块指针\",{\"1\":{\"169\":1}}],[\"文件目录\",{\"0\":{\"168\":1}}],[\"文件检索效率\",{\"1\":{\"167\":1}}],[\"文件中的记录一个接一个的顺序排列\",{\"1\":{\"167\":1}}],[\"文件的权限等信息\",{\"1\":{\"869\":1}}],[\"文件的基本操作\",{\"0\":{\"171\":1}}],[\"文件的数据是如何存放在外存中的\",{\"1\":{\"167\":1}}],[\"文件的物理结构\",{\"0\":{\"169\":1},\"1\":{\"167\":1}}],[\"文件的逻辑结构\",{\"0\":{\"167\":1}}],[\"文件逻辑结构\",{\"1\":{\"167\":1}}],[\"文件保护\",{\"0\":{\"173\":1},\"1\":{\"166\":1}}],[\"文件共享是操作系统为用户提供文件共享功能\",{\"1\":{\"172\":1}}],[\"文件共享\",{\"0\":{\"172\":1},\"1\":{\"166\":1}}],[\"文件如何存放在外存\",{\"1\":{\"166\":1}}],[\"文件组织形式\",{\"1\":{\"166\":1}}],[\"文件区主要存放文件\",{\"1\":{\"153\":1}}],[\"文件管理等\",{\"1\":{\"130\":1}}],[\"文件管理\",{\"1\":{\"126\":1}}],[\"维护的变量就是0\",{\"1\":{\"993\":1}}],[\"维护的变量变为0\",{\"1\":{\"993\":1}}],[\"维护方便\",{\"1\":{\"984\":1}}],[\"维护成本高\",{\"1\":{\"842\":1}}],[\"维护\",{\"1\":{\"842\":1}}],[\"维护独立的\",{\"1\":{\"826\":1}}],[\"维护一个独立的\",{\"1\":{\"891\":1}}],[\"维护一个线程\",{\"1\":{\"796\":1}}],[\"维护一个row\",{\"1\":{\"387\":1}}],[\"详细分析如下\",{\"1\":{\"825\":1}}],[\"呢\",{\"1\":{\"825\":1,\"993\":1}}],[\"备注\",{\"1\":{\"822\":1}}],[\"含义\",{\"1\":{\"822\":1}}],[\"废弃字节\",{\"1\":{\"821\":1}}],[\"池化功能还不成熟\",{\"1\":{\"820\":1}}],[\"池化功能是否开启\",{\"1\":{\"820\":1}}],[\"池化功能更节约内存\",{\"1\":{\"820\":1}}],[\"池化的最大意义在于可以重用\",{\"1\":{\"820\":1}}],[\"池化\",{\"0\":{\"820\":1},\"1\":{\"831\":1}}],[\"池化基于直接内存的\",{\"1\":{\"818\":1}}],[\"压力\",{\"1\":{\"820\":1}}],[\"压力小\",{\"1\":{\"819\":1}}],[\"压缩文件需要手动生成\",{\"1\":{\"639\":1}}],[\"压缩列表只会用于保存的节点数量不多的场景\",{\"1\":{\"281\":1}}],[\"压缩列表占用的内存空间就需要重新分配\",{\"1\":{\"280\":1}}],[\"压缩列表占用的内存空间需要重新分配\",{\"1\":{\"278\":1}}],[\"压缩列表新增某个元素或修改某个元素时\",{\"1\":{\"280\":1}}],[\"压缩列表除了查找复杂度高的问题\",{\"1\":{\"280\":1}}],[\"压缩列表里的每个节点中的\",{\"1\":{\"279\":1}}],[\"压缩列表就会根据数据是字符串还是整数\",{\"1\":{\"279\":1}}],[\"压缩列表节点的\",{\"1\":{\"280\":1}}],[\"压缩列表节点包含三部分内容\",{\"1\":{\"279\":1}}],[\"压缩列表节点\",{\"1\":{\"279\":1}}],[\"压缩列表在表头有三个字段\",{\"1\":{\"279\":1}}],[\"压缩列表是\",{\"1\":{\"279\":1}}],[\"压缩列表结构设计\",{\"0\":{\"279\":1}}],[\"压缩列表的缺陷\",{\"0\":{\"281\":1}}],[\"压缩列表的缺陷也是有的\",{\"1\":{\"278\":1}}],[\"压缩列表的最大特点\",{\"1\":{\"278\":1}}],[\"压缩列表\",{\"0\":{\"278\":1},\"1\":{\"424\":1}}],[\"堆外内存最好是手动来释放\",{\"1\":{\"825\":1}}],[\"堆内存\",{\"0\":{\"819\":1}}],[\"堆中的每个节点存放每个有序小文件对应的输入流\",{\"1\":{\"291\":1}}],[\"入门案例详细步骤\",{\"1\":{\"1032\":1}}],[\"入门操作\",{\"0\":{\"930\":1}}],[\"入站\",{\"1\":{\"825\":1}}],[\"入站处理器中\",{\"1\":{\"816\":1}}],[\"入站处理器通常是\",{\"1\":{\"816\":1}}],[\"入口\",{\"1\":{\"790\":1}}],[\"填充结果\",{\"1\":{\"809\":1}}],[\"医生\",{\"1\":{\"805\":1}}],[\"💡\",{\"0\":{\"799\":1,\"887\":1}}],[\"细分2\",{\"1\":{\"798\":1}}],[\"细分1\",{\"1\":{\"798\":2}}],[\"细节应该依赖抽象\",{\"1\":{\"109\":1}}],[\"醒来后\",{\"1\":{\"792\":1}}],[\"超卖问题是典型的多线程安全问题\",{\"1\":{\"996\":1}}],[\"超时剔除\",{\"1\":{\"980\":1}}],[\"超时时才能被执行\",{\"1\":{\"792\":1}}],[\"超时时间为\",{\"1\":{\"792\":2}}],[\"超过了文件末尾\",{\"1\":{\"867\":1}}],[\"超过\",{\"1\":{\"773\":1,\"870\":1}}],[\"超过几个g\",{\"1\":{\"376\":1}}],[\"超过三个表禁止join\",{\"1\":{\"266\":1}}],[\"超过阈值\",{\"1\":{\"25\":1}}],[\"清除上一次的\",{\"1\":{\"791\":1}}],[\"清理工作\",{\"1\":{\"791\":1}}],[\"剖析\",{\"0\":{\"791\":1,\"793\":1,\"794\":1}}],[\"附件为\",{\"1\":{\"790\":1}}],[\"附录\",{\"0\":{\"3\":1,\"9\":1,\"16\":1,\"29\":1}}],[\"日志文件\",{\"1\":{\"1015\":1}}],[\"日志\",{\"1\":{\"1015\":1}}],[\"日志记录\",{\"1\":{\"790\":1,\"793\":1}}],[\"日志管理和权限管理等\",{\"1\":{\"706\":1}}],[\"立刻返回\",{\"1\":{\"882\":1}}],[\"立刻写入磁盘\",{\"1\":{\"869\":1}}],[\"立刻\",{\"1\":{\"803\":1}}],[\"立刻调用\",{\"1\":{\"790\":1}}],[\"立刻就可以开始去做其他事\",{\"1\":{\"409\":1}}],[\"序号\",{\"1\":{\"788\":1}}],[\"序列号的位数\",{\"1\":{\"993\":1}}],[\"序列号的最大值是4095\",{\"1\":{\"441\":1}}],[\"序列号\",{\"1\":{\"992\":1}}],[\"序列号最大值为4095\",{\"1\":{\"441\":2}}],[\"序列化错误\",{\"1\":{\"773\":1}}],[\"序列化方法\",{\"1\":{\"773\":1}}],[\"序列化时\",{\"1\":{\"773\":1}}],[\"序列化算法\",{\"1\":{\"769\":1}}],[\"序列化\",{\"1\":{\"104\":1,\"773\":2}}],[\"序列化反序列化\",{\"1\":{\"103\":1}}],[\"统一采用\",{\"1\":{\"781\":1}}],[\"统计score值在给定范围内的所有元素的个数\",{\"1\":{\"1030\":1}}],[\"统计出来的时间也就是所有分线程执行完后的时间\",{\"1\":{\"993\":1}}],[\"统计\",{\"1\":{\"872\":1}}],[\"统计文件夹和文件个数\",{\"1\":{\"872\":1}}],[\"统计数据表的行数只需要o\",{\"1\":{\"387\":1}}],[\"统计设备范围内常驻人口数量\",{\"1\":{\"296\":1}}],[\"统计修正等\",{\"1\":{\"268\":1}}],[\"课堂代码如下\",{\"1\":{\"1024\":1}}],[\"课堂调试关键断点为\",{\"1\":{\"776\":1}}],[\"课程中的使用方式是没有像cas一样带自旋的操作\",{\"1\":{\"996\":1}}],[\"课程中的使用方式\",{\"1\":{\"996\":1}}],[\"课题是什么以及创新点\",{\"0\":{\"300\":1}}],[\"半连接队列\",{\"1\":{\"776\":1}}],[\"半包用这种办法还是不好解决\",{\"1\":{\"753\":1}}],[\"半包\",{\"1\":{\"751\":1,\"842\":1,\"859\":1}}],[\"半包现象\",{\"0\":{\"750\":1}}],[\"队列里可以堆放多个\",{\"1\":{\"837\":1}}],[\"队列满了\",{\"1\":{\"776\":1}}],[\"队列\",{\"1\":{\"776\":1}}],[\"队列的最大长度取决于系统为进程分配了多少个内存块\",{\"1\":{\"163\":1}}],[\"魔数\",{\"1\":{\"769\":1}}],[\"束脩\",{\"1\":{\"766\":1}}],[\"肉亦可\",{\"1\":{\"766\":1}}],[\"鸭亦可\",{\"1\":{\"766\":1}}],[\"白白浪费了\",{\"1\":{\"877\":1}}],[\"白菜豆腐不可\",{\"1\":{\"766\":1}}],[\"白菜豆腐不可少\",{\"1\":{\"766\":1}}],[\"白箱\",{\"1\":{\"112\":1}}],[\"然主家亦振振有词\",{\"1\":{\"766\":1}}],[\"然后重载系统服务\",{\"1\":{\"1016\":1}}],[\"然后重新编译内核但是性能可能受到影响\",{\"1\":{\"410\":1}}],[\"然后重新调整此堆为小顶堆\",{\"1\":{\"290\":1}}],[\"然后重新提交被拒绝的任务\",{\"1\":{\"243\":1}}],[\"然后修改redis\",{\"1\":{\"1015\":1}}],[\"然后修改nginx的conf目录下的nginx\",{\"1\":{\"999\":1}}],[\"然后修改分区状态\",{\"1\":{\"154\":1}}],[\"然后大家一起去进行扣减\",{\"1\":{\"997\":1}}],[\"然后要求version\",{\"1\":{\"996\":1}}],[\"然后我们期望的是分线程全部走完之后\",{\"1\":{\"993\":1}}],[\"然后从value中判断出来当前的数据已经过期了\",{\"1\":{\"987\":1}}],[\"然后从线程中取出线程的成员变量map\",{\"1\":{\"961\":1}}],[\"然后把这个数据重新加载到缓存的\",{\"1\":{\"987\":1}}],[\"然后把缓存中的数据进行删除\",{\"1\":{\"983\":1}}],[\"然后把所有流连接成一个流\",{\"1\":{\"339\":1}}],[\"然后存入redis\",{\"1\":{\"979\":1}}],[\"然后让前端带来这个token就能完成我们的整体逻辑了\",{\"1\":{\"966\":1}}],[\"然后用这个线程转发到工程中的controller\",{\"1\":{\"961\":1}}],[\"然后用这个整数值对16384进行取模来得到具体槽位\",{\"1\":{\"435\":1}}],[\"然后和用户输入的验证码进行校验\",{\"1\":{\"959\":1}}],[\"然后切换至写模式\",{\"1\":{\"848\":1}}],[\"然后自定义捕获异常类型即可对这些捕获的异常进行统一处理\",{\"1\":{\"732\":1}}],[\"然后进行或运行\",{\"1\":{\"441\":1}}],[\"然后需要全局唯一\",{\"1\":{\"440\":1}}],[\"然后按指定的步长进行自增\",{\"1\":{\"439\":1}}],[\"然后向slave发送一个del命令\",{\"1\":{\"436\":1}}],[\"然后程序就可以执行了\",{\"1\":{\"419\":1}}],[\"然后离散的存储在不同的物理块中\",{\"1\":{\"413\":1}}],[\"然后查询每个fd对应的设备状态\",{\"1\":{\"410\":1}}],[\"然后将课前资料提供的redis安装包上传到虚拟机的任意目录\",{\"1\":{\"1012\":1}}],[\"然后将数据存入redis\",{\"1\":{\"978\":1}}],[\"然后将数据拷贝到用户内存\",{\"1\":{\"409\":1}}],[\"然后将物理块号与页内偏移地址拼接成实际物理地址\",{\"1\":{\"413\":1}}],[\"然后将对应的位数组的下标设置为\",{\"1\":{\"273\":1}}],[\"然后\",{\"1\":{\"409\":1}}],[\"然后kernel返回结果\",{\"1\":{\"409\":1}}],[\"然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"409\":1}}],[\"然后才会从操作系统的内核缓冲区拷贝到应用程序的地址空间\",{\"1\":{\"408\":1}}],[\"然后才执行实际的修改操作\",{\"1\":{\"277\":1}}],[\"然后为每条待插入记录的auto\",{\"1\":{\"400\":1}}],[\"然后对数据进行更新或删除操作时会对当前字段的version进行加一操作\",{\"1\":{\"397\":1}}],[\"然后对于\",{\"1\":{\"276\":1}}],[\"然后在任务队列的任务都处理完成后\",{\"1\":{\"797\":1}}],[\"然后在两者之间选择一个小值作为\",{\"1\":{\"751\":1}}],[\"然后在拦截其中进行拦截处理\",{\"1\":{\"368\":1}}],[\"然后在修改奖状上的名字即可\",{\"1\":{\"87\":1}}],[\"然后通过\",{\"1\":{\"327\":1}}],[\"然后返回订单id\",{\"1\":{\"995\":1}}],[\"然后返回\",{\"1\":{\"409\":1}}],[\"然后返回已经统计到的字符个数\",{\"1\":{\"276\":1}}],[\"然后返回放弃前offset行\",{\"1\":{\"266\":1}}],[\"然后唤醒entrylist中等待的线程来竞争锁\",{\"1\":{\"211\":1}}],[\"然后调度执行其他同优先级的线程\",{\"1\":{\"203\":1}}],[\"然后由操作系统的缺页中断处理程序处理中断\",{\"1\":{\"162\":1}}],[\"然后继续执行程序\",{\"1\":{\"419\":1}}],[\"然后继续执行\",{\"1\":{\"161\":1,\"162\":1}}],[\"然后采取某种措施解除死锁\",{\"1\":{\"147\":1}}],[\"然后再根据优惠卷id和用户id查询是否已经下过这个订单\",{\"1\":{\"998\":1}}],[\"然后再根据编号去调用目标方法\",{\"1\":{\"527\":1}}],[\"然后再来执行逻辑\",{\"1\":{\"987\":1}}],[\"然后再通过短信的方式将验证码发送给用户\",{\"1\":{\"959\":1}}],[\"然后再进行回表操作\",{\"1\":{\"385\":1}}],[\"然后再对它进行更新或删除\",{\"1\":{\"383\":1}}],[\"然后再关联\",{\"1\":{\"266\":1}}],[\"然后再程序中以委托的方式来使用算法\",{\"1\":{\"114\":1}}],[\"然后再把内裤外穿\",{\"1\":{\"54\":1}}],[\"遂与主家理论\",{\"1\":{\"766\":1}}],[\"丝毫未见鸡鸭鱼肉的款待\",{\"1\":{\"766\":1}}],[\"私塾先生据理力争\",{\"1\":{\"766\":1}}],[\"私塾先生临行时\",{\"1\":{\"766\":1}}],[\"私塾先生先是很不解\",{\"1\":{\"766\":1}}],[\"私塾先生虽然认真教课\",{\"1\":{\"766\":1}}],[\"私有构造方法\",{\"1\":{\"101\":7,\"103\":2,\"104\":2}}],[\"留\",{\"1\":{\"766\":1}}],[\"留我不\",{\"1\":{\"766\":1}}],[\"留客天\",{\"1\":{\"766\":1}}],[\"制定通信双方要共同遵守的通信规则\",{\"1\":{\"766\":1}}],[\"触发的原始流程\",{\"1\":{\"816\":1}}],[\"触发上一个出站处理器\",{\"1\":{\"816\":1}}],[\"触发\",{\"1\":{\"790\":3,\"793\":3,\"794\":2}}],[\"触发了写空闲事件\",{\"1\":{\"764\":1}}],[\"触发了读空闲事件\",{\"1\":{\"764\":1}}],[\"触动主动清理策略\",{\"1\":{\"429\":1}}],[\"您已被拉入\",{\"1\":{\"761\":1}}],[\"您所点的咖啡没有\",{\"1\":{\"63\":1}}],[\"群不存在\",{\"1\":{\"761\":2}}],[\"群加入成功\",{\"1\":{\"761\":1}}],[\"群管理器\",{\"1\":{\"761\":1}}],[\"群聊\",{\"0\":{\"761\":1},\"1\":{\"761\":1,\"769\":1}}],[\"登录拦截器\",{\"1\":{\"961\":1}}],[\"登录成功\",{\"1\":{\"759\":1,\"760\":1}}],[\"登录成功返回\",{\"1\":{\"758\":1}}],[\"登录\",{\"0\":{\"759\":1},\"1\":{\"758\":1,\"760\":1,\"960\":1}}],[\"登录模块\",{\"1\":{\"296\":1}}],[\"聊天组会话管理接口\",{\"1\":{\"758\":1}}],[\"聊天室业务\",{\"0\":{\"759\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1}}],[\"聊天室业务介绍\",{\"0\":{\"758\":1}}],[\"聊天室案例\",{\"0\":{\"757\":1}}],[\"聊聊树状数组\",{\"1\":{\"286\":1}}],[\"剥离字节数\",{\"1\":{\"756\":1}}],[\"剥夺调度方式\",{\"1\":{\"137\":1}}],[\"浪费\",{\"1\":{\"754\":1}}],[\"浪费了宝贵的内存资源\",{\"1\":{\"161\":1}}],[\"略\",{\"1\":{\"753\":1,\"790\":1,\"793\":1,\"999\":1}}],[\"刨去\",{\"1\":{\"751\":1}}],[\"光纤分布式数据接口\",{\"1\":{\"751\":1}}],[\"窗口关闭或者按下ctrl\",{\"1\":{\"1014\":1}}],[\"窗口就可以向前滑动\",{\"1\":{\"751\":1}}],[\"窗口必须停止滑动\",{\"1\":{\"751\":1}}],[\"窗口内的数据才允许被发送\",{\"1\":{\"751\":1}}],[\"窗口实际就起到一个缓冲区的作用\",{\"1\":{\"751\":1}}],[\"窗口大小即决定了无需等待应答而可以继续发送的数据最大值\",{\"1\":{\"751\":1}}],[\"窗口颜色和声音等元素的组合\",{\"1\":{\"107\":1}}],[\"粘包\",{\"1\":{\"751\":1}}],[\"粘包现象\",{\"0\":{\"749\":1}}],[\"粘包与半包\",{\"0\":{\"748\":1}}],[\"慢\",{\"1\":{\"745\":1}}],[\"玖\",{\"1\":{\"744\":1}}],[\"捌\",{\"1\":{\"744\":1}}],[\"柒\",{\"1\":{\"744\":1}}],[\"陆\",{\"1\":{\"744\":1}}],[\"伍\",{\"1\":{\"744\":1}}],[\"肆\",{\"1\":{\"744\":1}}],[\"肆虐的毛豆的博客\",{\"1\":{\"324\":1}}],[\"叁\",{\"1\":{\"744\":1}}],[\"贰\",{\"1\":{\"744\":1}}],[\"壹\",{\"1\":{\"744\":1}}],[\"零拷贝适合小文件传输\",{\"1\":{\"905\":1}}],[\"零拷贝的优点有\",{\"1\":{\"905\":1}}],[\"零拷贝\",{\"0\":{\"903\":1},\"1\":{\"826\":1,\"827\":1,\"829\":1,\"830\":1,\"905\":1}}],[\"零\",{\"1\":{\"744\":1}}],[\"协调这些线程执行的先后顺序\",{\"1\":{\"742\":1}}],[\"协议举例\",{\"0\":{\"767\":1,\"768\":1}}],[\"协议是这样的\",{\"1\":{\"766\":1}}],[\"协议的目的就是划定消息的边界\",{\"1\":{\"766\":1}}],[\"协议设计与解析\",{\"0\":{\"765\":1}}],[\"协议\",{\"1\":{\"653\":1}}],[\"顾名思义\",{\"1\":{\"736\":1}}],[\"顾名思义就是锁住某一行\",{\"1\":{\"401\":1}}],[\"邀请我们思考这一亘古难题\",{\"1\":{\"731\":1}}],[\"罗韦利用诗意的文字\",{\"1\":{\"731\":1}}],[\"卡洛\",{\"1\":{\"731\":1}}],[\"卡车\",{\"1\":{\"33\":1}}],[\"恰是父亲当年为她放弃的那所\",{\"1\":{\"731\":1}}],[\"湖北武汉加油中国加油\",{\"1\":{\"731\":1}}],[\"武汉加油\",{\"1\":{\"731\":1}}],[\"疫情严重\",{\"1\":{\"731\":1}}],[\"起到数据备份的作用\",{\"1\":{\"1008\":1}}],[\"起点\",{\"1\":{\"825\":1}}],[\"起步依赖本质上是一个maven项目对象模型\",{\"1\":{\"727\":1}}],[\"起始路径\",{\"1\":{\"653\":1}}],[\"起始地址\",{\"1\":{\"154\":1,\"156\":1}}],[\"起始位置\",{\"1\":{\"151\":1}}],[\"部署效率\",{\"1\":{\"726\":1}}],[\"部分\",{\"1\":{\"549\":1,\"556\":1}}],[\"部分收集\",{\"1\":{\"350\":1}}],[\"准生产级别\",{\"1\":{\"726\":1}}],[\"准备一个空\",{\"1\":{\"787\":1}}],[\"准备工作\",{\"0\":{\"783\":1}}],[\"准备容器\",{\"1\":{\"650\":1}}],[\"准备参数\",{\"1\":{\"644\":1}}],[\"准备\",{\"0\":{\"587\":1,\"594\":1,\"614\":1},\"1\":{\"568\":1,\"587\":1,\"595\":1,\"650\":1,\"809\":1}}],[\"准备对象绑定与类型转换\",{\"1\":{\"568\":1}}],[\"准备数据绑定工厂\",{\"1\":{\"644\":1}}],[\"准备数据\",{\"1\":{\"409\":1}}],[\"准备常量1\",{\"1\":{\"230\":1}}],[\"约定大于配置\",{\"1\":{\"726\":1}}],[\"约50亿年\",{\"1\":{\"265\":1}}],[\"嵌套的\",{\"1\":{\"720\":1}}],[\"拥有beanfactory的所有支持\",{\"1\":{\"707\":1}}],[\"拥有启动分区的磁盘为启动磁盘或系统磁盘\",{\"1\":{\"178\":1}}],[\"团队提倡测试驱动开发\",{\"1\":{\"705\":1}}],[\"列举一些重要的spring模块\",{\"0\":{\"705\":1}}],[\"列名\",{\"1\":{\"266\":1,\"267\":3,\"383\":1}}],[\"抛出异常\",{\"1\":{\"806\":1}}],[\"抛出\",{\"1\":{\"688\":2}}],[\"唯有一点\",{\"1\":{\"905\":1}}],[\"唯有后初始化的流程会走\",{\"1\":{\"678\":1}}],[\"唯一id\",{\"1\":{\"441\":1}}],[\"唯一的重点就是这个全局唯一id如何生成\",{\"1\":{\"315\":1}}],[\"唯一索引\",{\"1\":{\"266\":1,\"382\":1}}],[\"唯一索引名为uk字段名\",{\"1\":{\"265\":1}}],[\"唯一需要注意的是\",{\"1\":{\"96\":1}}],[\"怎么解决呢\",{\"1\":{\"981\":1}}],[\"怎么办\",{\"1\":{\"824\":1}}],[\"怎么判断客户端连接是否假死呢\",{\"1\":{\"764\":1}}],[\"怎么做呢\",{\"1\":{\"672\":2}}],[\"怎么到了\",{\"1\":{\"661\":1}}],[\"及handlermapping的配置找到处理请求的处理器\",{\"1\":{\"736\":1}}],[\"及model\",{\"1\":{\"734\":1}}],[\"及泛型\",{\"1\":{\"688\":1}}],[\"及父工厂中找类型匹配的\",{\"1\":{\"688\":1}}],[\"及事务属性\",{\"1\":{\"662\":1}}],[\"及数据\",{\"1\":{\"419\":1}}],[\"扫描被\",{\"1\":{\"731\":1}}],[\"扫描时\",{\"1\":{\"682\":1}}],[\"扫描具体包\",{\"1\":{\"661\":1}}],[\"扫描算法\",{\"1\":{\"176\":1}}],[\"├───jsp\",{\"1\":{\"653\":1}}],[\"├───classes\",{\"1\":{\"653\":1}}],[\"├───context1\",{\"1\":{\"653\":1}}],[\"├───connector\",{\"1\":{\"653\":1}}],[\"│\",{\"1\":{\"653\":9}}],[\"└───context2\",{\"1\":{\"653\":1}}],[\"└───lib\",{\"1\":{\"653\":1}}],[\"└───web\",{\"1\":{\"653\":2}}],[\"└───host\",{\"1\":{\"653\":1}}],[\"└───engine\",{\"1\":{\"653\":1}}],[\"└───service\",{\"1\":{\"653\":1}}],[\"端口分别为8081和8082\",{\"1\":{\"999\":1}}],[\"端口\",{\"1\":{\"653\":1}}],[\"绑定事件\",{\"1\":{\"881\":1}}],[\"绑定监听端口\",{\"1\":{\"876\":1,\"877\":1}}],[\"绑定的事件类型可以有\",{\"1\":{\"881\":1}}],[\"绑定的事件\",{\"1\":{\"881\":1}}],[\"绑定的监听端口\",{\"1\":{\"834\":1}}],[\"绑定的是同一个线程\",{\"1\":{\"799\":1}}],[\"绑定到\",{\"1\":{\"790\":1}}],[\"绑定端口\",{\"1\":{\"790\":1}}],[\"绑定会话\",{\"1\":{\"758\":1}}],[\"绑定\",{\"0\":{\"881\":1},\"1\":{\"650\":1,\"652\":1,\"837\":1}}],[\"阶段二\",{\"1\":{\"650\":1}}],[\"阶段一\",{\"1\":{\"650\":1}}],[\"启用的情况下\",{\"1\":{\"776\":1}}],[\"启用spring\",{\"1\":{\"731\":1}}],[\"启示\",{\"0\":{\"649\":1}}],[\"启动redis\",{\"1\":{\"1015\":1}}],[\"启动三次\",{\"1\":{\"798\":2}}],[\"启动死循环\",{\"1\":{\"791\":1}}],[\"启动剖析\",{\"0\":{\"790\":1}}],[\"启动日志\",{\"1\":{\"728\":1}}],[\"启动\",{\"0\":{\"1013\":1},\"1\":{\"655\":1,\"790\":1,\"791\":1,\"1015\":1,\"1016\":1}}],[\"启动过程\",{\"0\":{\"650\":1,\"651\":1}}],[\"启动后\",{\"1\":{\"648\":1}}],[\"启动后就初始化\",{\"1\":{\"561\":1}}],[\"启动监控器线程\",{\"1\":{\"206\":1}}],[\"启动块位于磁盘的固定位置\",{\"1\":{\"178\":1}}],[\"启动分区\",{\"1\":{\"178\":1}}],[\"启动磁头臂时间为s\",{\"1\":{\"176\":1}}],[\"骨架生成的代码中\",{\"1\":{\"648\":1}}],[\"骨架项目\",{\"0\":{\"646\":1}}],[\"插件\",{\"1\":{\"648\":1}}],[\"插入hash数据\",{\"1\":{\"1032\":1}}],[\"插入和删除快\",{\"1\":{\"1028\":1}}],[\"插入的数据必须遵守这些约束\",{\"1\":{\"1004\":1}}],[\"插入数据\",{\"1\":{\"934\":1}}],[\"插入性能差\",{\"1\":{\"392\":1}}],[\"插入一个新单词\",{\"1\":{\"282\":1}}],[\"插入排序\",{\"0\":{\"190\":1}}],[\"路径找到\",{\"1\":{\"644\":1}}],[\"路径\",{\"1\":{\"644\":1}}],[\"匹配优先级也高于\",{\"1\":{\"644\":1}}],[\"匹配\",{\"1\":{\"643\":1}}],[\"匹萨\",{\"1\":{\"33\":1}}],[\"欢迎页支持静态欢迎页与动态欢迎页\",{\"1\":{\"642\":1}}],[\"欢迎页\",{\"0\":{\"640\":1}}],[\"责任链模式体现\",{\"1\":{\"639\":1}}],[\"出站消息最终都会转为\",{\"1\":{\"825\":1}}],[\"出站处理器中\",{\"1\":{\"816\":1}}],[\"出站处理器通常是\",{\"1\":{\"816\":1}}],[\"出站\",{\"1\":{\"816\":1,\"825\":1}}],[\"出错时使用请求转发方式跳转\",{\"1\":{\"619\":1}}],[\"出现时\",{\"1\":{\"792\":1}}],[\"出现丢包\",{\"1\":{\"764\":1}}],[\"出现异常\",{\"1\":{\"644\":1}}],[\"出现了异常\",{\"1\":{\"617\":1,\"743\":1,\"744\":2}}],[\"出现这个问题的原因主要还是在于redis的过期数据删除策略\",{\"1\":{\"436\":1}}],[\"出现问题的原因是jvm在实例化对象的时候会进行优化和指令重排序操作\",{\"1\":{\"101\":1}}],[\"评论列表等\",{\"1\":{\"1028\":1}}],[\"评价\",{\"1\":{\"617\":1}}],[\"评估gc的性能指标\",{\"0\":{\"359\":1}}],[\"谁负责\",{\"1\":{\"825\":1}}],[\"谁是最后使用者\",{\"1\":{\"825\":1}}],[\"谁来负责\",{\"1\":{\"825\":1}}],[\"谁能谁先转换\",{\"1\":{\"604\":1}}],[\"谁也无法结束\",{\"1\":{\"222\":1}}],[\"走哈希思想去判断当前这个要查询的这个数据是否存在\",{\"1\":{\"984\":1}}],[\"走完一个流程\",{\"1\":{\"835\":1}}],[\"走视图解析及渲染流程\",{\"1\":{\"644\":1}}],[\"走\",{\"1\":{\"576\":2,\"617\":2,\"644\":1}}],[\"走到窗边看看风景\",{\"1\":{\"308\":1}}],[\"门面模式\",{\"1\":{\"576\":1}}],[\"委派conversionservice\",{\"1\":{\"576\":1}}],[\"省去了我们自定义redistemplate的序列化方式的步骤\",{\"1\":{\"1042\":1}}],[\"省去其他的修改操作\",{\"1\":{\"63\":1}}],[\"省略创建productlist过程\",{\"1\":{\"950\":1}}],[\"省略一些不重要的方法\",{\"1\":{\"822\":1}}],[\"省略旧的代码\",{\"1\":{\"783\":1}}],[\"省略\",{\"1\":{\"568\":2}}],[\"封装redis工具类\",{\"0\":{\"990\":1}}],[\"封装逻辑过期时间\",{\"1\":{\"989\":1}}],[\"封装起来\",{\"1\":{\"706\":1}}],[\"封装启动\",{\"1\":{\"650\":1}}],[\"封装环境键值\",{\"1\":{\"622\":1}}],[\"封装好\",{\"1\":{\"617\":1}}],[\"封装为\",{\"1\":{\"561\":1}}],[\"封装了创建对象的过程\",{\"1\":{\"64\":1}}],[\"俩是一对\",{\"1\":{\"558\":1}}],[\"体现在以下方面\",{\"1\":{\"876\":1}}],[\"体现在上面方法的\",{\"1\":{\"549\":1,\"556\":1}}],[\"体会返回值处理器的作用\",{\"1\":{\"564\":1}}],[\"体会参数解析器的作用\",{\"1\":{\"564\":1}}],[\"体积\",{\"1\":{\"194\":2}}],[\"环绕通知1返回最终的结果\",{\"1\":{\"546\":1}}],[\"环绕通知2继续将结果返回给环绕通知1\",{\"1\":{\"546\":1}}],[\"环绕通知\",{\"1\":{\"545\":3,\"549\":1,\"556\":1}}],[\"环境变量来定位\",{\"1\":{\"871\":1}}],[\"环境对象\",{\"1\":{\"652\":1}}],[\"环境容器\",{\"1\":{\"451\":3}}],[\"环境\",{\"1\":{\"446\":1,\"449\":1,\"646\":1}}],[\"形成类似于这样的结构\",{\"1\":{\"1026\":1}}],[\"形成一套规范\",{\"1\":{\"110\":1}}],[\"形式\",{\"1\":{\"545\":1}}],[\"资格\",{\"1\":{\"539\":3}}],[\"资源\",{\"1\":{\"246\":1,\"446\":1,\"449\":1,\"682\":1}}],[\"资源的循环链\",{\"1\":{\"221\":1}}],[\"资源剥夺法\",{\"1\":{\"150\":1}}],[\"资源利用率低\",{\"1\":{\"148\":1,\"164\":1}}],[\"资源共享分为\",{\"1\":{\"127\":1}}],[\"资源共享\",{\"1\":{\"127\":1}}],[\"典型接口为\",{\"1\":{\"528\":1}}],[\"典型实现\",{\"1\":{\"528\":1}}],[\"典型功能有\",{\"1\":{\"446\":1}}],[\"切片后的\",{\"1\":{\"826\":3}}],[\"切面统一为低级\",{\"1\":{\"539\":1}}],[\"切面\",{\"0\":{\"529\":1},\"1\":{\"528\":1,\"539\":1}}],[\"切面的抽象如下\",{\"1\":{\"528\":1}}],[\"切点是什么\",{\"1\":{\"545\":1}}],[\"切点实现\",{\"1\":{\"535\":1}}],[\"切点的局限性\",{\"1\":{\"535\":1}}],[\"切点用法\",{\"1\":{\"535\":1}}],[\"切点匹配\",{\"0\":{\"532\":1,\"533\":1}}],[\"切点\",{\"1\":{\"528\":1}}],[\"切换读模式\",{\"1\":{\"865\":1}}],[\"切换读写模式\",{\"1\":{\"332\":1}}],[\"切换为读取限制\",{\"1\":{\"848\":1}}],[\"切换为读取位置\",{\"1\":{\"848\":1}}],[\"切换至写模式\",{\"1\":{\"847\":1}}],[\"切换至读模式\",{\"1\":{\"847\":1}}],[\"切换\",{\"1\":{\"137\":1,\"846\":2}}],[\"切换与过程的调度方式\",{\"0\":{\"137\":1}}],[\"切换的工作都是由内核负责\",{\"1\":{\"135\":1}}],[\"切换进程\",{\"1\":{\"135\":1}}],[\"切换同进程内的线程\",{\"1\":{\"135\":1}}],[\"额外提供了下面几个方法\",{\"1\":{\"527\":1}}],[\"额外的内存消耗\",{\"1\":{\"984\":1}}],[\"额外的检查\",{\"1\":{\"406\":1}}],[\"额外的这个线程就能顶上去\",{\"1\":{\"246\":1}}],[\"次\",{\"1\":{\"824\":1,\"904\":2,\"905\":2}}],[\"次发送\",{\"1\":{\"753\":1}}],[\"次接收\",{\"1\":{\"749\":1}}],[\"次调用生成的代理类\",{\"1\":{\"519\":1}}],[\"次调用会生成代理类\",{\"1\":{\"519\":1}}],[\"次反射性能较低\",{\"1\":{\"519\":1}}],[\"次方\",{\"1\":{\"277\":2}}],[\"配合\",{\"1\":{\"671\":1}}],[\"配合目标对象一起使用\",{\"1\":{\"527\":1}}],[\"配合代理对象一起使用\",{\"1\":{\"527\":1}}],[\"配合接口方法反射\",{\"1\":{\"516\":1}}],[\"配置连接池\",{\"1\":{\"1034\":1}}],[\"配置反向代理和负载均衡\",{\"1\":{\"999\":1}}],[\"配置或spring容器中是否存在某个bean等\",{\"1\":{\"730\":1}}],[\"配置相应的初始化参数\",{\"1\":{\"730\":1}}],[\"配置视图路径\",{\"1\":{\"647\":1}}],[\"配置了\",{\"1\":{\"617\":1}}],[\"配置为\",{\"1\":{\"617\":1}}],[\"配置\",{\"1\":{\"582\":1,\"648\":1,\"665\":1,\"897\":1}}],[\"配置类编写\",{\"0\":{\"949\":1}}],[\"配置类包含\",{\"1\":{\"491\":1}}],[\"配置类不包含\",{\"1\":{\"491\":1}}],[\"配置类\",{\"0\":{\"491\":1},\"1\":{\"491\":1}}],[\"配置类的容器\",{\"1\":{\"451\":1}}],[\"配置文件的容器\",{\"1\":{\"451\":1}}],[\"配置文件\",{\"0\":{\"1039\":1},\"1\":{\"451\":2,\"773\":1}}],[\"配置中心\",{\"1\":{\"433\":1}}],[\"配置数据源信息\",{\"1\":{\"372\":1}}],[\"配置映射关系\",{\"1\":{\"268\":1}}],[\"置为\",{\"1\":{\"791\":1}}],[\"置为1\",{\"1\":{\"234\":1}}],[\"置于代理类之外\",{\"1\":{\"516\":1}}],[\"⬇️如果存在\",{\"1\":{\"672\":1}}],[\"⬇️该方法从\",{\"1\":{\"670\":1}}],[\"⬇️通过\",{\"1\":{\"657\":1}}],[\"⬇️原始资源解析\",{\"1\":{\"638\":1}}],[\"⬇️压缩优化\",{\"1\":{\"638\":1}}],[\"⬇️缓存优化\",{\"1\":{\"638\":1}}],[\"⬇️handler\",{\"1\":{\"630\":1}}],[\"⬇️映射条件\",{\"1\":{\"630\":1}}],[\"⬇️调用代理方法\",{\"1\":{\"523\":1}}],[\"⬇️调用目标方法\",{\"1\":{\"523\":1}}],[\"⬇️4\",{\"1\":{\"515\":1}}],[\"⬇️3\",{\"1\":{\"515\":1}}],[\"⬇️这就是\",{\"1\":{\"515\":1}}],[\"秘密都在里面\",{\"1\":{\"515\":1}}],[\"侵入性较强\",{\"1\":{\"504\":1}}],[\"织入增强功能\",{\"1\":{\"504\":1}}],[\"织入到目标类的字节码中\",{\"1\":{\"504\":1}}],[\"仍然占用着资源\",{\"1\":{\"764\":1}}],[\"仍然使用\",{\"1\":{\"500\":1}}],[\"仍应被施加于原始对象\",{\"1\":{\"542\":1}}],[\"仍指向原有属性所指向的对象的内存地址\",{\"1\":{\"86\":1}}],[\"期望满足一定条件才能被\",{\"1\":{\"672\":1}}],[\"期望是多例\",{\"1\":{\"500\":1}}],[\"期间发生了什么\",{\"1\":{\"198\":1}}],[\"刷新token有效期\",{\"1\":{\"972\":1}}],[\"刷新\",{\"1\":{\"498\":1}}],[\"⬅️加入条件\",{\"1\":{\"672\":1}}],[\"⬅️本项目的配置类\",{\"1\":{\"670\":1}}],[\"⬅️第三方的配置类\",{\"1\":{\"670\":2}}],[\"⬅️收集容器中所有\",{\"1\":{\"622\":1}}],[\"⬅️名称为\",{\"1\":{\"622\":1}}],[\"⬅️errorproperties\",{\"1\":{\"622\":1}}],[\"⬅️tomcatservletwebserverfactory\",{\"1\":{\"619\":1}}],[\"⬅️修改了\",{\"1\":{\"619\":1}}],[\"⬅️非反射调用\",{\"1\":{\"523\":2}}],[\"⬅️反射调用\",{\"1\":{\"523\":1}}],[\"⬅️\",{\"1\":{\"491\":1}}],[\"失效\",{\"0\":{\"500\":1}}],[\"失效分析\",{\"0\":{\"491\":1}}],[\"失败的原因在于\",{\"1\":{\"997\":1}}],[\"失败的后备预案\",{\"1\":{\"360\":1}}],[\"失败随时都可能发生\",{\"1\":{\"928\":1}}],[\"失败返回\",{\"1\":{\"758\":1}}],[\"失败了就走失败的流程\",{\"1\":{\"313\":1}}],[\"失败演示\",{\"1\":{\"212\":1}}],[\"框架集成\",{\"0\":{\"947\":1}}],[\"框架在\",{\"1\":{\"841\":1}}],[\"框架\",{\"0\":{\"782\":1},\"1\":{\"841\":2}}],[\"框架的支持\",{\"1\":{\"705\":2}}],[\"框架的工具类\",{\"1\":{\"244\":1}}],[\"框架内部的类常用内置注入和初始化\",{\"1\":{\"490\":1}}],[\"技术\",{\"1\":{\"480\":1,\"644\":1}}],[\"技术大佬沃兹我也很喜欢\",{\"1\":{\"306\":1}}],[\"泛型创建\",{\"1\":{\"695\":1}}],[\"泛型找到\",{\"1\":{\"695\":1}}],[\"泛型\",{\"1\":{\"470\":1,\"695\":1}}],[\"销毁前执行的方法\",{\"1\":{\"711\":1}}],[\"销毁不归容器管\",{\"1\":{\"710\":1}}],[\"销毁机制疑似实现有误\",{\"1\":{\"499\":1}}],[\"销毁之前的增强\",{\"1\":{\"460\":1}}],[\"销毁\",{\"1\":{\"458\":1,\"496\":1}}],[\"注解进行查找\",{\"1\":{\"736\":1}}],[\"注解了解吗\",{\"0\":{\"722\":1}}],[\"注解的作用与\",{\"1\":{\"661\":1}}],[\"注解的接口\",{\"1\":{\"661\":2}}],[\"注解的平级\",{\"1\":{\"466\":1}}],[\"注解且返回非简单类型时\",{\"1\":{\"600\":1}}],[\"注解时\",{\"1\":{\"600\":2}}],[\"注解来辅助获得参数名\",{\"1\":{\"572\":1}}],[\"注释或添加\",{\"1\":{\"491\":1}}],[\"注入redistemplate\",{\"1\":{\"1040\":1}}],[\"注入其它\",{\"0\":{\"500\":1},\"1\":{\"496\":1}}],[\"注入\",{\"1\":{\"490\":4,\"491\":1}}],[\"注册到\",{\"1\":{\"790\":1,\"893\":1}}],[\"注册到容器中\",{\"1\":{\"486\":1}}],[\"注册\",{\"1\":{\"769\":1,\"790\":2,\"793\":1,\"890\":1,\"959\":1}}],[\"注册拦截器\",{\"1\":{\"738\":2}}],[\"注册所有\",{\"1\":{\"619\":1}}],[\"注册一个\",{\"1\":{\"454\":1}}],[\"注意到复制分片从不与原\",{\"1\":{\"928\":1}}],[\"注意各种异常\",{\"1\":{\"825\":1}}],[\"注意不能仅捕获\",{\"1\":{\"815\":1}}],[\"注意不是到了串行化才解决了幻读\",{\"1\":{\"393\":1}}],[\"注意不是threadlocal对象\",{\"1\":{\"247\":1}}],[\"注意发送的数据未必能够一次读完\",{\"1\":{\"794\":1}}],[\"注意⚠️\",{\"0\":{\"792\":1}}],[\"注意此时没有注册\",{\"1\":{\"790\":1}}],[\"注意文件名与控制器方法返回的视图逻辑名一致\",{\"1\":{\"647\":1}}],[\"注意事项\",{\"0\":{\"443\":1}}],[\"注意这里使用synchronized同步\",{\"1\":{\"441\":1}}],[\"注意两种结构都需要考虑是在中间操作还是在两端操作\",{\"1\":{\"322\":1}}],[\"注意字符统计函数的区别\",{\"1\":{\"267\":1}}],[\"注意线程池线程数和cyclicbarrier的计数要一样\",{\"1\":{\"263\":1}}],[\"注意callable中的是call方法\",{\"1\":{\"202\":1}}],[\"注意每次读写的只能是连续的多个块\",{\"1\":{\"181\":1}}],[\"注意\",{\"1\":{\"42\":1,\"49\":1,\"89\":1,\"120\":1,\"147\":1,\"154\":1,\"158\":1,\"163\":1,\"180\":1,\"211\":1,\"267\":1,\"282\":1,\"350\":1,\"443\":1,\"449\":1,\"450\":1,\"491\":1,\"500\":1,\"506\":1,\"519\":1,\"523\":1,\"531\":1,\"670\":1,\"750\":1,\"754\":1,\"792\":1,\"803\":1,\"822\":1,\"854\":1,\"987\":1,\"998\":1,\"1030\":1}}],[\"旧\",{\"1\":{\"451\":4}}],[\"演示主类推断\",{\"1\":{\"652\":1}}],[\"演示\",{\"0\":{\"488\":1,\"493\":1,\"521\":1,\"525\":1,\"529\":1,\"533\":1,\"554\":1,\"566\":1,\"570\":1,\"587\":1,\"594\":1,\"598\":1,\"602\":1,\"606\":1,\"610\":1,\"614\":1,\"625\":1,\"629\":1,\"651\":1,\"669\":1,\"676\":1,\"680\":1,\"684\":1,\"689\":1,\"693\":1,\"697\":1,\"701\":1,\"798\":1,\"800\":1,\"801\":1}}],[\"演示4\",{\"0\":{\"484\":1}}],[\"演示3\",{\"0\":{\"464\":1,\"481\":1,\"543\":1,\"583\":1,\"640\":1}}],[\"演示2\",{\"0\":{\"450\":1,\"455\":1,\"462\":1,\"471\":1,\"478\":1,\"501\":1,\"512\":1,\"517\":1,\"540\":1,\"550\":1,\"562\":1,\"580\":1,\"621\":1,\"637\":1,\"656\":1}}],[\"演示1\",{\"0\":{\"447\":1,\"452\":1,\"459\":1,\"468\":1,\"475\":1,\"497\":1,\"510\":1,\"515\":1,\"537\":1,\"547\":1,\"559\":1,\"577\":1,\"618\":1,\"633\":1,\"654\":1}}],[\"学会查询就好啦\",{\"1\":{\"1023\":1}}],[\"学习一种特殊的\",{\"1\":{\"673\":1}}],[\"学到\",{\"1\":{\"449\":1}}],[\"学生表中的student\",{\"1\":{\"267\":1}}],[\"学生类\",{\"1\":{\"89\":1}}],[\"收一个小尾巴\",{\"1\":{\"1043\":1}}],[\"收到\",{\"1\":{\"776\":3}}],[\"收获💡\",{\"0\":{\"449\":1,\"454\":1,\"457\":1,\"461\":1,\"466\":1,\"470\":1,\"473\":1,\"477\":1,\"480\":1,\"483\":1,\"486\":1,\"490\":1,\"495\":1,\"499\":1,\"503\":1,\"506\":1,\"508\":1,\"511\":1,\"513\":1,\"516\":1,\"519\":1,\"523\":1,\"527\":1,\"531\":1,\"535\":1,\"539\":1,\"542\":1,\"545\":1,\"549\":1,\"552\":1,\"556\":1,\"561\":1,\"564\":1,\"568\":1,\"572\":1,\"579\":1,\"582\":1,\"585\":1,\"588\":1,\"596\":1,\"600\":1,\"604\":1,\"608\":1,\"612\":1,\"616\":1,\"620\":1,\"623\":1,\"627\":1,\"631\":1,\"636\":1,\"639\":1,\"642\":1,\"652\":1,\"671\":1,\"673\":1,\"678\":1,\"682\":1,\"686\":1,\"691\":1,\"695\":1,\"699\":1,\"703\":1}}],[\"收集操作发生的频率\",{\"1\":{\"359\":1}}],[\"收集频率\",{\"1\":{\"359\":1}}],[\"收集整个java堆和方法区的垃圾收集\",{\"1\":{\"350\":1}}],[\"收集整个新生代以及部分老年代的垃圾收集\",{\"1\":{\"350\":1}}],[\"收集\",{\"0\":{\"343\":1}}],[\"国际化信息支持\",{\"1\":{\"707\":1}}],[\"国际化文件名固定为\",{\"1\":{\"450\":1}}],[\"国际化文件均在\",{\"1\":{\"450\":1}}],[\"国际化\",{\"0\":{\"450\":1},\"1\":{\"446\":1,\"449\":1}}],[\"容易崩溃\",{\"1\":{\"955\":1}}],[\"容器下\",{\"1\":{\"897\":1}}],[\"容器启动的时间较beanfactory也会长一些\",{\"1\":{\"707\":1}}],[\"容器启动初期速度较快\",{\"1\":{\"707\":1}}],[\"容器启动时创建\",{\"1\":{\"496\":1}}],[\"容器的创建\",{\"1\":{\"652\":1}}],[\"容器中找一些\",{\"1\":{\"561\":1}}],[\"容器停止时销毁\",{\"1\":{\"496\":1}}],[\"容器用到此\",{\"1\":{\"496\":1}}],[\"容器关闭时销毁\",{\"1\":{\"496\":1}}],[\"容器\",{\"0\":{\"656\":1},\"1\":{\"490\":2,\"617\":1,\"650\":1}}],[\"容器实现\",{\"0\":{\"451\":1},\"1\":{\"457\":1}}],[\"容器接口\",{\"0\":{\"446\":1}}],[\"容器与\",{\"0\":{\"445\":1}}],[\"容量不够了\",{\"1\":{\"823\":1}}],[\"容量\",{\"1\":{\"328\":1,\"332\":1}}],[\"掩码\",{\"1\":{\"441\":1}}],[\"纪年\",{\"1\":{\"441\":1}}],[\"机房等\",{\"1\":{\"764\":1}}],[\"机器\",{\"1\":{\"443\":1}}],[\"机器号+服务号\",{\"1\":{\"440\":1}}],[\"机器id+服务id\",{\"1\":{\"440\":1}}],[\"机制是java集合\",{\"1\":{\"324\":1}}],[\"背压可以理解为订阅者能和发布者交互\",{\"1\":{\"745\":1}}],[\"背压\",{\"0\":{\"745\":1}}],[\"背景\",{\"0\":{\"439\":1}}],[\"背包体积\",{\"1\":{\"194\":1}}],[\"背包问题开始讲起吧\",{\"1\":{\"194\":1}}],[\"背包问题\",{\"1\":{\"194\":1,\"195\":1}}],[\"背包\",{\"0\":{\"193\":1},\"1\":{\"195\":1}}],[\"雪花算法中41位比特位不是直接用来存储当前服务器毫秒时间戳的\",{\"1\":{\"443\":1}}],[\"雪花算法服务需要部署的节点超过1024台\",{\"1\":{\"443\":1}}],[\"雪花算法有如下缺点\",{\"1\":{\"442\":1}}],[\"雪花算法有以下几个优点\",{\"1\":{\"442\":1}}],[\"雪花算法原理就是生成一个的64位比特位的\",{\"1\":{\"440\":1}}],[\"雪花算法是其中一个用于解决分布式\",{\"1\":{\"439\":1}}],[\"雪花算法详解与实现\",{\"1\":{\"438\":1}}],[\"雪花算法\",{\"0\":{\"438\":1,\"440\":1},\"1\":{\"440\":1}}],[\"雪橇\",{\"1\":{\"33\":1}}],[\"陷入死循环\",{\"1\":{\"436\":1}}],[\"告知slave也删除这个key\",{\"1\":{\"436\":1}}],[\"告诉发布者后面不接受数据了\",{\"1\":{\"743\":1,\"744\":2}}],[\"告诉他read操作完成了\",{\"1\":{\"409\":1}}],[\"告诉其他人这个数据页或数据表已经有人给它上过排他锁了\",{\"1\":{\"400\":1}}],[\"告诉编译器取消结构体在编译过程中的优化对齐\",{\"1\":{\"277\":1}}],[\"槽位定位算法\",{\"1\":{\"435\":1}}],[\"槽位的信息存储于每个节点中\",{\"1\":{\"435\":1}}],[\"据官方文档称可以线性扩展到上万个节点\",{\"1\":{\"434\":1}}],[\"涉及到了分布式选举\",{\"1\":{\"433\":1}}],[\"影响的底层接收缓冲区\",{\"1\":{\"750\":1}}],[\"影响数据恢复或主从同步的效率\",{\"1\":{\"433\":1}}],[\"影响查询性能\",{\"1\":{\"266\":1}}],[\"哨兵\",{\"1\":{\"433\":1}}],[\"哨兵通常需要3个实例\",{\"1\":{\"433\":1}}],[\"哨兵集群还是能正常工作的\",{\"1\":{\"433\":1}}],[\"哨兵用于实现redis集群的高可用\",{\"1\":{\"433\":1}}],[\"哨兵是redis集群中非常重要的一个组件\",{\"1\":{\"433\":1}}],[\"哨兵的配置略微复杂\",{\"1\":{\"433\":1}}],[\"哨兵模式\",{\"0\":{\"433\":1}}],[\"惰性删除对cpu更加友好\",{\"1\":{\"427\":1}}],[\"惰性删除\",{\"1\":{\"427\":1}}],[\"永远为0\",{\"1\":{\"992\":1}}],[\"永不过时\",{\"1\":{\"426\":1}}],[\"永久\",{\"1\":{\"419\":1}}],[\"折半查找\",{\"1\":{\"425\":1}}],[\"跳过对齐填充的一个字节\",{\"1\":{\"770\":1}}],[\"跳过元素\",{\"1\":{\"338\":1}}],[\"跳表\",{\"1\":{\"424\":1}}],[\"集成\",{\"0\":{\"656\":1}}],[\"集群环境下\",{\"1\":{\"999\":1}}],[\"集群环境下的并发问题\",{\"0\":{\"999\":1}}],[\"集群模式\",{\"0\":{\"434\":1}}],[\"集群监控\",{\"1\":{\"433\":1}}],[\"集群数据同步等\",{\"1\":{\"423\":1}}],[\"集合中真正删除\",{\"1\":{\"890\":1}}],[\"集合中移除\",{\"1\":{\"887\":1}}],[\"集合中删除\",{\"1\":{\"886\":1,\"888\":1,\"890\":1}}],[\"集合\",{\"1\":{\"430\":1,\"574\":1,\"695\":1,\"758\":2,\"887\":1}}],[\"集合运算\",{\"1\":{\"422\":1}}],[\"集上面二者的优点\",{\"1\":{\"135\":1}}],[\"介绍一下sprig\",{\"0\":{\"738\":1}}],[\"介绍一下spring\",{\"0\":{\"736\":1}}],[\"介绍spring\",{\"0\":{\"728\":1}}],[\"介绍\",{\"1\":{\"422\":5}}],[\"介绍页\",{\"0\":{\"0\":1}}],[\"哪怕此时redis中的数据过期了\",{\"1\":{\"984\":1}}],[\"哪个\",{\"1\":{\"758\":4}}],[\"哪一个页面是未来最长时间内不再被访问的\",{\"1\":{\"420\":1}}],[\"哪些情况不适合创建索引\",{\"0\":{\"384\":1}}],[\"哪些情况适合创建索引\",{\"0\":{\"383\":1}}],[\"哪些因素导致你如此担心这件事情\",{\"1\":{\"309\":1}}],[\"腾出足够的内存空间后\",{\"1\":{\"418\":1}}],[\"功能丰富\",{\"1\":{\"1009\":1}}],[\"功能的实现提供一些最基础的支持\",{\"1\":{\"705\":1}}],[\"功能\",{\"1\":{\"574\":1,\"806\":1}}],[\"功能将它们调入内存\",{\"1\":{\"418\":1}}],[\"功能和目标\",{\"1\":{\"126\":1}}],[\"顺序\",{\"1\":{\"837\":1}}],[\"顺序执行的\",{\"1\":{\"417\":1}}],[\"顺序文件\",{\"1\":{\"167\":1}}],[\"到达服务器端\",{\"1\":{\"835\":1}}],[\"到关闭状态从而拒绝新的任务的加入\",{\"1\":{\"797\":1}}],[\"到再循环进来这个阶段新增的任务会不会及时执行呢\",{\"1\":{\"791\":1}}],[\"到\",{\"0\":{\"536\":1},\"1\":{\"650\":1,\"776\":1,\"793\":1,\"826\":1,\"845\":2}}],[\"到底什么是\",{\"1\":{\"449\":1}}],[\"到在内存中找到对应的实际物理地址单元并取出数据\",{\"1\":{\"413\":1}}],[\"到作业完成为止的这段时间间隔\",{\"1\":{\"138\":1}}],[\"视图\",{\"1\":{\"647\":1,\"734\":1}}],[\"视图名固定为\",{\"1\":{\"642\":1}}],[\"视情况而定\",{\"1\":{\"410\":1}}],[\"视频中未讲解\",{\"1\":{\"703\":1}}],[\"视频的每一帧就相当于一张图片\",{\"1\":{\"300\":1}}],[\"视频文化这样的二进制数据\",{\"1\":{\"276\":1}}],[\"毕竟epoll的通知机制需要很多函数回调\",{\"1\":{\"410\":1}}],[\"线路上存在a\",{\"1\":{\"845\":1}}],[\"线性下降性能问题\",{\"1\":{\"410\":1}}],[\"线程读取过程中不需要等待\",{\"1\":{\"987\":1}}],[\"线程去进行\",{\"1\":{\"987\":1}}],[\"线程2\",{\"1\":{\"996\":1}}],[\"线程2也去查询库存\",{\"1\":{\"996\":1}}],[\"线程2获得到锁\",{\"1\":{\"987\":1}}],[\"线程2在执行过程中\",{\"1\":{\"987\":1}}],[\"线程4同时过来访问当前这个方法\",{\"1\":{\"987\":1}}],[\"线程3也直接返回数据\",{\"1\":{\"987\":1}}],[\"线程3\",{\"1\":{\"987\":1}}],[\"线程1再执行更新动作时\",{\"1\":{\"982\":1}}],[\"线程会找到用户想要访问的工程\",{\"1\":{\"961\":1}}],[\"线程仅能处理一个\",{\"1\":{\"916\":1}}],[\"线程上下文切换成本高\",{\"1\":{\"914\":1}}],[\"线程上执行\",{\"1\":{\"790\":1}}],[\"线程需要等待结果\",{\"1\":{\"906\":1}}],[\"线程自己不去获取结果\",{\"1\":{\"901\":1}}],[\"线程自己去获取结果\",{\"1\":{\"901\":1}}],[\"线程才会恢复运行\",{\"1\":{\"890\":1}}],[\"线程阻塞\",{\"1\":{\"890\":1}}],[\"线程大部分时间都在做无用功\",{\"1\":{\"878\":1}}],[\"线程仍然会继续运行\",{\"1\":{\"877\":1}}],[\"线程仍然在不断运行\",{\"1\":{\"877\":1}}],[\"线程还会继续运行\",{\"1\":{\"877\":1}}],[\"线程实际还是阻塞的\",{\"1\":{\"877\":1}}],[\"线程只是等待数据写入\",{\"1\":{\"877\":1}}],[\"线程停止运行\",{\"1\":{\"876\":2}}],[\"线程连接建立好之后\",{\"1\":{\"803\":1}}],[\"线程被打断\",{\"1\":{\"792\":1}}],[\"线程唤醒\",{\"1\":{\"792\":1}}],[\"线程调用\",{\"1\":{\"792\":1}}],[\"线程来调用\",{\"1\":{\"792\":1}}],[\"线程抢先将\",{\"1\":{\"791\":1}}],[\"线程和提交任务线程都有可能执行\",{\"1\":{\"791\":1}}],[\"线程执行接下来的操作\",{\"1\":{\"790\":1}}],[\"线程间的依赖顺序是一件非常麻烦的事情\",{\"1\":{\"742\":1}}],[\"线程间并发\",{\"1\":{\"135\":1}}],[\"线程变量中如果有province字段\",{\"1\":{\"368\":1}}],[\"线程持有的锁\",{\"1\":{\"353\":1}}],[\"线程不必等待结果\",{\"1\":{\"906\":1}}],[\"线程不仅要处理\",{\"1\":{\"791\":1}}],[\"线程不被回收\",{\"1\":{\"247\":1}}],[\"线程不安全\",{\"1\":{\"101\":2}}],[\"线程个数始终为1\",{\"1\":{\"244\":1}}],[\"线程数固定为\",{\"1\":{\"244\":1}}],[\"线程工厂\",{\"1\":{\"242\":1}}],[\"线程池版缺点⚠️\",{\"0\":{\"916\":1}}],[\"线程池版设计\",{\"0\":{\"915\":1}}],[\"线程池创建多少线程合适\",{\"0\":{\"246\":1}}],[\"线程池状态\",{\"0\":{\"241\":1}}],[\"线程池的好处\",{\"0\":{\"240\":1}}],[\"线程池\",{\"0\":{\"239\":1},\"1\":{\"807\":1,\"834\":1}}],[\"线程池以及字符串连接池都运用了享元模式的思想\",{\"1\":{\"238\":1}}],[\"线程交替输出\",{\"0\":{\"225\":1}}],[\"线程已经拥有了至少一种资\",{\"1\":{\"221\":1}}],[\"线程刚被创建\",{\"1\":{\"208\":1}}],[\"线程状态\",{\"0\":{\"208\":1}}],[\"线程休眠\",{\"1\":{\"206\":1}}],[\"线程优先级\",{\"0\":{\"205\":1}}],[\"线程启动后自动调用\",{\"1\":{\"202\":1}}],[\"线程切换由操作系统内核完成\",{\"1\":{\"135\":1}}],[\"线程切换可以在用户态下完成\",{\"1\":{\"135\":1}}],[\"线程管理的系统开销小\",{\"1\":{\"135\":1}}],[\"线程的切换\",{\"1\":{\"790\":1,\"793\":1}}],[\"线程的方法\",{\"1\":{\"235\":1}}],[\"线程的状态\",{\"1\":{\"208\":1}}],[\"线程的状态转换\",{\"1\":{\"208\":1}}],[\"线程的管理工作是操作系统内核完成\",{\"1\":{\"135\":1}}],[\"线程的实现方式\",{\"1\":{\"135\":1}}],[\"线程的属性\",{\"1\":{\"135\":1}}],[\"线程几乎不拥有系统资源\",{\"1\":{\"135\":1}}],[\"线程也有就绪\",{\"1\":{\"135\":1}}],[\"线程控制块\",{\"1\":{\"135\":1}}],[\"线程是稀缺资源\",{\"1\":{\"240\":1}}],[\"线程是处理机调度的单位\",{\"1\":{\"135\":1}}],[\"线程是调度的基本单位\",{\"1\":{\"135\":1}}],[\"线程是一个基本的cpu执行单位\",{\"1\":{\"135\":1}}],[\"线程是程序执行流的最小单位\",{\"1\":{\"135\":1}}],[\"线程概念\",{\"1\":{\"135\":1}}],[\"线程\",{\"0\":{\"135\":1},\"1\":{\"219\":1,\"759\":1,\"787\":1,\"790\":3,\"791\":1,\"792\":1,\"793\":2}}],[\"线程安全问题\",{\"1\":{\"101\":1}}],[\"线程安全\",{\"1\":{\"101\":2}}],[\"迅速激活这个文件描述符\",{\"1\":{\"410\":1}}],[\"水平触发和边缘触发\",{\"1\":{\"410\":1}}],[\"水平触发\",{\"1\":{\"410\":1}}],[\"套接字描述符\",{\"1\":{\"409\":1}}],[\"套娃\",{\"1\":{\"158\":1}}],[\"监听的端口\",{\"1\":{\"1015\":1}}],[\"监听所有\",{\"1\":{\"893\":1}}],[\"监听\",{\"0\":{\"882\":1}}],[\"监听器发送通知\",{\"1\":{\"728\":1}}],[\"监听器会统一转换为\",{\"1\":{\"703\":1}}],[\"监视\",{\"1\":{\"409\":1}}],[\"监控器运行中\",{\"1\":{\"206\":1}}],[\"寄存器\",{\"1\":{\"406\":2}}],[\"较之被动的超时方案\",{\"1\":{\"403\":1}}],[\"闭区间\",{\"1\":{\"401\":1}}],[\"临键锁\",{\"1\":{\"401\":1}}],[\"临界区\",{\"1\":{\"140\":1}}],[\"临界资源\",{\"1\":{\"140\":1}}],[\"兼容\",{\"1\":{\"398\":1,\"400\":5}}],[\"乐观锁解决超卖问题\",{\"0\":{\"997\":1}}],[\"乐观锁的典型代表\",{\"1\":{\"996\":1}}],[\"乐观锁的时间戳机制\",{\"1\":{\"397\":1}}],[\"乐观锁的版本号机制\",{\"1\":{\"397\":1}}],[\"乐观锁也是一种思想\",{\"1\":{\"397\":1}}],[\"乐观锁\",{\"1\":{\"397\":1,\"996\":2}}],[\"乐观读\",{\"1\":{\"260\":2}}],[\"悲观锁中又可以再细分为公平锁\",{\"1\":{\"996\":1}}],[\"悲观锁可以实现对于数据的串行化执行\",{\"1\":{\"996\":1}}],[\"悲观锁是一种思想\",{\"1\":{\"397\":1}}],[\"悲观锁\",{\"1\":{\"397\":1,\"996\":1}}],[\"获得age\",{\"1\":{\"1025\":1}}],[\"获得了锁的线程他会开启一个\",{\"1\":{\"987\":1}}],[\"获得到正确的\",{\"1\":{\"803\":1}}],[\"获得对应的消息\",{\"1\":{\"773\":1}}],[\"获得\",{\"1\":{\"546\":1}}],[\"获得锁之后\",{\"1\":{\"396\":1}}],[\"获取数据\",{\"1\":{\"1032\":1,\"1042\":1}}],[\"获取一个hash类型的key中的所有的field\",{\"1\":{\"1027\":1}}],[\"获取一个hash类型的key中的所有的field和value\",{\"1\":{\"1027\":1}}],[\"获取一个hash类型key的field的值\",{\"1\":{\"1027\":1}}],[\"获取锁成功\",{\"1\":{\"990\":1}}],[\"获取锁失败\",{\"1\":{\"990\":1}}],[\"获取锁失败的线程都将进入到这个队列中排队\",{\"1\":{\"253\":1}}],[\"获取string数据\",{\"1\":{\"1040\":1,\"1042\":1}}],[\"获取sorted\",{\"1\":{\"1030\":3}}],[\"获取set中的所有元素\",{\"1\":{\"1029\":1}}],[\"获取session中的用户\",{\"1\":{\"961\":1}}],[\"获取session\",{\"1\":{\"961\":1}}],[\"获取singleton类的私有无参构造方法对象\",{\"1\":{\"103\":1}}],[\"获取singleton类的字节码对象\",{\"1\":{\"103\":1}}],[\"获取singleton类的对象\",{\"1\":{\"103\":1}}],[\"获取这些\",{\"1\":{\"917\":1}}],[\"获取所有事件\",{\"1\":{\"884\":1,\"886\":1}}],[\"获取当前日期\",{\"1\":{\"993\":1}}],[\"获取当前位置\",{\"1\":{\"867\":1}}],[\"获取当前url所支持的方法\",{\"1\":{\"314\":1}}],[\"获取的\",{\"1\":{\"863\":2}}],[\"获取的是工厂对象\",{\"1\":{\"678\":1}}],[\"获取失败信息\",{\"1\":{\"806\":1}}],[\"获取任务结果\",{\"1\":{\"806\":2}}],[\"获取唯一的\",{\"1\":{\"787\":1}}],[\"获取要调用的方法\",{\"1\":{\"784\":1}}],[\"获取真正的实现对象\",{\"1\":{\"784\":1}}],[\"获取到对应的\",{\"1\":{\"773\":1}}],[\"获取内容的字节数组\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"获取请求头中的token\",{\"1\":{\"972\":1}}],[\"获取请求\",{\"1\":{\"768\":1}}],[\"获取组成员的\",{\"1\":{\"758\":1}}],[\"获取组成员\",{\"1\":{\"758\":1}}],[\"获取属性\",{\"1\":{\"758\":1}}],[\"获取监听器的参数配置\",{\"1\":{\"728\":1}}],[\"获取指定score范围内的元素\",{\"1\":{\"1030\":1}}],[\"获取指定排名范围内的元素\",{\"1\":{\"1030\":1}}],[\"获取指定名称的bean\",{\"1\":{\"708\":1}}],[\"获取指定时间戳的接下来的时间戳\",{\"1\":{\"441\":1}}],[\"获取\",{\"0\":{\"863\":1},\"1\":{\"644\":1,\"691\":1,\"783\":1,\"804\":1,\"835\":1,\"890\":1,\"1032\":1}}],[\"获取泛型参数\",{\"0\":{\"583\":1},\"1\":{\"585\":2}}],[\"获取方法上注解信息\",{\"1\":{\"483\":1}}],[\"获取类名\",{\"1\":{\"480\":1}}],[\"获取直接或间接标注的注解信息\",{\"1\":{\"480\":1}}],[\"获取传递的参数\",{\"1\":{\"368\":1}}],[\"获取参数方法\",{\"1\":{\"368\":1}}],[\"获取头信息\",{\"1\":{\"314\":1}}],[\"获取字符串长度的时间复杂度为\",{\"1\":{\"276\":1}}],[\"获取字节码对象\",{\"1\":{\"77\":1}}],[\"获取共享锁可中断\",{\"1\":{\"255\":1}}],[\"获取共享锁\",{\"1\":{\"255\":1}}],[\"获取互斥锁后\",{\"1\":{\"988\":1}}],[\"获取互斥锁可中断\",{\"1\":{\"255\":1}}],[\"获取互斥锁\",{\"1\":{\"255\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"获取元素的线程阻塞在notempty条件上\",{\"1\":{\"254\":1}}],[\"获取并计算\",{\"1\":{\"232\":1}}],[\"获取并更新\",{\"1\":{\"232\":1}}],[\"获取并加值\",{\"1\":{\"232\":1}}],[\"获取并自减\",{\"1\":{\"232\":1}}],[\"获取并自增\",{\"1\":{\"232\":1}}],[\"获取静态变量i的值\",{\"1\":{\"230\":1}}],[\"获取下一局要出的手势\",{\"1\":{\"116\":1}}],[\"获取命令执行后的结果\",{\"1\":{\"105\":1}}],[\"获取runtime类对象\",{\"1\":{\"105\":1}}],[\"获取代理对象\",{\"1\":{\"94\":2,\"95\":1,\"998\":1}}],[\"获取c2奖状所属学生对象\",{\"1\":{\"89\":2}}],[\"获取现在状态\",{\"1\":{\"81\":1}}],[\"获取集合中的元素\",{\"1\":{\"78\":1}}],[\"获取迭代器对象\",{\"1\":{\"78\":1}}],[\"于是乎我们需要保证id的唯一性\",{\"1\":{\"992\":1}}],[\"于是就希望转发至\",{\"1\":{\"617\":1}}],[\"于是他可以再次发送read操作\",{\"1\":{\"409\":1}}],[\"于是\",{\"1\":{\"396\":1}}],[\"于是一个超人就诞生了\",{\"1\":{\"54\":1}}],[\"持久化等文件会保存在这个目录\",{\"1\":{\"1015\":1}}],[\"持久性和隔离性都是为了保证数据库状态的一致性\",{\"1\":{\"396\":1}}],[\"持久性实现原理\",{\"1\":{\"396\":1}}],[\"持久性\",{\"1\":{\"396\":1}}],[\"持锁线程执行完synchronized同步块后\",{\"1\":{\"212\":1}}],[\"少则几十万\",{\"1\":{\"975\":1}}],[\"少一次拷贝\",{\"1\":{\"851\":1}}],[\"少一次内存复制\",{\"1\":{\"819\":1}}],[\"少不得束修金\",{\"1\":{\"766\":1}}],[\"少用or\",{\"1\":{\"395\":1}}],[\"少量大分区\",{\"1\":{\"154\":1}}],[\"记住如下几个步骤即可\",{\"1\":{\"1040\":1}}],[\"记作事务a\",{\"1\":{\"393\":1}}],[\"记录日志\",{\"1\":{\"790\":1,\"792\":3}}],[\"记录监听器\",{\"1\":{\"650\":1}}],[\"记录\",{\"1\":{\"650\":2,\"791\":1}}],[\"记录最后一次使用的毫秒时间戳\",{\"1\":{\"441\":1}}],[\"记录最后使用的毫秒时间戳\",{\"1\":{\"441\":1}}],[\"记录锁\",{\"1\":{\"401\":1}}],[\"记录了这个\",{\"1\":{\"829\":1}}],[\"记录了当前节点的实际数据\",{\"1\":{\"279\":1}}],[\"记录了当前节点实际数据的类型以及长度\",{\"1\":{\"279\":1}}],[\"记录了\",{\"1\":{\"279\":1,\"527\":2}}],[\"记录了字符串长度\",{\"1\":{\"277\":1}}],[\"记录压缩列表包含的节点数量\",{\"1\":{\"279\":1}}],[\"记录压缩列表\",{\"1\":{\"279\":1}}],[\"记录整个压缩列表占用对内存字节数\",{\"1\":{\"279\":1}}],[\"记录可以是定长的或可变长的\",{\"1\":{\"167\":1}}],[\"记录式文件\",{\"1\":{\"167\":1}}],[\"记录型信号量\",{\"1\":{\"143\":1}}],[\"掘金\",{\"1\":{\"393\":1,\"738\":1}}],[\"谈谈你对mvcc的了解\",{\"0\":{\"393\":1},\"1\":{\"396\":2}}],[\"改造原始代码\",{\"0\":{\"1035\":1}}],[\"改造uuid\",{\"1\":{\"392\":1}}],[\"改成stock大于0\",{\"1\":{\"997\":1}}],[\"改成了\",{\"1\":{\"523\":1}}],[\"改为\",{\"1\":{\"997\":1}}],[\"改变\",{\"1\":{\"854\":1}}],[\"改进的地方\",{\"1\":{\"877\":1}}],[\"改进方法\",{\"1\":{\"185\":1}}],[\"改进型时钟置换算法思想\",{\"1\":{\"163\":1}}],[\"改进型的时钟置换算法\",{\"1\":{\"163\":1}}],[\"改进工厂类\",{\"1\":{\"77\":1}}],[\"回答是不太好\",{\"1\":{\"829\":1}}],[\"回到了熟悉的代码\",{\"1\":{\"793\":1}}],[\"回到用户态\",{\"1\":{\"406\":1}}],[\"回复\",{\"1\":{\"776\":1}}],[\"回来了\",{\"1\":{\"751\":1}}],[\"回调对象\",{\"1\":{\"803\":1}}],[\"回调aware接口的方法\",{\"1\":{\"711\":1}}],[\"回调的接口换了一下\",{\"1\":{\"523\":1}}],[\"回调\",{\"1\":{\"515\":1,\"790\":2}}],[\"回调各种\",{\"1\":{\"458\":1}}],[\"回滚和提交是由事务管理器来完成的\",{\"1\":{\"721\":1}}],[\"回滚操作\",{\"1\":{\"662\":1}}],[\"回滚时则会执行相反的update\",{\"1\":{\"396\":1}}],[\"回滚时会执行insert\",{\"1\":{\"396\":1}}],[\"回滚时会执行delete\",{\"1\":{\"396\":1}}],[\"回滚段上用于恢复数据的信息\",{\"1\":{\"389\":1}}],[\"回收内存的源码实现\",{\"1\":{\"825\":1}}],[\"回收内存即可\",{\"1\":{\"825\":1}}],[\"回收算法\",{\"1\":{\"355\":1}}],[\"回收区的前\",{\"1\":{\"154\":2}}],[\"回收区的前或后面有一个相邻的空闲分区\",{\"1\":{\"154\":1}}],[\"回收资源\",{\"1\":{\"133\":1}}],[\"明显会大于二级索引\",{\"1\":{\"387\":1}}],[\"明星类\",{\"1\":{\"111\":1}}],[\"明星由于全身心投入艺术\",{\"1\":{\"111\":1}}],[\"明星与经纪人的关系实例\",{\"1\":{\"111\":1}}],[\"北京市\",{\"1\":{\"385\":1}}],[\"`下一个定时任务执行时间\",{\"1\":{\"792\":1}}],[\"`firstname`\",{\"1\":{\"385\":1}}],[\"`lastname`\",{\"1\":{\"385\":1}}],[\"`zipcode`\",{\"1\":{\"385\":1}}],[\"`zip\",{\"1\":{\"385\":1}}],[\"散列性\",{\"1\":{\"383\":1}}],[\"张\",{\"1\":{\"383\":1,\"385\":1}}],[\"张三的好友有\",{\"1\":{\"1029\":1}}],[\"张三\",{\"1\":{\"87\":1,\"89\":2,\"337\":1,\"770\":1,\"785\":1,\"787\":1,\"1005\":2}}],[\"尤其是在数据量大的情况下\",{\"1\":{\"383\":1}}],[\"尤其是最近几年爆火的996icu的话题\",{\"1\":{\"305\":1}}],[\"频繁作为\",{\"1\":{\"383\":1}}],[\"过期时间单位\",{\"1\":{\"990\":2}}],[\"过期时间\",{\"1\":{\"990\":2}}],[\"过期数据删除策略\",{\"0\":{\"427\":1}}],[\"过一会再进行尝试\",{\"1\":{\"988\":1}}],[\"过滤掉小于0的\",{\"1\":{\"744\":1}}],[\"过滤器时能用上\",{\"1\":{\"552\":1}}],[\"过长的主键索引会令二级索引变得过大\",{\"1\":{\"379\":1}}],[\"过于复杂\",{\"1\":{\"49\":1}}],[\"叶子节点之间会有指针\",{\"1\":{\"378\":1}}],[\"严重影响查询的效率\",{\"1\":{\"383\":1}}],[\"严重拖慢更新和新增速度\",{\"1\":{\"266\":1}}],[\"严格匹配数据源\",{\"1\":{\"372\":1}}],[\"延迟发送\",{\"1\":{\"751\":1}}],[\"延迟\",{\"1\":{\"688\":1}}],[\"延迟加载配置是全局开启的\",{\"1\":{\"366\":1}}],[\"延迟时间和传输时间都与磁盘转速相关\",{\"1\":{\"176\":1}}],[\"延迟时间tr​\",{\"1\":{\"176\":1}}],[\"错误原因>>>\",{\"1\":{\"732\":2}}],[\"错误页处理\",{\"0\":{\"618\":1}}],[\"错误页面之间是通过请求转发跳转的\",{\"1\":{\"617\":1}}],[\"错误的\",{\"1\":{\"366\":1}}],[\"错位命名\",{\"1\":{\"177\":1}}],[\"替换原来的位置\",{\"1\":{\"366\":1}}],[\"删除sorted\",{\"1\":{\"1030\":1}}],[\"删除一个指定的key\",{\"1\":{\"1024\":1}}],[\"删除缓存\",{\"1\":{\"982\":1,\"983\":1}}],[\"删除缓存还是更新缓存\",{\"1\":{\"982\":1}}],[\"删除索引\",{\"1\":{\"933\":2,\"950\":1}}],[\"删除是危险操作\",{\"1\":{\"873\":1}}],[\"删除很危险⚠️\",{\"0\":{\"873\":1}}],[\"删除多级目录\",{\"1\":{\"872\":1}}],[\"删除目录\",{\"1\":{\"872\":1}}],[\"删除单个\",{\"1\":{\"1024\":1}}],[\"删除单个列表\",{\"1\":{\"430\":1}}],[\"删除单个字符串类型的key\",{\"1\":{\"430\":1}}],[\"删除key的命令会阻塞redis吗\",{\"0\":{\"430\":1}}],[\"删除和查找\",{\"1\":{\"425\":1}}],[\"删除不再使用或很少使用的索引\",{\"1\":{\"384\":1}}],[\"删除cms垃圾回收器\",{\"1\":{\"360\":1,\"362\":1}}],[\"删除文件\",{\"1\":{\"168\":1,\"171\":1,\"872\":1}}],[\"青色虚线\",{\"1\":{\"360\":1}}],[\"弃用parallel\",{\"1\":{\"360\":1}}],[\"绿色虚线\",{\"1\":{\"360\":1}}],[\"移出最近最少使用的key\",{\"1\":{\"429\":1}}],[\"移动文件\",{\"1\":{\"872\":1}}],[\"移动端\",{\"1\":{\"360\":1}}],[\"移动磁头时间\",{\"1\":{\"176\":1}}],[\"移除set中的指定元素\",{\"1\":{\"1029\":1}}],[\"移除并返回列表右侧的第一个元素\",{\"1\":{\"1028\":1}}],[\"移除并返回列表左侧的第一个元素\",{\"1\":{\"1028\":1}}],[\"移除用户\",{\"1\":{\"972\":1}}],[\"移除初始化器\",{\"1\":{\"790\":1}}],[\"移除聊天组\",{\"1\":{\"758\":1}}],[\"移除组成员\",{\"1\":{\"758\":1}}],[\"移除了cms垃圾收集器\",{\"1\":{\"362\":1}}],[\"移除\",{\"1\":{\"360\":1}}],[\"串行回收器\",{\"1\":{\"360\":1}}],[\"吞吐量的补数\",{\"1\":{\"359\":1}}],[\"吞吐量\",{\"1\":{\"359\":3,\"890\":1,\"927\":1,\"928\":1}}],[\"间接\",{\"1\":{\"523\":2}}],[\"间接实现了图像配对\",{\"1\":{\"3\":1}}],[\"间隙锁\",{\"1\":{\"401\":1}}],[\"间断性地还执行了应用程序代码\",{\"1\":{\"356\":1}}],[\"知识小扩展\",{\"1\":{\"997\":1}}],[\"知识小贴士\",{\"1\":{\"993\":1}}],[\"知识的广度\",{\"1\":{\"303\":1}}],[\"知道设备就绪或者主动超时\",{\"1\":{\"410\":1}}],[\"知道垃圾收集完成\",{\"1\":{\"356\":1}}],[\"讲一讲垃圾回收算法\",{\"1\":{\"355\":1}}],[\"讲解gan精巧的自监督对抗学习范式背后的算法和数学原理\",{\"1\":{\"10\":1}}],[\"阿里\",{\"1\":{\"355\":1}}],[\"阿尔萨斯\",{\"1\":{\"94\":1}}],[\"京东\",{\"1\":{\"355\":1}}],[\"滴滴\",{\"1\":{\"355\":1}}],[\"天然的问题就是自旋\",{\"1\":{\"997\":1}}],[\"天然的幂等性\",{\"1\":{\"314\":1}}],[\"天留\",{\"1\":{\"766\":1}}],[\"天才基本法\",{\"1\":{\"731\":1}}],[\"天猫\",{\"1\":{\"355\":1}}],[\"垃圾收集器组合关系\",{\"1\":{\"360\":1}}],[\"垃圾收集所用时间与总运行时间的比例\",{\"1\":{\"359\":1}}],[\"垃圾收集开销\",{\"1\":{\"359\":1}}],[\"垃圾收集线程只收集一小片区域的内存空间\",{\"1\":{\"356\":1}}],[\"垃圾收集策略和算法\",{\"1\":{\"355\":1}}],[\"垃圾回收的影响\",{\"1\":{\"905\":1}}],[\"垃圾回收的管理\",{\"1\":{\"819\":1}}],[\"垃圾回收\",{\"1\":{\"825\":1}}],[\"垃圾回收器的选择\",{\"0\":{\"361\":1}}],[\"垃圾回收器就是一个守护线程\",{\"1\":{\"207\":1}}],[\"垃圾回收算法的实现原理\",{\"1\":{\"355\":1}}],[\"垃圾回收算法有哪些\",{\"1\":{\"355\":1}}],[\"百度\",{\"1\":{\"355\":1}}],[\"百万\",{\"1\":{\"151\":1}}],[\"蚂蚁金服\",{\"1\":{\"355\":1}}],[\"拼接并返回\",{\"1\":{\"993\":1}}],[\"拼接前后\",{\"1\":{\"354\":1}}],[\"拼凑\",{\"1\":{\"154\":1}}],[\"权限没有要求\",{\"1\":{\"351\":1}}],[\"权限必须是public\",{\"1\":{\"351\":1}}],[\"混合收集\",{\"1\":{\"350\":1}}],[\"混合索引\",{\"1\":{\"169\":1}}],[\"老年代收集器\",{\"1\":{\"360\":1}}],[\"老年代收集\",{\"1\":{\"350\":1}}],[\"老年代\",{\"1\":{\"350\":1}}],[\"老版本keras\",{\"1\":{\"14\":1}}],[\"逃逸分析\",{\"1\":{\"349\":1}}],[\"栈大小分为固定的\",{\"1\":{\"348\":1}}],[\"举例来说\",{\"1\":{\"727\":1}}],[\"举例栈溢出的情况\",{\"0\":{\"348\":1}}],[\"举个hashset插入对象的例子\",{\"1\":{\"318\":1}}],[\"举个例子\",{\"1\":{\"276\":2,\"277\":1,\"974\":1}}],[\"举个简单的例子\",{\"1\":{\"273\":1}}],[\"沙箱安全机制\",{\"0\":{\"346\":1}}],[\"沙发\",{\"1\":{\"33\":1}}],[\"倘若父类加载器无法完成此加载任务\",{\"1\":{\"345\":1}}],[\"依次按照\",{\"1\":{\"837\":1}}],[\"依次反复\",{\"1\":{\"356\":1}}],[\"依次递归\",{\"1\":{\"345\":1}}],[\"依赖库\",{\"0\":{\"1011\":1}}],[\"依赖的前提下\",{\"1\":{\"649\":1}}],[\"依赖注入阶段执行\",{\"1\":{\"711\":1}}],[\"依赖注入阶段执行的方法\",{\"1\":{\"711\":1}}],[\"依赖注入和初始化影响的是原始对象\",{\"1\":{\"686\":1}}],[\"依赖注入与初始化不应该被增强\",{\"1\":{\"542\":1}}],[\"依赖注入前\",{\"1\":{\"542\":1}}],[\"依赖注入前的增强\",{\"1\":{\"460\":1}}],[\"依赖注入仅发生了一次\",{\"1\":{\"500\":1}}],[\"依赖注入\",{\"1\":{\"458\":1,\"463\":1,\"470\":1,\"678\":1}}],[\"依赖服务器时间\",{\"1\":{\"442\":1}}],[\"依赖倒转原则\",{\"0\":{\"109\":1}}],[\"依赖\",{\"1\":{\"108\":1,\"672\":2,\"773\":1}}],[\"规范环境键名称\",{\"1\":{\"652\":1}}],[\"规整的话使用碰撞指针否则使用空闲列表\",{\"1\":{\"352\":1}}],[\"规约\",{\"0\":{\"342\":1}}],[\"规定每个进程必须按照编号递增的顺序请求资源\",{\"1\":{\"148\":1}}],[\"规定了具体原型对象必须实现的的\",{\"1\":{\"85\":1}}],[\"规定要实现复杂对象的哪些部分的创建\",{\"1\":{\"48\":1}}],[\"映射器与适配器小结\",{\"0\":{\"643\":1}}],[\"映射欢迎页\",{\"1\":{\"642\":1}}],[\"映射路径\",{\"1\":{\"636\":1}}],[\"映射信息\",{\"1\":{\"561\":1}}],[\"映射\",{\"0\":{\"339\":1,\"926\":1},\"1\":{\"558\":1}}],[\"筛选时会考虑\",{\"1\":{\"688\":1}}],[\"筛选\",{\"1\":{\"338\":1}}],[\"筛选与切片\",{\"0\":{\"338\":1}}],[\"返同一个扔了前n个元素的流\",{\"1\":{\"338\":1}}],[\"返回set中元素的个数\",{\"1\":{\"1029\":1}}],[\"返回shop信息\",{\"1\":{\"989\":1,\"990\":1}}],[\"返回一段角标范围内的所有元素\",{\"1\":{\"1028\":1}}],[\"返回一个错误信息\",{\"1\":{\"990\":1}}],[\"返回目前的age的值\",{\"1\":{\"1025\":1}}],[\"返回订单id\",{\"1\":{\"998\":2}}],[\"返回错误\",{\"1\":{\"990\":1}}],[\"返回错误信息\",{\"1\":{\"960\":2,\"968\":1,\"990\":1}}],[\"返回过期的商铺信息\",{\"1\":{\"989\":1,\"990\":1}}],[\"返回1\",{\"1\":{\"988\":1}}],[\"返回数据\",{\"1\":{\"988\":1}}],[\"返回token\",{\"1\":{\"968\":1}}],[\"返回true即拼接否则不拼接\",{\"1\":{\"370\":1}}],[\"返回true\",{\"1\":{\"104\":1,\"255\":1}}],[\"返回401状态码\",{\"1\":{\"961\":1}}],[\"返回ok\",{\"1\":{\"960\":1}}],[\"返回结果\",{\"1\":{\"784\":1}}],[\"返回响应\",{\"1\":{\"768\":1}}],[\"返回响应体前包装\",{\"1\":{\"608\":1}}],[\"返回json或xml形式数据\",{\"1\":{\"731\":1}}],[\"返回不为null\",{\"1\":{\"711\":1}}],[\"返回null\",{\"1\":{\"806\":1}}],[\"返回null保持原有对象不变\",{\"1\":{\"711\":1}}],[\"返回n行\",{\"1\":{\"266\":1}}],[\"返回的都是脏数据\",{\"1\":{\"987\":1}}],[\"返回的\",{\"1\":{\"670\":1}}],[\"返回的也是一个抽象的产品\",{\"1\":{\"58\":1}}],[\"返回值数据class类型\",{\"1\":{\"990\":1}}],[\"返回值数据类型\",{\"1\":{\"990\":2}}],[\"返回值class类型\",{\"1\":{\"990\":1}}],[\"返回值表示读到了多少字节\",{\"1\":{\"864\":1}}],[\"返回值\",{\"1\":{\"783\":1}}],[\"返回值省略\",{\"1\":{\"600\":1}}],[\"返回值添加了\",{\"1\":{\"600\":2}}],[\"返回值类型为\",{\"1\":{\"600\":3}}],[\"返回值类型为boolean类型\",{\"1\":{\"119\":1}}],[\"返回值处理器体现了组合模式\",{\"1\":{\"643\":1}}],[\"返回值处理器\",{\"0\":{\"597\":1},\"1\":{\"612\":1,\"644\":2}}],[\"返回流中最小值\",{\"1\":{\"341\":1}}],[\"返回流中最大值\",{\"1\":{\"341\":1}}],[\"返回流中元泰的总个数\",{\"1\":{\"341\":1}}],[\"返回当前流中的任意元素\",{\"1\":{\"341\":1}}],[\"返回第一个元素\",{\"1\":{\"341\":1}}],[\"返回为4\",{\"1\":{\"267\":1}}],[\"返回为12\",{\"1\":{\"267\":1}}],[\"返回原进程继续往下执行\",{\"1\":{\"129\":1}}],[\"返回进程对象\",{\"1\":{\"105\":1}}],[\"返回\",{\"1\":{\"105\":2,\"232\":10,\"794\":1,\"877\":1,\"983\":1,\"990\":1,\"1041\":1}}],[\"截断流\",{\"1\":{\"338\":1}}],[\"田七\",{\"1\":{\"337\":2}}],[\"赵六\",{\"1\":{\"337\":1,\"1029\":1}}],[\"王五\",{\"1\":{\"337\":1,\"1029\":2}}],[\"断点类型加以区分\",{\"1\":{\"790\":1}}],[\"断点2\",{\"1\":{\"775\":1}}],[\"断点1\",{\"1\":{\"775\":1}}],[\"断言型接口\",{\"1\":{\"336\":1}}],[\"断开原来的head节点\",{\"1\":{\"261\":1}}],[\"供大家参考\",{\"1\":{\"451\":1}}],[\"供给型接口\",{\"1\":{\"336\":1}}],[\"供子类实现\",{\"1\":{\"122\":1}}],[\"声明式事务\",{\"1\":{\"719\":1}}],[\"声明类\",{\"1\":{\"336\":1}}],[\"声明函数式接口\",{\"1\":{\"336\":1}}],[\"声明了\",{\"1\":{\"277\":1}}],[\"充分调用os参与并发操作\",{\"1\":{\"334\":1}}],[\"便于处理\",{\"1\":{\"773\":1}}],[\"便于代码的维护\",{\"1\":{\"734\":1}}],[\"便于减少系统的重复代码\",{\"1\":{\"706\":1}}],[\"便发出缺页\",{\"1\":{\"418\":1}}],[\"便可使一个大的用户程序在较小的内存空间中运行\",{\"1\":{\"418\":1}}],[\"便可继续执行下去\",{\"1\":{\"418\":1}}],[\"便可以利用undo\",{\"1\":{\"396\":1}}],[\"便表示所要访问的页表项在快表中\",{\"1\":{\"413\":1}}],[\"便获取事件然后针对每个事件进行相应的处理\",{\"1\":{\"332\":1}}],[\"便产生一个缺页中断\",{\"1\":{\"162\":1}}],[\"决定\",{\"1\":{\"781\":1,\"794\":1}}],[\"决定入站缓冲区的大小\",{\"1\":{\"781\":1}}],[\"决定的\",{\"1\":{\"332\":1}}],[\"决定hash表的最大填满程度\",{\"1\":{\"328\":1}}],[\"范围查询\",{\"0\":{\"942\":1},\"1\":{\"942\":1}}],[\"范围\",{\"1\":{\"773\":1}}],[\"范围是0\",{\"1\":{\"328\":1}}],[\"范围的缓存数据\",{\"1\":{\"320\":1}}],[\"尺寸\",{\"1\":{\"328\":1}}],[\"换句话说\",{\"1\":{\"1042\":1}}],[\"换句话说使用扰动函数之后可以减少碰撞\",{\"1\":{\"327\":1}}],[\"换人\",{\"1\":{\"799\":1}}],[\"换来了一个更大的空间来支持程序的运行\",{\"1\":{\"418\":1}}],[\"换算出一页大概能存储1000条数据\",{\"1\":{\"377\":1}}],[\"换出需要磁盘的i\",{\"1\":{\"163\":1}}],[\"换出\",{\"1\":{\"161\":1}}],[\"底层采用了\",{\"1\":{\"905\":1}}],[\"底层使用的是水平触发\",{\"1\":{\"885\":1}}],[\"底层使用了\",{\"1\":{\"830\":1}}],[\"底层会利用操作系统的零拷贝进行优化\",{\"1\":{\"870\":1}}],[\"底层会用操作系统的零拷贝进行优化\",{\"1\":{\"870\":1}}],[\"底层也不会有拷贝操作\",{\"1\":{\"830\":1}}],[\"底层内存会被回收\",{\"1\":{\"825\":1}}],[\"底层为数组实现\",{\"1\":{\"792\":1}}],[\"底层为双向链表\",{\"1\":{\"422\":1}}],[\"底层第二套转换接口\",{\"0\":{\"575\":1}}],[\"底层第一套转换接口与实现\",{\"0\":{\"574\":1}}],[\"底层的实现是一个跳表\",{\"1\":{\"1030\":1}}],[\"底层的真正读写是操作系统来完成的\",{\"1\":{\"904\":1}}],[\"底层的\",{\"1\":{\"764\":1}}],[\"底层的切面实现\",{\"1\":{\"531\":1}}],[\"底层的切点实现\",{\"1\":{\"531\":1}}],[\"底层的通知实现\",{\"1\":{\"531\":1}}],[\"底层切点\",{\"0\":{\"529\":1}}],[\"底层实现\",{\"1\":{\"504\":1}}],[\"底层实现方式之一是代理\",{\"1\":{\"504\":1}}],[\"底层是有一个数组\",{\"1\":{\"332\":1}}],[\"底层数据结构的不同导致应用场景也有所不同\",{\"1\":{\"326\":1}}],[\"底层细节对用户不透明\",{\"1\":{\"185\":1}}],[\"拆箱\",{\"1\":{\"321\":1}}],[\"强调的是所属关系\",{\"1\":{\"317\":1}}],[\"强制写入\",{\"0\":{\"869\":1}}],[\"强制性\",{\"1\":{\"720\":1}}],[\"强制\",{\"1\":{\"265\":9,\"266\":4,\"267\":8,\"268\":7,\"383\":1}}],[\"强制撤销部分\",{\"1\":{\"150\":1}}],[\"共同使用\",{\"1\":{\"891\":1}}],[\"共同点\",{\"1\":{\"317\":1,\"413\":1}}],[\"共享锁\",{\"1\":{\"398\":1,\"400\":1}}],[\"共享锁和排他锁既可以加在表上\",{\"1\":{\"398\":1}}],[\"共享锁允许同时多个线程占有\",{\"1\":{\"252\":1}}],[\"共享模式下使用\",{\"1\":{\"255\":2}}],[\"共享变量\",{\"1\":{\"233\":1}}],[\"共享设备\",{\"1\":{\"185\":1}}],[\"共享打印机原理分析\",{\"1\":{\"184\":1}}],[\"共享的数据结构\",{\"1\":{\"145\":1}}],[\"共享存储\",{\"1\":{\"134\":1}}],[\"共享\",{\"1\":{\"127\":2}}],[\"流逝\",{\"1\":{\"731\":1}}],[\"流程梳理\",{\"0\":{\"836\":1}}],[\"流程中的异常\",{\"1\":{\"617\":1}}],[\"流程如上图所示\",{\"1\":{\"409\":2}}],[\"流程如下图\",{\"1\":{\"315\":1}}],[\"流程\",{\"1\":{\"355\":1,\"460\":1,\"617\":3}}],[\"流式文件\",{\"1\":{\"167\":1}}],[\"退出循环\",{\"1\":{\"792\":4}}],[\"退出\",{\"0\":{\"762\":1}}],[\"退出群聊\",{\"1\":{\"761\":1}}],[\"退出区\",{\"1\":{\"140\":1}}],[\"退款等等状态\",{\"1\":{\"315\":1}}],[\"已过期\",{\"1\":{\"989\":1,\"990\":1}}],[\"已废弃\",{\"1\":{\"842\":1}}],[\"已完成了它的使命\",{\"1\":{\"825\":1}}],[\"已退出群\",{\"1\":{\"761\":1}}],[\"已发送的数据都收到\",{\"1\":{\"751\":1}}],[\"已具备等价功能\",{\"1\":{\"678\":1}}],[\"已初始化事件3️⃣\",{\"1\":{\"650\":1}}],[\"已准备事件2️⃣\",{\"1\":{\"650\":1}}],[\"已调入内存\",{\"1\":{\"418\":1}}],[\"已支付\",{\"1\":{\"315\":1}}],[\"已经不够了\",{\"1\":{\"823\":1}}],[\"已经读取过的部分\",{\"1\":{\"821\":1}}],[\"已经\",{\"1\":{\"764\":1}}],[\"已经异常断开\",{\"1\":{\"762\":1}}],[\"已经断开\",{\"1\":{\"762\":1}}],[\"已经存在\",{\"1\":{\"761\":1}}],[\"已经配置了\",{\"1\":{\"668\":1}}],[\"已经为\",{\"1\":{\"276\":1}}],[\"已经是最后的节点了\",{\"1\":{\"249\":1}}],[\"已经知道文件的起始地址\",{\"1\":{\"167\":1}}],[\"已经具备运行条件\",{\"1\":{\"132\":1}}],[\"待实现\",{\"1\":{\"783\":2}}],[\"待支付\",{\"1\":{\"315\":1}}],[\"待以后需要的时候再重新申请一下\",{\"1\":{\"148\":1}}],[\"懂点技术的都可以模拟请求调用接口\",{\"1\":{\"315\":1}}],[\"隐藏用户敏感信息\",{\"0\":{\"962\":1}}],[\"隐藏列中包含了本行数据的事务id\",{\"1\":{\"393\":1}}],[\"隐藏列\",{\"1\":{\"393\":1}}],[\"隐藏\",{\"1\":{\"315\":1}}],[\"隐式链接\",{\"1\":{\"169\":2}}],[\"哈希结构也是我们以后实际开发中常用的命令哟\",{\"1\":{\"1027\":1}}],[\"哈希索引的时间复杂度会退化为o\",{\"1\":{\"381\":1}}],[\"哈希值\",{\"1\":{\"353\":1,\"434\":1}}],[\"哈希函数\",{\"1\":{\"272\":1}}],[\"哈哈哈\",{\"1\":{\"313\":1}}],[\"订单id\",{\"1\":{\"995\":1,\"998\":3}}],[\"订单支付时\",{\"1\":{\"313\":1}}],[\"订单创建成功去减库存时\",{\"1\":{\"313\":1}}],[\"订阅者消费了数据之后\",{\"1\":{\"745\":1}}],[\"订阅者会有一个缓冲池\",{\"1\":{\"745\":1}}],[\"订阅者处理完了\",{\"1\":{\"744\":1}}],[\"订阅者\",{\"1\":{\"742\":1}}],[\"订阅\",{\"1\":{\"80\":1}}],[\"订阅模式\",{\"0\":{\"79\":1},\"1\":{\"743\":1}}],[\"带来巨大压力\",{\"1\":{\"986\":1}}],[\"带\",{\"1\":{\"650\":1}}],[\"带参数绑定的通知方法调用\",{\"0\":{\"554\":1}}],[\"带参的构造器\",{\"1\":{\"351\":1}}],[\"带你了解一波\",{\"1\":{\"312\":1}}],[\"带权周转时间很大\",{\"1\":{\"139\":1}}],[\"带权周转时间与周转时间都是越小越好\",{\"1\":{\"138\":1}}],[\"带权周转时间肯定是大于1的\",{\"1\":{\"138\":1}}],[\"带权周转时间\",{\"1\":{\"138\":2}}],[\"幂等性的实现方式\",{\"0\":{\"315\":1}}],[\"幂等性如何实现\",{\"1\":{\"312\":1}}],[\"幂等性\",{\"0\":{\"312\":1}}],[\"靠自己\",{\"1\":{\"311\":1}}],[\"偶尔也会谈起\",{\"1\":{\"309\":1}}],[\"担心课题出现问题\",{\"1\":{\"309\":1}}],[\"担心找不到面试\",{\"1\":{\"309\":1}}],[\"乒乓球和篮球等等\",{\"1\":{\"309\":1}}],[\"听听音乐\",{\"1\":{\"308\":1}}],[\"想上锁的那个事务需要遍历有没有行锁\",{\"1\":{\"400\":1}}],[\"想想自己最近的努力\",{\"1\":{\"308\":1}}],[\"想要在某个行业有所成就\",{\"1\":{\"305\":1}}],[\"想要达到这样的效果\",{\"1\":{\"107\":1}}],[\"努力向上爬\",{\"1\":{\"307\":1}}],[\"乔布斯传\",{\"1\":{\"306\":1}}],[\"耳机\",{\"1\":{\"305\":1}}],[\"音箱\",{\"1\":{\"305\":1}}],[\"音频\",{\"1\":{\"276\":1}}],[\"智能家电都能配置鸿蒙系统\",{\"1\":{\"305\":1}}],[\"鸿蒙\",{\"1\":{\"305\":1}}],[\"投入大量时间是必不可少的\",{\"1\":{\"305\":1}}],[\"艰苦奋斗\",{\"1\":{\"305\":1}}],[\"心系中华\",{\"1\":{\"304\":1,\"305\":1}}],[\"南邮和华为的渊源\",{\"1\":{\"304\":1}}],[\"凡事还是得按部就班来\",{\"1\":{\"302\":1}}],[\"凡是与资源有关的操作\",{\"1\":{\"130\":1}}],[\"聚合查询\",{\"0\":{\"945\":1},\"1\":{\"945\":1}}],[\"聚合或组合关系\",{\"1\":{\"111\":1}}],[\"聚簇索引包含的信息多\",{\"1\":{\"387\":1}}],[\"聚簇索引和非聚簇索引\",{\"1\":{\"382\":1}}],[\"聚类中心当然是互相离得越远越好\",{\"1\":{\"300\":1}}],[\"距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心\",{\"1\":{\"300\":1}}],[\"经拆分后每个步骤需要\",{\"1\":{\"805\":1}}],[\"经研究发现\",{\"1\":{\"805\":1}}],[\"经过nginx的负载均衡分流后\",{\"1\":{\"955\":1}}],[\"经过很多工序的加工\",{\"1\":{\"816\":1}}],[\"经过适配转换成\",{\"1\":{\"574\":1}}],[\"经过地址变换\",{\"1\":{\"413\":1}}],[\"经过模型\",{\"1\":{\"300\":1}}],[\"经常被用来实现排行榜这样的功能\",{\"1\":{\"1030\":1}}],[\"经常用到这两个接口\",{\"1\":{\"806\":1}}],[\"经常\",{\"1\":{\"383\":1}}],[\"经纪人类\",{\"1\":{\"111\":1}}],[\"看病可以细分为四个步骤\",{\"1\":{\"805\":1}}],[\"看是否应当阻塞\",{\"1\":{\"791\":1}}],[\"看需要的类型是否为\",{\"1\":{\"688\":1}}],[\"看看别人其他模块的思路\",{\"1\":{\"311\":1}}],[\"看到乔布斯被苹果踢出董事会成立next和皮克斯那了\",{\"1\":{\"306\":1}}],[\"看别人代码的编写思路\",{\"1\":{\"297\":1}}],[\"看如下类图\",{\"1\":{\"110\":1}}],[\"归属地\",{\"1\":{\"296\":1}}],[\"归属地和运营商数量统计接口\",{\"1\":{\"296\":1}}],[\"采集时间\",{\"1\":{\"296\":1}}],[\"采用的核心思路就是书写一个userdto对象\",{\"1\":{\"962\":1}}],[\"采用的就是这种模式\",{\"1\":{\"218\":1}}],[\"采用这种方法后\",{\"1\":{\"754\":1}}],[\"采用cglib比较合适\",{\"1\":{\"718\":1}}],[\"采用cas配上失败重试的方式保证操作的原子性\",{\"1\":{\"352\":1}}],[\"采用cas失败重试\",{\"1\":{\"352\":1}}],[\"采用cas主线程仅能判断出共享变量的值与初值a是否相同\",{\"1\":{\"233\":1}}],[\"采用轮询方式\",{\"1\":{\"410\":1}}],[\"采用行级锁和mvcc机制\",{\"1\":{\"387\":1}}],[\"采用双引号进行拼接\",{\"1\":{\"366\":1}}],[\"采用双缓冲策略\",{\"1\":{\"186\":1}}],[\"采用mysql自带的concat函数进行拼接\",{\"1\":{\"366\":1}}],[\"采用$\",{\"1\":{\"366\":1}}],[\"采用in来进行批量删除时只能采用$\",{\"1\":{\"366\":1}}],[\"采用了proactor模式\",{\"1\":{\"333\":1}}],[\"采用分治的思想\",{\"1\":{\"290\":1}}],[\"采用固定加锁的顺序\",{\"1\":{\"221\":1}}],[\"采用单缓冲策略\",{\"1\":{\"186\":1}}],[\"采用spooling技术将独占设备改造成虚拟的共享设备\",{\"1\":{\"185\":1}}],[\"采用k层索引结构\",{\"1\":{\"169\":1}}],[\"采用两级目录结构\",{\"1\":{\"168\":1}}],[\"采用虚拟内存技术的系统中\",{\"1\":{\"164\":1}}],[\"采用\",{\"1\":{\"152\":1,\"523\":1}}],[\"采用顺序资源分配法\",{\"1\":{\"148\":1}}],[\"采用静态分配方法\",{\"1\":{\"148\":1}}],[\"采用动态优先级\",{\"1\":{\"139\":1}}],[\"采用组合或聚合复用时\",{\"1\":{\"112\":1}}],[\"采用抽象工厂模式则是不需要关心构建过程\",{\"1\":{\"55\":1}}],[\"验证码错误\",{\"1\":{\"960\":1,\"968\":1}}],[\"验证码\",{\"1\":{\"960\":1}}],[\"验证生成100万个id需要多久\",{\"1\":{\"441\":1}}],[\"验证成功则会直接保持登陆状态\",{\"1\":{\"296\":1}}],[\"验戳\",{\"1\":{\"260\":1}}],[\"服务\",{\"1\":{\"1015\":1}}],[\"服务器压力过大\",{\"1\":{\"963\":1}}],[\"服务器按预定长度读取\",{\"1\":{\"890\":1}}],[\"服务器仅接收\",{\"1\":{\"833\":1}}],[\"服务器\",{\"0\":{\"784\":1}}],[\"服务器架子\",{\"1\":{\"783\":1}}],[\"服务器端代码为\",{\"1\":{\"884\":1}}],[\"服务器端成功接受连接时触发\",{\"1\":{\"881\":1}}],[\"服务器端\",{\"0\":{\"834\":1},\"1\":{\"835\":1,\"876\":1,\"877\":1,\"890\":1}}],[\"服务器端打印\",{\"1\":{\"816\":1}}],[\"服务器端两个\",{\"1\":{\"798\":1}}],[\"服务器端的\",{\"1\":{\"783\":1}}],[\"服务器端的某次输出\",{\"1\":{\"749\":1,\"750\":1}}],[\"服务器端解决\",{\"1\":{\"764\":1}}],[\"服务器端将\",{\"1\":{\"760\":1}}],[\"服务器端加入\",{\"1\":{\"754\":1}}],[\"服务器端在cookie中拿到sessionid然后再服务器的session对象中查找sessionid进行验证\",{\"1\":{\"296\":1}}],[\"服务器提供了\",{\"1\":{\"644\":1}}],[\"服务器默认错误地址\",{\"1\":{\"619\":1}}],[\"服务器号\",{\"1\":{\"443\":1}}],[\"服务器时钟回拨时可能会生成重复\",{\"1\":{\"442\":1}}],[\"服务器等\",{\"1\":{\"360\":1}}],[\"服务器得到通知\",{\"1\":{\"333\":1}}],[\"服务器就会需要启动一个线程来进行处理\",{\"1\":{\"331\":1}}],[\"服务器实现模式为一个连接一个线程\",{\"1\":{\"331\":1}}],[\"服务方提供一个查询操作是否成功的api\",{\"1\":{\"313\":1}}],[\"服务端正常会返回pong\",{\"1\":{\"1018\":1}}],[\"服务端\",{\"1\":{\"816\":2}}],[\"服务端根据它找到实现\",{\"1\":{\"783\":1}}],[\"服务端也一直收不到数据\",{\"1\":{\"764\":1}}],[\"服务端加入\",{\"1\":{\"755\":1}}],[\"服务端输出\",{\"1\":{\"754\":1,\"755\":1,\"756\":1}}],[\"服务端修改一下接收缓冲区\",{\"1\":{\"750\":1}}],[\"服务端代码\",{\"1\":{\"749\":1}}],[\"服务端会校验这个token\",{\"1\":{\"315\":1}}],[\"服务端会生成一个全局唯一的id保存在redis中\",{\"1\":{\"315\":1}}],[\"服务端扣钱成功\",{\"1\":{\"313\":1}}],[\"服务端进行账号密码校验\",{\"1\":{\"296\":1}}],[\"项目可独立运行\",{\"1\":{\"726\":1}}],[\"项目磁盘路径\",{\"1\":{\"653\":1}}],[\"项目\",{\"0\":{\"299\":1},\"1\":{\"649\":1,\"655\":1}}],[\"项目的创新点\",{\"0\":{\"298\":1}}],[\"项目的难点\",{\"0\":{\"297\":1}}],[\"项目描述\",{\"0\":{\"295\":1}}],[\"项目名称\",{\"0\":{\"294\":1}}],[\"地空闲状态\",{\"1\":{\"419\":1}}],[\"地质灾害影响人群分析系统\",{\"1\":{\"294\":1}}],[\"地址\",{\"1\":{\"1019\":1,\"1031\":1}}],[\"地址转换时不需要访问磁盘\",{\"1\":{\"169\":1}}],[\"地址变换机构\",{\"1\":{\"162\":2}}],[\"地址变换是在装入的时候一次性完成的\",{\"1\":{\"151\":1}}],[\"像个弹簧一样\",{\"1\":{\"974\":1}}],[\"像企业级mysql加上固态硬盘能够支撑的并发\",{\"1\":{\"955\":1}}],[\"像控制反转和依赖注入功能\",{\"1\":{\"451\":1}}],[\"像c语言中指针存储的数值就可以理解为逻辑地址\",{\"1\":{\"414\":1}}],[\"像平板\",{\"1\":{\"305\":1}}],[\"像可以设置两个参数30天出现20天及以上的\",{\"1\":{\"296\":1}}],[\"像乒乓球和羽毛球都打得不错\",{\"1\":{\"293\":1}}],[\"像大数据方面我也对hadoop\",{\"1\":{\"293\":1}}],[\"像前端方面我也系统了解过javascript和vue以及vue的组件框架element\",{\"1\":{\"293\":1}}],[\"像reentrantlock\",{\"1\":{\"251\":1}}],[\"华为手机\",{\"1\":{\"950\":1}}],[\"华为在19年也发布了自己的操作系统鸿蒙\",{\"1\":{\"305\":1}}],[\"华为这个名字的由来是\",{\"1\":{\"304\":1,\"305\":1}}],[\"华为这个品牌的国民认可度还是很高的\",{\"1\":{\"304\":1}}],[\"华为的第一台交换机就是看南邮的教科书实现的\",{\"1\":{\"304\":1,\"305\":1}}],[\"华为最开始是做交换机的\",{\"1\":{\"304\":1,\"305\":1}}],[\"华为面经总结\",{\"0\":{\"292\":1}}],[\"华硕\",{\"1\":{\"52\":2}}],[\"拿到触发事件的channel\",{\"1\":{\"890\":1}}],[\"拿到\",{\"1\":{\"816\":1}}],[\"拿到一个事件\",{\"1\":{\"793\":1}}],[\"拿到空的\",{\"1\":{\"788\":1}}],[\"拿到的是产品对象\",{\"1\":{\"678\":1}}],[\"拿出堆顶的输入流\",{\"1\":{\"291\":1}}],[\"拿铁咖啡和提拉米苏是同一产品族\",{\"1\":{\"74\":1}}],[\"题目描述\",{\"0\":{\"289\":1}}],[\"树非叶子节点也存储数据\",{\"1\":{\"378\":1}}],[\"树状数组\",{\"0\":{\"286\":1}}],[\"树形结构不便于实现文件的共享\",{\"1\":{\"168\":1}}],[\"树形目录结构可以很方便的对文件进行分类\",{\"1\":{\"168\":1}}],[\"虽说如此\",{\"1\":{\"281\":1}}],[\"虽然有channel对象\",{\"1\":{\"803\":1}}],[\"虽然reids是c语言编写的\",{\"1\":{\"422\":1}}],[\"虽然连接数有上限\",{\"1\":{\"410\":1}}],[\"虽然spring执行不报错\",{\"1\":{\"366\":1}}],[\"虽然我们会对各个收集器进行比较\",{\"1\":{\"360\":1}}],[\"虽然压缩列表紧凑型的内存布局能节省内存开销\",{\"1\":{\"281\":1}}],[\"虽然\",{\"1\":{\"277\":1}}],[\"虽然算法性能好\",{\"1\":{\"163\":1}}],[\"虽然可以提供给多个进程使用\",{\"1\":{\"127\":1}}],[\"虽然它不强制要求所有的子类必须遵循这些契约\",{\"1\":{\"108\":1}}],[\"推断主启动类\",{\"1\":{\"650\":1}}],[\"推断应用类型\",{\"1\":{\"650\":1}}],[\"推动了第二张牌倒下\",{\"1\":{\"280\":1}}],[\"推荐使用\",{\"1\":{\"719\":1}}],[\"推荐使用增长的数值类型值作为主键来说不适合\",{\"1\":{\"439\":1}}],[\"推荐使用uuid\",{\"1\":{\"392\":1}}],[\"推荐的主键设计\",{\"0\":{\"392\":1}}],[\"推荐受用具体字段查询\",{\"1\":{\"388\":1}}],[\"推荐\",{\"1\":{\"265\":5,\"266\":6,\"267\":1,\"268\":1,\"778\":1}}],[\"造成内存资源的严重浪费\",{\"1\":{\"419\":1}}],[\"造成系统吞吐量的下降\",{\"1\":{\"356\":1}}],[\"造成访问压缩列表性能的下降\",{\"1\":{\"280\":1}}],[\"造者模式所创建的产品一般具有较多的共同点\",{\"1\":{\"50\":1}}],[\"连上了\",{\"1\":{\"887\":1}}],[\"连接等待时间\",{\"1\":{\"1039\":1}}],[\"连接池的初始化\",{\"1\":{\"1034\":1}}],[\"连接\",{\"1\":{\"916\":1}}],[\"连接已建立\",{\"1\":{\"886\":3}}],[\"连接已经断开了\",{\"1\":{\"764\":1}}],[\"连接集合\",{\"1\":{\"876\":1,\"877\":1}}],[\"连接肯定建立了\",{\"1\":{\"803\":2}}],[\"连接未建立\",{\"1\":{\"803\":2}}],[\"连接事件\",{\"1\":{\"792\":1}}],[\"连接假死\",{\"0\":{\"764\":1}}],[\"连接表的数量尽量不要超过\",{\"1\":{\"383\":1}}],[\"连接操作时\",{\"1\":{\"383\":1}}],[\"连接建立后\",{\"1\":{\"331\":1}}],[\"连锁更新\",{\"0\":{\"280\":1},\"1\":{\"280\":2,\"281\":2}}],[\"连续分配的文件在顺序访问时速度最快\",{\"1\":{\"169\":1}}],[\"连续分配方式要求每个文件在磁盘上占有一组连续的块\",{\"1\":{\"169\":1}}],[\"连续分配\",{\"1\":{\"154\":1,\"169\":1,\"170\":1}}],[\"连续分配管理方式是指为一个程序分配一个连续的内存空间\",{\"1\":{\"413\":1}}],[\"连续分配管理方式\",{\"0\":{\"154\":1}}],[\"了不起的我\",{\"1\":{\"731\":1}}],[\"了解什么设计模式\",{\"1\":{\"740\":1}}],[\"了解\",{\"1\":{\"691\":2}}],[\"了它的功能\",{\"1\":{\"449\":1}}],[\"了\",{\"1\":{\"279\":1,\"280\":1,\"825\":1}}],[\"十进制255\",{\"1\":{\"279\":1}}],[\"尾部\",{\"1\":{\"279\":1}}],[\"甚至可以是图格式\",{\"1\":{\"1004\":1}}],[\"甚至可能引发连锁更新的问题\",{\"1\":{\"278\":1}}],[\"甚至json\",{\"1\":{\"1001\":1}}],[\"甚至是一张图片或一个pdf文档等不同的媒体形式\",{\"1\":{\"736\":2}}],[\"甚至全部死锁的进程\",{\"1\":{\"150\":1}}],[\"缓存击穿\",{\"1\":{\"990\":1}}],[\"缓存击穿问题也叫热点key问题\",{\"1\":{\"987\":1}}],[\"缓存击穿问题及解决思路\",{\"0\":{\"987\":1}}],[\"缓存重建\",{\"1\":{\"989\":1,\"990\":1}}],[\"缓存雪崩是指在同一时段大量的缓存key同时失效或者redis服务宕机\",{\"1\":{\"986\":1}}],[\"缓存雪崩问题及解决思路\",{\"0\":{\"986\":1}}],[\"缓存null值\",{\"1\":{\"985\":1}}],[\"缓存空对象思路分析\",{\"1\":{\"984\":1}}],[\"缓存空对象\",{\"1\":{\"984\":1}}],[\"缓存穿透的解决方案有哪些\",{\"1\":{\"985\":1}}],[\"缓存穿透产生的原因是什么\",{\"1\":{\"985\":1}}],[\"缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在\",{\"1\":{\"984\":1}}],[\"缓存穿透\",{\"1\":{\"984\":1,\"985\":1,\"988\":1,\"990\":2}}],[\"缓存穿透问题的解决思路\",{\"0\":{\"984\":1}}],[\"缓存调用者在更新完数据库后再去更新缓存\",{\"1\":{\"981\":1}}],[\"缓存更新是redis为了节约内存而设计出来的一个东西\",{\"1\":{\"980\":1}}],[\"缓存更新策略\",{\"0\":{\"980\":1}}],[\"缓存模型和思路\",{\"0\":{\"978\":1}}],[\"缓存可以大大降低用户访问并发量带来的服务器读写压力\",{\"1\":{\"975\":1}}],[\"缓存数据存储于代码中\",{\"1\":{\"975\":1}}],[\"缓存伪共享\",{\"1\":{\"905\":1}}],[\"缓存i\",{\"1\":{\"408\":2}}],[\"缓存\",{\"0\":{\"408\":1},\"1\":{\"278\":1,\"974\":1}}],[\"缓冲可写\",{\"1\":{\"894\":1}}],[\"缓冲池有位置了\",{\"1\":{\"745\":1}}],[\"缓冲池\",{\"1\":{\"186\":1}}],[\"缓冲区的数据写入网卡\",{\"1\":{\"904\":1,\"905\":1}}],[\"缓冲区写不下时再关注可写事件\",{\"1\":{\"894\":1}}],[\"缓冲区对象内置了一些机制\",{\"1\":{\"332\":1}}],[\"缓冲区本质上是一个可以读写数据的内存块\",{\"1\":{\"332\":1}}],[\"缓冲区\",{\"1\":{\"332\":1,\"883\":1,\"904\":1,\"905\":2}}],[\"缓冲区介绍以及作用\",{\"1\":{\"186\":1}}],[\"缓冲区管理\",{\"0\":{\"186\":1}}],[\"默认有16个库\",{\"1\":{\"1015\":1}}],[\"默认有如下数据\",{\"1\":{\"337\":1}}],[\"默认启动\",{\"0\":{\"1014\":1},\"1\":{\"1013\":1}}],[\"默认的安装路径是在\",{\"1\":{\"1012\":1}}],[\"默认类型为\",{\"1\":{\"923\":1}}],[\"默认文件\",{\"1\":{\"908\":1}}],[\"默认开启\",{\"1\":{\"897\":1}}],[\"默认习惯是\",{\"1\":{\"822\":1}}],[\"默认是采用jdk序列化\",{\"1\":{\"1041\":1}}],[\"默认是6379\",{\"1\":{\"1018\":1}}],[\"默认是当前目录\",{\"1\":{\"1015\":1}}],[\"默认是127\",{\"1\":{\"1015\":1,\"1018\":1}}],[\"默认是非池化实现\",{\"1\":{\"820\":1}}],[\"默认是\",{\"1\":{\"791\":1}}],[\"默认以\",{\"1\":{\"755\":1}}],[\"默认\",{\"1\":{\"751\":1,\"792\":1,\"794\":1}}],[\"默认作用域\",{\"1\":{\"710\":1}}],[\"默认全部初始化并进行依赖注入\",{\"1\":{\"707\":1}}],[\"默认采用延迟初始化策略\",{\"1\":{\"707\":1}}],[\"默认就是\",{\"1\":{\"668\":1}}],[\"默认不再支持自定义索引类型\",{\"1\":{\"923\":1}}],[\"默认不带\",{\"1\":{\"648\":1}}],[\"默认不允许跨\",{\"1\":{\"449\":1}}],[\"默认映射路径为\",{\"1\":{\"644\":1}}],[\"默认值\",{\"1\":{\"568\":1,\"926\":1}}],[\"默认值是1024\",{\"1\":{\"410\":1}}],[\"默认false\",{\"1\":{\"372\":1}}],[\"默认1\",{\"1\":{\"323\":1}}],[\"默认情况下所有的socket都是blocking\",{\"1\":{\"409\":1}}],[\"默认情况下\",{\"1\":{\"277\":1,\"710\":1,\"928\":1}}],[\"默认为空\",{\"1\":{\"1015\":1}}],[\"默认为flow\",{\"1\":{\"745\":1}}],[\"默认为\",{\"1\":{\"617\":1,\"794\":1}}],[\"默认为16\",{\"1\":{\"328\":1}}],[\"默认为8\",{\"1\":{\"327\":1}}],[\"默认为0\",{\"1\":{\"249\":1,\"328\":1}}],[\"默认为5\",{\"1\":{\"205\":1}}],[\"未过期\",{\"1\":{\"989\":1,\"990\":1}}],[\"未必时时可写\",{\"1\":{\"878\":1}}],[\"未关注事件\",{\"1\":{\"790\":1}}],[\"未设置延迟\",{\"1\":{\"496\":1}}],[\"未来五年我希望能够留在南京\",{\"1\":{\"307\":1}}],[\"未来五年的职业规划\",{\"0\":{\"307\":1}}],[\"未使用空间\",{\"1\":{\"277\":2}}],[\"未修改过的页面不用写回外存\",{\"1\":{\"162\":1}}],[\"翻倍扩容\",{\"1\":{\"277\":1}}],[\"翻炒是一样的\",{\"1\":{\"120\":1}}],[\"翻炒\",{\"1\":{\"120\":1}}],[\"翻炒等步骤\",{\"1\":{\"120\":1}}],[\"里面有\",{\"1\":{\"796\":1}}],[\"里也能获取到\",{\"1\":{\"617\":1}}],[\"里的数据\",{\"1\":{\"277\":1}}],[\"里氏替换原则告诉我们\",{\"1\":{\"108\":1}}],[\"里氏替换原则\",{\"1\":{\"108\":1}}],[\"里氏代换原则\",{\"0\":{\"108\":1}}],[\"既可以支持正向检索和也可以支持反向检索\",{\"1\":{\"1028\":1}}],[\"既可用于\",{\"1\":{\"779\":1}}],[\"既不需要手动修改\",{\"1\":{\"277\":1}}],[\"既然之前的拦截器无法对不需要拦截的路径生效\",{\"1\":{\"971\":1}}],[\"既然每个请求都是独立的\",{\"1\":{\"961\":1}}],[\"既然没有接口都可以用cglib\",{\"0\":{\"718\":1}}],[\"既然redo\",{\"1\":{\"396\":1}}],[\"既然\",{\"1\":{\"275\":1}}],[\"稍微一不注意\",{\"1\":{\"276\":1}}],[\"语法有统一标准\",{\"1\":{\"1006\":1}}],[\"语句的\",{\"1\":{\"383\":1}}],[\"语句相同\",{\"1\":{\"267\":1}}],[\"语言版本\",{\"1\":{\"440\":1}}],[\"语言标准库的函数\",{\"1\":{\"277\":1}}],[\"语言标准库中字符串的操作函数是很不安全的\",{\"1\":{\"276\":1}}],[\"语言标准库中的字符串操作函数就通过判断字符是不是\",{\"1\":{\"276\":1}}],[\"语言字符串用\",{\"1\":{\"276\":1}}],[\"语言字符串的缺陷\",{\"0\":{\"276\":1},\"1\":{\"277\":1}}],[\"语言获取字符串长度的时间复杂度是\",{\"1\":{\"276\":1}}],[\"语言获取字符串长度的函数\",{\"1\":{\"276\":1}}],[\"语言里\",{\"1\":{\"276\":1}}],[\"语言的字符串标准库提供的字符串操作函数\",{\"1\":{\"277\":1}}],[\"语言的字符串长度获取\",{\"1\":{\"277\":1}}],[\"语言的字符串不足之处以及可以改进的地方\",{\"1\":{\"276\":1}}],[\"语言的字符串是不会记录自身的缓冲区大小的\",{\"1\":{\"276\":1}}],[\"语言的字符串只能保存文本数据\",{\"1\":{\"276\":1}}],[\"语言的字符串其实就是一个字符数组\",{\"1\":{\"276\":1}}],[\"语言的同学\",{\"1\":{\"276\":1}}],[\"语言的\",{\"1\":{\"275\":2}}],[\"语言实现的\",{\"1\":{\"275\":1}}],[\"值也有所不同\",{\"1\":{\"751\":1}}],[\"值为多个自动配置类名\",{\"1\":{\"670\":1}}],[\"值\",{\"1\":{\"439\":1,\"776\":1,\"822\":9}}],[\"值很重要\",{\"1\":{\"328\":1}}],[\"值时\",{\"1\":{\"328\":1}}],[\"值有时也是字符串类型\",{\"1\":{\"275\":1}}],[\"值存储的是对应的对象\",{\"1\":{\"77\":1}}],[\"邮箱的垃圾邮件过滤\",{\"1\":{\"274\":1}}],[\"综合\",{\"1\":{\"574\":1}}],[\"综合考虑使用方案一\",{\"1\":{\"982\":1}}],[\"综合考虑了等待时间和运行时间\",{\"1\":{\"139\":1}}],[\"综合考虑作业\",{\"1\":{\"139\":1}}],[\"综上\",{\"1\":{\"273\":1}}],[\"去降低代的耦合\",{\"1\":{\"1034\":1}}],[\"去调用操作系统\",{\"1\":{\"904\":1}}],[\"去调用它创建和运行\",{\"1\":{\"648\":1}}],[\"去执行关闭\",{\"1\":{\"805\":1}}],[\"去除重复元素\",{\"1\":{\"338\":1}}],[\"去年找实习一面被刷\",{\"1\":{\"310\":1}}],[\"去重\",{\"1\":{\"274\":2}}],[\"去重非常方便\",{\"1\":{\"273\":1}}],[\"去银行办理业务一般要经过以下4个流程\",{\"1\":{\"118\":1}}],[\"≈\",{\"1\":{\"272\":1}}],[\"年关将至\",{\"1\":{\"766\":1}}],[\"年提出的\",{\"1\":{\"272\":1}}],[\"年龄区间\",{\"1\":{\"265\":1}}],[\"根节点是黑色\",{\"1\":{\"270\":1}}],[\"根据多个key获取多个string类型的value\",{\"1\":{\"1025\":1}}],[\"根据多态的特性\",{\"1\":{\"94\":1}}],[\"根据key获取string类型的value\",{\"1\":{\"1025\":1}}],[\"根据指定的key查询缓存\",{\"1\":{\"990\":4}}],[\"根据id查询数据库\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"990\":2}}],[\"根据id查询店铺时\",{\"1\":{\"983\":1}}],[\"根据id修改店铺时\",{\"1\":{\"983\":1}}],[\"根据手机号查询用户\",{\"1\":{\"960\":1,\"968\":1}}],[\"根据经验mysql企业级服务器只要上点并发\",{\"1\":{\"955\":1}}],[\"根据虚引用释放堆外内存\",{\"1\":{\"905\":1}}],[\"根据消息类型字节\",{\"1\":{\"773\":1}}],[\"根据用户名获取\",{\"1\":{\"758\":1}}],[\"根据监听器方法参数确定事件类型\",{\"1\":{\"699\":1}}],[\"根据接口泛型确定事件类型\",{\"1\":{\"699\":1}}],[\"根据接口生成的\",{\"1\":{\"486\":1}}],[\"根据此类型找到多个\",{\"1\":{\"695\":2}}],[\"根据一个固定为\",{\"1\":{\"617\":1}}],[\"根据状态码去找\",{\"1\":{\"617\":1}}],[\"根据他俩创建\",{\"1\":{\"546\":1}}],[\"根据上面的要素\",{\"1\":{\"770\":1}}],[\"根据上述分析\",{\"1\":{\"513\":1}}],[\"根据上一局的手势从概率上计算出下一局的手势从这前的猜拳结果计算下一局出各种拳的概率\",{\"1\":{\"116\":1}}],[\"根据\",{\"1\":{\"458\":2,\"528\":1,\"576\":1,\"644\":1}}],[\"根据锁的粒度进行分类\",{\"0\":{\"399\":1}}],[\"根据锁的类型分类\",{\"0\":{\"398\":1}}],[\"根据实际文本区分度决定索引长度\",{\"1\":{\"383\":1}}],[\"根据实际文本区分度决定索引长度即可\",{\"1\":{\"266\":1}}],[\"根据该字符串是否在常量池中存在\",{\"1\":{\"354\":1}}],[\"根据业务需求而变\",{\"1\":{\"314\":2}}],[\"根据字符串的长度大小\",{\"1\":{\"279\":1}}],[\"根据得到的哈希值\",{\"1\":{\"273\":1}}],[\"根据墨菲定律\",{\"1\":{\"266\":1}}],[\"根据coct找到chct\",{\"1\":{\"185\":1}}],[\"根据dct找到coct\",{\"1\":{\"185\":1}}],[\"根据sdt找到dct\",{\"1\":{\"185\":1}}],[\"根据进程请求的物理设备名查找sdt\",{\"1\":{\"185\":1}}],[\"根据进程的大小动态建立分区\",{\"1\":{\"154\":1}}],[\"根据设备类型选择调用相应的驱动程序\",{\"1\":{\"182\":1}}],[\"根据各条记录的长度\",{\"1\":{\"167\":1}}],[\"根据局部性原理\",{\"1\":{\"164\":1}}],[\"根据拆分的很多个页表建立页目录表\",{\"1\":{\"158\":1}}],[\"根据常在系统中运行的作业大小情况进行划分\",{\"1\":{\"154\":1}}],[\"根据内存的当前情况\",{\"1\":{\"151\":1}}],[\"根据优先级是否可以动态改变\",{\"1\":{\"139\":1}}],[\"根据中断信号类型转入相应的中断处理程序\",{\"1\":{\"129\":1}}],[\"根据依赖倒转原则进行改进\",{\"1\":{\"109\":1}}],[\"根据键获取值\",{\"1\":{\"77\":1}}],[\"节省运行期间扫描\",{\"1\":{\"682\":1}}],[\"节省内存空间\",{\"1\":{\"277\":1}}],[\"节点失败的情况下\",{\"1\":{\"928\":1}}],[\"节点不知怎么的就处于离线状态\",{\"1\":{\"928\":1}}],[\"节点的\",{\"1\":{\"280\":2}}],[\"节点距离起始地址由多少字节\",{\"1\":{\"279\":1}}],[\"节点是红色或黑色\",{\"1\":{\"270\":1}}],[\"节约了我们的空间~\",{\"1\":{\"1042\":1}}],[\"节约了线程的数量\",{\"1\":{\"879\":1}}],[\"节约索引存储\",{\"1\":{\"265\":1}}],[\"节约软件开发成本和维护成本\",{\"1\":{\"106\":1}}],[\"事务\",{\"0\":{\"1007\":1},\"1\":{\"998\":1}}],[\"事务想要生效\",{\"1\":{\"998\":1}}],[\"事务将不会发生回滚\",{\"1\":{\"720\":1}}],[\"事务传播类型\",{\"1\":{\"720\":1}}],[\"事务处理也是通过aop实现的\",{\"1\":{\"716\":1}}],[\"事务通知类\",{\"1\":{\"662\":1}}],[\"事务切面类\",{\"1\":{\"662\":1}}],[\"事务自动配置类有两个\",{\"1\":{\"662\":1}}],[\"事务等待链表\",{\"1\":{\"403\":1}}],[\"事务都无法推进下去\",{\"1\":{\"403\":1}}],[\"事务有意向对表中的某些行加排他锁\",{\"1\":{\"400\":1}}],[\"事务有意向对表中的某些行加共享锁\",{\"1\":{\"400\":1}}],[\"事务便可以修改数据\",{\"1\":{\"396\":1}}],[\"事务在修改数据之前\",{\"1\":{\"396\":1}}],[\"事务的打开\",{\"1\":{\"721\":1}}],[\"事务的持久性无法保证\",{\"1\":{\"396\":1}}],[\"事务的四大特性以及如何实现\",{\"0\":{\"396\":1}}],[\"事务一旦提交\",{\"1\":{\"396\":1}}],[\"事务与事务之间的操作时互相隔离互不干扰的\",{\"1\":{\"396\":1}}],[\"事务中任何一个sql语句执行失败\",{\"1\":{\"396\":1}}],[\"事务会影响数据库的qps\",{\"1\":{\"268\":1}}],[\"事件发生后要么处理\",{\"1\":{\"890\":1}}],[\"事件发生后\",{\"1\":{\"885\":1}}],[\"事件发生后能否不处理💡\",{\"0\":{\"885\":1}}],[\"事件发生时\",{\"1\":{\"883\":1}}],[\"事件发生线程才去处理\",{\"1\":{\"879\":1}}],[\"事件发布器模拟实现\",{\"1\":{\"703\":1}}],[\"事件发布器\",{\"0\":{\"700\":1,\"701\":1}}],[\"事件发布还可以异步\",{\"1\":{\"449\":1}}],[\"事件发布与监听\",{\"1\":{\"446\":1,\"449\":1}}],[\"事件处理时的线程安全\",{\"1\":{\"796\":1}}],[\"事件处理耗时\",{\"1\":{\"791\":1}}],[\"事件都由此\",{\"1\":{\"796\":1}}],[\"事件循环组\",{\"1\":{\"796\":1}}],[\"事件循环对象\",{\"1\":{\"796\":1}}],[\"事件监听器的两种方式\",{\"1\":{\"699\":1}}],[\"事件监听器\",{\"0\":{\"696\":1,\"697\":1}}],[\"事件7️⃣\",{\"1\":{\"650\":1}}],[\"事件6️⃣\",{\"1\":{\"650\":1}}],[\"事件5️⃣\",{\"1\":{\"650\":1}}],[\"事件4️⃣\",{\"1\":{\"650\":1}}],[\"事件1️⃣\",{\"1\":{\"650\":1}}],[\"事件解耦\",{\"1\":{\"449\":1}}],[\"事件\",{\"0\":{\"798\":1,\"881\":1,\"882\":1,\"884\":1,\"886\":1,\"892\":1},\"1\":{\"332\":1,\"410\":1,\"759\":1,\"762\":1,\"764\":2,\"767\":1,\"790\":4,\"791\":3,\"792\":1,\"793\":5,\"794\":3,\"796\":1,\"798\":2,\"800\":1,\"883\":3,\"887\":2,\"890\":1,\"893\":1,\"896\":2,\"909\":2}}],[\"事情的结果如何\",{\"1\":{\"308\":1}}],[\"事实上\",{\"1\":{\"161\":1,\"163\":1,\"409\":1,\"410\":1}}],[\"二狗\",{\"1\":{\"1029\":1}}],[\"二叉树退化导致的递归爆栈问题\",{\"1\":{\"740\":1}}],[\"二叉树构建\",{\"0\":{\"283\":1}}],[\"二十二岁的林朝夕在父亲确诊阿尔茨海默病这天\",{\"1\":{\"731\":1}}],[\"二者均为全双工\",{\"1\":{\"900\":1}}],[\"二者成员变量并不共用数据\",{\"1\":{\"686\":1}}],[\"二者互为存在的条件\",{\"1\":{\"127\":1}}],[\"二级页表\",{\"1\":{\"413\":1}}],[\"二进制安全\",{\"1\":{\"277\":1}}],[\"二是效率低\",{\"1\":{\"268\":1}}],[\"增改查数据都会先加载到mysql的缓存中\",{\"1\":{\"976\":1}}],[\"增强id的复杂度\",{\"1\":{\"985\":1}}],[\"增强逻辑\",{\"1\":{\"516\":2}}],[\"增强\",{\"0\":{\"606\":1},\"1\":{\"513\":1,\"607\":1,\"644\":2}}],[\"增量收集算法\",{\"0\":{\"356\":1}}],[\"增减字段容易与resultmap配置不一致\",{\"1\":{\"268\":1}}],[\"增加1\",{\"1\":{\"1025\":1}}],[\"增加一人一单逻辑\",{\"1\":{\"998\":1}}],[\"增加配置类和配置文件\",{\"1\":{\"773\":1}}],[\"增加查询分析器解析成本\",{\"1\":{\"268\":1}}],[\"增加size计数\",{\"1\":{\"249\":1}}],[\"增加对象间的耦合性\",{\"1\":{\"108\":1}}],[\"增加软件的可扩展性和灵活性\",{\"1\":{\"106\":1}}],[\"增加了cpu的l1\",{\"1\":{\"976\":1}}],[\"增加了请求调段及分段置换功能后形成的段式虚拟存储系统\",{\"1\":{\"419\":1}}],[\"增加了三个元数据\",{\"1\":{\"277\":1}}],[\"增加了延迟时间\",{\"1\":{\"177\":1}}],[\"增加了灵活性\",{\"1\":{\"154\":1}}],[\"增加了用户编程的负担\",{\"1\":{\"153\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"97\":1}}],[\"增加了代码维护的复杂度\",{\"1\":{\"96\":1}}],[\"增加新产品时还是需要修改工厂类的代码\",{\"1\":{\"64\":1}}],[\"速度快\",{\"1\":{\"267\":1,\"1009\":1}}],[\"速度非常慢\",{\"1\":{\"266\":1}}],[\"比较适合用来实现特殊的功能需求\",{\"1\":{\"1031\":1}}],[\"比较费解\",{\"1\":{\"792\":1}}],[\"比较好理解\",{\"1\":{\"792\":1}}],[\"比较常用的比如annotationconfigapplicationcontext\",{\"1\":{\"708\":1}}],[\"比\",{\"1\":{\"267\":1,\"449\":1,\"911\":1}}],[\"比如我们tomcat中的线程池\",{\"1\":{\"1033\":1}}],[\"比如唯一性\",{\"1\":{\"1001\":1}}],[\"比如时间是否充足\",{\"1\":{\"995\":1,\"998\":1}}],[\"比如商城在一天时间内\",{\"1\":{\"992\":1}}],[\"比如之前提到的map\",{\"1\":{\"976\":1}}],[\"比如说我们的数据库连接池\",{\"1\":{\"1033\":1}}],[\"比如说\",{\"1\":{\"922\":1}}],[\"比如一个\",{\"1\":{\"891\":1}}],[\"比如一个线程发起建立连接\",{\"1\":{\"805\":1}}],[\"比如get和post\",{\"1\":{\"737\":1}}],[\"比如当我们引用第三方库中的类需要装配到spring容器中时\",{\"1\":{\"713\":1}}],[\"比如dao\",{\"1\":{\"712\":1}}],[\"比如beannameaware中setbeanname\",{\"1\":{\"711\":1}}],[\"比如条件是\",{\"1\":{\"672\":1}}],[\"比如直播间礼物排行\",{\"1\":{\"422\":1}}],[\"比如集合的交集和并集\",{\"1\":{\"422\":1}}],[\"比如用户的访问次数\",{\"1\":{\"422\":1}}],[\"比如可以通过aop实现应用程序中的日志功能\",{\"1\":{\"716\":1}}],[\"比如可以用于王者荣耀玩家加载\",{\"1\":{\"262\":1}}],[\"比如可能对操作系统造成伤害以及给同时运行多个程序造成困难\",{\"1\":{\"415\":1}}],[\"比如数据页或数据表加上意向锁\",{\"1\":{\"400\":1}}],[\"比如自定义string类\",{\"1\":{\"346\":1}}],[\"比如相册服务器\",{\"1\":{\"334\":1}}],[\"比如聊天服务器等等\",{\"1\":{\"334\":1}}],[\"比如在退款的时候\",{\"1\":{\"315\":1}}],[\"比如在put操作中\",{\"1\":{\"249\":1}}],[\"比如订单的状态有提交\",{\"1\":{\"315\":1}}],[\"比如订单的流水号\",{\"1\":{\"315\":1}}],[\"比如订单的问题\",{\"1\":{\"313\":1}}],[\"比如订单提交\",{\"1\":{\"314\":1}}],[\"比如根据id更新数据\",{\"1\":{\"314\":1}}],[\"比如根据id删除某一个资源\",{\"1\":{\"314\":1}}],[\"比如根据网络制式查询对应的常驻人口或者说更具设备名称以及时间段复合查询满足条件的常驻人口\",{\"1\":{\"296\":1}}],[\"比如羽毛球\",{\"1\":{\"309\":1}}],[\"比如沃兹想让乔布斯在发布会上感谢appleⅱ团队\",{\"1\":{\"306\":1}}],[\"比如controller层发送给前端的参数如何包装等等~~\",{\"1\":{\"297\":1}}],[\"比如copy\",{\"1\":{\"162\":1}}],[\"比如常驻人口定义参数\",{\"1\":{\"296\":1}}],[\"比如归属地就选择top10进行饼状图展示\",{\"1\":{\"296\":1}}],[\"比如有缓冲区溢出的风险\",{\"1\":{\"276\":1}}],[\"比如有三个进程a\",{\"1\":{\"148\":1}}],[\"比如爬给定网址的时候对已经爬取过的\",{\"1\":{\"274\":1}}],[\"比如判断一个数字是否存在于包含大量数字的数字集中\",{\"1\":{\"274\":1}}],[\"比如下面代码\",{\"1\":{\"368\":1}}],[\"比如下面这种情况\",{\"1\":{\"263\":1}}],[\"比如下面这些\",{\"1\":{\"255\":1}}],[\"比如下图中t2和t3就占有共享锁\",{\"1\":{\"253\":1}}],[\"比如reentrantreadwritelock中的写锁可以降级为读锁\",{\"1\":{\"252\":1}}],[\"比如reentrantreadwritelock\",{\"1\":{\"252\":1,\"253\":1}}],[\"比如字符串常量池\",{\"1\":{\"238\":1}}],[\"比如spring中的bean的创建\",{\"1\":{\"1034\":1}}],[\"比如spf如果有源源不断的短进程到来\",{\"1\":{\"147\":1}}],[\"比如syn\",{\"1\":{\"996\":1}}],[\"比如string则比较的具体内容是否相等\",{\"1\":{\"319\":1}}],[\"比如substring\",{\"1\":{\"236\":1}}],[\"比如atomicinteger\",{\"1\":{\"230\":1}}],[\"比如volatile修饰的i\",{\"1\":{\"228\":1}}],[\"比如p2中申请一个r1\",{\"1\":{\"150\":1}}],[\"比如使用spooling技术\",{\"1\":{\"148\":1}}],[\"比如使用继承会给程序带来侵入性\",{\"1\":{\"108\":1}}],[\"比如flag\",{\"1\":{\"141\":1}}],[\"比如摄像头\",{\"1\":{\"140\":1}}],[\"比如打印机\",{\"1\":{\"135\":1}}],[\"比如qq要发送文件\",{\"1\":{\"135\":1}}],[\"比如共享空间里只能放一个长度为10的数组\",{\"1\":{\"134\":1}}],[\"比如获取打印机等\",{\"1\":{\"132\":1}}],[\"比如代码和数据存储的位置\",{\"1\":{\"131\":1}}],[\"比如进程切换\",{\"1\":{\"129\":1}}],[\"比如虚拟存储技术\",{\"1\":{\"127\":1}}],[\"比如扬声器可以同时播放两个地方的\",{\"1\":{\"127\":1}}],[\"比如\",{\"1\":{\"127\":3,\"132\":1,\"140\":1,\"143\":1,\"147\":2,\"154\":1,\"159\":1,\"163\":1,\"166\":1,\"167\":1,\"170\":1,\"173\":1,\"183\":1,\"276\":2,\"277\":5,\"279\":1,\"345\":1,\"383\":1,\"386\":1,\"391\":1,\"424\":1,\"706\":1,\"731\":1,\"922\":1,\"924\":1,\"927\":1}}],[\"比如将文件拖拽到垃圾箱\",{\"1\":{\"126\":1}}],[\"比如创建美团外卖等\",{\"1\":{\"63\":1}}],[\"比如13∗13\",{\"1\":{\"24\":1}}],[\"轻松扛下上万并发\",{\"1\":{\"955\":1}}],[\"轻松工作\",{\"1\":{\"267\":2}}],[\"轻负载的hash表具有冲突少\",{\"1\":{\"328\":1}}],[\"轻量级锁\",{\"0\":{\"213\":1}}],[\"均以utf\",{\"1\":{\"267\":1}}],[\"级联更新是强阻塞\",{\"1\":{\"267\":1}}],[\"级别断点\",{\"1\":{\"845\":1}}],[\"级别\",{\"1\":{\"266\":1}}],[\"跟业务相关\",{\"1\":{\"769\":1}}],[\"跟null和非null无关\",{\"1\":{\"267\":1}}],[\"跟数据库无关\",{\"1\":{\"267\":1}}],[\"常见方法\",{\"0\":{\"850\":1}}],[\"常见返回值处理器\",{\"0\":{\"598\":1}}],[\"常见参数的解析\",{\"1\":{\"568\":1}}],[\"常见参数解析器\",{\"0\":{\"566\":1}}],[\"常见\",{\"0\":{\"455\":1},\"1\":{\"535\":1}}],[\"常见的有\",{\"1\":{\"1024\":1}}],[\"常见的解决方案有两种\",{\"1\":{\"984\":1,\"987\":1}}],[\"常见的返回值处理器\",{\"1\":{\"600\":1}}],[\"常见的\",{\"1\":{\"457\":1,\"911\":2}}],[\"常见的如页式管理和段式管理\",{\"1\":{\"413\":1}}],[\"常见的如块式管理\",{\"1\":{\"413\":1}}],[\"常见的几种内存管理机制\",{\"0\":{\"413\":1}}],[\"常见的垃圾回收器算法有哪些\",{\"1\":{\"355\":1}}],[\"常用来存储一个有序数据\",{\"1\":{\"1028\":1}}],[\"常用注解有那些\",{\"0\":{\"721\":1}}],[\"常用于sorted\",{\"1\":{\"425\":1}}],[\"常用命令\",{\"1\":{\"422\":5}}],[\"常用的方法比如getbean\",{\"1\":{\"708\":1}}],[\"常用的channel有\",{\"1\":{\"332\":1}}],[\"常用的段常驻内存\",{\"1\":{\"153\":1}}],[\"常驻人口表字段包括\",{\"1\":{\"296\":1}}],[\"常驻人口分析模块\",{\"1\":{\"296\":1}}],[\"常量池中不会存在相同内容的变量\",{\"1\":{\"354\":1}}],[\"常量与常量引用的拼接结果在常量池\",{\"1\":{\"354\":1}}],[\"常量\",{\"1\":{\"267\":1}}],[\"抵制惟一索引\",{\"1\":{\"266\":1}}],[\"宁缺勿滥\",{\"1\":{\"266\":1}}],[\"宁滥勿缺\",{\"1\":{\"266\":1}}],[\"至于一个分片怎样分布\",{\"1\":{\"927\":1}}],[\"至于是否调用还是得看cpu的分配\",{\"1\":{\"202\":1}}],[\"至少两个线程\",{\"1\":{\"901\":1}}],[\"至少要达到\",{\"1\":{\"266\":1}}],[\"至此双方相安无事\",{\"1\":{\"766\":1}}],[\"至\",{\"1\":{\"652\":1}}],[\"条件查询+分页\",{\"1\":{\"950\":1}}],[\"条件查询\",{\"0\":{\"937\":1},\"1\":{\"937\":1}}],[\"条件成立\",{\"1\":{\"672\":1}}],[\"条件装配的底层是本质上是\",{\"1\":{\"672\":1}}],[\"条件装配底层\",{\"0\":{\"672\":1}}],[\"条件映射\",{\"1\":{\"631\":1}}],[\"条件过滤是非常可怕的\",{\"1\":{\"383\":1}}],[\"条件创建索引\",{\"1\":{\"383\":1}}],[\"条件列检索出来这条记录\",{\"1\":{\"383\":1}}],[\"条件列\",{\"1\":{\"383\":1}}],[\"条件中经常被使用到\",{\"1\":{\"383\":1}}],[\"条件\",{\"1\":{\"266\":1}}],[\"效率不高\",{\"1\":{\"1024\":1}}],[\"效率几乎是原来的四倍\",{\"1\":{\"805\":1}}],[\"效率提升\",{\"1\":{\"410\":1}}],[\"效率较低\",{\"1\":{\"410\":1}}],[\"效率会很低\",{\"1\":{\"396\":1}}],[\"效率就非常的低下\",{\"1\":{\"266\":1}}],[\"效率高\",{\"1\":{\"135\":1,\"442\":1,\"870\":2}}],[\"区分事件类型\",{\"1\":{\"890\":1}}],[\"区分度\",{\"1\":{\"383\":1}}],[\"区分度会\",{\"1\":{\"383\":1}}],[\"区分度会高达90\",{\"1\":{\"266\":1}}],[\"区分度最高的在最左边\",{\"1\":{\"266\":1}}],[\"区域加锁保证更新的原子性\",{\"1\":{\"352\":1}}],[\"区域一起回收\",{\"1\":{\"350\":1}}],[\"区间的数据\",{\"1\":{\"434\":1}}],[\"区间查询\",{\"1\":{\"287\":1}}],[\"区间求和\",{\"0\":{\"287\":1}}],[\"区别在于\",{\"1\":{\"813\":1}}],[\"区别在于打包方式选择\",{\"1\":{\"647\":1}}],[\"区别就是在于cyclibarrier计数变为0后下次再调用可以恢复到初始设定的值\",{\"1\":{\"263\":1}}],[\"区别\",{\"1\":{\"131\":1,\"203\":1,\"244\":1,\"317\":1,\"413\":1}}],[\"业务号\",{\"1\":{\"443\":1}}],[\"业务需要二外执行一次类似last\",{\"1\":{\"391\":1}}],[\"业务表达能力以及团队沟通都是能够锻炼的点\",{\"1\":{\"299\":1}}],[\"业务上具有唯一特性的字段\",{\"1\":{\"266\":1,\"383\":1}}],[\"业务名称\",{\"1\":{\"265\":1}}],[\"太阳\",{\"1\":{\"265\":1}}],[\"太阳花的小绿豆\",{\"1\":{\"31\":1}}],[\"恐龙化石\",{\"1\":{\"265\":1}}],[\"龟\",{\"1\":{\"265\":1}}],[\"合在一起就是\",{\"1\":{\"837\":1}}],[\"合并为一个逻辑上的\",{\"1\":{\"829\":1}}],[\"合理进行任务拆分\",{\"1\":{\"805\":1}}],[\"合适的字符存储长度\",{\"1\":{\"265\":1}}],[\"合成复用原则是指\",{\"1\":{\"112\":1}}],[\"合成复用原则\",{\"0\":{\"112\":1}}],[\"参见定义pojo类以及数据库字段定义规定第8条\",{\"1\":{\"268\":1}}],[\"参考🔖\",{\"0\":{\"902\":1}}],[\"参考实现\",{\"1\":{\"891\":1}}],[\"参考下图\",{\"1\":{\"792\":1}}],[\"参考\",{\"1\":{\"265\":1,\"266\":1,\"267\":2,\"268\":2}}],[\"参数与系统参数\",{\"1\":{\"776\":1}}],[\"参数调优\",{\"0\":{\"774\":1}}],[\"参数名解析\",{\"0\":{\"569\":1}}],[\"参数解析器\",{\"0\":{\"565\":1},\"1\":{\"643\":1}}],[\"参数配置模块\",{\"1\":{\"296\":1}}],[\"参数1\",{\"1\":{\"232\":1}}],[\"参数\",{\"1\":{\"126\":1,\"775\":1,\"776\":1,\"778\":1,\"779\":3,\"780\":1,\"781\":1,\"897\":1}}],[\"冗余字段应遵循\",{\"1\":{\"265\":1}}],[\"库存已经被修改过了\",{\"1\":{\"997\":1}}],[\"库存超卖问题分析\",{\"0\":{\"996\":1}}],[\"库存不足\",{\"1\":{\"995\":2,\"996\":3,\"998\":5}}],[\"库存是否充足\",{\"1\":{\"995\":1}}],[\"库名与应用名称尽量一致\",{\"1\":{\"265\":1}}],[\"库函数在应用程序和系统调用之间\",{\"1\":{\"130\":1}}],[\"步长为指定的increment值\",{\"1\":{\"1030\":1}}],[\"步长为1\",{\"1\":{\"265\":1}}],[\"步走视图解析及渲染流程\",{\"1\":{\"644\":1}}],[\"步视图解析及渲染流程\",{\"1\":{\"644\":1}}],[\"步骤三\",{\"1\":{\"989\":1}}],[\"步骤二\",{\"1\":{\"989\":1}}],[\"步骤一\",{\"1\":{\"989\":1}}],[\"步骤4\",{\"1\":{\"647\":1}}],[\"步骤3\",{\"1\":{\"647\":1}}],[\"步骤2\",{\"1\":{\"647\":1}}],[\"步骤1\",{\"1\":{\"647\":1}}],[\"步骤\",{\"1\":{\"144\":1,\"847\":1}}],[\"得知自己暗恋多年的校园男神裴之即将出国深造的消息\",{\"1\":{\"731\":1}}],[\"得先来看看\",{\"1\":{\"275\":1}}],[\"得到的结果是这样的\",{\"1\":{\"1041\":1}}],[\"得到的反馈是发送超时\",{\"1\":{\"764\":1}}],[\"得到\",{\"1\":{\"650\":1}}],[\"得到一个值\",{\"1\":{\"342\":1}}],[\"得到值之后判断位数组中的每个元素是否都为\",{\"1\":{\"273\":2}}],[\"得到哈希值\",{\"1\":{\"273\":1}}],[\"得到不正确的结果\",{\"1\":{\"265\":1}}],[\"得防着其他线程来修改共享变量\",{\"1\":{\"231\":1}}],[\"请思考\",{\"1\":{\"825\":1}}],[\"请关注下面方法的不同实现\",{\"1\":{\"825\":1}}],[\"请输入密码\",{\"1\":{\"759\":1}}],[\"请输入用户名\",{\"1\":{\"759\":1}}],[\"请你说说spring的核心是什么\",{\"0\":{\"706\":1}}],[\"请你讲一个最近比较烦心的事情\",{\"0\":{\"309\":1}}],[\"请参考\",{\"1\":{\"646\":1}}],[\"请参考mysql官方保留字\",{\"1\":{\"265\":1}}],[\"请自行查阅\",{\"1\":{\"449\":1}}],[\"请检查服务器时间\",{\"1\":{\"441\":1}}],[\"请选cms\",{\"1\":{\"361\":1}}],[\"请选parallel\",{\"1\":{\"361\":1}}],[\"请选serial\",{\"1\":{\"361\":1}}],[\"请讲述这样一次经历\",{\"0\":{\"311\":1}}],[\"请举例讲述一次你失败的经历\",{\"0\":{\"310\":1}}],[\"请把等号条件的列前置\",{\"1\":{\"266\":1}}],[\"请注意利用索引的有序性\",{\"1\":{\"266\":1}}],[\"请不要在创建表时就分库分表\",{\"1\":{\"265\":1}}],[\"请求我们的nginx服务器\",{\"1\":{\"955\":1}}],[\"请求消息处理器\",{\"1\":{\"783\":1}}],[\"请求消息\",{\"1\":{\"783\":1}}],[\"请求序号\",{\"1\":{\"769\":1}}],[\"请求体\",{\"1\":{\"768\":1}}],[\"请求头\",{\"1\":{\"768\":1}}],[\"请求行\",{\"1\":{\"768\":1}}],[\"请求一个数据\",{\"1\":{\"743\":1,\"744\":1}}],[\"请求地址\",{\"1\":{\"737\":1}}],[\"请求类型\",{\"1\":{\"737\":1}}],[\"请求参数\",{\"1\":{\"736\":1}}],[\"请求参数如果有中文\",{\"1\":{\"668\":1}}],[\"请求报文头\",{\"1\":{\"736\":1}}],[\"请求到达服务器\",{\"1\":{\"644\":1}}],[\"请求方法等信息\",{\"1\":{\"561\":1}}],[\"请求结束时销毁\",{\"1\":{\"496\":1}}],[\"请求雪花算法服务获取\",{\"1\":{\"440\":1}}],[\"请求段页式存储管理\",{\"1\":{\"419\":1}}],[\"请求分段系统是在分段系统的基础上\",{\"1\":{\"419\":1}}],[\"请求分段存储管理\",{\"1\":{\"419\":1}}],[\"请求分页管理的方式\",{\"1\":{\"162\":1}}],[\"请求分页存储管理可以提供虚拟内存\",{\"1\":{\"419\":1}}],[\"请求分页存储管理不要求将作业全部地址空间同时装入主存\",{\"1\":{\"419\":1}}],[\"请求分页存储管理建立在分页存储管理之上\",{\"1\":{\"419\":1}}],[\"请求分页存储管理与基本分页存储管理的主要区别\",{\"1\":{\"162\":1}}],[\"请求分页存储管理\",{\"0\":{\"162\":1},\"1\":{\"419\":1}}],[\"请求最终将到达顶层的启动类加载器\",{\"1\":{\"345\":1}}],[\"请求的时候携带这个全局id一起请求\",{\"1\":{\"315\":1}}],[\"请求调页策略\",{\"1\":{\"164\":1}}],[\"请求和响应消息\",{\"1\":{\"783\":1}}],[\"请求和释放资源的顺序不当\",{\"1\":{\"147\":1}}],[\"请求和保持条件\",{\"1\":{\"147\":1,\"221\":1}}],[\"禁用\",{\"1\":{\"659\":1}}],[\"禁用保留字\",{\"1\":{\"265\":1}}],[\"禁止驱逐数据\",{\"1\":{\"429\":1}}],[\"禁止使用存储过程\",{\"1\":{\"267\":1}}],[\"禁止使用float和double\",{\"1\":{\"265\":1}}],[\"禁止两个下划线中间只出现数字\",{\"1\":{\"265\":1}}],[\"禁止出现数字开头\",{\"1\":{\"265\":1}}],[\"禁止指令重排\",{\"1\":{\"227\":1}}],[\"竞争成功\",{\"1\":{\"261\":1}}],[\"竞争的时候是非公平的\",{\"1\":{\"211\":1}}],[\"戳\",{\"1\":{\"260\":1}}],[\"尝试释放被丢弃对象占用的内存\",{\"1\":{\"357\":1}}],[\"尝试释放锁\",{\"1\":{\"255\":2}}],[\"尝试获取锁\",{\"1\":{\"255\":2}}],[\"达到一种并发读的效果\",{\"1\":{\"253\":1}}],[\"达到了与对象解耦的目的\",{\"1\":{\"60\":1}}],[\"象棋中的一个cell累加计数\",{\"1\":{\"249\":1}}],[\"向set中添加一个或多个元素\",{\"1\":{\"1029\":1}}],[\"向列表右侧插入一个或多个元素\",{\"1\":{\"1028\":1}}],[\"向列表左侧插入一个或多个元素\",{\"1\":{\"1028\":1}}],[\"向客户端发送内容\",{\"1\":{\"893\":1}}],[\"向\",{\"0\":{\"852\":1},\"1\":{\"846\":1,\"847\":1,\"859\":1,\"890\":1}}],[\"向下兼容性\",{\"1\":{\"842\":1}}],[\"向后传递\",{\"1\":{\"825\":2}}],[\"向假死的连接发送数据\",{\"1\":{\"764\":1}}],[\"向basecount累加计数\",{\"1\":{\"249\":1}}],[\"向上层提供统一的调用接口\",{\"1\":{\"182\":1}}],[\"追问问题\",{\"1\":{\"308\":1,\"309\":1,\"310\":1,\"311\":1}}],[\"追加字符串函数\",{\"1\":{\"277\":1}}],[\"追加至链表尾\",{\"1\":{\"249\":1}}],[\"追求的是最低的缺页率\",{\"1\":{\"163\":1}}],[\"追求最少的平均等待时间\",{\"1\":{\"139\":1}}],[\"遍历所有事件\",{\"1\":{\"884\":1,\"886\":1}}],[\"遍历目录文件\",{\"1\":{\"872\":1}}],[\"遍历监听器集合\",{\"1\":{\"703\":1}}],[\"遍历整个文件\",{\"1\":{\"291\":1}}],[\"遍历步骤2中的小文件\",{\"1\":{\"290\":1}}],[\"遍历第一个文件\",{\"1\":{\"290\":1}}],[\"遍历结束后\",{\"1\":{\"290\":1}}],[\"遍历链表\",{\"1\":{\"249\":1}}],[\"遍历properties集合对象\",{\"1\":{\"77\":1}}],[\"锁\",{\"1\":{\"998\":1}}],[\"锁的粒度太粗了\",{\"1\":{\"998\":1}}],[\"锁的粒度更小\",{\"1\":{\"249\":1}}],[\"锁的信息链表\",{\"1\":{\"403\":1}}],[\"锁定一个范围包含记录本身\",{\"1\":{\"401\":1}}],[\"锁定一个范围\",{\"1\":{\"401\":1}}],[\"锁可以分为表锁\",{\"1\":{\"396\":1}}],[\"锁机制的基本原理可以概括为\",{\"1\":{\"396\":1}}],[\"锁机制保证隔离性\",{\"1\":{\"396\":1}}],[\"锁状态标志\",{\"1\":{\"353\":1}}],[\"锁升级\",{\"1\":{\"260\":1}}],[\"锁住链表头节点\",{\"1\":{\"249\":1}}],[\"帮忙扩容\",{\"1\":{\"249\":1}}],[\"正准备去扣减库存\",{\"1\":{\"996\":1}}],[\"正式代码\",{\"1\":{\"989\":1}}],[\"正式环境应放在finally或者try\",{\"1\":{\"743\":1,\"744\":1}}],[\"正确使用姿势\",{\"0\":{\"847\":1}}],[\"正确写法\",{\"1\":{\"366\":2}}],[\"正文长度\",{\"1\":{\"769\":1}}],[\"正常化路径\",{\"1\":{\"871\":1}}],[\"正常\",{\"1\":{\"644\":1}}],[\"正常遍历链表\",{\"1\":{\"249\":1}}],[\"正向积极的价值观\",{\"1\":{\"305\":1}}],[\"正向的价值观\",{\"1\":{\"304\":1}}],[\"正如扩展\",{\"1\":{\"280\":1}}],[\"正是因为程序具有局部性原理\",{\"1\":{\"416\":1}}],[\"正是因为这两个阶段\",{\"1\":{\"409\":1}}],[\"正是\",{\"1\":{\"279\":1}}],[\"正例\",{\"1\":{\"265\":5,\"266\":4,\"267\":2,\"268\":1}}],[\"正负样本\",{\"0\":{\"25\":1}}],[\"红色虚线\",{\"1\":{\"360\":1}}],[\"红黑树\",{\"0\":{\"270\":1},\"1\":{\"249\":2}}],[\"红绿灯\",{\"1\":{\"33\":1}}],[\"扩容超过\",{\"1\":{\"823\":1}}],[\"扩容规则是\",{\"1\":{\"823\":1}}],[\"扩容的时候还是会将扩容后的数据长度与integer\",{\"1\":{\"323\":1}}],[\"扩容\",{\"0\":{\"823\":1},\"1\":{\"277\":1}}],[\"扩容时如果某个bin迁移完毕\",{\"1\":{\"249\":1}}],[\"扩容时\",{\"1\":{\"249\":1,\"434\":1}}],[\"扩容线程数\",{\"1\":{\"249\":1}}],[\"扩展性\",{\"1\":{\"1008\":2}}],[\"扩展性高\",{\"1\":{\"58\":1}}],[\"扩展你的搜索量\",{\"1\":{\"928\":1}}],[\"扩展你的内容容量\",{\"1\":{\"927\":1}}],[\"扩展序列化算法\",{\"0\":{\"773\":1}}],[\"扩展一样\",{\"1\":{\"280\":1}}],[\"扩展\",{\"0\":{\"65\":1,\"89\":1},\"1\":{\"280\":1}}],[\"操作数据库的回调函数\",{\"1\":{\"990\":1}}],[\"操作代码\",{\"1\":{\"988\":1}}],[\"操作锁的代码\",{\"1\":{\"988\":1}}],[\"操作缓存和数据库时有三个问题需要考虑\",{\"1\":{\"982\":1}}],[\"操作阻塞\",{\"1\":{\"907\":1}}],[\"操作\",{\"1\":{\"792\":1,\"837\":2,\"996\":1}}],[\"操作元数据的工具类\",{\"1\":{\"480\":1}}],[\"操作时就不满足version=1\",{\"1\":{\"996\":1}}],[\"操作时\",{\"1\":{\"246\":1}}],[\"操作系内存\",{\"1\":{\"235\":1}}],[\"操作系统使用\",{\"1\":{\"904\":1}}],[\"操作系统出于性能的考虑\",{\"1\":{\"869\":1}}],[\"操作系统必须在内存中选择一个页面将其移出内存\",{\"1\":{\"420\":1}}],[\"操作系统虚拟内存介绍\",{\"0\":{\"416\":1}}],[\"操作系统就分配给它一块\",{\"1\":{\"413\":1}}],[\"操作系统内存管理介绍\",{\"0\":{\"411\":1}}],[\"操作系统会将i\",{\"1\":{\"408\":1}}],[\"操作系统会回收进程拥有的资源\",{\"1\":{\"132\":1}}],[\"操作系统将虚拟空间划分成两部分\",{\"1\":{\"406\":1}}],[\"操作系统将进程划分为几种状态\",{\"1\":{\"132\":1}}],[\"操作系统io介绍\",{\"0\":{\"405\":1}}],[\"操作系统层面\",{\"1\":{\"208\":1}}],[\"操作系统是无法修复的\",{\"1\":{\"178\":1}}],[\"操作系统向上提供的功能\",{\"1\":{\"166\":1}}],[\"操作系统下\",{\"0\":{\"165\":1}}],[\"操作系统为每一个进程分配一组固定数目的物理块\",{\"1\":{\"164\":1}}],[\"操作系统为进程分配资源\",{\"1\":{\"132\":1}}],[\"操作系统无法提前预判页面访问序列\",{\"1\":{\"163\":1}}],[\"操作系统用某种数据结构记录\",{\"1\":{\"156\":1}}],[\"操作系统如何记录各个分区空闲或者分配的情况\",{\"1\":{\"154\":1}}],[\"操作系统如何找到各个程序代码以及数据存储的位置\",{\"1\":{\"131\":1}}],[\"操作系统完成自动覆盖\",{\"1\":{\"153\":1}}],[\"操作系统负责内存空间的分配和回收\",{\"1\":{\"152\":1}}],[\"操作系统中\",{\"0\":{\"146\":1}}],[\"操作系统更偏向i\",{\"1\":{\"139\":1}}],[\"操作系统只看得见内核级线程\",{\"1\":{\"135\":1}}],[\"操作系统只负责提供共享空间和同步互斥工具\",{\"1\":{\"134\":1}}],[\"操作系统在内存中开辟一个区域供进程间共同使用\",{\"1\":{\"134\":1}}],[\"操作系统提供了一些方法\",{\"1\":{\"134\":1}}],[\"操作系统需要实现文件保护功能\",{\"1\":{\"183\":1}}],[\"操作系统需要实现的功能\",{\"0\":{\"126\":1}}],[\"操作系统需要建立一个数据结构\",{\"1\":{\"154\":1}}],[\"操作系统需要提供内存保护功能\",{\"1\":{\"152\":1}}],[\"操作系统需要提供地址转换功能\",{\"1\":{\"152\":1}}],[\"操作系统需要提供某种技术从逻辑上对内存空间进程扩充\",{\"1\":{\"152\":1}}],[\"操作系统需要提供进程同步机制来解决异步问题\",{\"1\":{\"131\":1}}],[\"操作系统通过pcb来管理进程\",{\"1\":{\"131\":1}}],[\"操作系统的内存管理主要负责内存的分配与回收\",{\"1\":{\"412\":1}}],[\"操作系统的内核\",{\"1\":{\"128\":1}}],[\"操作系统的核心是内核\",{\"1\":{\"406\":1}}],[\"操作系统的体系结构分为大内核和微内核\",{\"1\":{\"128\":1}}],[\"操作系统的体系结构\",{\"1\":{\"128\":1}}],[\"操作系统的并发性\",{\"1\":{\"127\":1}}],[\"操作系统的四个特征\",{\"0\":{\"127\":1}}],[\"操作系统的概念\",{\"0\":{\"125\":1}}],[\"操作系统作为最接近硬件的层次\",{\"1\":{\"126\":1}}],[\"操作系统作为用户和计算机硬件之间的接口\",{\"1\":{\"126\":1}}],[\"操作系统作为系统资源的管理者需要实现的功能和目标\",{\"1\":{\"126\":1}}],[\"操作系统\",{\"0\":{\"404\":1},\"1\":{\"125\":1,\"246\":1}}],[\"操作系统上\",{\"0\":{\"124\":1}}],[\"核数\",{\"1\":{\"246\":1}}],[\"核心思路就是利用redis的setnx方法来表示获取锁\",{\"1\":{\"988\":1}}],[\"核心思路\",{\"1\":{\"988\":1}}],[\"核心思路如下\",{\"1\":{\"983\":1,\"985\":1}}],[\"核心思路分析\",{\"1\":{\"963\":1}}],[\"核心cpu\",{\"1\":{\"955\":1}}],[\"核心数的线程\",{\"1\":{\"896\":1}}],[\"核心代码如下\",{\"1\":{\"773\":1}}],[\"核心模块\",{\"1\":{\"705\":1}}],[\"核心对象\",{\"1\":{\"661\":1}}],[\"核心算法\",{\"1\":{\"441\":1}}],[\"核心线程数\",{\"1\":{\"242\":1,\"244\":1}}],[\"核心部分是counter\",{\"1\":{\"219\":1}}],[\"核心态\",{\"1\":{\"128\":1,\"129\":2}}],[\"希望尽可能发送足够大的数据\",{\"1\":{\"751\":1}}],[\"希望多个任务排队执行\",{\"1\":{\"244\":1}}],[\"希捷硬盘类\",{\"1\":{\"109\":1}}],[\"丢弃队列最前面的任务\",{\"1\":{\"243\":1}}],[\"丢弃任务\",{\"1\":{\"243\":1}}],[\"丢弃该任务并抛出rejectedexecutionexception异常\",{\"1\":{\"243\":1}}],[\"拒绝策略\",{\"0\":{\"243\":1},\"1\":{\"242\":1}}],[\"针对cas中的自旋压力过大\",{\"1\":{\"997\":1}}],[\"针对这一问题的常见解决方案就是加锁\",{\"1\":{\"996\":1}}],[\"针对所有的key做处理\",{\"1\":{\"429\":1}}],[\"针对设置了过期时间的key做处理\",{\"1\":{\"429\":1}}],[\"针对linux操作系统而言\",{\"1\":{\"406\":1}}],[\"针对同一份数据\",{\"1\":{\"398\":1}}],[\"针对hotspot\",{\"1\":{\"350\":1}}],[\"针对jdk\",{\"1\":{\"328\":1}}],[\"针对客户端连续点击或者调用方的超时重试等情况\",{\"1\":{\"315\":1}}],[\"针对压缩列表在设计上的不足\",{\"1\":{\"281\":1}}],[\"针对救急线程\",{\"1\":{\"242\":1}}],[\"针对上例中的缺点\",{\"1\":{\"66\":1}}],[\"救急线程空闲时的最大空闲时间\",{\"1\":{\"242\":1}}],[\"救急线程在没有空闲核心线程和任务队列满了的情况下才会创建使用\",{\"1\":{\"242\":1}}],[\"救急线程数\",{\"1\":{\"242\":1}}],[\"终结状态\",{\"1\":{\"241\":1}}],[\"终止状态\",{\"1\":{\"208\":1}}],[\"终止线程执行\",{\"1\":{\"206\":1}}],[\"终止态\",{\"1\":{\"132\":1}}],[\"活跃\",{\"1\":{\"410\":1}}],[\"活动线程为0时\",{\"1\":{\"241\":1}}],[\"活锁是因为线程间修改了对方的结束条件\",{\"1\":{\"222\":1}}],[\"活锁出现在两个线程\",{\"1\":{\"222\":1}}],[\"活锁\",{\"0\":{\"220\":1,\"222\":1}}],[\"描述了这个\",{\"1\":{\"454\":1}}],[\"描述了产品的主要特性和功能\",{\"1\":{\"62\":1,\"68\":1,\"73\":1}}],[\"描述\",{\"1\":{\"241\":1,\"332\":1}}],[\"低延迟\",{\"1\":{\"1009\":1}}],[\"低16为存储互斥锁状态\",{\"1\":{\"252\":1}}],[\"低\",{\"1\":{\"241\":1}}],[\"低级调度的时间\",{\"1\":{\"138\":1}}],[\"低级调度\",{\"1\":{\"136\":1}}],[\"位\",{\"1\":{\"876\":2}}],[\"位置\",{\"0\":{\"867\":1},\"1\":{\"821\":1,\"854\":1}}],[\"位数组中的每个元素都只占用\",{\"1\":{\"272\":1}}],[\"位表示线程数量\",{\"1\":{\"241\":1}}],[\"位来表示线程池状态\",{\"1\":{\"241\":1}}],[\"位视图法\",{\"1\":{\"170\":1}}],[\"任意一个线程执行计算\",{\"1\":{\"809\":1}}],[\"任意方法中获取缓存的数据\",{\"1\":{\"247\":1}}],[\"任何程序想要运行\",{\"1\":{\"961\":1}}],[\"任何场景下都适用的完美收集器存在\",{\"1\":{\"360\":1}}],[\"任何字段如果为非负数\",{\"1\":{\"265\":1}}],[\"任务分为普通任务\",{\"1\":{\"837\":1}}],[\"任务是否完成\",{\"1\":{\"806\":1}}],[\"任务是否取消\",{\"1\":{\"806\":1}}],[\"任务\",{\"1\":{\"791\":2}}],[\"任务数多于\",{\"1\":{\"244\":1}}],[\"任务执行完毕\",{\"1\":{\"241\":1,\"244\":1}}],[\"任务可以不需要等到线程创建就直接运行\",{\"1\":{\"240\":1}}],[\"任我行\",{\"1\":{\"78\":1}}],[\"享元模式简单理解就是重用数量有限的同一对象\",{\"1\":{\"238\":1}}],[\"享元模式\",{\"0\":{\"238\":1}}],[\"构建数据\",{\"1\":{\"934\":1}}],[\"构建phone对象\",{\"1\":{\"52\":1}}],[\"构造消息对象\",{\"1\":{\"759\":1}}],[\"构造方法注入\",{\"1\":{\"706\":1}}],[\"构造方法中所做的操作\",{\"1\":{\"652\":1}}],[\"构造\",{\"1\":{\"463\":1,\"650\":1,\"651\":1}}],[\"构造时设置计数个数\",{\"1\":{\"263\":1}}],[\"构造函数传入的count值最终都会赋值给state\",{\"1\":{\"262\":1}}],[\"构造器分析\",{\"1\":{\"249\":1}}],[\"构造新字符串对象时\",{\"1\":{\"236\":1}}],[\"做好热点参数的限流\",{\"1\":{\"985\":1}}],[\"做好数据的基础格式校验\",{\"1\":{\"985\":1}}],[\"做一个标记\",{\"1\":{\"854\":1}}],[\"做拒绝逻辑\",{\"1\":{\"791\":1}}],[\"做的事就是将原生\",{\"1\":{\"790\":1}}],[\"做的事就是添加一个初始化器\",{\"1\":{\"790\":1}}],[\"做的\",{\"1\":{\"604\":1}}],[\"做出了修改\",{\"1\":{\"236\":1}}],[\"做其他处理\",{\"1\":{\"140\":1}}],[\"累加cell\",{\"1\":{\"234\":1}}],[\"累加\",{\"1\":{\"234\":1,\"342\":1}}],[\"累加单元数组\",{\"1\":{\"234\":1}}],[\"懒惰初始化\",{\"1\":{\"234\":1}}],[\"懒汉式\",{\"1\":{\"101\":7}}],[\"懒汉式双重锁校验\",{\"1\":{\"57\":1}}],[\"懒汉式线程安全\",{\"1\":{\"57\":1}}],[\"懒汉式线程不安全\",{\"1\":{\"57\":1}}],[\"确保只能执行一次\",{\"1\":{\"1034\":1}}],[\"确保事务不会出现问题\",{\"1\":{\"998\":1}}],[\"确保要递归删除的文件夹没有重要内容\",{\"1\":{\"873\":1}}],[\"确保接到的\",{\"1\":{\"771\":1,\"773\":1}}],[\"确保这个原子引用没有引用过别人\",{\"1\":{\"232\":1}}],[\"确定单次读取大小\",{\"1\":{\"794\":1}}],[\"确定具体消息类型\",{\"1\":{\"773\":1}}],[\"确定该对象所属类型\",{\"1\":{\"353\":1}}],[\"确定分界点x\",{\"1\":{\"191\":1}}],[\"确认无误才能执行更新语句\",{\"1\":{\"267\":1}}],[\"你会发现在threadlocal中\",{\"1\":{\"961\":1}}],[\"你会感到有些紧张\",{\"0\":{\"308\":1}}],[\"你好\",{\"1\":{\"855\":3,\"889\":1}}],[\"你来我往\",{\"1\":{\"766\":1}}],[\"你有什么要说的呢\",{\"1\":{\"766\":1}}],[\"你有什么样的总结和反思\",{\"1\":{\"310\":1,\"311\":1}}],[\"你只要添加spring\",{\"1\":{\"727\":1}}],[\"你打算做个web应用程序\",{\"1\":{\"727\":1}}],[\"你知道哪几种垃圾收集器\",{\"1\":{\"355\":1}}],[\"你知道哪几种垃圾回收器\",{\"1\":{\"355\":1}}],[\"你的索引将会有1个主分片和另外1个复制分片\",{\"1\":{\"928\":1}}],[\"你的行为对他人有怎样的影响\",{\"1\":{\"311\":1}}],[\"你的感受如何\",{\"1\":{\"310\":1}}],[\"你采取了哪些具体措施\",{\"1\":{\"311\":1}}],[\"你当时是怎样想的\",{\"1\":{\"311\":1}}],[\"你认为解决困难的关键是什么\",{\"1\":{\"311\":1}}],[\"你认为是什么原因造成了这样的结果\",{\"1\":{\"310\":1}}],[\"你如何看待他们的想法\",{\"1\":{\"309\":1}}],[\"你是如何重建自信的\",{\"1\":{\"310\":1}}],[\"你是如何处理的\",{\"1\":{\"308\":1}}],[\"你是否与他人谈论过对此事的担忧\",{\"1\":{\"309\":1}}],[\"你通过什么方法来调节自己的情绪\",{\"1\":{\"309\":1}}],[\"你现在如何看待此事\",{\"1\":{\"308\":1}}],[\"你都会有哪些行为表现\",{\"1\":{\"308\":1}}],[\"你对华为有什么了解\",{\"0\":{\"305\":1}}],[\"你自己最认可的一件事是什么\",{\"0\":{\"303\":1}}],[\"你可以在任何时候动态地改变复制的数量\",{\"1\":{\"928\":1}}],[\"你可以指定你想要的分片的数量\",{\"1\":{\"927\":1}}],[\"你可以存储任意多的文档\",{\"1\":{\"924\":1}}],[\"你可以拥有某一个客户的文档\",{\"1\":{\"924\":1}}],[\"你可以定义一种或多种类型\",{\"1\":{\"923\":1}}],[\"你可以有一个客户数据的索引\",{\"1\":{\"922\":1}}],[\"你可以利用多线程提高它的利用率\",{\"1\":{\"246\":1}}],[\"你可以使用gan实现照片转成油画\",{\"1\":{\"10\":1}}],[\"你们才有机会\",{\"1\":{\"231\":1}}],[\"~selectionkey\",{\"1\":{\"792\":1}}],[\"~\",{\"1\":{\"441\":3,\"859\":1}}],[\"~~\",{\"1\":{\"231\":1,\"297\":1}}],[\"~junyanz\",{\"1\":{\"5\":1}}],[\"理解为处理数据的工人\",{\"1\":{\"837\":1}}],[\"理解为数据的处理工序\",{\"1\":{\"837\":1}}],[\"理解为数据的通道\",{\"1\":{\"837\":1}}],[\"理解为流动的数据\",{\"1\":{\"837\":1}}],[\"理解什么是bio\",{\"1\":{\"330\":1}}],[\"理解生成对抗网络\",{\"1\":{\"6\":1,\"13\":1}}],[\"理论上可以支持所有数据源\",{\"1\":{\"660\":1}}],[\"理论上ide结果应该是1000\",{\"1\":{\"230\":1}}],[\"理论与实践以及动手能力\",{\"1\":{\"311\":1}}],[\"理论知识和实践操作不能有效统一\",{\"1\":{\"297\":1}}],[\"理论情况下\",{\"1\":{\"272\":1}}],[\"理论情况下添加到集合中的元素越多\",{\"1\":{\"272\":1}}],[\"固定长度\",{\"0\":{\"754\":1}}],[\"固定值\",{\"1\":{\"279\":1}}],[\"固定线程运行顺序\",{\"0\":{\"224\":1}}],[\"固定分隔符\",{\"0\":{\"755\":1}}],[\"固定分配\",{\"1\":{\"164\":2}}],[\"固定分区分配分为两种\",{\"1\":{\"154\":1}}],[\"固定分区分配\",{\"1\":{\"154\":1}}],[\"却一直运行不完的现象\",{\"1\":{\"222\":1}}],[\"停止\",{\"1\":{\"1016\":1}}],[\"停止服务\",{\"1\":{\"1015\":1}}],[\"停止线程的运行\",{\"1\":{\"797\":1}}],[\"停止运行的现象\",{\"1\":{\"222\":1}}],[\"停车收费米表\",{\"1\":{\"33\":1}}],[\"必然导致\",{\"1\":{\"876\":1}}],[\"必然导致索引的大小也会很大\",{\"1\":{\"376\":1}}],[\"必然有脏数据产生\",{\"1\":{\"266\":1}}],[\"必然存在一个线程\",{\"1\":{\"221\":1}}],[\"必须全部是小写字母\",{\"1\":{\"922\":1}}],[\"必须将事件移除\",{\"1\":{\"884\":1}}],[\"必须处理\",{\"1\":{\"884\":1,\"886\":1}}],[\"必须工作在非阻塞模式\",{\"1\":{\"881\":1}}],[\"必须关闭\",{\"1\":{\"866\":1}}],[\"必须通过\",{\"1\":{\"863\":1}}],[\"必须\",{\"1\":{\"825\":2}}],[\"必须配合多线程\",{\"1\":{\"805\":1}}],[\"必须和\",{\"1\":{\"771\":1,\"773\":1}}],[\"必须添加如下依赖\",{\"1\":{\"648\":1}}],[\"必须调用到足够次数才会进行优化\",{\"1\":{\"523\":1}}],[\"必须提前创建\",{\"1\":{\"491\":1}}],[\"必须使用非阻塞套接口\",{\"1\":{\"410\":1}}],[\"必须使用is\",{\"1\":{\"265\":1}}],[\"必须同时更新记录对应的gmt\",{\"1\":{\"268\":1}}],[\"必须指定索引长度\",{\"1\":{\"266\":1,\"383\":1}}],[\"必须是unsigned\",{\"1\":{\"265\":1}}],[\"必须是互斥的进程\",{\"1\":{\"140\":1}}],[\"必须先顺序查找第i\",{\"1\":{\"167\":1}}],[\"必须由程序员声明覆盖结构\",{\"1\":{\"153\":1}}],[\"必须分配其要求的全部内存空间\",{\"1\":{\"151\":1}}],[\"必须按规定次序申请资源\",{\"1\":{\"148\":1}}],[\"必须考虑到所有的子类\",{\"1\":{\"108\":1}}],[\"源\",{\"1\":{\"221\":1,\"650\":1}}],[\"源码解析\",{\"1\":{\"104\":1}}],[\"唤醒下一个线程后如果发现该线程占有的是共享锁\",{\"1\":{\"253\":1}}],[\"唤醒\",{\"1\":{\"219\":1,\"759\":1,\"791\":1}}],[\"唤醒阻塞队列来竞争\",{\"1\":{\"212\":1}}],[\"满足下列需求\",{\"1\":{\"990\":1}}],[\"满足下面的需求\",{\"1\":{\"983\":1}}],[\"满足开闭原则\",{\"1\":{\"70\":1}}],[\"满时不会再加入数据\",{\"1\":{\"218\":1}}],[\"偏向时间戳\",{\"1\":{\"353\":1}}],[\"偏向线程id\",{\"1\":{\"353\":1}}],[\"偏向锁\",{\"0\":{\"214\":1}}],[\"偏移量\",{\"1\":{\"156\":1}}],[\"途中waitset中的thread\",{\"1\":{\"211\":1}}],[\"刚刚说的imsi就相当于身份证号\",{\"1\":{\"296\":1}}],[\"刚刚换入的页面马上又要换出外存\",{\"1\":{\"164\":1}}],[\"刚刚换出的页面马上又要换入内存\",{\"1\":{\"164\":1}}],[\"刚开始\",{\"1\":{\"261\":1}}],[\"刚开始monitor中的owner为null\",{\"1\":{\"211\":1}}],[\"成功删除1个\",{\"1\":{\"1024\":1}}],[\"成功的概率太低\",{\"1\":{\"997\":1}}],[\"成功\",{\"1\":{\"988\":1,\"989\":1,\"990\":1}}],[\"成功插入的key的线程我们认为他就是获得到锁的线程\",{\"1\":{\"988\":1}}],[\"成功时返回组对象\",{\"1\":{\"758\":1}}],[\"成功演示\",{\"1\":{\"212\":1}}],[\"成员集合\",{\"1\":{\"758\":1}}],[\"成员名\",{\"1\":{\"758\":2}}],[\"成员\",{\"1\":{\"758\":2}}],[\"成员按类型查找装配\",{\"1\":{\"695\":1}}],[\"成员或参数\",{\"1\":{\"688\":1}}],[\"成员中\",{\"1\":{\"678\":2}}],[\"成员变量的数据类型不同\",{\"1\":{\"277\":1}}],[\"成员变量的线程安全性\",{\"1\":{\"232\":1}}],[\"成员变量来记录长度\",{\"1\":{\"277\":1}}],[\"成员变量\",{\"1\":{\"277\":3}}],[\"成员变量和静态变量的线程安全分析\",{\"1\":{\"209\":1}}],[\"成为内核空间\",{\"1\":{\"406\":1}}],[\"成组链接法\",{\"1\":{\"170\":1}}],[\"变成了下面的两个\",{\"1\":{\"859\":1}}],[\"变量变为0时\",{\"1\":{\"993\":1}}],[\"变量代表还剩余多少字节\",{\"1\":{\"870\":1}}],[\"变量拼接的原理是stringbuilder\",{\"1\":{\"354\":1}}],[\"变量的赋值也会通过\",{\"1\":{\"237\":1}}],[\"变量的线程安全分析\",{\"0\":{\"209\":1}}],[\"变量\",{\"1\":{\"234\":1}}],[\"变化和消亡的\",{\"1\":{\"131\":1}}],[\"涵盖了操作系统层面的\",{\"1\":{\"208\":1}}],[\"六种状态\",{\"1\":{\"208\":1}}],[\"仅适合短连接场景\",{\"1\":{\"916\":1}}],[\"仅支持阻塞\",{\"1\":{\"900\":1}}],[\"仅执行一次\",{\"1\":{\"834\":1,\"835\":1}}],[\"仅会打印\",{\"1\":{\"816\":1}}],[\"仅关联\",{\"1\":{\"790\":1}}],[\"仅决定了\",{\"1\":{\"750\":1}}],[\"仅根据视图名找视图\",{\"1\":{\"642\":1}}],[\"仅做类型转换\",{\"1\":{\"576\":1}}],[\"仅是调用\",{\"1\":{\"527\":3}}],[\"仅为根据接口名生成\",{\"1\":{\"486\":1}}],[\"仅分配引用变量空间即可\",{\"1\":{\"352\":1}}],[\"仅用在一个写线程\",{\"1\":{\"228\":1}}],[\"仅在语言层面创建了线程对象\",{\"1\":{\"208\":1}}],[\"仅仅是一个提示\",{\"1\":{\"205\":1}}],[\"守护进程\",{\"1\":{\"1015\":1}}],[\"守护线程💡\",{\"0\":{\"908\":1}}],[\"守护线程无论是否执行完毕\",{\"1\":{\"207\":1}}],[\"守护线程\",{\"0\":{\"207\":1}}],[\"守候寂寞\",{\"1\":{\"37\":1}}],[\"睡眠结束后的线程未必会立刻得到执行\",{\"1\":{\"203\":1}}],[\"五花八门各种各样\",{\"1\":{\"1006\":1}}],[\"五种状态\",{\"1\":{\"208\":1}}],[\"五\",{\"1\":{\"197\":1}}],[\"面对紧张时\",{\"1\":{\"308\":1}}],[\"面试以及课题所带来的压力\",{\"1\":{\"309\":1}}],[\"面试官好\",{\"1\":{\"293\":1}}],[\"面试\",{\"1\":{\"197\":1}}],[\"面向对象的开发很好的解决了这个问题\",{\"1\":{\"109\":1}}],[\"面向对象中的继承性的思考和说明\",{\"1\":{\"108\":1}}],[\"思路分析\",{\"1\":{\"989\":1}}],[\"思考注释中两个问题\",{\"1\":{\"889\":1}}],[\"思考\",{\"1\":{\"844\":3}}],[\"思考下面的场景\",{\"1\":{\"805\":1}}],[\"思否\",{\"1\":{\"197\":2}}],[\"思想\",{\"1\":{\"153\":1}}],[\"彻底弄清post和get请求的区别\",{\"1\":{\"197\":1}}],[\"彻底和对象解耦\",{\"1\":{\"60\":1}}],[\"件物品\",{\"1\":{\"195\":2}}],[\"件物品的情况\",{\"1\":{\"195\":4}}],[\"之别\",{\"1\":{\"928\":1}}],[\"之\",{\"0\":{\"586\":1,\"593\":1,\"605\":1,\"613\":1}}],[\"之外\",{\"1\":{\"495\":1}}],[\"之和\",{\"1\":{\"413\":1}}],[\"之前存在的age\",{\"1\":{\"1025\":1}}],[\"之前存在的name\",{\"1\":{\"1025\":1}}],[\"之前的方式要修改前后都保持一致\",{\"1\":{\"997\":1}}],[\"之前的项目因为是第一次啥啥啥的\",{\"1\":{\"311\":1}}],[\"之前咱们已经重点分析过这个逻辑啦\",{\"1\":{\"968\":1}}],[\"之前没有其它出站处理器了\",{\"1\":{\"816\":1}}],[\"之前没有封校的时候我还会去爬紫金山\",{\"1\":{\"309\":1}}],[\"之前\",{\"1\":{\"776\":1,\"820\":1}}],[\"之前介绍的都是将具体类交给\",{\"1\":{\"661\":1}}],[\"之前学习的代理是运行时生成新的字节码\",{\"1\":{\"504\":1}}],[\"之前比较当前服务器时钟是否被回拨\",{\"1\":{\"442\":1}}],[\"之前一共实现了6中内存淘汰机制\",{\"1\":{\"429\":1}}],[\"之前我在写项目的时候还发现了我没有写注释的习惯\",{\"1\":{\"302\":1}}],[\"之前atomiclong等都是在一个共享资源变量上进行竞争\",{\"1\":{\"234\":1}}],[\"之间进行了绑定\",{\"1\":{\"798\":1}}],[\"之间也会有顺序问题\",{\"1\":{\"643\":1}}],[\"之间\",{\"1\":{\"280\":1}}],[\"之间的关系是固定的\",{\"1\":{\"974\":1}}],[\"之间的内容进行切片\",{\"1\":{\"826\":1}}],[\"之间的节点\",{\"1\":{\"280\":1}}],[\"之间的遍历顺序关系\",{\"1\":{\"195\":1}}],[\"之所以\",{\"1\":{\"277\":1}}],[\"之后注册等操作在\",{\"1\":{\"790\":1}}],[\"之后\",{\"1\":{\"776\":1}}],[\"之后再进行读操作时\",{\"1\":{\"393\":1}}],[\"之后再传送到输出设备上\",{\"1\":{\"184\":1}}],[\"之后通过role\",{\"1\":{\"366\":1}}],[\"之后能在线程使用完后自己释放\",{\"1\":{\"221\":1}}],[\"之后在转存到输入井中\",{\"1\":{\"184\":1}}],[\"之后开始访问临界区\",{\"1\":{\"141\":1}}],[\"递减更新的话前面是旧值\",{\"1\":{\"194\":1}}],[\"考虑第\",{\"1\":{\"195\":2}}],[\"考虑第一件物品\",{\"1\":{\"194\":1}}],[\"考虑其余物品\",{\"1\":{\"194\":1}}],[\"考虑哪个进程先达到就绪队列\",{\"1\":{\"139\":1}}],[\"考虑哪个作业先到达后备队列\",{\"1\":{\"139\":1}}],[\"价值\",{\"1\":{\"194\":2}}],[\"物品个数\",{\"1\":{\"194\":1}}],[\"物理设备名\",{\"1\":{\"185\":1}}],[\"物理设备名是进程请求分配时提供的参数\",{\"1\":{\"185\":1}}],[\"物理块对应着物理地址\",{\"1\":{\"413\":1}}],[\"物理块\",{\"1\":{\"169\":1}}],[\"物理地址=\",{\"1\":{\"156\":1}}],[\"物理地址的转换\",{\"1\":{\"151\":1}}],[\"物理地址即绝对地址\",{\"1\":{\"151\":1}}],[\"物理地址\",{\"1\":{\"151\":1}}],[\"物理实体是实际存在的\",{\"1\":{\"127\":1}}],[\"埃氏筛\",{\"0\":{\"192\":1}}],[\"快速入门\",{\"0\":{\"1037\":1}}],[\"快速完成映射\",{\"1\":{\"561\":1}}],[\"快速\",{\"1\":{\"359\":1}}],[\"快排\",{\"0\":{\"191\":1}}],[\"快表的作用和缓存很类似\",{\"1\":{\"413\":1}}],[\"快表解决\",{\"1\":{\"413\":1}}],[\"快表和多级页表\",{\"1\":{\"413\":1}}],[\"快表\",{\"1\":{\"157\":1,\"413\":2}}],[\"标准的操作方式就是查询数据库之前先查询缓存\",{\"1\":{\"978\":1}}],[\"标点符号\",{\"1\":{\"766\":1}}],[\"标注监听方法\",{\"1\":{\"699\":1}}],[\"标注\",{\"1\":{\"695\":1}}],[\"标注方法作为扩展点\",{\"1\":{\"582\":1}}],[\"标注的\",{\"1\":{\"695\":1}}],[\"标注的接口\",{\"1\":{\"661\":1}}],[\"标注的销毁方法\",{\"1\":{\"495\":1}}],[\"标注的初始化方法\",{\"1\":{\"495\":1}}],[\"标注需排序的元素\",{\"1\":{\"190\":1}}],[\"标记为❤的就是推荐使用的java客户端\",{\"1\":{\"1031\":1}}],[\"标记当前position位置\",{\"1\":{\"332\":1}}],[\"标记压缩列表的结束点\",{\"1\":{\"279\":1}}],[\"标记各\",{\"1\":{\"173\":1}}],[\"小伙伴们就会发现那个class数据已经不在了\",{\"1\":{\"1042\":1}}],[\"小value是lucy\",{\"1\":{\"1027\":1}}],[\"小key是name\",{\"1\":{\"1027\":1}}],[\"小米11\",{\"1\":{\"1005\":2,\"1026\":1}}],[\"小总结\",{\"1\":{\"985\":1}}],[\"小端写入\",{\"1\":{\"822\":1}}],[\"小时\",{\"1\":{\"805\":1}}],[\"小故事\",{\"1\":{\"766\":1}}],[\"小表驱动大表\",{\"1\":{\"386\":1}}],[\"小顶堆中就是出现频率前100的单词了\",{\"1\":{\"291\":1}}],[\"小于最大次数\",{\"1\":{\"794\":1}}],[\"小于实际发送数据量\",{\"1\":{\"751\":1}}],[\"小于\",{\"1\":{\"277\":1}}],[\"小于等于x的放在区间左边\",{\"1\":{\"191\":1}}],[\"小林coding\",{\"1\":{\"275\":1,\"278\":1}}],[\"小概率会误判\",{\"1\":{\"273\":1}}],[\"小数类型为decimal\",{\"1\":{\"265\":1}}],[\"小数组是hashentry数组\",{\"1\":{\"249\":1}}],[\"小\",{\"1\":{\"189\":1}}],[\"小结\",{\"1\":{\"128\":1,\"129\":1,\"130\":1,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":1,\"140\":1,\"143\":1,\"144\":1,\"158\":1,\"159\":1}}],[\"独占设备\",{\"1\":{\"185\":1}}],[\"独立线程去重构数据\",{\"1\":{\"989\":1}}],[\"独立出来\",{\"1\":{\"760\":1}}],[\"独立出来一张表\",{\"1\":{\"265\":1}}],[\"独立于普通的应用程序\",{\"1\":{\"406\":1}}],[\"独立接收调度的基本单位\",{\"1\":{\"131\":1}}],[\"独立获得资源\",{\"1\":{\"131\":1}}],[\"独立性\",{\"1\":{\"131\":1}}],[\"输出带有定位框和具体分类的图片\",{\"1\":{\"300\":1}}],[\"输出\",{\"1\":{\"282\":1,\"500\":2,\"753\":1,\"796\":2,\"798\":1,\"800\":1,\"801\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":1,\"818\":1,\"825\":1,\"826\":6,\"829\":1,\"830\":2,\"846\":1,\"855\":1,\"858\":1,\"870\":1,\"886\":1,\"889\":1,\"898\":1,\"907\":1}}],[\"输出缓冲区\",{\"1\":{\"184\":1}}],[\"输出进程\",{\"1\":{\"184\":1}}],[\"输出井\",{\"1\":{\"184\":1}}],[\"输出技术\",{\"1\":{\"184\":1}}],[\"输入是与垃圾相关的图片\",{\"1\":{\"300\":1}}],[\"输入网址到网页显示期间发生了什么\",{\"0\":{\"198\":1}}],[\"输入缓冲区用于暂存从输入设备输入的数据\",{\"1\":{\"184\":1}}],[\"输入缓冲区\",{\"1\":{\"184\":1}}],[\"输入进程\",{\"1\":{\"184\":1}}],[\"输入井\",{\"1\":{\"184\":1}}],[\"输入法换皮肤\",{\"1\":{\"76\":1}}],[\"脱机技术简介\",{\"1\":{\"184\":1}}],[\"脱机命令接口\",{\"1\":{\"126\":1}}],[\"加\",{\"1\":{\"1030\":1}}],[\"加强用户权限校验\",{\"1\":{\"985\":1}}],[\"加入依赖\",{\"1\":{\"833\":1}}],[\"加入至\",{\"1\":{\"790\":1}}],[\"加入群聊\",{\"1\":{\"761\":1}}],[\"加入自己\",{\"1\":{\"759\":1}}],[\"加入聊天组\",{\"1\":{\"758\":1}}],[\"加入\",{\"1\":{\"755\":1}}],[\"加上rollbackfor=exception\",{\"1\":{\"722\":1}}],[\"加上实现循环检查的一系列指令即可\",{\"1\":{\"181\":1}}],[\"加载spring\",{\"1\":{\"730\":1}}],[\"加载\",{\"1\":{\"650\":1,\"652\":1}}],[\"加载的是主存中最新数据\",{\"1\":{\"227\":1}}],[\"加在\",{\"1\":{\"500\":1}}],[\"加在成员变量上就不行了\",{\"1\":{\"500\":1}}],[\"加在也可以加在成员变量上\",{\"1\":{\"500\":1}}],[\"加mdl写锁\",{\"1\":{\"400\":1}}],[\"加mdl读锁\",{\"1\":{\"400\":1}}],[\"加锁解锁流程\",{\"1\":{\"261\":1}}],[\"加解写锁\",{\"1\":{\"260\":1}}],[\"加解读锁\",{\"1\":{\"260\":1}}],[\"加值并获取\",{\"1\":{\"232\":1}}],[\"加密\",{\"1\":{\"173\":1}}],[\"加密保护\",{\"1\":{\"173\":1}}],[\"轮流处理\",{\"1\":{\"896\":1}}],[\"轮流的让各个进程执行一个时间片\",{\"1\":{\"139\":1}}],[\"轮流的为各个进程服务\",{\"1\":{\"139\":1}}],[\"轮询\",{\"1\":{\"181\":1}}],[\"属性值\",{\"1\":{\"758\":2}}],[\"属性名\",{\"1\":{\"758\":2}}],[\"属性\",{\"1\":{\"332\":1,\"737\":1}}],[\"属性也必须从\",{\"1\":{\"280\":1}}],[\"属性从原来的\",{\"1\":{\"280\":1}}],[\"属性只有\",{\"1\":{\"280\":1}}],[\"属性会根据前一个节点的长度进行不同的空间大小分配\",{\"1\":{\"280\":1}}],[\"属性的空间大小跟数据是字符串还是整数\",{\"1\":{\"279\":1}}],[\"属性的空间大小跟前一个节点长度值有关\",{\"1\":{\"279\":1}}],[\"属性需要用\",{\"1\":{\"279\":2,\"280\":3}}],[\"属性都记录了\",{\"1\":{\"279\":1}}],[\"属性定义下面的结构体\",{\"1\":{\"277\":1}}],[\"属性定义结构体\",{\"1\":{\"277\":1}}],[\"属性用final修饰保证该属性是只读的\",{\"1\":{\"236\":1}}],[\"属性中引用的其他对象也会被克隆\",{\"1\":{\"86\":1}}],[\"属于比较昂贵的操作\",{\"1\":{\"791\":1}}],[\"属于操作系统参数\",{\"1\":{\"777\":1}}],[\"属于操作系统的内核部分\",{\"1\":{\"183\":1}}],[\"属于\",{\"1\":{\"775\":1,\"776\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":1}}],[\"属于小概率事件\",{\"1\":{\"397\":1}}],[\"属于顺序io\",{\"1\":{\"396\":1}}],[\"属于硬件故障\",{\"1\":{\"178\":1}}],[\"坏块\",{\"1\":{\"178\":1}}],[\"坏块管理\",{\"1\":{\"178\":1}}],[\"盘\",{\"1\":{\"178\":1}}],[\"盘面\",{\"1\":{\"175\":1}}],[\"自减操作\",{\"1\":{\"1025\":2}}],[\"自减并获取\",{\"1\":{\"232\":1}}],[\"自由\",{\"1\":{\"1004\":1}}],[\"自带的序列化\",{\"1\":{\"773\":1}}],[\"自定义redistemplate\",{\"1\":{\"1042\":1}}],[\"自定义协议要素\",{\"0\":{\"769\":1}}],[\"自定义参数与返回值处理器\",{\"0\":{\"562\":1}}],[\"自行调用销毁方法\",{\"1\":{\"710\":1}}],[\"自行车类\",{\"1\":{\"49\":1}}],[\"自行车\",{\"1\":{\"33\":1}}],[\"自然排序\",{\"1\":{\"340\":1}}],[\"自动递增\",{\"1\":{\"829\":1}}],[\"自动侦测以及自动装配到spring容器中\",{\"1\":{\"713\":1}}],[\"自动配置类本质上就是一个配置类而已\",{\"1\":{\"671\":1}}],[\"自动配置类原理\",{\"0\":{\"669\":1}}],[\"自动配置类为\",{\"1\":{\"659\":1,\"661\":1}}],[\"自动配置的本质是通过\",{\"1\":{\"659\":1}}],[\"自动配置\",{\"0\":{\"658\":1},\"1\":{\"659\":1}}],[\"自动拆箱\",{\"1\":{\"321\":1}}],[\"自动装箱\",{\"1\":{\"321\":1}}],[\"自动装箱与自动拆箱\",{\"0\":{\"321\":1}}],[\"自己根据返回值检查是否有事件\",{\"1\":{\"882\":1}}],[\"自己\",{\"1\":{\"816\":1}}],[\"自己调用\",{\"1\":{\"792\":1}}],[\"自己测试时请将包名根据情况补全\",{\"1\":{\"670\":1}}],[\"自己的\",{\"1\":{\"796\":2,\"852\":1,\"853\":1}}],[\"自己的缺点\",{\"0\":{\"302\":1}}],[\"自己的优点\",{\"0\":{\"301\":1}}],[\"自己正也开发一个简易的一个系统来实现这么个功能\",{\"1\":{\"300\":1}}],[\"自己创建一个单线程串行执行任务\",{\"1\":{\"244\":1}}],[\"自我介绍\",{\"0\":{\"293\":1},\"1\":{\"740\":1}}],[\"自增长\",{\"1\":{\"993\":1}}],[\"自增步长为3\",{\"1\":{\"439\":1}}],[\"自增锁\",{\"1\":{\"400\":1}}],[\"自增id的性能较差\",{\"1\":{\"391\":1}}],[\"自增id的问题\",{\"0\":{\"391\":1}}],[\"自增并获取\",{\"1\":{\"232\":1}}],[\"自增\",{\"1\":{\"230\":1}}],[\"自旋会占用cpu时间\",{\"1\":{\"212\":1}}],[\"自旋优化\",{\"0\":{\"212\":1}}],[\"自举装入程序\",{\"1\":{\"178\":2}}],[\"自举程序\",{\"1\":{\"178\":1}}],[\"引用计数加一\",{\"1\":{\"826\":1}}],[\"引用计数\",{\"1\":{\"770\":1}}],[\"引发缓存雪崩甚至系统崩溃\",{\"1\":{\"437\":1}}],[\"引发了对\",{\"1\":{\"280\":1}}],[\"引导块\",{\"1\":{\"178\":1}}],[\"引入spring\",{\"1\":{\"1040\":1}}],[\"引入自动配置类时\",{\"1\":{\"672\":1}}],[\"引入自动配置\",{\"1\":{\"670\":1}}],[\"引入依赖\",{\"0\":{\"931\":1,\"948\":1},\"1\":{\"372\":1,\"1032\":1}}],[\"引入了\",{\"1\":{\"773\":1,\"871\":1}}],[\"引入了窗口概念\",{\"1\":{\"751\":1}}],[\"引入了异步通道的概念\",{\"1\":{\"333\":1}}],[\"引入了进程\",{\"1\":{\"131\":1}}],[\"引入\",{\"1\":{\"281\":2}}],[\"引入线程之后的变化\",{\"1\":{\"135\":1}}],[\"引入线程之后\",{\"1\":{\"135\":4}}],[\"引入线程后\",{\"1\":{\"135\":2}}],[\"转发至\",{\"1\":{\"642\":1}}],[\"转为需要的\",{\"1\":{\"576\":1}}],[\"转为类型\",{\"1\":{\"574\":1}}],[\"转为其它类型\",{\"1\":{\"574\":1}}],[\"转向正确的节点\",{\"1\":{\"434\":1}}],[\"转到与中断信号对应的处理程序去执行\",{\"1\":{\"406\":1}}],[\"转换为其它类型的\",{\"1\":{\"825\":1}}],[\"转换\",{\"1\":{\"576\":2,\"688\":1}}],[\"转换至可运行状态\",{\"1\":{\"208\":1}}],[\"转换器第1面插入当地的插座\",{\"1\":{\"39\":1}}],[\"转化成特定设备能听得懂的一些列操作\",{\"1\":{\"182\":1}}],[\"转两圈读取完0号盘面的数据以后\",{\"1\":{\"177\":1}}],[\"转两圈读完的原因\",{\"1\":{\"177\":1}}],[\"减少正常用法\",{\"1\":{\"1025\":1}}],[\"减少\",{\"1\":{\"905\":1}}],[\"减少了一次数据拷贝\",{\"1\":{\"905\":1}}],[\"减少了线程上下文切换\",{\"1\":{\"879\":1}}],[\"减少了系统开销\",{\"1\":{\"332\":1}}],[\"减少内存溢出的可能\",{\"1\":{\"820\":1,\"831\":1}}],[\"减少内存碎片\",{\"1\":{\"413\":1}}],[\"减少select\",{\"1\":{\"395\":1}}],[\"减少延迟时间的方法\",{\"0\":{\"177\":1},\"1\":{\"177\":2}}],[\"减少信号量的数目\",{\"1\":{\"144\":1}}],[\"循环\",{\"1\":{\"796\":1}}],[\"循环这个过程\",{\"1\":{\"291\":1}}],[\"循环栅栏\",{\"1\":{\"263\":1}}],[\"循环进行cas重试\",{\"1\":{\"234\":1}}],[\"循环缓冲区\",{\"1\":{\"186\":1}}],[\"循环扫描算法\",{\"1\":{\"176\":1}}],[\"循环等待条件\",{\"1\":{\"147\":1,\"221\":1}}],[\"寻道时间\",{\"1\":{\"176\":2}}],[\"寻找时间\",{\"1\":{\"176\":1}}],[\"柱面\",{\"1\":{\"175\":2}}],[\"扇区都一一对应\",{\"1\":{\"177\":1}}],[\"扇区\",{\"1\":{\"175\":1}}],[\"磁道\",{\"1\":{\"175\":1}}],[\"磁盘调度\",{\"1\":{\"183\":1}}],[\"磁盘调度算法\",{\"0\":{\"176\":1},\"1\":{\"176\":1}}],[\"磁盘初始化\",{\"1\":{\"178\":1}}],[\"磁盘的管理\",{\"0\":{\"178\":1}}],[\"磁盘的分类\",{\"1\":{\"175\":1}}],[\"磁盘的结构\",{\"0\":{\"175\":1}}],[\"磁盘i\",{\"1\":{\"169\":1}}],[\"磁盘块的大小与内存块\",{\"1\":{\"169\":1}}],[\"磁盘块\",{\"1\":{\"169\":1}}],[\"磁盘中的存储单元也会被分为一个个\",{\"1\":{\"169\":1}}],[\"磁盘\",{\"1\":{\"153\":1,\"175\":1}}],[\"译码\",{\"1\":{\"173\":1}}],[\"密码\",{\"1\":{\"173\":1,\"758\":1,\"1015\":1}}],[\"口令保护\",{\"1\":{\"173\":1}}],[\"软链接\",{\"1\":{\"172\":1}}],[\"软件设计原则\",{\"0\":{\"106\":1}}],[\"硬着陆导致的损害\",{\"1\":{\"974\":1}}],[\"硬件性能的提升也有助于降低收集器运行时对应用程序的影响\",{\"1\":{\"359\":1}}],[\"硬链接\",{\"1\":{\"172\":1}}],[\"硬盘全部打满\",{\"1\":{\"955\":1}}],[\"硬盘只能是希捷的\",{\"1\":{\"109\":1}}],[\"硬盘可以选择希捷\",{\"1\":{\"109\":1}}],[\"硬盘\",{\"1\":{\"109\":1}}],[\"打散流量\",{\"1\":{\"955\":1}}],[\"打个比喻\",{\"1\":{\"816\":1}}],[\"打头的注解本质是利用了\",{\"1\":{\"671\":1}}],[\"打印可读取内容\",{\"1\":{\"849\":1}}],[\"打印所有内容\",{\"1\":{\"849\":1}}],[\"打印banner信息\",{\"1\":{\"728\":1}}],[\"打印\",{\"1\":{\"650\":1,\"803\":4}}],[\"打印机\",{\"1\":{\"140\":1}}],[\"打开\",{\"1\":{\"647\":1}}],[\"打开不同的浏览器\",{\"1\":{\"498\":1}}],[\"打开文件\",{\"1\":{\"171\":2}}],[\"打快照\",{\"1\":{\"393\":1}}],[\"打断线程\",{\"1\":{\"206\":1}}],[\"②分配第一个分组中的100个空闲块\",{\"1\":{\"170\":1}}],[\"②多层索引\",{\"1\":{\"169\":1}}],[\"足够\",{\"1\":{\"170\":1}}],[\"①检查第一个分组的块数是否足够\",{\"1\":{\"170\":1}}],[\"①链接方案\",{\"1\":{\"169\":1}}],[\"离散分配都适用\",{\"1\":{\"170\":1}}],[\"离散分配时所分配地址空间的基本单位不同\",{\"1\":{\"159\":1}}],[\"③混合索引\",{\"1\":{\"169\":1}}],[\"支持基于redis的jdkcollection实现\",{\"1\":{\"1036\":1}}],[\"支持基于jdk\",{\"1\":{\"1036\":1}}],[\"支持基于lettuce的响应式编程\",{\"1\":{\"1036\":1}}],[\"支持redis哨兵和redis集群\",{\"1\":{\"1036\":1}}],[\"支持redis的发布订阅模型\",{\"1\":{\"1036\":1}}],[\"支持交集\",{\"1\":{\"1029\":1}}],[\"支持多语言客户端\",{\"1\":{\"1009\":1}}],[\"支持多种type\",{\"1\":{\"923\":1}}],[\"支持主从集群\",{\"1\":{\"1009\":1}}],[\"支持数据持久化\",{\"1\":{\"1009\":1}}],[\"支持每秒产生2^32个不同id\",{\"1\":{\"992\":1}}],[\"支持链式调用\",{\"1\":{\"831\":1}}],[\"支持两大类数据源\",{\"1\":{\"660\":1}}],[\"支持\",{\"1\":{\"647\":1}}],[\"支持五种\",{\"1\":{\"496\":1}}],[\"支持配置为阻塞同步\",{\"1\":{\"434\":1}}],[\"支持一个进程所能打开的最大连接数\",{\"1\":{\"410\":1}}],[\"支持查看系统已接入设备\",{\"1\":{\"296\":1}}],[\"支持顺序访问和直接访问\",{\"1\":{\"169\":1}}],[\"支持用户级线程和内核级线程的系统中\",{\"1\":{\"135\":1}}],[\"块式管理\",{\"1\":{\"413\":1}}],[\"块io的效率比流io高很多\",{\"1\":{\"334\":1}}],[\"块\",{\"1\":{\"169\":1,\"181\":1}}],[\"层次结构清晰\",{\"1\":{\"168\":1}}],[\"显然当只有一件物品的时候\",{\"1\":{\"195\":1}}],[\"显然比较麻烦\",{\"1\":{\"93\":1}}],[\"显示链接\",{\"1\":{\"169\":2}}],[\"显示目录\",{\"1\":{\"168\":1}}],[\"搜索引擎\",{\"1\":{\"841\":1}}],[\"搜索引擎回滚\",{\"1\":{\"268\":1}}],[\"搜索\",{\"1\":{\"168\":1,\"922\":1}}],[\"搜狗输入法\",{\"1\":{\"107\":3}}],[\"索引查询getsettings\",{\"1\":{\"933\":1}}],[\"索引查询getmappings\",{\"1\":{\"933\":1}}],[\"索引查询getaliases\",{\"1\":{\"933\":1}}],[\"索引删除\",{\"1\":{\"933\":1}}],[\"索引操作\",{\"0\":{\"933\":1},\"1\":{\"933\":1}}],[\"索引下推\",{\"0\":{\"385\":1}}],[\"索引列按递增的顺序\",{\"1\":{\"383\":1}}],[\"索引就是让数据按照某种顺序进行存储或检索\",{\"1\":{\"383\":1}}],[\"索引主要有4种\",{\"1\":{\"382\":1}}],[\"索引的分类\",{\"0\":{\"382\":1}}],[\"索引的长度与区分度是一对矛盾体\",{\"1\":{\"266\":1,\"383\":1}}],[\"索引树会一次性加载吗\",{\"0\":{\"376\":1}}],[\"索引也要进行动态维护\",{\"1\":{\"375\":1}}],[\"索引需要占磁盘空间\",{\"1\":{\"375\":1}}],[\"索引是在存储引擎中实现的\",{\"1\":{\"375\":1}}],[\"索引物理文件全扫描\",{\"1\":{\"266\":1}}],[\"索引a\",{\"1\":{\"266\":1}}],[\"索引中有范围查找\",{\"1\":{\"266\":1}}],[\"索引\",{\"0\":{\"922\":1},\"1\":{\"266\":1,\"927\":2}}],[\"索引长度\",{\"1\":{\"266\":1,\"383\":1}}],[\"索引规约\",{\"0\":{\"266\":1}}],[\"索引分配\",{\"1\":{\"169\":1}}],[\"索引结点\",{\"1\":{\"168\":1}}],[\"索引顺序文件\",{\"1\":{\"167\":1}}],[\"索引文件可能比数据文件更快达到最大文件尺寸\",{\"1\":{\"375\":1}}],[\"索引文件具有b\",{\"1\":{\"266\":1}}],[\"索引文件\",{\"1\":{\"167\":1}}],[\"索引方式\",{\"1\":{\"131\":1}}],[\"逻辑分析\",{\"1\":{\"987\":1}}],[\"逻辑过期时间单位\",{\"1\":{\"990\":2}}],[\"逻辑过期时间\",{\"1\":{\"989\":1,\"990\":2}}],[\"逻辑过期方案\",{\"1\":{\"987\":2}}],[\"逻辑过期\",{\"1\":{\"987\":1,\"990\":1}}],[\"逻辑视图名\",{\"1\":{\"736\":1}}],[\"逻辑上没有最大值限制\",{\"1\":{\"776\":1}}],[\"逻辑上\",{\"1\":{\"167\":1}}],[\"逻辑地址和物理地址\",{\"0\":{\"414\":1}}],[\"逻辑地址转物理地址\",{\"1\":{\"160\":1}}],[\"逻辑地址在页面的偏移量\",{\"1\":{\"156\":1}}],[\"逻辑地址如何转换为物理地址\",{\"1\":{\"156\":1}}],[\"逻辑地址就是相对初始位置的距离\",{\"1\":{\"151\":1}}],[\"逻辑地址\",{\"1\":{\"151\":3,\"156\":2}}],[\"定时任务\",{\"1\":{\"837\":1}}],[\"定时任务通过\",{\"1\":{\"296\":1}}],[\"定长字节表示内容长度\",{\"1\":{\"766\":1}}],[\"定长记录\",{\"1\":{\"167\":1}}],[\"定期删除对内存更加友好\",{\"1\":{\"427\":1}}],[\"定期删除\",{\"1\":{\"427\":1}}],[\"定制排序\",{\"1\":{\"340\":1}}],[\"定位死锁的方法\",{\"1\":{\"221\":1}}],[\"定义最终订阅者\",{\"1\":{\"744\":1}}],[\"定义处理器\",{\"1\":{\"744\":1}}],[\"定义订阅者\",{\"1\":{\"743\":1}}],[\"定义发布者\",{\"1\":{\"743\":1,\"744\":1}}],[\"定义配置类\",{\"1\":{\"738\":1}}],[\"定义配置文件\",{\"1\":{\"77\":1}}],[\"定义等\",{\"1\":{\"652\":1}}],[\"定义字段类型为text\",{\"1\":{\"265\":1}}],[\"定义了对其他库的传递依赖\",{\"1\":{\"727\":1}}],[\"定义了算法的骨架\",{\"1\":{\"119\":1}}],[\"定义了产品的规范\",{\"1\":{\"62\":1,\"68\":1,\"73\":1}}],[\"定义一个操作中的算法骨架\",{\"1\":{\"118\":1}}],[\"定义一个用于创建对象的接口\",{\"1\":{\"67\":1}}],[\"定义一个创建对象的接口\",{\"1\":{\"58\":1}}],[\"定义一个适配器类来实现当前系统的业务接口\",{\"1\":{\"41\":1}}],[\"定义各种抽象组件\",{\"1\":{\"49\":1}}],[\"定义适配器类\",{\"1\":{\"41\":1}}],[\"定义\",{\"1\":{\"39\":1,\"118\":1,\"477\":1,\"650\":1,\"652\":1}}],[\"占用\",{\"1\":{\"792\":1}}],[\"占用36字节\",{\"1\":{\"392\":1}}],[\"占用8个字节\",{\"1\":{\"377\":1}}],[\"占用4个字节\",{\"1\":{\"377\":1}}],[\"占用空间都发生变化\",{\"1\":{\"280\":1}}],[\"占用一块连续的内存空间\",{\"1\":{\"278\":1}}],[\"占用的存储空间\",{\"1\":{\"167\":1}}],[\"占有cpu\",{\"1\":{\"132\":1}}],[\"工序有多道\",{\"1\":{\"837\":1}}],[\"工人按照\",{\"1\":{\"837\":1}}],[\"工人既可以执行\",{\"1\":{\"837\":1}}],[\"工人可以管理多个\",{\"1\":{\"837\":1}}],[\"工人执行\",{\"1\":{\"798\":2}}],[\"工人也分别绑定了\",{\"1\":{\"798\":1}}],[\"工人和\",{\"1\":{\"798\":1}}],[\"工人\",{\"1\":{\"798\":2}}],[\"工具反编译第\",{\"1\":{\"519\":1}}],[\"工具反编译代理类\",{\"1\":{\"516\":1}}],[\"工资总和\",{\"1\":{\"342\":1}}],[\"工作目录\",{\"1\":{\"1015\":1}}],[\"工作在非阻塞模式下\",{\"1\":{\"917\":1}}],[\"工作模式⚠️\",{\"0\":{\"862\":1}}],[\"工作量大\",{\"1\":{\"842\":1}}],[\"工作原理\",{\"1\":{\"345\":1}}],[\"工作时\",{\"1\":{\"323\":1}}],[\"工作集\",{\"1\":{\"164\":1}}],[\"工厂设计模式是实际开发中非常常用的一种设计模式\",{\"1\":{\"1034\":1}}],[\"工厂方法使一个产品类的实例化延迟到其工厂的子类\",{\"1\":{\"67\":1}}],[\"工厂方法模式只生产一个等级的产品\",{\"1\":{\"72\":1}}],[\"工厂方法模式只考虑生产同等级的产品\",{\"1\":{\"71\":1}}],[\"工厂方法模式保持了简单工厂模式的优点\",{\"1\":{\"69\":1}}],[\"工厂方法模式是简单工厂模式的进一步抽象\",{\"1\":{\"69\":1}}],[\"工厂方法模式的主要角色\",{\"1\":{\"68\":1}}],[\"工厂方法模式\",{\"0\":{\"66\":1},\"1\":{\"60\":1}}],[\"工厂方法模式注重的是整体对象的创建方式\",{\"1\":{\"54\":1}}],[\"工厂方法模式vs建造者模式\",{\"0\":{\"54\":1}}],[\"工厂类的客户端可能有很多\",{\"1\":{\"63\":1}}],[\"工厂类代码如下\",{\"1\":{\"63\":1}}],[\"工厂对象和商品对象的耦合\",{\"1\":{\"63\":1}}],[\"工厂\",{\"1\":{\"63\":1}}],[\"工厂模式最大的优点就是\",{\"1\":{\"60\":1}}],[\"工厂模式使其创建过程延迟到子类进行\",{\"1\":{\"58\":1}}],[\"工厂模式\",{\"0\":{\"58\":1,\"59\":1}}],[\"颠簸\",{\"1\":{\"164\":1}}],[\"抖动\",{\"1\":{\"164\":1}}],[\"预设长度\",{\"0\":{\"756\":1}}],[\"预写式日志\",{\"1\":{\"396\":1}}],[\"预计废弃\",{\"1\":{\"360\":1}}],[\"预调页策略\",{\"1\":{\"164\":1}}],[\"预防死锁\",{\"0\":{\"148\":1},\"1\":{\"147\":1}}],[\"何时不阻塞💡\",{\"0\":{\"883\":1}}],[\"何时调入页面\",{\"1\":{\"164\":1}}],[\"何时使用\",{\"1\":{\"58\":1}}],[\"√\",{\"1\":{\"164\":3}}],[\"全连接队列\",{\"1\":{\"776\":1}}],[\"全部数据处理完成\",{\"1\":{\"743\":1,\"744\":2}}],[\"全局id生成器\",{\"1\":{\"992\":1}}],[\"全局异常捕获\",{\"1\":{\"732\":2}}],[\"全局异常捕获>>>\",{\"1\":{\"732\":1}}],[\"全局异常处理器\",{\"1\":{\"732\":1}}],[\"全局增强点5️⃣\",{\"1\":{\"644\":1}}],[\"全局增强点4️⃣\",{\"1\":{\"644\":1}}],[\"全局增强点3️⃣\",{\"1\":{\"644\":1}}],[\"全局增强点2️⃣\",{\"1\":{\"644\":1}}],[\"全局增强点1️⃣\",{\"1\":{\"644\":1}}],[\"全局hash表以及多种高效数据结构\",{\"1\":{\"424\":1}}],[\"全局唯一id\",{\"0\":{\"992\":1}}],[\"全局唯一\",{\"1\":{\"392\":1}}],[\"全局唯一保证在各系统之间都是唯一的\",{\"1\":{\"392\":1}}],[\"全局置换\",{\"1\":{\"164\":2}}],[\"全程没有加锁\",{\"1\":{\"249\":1}}],[\"全类名\",{\"1\":{\"77\":1}}],[\"局部唯一性\",{\"1\":{\"391\":1}}],[\"局部变量被初始化为基本数据类型则是安全的\",{\"1\":{\"209\":1}}],[\"局部变量线程安全分析\",{\"1\":{\"209\":1}}],[\"局部置换\",{\"1\":{\"164\":2}}],[\"局部性原理有表现在下述两个方面\",{\"1\":{\"417\":1}}],[\"局部性原理是虚拟内存技术的基础\",{\"1\":{\"416\":1}}],[\"局部性原理\",{\"0\":{\"417\":1},\"1\":{\"161\":1}}],[\"又可以分为3类\",{\"1\":{\"1025\":1}}],[\"又可以分为定长记录和可变长记录\",{\"1\":{\"167\":1}}],[\"又有两个线程\",{\"1\":{\"999\":1}}],[\"又不具备\",{\"1\":{\"904\":1}}],[\"又读了一个字节\",{\"1\":{\"826\":1}}],[\"又对\",{\"1\":{\"806\":1}}],[\"又回到了熟悉的\",{\"1\":{\"793\":1}}],[\"又支持如下数据源\",{\"1\":{\"660\":1}}],[\"又提供了一个\",{\"1\":{\"617\":1}}],[\"又用了一大堆\",{\"1\":{\"527\":1}}],[\"又增加了2种策略\",{\"1\":{\"429\":1}}],[\"又推动了第三张牌倒下\",{\"1\":{\"280\":1}}],[\"又会走上面的静态资源处理流程\",{\"1\":{\"642\":1}}],[\"又会引发对\",{\"1\":{\"280\":1}}],[\"又会导致多道程序并发度下降\",{\"1\":{\"164\":1}}],[\"又称设备无关性软件\",{\"1\":{\"182\":1}}],[\"又称树形目录结构\",{\"1\":{\"168\":1}}],[\"又称\",{\"1\":{\"167\":1,\"184\":1}}],[\"又称clock算法\",{\"1\":{\"163\":1}}],[\"又称限长寄存器\",{\"1\":{\"152\":1}}],[\"又称为\",{\"1\":{\"167\":1}}],[\"又称为基址寄存器\",{\"1\":{\"152\":1}}],[\"又称为动态运行时装入\",{\"1\":{\"151\":1}}],[\"又称为虚拟机\",{\"1\":{\"126\":1}}],[\"又称可重定位装入\",{\"1\":{\"151\":1}}],[\"又称抢占方式\",{\"1\":{\"137\":1}}],[\"又称非抢占方式\",{\"1\":{\"137\":1}}],[\"驻留集的大小不能小于工作集的大小\",{\"1\":{\"164\":1}}],[\"驻留集大小可变\",{\"1\":{\"164\":1}}],[\"驻留集大小不变\",{\"1\":{\"164\":1}}],[\"驻留集大小一般小于进程的总大小\",{\"1\":{\"164\":1}}],[\"驻留集太大\",{\"1\":{\"164\":1}}],[\"驻留集太小\",{\"1\":{\"164\":1}}],[\"驻留集\",{\"1\":{\"164\":1}}],[\"暂停期间不会占用\",{\"1\":{\"876\":1}}],[\"暂停时间的重要性日益凸显\",{\"1\":{\"359\":1}}],[\"暂停时间\",{\"1\":{\"359\":3}}],[\"暂不换出\",{\"1\":{\"163\":1}}],[\"暂时用不到的部分留在外存\",{\"1\":{\"161\":1}}],[\"暂时用不到的数据放在更低速的存储器中\",{\"1\":{\"161\":1}}],[\"暂时用不到的数据\",{\"1\":{\"161\":1}}],[\"暂时放到外存上\",{\"1\":{\"150\":1}}],[\"暂时调到外存的进程状态为挂起状态\",{\"1\":{\"136\":1}}],[\"找出词频top100的词\",{\"1\":{\"290\":1}}],[\"找最晚出现的淘汰掉\",{\"1\":{\"163\":1}}],[\"找到一条完整消息\",{\"1\":{\"890\":1}}],[\"找到反序列化算法\",{\"1\":{\"773\":1}}],[\"找到\",{\"1\":{\"561\":1}}],[\"找到有\",{\"1\":{\"539\":1}}],[\"找到这些方法编号\",{\"1\":{\"527\":1}}],[\"找到相同的key\",{\"1\":{\"249\":1}}],[\"找到合适的插入位置\",{\"1\":{\"190\":1}}],[\"找到最大\",{\"1\":{\"189\":1}}],[\"找到目标扇区平均需要转半圈\",{\"1\":{\"176\":1}}],[\"找到该文件对应的目录项\",{\"1\":{\"168\":1}}],[\"找到大小能够满足要求的第一个空闲分区\",{\"1\":{\"155\":4}}],[\"找到第一个能满足大小的空闲分区\",{\"1\":{\"155\":1}}],[\"时的读写模式决定\",{\"1\":{\"863\":1}}],[\"时的时间戳来解决\",{\"1\":{\"442\":1}}],[\"时都有问题\",{\"1\":{\"523\":1}}],[\"时创建\",{\"1\":{\"496\":3}}],[\"时便得到通知\",{\"1\":{\"410\":1}}],[\"时需注意npe问题\",{\"1\":{\"267\":1}}],[\"时钟周期不被浪费\",{\"1\":{\"246\":1}}],[\"时钟置换算法是一种性能和开销较均衡的算法\",{\"1\":{\"163\":1}}],[\"时钟置换算法\",{\"1\":{\"163\":2}}],[\"时\",{\"1\":{\"244\":1,\"263\":1,\"267\":1,\"277\":1,\"327\":1,\"450\":1,\"600\":3,\"730\":1,\"751\":1,\"790\":1,\"791\":2,\"803\":5,\"825\":1,\"886\":1,\"890\":1,\"909\":2}}],[\"时间的本质\",{\"1\":{\"731\":1}}],[\"时间的秩序\",{\"1\":{\"731\":1}}],[\"时间\",{\"1\":{\"731\":1}}],[\"时间戳\",{\"1\":{\"441\":1,\"992\":1}}],[\"时间戳需要左移的位数\",{\"1\":{\"441\":1}}],[\"时间戳和版本号机制一样\",{\"1\":{\"397\":1}}],[\"时间复杂度为o\",{\"1\":{\"430\":2}}],[\"时间复杂度\",{\"1\":{\"430\":1}}],[\"时间复杂度是\",{\"1\":{\"277\":1}}],[\"时间复杂度只需要\",{\"1\":{\"277\":1}}],[\"时间复杂度也很高\",{\"1\":{\"276\":1}}],[\"时间单位为\",{\"1\":{\"882\":1}}],[\"时间单位\",{\"1\":{\"242\":1}}],[\"时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中\",{\"1\":{\"417\":1}}],[\"时间局部性\",{\"1\":{\"161\":1,\"417\":1}}],[\"时间片从小到大\",{\"1\":{\"139\":1}}],[\"时间片轮转算法\",{\"1\":{\"139\":1}}],[\"放行\",{\"1\":{\"961\":1,\"972\":1}}],[\"放入\",{\"1\":{\"574\":1,\"600\":4,\"617\":1,\"776\":1,\"825\":1,\"887\":1}}],[\"放入新的hash表中\",{\"1\":{\"328\":1}}],[\"放入阻塞队列\",{\"1\":{\"162\":1}}],[\"放回就绪队列\",{\"1\":{\"162\":1}}],[\"远古时代的计算机操作系统的内存管理方式\",{\"1\":{\"413\":1}}],[\"远大于实际的容量\",{\"1\":{\"161\":1}}],[\"远程词典服务器\",{\"1\":{\"1009\":1}}],[\"远程rpc\",{\"1\":{\"246\":1}}],[\"远程\",{\"1\":{\"98\":1}}],[\"直击数据库\",{\"1\":{\"984\":1}}],[\"直至\",{\"1\":{\"449\":1}}],[\"直至作业运行结束\",{\"1\":{\"161\":1}}],[\"直到获取到锁为止\",{\"1\":{\"988\":1}}],[\"直到新开的线程完成这个逻辑后\",{\"1\":{\"987\":1}}],[\"直到线程1把锁释放后\",{\"1\":{\"987\":1}}],[\"直到返回\",{\"1\":{\"825\":1}}],[\"直到超时\",{\"1\":{\"791\":1}}],[\"直到找到一个未过期的key返回\",{\"1\":{\"436\":1}}],[\"直到有描述符就绪\",{\"1\":{\"410\":1}}],[\"直到数据变为可以读取之前\",{\"1\":{\"332\":1}}],[\"直到所有文件输入流都没有数据为止\",{\"1\":{\"291\":1}}],[\"直到构造好有100个结点的小顶堆为止\",{\"1\":{\"290\":1}}],[\"直接放行\",{\"1\":{\"993\":1}}],[\"直接就返回404了\",{\"1\":{\"985\":1}}],[\"直接查询数据库那肯定慢咯\",{\"1\":{\"977\":1}}],[\"直接调用\",{\"1\":{\"799\":1}}],[\"直接调用即可\",{\"1\":{\"549\":1}}],[\"直接内存对\",{\"1\":{\"819\":1}}],[\"直接内存创建和销毁的代价昂贵\",{\"1\":{\"819\":1}}],[\"直接内存\",{\"0\":{\"819\":1},\"1\":{\"781\":1,\"851\":1}}],[\"直接返回null\",{\"1\":{\"989\":1,\"990\":1}}],[\"直接返回\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"990\":2}}],[\"直接返回指定的结果给客户端\",{\"1\":{\"315\":1}}],[\"直接返回这个成员变量的值就行\",{\"1\":{\"277\":1}}],[\"直接返回实际\",{\"1\":{\"101\":1}}],[\"直接返回实例\",{\"1\":{\"101\":1}}],[\"直接释放掉\",{\"1\":{\"221\":1}}],[\"直接存储器存取\",{\"1\":{\"181\":1}}],[\"直接抛异常\",{\"1\":{\"104\":1}}],[\"直接进行获取即可\",{\"1\":{\"77\":1}}],[\"直接在工厂里更换该对象即可\",{\"1\":{\"60\":1}}],[\"直接产生出来的就是一个力大无穷\",{\"1\":{\"54\":1}}],[\"段\",{\"1\":{\"418\":8,\"419\":1}}],[\"段式管理通过段表对应逻辑地址和物理地址\",{\"1\":{\"413\":1}}],[\"段式管理\",{\"1\":{\"413\":1}}],[\"段页式存储管理结合了页式管理和段式管理的优点\",{\"1\":{\"413\":1}}],[\"段页式系统的逻辑地址结构由段号\",{\"1\":{\"160\":1}}],[\"段页式管理\",{\"1\":{\"160\":1,\"413\":1}}],[\"段页式管理方式\",{\"0\":{\"160\":1}}],[\"段表寄存器\",{\"1\":{\"159\":1}}],[\"段表\",{\"1\":{\"159\":1,\"160\":1}}],[\"段内地址\",{\"1\":{\"160\":1}}],[\"段内地址位数决定了每个段的最大长度是多少\",{\"1\":{\"159\":1}}],[\"段内偏移量\",{\"1\":{\"159\":1}}],[\"段名\",{\"1\":{\"159\":1}}],[\"段号是隐含的\",{\"1\":{\"160\":1}}],[\"段号是可以隐含的\",{\"1\":{\"159\":1}}],[\"段号的位数决定了每个进程最多可以分几个段\",{\"1\":{\"159\":1}}],[\"段号\",{\"1\":{\"159\":1}}],[\"联合索引优于单值\",{\"1\":{\"383\":1}}],[\"联想寄存器\",{\"1\":{\"157\":1}}],[\"联机命令接口\",{\"1\":{\"126\":1}}],[\"结束时间等等字段\",{\"1\":{\"994\":1}}],[\"结束抢购时间\",{\"1\":{\"994\":1}}],[\"结束后\",{\"1\":{\"743\":1,\"744\":1}}],[\"结合目标与环绕通知链\",{\"1\":{\"549\":1}}],[\"结合目标用\",{\"1\":{\"523\":1}}],[\"结合代理用\",{\"1\":{\"523\":1}}],[\"结合cas和volatile可以实现无锁并发\",{\"1\":{\"231\":1}}],[\"结果又是节点6\",{\"1\":{\"816\":1}}],[\"结果容器\",{\"1\":{\"809\":1}}],[\"结果是一样的\",{\"1\":{\"829\":1}}],[\"结果是\",{\"1\":{\"807\":1,\"808\":1,\"809\":1,\"816\":2,\"822\":2,\"823\":1}}],[\"结果仍\",{\"1\":{\"688\":1}}],[\"结果个数为\",{\"1\":{\"688\":1}}],[\"结果就在堆中\",{\"1\":{\"354\":1}}],[\"结果写到一个大文件中\",{\"1\":{\"291\":1}}],[\"结果发现也没有\",{\"1\":{\"236\":1}}],[\"结果\",{\"1\":{\"232\":10,\"568\":1,\"732\":1,\"787\":1,\"791\":1,\"824\":1,\"829\":1,\"857\":1}}],[\"结论\",{\"1\":{\"156\":1,\"186\":2}}],[\"结构化与非结构化\",{\"0\":{\"1004\":1}}],[\"结构体实际占用多少内存空间\",{\"1\":{\"277\":1}}],[\"结构头占用空间也比较少\",{\"1\":{\"277\":1}}],[\"结构中有个\",{\"1\":{\"277\":1}}],[\"结构中的每个成员变量分别介绍下\",{\"1\":{\"277\":1}}],[\"结构里引入了\",{\"1\":{\"277\":1}}],[\"结构因为加入了\",{\"1\":{\"277\":1}}],[\"结构在原本字符数组之上\",{\"1\":{\"277\":1}}],[\"结构设计\",{\"0\":{\"277\":1}}],[\"结构来表示字符串\",{\"1\":{\"275\":1}}],[\"结构上看进程由pcb\",{\"1\":{\"131\":1}}],[\"结构性\",{\"1\":{\"131\":1}}],[\"结构\",{\"0\":{\"40\":1,\"48\":1,\"62\":1,\"68\":1,\"73\":1,\"81\":1,\"85\":1,\"92\":1,\"115\":1,\"119\":1,\"848\":1}}],[\"算出逻辑地址对应的页号\",{\"1\":{\"156\":1}}],[\"算法产生的缘由\",{\"1\":{\"751\":1}}],[\"算法\",{\"1\":{\"751\":2}}],[\"算法中可通过记录最后一个生成\",{\"1\":{\"442\":1}}],[\"算法简单\",{\"1\":{\"442\":1}}],[\"算法优缺点\",{\"0\":{\"442\":1}}],[\"算法实现\",{\"0\":{\"441\":1}}],[\"算法实现简单\",{\"1\":{\"139\":1}}],[\"算法的实现需要专门的硬件支持\",{\"1\":{\"163\":1}}],[\"算法的整体步骤很固定\",{\"1\":{\"122\":1}}],[\"算法种类\",{\"1\":{\"163\":1}}],[\"算法思想\",{\"1\":{\"139\":5,\"141\":4,\"155\":4}}],[\"算法规则\",{\"1\":{\"139\":6,\"163\":1}}],[\"页的调入调出\",{\"1\":{\"418\":1}}],[\"页的大小是固定的\",{\"1\":{\"413\":1}}],[\"页的地址结构\",{\"1\":{\"413\":1}}],[\"页和段都是离散存储的\",{\"1\":{\"413\":1}}],[\"页和块的大小相同\",{\"1\":{\"413\":1}}],[\"页\",{\"1\":{\"413\":2}}],[\"页式管理虽然提高了内存利用率\",{\"1\":{\"413\":1}}],[\"页式管理中将进程的逻辑地址空间分成若干个页\",{\"1\":{\"413\":1}}],[\"页式管理\",{\"1\":{\"413\":1}}],[\"页锁和行锁\",{\"1\":{\"399\":1}}],[\"页锁\",{\"1\":{\"396\":1}}],[\"页分裂\",{\"1\":{\"380\":1}}],[\"页内地址组成\",{\"1\":{\"160\":1}}],[\"页内偏移量\",{\"1\":{\"156\":1}}],[\"页表也会很大的问题\",{\"1\":{\"413\":1}}],[\"页表机制\",{\"1\":{\"162\":2}}],[\"页表的作用是实现页号到物理块号的地址映射\",{\"1\":{\"413\":1}}],[\"页表的起始地址\",{\"1\":{\"160\":1}}],[\"页表的开始地址\",{\"1\":{\"157\":1}}],[\"页表存放块号\",{\"1\":{\"160\":1}}],[\"页表长度\",{\"1\":{\"160\":1}}],[\"页表必须连续存放\",{\"1\":{\"158\":1}}],[\"页表起始地址和长度放在pcb在\",{\"1\":{\"157\":1}}],[\"页表中的一条记录\",{\"1\":{\"156\":1}}],[\"页表项中的访问字段记录页面自上次被访问以来所经历的时间t\",{\"1\":{\"163\":1}}],[\"页表项的个数\",{\"1\":{\"157\":1}}],[\"页表项\",{\"1\":{\"156\":1}}],[\"页表由页号和块号\",{\"1\":{\"156\":1}}],[\"页表\",{\"1\":{\"156\":1,\"160\":1,\"413\":1}}],[\"页号是隐含\",{\"1\":{\"160\":1}}],[\"页号在内存中的起始地址\",{\"1\":{\"156\":1}}],[\"页号\",{\"1\":{\"156\":1,\"160\":1}}],[\"页号也是从0开始\",{\"1\":{\"156\":1}}],[\"页面流程\",{\"1\":{\"960\":1}}],[\"页面对应着逻辑地址\",{\"1\":{\"413\":1}}],[\"页面\",{\"1\":{\"413\":2}}],[\"页面搜索严禁左模糊或者全模糊\",{\"1\":{\"266\":1}}],[\"页面的大小相同\",{\"1\":{\"169\":1}}],[\"页面的换入\",{\"1\":{\"163\":1}}],[\"页面分配策略\",{\"0\":{\"164\":1}}],[\"页面置换发生了6次\",{\"1\":{\"163\":1}}],[\"页面置换算法\",{\"0\":{\"163\":1,\"420\":1}}],[\"页面存放的内存块号组成\",{\"1\":{\"160\":1}}],[\"页面长度\",{\"1\":{\"156\":2}}],[\"页面不必连续存放\",{\"1\":{\"156\":1}}],[\"页面与页框有一一对应关系\",{\"1\":{\"156\":1}}],[\"页框\",{\"1\":{\"413\":1}}],[\"页框号\",{\"1\":{\"156\":1}}],[\"页框号从0开始\",{\"1\":{\"156\":1}}],[\"页框不能太大\",{\"1\":{\"156\":1}}],[\"邻近适应算法\",{\"1\":{\"155\":1}}],[\"尽管json的序列化方式可以满足我们的需求\",{\"1\":{\"1042\":1}}],[\"尽量使用覆盖索引\",{\"1\":{\"395\":1}}],[\"尽量先使用组合或者聚合等关联关系来实现\",{\"1\":{\"112\":1}}],[\"尽可能缩减加锁的范围\",{\"1\":{\"221\":1}}],[\"尽可能更多的留下大片的空闲区\",{\"1\":{\"155\":1}}],[\"外\",{\"1\":{\"776\":1}}],[\"外存\",{\"1\":{\"417\":1}}],[\"外存利用率高\",{\"1\":{\"169\":2}}],[\"外围设备完成用户请求的操作后\",{\"1\":{\"406\":1}}],[\"外键影响数据库的插入速度\",{\"1\":{\"267\":1}}],[\"外键与级联更新适用于单机低并发\",{\"1\":{\"267\":1}}],[\"外部碎片\",{\"1\":{\"154\":1}}],[\"外中断的处理过程\",{\"1\":{\"129\":1}}],[\"情况三\",{\"1\":{\"154\":1}}],[\"情况二\",{\"1\":{\"154\":1}}],[\"情况一\",{\"1\":{\"154\":1}}],[\"状态改变为\",{\"1\":{\"776\":3}}],[\"状态修改为\",{\"1\":{\"776\":1}}],[\"状态机\",{\"1\":{\"315\":1}}],[\"状态如下\",{\"1\":{\"261\":1}}],[\"状态变量state\",{\"0\":{\"252\":1}}],[\"状态名称\",{\"1\":{\"241\":1}}],[\"状态转移方程\",{\"1\":{\"195\":1}}],[\"状态寄存器对应一个具体的设备\",{\"1\":{\"180\":1}}],[\"状态寄存器可能也有多个\",{\"1\":{\"180\":1}}],[\"状态等信息\",{\"1\":{\"154\":1}}],[\"状态\",{\"1\":{\"154\":1,\"181\":1,\"203\":2,\"848\":2}}],[\"划分为小分区\",{\"1\":{\"155\":1}}],[\"划分多个小分区\",{\"1\":{\"154\":1}}],[\"划分可分为白色汽车\",{\"1\":{\"112\":1}}],[\"划分可分为汽油汽车\",{\"1\":{\"112\":1}}],[\"缺页\",{\"1\":{\"419\":1}}],[\"缺页次数不减反增的异常现象\",{\"1\":{\"163\":1}}],[\"缺页发生9次\",{\"1\":{\"163\":1}}],[\"缺页发生10次\",{\"1\":{\"163\":1}}],[\"缺页9次\",{\"1\":{\"163\":1}}],[\"缺页率\",{\"1\":{\"163\":1}}],[\"缺页时未必发生页面置换\",{\"1\":{\"163\":1}}],[\"缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的\",{\"1\":{\"162\":1}}],[\"缺页中断机构\",{\"1\":{\"162\":2}}],[\"缺乏灵活性\",{\"1\":{\"154\":1}}],[\"缺点在于有锁就有死锁问题的发生\",{\"1\":{\"987\":1}}],[\"缺点在于在构建完缓存之前\",{\"1\":{\"987\":1}}],[\"缺点是数据拷贝耗费性能\",{\"1\":{\"891\":1}}],[\"缺点是效率低\",{\"1\":{\"890\":1}}],[\"缺点是浪费带宽\",{\"1\":{\"890\":1}}],[\"缺点是\",{\"1\":{\"754\":1,\"890\":1}}],[\"缺点是包的往返时间越长性能就越差\",{\"1\":{\"751\":1}}],[\"缺点需要转义\",{\"1\":{\"752\":1}}],[\"缺点浪费空间\",{\"1\":{\"752\":1}}],[\"缺点效率太低\",{\"1\":{\"752\":1}}],[\"缺点\",{\"1\":{\"50\":1,\"58\":1,\"64\":1,\"70\":1,\"75\":1,\"97\":1,\"121\":1,\"135\":2,\"139\":4,\"142\":3,\"148\":4,\"153\":1,\"154\":2,\"155\":4,\"160\":1,\"169\":3,\"173\":1,\"181\":3,\"185\":1,\"356\":1,\"375\":1,\"755\":1,\"829\":1,\"984\":2,\"1041\":1}}],[\"总是运行完所有非\",{\"1\":{\"791\":1}}],[\"总是淘汰最先进入内存的页面\",{\"1\":{\"420\":1}}],[\"总会被执行\",{\"1\":{\"490\":1}}],[\"总运行时间\",{\"1\":{\"359\":1}}],[\"总之\",{\"1\":{\"313\":1,\"731\":1,\"928\":1}}],[\"总之对换区的i\",{\"1\":{\"153\":1}}],[\"总共8种\",{\"1\":{\"429\":1}}],[\"总共500个小文件\",{\"1\":{\"291\":1}}],[\"总共需要跨越n个磁道\",{\"1\":{\"176\":1}}],[\"总的来说\",{\"1\":{\"277\":1}}],[\"总的平均存储时间ta​=ts​+2r1​+rnb​\",{\"1\":{\"176\":1}}],[\"总结一下\",{\"1\":{\"290\":1}}],[\"总结\",{\"0\":{\"334\":1,\"1008\":1},\"1\":{\"197\":1,\"272\":1,\"410\":1,\"413\":1}}],[\"总结如下\",{\"1\":{\"123\":1,\"1008\":1}}],[\"除上述情况\",{\"1\":{\"751\":1}}],[\"除此以外\",{\"1\":{\"504\":1}}],[\"除此之外还需要引入aspectj依赖\",{\"1\":{\"998\":1}}],[\"除此之外还要实现常驻人口展示的接口\",{\"1\":{\"296\":1}}],[\"除此之外听音乐也能舒缓我的情绪\",{\"1\":{\"309\":1}}],[\"除此之外\",{\"1\":{\"293\":1,\"299\":1,\"336\":1,\"707\":1}}],[\"除数据库层面的保障\",{\"1\":{\"396\":1}}],[\"除了上述四点以外\",{\"1\":{\"1008\":1}}],[\"除了上述核心操作\",{\"1\":{\"728\":1}}],[\"除了用\",{\"1\":{\"803\":1}}],[\"除了可以处理\",{\"1\":{\"800\":1}}],[\"除了课堂上讲的\",{\"1\":{\"495\":1}}],[\"除了超时机制\",{\"1\":{\"403\":1}}],[\"除了修改buffer\",{\"1\":{\"396\":1}}],[\"除了数据表占数据空间之外\",{\"1\":{\"375\":1}}],[\"除了设计不同类型的结构体\",{\"1\":{\"277\":1}}],[\"除了字符串的末尾之外\",{\"1\":{\"276\":1}}],[\"除了cpu以外\",{\"1\":{\"132\":1}}],[\"除文件的最后一个盘块之外\",{\"1\":{\"169\":1}}],[\"除非运行结束\",{\"1\":{\"153\":1}}],[\"覆盖掉\",{\"1\":{\"872\":1}}],[\"覆盖与交换\",{\"0\":{\"153\":1}}],[\"覆盖技术\",{\"1\":{\"152\":1,\"153\":1}}],[\"边装入边链接\",{\"1\":{\"151\":1}}],[\"绝大多数情况都是用lru策略\",{\"1\":{\"429\":1}}],[\"绝大多数情况下使用的是行锁\",{\"1\":{\"396\":1}}],[\"绝大部分的操作都是读操作\",{\"1\":{\"101\":1}}],[\"绝对路径\",{\"1\":{\"871\":2}}],[\"绝对装入只适用于单道程序的环境\",{\"1\":{\"151\":1}}],[\"绝对装入\",{\"1\":{\"151\":1}}],[\"绝对地址\",{\"1\":{\"151\":1}}],[\"个数\",{\"1\":{\"897\":1}}],[\"个数💡\",{\"0\":{\"897\":1}}],[\"个数超过一个时\",{\"1\":{\"830\":1}}],[\"个医生一天工作\",{\"1\":{\"805\":1}}],[\"个医生给人看病\",{\"1\":{\"805\":1}}],[\"个客户端连接时\",{\"1\":{\"776\":1}}],[\"个客户端都打印\",{\"1\":{\"776\":1}}],[\"个\",{\"1\":{\"776\":1}}],[\"个消息\",{\"1\":{\"749\":1,\"750\":1}}],[\"个事件\",{\"1\":{\"651\":1}}],[\"个初始化方法\",{\"1\":{\"495\":1}}],[\"个索引位置进行截取子串\",{\"1\":{\"336\":1}}],[\"个小文件中的单词进行排序\",{\"1\":{\"291\":1}}],[\"个元素的位数组只占用\",{\"1\":{\"272\":1}}],[\"个格子\",{\"1\":{\"194\":1}}],[\"个格子和\",{\"1\":{\"194\":1}}],[\"个格子的值时\",{\"1\":{\"194\":1}}],[\"个房间\",{\"1\":{\"151\":1}}],[\"个存储单元\",{\"1\":{\"151\":1}}],[\"个字节后\",{\"1\":{\"848\":1}}],[\"个字节后的状态\",{\"1\":{\"848\":1}}],[\"个字节大小\",{\"1\":{\"280\":1}}],[\"个字节被浪费掉了\",{\"1\":{\"277\":1}}],[\"个字节是为了字节对齐而分配的\",{\"1\":{\"277\":1}}],[\"个字节\",{\"1\":{\"151\":1,\"277\":5,\"749\":1,\"770\":1,\"771\":1,\"773\":1,\"822\":2}}],[\"亿以上\",{\"1\":{\"274\":1}}],[\"亿\",{\"1\":{\"151\":1}}],[\"兆\",{\"1\":{\"151\":1}}],[\"千变万化\",{\"1\":{\"516\":1}}],[\"千兆\",{\"1\":{\"151\":1}}],[\"千\",{\"1\":{\"151\":1}}],[\"挂起\",{\"1\":{\"150\":1}}],[\"挂起介绍\",{\"1\":{\"136\":1}}],[\"还得利用代理来生效\",{\"1\":{\"998\":1}}],[\"还得根据变量是基本类型和引用类型两种情况分类讨论\",{\"1\":{\"349\":1}}],[\"还具有库存\",{\"1\":{\"994\":1}}],[\"还包含从主分片复制数据的过程\",{\"1\":{\"929\":1}}],[\"还没有结果\",{\"1\":{\"810\":1}}],[\"还没有完成\",{\"1\":{\"790\":1}}],[\"还要处理\",{\"1\":{\"791\":1}}],[\"还要再遍历源字符串才能完成追加\",{\"1\":{\"276\":1}}],[\"还要再回收一块\",{\"1\":{\"170\":1}}],[\"还不如声明这是一个web应用程序来的简单\",{\"1\":{\"727\":1}}],[\"还支持比如事件发布\",{\"1\":{\"707\":1}}],[\"还未产生结果时返回\",{\"1\":{\"806\":1}}],[\"还未涉及数据读取\",{\"1\":{\"793\":1}}],[\"还未绑定\",{\"1\":{\"790\":1}}],[\"还未准备好\",{\"1\":{\"491\":1}}],[\"还未与操作系统线程关联\",{\"1\":{\"208\":1}}],[\"还是建议用业务来维护关联关系\",{\"1\":{\"1005\":1}}],[\"还是会把这个数据写入到redis中\",{\"1\":{\"985\":1}}],[\"还是相当于闲置\",{\"1\":{\"906\":1}}],[\"还是使用原始\",{\"1\":{\"826\":1}}],[\"还是时间存在于我们之中\",{\"1\":{\"731\":1}}],[\"还是\",{\"1\":{\"576\":1}}],[\"还是在同一毫秒内\",{\"1\":{\"441\":1}}],[\"还是缓解压力的一个好办法\",{\"1\":{\"309\":1}}],[\"还更差一些\",{\"1\":{\"409\":1}}],[\"还需再次利用切点表达式\",{\"1\":{\"556\":1}}],[\"还需记录数组的长度\",{\"1\":{\"353\":1}}],[\"还需要再加一个版本号\",{\"1\":{\"233\":1}}],[\"还可以使用回调的方式\",{\"1\":{\"803\":1}}],[\"还可以使用自旋来进行优化\",{\"1\":{\"212\":1}}],[\"还可以实现\",{\"1\":{\"495\":1}}],[\"还可以从性格冷静\",{\"1\":{\"301\":1}}],[\"还有内容\",{\"1\":{\"909\":1}}],[\"还有种办法是采用\",{\"1\":{\"824\":1}}],[\"还有一类方法是\",{\"1\":{\"822\":1}}],[\"还有一个订单数据的索引\",{\"1\":{\"922\":1}}],[\"还有一个相关的\",{\"1\":{\"661\":1}}],[\"还有一个特点是\",{\"1\":{\"410\":1}}],[\"还有一个问题\",{\"1\":{\"280\":1}}],[\"还有一个适配器模式是接口适配器模式\",{\"1\":{\"42\":1}}],[\"还有同学会笼统地回答\",{\"1\":{\"805\":1}}],[\"还有对于项目的理解\",{\"1\":{\"311\":1}}],[\"还有首页定位参数\",{\"1\":{\"296\":1}}],[\"还有在学习大数据的时候自己在电脑上用虚拟机搭了一个有三个节点的hadoop集群\",{\"1\":{\"293\":1}}],[\"还会在redo\",{\"1\":{\"396\":1}}],[\"还会给\",{\"1\":{\"277\":1}}],[\"还会降低系统的稳定性\",{\"1\":{\"240\":1}}],[\"还会唤醒阻塞的线程\",{\"1\":{\"219\":1}}],[\"还连着的边的那些进程就是死锁进程\",{\"1\":{\"150\":1}}],[\"蓝色表示正在请求的资源\",{\"1\":{\"150\":1}}],[\"检测和解除\",{\"0\":{\"150\":1}}],[\"检查\",{\"1\":{\"893\":1}}],[\"检查文件是否存在\",{\"1\":{\"872\":1}}],[\"检查workid的合法值\",{\"1\":{\"441\":1}}],[\"检查datacenterid的合法值\",{\"1\":{\"441\":1}}],[\"检查是否没有匹配所有元素\",{\"1\":{\"341\":1}}],[\"检查是否至少匹配一个元素\",{\"1\":{\"341\":1}}],[\"检查是否匹配所有元素\",{\"1\":{\"341\":1}}],[\"检查是否会发生抢占\",{\"1\":{\"139\":1}}],[\"检查设备状态等\",{\"1\":{\"182\":1}}],[\"检查后\",{\"1\":{\"141\":1}}],[\"处\",{\"1\":{\"834\":6,\"835\":8}}],[\"处的\",{\"1\":{\"816\":3,\"835\":1}}],[\"处返回的是\",{\"1\":{\"803\":1}}],[\"处代码\",{\"1\":{\"790\":1,\"816\":4}}],[\"处于不安全状态未必发生了死锁\",{\"1\":{\"149\":1}}],[\"处理事件\",{\"1\":{\"890\":1}}],[\"处理消息的边界\",{\"0\":{\"890\":1}}],[\"处理key\",{\"1\":{\"886\":1,\"890\":1}}],[\"处理数据\",{\"1\":{\"837\":1}}],[\"处理原则\",{\"1\":{\"825\":2}}],[\"处理的病人总数是\",{\"1\":{\"805\":1}}],[\"处理关闭之后的操作\",{\"1\":{\"804\":3}}],[\"处理定时任务\",{\"0\":{\"801\":1}}],[\"处理普通任务\",{\"0\":{\"800\":1}}],[\"处理字符数据比较合适\",{\"1\":{\"755\":1}}],[\"处理字符串\",{\"1\":{\"336\":1}}],[\"处理完第一个\",{\"1\":{\"909\":2}}],[\"处理完毕\",{\"1\":{\"884\":1}}],[\"处理完成后\",{\"1\":{\"791\":1}}],[\"处理完了\",{\"1\":{\"743\":1}}],[\"处理完调用request再请求一个数据\",{\"1\":{\"743\":1,\"744\":1}}],[\"处理器和最终订阅者建立订阅关系\",{\"1\":{\"744\":1}}],[\"处理器处理完了\",{\"1\":{\"744\":1}}],[\"处理器接收到的数据\",{\"1\":{\"744\":1}}],[\"处理器\",{\"1\":{\"742\":1,\"834\":1,\"835\":1}}],[\"处理器映射器找到具体的处理器\",{\"1\":{\"736\":1}}],[\"处理器完成业务逻辑的处理后\",{\"1\":{\"736\":1}}],[\"处理异常\",{\"1\":{\"790\":3}}],[\"处理异常流程\",{\"1\":{\"644\":1}}],[\"处理异常或视图渲染\",{\"1\":{\"644\":1}}],[\"处理返回值\",{\"1\":{\"644\":1}}],[\"处理流程\",{\"0\":{\"644\":1}}],[\"处理控制器方法返回值\",{\"1\":{\"561\":1}}],[\"处理\",{\"0\":{\"798\":1,\"884\":1,\"886\":1,\"892\":1},\"1\":{\"558\":1,\"642\":1,\"643\":4,\"650\":1,\"743\":1,\"751\":1,\"792\":1,\"793\":1,\"794\":1,\"835\":1,\"909\":2}}],[\"处理并发安全问题\",{\"1\":{\"352\":1}}],[\"处理后续任务\",{\"1\":{\"206\":1}}],[\"处理剩余物品\",{\"1\":{\"195\":1}}],[\"处理一个数据块的平均耗时为max\",{\"1\":{\"186\":1}}],[\"处理一块数据平均耗时max\",{\"1\":{\"186\":1}}],[\"处理机调度的概念\",{\"1\":{\"136\":1}}],[\"处理机的调度\",{\"0\":{\"136\":1}}],[\"处理机管理\",{\"1\":{\"126\":1}}],[\"处理其中可能的异常\",{\"1\":{\"98\":1}}],[\"处理创建对象的细节\",{\"1\":{\"63\":1}}],[\"编解码器\",{\"0\":{\"770\":1}}],[\"编程客户端\",{\"1\":{\"1017\":1}}],[\"编程式事务\",{\"1\":{\"719\":1}}],[\"编程添加\",{\"1\":{\"655\":1,\"657\":1}}],[\"编写条件判断逻辑\",{\"1\":{\"672\":1}}],[\"编写\",{\"1\":{\"647\":1,\"844\":2}}],[\"编写控制器\",{\"1\":{\"647\":1}}],[\"编写程序困难\",{\"1\":{\"145\":1}}],[\"编号从0至15\",{\"1\":{\"1021\":1}}],[\"编号0~15\",{\"1\":{\"1015\":1}}],[\"编号\",{\"1\":{\"527\":6}}],[\"编号相同资源一次申请完\",{\"1\":{\"148\":1}}],[\"编码解决商品查询的缓存穿透问题\",{\"0\":{\"985\":1}}],[\"编码\",{\"1\":{\"173\":1}}],[\"编译阶段\",{\"1\":{\"714\":1}}],[\"编译时会进行预处理用\",{\"1\":{\"366\":1}}],[\"编译器增强能突破代理仅能通过方法重写增强的限制\",{\"1\":{\"506\":1}}],[\"编译器也能修改\",{\"1\":{\"506\":1}}],[\"编译器也会给它分配\",{\"1\":{\"277\":1}}],[\"编译器\",{\"0\":{\"505\":1},\"1\":{\"506\":1}}],[\"编译器在编译\",{\"1\":{\"504\":1}}],[\"编译器就分配多少空间\",{\"1\":{\"277\":1}}],[\"编译器是使用\",{\"1\":{\"277\":1}}],[\"编译器会按照\",{\"1\":{\"277\":1}}],[\"编译和链接之后装入模块的地址都是从0开始\",{\"1\":{\"151\":1}}],[\"编译和链接之后指令中的地址都是从0开始的逻辑地址\",{\"1\":{\"151\":1}}],[\"编译程序产生绝对地址的目标代码\",{\"1\":{\"151\":1}}],[\"首先我们的初始方案是封装了一个createvoucherorder方法\",{\"1\":{\"998\":1}}],[\"首先我们要思考一下利用redis来存储数据\",{\"1\":{\"965\":1}}],[\"首先启动服务器端\",{\"1\":{\"898\":1}}],[\"首先要说明\",{\"1\":{\"806\":1}}],[\"首先编写条件判断类\",{\"1\":{\"672\":1}}],[\"首先看\",{\"1\":{\"604\":1}}],[\"首先看是否有自定义转换器\",{\"1\":{\"576\":1}}],[\"首先根据方法名和参数个数\",{\"1\":{\"527\":1}}],[\"首先他会立刻返回\",{\"1\":{\"409\":1}}],[\"首先会检查该key是否过期\",{\"1\":{\"436\":1}}],[\"首先会从buffer\",{\"1\":{\"396\":1}}],[\"首先会调用cas进行一次抢锁\",{\"1\":{\"258\":1}}],[\"首先计算对象占用空间大小\",{\"1\":{\"352\":1}}],[\"首先去检查这个指令的参数能否在metaspace的常量池中定位到一个类的符号引用\",{\"1\":{\"352\":1}}],[\"首先是一种由心而生的认同感\",{\"1\":{\"304\":1}}],[\"首先遍历大文件\",{\"1\":{\"290\":1}}],[\"首先\",{\"1\":{\"272\":1,\"383\":1,\"728\":1,\"1016\":1}}],[\"首先给系统中的资源编号\",{\"1\":{\"148\":1}}],[\"首次执行\",{\"1\":{\"546\":1,\"790\":1}}],[\"首次适应算法\",{\"1\":{\"155\":1}}],[\"首次创建会同步\",{\"1\":{\"57\":1}}],[\"释放原有\",{\"1\":{\"826\":1}}],[\"释放未处理消息逻辑\",{\"1\":{\"825\":1}}],[\"释放共享锁\",{\"1\":{\"255\":1}}],[\"释放互斥锁\",{\"1\":{\"255\":1,\"988\":1}}],[\"释放锁的时候也需要将state减为0\",{\"1\":{\"252\":1}}],[\"释放锁\",{\"1\":{\"212\":1,\"989\":1,\"990\":2}}],[\"释放已经获得的资源可能造成前一阶段工作的失效\",{\"1\":{\"148\":1}}],[\"释放资源\",{\"1\":{\"144\":1,\"1032\":1}}],[\"破坏\",{\"1\":{\"842\":1}}],[\"破坏循环等待条件\",{\"1\":{\"148\":1}}],[\"破坏请求和保持条件\",{\"1\":{\"148\":1}}],[\"破坏不剥夺条件\",{\"1\":{\"148\":1}}],[\"破坏互斥条件\",{\"1\":{\"148\":1}}],[\"破坏死锁产生的四个必要条件中的一个或几个\",{\"1\":{\"147\":1}}],[\"破坏单例模式\",{\"1\":{\"103\":1}}],[\"链路层对一次能够发送的最大数据有限制\",{\"1\":{\"751\":1}}],[\"链表等等\",{\"1\":{\"424\":1}}],[\"链表不支持随机访问\",{\"1\":{\"322\":1}}],[\"链表\",{\"1\":{\"249\":1}}],[\"链表就会转换为红黑树\",{\"1\":{\"249\":1}}],[\"链接\",{\"1\":{\"352\":1}}],[\"链接方案\",{\"1\":{\"169\":1}}],[\"链接方式\",{\"1\":{\"131\":1}}],[\"链接分配采取离散分配的方式\",{\"1\":{\"169\":1}}],[\"链接分配\",{\"1\":{\"169\":1}}],[\"链接的三种方式\",{\"1\":{\"151\":1}}],[\"链中的每一个进程已获得的资源同时被下一个进程所请求\",{\"1\":{\"147\":1}}],[\"故称为雪花算法\",{\"1\":{\"440\":1}}],[\"故障转移时\",{\"1\":{\"433\":1}}],[\"故障转移\",{\"1\":{\"433\":1}}],[\"故不细加阐述\",{\"1\":{\"366\":1}}],[\"故不建议在开发代码中使用此语句\",{\"1\":{\"267\":1}}],[\"故这种策略主要用于进程首次调入\",{\"1\":{\"164\":1}}],[\"故意设计的死循环除外\",{\"1\":{\"147\":1}}],[\"故读进程最多只能有一个\",{\"1\":{\"134\":1}}],[\"异常关闭时\",{\"1\":{\"883\":1}}],[\"异常值\",{\"1\":{\"783\":1}}],[\"异常是\",{\"1\":{\"762\":1}}],[\"异常报告\",{\"1\":{\"728\":1}}],[\"异常信息由于会被\",{\"1\":{\"617\":1}}],[\"异常处理原则\",{\"1\":{\"825\":1}}],[\"异常处理等辅助操作\",{\"1\":{\"728\":1}}],[\"异常处理\",{\"0\":{\"617\":1},\"1\":{\"644\":1}}],[\"异常解析器\",{\"0\":{\"609\":1}}],[\"异常\",{\"1\":{\"406\":1,\"688\":2,\"775\":1,\"815\":1,\"826\":1}}],[\"异如上\",{\"1\":{\"147\":1}}],[\"异步的构建缓存\",{\"1\":{\"987\":1}}],[\"异步模型需要底层操作系统\",{\"1\":{\"906\":1}}],[\"异步意味着\",{\"1\":{\"906\":1}}],[\"异步阻塞\",{\"1\":{\"901\":1}}],[\"异步处理任务失败\",{\"1\":{\"814\":1}}],[\"异步处理任务成功\",{\"1\":{\"811\":1}}],[\"异步处理关闭\",{\"1\":{\"804\":1}}],[\"异步接收结果\",{\"1\":{\"806\":1,\"811\":1}}],[\"异步并没有缩短响应时间\",{\"1\":{\"805\":1}}],[\"异步方式用了多线程\",{\"1\":{\"805\":1}}],[\"异步方式处理关闭\",{\"1\":{\"804\":1}}],[\"异步提升的是什么💡\",{\"0\":{\"805\":1}}],[\"异步非阻塞\",{\"1\":{\"803\":1,\"901\":1}}],[\"异步执行\",{\"1\":{\"790\":1}}],[\"异步io的实现会负责把数据从内核空间拷贝到用户空间\",{\"1\":{\"410\":1}}],[\"异步io\",{\"1\":{\"409\":1}}],[\"异步i\",{\"1\":{\"409\":2}}],[\"异步性\",{\"1\":{\"131\":1}}],[\"异步\",{\"1\":{\"127\":2,\"901\":2}}],[\"死循环的异同\",{\"1\":{\"147\":1}}],[\"死循环的概念\",{\"1\":{\"147\":1}}],[\"死锁检查抛出的\",{\"1\":{\"815\":1}}],[\"死锁检查\",{\"1\":{\"815\":1}}],[\"死锁是指两个或两个以上的事务在执行过程中\",{\"1\":{\"403\":1}}],[\"死锁是因为线程互相持有对象想要的锁\",{\"1\":{\"222\":1}}],[\"死锁与活锁的区别\",{\"1\":{\"222\":1}}],[\"死锁的检测和解除\",{\"1\":{\"147\":1}}],[\"死锁的处理策略\",{\"0\":{\"148\":1,\"149\":1,\"150\":1},\"1\":{\"147\":1}}],[\"死锁的概念\",{\"0\":{\"147\":1}}],[\"死锁结束\",{\"1\":{\"147\":1}}],[\"死锁产生的条件\",{\"1\":{\"147\":1}}],[\"死锁\",{\"0\":{\"220\":1,\"221\":1},\"1\":{\"147\":1}}],[\"什么情况下触发垃圾回收\",{\"1\":{\"355\":1}}],[\"什么是缓存\",{\"0\":{\"974\":1},\"1\":{\"974\":1}}],[\"什么是mvc\",{\"0\":{\"734\":1}}],[\"什么是布隆过滤器\",{\"0\":{\"272\":1}}],[\"什么是内存\",{\"1\":{\"151\":1}}],[\"什么是安全序列\",{\"1\":{\"149\":1}}],[\"什么是死锁\",{\"1\":{\"147\":1}}],[\"什么时候可以加\",{\"0\":{\"771\":1}}],[\"什么时候用单例什么时候用多例\",{\"1\":{\"740\":1}}],[\"什么时候会从用户态切换到内核态\",{\"1\":{\"406\":1}}],[\"什么时候会发生死锁\",{\"1\":{\"147\":1}}],[\"什么时候应该交换\",{\"1\":{\"153\":1}}],[\"什么时候调整\",{\"1\":{\"139\":1}}],[\"函数时\",{\"1\":{\"776\":1}}],[\"函数返回\",{\"1\":{\"410\":1}}],[\"函数式接口\",{\"1\":{\"643\":1}}],[\"函数式\",{\"1\":{\"643\":1}}],[\"函数式sql\",{\"0\":{\"371\":1}}],[\"函数式编程接口\",{\"1\":{\"232\":4}}],[\"函数型接口\",{\"1\":{\"336\":1}}],[\"函数来说\",{\"1\":{\"276\":1}}],[\"函数类似\",{\"1\":{\"276\":1}}],[\"函数和\",{\"1\":{\"276\":1}}],[\"函数假定程序员在执行这个函数时\",{\"1\":{\"276\":1}}],[\"函数是可以将两个字符串拼接在一起\",{\"1\":{\"276\":1}}],[\"函数的执行流程\",{\"1\":{\"276\":1}}],[\"函数\",{\"1\":{\"145\":1,\"277\":1,\"395\":1}}],[\"易出错\",{\"1\":{\"145\":1}}],[\"易于维护和升级\",{\"1\":{\"107\":1}}],[\"初步代码\",{\"1\":{\"998\":1}}],[\"初步了解\",{\"1\":{\"568\":1}}],[\"初识文件管理\",{\"0\":{\"166\":1}}],[\"初始redis\",{\"0\":{\"1002\":1}}],[\"初始方案思路总结\",{\"0\":{\"970\":1}}],[\"初始容量是\",{\"1\":{\"818\":1,\"823\":1}}],[\"初始时间戳\",{\"1\":{\"441\":1}}],[\"初始时为1\",{\"1\":{\"244\":1}}],[\"初始时为1时的区别\",{\"1\":{\"244\":1}}],[\"初始主键值为1\",{\"1\":{\"439\":1}}],[\"初始状态\",{\"1\":{\"208\":1}}],[\"初始值为0\",{\"1\":{\"144\":1}}],[\"初始化之前执行\",{\"1\":{\"711\":1}}],[\"初始化之前执行的方法\",{\"1\":{\"711\":1}}],[\"初始化之后执行\",{\"1\":{\"711\":1}}],[\"初始化之后执行的方法\",{\"1\":{\"711\":1}}],[\"初始化之后\",{\"1\":{\"542\":1}}],[\"初始化器的\",{\"1\":{\"790\":1}}],[\"初始化器的职责是将\",{\"1\":{\"790\":1}}],[\"初始化器是一次性的\",{\"1\":{\"790\":1}}],[\"初始化器增强\",{\"1\":{\"652\":1}}],[\"初始化器\",{\"1\":{\"650\":1,\"790\":1,\"793\":1}}],[\"初始化前用它增强\",{\"1\":{\"619\":1}}],[\"初始化前后的增强\",{\"1\":{\"460\":1}}],[\"初始化时准备参数解析器\",{\"1\":{\"644\":2}}],[\"初始化时记录映射关系\",{\"1\":{\"644\":1}}],[\"初始化时会优先到容器里寻找各种组件\",{\"1\":{\"644\":1}}],[\"初始化时会解析\",{\"1\":{\"588\":1,\"596\":1,\"616\":1}}],[\"初始化时\",{\"1\":{\"561\":2}}],[\"初始化销毁顺序\",{\"0\":{\"493\":1}}],[\"初始化销毁方法是什么\",{\"1\":{\"454\":1}}],[\"初始化与销毁\",{\"0\":{\"492\":1}}],[\"初始化零值\",{\"1\":{\"352\":1}}],[\"初始化成员变量\",{\"1\":{\"352\":1}}],[\"初始化才正式开始\",{\"1\":{\"352\":1}}],[\"初始化分配到的空间\",{\"1\":{\"352\":1}}],[\"初始化容量\",{\"1\":{\"328\":1}}],[\"初始化一个100个节点的小顶堆\",{\"1\":{\"291\":1}}],[\"初始化一个小顶堆\",{\"1\":{\"291\":1}}],[\"初始化table使用了cas\",{\"1\":{\"249\":1}}],[\"初始化程序\",{\"1\":{\"178\":1}}],[\"初始化\",{\"0\":{\"559\":1},\"1\":{\"143\":1,\"287\":1,\"352\":1,\"458\":1,\"463\":1,\"470\":1,\"491\":1,\"644\":1,\"787\":1,\"790\":1}}],[\"初始化pcb\",{\"1\":{\"132\":1}}],[\"初值为1\",{\"1\":{\"144\":1}}],[\"四次挥手\",{\"1\":{\"198\":1}}],[\"四种软件实现方式\",{\"1\":{\"142\":1}}],[\"四个特征\",{\"1\":{\"127\":1}}],[\"相较于原来从缓存中查询不到数据后直接查询数据库而言\",{\"1\":{\"988\":1}}],[\"相关方法都会不会让线程暂停\",{\"1\":{\"877\":1}}],[\"相关方法都会导致线程暂停\",{\"1\":{\"876\":1}}],[\"相关的\",{\"1\":{\"830\":1}}],[\"相关配置\",{\"1\":{\"659\":1,\"783\":1}}],[\"相应地将内存的物理地址空间分成若干个块\",{\"1\":{\"413\":1}}],[\"相应地\",{\"1\":{\"413\":1}}],[\"相应就大大提高了执行速度\",{\"1\":{\"318\":1}}],[\"相当于\",{\"1\":{\"1025\":1}}],[\"相当于减\",{\"1\":{\"1025\":1}}],[\"相当于是数据表的字段\",{\"1\":{\"925\":1}}],[\"相当于外表循环\",{\"1\":{\"386\":1}}],[\"相当于字符串拼接\",{\"1\":{\"366\":1}}],[\"相当于占位符\",{\"1\":{\"366\":1}}],[\"相当于有\",{\"1\":{\"277\":1}}],[\"相当于宾馆的房间\",{\"1\":{\"151\":1}}],[\"相对路径\",{\"1\":{\"871\":1}}],[\"相对于整体偏移量等信息\",{\"1\":{\"829\":1}}],[\"相对于select和poll而言\",{\"1\":{\"410\":1}}],[\"相对于应用程序的执行\",{\"1\":{\"359\":1}}],[\"相对还算比较容易\",{\"1\":{\"336\":1}}],[\"相对来说io读写次数也就降低了\",{\"1\":{\"378\":1}}],[\"相对来说\",{\"1\":{\"258\":1,\"707\":1}}],[\"相对耗时的任务\",{\"1\":{\"244\":1}}],[\"相对地址\",{\"1\":{\"151\":2}}],[\"相比于我们平时常用的的\",{\"1\":{\"272\":1}}],[\"相比于对segment加锁\",{\"1\":{\"249\":1}}],[\"相比于隐式链接来说\",{\"1\":{\"169\":1}}],[\"相比软件实现方法\",{\"1\":{\"142\":1}}],[\"相同的构建器\",{\"1\":{\"47\":1}}],[\"相同的装配\",{\"1\":{\"47\":1}}],[\"利用set的命令实现下列功能\",{\"1\":{\"1029\":1}}],[\"利用redis\",{\"1\":{\"1015\":1}}],[\"利用redis集群提高服务的可用性\",{\"1\":{\"986\":1}}],[\"利用cas进行无锁化机制加锁\",{\"1\":{\"996\":1}}],[\"利用缓存空值的方式解决缓存穿透问题\",{\"1\":{\"990\":2}}],[\"利用单元测试进行缓存预热\",{\"1\":{\"989\":1}}],[\"利用逻辑过期解决缓存击穿问题\",{\"0\":{\"989\":1}}],[\"利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑\",{\"1\":{\"988\":1}}],[\"利用互斥锁解决缓存击穿问题\",{\"0\":{\"988\":1}}],[\"利用tcc等分布式事务方案\",{\"1\":{\"982\":1}}],[\"利用集群支撑起整个项目\",{\"1\":{\"955\":1}}],[\"利用多线程优化💡\",{\"0\":{\"896\":1}}],[\"利用其它们实现转换\",{\"1\":{\"574\":1}}],[\"利用局部性原理实现高速缓存\",{\"1\":{\"417\":1}}],[\"利用mmap\",{\"1\":{\"410\":1}}],[\"利用数据库唯一索引特性\",{\"1\":{\"315\":1}}],[\"利用基于k\",{\"1\":{\"300\":1}}],[\"利用延迟关联或者子查询优化超多分页场景\",{\"1\":{\"266\":1}}],[\"利用覆盖索引来进行查询操作\",{\"1\":{\"266\":1}}],[\"利用率\",{\"1\":{\"246\":1}}],[\"利用\",{\"1\":{\"142\":1}}],[\"遵循了空闲让进\",{\"1\":{\"141\":1}}],[\"遵循里氏替换原则\",{\"1\":{\"108\":1}}],[\"数值\",{\"1\":{\"1001\":1}}],[\"数量级增长会非常快\",{\"1\":{\"383\":1}}],[\"数组\",{\"1\":{\"332\":1,\"417\":1,\"829\":1}}],[\"数组支持随机访问\",{\"1\":{\"322\":1}}],[\"数组和链表在插入删除方面的区别\",{\"1\":{\"322\":1}}],[\"数组转换为二叉树\",{\"1\":{\"283\":1}}],[\"数组中的各个元素用来标志各进程想进入临界区的意愿\",{\"1\":{\"141\":1}}],[\"数字集很大\",{\"1\":{\"274\":1}}],[\"数千万岁\",{\"1\":{\"265\":1}}],[\"数百岁\",{\"1\":{\"265\":1}}],[\"数据序列化器\",{\"0\":{\"1041\":1}}],[\"数据量过大之后\",{\"1\":{\"992\":1}}],[\"数据量小的表\",{\"1\":{\"384\":1}}],[\"数据拷贝了\",{\"1\":{\"905\":2}}],[\"数据拷贝了共\",{\"1\":{\"904\":1}}],[\"数据从内核缓冲区传输到\",{\"1\":{\"905\":1}}],[\"数据包大小一样\",{\"1\":{\"890\":1}}],[\"数据包的大小不好把握\",{\"1\":{\"754\":1}}],[\"数据暂不能写出的情况\",{\"1\":{\"881\":1}}],[\"数据暂不能读入的情况\",{\"1\":{\"881\":1}}],[\"数据可写出时触发\",{\"1\":{\"881\":1}}],[\"数据可读入时触发\",{\"1\":{\"881\":1}}],[\"数据可以安全使用\",{\"1\":{\"260\":1}}],[\"数据复制过程中\",{\"1\":{\"877\":1}}],[\"数据之间使用\",{\"1\":{\"859\":1}}],[\"数据经过网络传输\",{\"1\":{\"835\":1}}],[\"数据写完之后再取消关注\",{\"1\":{\"894\":1}}],[\"数据写出\",{\"1\":{\"816\":1}}],[\"数据写入的时候时什么样的\",{\"1\":{\"277\":1}}],[\"数据读取\",{\"1\":{\"816\":1}}],[\"数据读取到了一个它稍微处理的缓冲区\",{\"1\":{\"332\":1}}],[\"数据绑定工厂\",{\"0\":{\"580\":1}}],[\"数据先写入主节点\",{\"1\":{\"434\":1}}],[\"数据也一般是以向量\",{\"1\":{\"417\":1}}],[\"数据或代码页会根据需要在物理内存与磁盘之间移动\",{\"1\":{\"415\":1}}],[\"数据会先被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"409\":1}}],[\"数据会被拷贝到操作系统内核的缓冲区中\",{\"1\":{\"408\":1}}],[\"数据在传输过程中需要在应用程序地址空间和内核之间进行多次数据拷贝操作\",{\"1\":{\"408\":1}}],[\"数据是存放在磁盘中的\",{\"1\":{\"396\":1}}],[\"数据无序\",{\"1\":{\"392\":1}}],[\"数据相似性大的就不适合建立索引\",{\"1\":{\"383\":1}}],[\"数据文件为了维持b+树的特性而频繁的分裂调整\",{\"1\":{\"380\":1}}],[\"数据又是递增的\",{\"1\":{\"378\":1}}],[\"数据页\",{\"1\":{\"376\":1}}],[\"数据总是从通道读取到缓冲区中\",{\"1\":{\"334\":1}}],[\"数据结构\",{\"0\":{\"269\":1},\"1\":{\"275\":1,\"278\":1}}],[\"数据订正\",{\"1\":{\"267\":1}}],[\"数据类型的底层数据结构是\",{\"1\":{\"275\":1}}],[\"数据类型必须绝对一致\",{\"1\":{\"266\":1}}],[\"数据类型是unsigned\",{\"1\":{\"265\":1}}],[\"数据库数量\",{\"1\":{\"1015\":1}}],[\"数据库中的version变成了2\",{\"1\":{\"996\":1}}],[\"数据库存在\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"990\":1}}],[\"数据库不存在返回错误\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"990\":1}}],[\"数据库和缓存不一致采用什么方案\",{\"0\":{\"982\":1}}],[\"数据库与缓存的问题交由系统本身去处理\",{\"1\":{\"981\":1}}],[\"数据库缓存不一致解决方案\",{\"0\":{\"981\":1}}],[\"数据库缓存\",{\"1\":{\"976\":1}}],[\"数据库\",{\"1\":{\"841\":1,\"1003\":1}}],[\"数据库引擎不支持事务\",{\"1\":{\"723\":1}}],[\"数据库死锁问题以及解决办法\",{\"0\":{\"403\":1}}],[\"数据库会自动给更大一级的空间\",{\"1\":{\"400\":1}}],[\"数据库也能将数据恢复\",{\"1\":{\"396\":1}}],[\"数据库的完整性约束没有被破坏\",{\"1\":{\"396\":1}}],[\"数据库状态应该退回到执行事务前的状态\",{\"1\":{\"396\":1}}],[\"数据库索引失效了怎么办\",{\"0\":{\"395\":1}}],[\"数据库索引是存储在磁盘上的\",{\"1\":{\"376\":1}}],[\"数据库去重表\",{\"1\":{\"315\":1}}],[\"数据库名\",{\"1\":{\"265\":1}}],[\"数据库字段名的修改代价很大\",{\"1\":{\"265\":1}}],[\"数据库开发规范\",{\"0\":{\"264\":1}}],[\"数据缓冲区管理\",{\"1\":{\"182\":1}}],[\"数据传输效率进一步增加\",{\"1\":{\"181\":1}}],[\"数据传输以\",{\"1\":{\"181\":1}}],[\"数据传送单位\",{\"1\":{\"181\":1}}],[\"数据传送的单位\",{\"1\":{\"181\":2}}],[\"数据输出\",{\"1\":{\"181\":3}}],[\"数据输入\",{\"1\":{\"181\":3}}],[\"数据的读取和写入是通过buffer\",{\"1\":{\"332\":1}}],[\"数据的传输不再需要先经过cpu再写入内存\",{\"1\":{\"181\":1}}],[\"数据的流向\",{\"1\":{\"181\":3}}],[\"数据的形式\",{\"1\":{\"134\":1}}],[\"数据寄存器\",{\"1\":{\"180\":1}}],[\"数据一旦被读出\",{\"1\":{\"134\":1}}],[\"数据以字符流的形式写入管道\",{\"1\":{\"134\":1}}],[\"数据段等等\",{\"1\":{\"413\":1}}],[\"数据段d和栈段s等\",{\"1\":{\"413\":1}}],[\"数据段组成\",{\"1\":{\"131\":1}}],[\"数据段\",{\"1\":{\"131\":1}}],[\"数据\",{\"1\":{\"109\":1,\"890\":1}}],[\"试着一个boolean类型的数组flag\",{\"1\":{\"141\":1}}],[\"忙等\",{\"1\":{\"181\":1}}],[\"忙则等待\",{\"1\":{\"140\":1,\"141\":1}}],[\"忙碌\",{\"1\":{\"138\":1}}],[\"剩余区\",{\"1\":{\"140\":1}}],[\"新华字典前面的目录就是索引的意思\",{\"1\":{\"922\":1}}],[\"新建一个单元测试类\",{\"1\":{\"1032\":1}}],[\"新建一个系统服务文件\",{\"1\":{\"1016\":1}}],[\"新建一个实体类\",{\"1\":{\"989\":1}}],[\"新建\",{\"1\":{\"647\":1}}],[\"新建countercells\",{\"1\":{\"249\":1}}],[\"新\",{\"1\":{\"451\":3}}],[\"新学一种代码之间解耦途径\",{\"1\":{\"449\":1}}],[\"新写入操作会报错\",{\"1\":{\"429\":1}}],[\"新生代收集器\",{\"1\":{\"360\":1}}],[\"新生代收集\",{\"1\":{\"350\":1}}],[\"新生代\",{\"1\":{\"350\":1}}],[\"新增秒杀卷代码\",{\"1\":{\"994\":1}}],[\"新增普通卷代码\",{\"1\":{\"994\":1}}],[\"新增此方法\",{\"1\":{\"989\":1}}],[\"新增文档\",{\"1\":{\"934\":1,\"950\":1}}],[\"新增设计了两种数据结构\",{\"1\":{\"281\":1}}],[\"新增或修改某个元素时\",{\"1\":{\"278\":1}}],[\"新增node\",{\"1\":{\"249\":1}}],[\"新的数据被旧数据覆盖了\",{\"1\":{\"982\":1}}],[\"新的\",{\"1\":{\"249\":1}}],[\"新进程到达时先进入第一级队列\",{\"1\":{\"139\":1}}],[\"新对象可以动态地引用与成分对象类型相同的对象\",{\"1\":{\"112\":1}}],[\"新对象可以调用已有对象的功能\",{\"1\":{\"112\":1}}],[\"新对象的属性和原来对象完全相同\",{\"1\":{\"86\":1}}],[\"或64g内存\",{\"1\":{\"955\":1}}],[\"或多次\",{\"1\":{\"928\":1}}],[\"或多或少都会感到压力把\",{\"1\":{\"309\":1}}],[\"或失败\",{\"1\":{\"806\":1}}],[\"或成功\",{\"1\":{\"806\":1}}],[\"或其子接口\",{\"1\":{\"695\":1}}],[\"或其它一些手段\",{\"1\":{\"458\":1}}],[\"或其它原因导致暂停时\",{\"1\":{\"246\":1}}],[\"或是超时\",{\"1\":{\"882\":1}}],[\"或是去执行\",{\"1\":{\"877\":1}}],[\"或是由非\",{\"1\":{\"792\":1}}],[\"或是在引导类加了\",{\"1\":{\"662\":1}}],[\"或是元素变大了\",{\"1\":{\"281\":1}}],[\"或\",{\"1\":{\"383\":1,\"413\":1,\"527\":1,\"648\":1,\"688\":1,\"695\":1,\"755\":1,\"764\":2,\"771\":1,\"773\":2,\"790\":1,\"847\":1,\"901\":1}}],[\"或bigint\",{\"1\":{\"377\":1}}],[\"或count\",{\"1\":{\"267\":1}}],[\"或每次写出一块\",{\"1\":{\"169\":1}}],[\"或颠簸\",{\"1\":{\"164\":1}}],[\"或最近未使用算法\",{\"1\":{\"163\":1}}],[\"或者不能严格保证acid的特性\",{\"1\":{\"1007\":1}}],[\"或者把他叫为淘汰更合适\",{\"1\":{\"980\":1}}],[\"或者由于任何原因消失了\",{\"1\":{\"928\":1}}],[\"或者单个节点处理搜索请求\",{\"1\":{\"927\":1}}],[\"或者调用\",{\"1\":{\"816\":1,\"853\":1}}],[\"或者有任务\",{\"1\":{\"792\":1}}],[\"或者已经达到目标\",{\"1\":{\"743\":1,\"744\":1}}],[\"或者是no\",{\"1\":{\"1003\":1}}],[\"或者是false\",{\"1\":{\"988\":1}}],[\"或者是使用redis作为缓存\",{\"1\":{\"976\":1}}],[\"或者是使用哈希\",{\"1\":{\"965\":1}}],[\"或者是其他可区别标识的10位比特位的整数值都行\",{\"1\":{\"440\":1}}],[\"或者是在最长时间内不再被访问的页面\",{\"1\":{\"420\":1}}],[\"或者超时\",{\"1\":{\"410\":1}}],[\"或者使用\",{\"1\":{\"383\":1}}],[\"或者runtime\",{\"1\":{\"357\":1}}],[\"或者从缓冲区写入到通道中\",{\"1\":{\"334\":1}}],[\"或者一个线程对集合进行删除时也可能会产生\",{\"1\":{\"324\":1}}],[\"或者元素值不大的情况才会使用压缩列表作为底层数据结构\",{\"1\":{\"278\":1}}],[\"或者\",{\"1\":{\"272\":1,\"531\":1,\"863\":1,\"866\":1}}],[\"或者说连接后无事可做\",{\"1\":{\"331\":1}}],[\"或者说位数组\",{\"1\":{\"272\":1}}],[\"或者说某些步骤的实现与具体的环境相关\",{\"1\":{\"118\":1}}],[\"或者要将数据分别写到不同内存区域时\",{\"1\":{\"181\":1}}],[\"或者在最长时间内不再被访问的页面\",{\"1\":{\"163\":1}}],[\"或页面\",{\"1\":{\"156\":1}}],[\"或称顶级页表\",{\"1\":{\"158\":1}}],[\"或称外层页表\",{\"1\":{\"158\":1}}],[\"或称为页帧\",{\"1\":{\"156\":1}}],[\"或称i\",{\"1\":{\"139\":1}}],[\"或终止进程法\",{\"1\":{\"150\":1}}],[\"或简称xchg指令\",{\"1\":{\"142\":1}}],[\"若是错误的配置了以下三种事务传播行为\",{\"1\":{\"720\":1}}],[\"若要支持\",{\"1\":{\"649\":1}}],[\"若想获取更多用法\",{\"1\":{\"646\":1}}],[\"若其所要访问的页面不在内存\",{\"1\":{\"420\":1}}],[\"若其中有与此相匹配地页号\",{\"1\":{\"413\":1}}],[\"若这个途中存在回路\",{\"1\":{\"403\":1}}],[\"若无外力作用\",{\"1\":{\"403\":1}}],[\"若无外力干涉\",{\"1\":{\"147\":1}}],[\"若将时间高低位互换\",{\"1\":{\"392\":1}}],[\"若流中元素不足n个\",{\"1\":{\"338\":1}}],[\"若存在\",{\"1\":{\"290\":1}}],[\"若实在避免不了\",{\"1\":{\"267\":1}}],[\"若count为0应直接返回\",{\"1\":{\"267\":1}}],[\"若之前的counter值为0\",{\"1\":{\"219\":1}}],[\"若进程请求的物理设备正在忙碌\",{\"1\":{\"185\":1}}],[\"若进程未能在时间片内运行完\",{\"1\":{\"139\":1}}],[\"若进程未在一个时间片内执行完毕\",{\"1\":{\"139\":1}}],[\"若换了一个物理设备\",{\"1\":{\"185\":1}}],[\"若通道忙碌则将进程pcb挂到通道等待队列中\",{\"1\":{\"185\":1}}],[\"若控制器忙碌则将进程pcb挂到控制器等待队列中\",{\"1\":{\"185\":1}}],[\"若设备忙碌则将进程pcb挂到设备等待队列中\",{\"1\":{\"185\":1}}],[\"若每个磁盘块1kb\",{\"1\":{\"169\":1}}],[\"若第三轮扫描失败\",{\"1\":{\"163\":1}}],[\"若第二轮扫描失败\",{\"1\":{\"163\":1}}],[\"若第一轮扫描失败\",{\"1\":{\"163\":1}}],[\"若第一轮扫描所有页面都是1\",{\"1\":{\"163\":1}}],[\"若还有可用的空闲内存块\",{\"1\":{\"163\":1}}],[\"若该页面在内存期间被修改过\",{\"1\":{\"162\":1}}],[\"若内存空间不够\",{\"1\":{\"161\":1,\"162\":1}}],[\"若更上级的队列中进入了一个新进程\",{\"1\":{\"139\":1}}],[\"若用完时间片进程还没有结束\",{\"1\":{\"139\":1}}],[\"若源源不断的有高优先级进程到来\",{\"1\":{\"139\":1}}],[\"抢购时间\",{\"1\":{\"994\":1}}],[\"抢占式算法\",{\"1\":{\"139\":1}}],[\"抢占式和非抢占式都有\",{\"1\":{\"139\":1}}],[\"抢到锁之后再次判断是否为空\",{\"1\":{\"101\":1}}],[\"抢到锁之后再次判断是否为null\",{\"1\":{\"101\":1}}],[\"否则不执行\",{\"1\":{\"1025\":1,\"1027\":1}}],[\"否则不放\",{\"1\":{\"291\":1}}],[\"否则进行下单\",{\"1\":{\"998\":1}}],[\"否则进程运行过程中将频繁缺页\",{\"1\":{\"164\":1}}],[\"否则下次处理就会有问题\",{\"1\":{\"886\":1,\"890\":1}}],[\"否则下次该事件仍会触发\",{\"1\":{\"885\":1}}],[\"否则返回组对象\",{\"1\":{\"758\":3}}],[\"否则返回\",{\"1\":{\"758\":2}}],[\"否则向下走\",{\"1\":{\"688\":4}}],[\"否则\",{\"1\":{\"682\":1,\"799\":1,\"815\":1,\"829\":1}}],[\"否则就是版本冲突\",{\"1\":{\"397\":1}}],[\"否则级联部分sql语句也会执行\",{\"1\":{\"366\":1}}],[\"否则说明该文件输入流中没有数据了\",{\"1\":{\"291\":1}}],[\"否则查询效率就会降低\",{\"1\":{\"278\":1}}],[\"否则最先被程序读入的\",{\"1\":{\"276\":1}}],[\"否则会抛异常\",{\"1\":{\"872\":1}}],[\"否则会抛notserializableexception异常\",{\"1\":{\"89\":1}}],[\"否则会导致持久化文件过大\",{\"1\":{\"433\":1}}],[\"否则会产生过大的内部碎片\",{\"1\":{\"156\":1}}],[\"否\",{\"1\":{\"139\":1}}],[\"随机生成token\",{\"1\":{\"968\":1}}],[\"随着类的加载而加载\",{\"1\":{\"1034\":1}}],[\"随着我们商城规模越来越大\",{\"1\":{\"992\":1}}],[\"随着分时操作系统的出现\",{\"1\":{\"139\":1}}],[\"随着等待时间越来越长\",{\"1\":{\"139\":1}}],[\"随身物品\",{\"1\":{\"33\":1}}],[\"响应状态\",{\"1\":{\"933\":3}}],[\"响应太慢\",{\"1\":{\"927\":1}}],[\"响应文件读取成功的是另一个线程\",{\"1\":{\"907\":1}}],[\"响应消息处理器\",{\"1\":{\"783\":1}}],[\"响应消息\",{\"1\":{\"783\":1}}],[\"响应式流\",{\"0\":{\"741\":1}}],[\"响应结果\",{\"1\":{\"622\":1}}],[\"响应快\",{\"1\":{\"139\":1}}],[\"响应比\",{\"1\":{\"139\":1}}],[\"响应时间\",{\"1\":{\"138\":1}}],[\"饥饿的概念\",{\"1\":{\"147\":1}}],[\"饥饿\",{\"0\":{\"220\":1,\"223\":1},\"1\":{\"139\":1,\"147\":1}}],[\"短信验证码登录\",{\"1\":{\"959\":1}}],[\"短信登录\",{\"0\":{\"952\":1}}],[\"短链接\",{\"0\":{\"753\":1},\"1\":{\"752\":1}}],[\"短任务优先\",{\"1\":{\"185\":1}}],[\"短进程优先\",{\"1\":{\"139\":1}}],[\"短作业优先算法\",{\"1\":{\"139\":1}}],[\"排他锁\",{\"1\":{\"398\":1,\"400\":1}}],[\"排序\",{\"0\":{\"188\":1,\"340\":1}}],[\"排在长作业\",{\"1\":{\"139\":1}}],[\"排队和对银行工作人员进行评分的业务对每个客户是一样的\",{\"1\":{\"118\":1}}],[\"排队\",{\"1\":{\"118\":1}}],[\"排队等一系列的操作\",{\"1\":{\"93\":1}}],[\"公网网络不稳定\",{\"1\":{\"764\":1}}],[\"公共范围\",{\"1\":{\"582\":1}}],[\"公司在其内部用于分布式环境下生成唯一\",{\"1\":{\"440\":1}}],[\"公司也没有人带\",{\"1\":{\"311\":1}}],[\"公平锁和非公平锁就这两点区别\",{\"1\":{\"258\":1}}],[\"公平的\",{\"1\":{\"139\":1}}],[\"公平\",{\"1\":{\"139\":2}}],[\"公交车\",{\"1\":{\"33\":1}}],[\"先请求redis\",{\"1\":{\"984\":1}}],[\"先修改数据库\",{\"1\":{\"983\":1}}],[\"先操作数据库\",{\"1\":{\"982\":1}}],[\"先操作缓存还是先操作数据库\",{\"1\":{\"982\":1}}],[\"先删除缓存\",{\"1\":{\"982\":1}}],[\"先后被触发\",{\"1\":{\"835\":1}}],[\"先写入\",{\"1\":{\"822\":1}}],[\"先写入长度\",{\"1\":{\"756\":1}}],[\"先搞清楚顺序\",{\"1\":{\"816\":1}}],[\"先经过一道道入站工序\",{\"1\":{\"816\":1}}],[\"先来看看\",{\"1\":{\"907\":1}}],[\"先来看可接入事件处理\",{\"1\":{\"793\":1}}],[\"先来先服务\",{\"1\":{\"185\":1}}],[\"先来先服务算法\",{\"1\":{\"139\":1,\"176\":1}}],[\"先约定用定长字节表示接下来数据的长度\",{\"1\":{\"756\":1}}],[\"先解析\",{\"1\":{\"688\":1}}],[\"先通过\",{\"1\":{\"617\":1}}],[\"先通过user\",{\"1\":{\"366\":1}}],[\"先通过两次cas操作去争抢锁\",{\"1\":{\"258\":1}}],[\"先会去创造一个新的长度的数组\",{\"1\":{\"323\":1}}],[\"先查后插\",{\"1\":{\"266\":1}}],[\"先快速定位需要获取的id段\",{\"1\":{\"266\":1}}],[\"先预处理第一件物品\",{\"1\":{\"195\":1}}],[\"先处理\",{\"1\":{\"194\":1}}],[\"先创建一个新的空文件夹\",{\"1\":{\"166\":1}}],[\"先为进程分配一定数目的物理块\",{\"1\":{\"164\":1}}],[\"先进先出页面置换算法\",{\"1\":{\"420\":1}}],[\"先进先出置换算法\",{\"1\":{\"163\":2}}],[\"先进入的页面在之后也有可能经常的访问到\",{\"1\":{\"163\":1}}],[\"先用大的\",{\"1\":{\"155\":1}}],[\"先用小的\",{\"1\":{\"155\":1}}],[\"先上锁后检查\",{\"1\":{\"141\":1}}],[\"先说说jdk提供的动态代理\",{\"1\":{\"94\":1}}],[\"周转时间包括四个部分\",{\"1\":{\"138\":1}}],[\"周转时间\",{\"1\":{\"138\":3}}],[\"非关系型数据库可以将数据拆分\",{\"1\":{\"1008\":1}}],[\"非关系型数据库\",{\"1\":{\"1008\":1}}],[\"非sql的\",{\"1\":{\"1003\":1}}],[\"非池化\",{\"0\":{\"820\":1}}],[\"非要用这么复杂的异步方式\",{\"1\":{\"805\":1}}],[\"非\",{\"1\":{\"791\":1,\"798\":1,\"820\":1}}],[\"非常不经济\",{\"1\":{\"751\":1}}],[\"非静态方法\",{\"1\":{\"721\":1}}],[\"非延迟\",{\"1\":{\"688\":1}}],[\"非内嵌数据库连接池\",{\"1\":{\"660\":1}}],[\"非连续分配管理方式允许一个程序员使用的内存分布在离散或者说不相邻的内存中\",{\"1\":{\"413\":1}}],[\"非阻塞模式\",{\"1\":{\"877\":2}}],[\"非阻塞模式下\",{\"1\":{\"877\":1,\"893\":1}}],[\"非阻塞\",{\"0\":{\"875\":1,\"877\":1},\"1\":{\"806\":2,\"877\":2,\"900\":1,\"901\":1}}],[\"非阻塞io\",{\"1\":{\"409\":1}}],[\"非阻塞i\",{\"1\":{\"409\":2}}],[\"非阻塞写入同理\",{\"1\":{\"332\":1}}],[\"非单调的主键会造成在插入新纪录时\",{\"1\":{\"380\":1}}],[\"非公平锁\",{\"1\":{\"996\":1}}],[\"非公平锁让获得锁的时间变得更加不确定\",{\"1\":{\"258\":1}}],[\"非公平锁会有更好的性能\",{\"1\":{\"258\":1}}],[\"非公平锁会直接cas抢锁\",{\"1\":{\"258\":1}}],[\"非公平锁在cas失败后\",{\"1\":{\"258\":1}}],[\"非公平锁在调用lock方法后\",{\"1\":{\"258\":1}}],[\"非抢占式算法\",{\"1\":{\"139\":2}}],[\"非剥夺调度方式\",{\"1\":{\"137\":1}}],[\"非特权指令\",{\"1\":{\"128\":1}}],[\"被进行了重新组合\",{\"1\":{\"859\":1}}],[\"被固定为这个区间的大小\",{\"1\":{\"826\":1}}],[\"被引用了多少次\",{\"1\":{\"825\":1}}],[\"被连成一串\",{\"1\":{\"816\":1}}],[\"被这些注解声明的类当被扫描到时就会创建对应的bean\",{\"1\":{\"709\":1}}],[\"被装配的代理不作为\",{\"1\":{\"695\":1}}],[\"被\",{\"1\":{\"678\":1}}],[\"被唤醒后他又要再次遍历fd\",{\"1\":{\"410\":1}}],[\"被程序语句获得的锁\",{\"1\":{\"389\":1}}],[\"被统称为nio\",{\"1\":{\"332\":1}}],[\"被换出的进程数据就存放在对换区\",{\"1\":{\"153\":1}}],[\"被挂起的进程pcb会被放到挂起队列中\",{\"1\":{\"136\":1}}],[\"被评为三好学生\",{\"1\":{\"87\":1,\"89\":1}}],[\"给一个key设置有效期\",{\"1\":{\"1024\":1}}],[\"给业务添加多级缓存\",{\"1\":{\"986\":1}}],[\"给缓存业务添加降级限流策略\",{\"1\":{\"986\":1}}],[\"给不同的key的ttl添加随机值\",{\"1\":{\"986\":1}}],[\"给数据库带来巨大压力\",{\"1\":{\"985\":1}}],[\"给\",{\"1\":{\"776\":2}}],[\"给定如何实现正整数的白名单\",{\"1\":{\"740\":1}}],[\"给定二叉树如何遍历\",{\"1\":{\"740\":1}}],[\"给线程取名字\",{\"1\":{\"242\":1}}],[\"给内存的存储单元编地址\",{\"1\":{\"151\":1}}],[\"给他们分配内存等必要资源\",{\"1\":{\"136\":1}}],[\"给程序设计带来便利的同时\",{\"1\":{\"108\":1}}],[\"作用之一\",{\"1\":{\"691\":1}}],[\"作用是不执行逻辑\",{\"1\":{\"642\":1}}],[\"作用域\",{\"0\":{\"497\":1},\"1\":{\"617\":1}}],[\"作用\",{\"1\":{\"457\":1}}],[\"作用字段个数\",{\"1\":{\"382\":1}}],[\"作为本地缓存\",{\"1\":{\"974\":1}}],[\"作为登录令牌\",{\"1\":{\"968\":1}}],[\"作为复制源的原来的分片\",{\"1\":{\"928\":1}}],[\"作为附件加入\",{\"1\":{\"893\":1}}],[\"作为附件关联到\",{\"1\":{\"890\":1}}],[\"作为服务器端\",{\"1\":{\"841\":1}}],[\"作为消息放入\",{\"1\":{\"793\":1}}],[\"作为消费者\",{\"1\":{\"313\":1}}],[\"作为分隔符\",{\"1\":{\"755\":1}}],[\"作为它的成员变量\",{\"1\":{\"644\":1}}],[\"作为静态资源\",{\"1\":{\"636\":1}}],[\"作为\",{\"1\":{\"622\":1}}],[\"作为扩展点\",{\"1\":{\"582\":1}}],[\"作为对比\",{\"1\":{\"504\":1}}],[\"作为一个哨兵集群去运行\",{\"1\":{\"433\":1}}],[\"作为访问数据库的缓冲\",{\"1\":{\"396\":1}}],[\"作为查询的字段列表\",{\"1\":{\"268\":1,\"388\":1}}],[\"作为treebin的节点\",{\"1\":{\"249\":1}}],[\"作为treebin\",{\"1\":{\"249\":1}}],[\"作业的地址空间被划分为若干个段\",{\"1\":{\"413\":1}}],[\"作业很大时\",{\"1\":{\"161\":1}}],[\"作业一旦进入内存之后\",{\"1\":{\"151\":1}}],[\"作业\",{\"1\":{\"139\":1}}],[\"作业在外存后备队列中等待的时间\",{\"1\":{\"138\":1}}],[\"作业处于等待处理机状态时间之和\",{\"1\":{\"138\":1}}],[\"作业实际运行时间\",{\"1\":{\"138\":1}}],[\"作业实际运行的时间\",{\"1\":{\"138\":1}}],[\"作业周转时间\",{\"1\":{\"138\":1}}],[\"作业数\",{\"1\":{\"138\":2}}],[\"作业提交时间\",{\"1\":{\"138\":2}}],[\"作业完成时间\",{\"1\":{\"138\":2}}],[\"作业调出时撤销pcb\",{\"1\":{\"136\":1}}],[\"作业调入时创建pcb\",{\"1\":{\"136\":1}}],[\"作业调度\",{\"1\":{\"136\":1,\"139\":1}}],[\"作者\",{\"1\":{\"1009\":1}}],[\"作者jun\",{\"1\":{\"5\":1}}],[\"作者相关\",{\"0\":{\"5\":1,\"12\":1}}],[\"客服了他们的缺点\",{\"1\":{\"135\":1}}],[\"客户程序就不需要变化\",{\"1\":{\"109\":1}}],[\"客户端对象\",{\"0\":{\"932\":1},\"1\":{\"932\":1}}],[\"客户端正常\",{\"1\":{\"883\":1}}],[\"客户端发送数据过来\",{\"1\":{\"883\":1}}],[\"客户端发起连接请求\",{\"1\":{\"883\":1}}],[\"客户端连接成功时触发\",{\"1\":{\"881\":1}}],[\"客户端向服务器端发送\",{\"1\":{\"833\":1}}],[\"客户端\",{\"0\":{\"786\":1,\"788\":1,\"835\":1},\"1\":{\"798\":1,\"816\":1,\"845\":1,\"876\":1,\"889\":1,\"890\":1,\"893\":1}}],[\"客户端架子\",{\"1\":{\"783\":1}}],[\"客户端启动\",{\"1\":{\"776\":1}}],[\"客户端可以定义如下心跳处理器\",{\"1\":{\"764\":1}}],[\"客户端可以定时向服务器端发送数据\",{\"1\":{\"764\":1}}],[\"客户端定时心跳\",{\"1\":{\"764\":1}}],[\"客户端代码为\",{\"1\":{\"884\":1}}],[\"客户端代码不变\",{\"1\":{\"798\":1,\"877\":1}}],[\"客户端代码第一版\",{\"0\":{\"785\":1}}],[\"客户端代码\",{\"0\":{\"787\":1},\"1\":{\"756\":1}}],[\"客户端代码希望发送\",{\"1\":{\"749\":1,\"750\":1}}],[\"客户端在每条消息之后\",{\"1\":{\"755\":1}}],[\"客户端输出\",{\"1\":{\"754\":1,\"755\":1,\"756\":1}}],[\"客户端什么时候\",{\"1\":{\"754\":1}}],[\"客户端测试代码\",{\"1\":{\"754\":1}}],[\"客户端调用业务请求的时候必须携带这个token\",{\"1\":{\"315\":1}}],[\"客户端先发送获取token的请求\",{\"1\":{\"315\":1}}],[\"客户端如果需要对象\",{\"1\":{\"77\":1}}],[\"客户端不应该被迫依赖于它不使用的方法\",{\"1\":{\"110\":1}}],[\"客户端不依赖产品实例的创建细节和内部结构\",{\"1\":{\"76\":1}}],[\"客户端不必知道产品内部组成的细节\",{\"1\":{\"50\":1}}],[\"别的线程还可以执行\",{\"1\":{\"135\":1}}],[\"整体可读性有了很大提升\",{\"1\":{\"1041\":1}}],[\"整体访问流程\",{\"0\":{\"967\":1}}],[\"整数类型\",{\"1\":{\"1025\":1}}],[\"整数时\",{\"1\":{\"823\":1}}],[\"整数\",{\"1\":{\"822\":1,\"824\":1}}],[\"整合时\",{\"1\":{\"451\":2}}],[\"整合\",{\"1\":{\"446\":1,\"449\":1}}],[\"整堆收集器\",{\"1\":{\"360\":1}}],[\"整堆收集\",{\"1\":{\"350\":1}}],[\"整个登录拦截功能就会出现问题\",{\"1\":{\"963\":1}}],[\"整个过程仅只发生了一次用户态与内核态的切换\",{\"1\":{\"905\":1}}],[\"整个过程开始于客户端发出一个http请求\",{\"1\":{\"736\":1}}],[\"整个自动配置的过程是\",{\"1\":{\"730\":1}}],[\"整个用户的process其实是一直被block的\",{\"1\":{\"409\":1}}],[\"整个进程会被阻塞\",{\"1\":{\"409\":1}}],[\"整个进程都会被阻塞\",{\"1\":{\"135\":1}}],[\"整个事务才算执行成功\",{\"1\":{\"396\":1}}],[\"整个concurrenthashmap就是一个node\",{\"1\":{\"249\":1}}],[\"整个线程池表现为线程数会根据任务量不断增长\",{\"1\":{\"244\":1}}],[\"整个系统只建立一张目录表\",{\"1\":{\"168\":1}}],[\"整型信号量\",{\"1\":{\"143\":1}}],[\"整理自同济子豪兄\",{\"1\":{\"20\":1}}],[\"阻塞直到绑定事件发生\",{\"1\":{\"882\":2}}],[\"阻塞直到事件发生\",{\"1\":{\"793\":1}}],[\"阻塞方法\",{\"1\":{\"876\":2}}],[\"阻塞方法之间相互影响\",{\"1\":{\"876\":1}}],[\"阻塞模式下\",{\"1\":{\"876\":1,\"916\":1}}],[\"阻塞等待\",{\"1\":{\"806\":1}}],[\"阻塞等等问题导致客户端或者调用方并不能及时的收到服务端的反馈甚至是调用超时的问题\",{\"1\":{\"313\":1}}],[\"阻塞的表现其实就是线程暂停了\",{\"1\":{\"876\":1}}],[\"阻塞的\",{\"1\":{\"792\":1}}],[\"阻塞线程io\",{\"1\":{\"791\":1}}],[\"阻塞了\",{\"1\":{\"791\":1}}],[\"阻塞写操作把处理多个文件描述符的任务饿死\",{\"1\":{\"410\":1}}],[\"阻塞io\",{\"1\":{\"409\":1}}],[\"阻塞i\",{\"1\":{\"409\":2}}],[\"阻塞非阻塞\",{\"1\":{\"405\":1}}],[\"阻塞队列使用的是synchronousqueue\",{\"1\":{\"244\":1}}],[\"阻塞队列是无界的\",{\"1\":{\"244\":1}}],[\"阻塞队列\",{\"1\":{\"242\":1}}],[\"阻塞状态不会\",{\"1\":{\"203\":1}}],[\"阻塞状态\",{\"1\":{\"203\":1,\"208\":3}}],[\"阻塞\",{\"0\":{\"875\":1,\"876\":1},\"1\":{\"135\":1,\"219\":1,\"775\":1,\"791\":1,\"901\":2}}],[\"阻塞态\",{\"1\":{\"132\":1}}],[\"多则几千万\",{\"1\":{\"975\":1}}],[\"多出来的数据会被默默抛弃\",{\"1\":{\"898\":1}}],[\"多关注\",{\"1\":{\"893\":1}}],[\"多路复用仅针对网络\",{\"1\":{\"878\":1}}],[\"多路复用\",{\"0\":{\"878\":1},\"1\":{\"901\":2}}],[\"多路归并排序对大文件进行排序的步骤如下\",{\"1\":{\"291\":1}}],[\"多\",{\"1\":{\"842\":1}}],[\"多核\",{\"1\":{\"805\":1}}],[\"多核cpu的场景下\",{\"1\":{\"231\":1}}],[\"多核cpu自旋才能发挥优势\",{\"1\":{\"212\":1}}],[\"多例bean不存在线程安全问题\",{\"1\":{\"712\":1}}],[\"多项\",{\"1\":{\"665\":2}}],[\"多了一个\",{\"1\":{\"648\":1}}],[\"多点啥\",{\"1\":{\"449\":1}}],[\"多使用commit\",{\"0\":{\"389\":1}}],[\"多表\",{\"1\":{\"383\":1}}],[\"多表关联查询时\",{\"1\":{\"266\":1}}],[\"多米诺牌的效应就此开始\",{\"1\":{\"280\":1}}],[\"多次操作会带来性能的损耗\",{\"1\":{\"829\":1}}],[\"多次提交很可能产生多笔订单\",{\"1\":{\"314\":1}}],[\"多次提交很可能产生副作用\",{\"1\":{\"314\":1}}],[\"多次调用会抛illegalthreadstateexception异常\",{\"1\":{\"202\":1}}],[\"多次性\",{\"1\":{\"161\":1}}],[\"多层索引\",{\"1\":{\"169\":1}}],[\"多级页表的提出主要是解决下面两个问题\",{\"1\":{\"413\":1}}],[\"多级页表\",{\"1\":{\"413\":1}}],[\"多级页表解决\",{\"1\":{\"413\":1}}],[\"多级目录结构\",{\"1\":{\"168\":1}}],[\"多级索引顺序文件\",{\"1\":{\"167\":1}}],[\"多级反馈队列调度算法\",{\"1\":{\"139\":1}}],[\"多对多模型\",{\"1\":{\"135\":1}}],[\"多对一模型\",{\"1\":{\"135\":1}}],[\"多线程版缺点⚠️\",{\"0\":{\"914\":1}}],[\"多线程版设计\",{\"0\":{\"913\":1}}],[\"多线程和异步所提升的效率并不是所认为的\",{\"1\":{\"805\":1}}],[\"多线程就效率高\",{\"1\":{\"805\":1}}],[\"多线程汇总结果\",{\"1\":{\"740\":1}}],[\"多线程可以在多核处理机上执行\",{\"1\":{\"135\":1}}],[\"多线程模型\",{\"0\":{\"135\":1}}],[\"多个单词之间用\",{\"1\":{\"1026\":1}}],[\"多个表中会生成重复的\",{\"1\":{\"439\":1}}],[\"多个事务的读操作可以同时进行而不会互相影响\",{\"1\":{\"398\":1}}],[\"多个版本的数据可以共存\",{\"1\":{\"393\":1}}],[\"多个channel以事件的形式注册到同一个selector\",{\"1\":{\"332\":1}}],[\"多个线程同时读取这个共享变量的值\",{\"1\":{\"230\":1}}],[\"多个线程不可以在多核处理机上并行运行\",{\"1\":{\"135\":1}}],[\"多个读线程的情况\",{\"1\":{\"228\":1}}],[\"多个用户共享同一个文件\",{\"1\":{\"172\":1}}],[\"多个用户级线程映射到一个内核级线程\",{\"1\":{\"135\":1}}],[\"多个模块\",{\"1\":{\"153\":1}}],[\"多深\",{\"1\":{\"37\":1}}],[\"写出剩余内容\",{\"1\":{\"909\":1}}],[\"写出\",{\"1\":{\"904\":1}}],[\"写完了\",{\"1\":{\"893\":1}}],[\"写事件由\",{\"1\":{\"909\":1}}],[\"写事件\",{\"1\":{\"893\":1}}],[\"写\",{\"1\":{\"859\":1,\"890\":1}}],[\"写模式下\",{\"1\":{\"848\":1}}],[\"写模式\",{\"1\":{\"846\":1}}],[\"写也不会阻塞读\",{\"1\":{\"845\":1}}],[\"写回结果\",{\"1\":{\"816\":1}}],[\"写回响应\",{\"1\":{\"768\":1}}],[\"写空闲时间过长\",{\"1\":{\"764\":2}}],[\"写锁之间是互斥的\",{\"1\":{\"400\":1}}],[\"写锁可以降级为读锁\",{\"1\":{\"259\":1}}],[\"写过程和普通锁没什么区别\",{\"1\":{\"260\":1}}],[\"写屏障\",{\"1\":{\"237\":1}}],[\"写屏障会确保指令重排序时\",{\"1\":{\"227\":1,\"237\":1}}],[\"写屏障保证该屏障之前的\",{\"1\":{\"227\":1,\"237\":1}}],[\"写指令之后\",{\"1\":{\"181\":1}}],[\"写都需要cpu的帮助\",{\"1\":{\"181\":1}}],[\"写一个或多个连续的数据块\",{\"1\":{\"181\":1}}],[\"写一个或多个块\",{\"1\":{\"181\":1}}],[\"写一个字\",{\"1\":{\"181\":2}}],[\"写一个磁道所需的时间刚好又是转一圈所需要的时间r1​\",{\"1\":{\"176\":1}}],[\"写的字节数为b\",{\"1\":{\"176\":1}}],[\"写数据时\",{\"1\":{\"877\":1}}],[\"写数据前\",{\"1\":{\"176\":1}}],[\"写数据\",{\"1\":{\"175\":1}}],[\"写数据必须在读数据之前完成\",{\"1\":{\"140\":1}}],[\"写文件\",{\"1\":{\"171\":1}}],[\"写操作完成后\",{\"1\":{\"248\":1}}],[\"写操作在该副本上进行\",{\"1\":{\"248\":1}}],[\"写操作则通过操作操作底层数组的新副本来实现\",{\"1\":{\"248\":1}}],[\"写操作的流程\",{\"1\":{\"181\":3}}],[\"写操作需要的时间\",{\"1\":{\"176\":1}}],[\"写操作\",{\"1\":{\"169\":1,\"181\":3}}],[\"写进程的write\",{\"1\":{\"134\":1}}],[\"写入一条string数据\",{\"1\":{\"1040\":1,\"1042\":1}}],[\"写入redis时\",{\"1\":{\"1042\":1}}],[\"写入redis\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":3}}],[\"写入的正确姿势如下\",{\"1\":{\"865\":1}}],[\"写入数据\",{\"0\":{\"852\":1},\"1\":{\"847\":1,\"1042\":1}}],[\"写入消息并清空缓冲区\",{\"1\":{\"835\":1}}],[\"写入字符串\",{\"1\":{\"822\":1}}],[\"写入后\",{\"1\":{\"822\":2}}],[\"写入\",{\"0\":{\"822\":1,\"865\":1},\"1\":{\"822\":12,\"846\":1,\"904\":1}}],[\"写入内容\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"写入tf卡功能\",{\"1\":{\"41\":1}}],[\"写入sd卡功能\",{\"1\":{\"41\":1}}],[\"管理多个\",{\"1\":{\"890\":1}}],[\"管理一个\",{\"1\":{\"829\":1}}],[\"管理\",{\"1\":{\"661\":2,\"671\":1,\"672\":1,\"787\":1}}],[\"管理的本质\",{\"1\":{\"486\":1}}],[\"管理的\",{\"1\":{\"458\":1}}],[\"管理上述3种资源种的内部花费\",{\"1\":{\"389\":1}}],[\"管程中定义的数据结构\",{\"1\":{\"145\":1}}],[\"管程有一个名字\",{\"1\":{\"145\":1}}],[\"管程的基本特征\",{\"1\":{\"145\":1}}],[\"管程的组成\",{\"1\":{\"145\":1}}],[\"管程的定义和基本特征\",{\"1\":{\"145\":1}}],[\"管程作用\",{\"1\":{\"145\":1}}],[\"管程\",{\"0\":{\"145\":1}}],[\"管道\",{\"1\":{\"332\":1}}],[\"管道变空\",{\"1\":{\"134\":1}}],[\"管道只能采用半双工通信\",{\"1\":{\"134\":1}}],[\"管道通信中\",{\"1\":{\"140\":1}}],[\"管道通信\",{\"1\":{\"134\":1}}],[\"管态\",{\"1\":{\"128\":1}}],[\"基础\",{\"0\":{\"920\":1,\"1000\":1}}],[\"基础值\",{\"1\":{\"234\":1}}],[\"基址\",{\"1\":{\"159\":1}}],[\"基地址变换机构可以借助页表将逻辑地址变换为物理地址\",{\"1\":{\"157\":1}}],[\"基地址变换机构\",{\"0\":{\"157\":1}}],[\"基于内存\",{\"1\":{\"1009\":1}}],[\"基于逻辑过期方式来解决缓存击穿问题\",{\"1\":{\"989\":1}}],[\"基于token获取redis中的用户\",{\"1\":{\"972\":1}}],[\"基于redis实现短信登录\",{\"0\":{\"968\":1}}],[\"基于stringredistemplate封装一个缓存工具类\",{\"1\":{\"990\":1}}],[\"基于session实现登录流程\",{\"0\":{\"959\":1}}],[\"基于spring框架的项目\",{\"1\":{\"726\":1}}],[\"基于事件驱动的网络应用框架\",{\"1\":{\"839\":1}}],[\"基于\",{\"1\":{\"451\":2,\"719\":1}}],[\"基于时间戳\",{\"1\":{\"442\":1}}],[\"基于io多路复用机制\",{\"1\":{\"424\":1}}],[\"基于跳表实现\",{\"1\":{\"422\":1}}],[\"基于这一点\",{\"1\":{\"419\":1}}],[\"基于局部性原理可知\",{\"1\":{\"418\":1}}],[\"基于undo\",{\"1\":{\"393\":1}}],[\"基于hashmap实现\",{\"1\":{\"326\":1}}],[\"基于死磕\",{\"1\":{\"250\":1}}],[\"基于符号链的共享方式\",{\"1\":{\"172\":1}}],[\"基于索引节点的共享方式\",{\"1\":{\"172\":1}}],[\"基于存储区的共享\",{\"1\":{\"134\":1}}],[\"基于数据结构的共享\",{\"1\":{\"134\":1}}],[\"基本概念\",{\"0\":{\"921\":1}}],[\"基本规则是\",{\"1\":{\"825\":1}}],[\"基本结构\",{\"1\":{\"653\":1}}],[\"基本的类型转换与数据绑定用法\",{\"1\":{\"579\":1}}],[\"基本的依赖注入\",{\"1\":{\"449\":1}}],[\"基本保证\",{\"1\":{\"442\":1}}],[\"基本不使用\",{\"1\":{\"429\":1}}],[\"基本思想\",{\"1\":{\"356\":1}}],[\"基本分段存储管理方式\",{\"0\":{\"159\":1}}],[\"基本分页存储管理的思想\",{\"1\":{\"156\":1}}],[\"基本分页存储管理的基本概念\",{\"0\":{\"156\":1}}],[\"基本方法又可以分为三种\",{\"1\":{\"119\":1}}],[\"基本方法\",{\"1\":{\"119\":1}}],[\"基本上不用修改之前已经测试通过的代码\",{\"1\":{\"50\":1}}],[\"恢复用户态现场\",{\"1\":{\"406\":1}}],[\"恢复运行环境\",{\"1\":{\"133\":1}}],[\"恢复原进程的cpu环境并退出中断\",{\"1\":{\"129\":1}}],[\"修复方案就是给randomkey增加最多执行次数\",{\"1\":{\"436\":1}}],[\"修改redistemplate的序列化器为genericjackson2jsonredisserializer\",{\"1\":{\"1042\":1}}],[\"修改为yes后即可后台运行\",{\"1\":{\"1015\":1}}],[\"修改为0\",{\"1\":{\"1015\":1}}],[\"修改为=1\",{\"1\":{\"163\":1}}],[\"修改为=0\",{\"1\":{\"163\":1}}],[\"修改秒杀业务\",{\"1\":{\"998\":1}}],[\"修改代码方案二\",{\"1\":{\"997\":1}}],[\"修改代码方案一\",{\"1\":{\"997\":1}}],[\"修改根据id查询商铺的业务\",{\"1\":{\"989\":1}}],[\"修改重点代码2\",{\"1\":{\"983\":1}}],[\"修改重点代码1\",{\"1\":{\"983\":1}}],[\"修改shopserviceimpl的querybyid方法\",{\"1\":{\"983\":1}}],[\"修改shopcontroller中的业务逻辑\",{\"1\":{\"983\":1}}],[\"修改数据\",{\"1\":{\"934\":1}}],[\"修改文档\",{\"1\":{\"934\":1,\"950\":1}}],[\"修改一下发送文字\",{\"1\":{\"886\":1}}],[\"修改编解码器\",{\"1\":{\"773\":1}}],[\"修改\",{\"1\":{\"508\":1}}],[\"修改目标字节码\",{\"1\":{\"504\":1}}],[\"修改目标类的字节码\",{\"1\":{\"504\":1}}],[\"修改目录\",{\"1\":{\"168\":1}}],[\"修改就不会成功\",{\"1\":{\"397\":1}}],[\"修改记录操作\",{\"1\":{\"267\":1}}],[\"修改位\",{\"1\":{\"163\":1}}],[\"修改进程状态标志\",{\"1\":{\"133\":1}}],[\"修饰\",{\"1\":{\"101\":1,\"688\":1}}],[\"更是可以做到动静分离\",{\"1\":{\"955\":1}}],[\"更少的用户态与内核态的切换\",{\"1\":{\"905\":1}}],[\"更为底层\",{\"1\":{\"900\":1,\"911\":1}}],[\"更进一步\",{\"0\":{\"895\":1}}],[\"更简洁\",{\"1\":{\"842\":1}}],[\"更节约内存\",{\"1\":{\"831\":1}}],[\"更加方便redis获取数据\",{\"1\":{\"1026\":1}}],[\"更加没有万能的收集器\",{\"1\":{\"360\":1}}],[\"更加严谨\",{\"1\":{\"291\":1}}],[\"更加容易扩展\",{\"1\":{\"64\":1}}],[\"更没有移植性\",{\"1\":{\"267\":1}}],[\"更重要的是提升检索速度\",{\"1\":{\"265\":1}}],[\"更不能是text字段\",{\"1\":{\"265\":1}}],[\"更新数据库\",{\"1\":{\"983\":1}}],[\"更新数据库时让缓存失效\",{\"1\":{\"982\":1}}],[\"更新数据表记录时\",{\"1\":{\"268\":1}}],[\"更新缓存\",{\"1\":{\"982\":1}}],[\"更新和删除的时候\",{\"1\":{\"922\":1}}],[\"更新的字段是非索引字段\",{\"1\":{\"383\":1}}],[\"更新\",{\"1\":{\"249\":1}}],[\"更新并获取\",{\"1\":{\"232\":1}}],[\"更新pcb中的信息\",{\"1\":{\"133\":1}}],[\"更方便使用\",{\"1\":{\"155\":1}}],[\"关系型数据库因为表之间存在关联关系\",{\"1\":{\"1008\":1}}],[\"关系型数据库集群模式一般是主从\",{\"1\":{\"1008\":1}}],[\"关系型数据库基于磁盘进行存储\",{\"1\":{\"1008\":1}}],[\"关联和非关联\",{\"0\":{\"1005\":1}}],[\"关于countdownlatch\",{\"1\":{\"993\":1}}],[\"关于threadlocal\",{\"1\":{\"961\":1}}],[\"关于select\",{\"0\":{\"388\":1}}],[\"关注\",{\"1\":{\"793\":2}}],[\"关注事件\",{\"1\":{\"790\":1}}],[\"关注的是所有标注\",{\"1\":{\"661\":1}}],[\"关闭\",{\"0\":{\"866\":1},\"1\":{\"802\":2}}],[\"关闭了nagle算法\",{\"1\":{\"778\":1}}],[\"关闭发布者\",{\"1\":{\"743\":1,\"744\":1}}],[\"关闭文件\",{\"1\":{\"171\":1}}],[\"关中断指令\",{\"1\":{\"133\":1,\"142\":1}}],[\"关键在于上面例子里面的订阅关系subscription这个接口\",{\"1\":{\"745\":1}}],[\"关键代码\",{\"0\":{\"463\":1,\"619\":1,\"622\":1,\"626\":1,\"630\":1,\"635\":1,\"638\":1,\"641\":1,\"655\":1,\"657\":1,\"670\":1},\"1\":{\"790\":10,\"793\":1,\"799\":1}}],[\"关键点在于如下拦截器的编写\",{\"1\":{\"368\":1}}],[\"关键词\",{\"1\":{\"120\":1}}],[\"关键字之后的双重检查锁模式是一种比较好的单例实现模式\",{\"1\":{\"101\":1}}],[\"关键字可以保证可见性和有序性\",{\"1\":{\"101\":1}}],[\"关键字\",{\"1\":{\"101\":1}}],[\"答\",{\"1\":{\"133\":1}}],[\"撤销已有进程\",{\"1\":{\"133\":1}}],[\"撤销pcb\",{\"1\":{\"132\":1}}],[\"撤销进程之前的运行都芜湖了\",{\"1\":{\"150\":1}}],[\"撤销进程法\",{\"1\":{\"150\":1}}],[\"撤销进程\",{\"1\":{\"131\":1}}],[\"单元测试\",{\"1\":{\"1032\":1}}],[\"单元测试和集成测试变得更简单\",{\"1\":{\"705\":1}}],[\"单体系统\",{\"1\":{\"982\":1}}],[\"单从字面意思不好理解\",{\"1\":{\"912\":1}}],[\"单线程配一个选择器\",{\"1\":{\"896\":1}}],[\"单线程可以配合\",{\"1\":{\"878\":1}}],[\"单线程\",{\"1\":{\"876\":1,\"877\":1,\"1009\":1}}],[\"单线程下\",{\"1\":{\"876\":1}}],[\"单线程没法异步提高效率\",{\"1\":{\"805\":1}}],[\"单位时间内能够处理请求的数量\",{\"1\":{\"805\":1}}],[\"单位时间内完成的作业的数量\",{\"1\":{\"138\":1}}],[\"单聊\",{\"0\":{\"760\":1},\"1\":{\"760\":1,\"769\":1}}],[\"单节点理论支持最高并发量为10万\",{\"1\":{\"433\":1}}],[\"单个进程所能打开的最大连接数由fd\",{\"1\":{\"410\":1}}],[\"单调递增是希望插入时不影响数据库性能\",{\"1\":{\"392\":1}}],[\"单列索引和联合索引\",{\"1\":{\"382\":1}}],[\"单词小的输入文件流放在堆顶\",{\"1\":{\"291\":1}}],[\"单点登录\",{\"1\":{\"738\":1}}],[\"单点修改\",{\"1\":{\"287\":1}}],[\"单点更新\",{\"0\":{\"287\":1}}],[\"单表中最多只有一个匹配行\",{\"1\":{\"266\":1}}],[\"单表行数超过500万行或者单表容量超过2gb\",{\"1\":{\"265\":1}}],[\"单表时自增\",{\"1\":{\"265\":1}}],[\"单核cpu自选就是浪费\",{\"1\":{\"212\":1}}],[\"单核cp每次最多处理一个进程\",{\"1\":{\"132\":1}}],[\"单缓冲\",{\"1\":{\"186\":1}}],[\"单级目录结构\",{\"1\":{\"168\":1}}],[\"单级页表的问题\",{\"1\":{\"158\":1}}],[\"单任务的操作系统中\",{\"1\":{\"154\":1}}],[\"单一连续分配方式\",{\"1\":{\"154\":1}}],[\"单标志法\",{\"1\":{\"141\":1}}],[\"单例bean存在线程安全问题\",{\"1\":{\"712\":1}}],[\"单例bean的线程安全问题了解吗\",{\"0\":{\"712\":1}}],[\"单例bean\",{\"1\":{\"710\":1}}],[\"单例的产品不会存储于\",{\"1\":{\"678\":1}}],[\"单例的生命周期和应用程序是一样长的\",{\"1\":{\"358\":1}}],[\"单例注入其它\",{\"1\":{\"503\":1}}],[\"单例对象\",{\"1\":{\"358\":1}}],[\"单例设计模式分类两种\",{\"1\":{\"101\":1}}],[\"单例类\",{\"1\":{\"100\":1}}],[\"单例模式的实现\",{\"0\":{\"101\":1}}],[\"单例模式的主要有以下角色\",{\"1\":{\"100\":1}}],[\"单例模式的结构\",{\"0\":{\"100\":1}}],[\"单例模式的应用场景\",{\"1\":{\"57\":1}}],[\"单例模式\",{\"0\":{\"57\":1,\"99\":1},\"1\":{\"99\":1}}],[\"应当是泛指教师应当得到的报酬\",{\"1\":{\"766\":1}}],[\"应该就安装成功了\",{\"1\":{\"1012\":1}}],[\"应该具体操作缓存还是操作数据库\",{\"1\":{\"982\":1}}],[\"应该替换成where子句\",{\"1\":{\"394\":1}}],[\"应该加在后面\",{\"1\":{\"282\":1}}],[\"应该要把设置的key\",{\"1\":{\"247\":1}}],[\"应该将坏块标记出来\",{\"1\":{\"178\":1}}],[\"应该优先淘汰没有修改过的页面\",{\"1\":{\"163\":1}}],[\"应该选择哪个分区进行分配\",{\"1\":{\"154\":1}}],[\"应该换出哪些进程\",{\"1\":{\"153\":1}}],[\"应该在外存\",{\"1\":{\"153\":1}}],[\"应该采取适当的方式将这些pcb组织起来\",{\"1\":{\"131\":1}}],[\"应立即释放处理机\",{\"1\":{\"140\":1}}],[\"应保证能在有限时间内进入临界区\",{\"1\":{\"140\":1}}],[\"应用层缓存\",{\"1\":{\"976\":1}}],[\"应用层\",{\"1\":{\"751\":2}}],[\"应用可以直接使用aop的功能\",{\"1\":{\"716\":1}}],[\"应用2\",{\"1\":{\"653\":1}}],[\"应用1\",{\"1\":{\"653\":1}}],[\"应用类型推断\",{\"1\":{\"652\":1}}],[\"应用\",{\"0\":{\"918\":1},\"1\":{\"261\":1}}],[\"应用的是装饰器模式\",{\"1\":{\"244\":1}}],[\"应用程序线程阻塞\",{\"1\":{\"764\":1}}],[\"应用程序值得是servletcontext\",{\"1\":{\"710\":1}}],[\"应用程序销毁时bean销毁\",{\"1\":{\"710\":1}}],[\"应用程序启动时bean创建\",{\"1\":{\"710\":1}}],[\"应用程序在运行之前没有必要将之全部装入内存\",{\"1\":{\"418\":1}}],[\"应用程序必须立即处理该事件\",{\"1\":{\"410\":1}}],[\"应用程序可以不立即处理该事件下次调用epoll\",{\"1\":{\"410\":1}}],[\"应用程序可以发出系统调用请求来获得操作系统的服务\",{\"1\":{\"130\":1}}],[\"应用程序通过系统调用请求操作系统的服务\",{\"1\":{\"130\":1}}],[\"应用程序\",{\"1\":{\"128\":1}}],[\"应用场景不同\",{\"1\":{\"45\":1}}],[\"应用场景\",{\"0\":{\"43\":1},\"1\":{\"422\":5}}],[\"→\",{\"1\":{\"129\":2}}],[\"最开始输入是\",{\"1\":{\"837\":1}}],[\"最开始读写指针都在\",{\"1\":{\"821\":1}}],[\"最好别修改\",{\"1\":{\"779\":1}}],[\"最小空闲连接\",{\"1\":{\"1039\":1}}],[\"最小连接数等\",{\"1\":{\"660\":1}}],[\"最小1\",{\"1\":{\"205\":1}}],[\"最初获得方法顺序是不确定的\",{\"1\":{\"527\":1}}],[\"最高只支持到\",{\"1\":{\"506\":1}}],[\"最高1位固定值0\",{\"1\":{\"440\":1}}],[\"最重要的实现\",{\"1\":{\"451\":1}}],[\"最低12位为1\",{\"1\":{\"441\":2}}],[\"最多可以部署210=1024台机器\",{\"1\":{\"440\":1}}],[\"最多只需1~3次磁盘io\",{\"0\":{\"377\":1}}],[\"最多只有一个任务的阻塞队列\",{\"1\":{\"242\":1}}],[\"最早是\",{\"1\":{\"440\":1}}],[\"最常用\",{\"1\":{\"429\":2}}],[\"最常使用\",{\"1\":{\"366\":1}}],[\"最少使用页面置换算法\",{\"1\":{\"420\":1}}],[\"最少的平均带权周转时间\",{\"1\":{\"139\":1}}],[\"最少的平均周转时间\",{\"1\":{\"139\":1}}],[\"最左前缀\",{\"1\":{\"395\":1}}],[\"最左前缀原则\",{\"1\":{\"383\":1}}],[\"最终结果如图\",{\"1\":{\"1041\":1}}],[\"最终返回\",{\"1\":{\"1024\":1}}],[\"最终多个线程相当于一起去扣减库存\",{\"1\":{\"996\":1}}],[\"最终都需要变成\",{\"1\":{\"773\":1}}],[\"最终客户端得到的响应消息可能是有一个普通的html页面\",{\"1\":{\"736\":2}}],[\"最终将结果相应给前端\",{\"1\":{\"366\":1}}],[\"最终使问题得以成功解决\",{\"0\":{\"311\":1}}],[\"最终\",{\"1\":{\"291\":1}}],[\"最终能够消除所有边\",{\"1\":{\"150\":1}}],[\"最糟糕的是会有\",{\"1\":{\"281\":1}}],[\"最大空闲连接\",{\"1\":{\"1039\":1}}],[\"最大连接\",{\"1\":{\"1039\":1}}],[\"最大长度\",{\"1\":{\"756\":1}}],[\"最大值可为\",{\"1\":{\"441\":1}}],[\"最大值31\",{\"1\":{\"441\":2}}],[\"最大的特点就在于边缘触发\",{\"1\":{\"410\":1}}],[\"最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理\",{\"1\":{\"96\":1}}],[\"最大线程数为integer\",{\"1\":{\"244\":1}}],[\"最大线程数\",{\"1\":{\"242\":1,\"244\":1}}],[\"最悲观的估计\",{\"1\":{\"231\":1}}],[\"最乐观的估计\",{\"1\":{\"231\":1}}],[\"最后小总结\",{\"1\":{\"1042\":1}}],[\"最后提供返回连接池中连接的方法\",{\"1\":{\"1034\":1}}],[\"最后返回一个完整的值\",{\"1\":{\"997\":1}}],[\"最后也需要加上条件version\",{\"1\":{\"996\":1}}],[\"最后也就导致无大分区可用\",{\"1\":{\"155\":1}}],[\"最后将用户数据保存到redis\",{\"1\":{\"967\":1}}],[\"最后将结果汇总\",{\"1\":{\"234\":1}}],[\"最后使用\",{\"1\":{\"905\":1}}],[\"最后输出又变成\",{\"1\":{\"837\":1}}],[\"最后输出\",{\"1\":{\"798\":1}}],[\"最后按\",{\"1\":{\"604\":1}}],[\"最后有一些特殊处理\",{\"1\":{\"576\":1}}],[\"最后计算出来的机器码能区分开来即可\",{\"1\":{\"443\":1}}],[\"最后12位\",{\"1\":{\"441\":1}}],[\"最后12位存储序列号\",{\"1\":{\"440\":1}}],[\"最后\",{\"1\":{\"383\":1}}],[\"最后一次上号时间\",{\"1\":{\"296\":1}}],[\"最后的字段是组合索引的一部分\",{\"1\":{\"266\":1}}],[\"最后到时线程阻塞\",{\"1\":{\"222\":1}}],[\"最近最久未使用页面置换算法\",{\"1\":{\"420\":1}}],[\"最近最久未使用置换算法\",{\"1\":{\"163\":2}}],[\"最近在看\",{\"1\":{\"306\":1}}],[\"最近在看什么书\",{\"0\":{\"306\":1}}],[\"最近写代码也会刻意注意到这点\",{\"1\":{\"302\":1}}],[\"最近访问过\",{\"1\":{\"163\":2}}],[\"最近没访问\",{\"1\":{\"163\":1}}],[\"最近没有访问且没有修改过的页面\",{\"1\":{\"163\":1}}],[\"最佳页面置换算法所选择的被淘汰页面将是以后永不使用的\",{\"1\":{\"420\":1}}],[\"最佳页面置换算法\",{\"1\":{\"420\":1}}],[\"最佳置换算法\",{\"1\":{\"163\":2}}],[\"最佳适应算法\",{\"1\":{\"155\":1}}],[\"最坏适应算法\",{\"1\":{\"155\":1}}],[\"最简单的多道程序的内存管理方式\",{\"1\":{\"154\":1}}],[\"最短寻找时间优先\",{\"1\":{\"176\":1}}],[\"最短的平均等待时间\",{\"1\":{\"139\":1}}],[\"最短剩余时间优先算法\",{\"1\":{\"139\":1}}],[\"最核心的部分\",{\"1\":{\"128\":1}}],[\"普通字符串\",{\"1\":{\"1025\":1}}],[\"普通文件\",{\"1\":{\"878\":1}}],[\"普通类\",{\"1\":{\"572\":1}}],[\"普通索引三种\",{\"1\":{\"266\":1}}],[\"普通索引名则为idx字段名\",{\"1\":{\"265\":1}}],[\"普通应用程序只能执行非特权指令\",{\"1\":{\"128\":1}}],[\"普通的运算指令\",{\"1\":{\"128\":1}}],[\"特征也与linkedlist类似\",{\"1\":{\"1028\":1}}],[\"特征\",{\"1\":{\"1009\":1}}],[\"特价卷除了具有优惠卷的基本信息以外\",{\"1\":{\"994\":1}}],[\"特价优惠券才需要填写这些信息\",{\"1\":{\"994\":1}}],[\"特殊处理\",{\"1\":{\"582\":1}}],[\"特有语法\",{\"1\":{\"504\":1}}],[\"特别时主从切换的瞬间存在访问瞬断的情况\",{\"1\":{\"433\":1}}],[\"特别是删除\",{\"1\":{\"267\":1}}],[\"特点就是先由操作系统完成后才通知服务端程序启动线程去处理\",{\"1\":{\"333\":1}}],[\"特点\",{\"1\":{\"137\":2,\"151\":2,\"153\":1,\"154\":3,\"244\":2}}],[\"特权指令和非特权指令都可执行\",{\"1\":{\"128\":1}}],[\"特权指令\",{\"1\":{\"128\":1}}],[\"特发此状\",{\"1\":{\"87\":1,\"89\":1}}],[\"4k\",{\"1\":{\"891\":2}}],[\"4b\",{\"1\":{\"755\":1,\"798\":2}}],[\"4999\",{\"1\":{\"950\":1,\"1005\":1,\"1026\":1}}],[\"49979\",{\"1\":{\"756\":17}}],[\"49\",{\"0\":{\"700\":1},\"1\":{\"750\":2,\"811\":3}}],[\"48\",{\"0\":{\"696\":1},\"1\":{\"798\":5}}],[\"484c54717461b527d7e199d942448f1\",{\"1\":{\"158\":1}}],[\"47499c2a\",{\"1\":{\"815\":2}}],[\"47\",{\"0\":{\"692\":1}}],[\"46\",{\"0\":{\"687\":1},\"1\":{\"749\":2}}],[\"44\",{\"0\":{\"679\":1},\"1\":{\"750\":7,\"907\":3}}],[\"4444\",{\"1\":{\"337\":1}}],[\"4294967294\",{\"1\":{\"870\":1}}],[\"42\",{\"0\":{\"672\":1}}],[\"41\",{\"0\":{\"658\":1},\"1\":{\"751\":1,\"812\":1}}],[\"4种解决方法\",{\"0\":{\"501\":1}}],[\"400\",{\"1\":{\"1043\":3}}],[\"401\",{\"1\":{\"961\":1,\"972\":1}}],[\"40\",{\"0\":{\"653\":1},\"1\":{\"751\":1,\"798\":3}}],[\"4095\",{\"1\":{\"441\":2}}],[\"40332004\",{\"1\":{\"31\":1}}],[\"4352\",{\"1\":{\"751\":1}}],[\"43\",{\"0\":{\"675\":1},\"1\":{\"337\":1,\"750\":2}}],[\"4之前唯一的选择\",{\"1\":{\"334\":1}}],[\"4开始支持\",{\"1\":{\"334\":1}}],[\"4开始\",{\"1\":{\"332\":1}}],[\"4释放了锁\",{\"1\":{\"261\":1}}],[\"45\",{\"0\":{\"683\":1},\"1\":{\"163\":1,\"941\":1}}],[\"4\",{\"0\":{\"128\":1,\"150\":1,\"169\":1,\"467\":1,\"778\":1,\"786\":1,\"821\":1,\"925\":1,\"934\":1,\"939\":1,\"947\":1,\"948\":1,\"949\":1,\"950\":1,\"957\":1,\"961\":1,\"983\":1,\"995\":1,\"1007\":1,\"1014\":1,\"1017\":1,\"1018\":1,\"1019\":1,\"1020\":1,\"1021\":2,\"1026\":1,\"1031\":1,\"1032\":1,\"1033\":1,\"1034\":1,\"1035\":1,\"1043\":1},\"1\":{\"132\":1,\"134\":1,\"135\":1,\"140\":2,\"147\":1,\"148\":1,\"156\":1,\"211\":1,\"237\":1,\"261\":1,\"265\":1,\"276\":1,\"277\":3,\"282\":1,\"336\":1,\"342\":1,\"366\":1,\"420\":1,\"644\":2,\"655\":1,\"657\":1,\"731\":1,\"743\":2,\"744\":2,\"749\":2,\"750\":3,\"753\":1,\"754\":11,\"755\":11,\"756\":11,\"770\":5,\"771\":4,\"773\":5,\"776\":2,\"787\":1,\"790\":3,\"793\":1,\"798\":24,\"805\":5,\"809\":1,\"815\":2,\"816\":2,\"818\":1,\"820\":2,\"822\":6,\"823\":1,\"824\":7,\"826\":7,\"829\":5,\"830\":4,\"834\":2,\"835\":2,\"842\":1,\"846\":2,\"848\":2,\"849\":8,\"855\":2,\"857\":3,\"858\":4,\"876\":1,\"877\":1,\"886\":2,\"889\":1,\"890\":1,\"893\":2,\"898\":1,\"904\":1,\"905\":1,\"907\":1,\"934\":6,\"939\":1,\"960\":1,\"961\":1,\"968\":2,\"983\":3,\"985\":3,\"988\":6,\"989\":2,\"990\":11,\"995\":1,\"998\":1,\"1024\":1,\"1025\":1,\"1027\":12,\"1028\":2,\"1029\":1,\"1032\":1,\"1038\":3}}],[\"才释放锁\",{\"1\":{\"987\":1}}],[\"才修复\",{\"1\":{\"897\":1}}],[\"才将\",{\"1\":{\"893\":1}}],[\"才可以实现高效的双向通信\",{\"1\":{\"845\":1}}],[\"才可以只装入部分程序到内存就开始运行\",{\"1\":{\"416\":1}}],[\"才可能导致异步性\",{\"1\":{\"127\":1}}],[\"才是对数据条件的过滤\",{\"1\":{\"383\":1}}],[\"才推荐进行分库分表\",{\"1\":{\"265\":1}}],[\"才需要关注写事件\",{\"1\":{\"893\":1}}],[\"才需要cpu的干预\",{\"1\":{\"181\":1}}],[\"才需要写回外存\",{\"1\":{\"163\":1}}],[\"才对他进行连接\",{\"1\":{\"151\":1}}],[\"才有资格申请更大编号的资源\",{\"1\":{\"148\":1}}],[\"才会关心\",{\"1\":{\"881\":1}}],[\"才会返回\",{\"1\":{\"758\":1}}],[\"才会采用主键索引来进行统计\",{\"1\":{\"387\":1}}],[\"才会进行读写\",{\"1\":{\"332\":1}}],[\"才会将任务放入该阻塞队列中\",{\"1\":{\"244\":1}}],[\"才会放入页表寄存器\",{\"1\":{\"157\":1}}],[\"才会修改turn\",{\"1\":{\"141\":1}}],[\"才会为k\",{\"1\":{\"139\":1}}],[\"才能操作\",{\"1\":{\"996\":1}}],[\"才能进行查询\",{\"1\":{\"988\":1}}],[\"才能得到结果\",{\"1\":{\"806\":1}}],[\"才能得到cpu的服务\",{\"1\":{\"132\":1}}],[\"才能发挥异步的优势\",{\"1\":{\"805\":1}}],[\"才能看下一个病人\",{\"1\":{\"805\":1}}],[\"才能执行\",{\"1\":{\"791\":1}}],[\"才能开始游戏\",{\"1\":{\"262\":1}}],[\"才能方便cpu操作\",{\"1\":{\"180\":1}}],[\"才能被cpu处理\",{\"1\":{\"126\":1}}],[\"空轮询导致\",{\"1\":{\"842\":1}}],[\"空轮询\",{\"1\":{\"792\":1}}],[\"空的\",{\"1\":{\"450\":1}}],[\"空\",{\"1\":{\"450\":1}}],[\"空时不会再消耗数据\",{\"1\":{\"218\":1}}],[\"空间扩展操作也就是重新分配内存\",{\"1\":{\"281\":1}}],[\"空间够的话\",{\"1\":{\"277\":1}}],[\"空间之前\",{\"1\":{\"277\":1}}],[\"空间优化\",{\"1\":{\"194\":1}}],[\"空间局部性通常是使用较大的高速缓存\",{\"1\":{\"417\":1}}],[\"空间局部性\",{\"1\":{\"161\":1,\"417\":1}}],[\"空闲检测\",{\"0\":{\"763\":1}}],[\"空闲列表\",{\"1\":{\"352\":1}}],[\"空闲\",{\"1\":{\"244\":1}}],[\"空闲时生存时间为60秒\",{\"1\":{\"244\":1}}],[\"空闲盘区链\",{\"1\":{\"170\":1}}],[\"空闲盘块链\",{\"1\":{\"170\":1}}],[\"空闲链表法\",{\"1\":{\"170\":1}}],[\"空闲表法\",{\"1\":{\"170\":1}}],[\"空闲分区按照容量递减的次序链接\",{\"1\":{\"155\":1}}],[\"空闲分区按照容量递增次序链接\",{\"1\":{\"155\":1}}],[\"空闲分区以地址递增的次序排列\",{\"1\":{\"155\":2}}],[\"空闲分区链\",{\"1\":{\"154\":1}}],[\"空闲分区表\",{\"1\":{\"154\":1}}],[\"空闲让进\",{\"1\":{\"140\":1}}],[\"空分复用技术\",{\"1\":{\"127\":1}}],[\"空调等\",{\"1\":{\"76\":1}}],[\"后台通过jsessionid从session中拿到用户信息\",{\"1\":{\"959\":1}}],[\"后台从session中拿到当前验证码\",{\"1\":{\"959\":1}}],[\"后台此时生成对应的验证码\",{\"1\":{\"959\":1}}],[\"后自动创建索引\",{\"1\":{\"950\":1}}],[\"后提供的\",{\"1\":{\"905\":1}}],[\"后设置成功结果\",{\"1\":{\"811\":1}}],[\"后才能发送剩余部分\",{\"1\":{\"751\":1}}],[\"后者功能上对标\",{\"1\":{\"662\":1}}],[\"后者过去分词表示被动更新\",{\"1\":{\"265\":1}}],[\"后获得\",{\"1\":{\"539\":1}}],[\"后两种在\",{\"1\":{\"523\":1}}],[\"后处理增强\",{\"1\":{\"652\":1}}],[\"后处理\",{\"1\":{\"650\":1}}],[\"后处理的添加顺序会对解析结果有影响\",{\"1\":{\"454\":1}}],[\"后处理器对应上方两种情况\",{\"1\":{\"491\":1}}],[\"后处理器对它做增强\",{\"1\":{\"454\":1}}],[\"后处理器的作用\",{\"0\":{\"475\":1}}],[\"后处理器运行分析\",{\"0\":{\"471\":1}}],[\"后处理器来完成\",{\"1\":{\"470\":1,\"477\":1}}],[\"后处理器作用\",{\"0\":{\"468\":1}}],[\"后处理器排序\",{\"0\":{\"464\":1}}],[\"后处理器完成的\",{\"1\":{\"454\":1}}],[\"后处理器\",{\"0\":{\"467\":1,\"474\":1},\"1\":{\"454\":1,\"458\":1,\"461\":1,\"659\":1}}],[\"后续的线程2\",{\"1\":{\"987\":1}}],[\"后续不会再监听事件\",{\"1\":{\"888\":1}}],[\"后续出站处理器的执行\",{\"1\":{\"816\":1}}],[\"后续这个\",{\"1\":{\"796\":1}}],[\"后续再没有用到多例的\",{\"1\":{\"500\":1}}],[\"后续版本中\",{\"0\":{\"362\":1}}],[\"后续讲解\",{\"1\":{\"127\":1}}],[\"后端需要对这个全局id校验来保证幂等操作\",{\"1\":{\"315\":1}}],[\"后端可以根据不同的状态去保证幂等性\",{\"1\":{\"315\":1}}],[\"后端的幂等性如何实现\",{\"1\":{\"315\":1}}],[\"后期可以开发小程序或者app\",{\"1\":{\"300\":1}}],[\"后期如果再加新品种的咖啡\",{\"1\":{\"63\":1}}],[\"后期如果需要coffee对象直接从工厂中获取即可\",{\"1\":{\"63\":1}}],[\"后\",{\"1\":{\"276\":1,\"644\":1,\"825\":1,\"901\":1}}],[\"后面会详细展开\",{\"1\":{\"834\":1}}],[\"后面解释\",{\"1\":{\"545\":1}}],[\"后面这些带有\",{\"1\":{\"451\":1}}],[\"后面在说明区别之处\",{\"1\":{\"277\":1}}],[\"后面讲解\",{\"1\":{\"158\":1}}],[\"后面不需要再排\",{\"1\":{\"155\":1}}],[\"后面的短作业需要等待很长时间\",{\"1\":{\"139\":1}}],[\"后都没有相邻的空闲分区\",{\"1\":{\"154\":1}}],[\"后各有一个相邻的空闲分区\",{\"1\":{\"154\":1}}],[\"后一种情况就需要进程切换\",{\"1\":{\"137\":1}}],[\"互转\",{\"0\":{\"855\":1}}],[\"互不干扰\",{\"1\":{\"720\":1}}],[\"互相协同工作\",{\"1\":{\"433\":1}}],[\"互相不阻塞\",{\"1\":{\"398\":1}}],[\"互相改变对方的结束条件\",{\"1\":{\"222\":1}}],[\"互补\",{\"1\":{\"338\":1}}],[\"互斥模式下使用\",{\"1\":{\"255\":2}}],[\"互斥锁实现缓存重建\",{\"1\":{\"988\":1}}],[\"互斥锁方案\",{\"1\":{\"987\":1}}],[\"互斥锁是一种独占锁\",{\"1\":{\"252\":1}}],[\"互斥锁+共享锁\",{\"1\":{\"252\":1}}],[\"互斥锁\",{\"1\":{\"252\":1,\"987\":1}}],[\"互斥条件\",{\"1\":{\"147\":1,\"221\":1}}],[\"互斥\",{\"1\":{\"140\":1}}],[\"互斥共享方式\",{\"1\":{\"127\":1}}],[\"互斥共享方式和同时共享方式\",{\"1\":{\"127\":1}}],[\"互为存在的条件\",{\"1\":{\"127\":1}}],[\"发出\",{\"1\":{\"835\":1}}],[\"发起了调用\",{\"1\":{\"803\":1}}],[\"发完即关\",{\"1\":{\"753\":1}}],[\"发一个包建立一次连接\",{\"1\":{\"752\":1}}],[\"发射调用目标方法\",{\"1\":{\"515\":1}}],[\"发现这个数量一定也大于1\",{\"1\":{\"996\":1}}],[\"发现没有环绕通知\",{\"1\":{\"546\":1}}],[\"发现有下一个环绕通知\",{\"1\":{\"546\":2}}],[\"发现它们是同一个对象\",{\"1\":{\"500\":1}}],[\"发现在dao层方法接口的参数中不用\",{\"1\":{\"365\":1}}],[\"发现\",{\"1\":{\"237\":1}}],[\"发现其方法最后是调用string\",{\"1\":{\"236\":1}}],[\"发生时\",{\"1\":{\"883\":1}}],[\"发生成功消息\",{\"1\":{\"761\":1}}],[\"发生异常时\",{\"1\":{\"617\":1}}],[\"发生了读写就绪事件\",{\"1\":{\"917\":1}}],[\"发生了事件\",{\"1\":{\"882\":1}}],[\"发生了一些没有预知的异常\",{\"1\":{\"406\":1}}],[\"发生了索引列的隐式转换\",{\"1\":{\"395\":1}}],[\"发生了中断\",{\"1\":{\"129\":1}}],[\"发生在多线程数组扩容的的情况下\",{\"1\":{\"329\":1}}],[\"发生缺页时只能选进程自己的物理块进行置换\",{\"1\":{\"164\":1}}],[\"发生死锁时\",{\"1\":{\"221\":1}}],[\"发生死锁的必要条件\",{\"1\":{\"221\":1}}],[\"发生死锁的时候一定有循环等待\",{\"1\":{\"147\":1}}],[\"发生死锁的进程一定是在阻塞态\",{\"1\":{\"147\":1}}],[\"发生死锁后\",{\"1\":{\"147\":1}}],[\"发生死锁至少有两个或两个以上的进程同时发生死锁\",{\"1\":{\"147\":1}}],[\"发送短信验证码成功\",{\"1\":{\"960\":1}}],[\"发送验证码\",{\"1\":{\"959\":1,\"960\":2}}],[\"发送数据不会管\",{\"1\":{\"898\":1}}],[\"发送数据时\",{\"1\":{\"894\":1}}],[\"发送缓冲区和接受缓冲区\",{\"1\":{\"779\":1}}],[\"发送信息方式如下\",{\"1\":{\"766\":1}}],[\"发送一个心跳包\",{\"1\":{\"764\":1}}],[\"发送拉群消息\",{\"1\":{\"761\":1}}],[\"发送内容随机的数据包\",{\"1\":{\"754\":1}}],[\"发送方的报文大小是\",{\"1\":{\"751\":1}}],[\"发送\",{\"1\":{\"751\":2,\"776\":1}}],[\"发送消息\",{\"1\":{\"134\":1,\"759\":1}}],[\"发送文件\",{\"1\":{\"127\":1}}],[\"发布出去\",{\"1\":{\"744\":1}}],[\"发布的数据类型是integer\",{\"1\":{\"743\":1,\"744\":1}}],[\"发布者就会被阻塞\",{\"1\":{\"745\":1}}],[\"发布者就会停\",{\"1\":{\"745\":1}}],[\"发布者调用submit方法发布数据就会被阻塞\",{\"1\":{\"745\":1}}],[\"发布者和处理器之间建立订阅关系\",{\"1\":{\"744\":1}}],[\"发布者订阅者之间建立订阅关系\",{\"1\":{\"743\":1}}],[\"发布者关闭了\",{\"1\":{\"743\":1,\"744\":2}}],[\"发布者\",{\"1\":{\"742\":1}}],[\"发布前先通过\",{\"1\":{\"703\":1}}],[\"发布事件\",{\"1\":{\"703\":1}}],[\"发布\",{\"0\":{\"79\":1},\"1\":{\"80\":1,\"650\":7}}],[\"微服务形式的\",{\"1\":{\"439\":1}}],[\"微观上可能是交替访问\",{\"1\":{\"127\":1}}],[\"微波炉\",{\"1\":{\"33\":1}}],[\"允许访问的地址\",{\"1\":{\"1015\":1}}],[\"允许访问的部分应该隔离出来可以访问\",{\"1\":{\"159\":1}}],[\"允许你在分片之上进行分布式的\",{\"1\":{\"927\":1}}],[\"允许你水平分割\",{\"1\":{\"927\":1}}],[\"允许在该类中使用\",{\"1\":{\"731\":1}}],[\"允许一个作业分多次调入内存\",{\"1\":{\"161\":1}}],[\"允许一个时间段内由多个进程同时对他们进行访问\",{\"1\":{\"127\":1}}],[\"允许死锁的产生\",{\"1\":{\"147\":1}}],[\"允许多个程序并发执行\",{\"1\":{\"127\":1}}],[\"允许用户通过程序间接使用\",{\"1\":{\"126\":1}}],[\"允许用户直接使用\",{\"1\":{\"126\":1}}],[\"摄像头\",{\"1\":{\"127\":1}}],[\"指大流程已经固定好了\",{\"1\":{\"461\":1}}],[\"指定redis的访问密码\",{\"1\":{\"1018\":1}}],[\"指定要连接的redis节点的端口\",{\"1\":{\"1018\":1}}],[\"指定要连接的redis节点的ip地址\",{\"1\":{\"1018\":1}}],[\"指定要连接的服务器和端口\",{\"1\":{\"835\":1}}],[\"指定配置启动\",{\"0\":{\"1015\":1},\"1\":{\"1013\":1}}],[\"指定\",{\"1\":{\"776\":2,\"787\":1,\"792\":1}}],[\"指定的销毁方法\",{\"1\":{\"495\":1}}],[\"指定的初始化方法\",{\"1\":{\"495\":1}}],[\"指定毫秒时间戳\",{\"1\":{\"441\":1}}],[\"指定访问数据源\",{\"1\":{\"372\":1}}],[\"指向内核为每一个进程所维护的该进程打开文件的记录表\",{\"1\":{\"407\":1}}],[\"指向undo\",{\"1\":{\"393\":1}}],[\"指向类元数据instanceklass\",{\"1\":{\"353\":1}}],[\"指向下一个盘块的指针也需要耗费少量的存储空间\",{\"1\":{\"169\":1}}],[\"指针\",{\"1\":{\"826\":1}}],[\"指针类型也一般为4\",{\"1\":{\"377\":1}}],[\"指针碰撞\",{\"1\":{\"352\":1}}],[\"指针只是指向字符数组的起始位置\",{\"1\":{\"276\":1}}],[\"指的是jdk提供的新的api\",{\"1\":{\"332\":1}}],[\"指的是使用普通的索引\",{\"1\":{\"266\":1}}],[\"指获取了cpu时间片运行中的状态\",{\"1\":{\"208\":1}}],[\"指该线程已经被创建\",{\"1\":{\"208\":1}}],[\"指该手机内存可以存放4\",{\"1\":{\"151\":1}}],[\"指在用户看来\",{\"1\":{\"167\":1}}],[\"指在某段时间间隔里\",{\"1\":{\"164\":1}}],[\"指请求分页存储管理中给进程分配的物理块的集合\",{\"1\":{\"164\":1}}],[\"指进程\",{\"1\":{\"138\":1}}],[\"指cpu\",{\"1\":{\"138\":1}}],[\"指令类型\",{\"1\":{\"769\":1}}],[\"指令来完成\",{\"1\":{\"237\":1}}],[\"指令是用硬件实现的\",{\"1\":{\"142\":1}}],[\"指令\",{\"1\":{\"128\":1,\"151\":1}}],[\"指两个或多个事件在同一时刻同时发生\",{\"1\":{\"127\":1}}],[\"指两个或多个事件在同一个时间间隔内发生\",{\"1\":{\"127\":1}}],[\"指挥者类\",{\"1\":{\"48\":1,\"49\":2}}],[\"虚拟主机\",{\"1\":{\"653\":1}}],[\"虚拟地址空间\",{\"1\":{\"419\":1}}],[\"虚拟地址空间大\",{\"1\":{\"413\":1}}],[\"虚拟地址到物理地址的转换要快\",{\"1\":{\"413\":1}}],[\"虚拟存储器地实现\",{\"1\":{\"419\":1}}],[\"虚拟存储器允许将一个作业分多次调入内存\",{\"1\":{\"419\":1}}],[\"虚拟存储器的实现方法\",{\"0\":{\"419\":1}}],[\"虚拟存储器\",{\"0\":{\"418\":1}}],[\"虚拟存储空间\",{\"1\":{\"406\":1}}],[\"虚拟存储技术\",{\"1\":{\"152\":1}}],[\"虚拟设备\",{\"1\":{\"185\":1}}],[\"虚拟性\",{\"1\":{\"161\":1}}],[\"虚拟内存类似于时间换空间\",{\"1\":{\"418\":1}}],[\"虚拟内存技术实际上就是建立了\",{\"1\":{\"417\":1}}],[\"虚拟内存技术\",{\"1\":{\"161\":1}}],[\"虚拟内存的实现有以下三种方式\",{\"1\":{\"419\":1}}],[\"虚拟内存的实现需要建立在离散分配的内存管理方式的基础上\",{\"1\":{\"161\":1}}],[\"虚拟内存的三个主要特征\",{\"1\":{\"161\":1}}],[\"虚拟内存的概念\",{\"0\":{\"161\":1}}],[\"虚拟内存实际的物理内存大小没有变\",{\"1\":{\"161\":1}}],[\"虚拟内存\",{\"0\":{\"418\":1},\"1\":{\"161\":1,\"415\":1}}],[\"虚拟处理器\",{\"1\":{\"127\":1}}],[\"虚拟技术分为\",{\"1\":{\"127\":1}}],[\"虚拟\",{\"1\":{\"127\":2}}],[\"虚拟机遇到一条new指令\",{\"1\":{\"352\":1}}],[\"虚拟机试图使用的最大内存量\",{\"1\":{\"105\":1}}],[\"虚拟机中的内存总量\",{\"1\":{\"105\":1}}],[\"虚拟机加载singletonholder\",{\"1\":{\"101\":1}}],[\"没法利用多路复用\",{\"1\":{\"878\":1}}],[\"没法支持很高的并发\",{\"1\":{\"433\":1}}],[\"没配置或没找到\",{\"1\":{\"617\":1}}],[\"没学过\",{\"1\":{\"276\":1}}],[\"没必要对全字段建立索引\",{\"1\":{\"266\":1,\"383\":1}}],[\"没必要让整个页表常驻内存\",{\"1\":{\"158\":1}}],[\"没有则返回nil\",{\"1\":{\"1028\":1}}],[\"没有类似mysql那么严格的约束\",{\"1\":{\"1001\":1}}],[\"没有多余key\",{\"1\":{\"984\":1}}],[\"没有此情况\",{\"1\":{\"901\":1}}],[\"没有充分利用多核\",{\"1\":{\"896\":1}}],[\"没有事件发生\",{\"1\":{\"890\":1}}],[\"没有移除\",{\"1\":{\"887\":1}}],[\"没有非阻塞模式\",{\"1\":{\"881\":1}}],[\"没有明显的性能提升\",{\"1\":{\"842\":1}}],[\"没有发生数据复制\",{\"1\":{\"826\":1}}],[\"没有成功传递到下一个\",{\"1\":{\"825\":1}}],[\"没有成员会返回\",{\"1\":{\"758\":1}}],[\"没有池化\",{\"1\":{\"820\":1}}],[\"没有任务\",{\"1\":{\"791\":1}}],[\"没有任何软件支持的计算机称为裸机\",{\"1\":{\"126\":1}}],[\"没有边界\",{\"1\":{\"766\":1}}],[\"没有写数据了\",{\"1\":{\"764\":1}}],[\"没有读到数据了\",{\"1\":{\"764\":1}}],[\"没有就可以判定为连接假死\",{\"1\":{\"764\":1}}],[\"没有实例变量\",{\"1\":{\"712\":1}}],[\"没有向下走\",{\"1\":{\"688\":1}}],[\"没有线程切换开销\",{\"1\":{\"424\":1}}],[\"没有线程来取是放不进去的\",{\"1\":{\"244\":1}}],[\"没有最大并发连接的限制\",{\"1\":{\"410\":1}}],[\"没有文件描述符限制\",{\"1\":{\"410\":1}}],[\"没有\",{\"1\":{\"383\":1,\"792\":1,\"972\":1}}],[\"没有一种放之四海皆准\",{\"1\":{\"360\":1}}],[\"没有返回到外部\",{\"1\":{\"349\":1}}],[\"没有人带\",{\"1\":{\"297\":1,\"311\":1}}],[\"没有竞争发生\",{\"1\":{\"249\":1}}],[\"没有上限\",{\"1\":{\"244\":1}}],[\"没有容量\",{\"1\":{\"244\":1}}],[\"没有核心线程\",{\"1\":{\"244\":1}}],[\"没有救急线程被创建\",{\"1\":{\"244\":1}}],[\"没有内部碎片\",{\"1\":{\"154\":1}}],[\"没有并发性就谈不上虚拟性\",{\"1\":{\"127\":1}}],[\"没能遇见你\",{\"1\":{\"37\":1}}],[\"存入redis\",{\"1\":{\"1042\":1}}],[\"存入数据\",{\"1\":{\"865\":1,\"1032\":1}}],[\"存击穿问题\",{\"1\":{\"990\":1}}],[\"存放在\",{\"1\":{\"277\":1}}],[\"存放在布隆过滤器的数据不容易删除\",{\"1\":{\"272\":1}}],[\"存放页表的起始地址\",{\"1\":{\"157\":1}}],[\"存放进程的上\",{\"1\":{\"152\":1}}],[\"存放起始地址\",{\"1\":{\"151\":1}}],[\"存放的位置都由进程控制\",{\"1\":{\"134\":1}}],[\"存在误判\",{\"1\":{\"984\":1}}],[\"存在误判可能\",{\"1\":{\"984\":1}}],[\"存在\",{\"1\":{\"682\":1,\"961\":1,\"962\":1,\"972\":1,\"990\":2}}],[\"存在自增id回溯的问题\",{\"1\":{\"391\":1}}],[\"存在问题\",{\"0\":{\"290\":1},\"1\":{\"998\":1}}],[\"存在数据库更新风暴的风险\",{\"1\":{\"267\":1}}],[\"存在非等号和等号混合判断条件时\",{\"1\":{\"266\":1}}],[\"存在精度损失问题\",{\"1\":{\"265\":1}}],[\"存在一种进程资源的循环等待链\",{\"1\":{\"147\":1}}],[\"存在的问题\",{\"0\":{\"102\":1}}],[\"存储在不同机器上\",{\"1\":{\"1008\":1}}],[\"存储方式\",{\"1\":{\"1008\":1}}],[\"存储的data\",{\"1\":{\"990\":1}}],[\"存储的value\",{\"1\":{\"990\":1}}],[\"存储的key\",{\"1\":{\"990\":2}}],[\"存储于本地代码\",{\"1\":{\"974\":1}}],[\"存储\",{\"1\":{\"790\":1,\"968\":1}}],[\"存储过程难以调试和扩展\",{\"1\":{\"267\":1}}],[\"存储parent\",{\"1\":{\"249\":1}}],[\"存储root和first\",{\"1\":{\"249\":1}}],[\"存储空间管理\",{\"1\":{\"170\":4}}],[\"存储空间的划分与初始化\",{\"1\":{\"170\":1}}],[\"存储空间利用率低\",{\"1\":{\"169\":1}}],[\"存储器利用率极低\",{\"1\":{\"154\":1}}],[\"存储器管理\",{\"1\":{\"126\":1}}],[\"存储管理所需要的各种信息\",{\"1\":{\"131\":1}}],[\"进而提高性能\",{\"1\":{\"927\":1}}],[\"进而直接将单个小文件读取到内存中处理\",{\"1\":{\"290\":1}}],[\"进一步降低tomcat服务的压力\",{\"1\":{\"955\":1}}],[\"进一步优化\",{\"1\":{\"905\":2}}],[\"进一步理解代理增强基于方法重写\",{\"1\":{\"686\":1}}],[\"进一步熟悉注解元数据\",{\"1\":{\"483\":1}}],[\"进一步提高了系统的并发度\",{\"1\":{\"135\":1}}],[\"进入redis安装目录\",{\"1\":{\"1015\":1}}],[\"进入redis目录\",{\"1\":{\"1012\":1}}],[\"进入死循环\",{\"1\":{\"791\":1}}],[\"进入了控制器\",{\"1\":{\"647\":1}}],[\"进入环绕通知2\",{\"1\":{\"546\":1}}],[\"进入环绕通知1\",{\"1\":{\"546\":1}}],[\"进入代理方法\",{\"1\":{\"515\":1}}],[\"进入内核态\",{\"1\":{\"406\":1}}],[\"进入华为也是我一直以来的一个梦想\",{\"1\":{\"307\":1}}],[\"进入aqs队列park阻塞\",{\"1\":{\"261\":1}}],[\"进入下一轮循环\",{\"1\":{\"249\":1}}],[\"进入阻塞状态\",{\"1\":{\"208\":1}}],[\"进入区的检查和上锁两个处理不是一气呵成的\",{\"1\":{\"141\":1}}],[\"进入区\",{\"1\":{\"140\":1}}],[\"进行查询之后\",{\"1\":{\"988\":1}}],[\"进行查找\",{\"1\":{\"695\":1}}],[\"进行对比\",{\"1\":{\"987\":1}}],[\"进行分隔\",{\"1\":{\"859\":1}}],[\"进行增强\",{\"1\":{\"842\":1}}],[\"进行切片\",{\"1\":{\"826\":1}}],[\"进行切片成多个\",{\"1\":{\"826\":1}}],[\"进行一些初始操作\",{\"1\":{\"826\":1}}],[\"进行一些定义参数的配置\",{\"1\":{\"296\":1}}],[\"进行了扩展\",{\"1\":{\"806\":1}}],[\"进行处理\",{\"1\":{\"744\":1}}],[\"进行装配\",{\"1\":{\"695\":1}}],[\"进行筛选\",{\"1\":{\"688\":2}}],[\"进行\",{\"1\":{\"650\":1,\"791\":1}}],[\"进行配置\",{\"1\":{\"617\":1}}],[\"进行位与运行后如果值为0\",{\"1\":{\"441\":1}}],[\"进行排序\",{\"1\":{\"383\":1}}],[\"进行sql编写\",{\"1\":{\"366\":1}}],[\"进行字符串拼接\",{\"1\":{\"366\":1}}],[\"进行相应的处理\",{\"1\":{\"333\":1}}],[\"进行相应编码\",{\"1\":{\"278\":1}}],[\"进行哈希取余\",{\"1\":{\"290\":1}}],[\"进行链表转为红黑树\",{\"1\":{\"249\":1}}],[\"进行多次中断处理才能完成\",{\"1\":{\"181\":1}}],[\"进行越界检查\",{\"1\":{\"152\":1}}],[\"进行封装\",{\"1\":{\"44\":1}}],[\"进程只有在调用一定的方法后\",{\"1\":{\"410\":1}}],[\"进程只作为除cpu之外的系统资源的分配单元\",{\"1\":{\"135\":1}}],[\"进程id命令查看线程状态有java层面死锁线程信息\",{\"1\":{\"221\":1}}],[\"进程对已获得的资源在未使用完成前不能被抢占\",{\"1\":{\"221\":1}}],[\"进程也必须阻塞等待\",{\"1\":{\"185\":1}}],[\"进程运行过程中动态申请设备资源\",{\"1\":{\"185\":1}}],[\"进程运行前为其分配全部所需资源\",{\"1\":{\"185\":1}}],[\"进程前将各页面装入各内存块中\",{\"1\":{\"160\":1}}],[\"进程未执行时\",{\"1\":{\"157\":1}}],[\"进程根据页框大小拆分为一个个区域\",{\"1\":{\"156\":1}}],[\"进程回退法\",{\"1\":{\"150\":1}}],[\"进程实际访问页面的集合\",{\"1\":{\"164\":1}}],[\"进程实际使用资源的顺序可能和编号递增顺序不一致\",{\"1\":{\"148\":1}}],[\"进程实体是静态的\",{\"1\":{\"131\":1}}],[\"进程实体的概念\",{\"1\":{\"131\":1}}],[\"进程实体\",{\"1\":{\"131\":2}}],[\"进程c需要用到a资源1和2\",{\"1\":{\"148\":1}}],[\"进程在运行期间发现缺页时才将所缺页面调入内存\",{\"1\":{\"164\":1}}],[\"进程在运行前一次申请完它所需要的全部资源\",{\"1\":{\"148\":1}}],[\"进程在内存与磁盘间动态调度\",{\"1\":{\"153\":1}}],[\"进程在cpu执行的时间\",{\"1\":{\"138\":1}}],[\"进程推进顺序非法\",{\"1\":{\"147\":1}}],[\"进程已经至少保持了一个资源\",{\"1\":{\"147\":1}}],[\"进程所获得的资源在未使用完之前\",{\"1\":{\"147\":1}}],[\"进程会调用wait里面的block原语进行自我阻塞\",{\"1\":{\"143\":1}}],[\"进程异步是指\",{\"1\":{\"140\":1}}],[\"进程互斥的实现方式\",{\"1\":{\"142\":1}}],[\"进程互斥的硬件实现方法\",{\"0\":{\"142\":1}}],[\"进程互斥的软件实现方法\",{\"0\":{\"141\":1}}],[\"进程互斥需要遵循的原则\",{\"1\":{\"140\":1}}],[\"进程互斥\",{\"0\":{\"140\":1},\"1\":{\"140\":2}}],[\"进程同步是为了结局进程异步的问题\",{\"1\":{\"140\":1}}],[\"进程同步\",{\"0\":{\"140\":1},\"1\":{\"140\":1,\"143\":1,\"144\":1}}],[\"进程有各自的优先级\",{\"1\":{\"139\":1}}],[\"进程为其服务\",{\"1\":{\"139\":1}}],[\"进程长时间得不到服务\",{\"1\":{\"139\":1}}],[\"进程到来\",{\"1\":{\"139\":1}}],[\"进程到达的先后顺序进行服务\",{\"1\":{\"139\":1}}],[\"进程优先得到服务\",{\"1\":{\"139\":1}}],[\"进程等待i\",{\"1\":{\"138\":1}}],[\"进程切换比较频繁\",{\"1\":{\"139\":1}}],[\"进程切换是有代价的\",{\"1\":{\"137\":1}}],[\"进程切换主要完成了\",{\"1\":{\"137\":1}}],[\"进程切换\",{\"1\":{\"137\":1}}],[\"进程调度指的是从就绪队列中选中一个要执行的进程\",{\"1\":{\"137\":1}}],[\"进程调度的方式\",{\"1\":{\"137\":1}}],[\"进程调度的时机\",{\"0\":{\"137\":1},\"1\":{\"137\":1}}],[\"进程调度是操作系统中最基本的一种调度\",{\"1\":{\"136\":1}}],[\"进程调度\",{\"1\":{\"136\":1,\"139\":7}}],[\"进程内各线程也可以并发\",{\"1\":{\"135\":1}}],[\"进程通过操作系统提供的\",{\"1\":{\"134\":1}}],[\"进程通信方法\",{\"1\":{\"134\":1}}],[\"进程通信是指进程之间信息交换\",{\"1\":{\"134\":1}}],[\"进程通信概念\",{\"1\":{\"134\":1}}],[\"进程通信\",{\"0\":{\"134\":1}}],[\"进程之间的数据交换以格式化消息为单位\",{\"1\":{\"134\":1}}],[\"进程控制相关的原语\",{\"1\":{\"133\":1}}],[\"进程控制是使用原语进行的\",{\"1\":{\"133\":1}}],[\"进程控制的主要功能就是对系统中的所有进程实施有效的管理\",{\"1\":{\"133\":1}}],[\"进程控制\",{\"0\":{\"133\":1},\"1\":{\"133\":1}}],[\"进程状态的转换\",{\"1\":{\"132\":1}}],[\"进程正在从系统中撤销\",{\"1\":{\"132\":1}}],[\"进程正在被创建\",{\"1\":{\"132\":1}}],[\"进程特征\",{\"1\":{\"131\":1}}],[\"进程是分配系统资源的单位\",{\"1\":{\"134\":1}}],[\"进程是程序的一次执行\",{\"1\":{\"132\":1}}],[\"进程是程序的一次执行过程\",{\"1\":{\"131\":1}}],[\"进程是资源分配的基本单位\",{\"1\":{\"135\":1}}],[\"进程是资源分配和调度的基本单位\",{\"1\":{\"135\":1}}],[\"进程是资源分配\",{\"1\":{\"131\":1}}],[\"进程是能够独立运行\",{\"1\":{\"131\":1}}],[\"进程是动态的\",{\"1\":{\"131\":1}}],[\"进程是一个程序的执行过程\",{\"1\":{\"126\":1}}],[\"进程映像\",{\"1\":{\"131\":1}}],[\"进程的最后一个页面可能没有一个页框那么大\",{\"1\":{\"156\":1}}],[\"进程的指令要访问某个地址的时候\",{\"1\":{\"152\":1}}],[\"进程的运行原理\",{\"1\":{\"151\":1}}],[\"进程的运行时间是由用户提供的\",{\"1\":{\"139\":1}}],[\"进程的偏好程度\",{\"1\":{\"139\":1}}],[\"进程的响应比\",{\"1\":{\"139\":1}}],[\"进程的等待时间和要求服务的时间\",{\"1\":{\"139\":1}}],[\"进程的基本状态\",{\"1\":{\"132\":1}}],[\"进程的状态\",{\"0\":{\"132\":1}}],[\"进程的组织\",{\"1\":{\"131\":1}}],[\"进程的定义\",{\"1\":{\"131\":1}}],[\"进程的执行不是一贯到底的\",{\"1\":{\"127\":1}}],[\"进程\",{\"0\":{\"131\":1},\"1\":{\"131\":1,\"139\":2}}],[\"补充自定义类型转换器\",{\"1\":{\"644\":1}}],[\"补充模型数据\",{\"1\":{\"644\":1}}],[\"补充关于时间片的大小\",{\"1\":{\"139\":1}}],[\"补充\",{\"1\":{\"126\":1,\"139\":1}}],[\"他拿到的对象实际上是不同的对象\",{\"1\":{\"998\":1}}],[\"他查询缓存没有命中\",{\"1\":{\"987\":1}}],[\"他查询缓存数据并不存在\",{\"1\":{\"982\":1}}],[\"他先把缓存删了\",{\"1\":{\"982\":1}}],[\"他确实可以使用对应路径的拦截\",{\"1\":{\"970\":1}}],[\"他还是另一个著名网络应用框架\",{\"1\":{\"840\":1}}],[\"他有request和cancel\",{\"1\":{\"745\":1}}],[\"他只告诉进程哪些fd刚刚变为就绪态\",{\"1\":{\"410\":1}}],[\"他没有最大连接数的限制\",{\"1\":{\"410\":1}}],[\"他将用户传入的fd数组拷贝到内核空间\",{\"1\":{\"410\":1}}],[\"他的操作逻辑是在操作时\",{\"1\":{\"996\":1}}],[\"他的操作就是安全的\",{\"1\":{\"996\":1}}],[\"他的基本原理就是select\",{\"1\":{\"409\":1}}],[\"他的寻址空间\",{\"1\":{\"406\":1}}],[\"他就会自动被删除~\",{\"1\":{\"1024\":1}}],[\"他就会进行自动配置\",{\"1\":{\"721\":1}}],[\"他就会将数据从kernel中拷贝到用户内存中\",{\"1\":{\"409\":1}}],[\"他就知道数据还没有准备好\",{\"1\":{\"409\":1}}],[\"他会经历两个阶段\",{\"1\":{\"409\":1}}],[\"他会阻断其他共享锁和排他锁\",{\"1\":{\"398\":1}}],[\"他是在beanfactory的基础上构建的\",{\"1\":{\"707\":1}}],[\"他是一个索引值\",{\"1\":{\"407\":1}}],[\"他是计算机系统中最基本的系统软件\",{\"1\":{\"125\":1}}],[\"他们在扣减时\",{\"1\":{\"997\":1}}],[\"他们从逻辑上讲他们是同一张表\",{\"1\":{\"992\":1}}],[\"他们就能够满负荷工作\",{\"1\":{\"805\":1}}],[\"他们不需要查找具体的行\",{\"1\":{\"387\":1}}],[\"他们共同的缺点是什么\",{\"1\":{\"355\":1}}],[\"他们的操作更多的是依赖于内存来操作\",{\"1\":{\"1008\":1}}],[\"他们的构造方法对\",{\"1\":{\"771\":1}}],[\"他们的作用一样\",{\"1\":{\"709\":1}}],[\"他们的线程状态都是timed\",{\"1\":{\"216\":1}}],[\"他们的插座如下图最左边\",{\"1\":{\"39\":1}}],[\"以秒为单位\",{\"1\":{\"992\":1}}],[\"以避免守护线程意外结束\",{\"1\":{\"908\":1}}],[\"以前的重构数据的逻辑\",{\"1\":{\"987\":1}}],[\"以前有同学写过这样的代码\",{\"1\":{\"889\":1}}],[\"以前开发的系统存在满足新系统功能需求的类\",{\"1\":{\"43\":1}}],[\"以下这段代码需要修改为\",{\"1\":{\"998\":1}}],[\"以下的框架都使用了\",{\"1\":{\"841\":1}}],[\"以下是管理bean时常用的一些注解\",{\"1\":{\"709\":1}}],[\"以下是面向面试\",{\"1\":{\"250\":1}}],[\"以一个简单的实现为例\",{\"1\":{\"796\":1}}],[\"以一个段\",{\"1\":{\"751\":1}}],[\"以解决粘包为例\",{\"1\":{\"753\":1}}],[\"以解决难以找到一块连续的大内存空间的问题\",{\"1\":{\"413\":1}}],[\"以太网的\",{\"1\":{\"751\":1}}],[\"以最快捷\",{\"1\":{\"730\":1}}],[\"以达到快速构建项目\",{\"1\":{\"726\":1}}],[\"以达到动态表名的效果\",{\"1\":{\"368\":1}}],[\"以非事务方式运行\",{\"1\":{\"720\":2}}],[\"以完成一个完整的业务操作\",{\"1\":{\"720\":1}}],[\"以支持判断事件类型\",{\"1\":{\"703\":1}}],[\"以它为准加载\",{\"1\":{\"682\":1}}],[\"以单例注入多例为例\",{\"1\":{\"500\":1}}],[\"以访问次数的多少作为参考点\",{\"1\":{\"429\":1}}],[\"以便添加更多的处理器\",{\"1\":{\"834\":1,\"835\":1}}],[\"以便后续使用\",{\"1\":{\"791\":1}}],[\"以便对后续\",{\"1\":{\"454\":1}}],[\"以便为即将调入的页面让出空间\",{\"1\":{\"420\":1}}],[\"以便能将作业分先后地多次装入内存\",{\"1\":{\"419\":1}}],[\"以使进程能继续执行下去\",{\"1\":{\"418\":1}}],[\"以使他们获得竞争处理机的权利\",{\"1\":{\"136\":1}}],[\"以段为单位\",{\"1\":{\"413\":1}}],[\"以段为单位进行分配\",{\"1\":{\"159\":1}}],[\"以二级页表而言\",{\"1\":{\"413\":1}}],[\"以块为单位\",{\"1\":{\"413\":1}}],[\"以read举例\",{\"1\":{\"409\":1}}],[\"以t\",{\"1\":{\"368\":1}}],[\"以免其他开发环境下出现bug\",{\"1\":{\"365\":1}}],[\"以免错误的使用到它\",{\"1\":{\"178\":1}}],[\"以串并行分类\",{\"1\":{\"360\":1}}],[\"以减少搜索时间\",{\"1\":{\"327\":1}}],[\"以防越界\",{\"1\":{\"323\":1}}],[\"以该节点结尾的单词数+1\",{\"1\":{\"282\":1}}],[\"以满足修改所需的大小\",{\"1\":{\"277\":1}}],[\"以学生和成绩的关系为例\",{\"1\":{\"267\":1}}],[\"以上命令除了incrbyfloat\",{\"1\":{\"1025\":1}}],[\"以上逻辑的核心含义是\",{\"1\":{\"997\":1}}],[\"以上两种\",{\"1\":{\"588\":1,\"596\":1,\"616\":1}}],[\"以上\",{\"1\":{\"266\":1,\"383\":1}}],[\"以提高查询性能\",{\"1\":{\"265\":1}}],[\"以提供用户和其他软件方便的接口和环境\",{\"1\":{\"125\":1}}],[\"以后通过调段功能和段的置换功能将暂时不运行的段调出\",{\"1\":{\"419\":1}}],[\"以后\",{\"1\":{\"419\":1,\"820\":1}}],[\"以后在第一次使用时才会真正创建\",{\"1\":{\"249\":1}}],[\"以后还可以修改\",{\"1\":{\"244\":1}}],[\"以保证能够取到上一行的前面的值\",{\"1\":{\"194\":1}}],[\"以递减的形式更新\",{\"1\":{\"194\":1}}],[\"以及在启动类添加配置\",{\"1\":{\"998\":1}}],[\"以及为原生\",{\"1\":{\"790\":1}}],[\"以及类路径下的\",{\"1\":{\"660\":1}}],[\"以及同一时间戳下序列号自增\",{\"1\":{\"442\":1}}],[\"以及用于服务器时钟回拨判断\",{\"1\":{\"441\":1}}],[\"以及后面看底层啥啥啥的\",{\"1\":{\"310\":1}}],[\"以及常驻人口多条件复合查询接口\",{\"1\":{\"296\":1}}],[\"以及字符串的长度有关\",{\"1\":{\"279\":1}}],[\"以及数据的大小\",{\"1\":{\"279\":1}}],[\"以及前面的区域\",{\"1\":{\"194\":1}}],[\"以及剩余的分区大小和起始地址等信息\",{\"1\":{\"154\":1}}],[\"以此达到主从库的数据一致性\",{\"1\":{\"436\":1}}],[\"以此实现设备保护功能\",{\"1\":{\"183\":1}}],[\"以此决定是否答应资源分配请求\",{\"1\":{\"149\":1}}],[\"以\",{\"1\":{\"173\":1,\"546\":1,\"627\":1,\"643\":1,\"889\":1}}],[\"以阻止其他进程同时进入临界区\",{\"1\":{\"140\":1}}],[\"以实现进程的并发执行\",{\"1\":{\"136\":1}}],[\"以不可预知的速度向前推进\",{\"1\":{\"127\":1}}],[\"无序\",{\"1\":{\"1029\":1}}],[\"无序长字符串等\",{\"1\":{\"384\":1}}],[\"无数的请求访问会在瞬间给数据库带来巨大的冲击\",{\"1\":{\"987\":1}}],[\"无关\",{\"1\":{\"828\":1}}],[\"无参\",{\"1\":{\"826\":1}}],[\"无参的\",{\"1\":{\"123\":1}}],[\"无效写操作较多\",{\"1\":{\"982\":1}}],[\"无效时处理\",{\"1\":{\"792\":1}}],[\"无效\",{\"1\":{\"792\":1}}],[\"无效io大大减少\",{\"1\":{\"396\":1}}],[\"无锁队列\",{\"1\":{\"791\":1}}],[\"无意义\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"无鱼\",{\"1\":{\"766\":1}}],[\"无鱼肉亦可\",{\"1\":{\"766\":1}}],[\"无鸡\",{\"1\":{\"766\":1}}],[\"无鸡鸭亦可\",{\"1\":{\"766\":1}}],[\"无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金\",{\"1\":{\"766\":1}}],[\"无循环依赖时\",{\"1\":{\"542\":1}}],[\"无非就是利用了多态\",{\"1\":{\"516\":1}}],[\"无论是他的put方法和他的get方法\",{\"1\":{\"961\":1}}],[\"无论是否存在\",{\"1\":{\"959\":1}}],[\"无论是否找到key\",{\"1\":{\"436\":1}}],[\"无论有没有\",{\"1\":{\"791\":1}}],[\"无论哪个原语\",{\"1\":{\"133\":1}}],[\"无界阻塞队列\",{\"1\":{\"242\":1}}],[\"无阻塞并发\",{\"1\":{\"231\":1}}],[\"无法利用\",{\"1\":{\"904\":1}}],[\"无法保证把\",{\"1\":{\"893\":1}}],[\"无法保存新节点的长度\",{\"1\":{\"280\":1}}],[\"无法进行数据读写\",{\"1\":{\"764\":1}}],[\"无法获得参数名\",{\"1\":{\"572\":1}}],[\"无法及时处理客户端请求\",{\"1\":{\"437\":1}}],[\"无法再装入新的页\",{\"1\":{\"418\":1}}],[\"无法使用覆盖索引\",{\"1\":{\"388\":1}}],[\"无法对单独的一个键或者几个索引键进行判断\",{\"1\":{\"381\":1}}],[\"无法修改\",{\"1\":{\"332\":1}}],[\"无法唤醒指定的线程\",{\"1\":{\"219\":1}}],[\"无法正常使用的扇区\",{\"1\":{\"178\":1}}],[\"无法破坏\",{\"1\":{\"148\":1}}],[\"无环图目录结构\",{\"1\":{\"168\":1}}],[\"无结构文件\",{\"1\":{\"167\":1}}],[\"无需过分关心\",{\"1\":{\"927\":1}}],[\"无需等\",{\"1\":{\"877\":1}}],[\"无需从头编写练习\",{\"1\":{\"783\":1}}],[\"无需外部依赖servlet容器\",{\"1\":{\"726\":1}}],[\"无需特殊设置\",{\"1\":{\"668\":1}}],[\"无需synchronized\",{\"1\":{\"249\":1}}],[\"无需synchronized创建成功\",{\"1\":{\"249\":1}}],[\"无需在作业运行时一次性全部装入内存\",{\"1\":{\"161\":1}}],[\"无需操作系统干预\",{\"1\":{\"135\":1}}],[\"无外部碎片\",{\"1\":{\"154\":2}}],[\"无须对原工厂进行任何修改\",{\"1\":{\"70\":1}}],[\"无须知道产品的具体创建过程\",{\"1\":{\"70\":1}}],[\"系统是几乎撑不住的\",{\"1\":{\"975\":1}}],[\"系统也需要\",{\"1\":{\"974\":1}}],[\"系统也能作为最后论文的创新点或贡献之一\",{\"1\":{\"300\":1}}],[\"系统异步\",{\"1\":{\"906\":1}}],[\"系统通过\",{\"1\":{\"906\":1}}],[\"系统资源占用较大\",{\"1\":{\"331\":1}}],[\"系统资源是分配给进程的\",{\"1\":{\"135\":1}}],[\"系统的组成如下\",{\"1\":{\"184\":1}}],[\"系统的开销减小\",{\"1\":{\"135\":1}}],[\"系统根据fcb中记录的信息来判断该用户是否有相应的访问权限\",{\"1\":{\"183\":1}}],[\"系统会扫描\",{\"1\":{\"950\":1}}],[\"系统会使用httpmessageconverter或者自定义的httpmessageconverter将请求的body中的json字符串转换成java对象\",{\"1\":{\"731\":1,\"737\":1}}],[\"系统会切换到硬盘读写的中断处理程序中执行后边的操作等\",{\"1\":{\"406\":1}}],[\"系统会自动采用占用空间小的二级索引来进行统计\",{\"1\":{\"387\":1}}],[\"系统会自动将该设备信息加入数据库\",{\"1\":{\"296\":1}}],[\"系统会检查该用户所属的分组是否有相应的访问权限\",{\"1\":{\"173\":1}}],[\"系统会根据段内地址自动划分页号和页内偏移地址\",{\"1\":{\"160\":1}}],[\"系统管理员\",{\"1\":{\"173\":1}}],[\"系统要根据文件名搜索目录\",{\"1\":{\"168\":1}}],[\"系统要花大量的时间来处理分页\",{\"1\":{\"164\":1}}],[\"系统要用什么样的数据结构记录内存的使用情况\",{\"1\":{\"154\":1}}],[\"系统区通常位于内存的低地址部分\",{\"1\":{\"154\":1}}],[\"系统将内存中某些进程暂时换出外存\",{\"1\":{\"153\":1}}],[\"系统还是有可能重新回到安全状态\",{\"1\":{\"149\":1}}],[\"系统就进入了不安全状态\",{\"1\":{\"149\":1}}],[\"系统就是安全状态\",{\"1\":{\"149\":1}}],[\"系统进程优先级高于用于进程\",{\"1\":{\"139\":1}}],[\"系统吞吐量\",{\"1\":{\"138\":1}}],[\"系统开销会增大\",{\"1\":{\"139\":1}}],[\"系统开销很小\",{\"1\":{\"135\":1}}],[\"系统开销小但是无法及时处理紧急任务\",{\"1\":{\"137\":1}}],[\"系统开销小\",{\"1\":{\"135\":1}}],[\"系统开销大\",{\"1\":{\"135\":2}}],[\"系统为每个运行的程序配置一个数据结构\",{\"1\":{\"131\":1}}],[\"系统调用的机制核心使用了操作系统为用户特别开放的一个中断来实现\",{\"1\":{\"406\":1}}],[\"系统调用的过程\",{\"1\":{\"130\":1}}],[\"系统调用将被阻塞\",{\"1\":{\"134\":2}}],[\"系统调用和库函数的区别\",{\"1\":{\"130\":1}}],[\"系统调用是操作系统提供给应用程序使用的接口\",{\"1\":{\"130\":1}}],[\"系统调用概念\",{\"1\":{\"130\":1}}],[\"系统调用\",{\"0\":{\"130\":1},\"1\":{\"406\":1}}],[\"系统更加庞大\",{\"1\":{\"121\":1}}],[\"系统中对象数据的存储\",{\"1\":{\"422\":1}}],[\"系统中设置一个页表寄存器\",{\"1\":{\"157\":1}}],[\"系统中找不出任何一个安全序列\",{\"1\":{\"149\":1}}],[\"系统中打印机的数量为1\",{\"1\":{\"143\":1}}],[\"系统中只有一个程序正在执行\",{\"1\":{\"127\":1}}],[\"系统中的各种共享资源都由操作系统统一掌管\",{\"1\":{\"130\":1}}],[\"系统中的某些资源\",{\"1\":{\"127\":2}}],[\"系统中的资源可供内存中多个并发执行的进程共同使用\",{\"1\":{\"127\":1}}],[\"系统中提供了产品的类库\",{\"1\":{\"76\":1}}],[\"系统中有多个产品族\",{\"1\":{\"76\":1}}],[\"炒蒜蓉菜心\",{\"1\":{\"120\":1}}],[\"炒手撕包菜\",{\"1\":{\"120\":1}}],[\"炒啊炒啊炒到熟啊\",{\"1\":{\"120\":1}}],[\"炒菜的步骤是固定的\",{\"1\":{\"120\":1}}],[\"炒菜\",{\"1\":{\"120\":1}}],[\"倒调味料是不一样\",{\"1\":{\"120\":1}}],[\"倒调味料\",{\"1\":{\"120\":1}}],[\"倒调料品\",{\"1\":{\"120\":1}}],[\"倒油\",{\"1\":{\"120\":2}}],[\"倒蔬菜是不一样的\",{\"1\":{\"120\":1}}],[\"倒蔬菜\",{\"1\":{\"120\":2}}],[\"热点文章的点赞数和转发数等等\",{\"1\":{\"422\":1}}],[\"热爱运动等方面拓展\",{\"1\":{\"301\":1}}],[\"热油是一样的\",{\"1\":{\"120\":1}}],[\"热油\",{\"1\":{\"120\":3}}],[\"热狗\",{\"1\":{\"33\":1}}],[\"包装了\",{\"1\":{\"816\":1}}],[\"包装类型的常量池技术\",{\"0\":{\"320\":1}}],[\"包装类型比如integer是不可变类\",{\"1\":{\"230\":1}}],[\"包装类常量池\",{\"1\":{\"238\":1}}],[\"包一层异常\",{\"1\":{\"812\":1}}],[\"包路径扫描\",{\"1\":{\"731\":1}}],[\"包\",{\"1\":{\"448\":1,\"460\":1,\"469\":1,\"476\":1,\"489\":1,\"494\":1,\"498\":1,\"502\":1,\"522\":1,\"538\":1,\"560\":1,\"567\":1,\"578\":1,\"584\":1,\"595\":1,\"599\":1,\"607\":1,\"615\":1,\"653\":1,\"677\":1,\"681\":1,\"685\":1,\"690\":1,\"694\":1,\"698\":1,\"702\":1}}],[\"包括分配主分片或者副本\",{\"1\":{\"929\":1}}],[\"包括分区号\",{\"1\":{\"154\":1}}],[\"包括普通任务和定时任务\",{\"1\":{\"791\":1}}],[\"包括url\",{\"1\":{\"736\":1}}],[\"包括applicationcontext\",{\"1\":{\"708\":1}}],[\"包括\",{\"1\":{\"682\":1,\"787\":1,\"1017\":1,\"1031\":1}}],[\"包括控制器方法对象\",{\"1\":{\"561\":1}}],[\"包括请求路径\",{\"1\":{\"561\":1}}],[\"包括5位\",{\"1\":{\"440\":1}}],[\"包括原理\",{\"1\":{\"355\":1}}],[\"包括程序代码中定义的各种类型的字段\",{\"1\":{\"353\":1}}],[\"包括当前节点\",{\"1\":{\"282\":1}}],[\"包括缓存回滚\",{\"1\":{\"268\":1}}],[\"包括自己\",{\"1\":{\"252\":1}}],[\"包括进行数据库操作时\",{\"1\":{\"246\":1}}],[\"包括设置设备寄存器\",{\"1\":{\"182\":1}}],[\"包括线程切换\",{\"1\":{\"135\":1}}],[\"包括用于判断的逻辑方法和需要子类重写的空方法两种\",{\"1\":{\"119\":1}}],[\"包含对各种数据库的集成\",{\"1\":{\"1036\":1}}],[\"包含通知和切点\",{\"1\":{\"662\":1}}],[\"包含以下三个\",{\"1\":{\"662\":1}}],[\"包含以下主要角色\",{\"1\":{\"40\":1}}],[\"包含一个\",{\"1\":{\"528\":2}}],[\"包含的元素数量较少\",{\"1\":{\"278\":1}}],[\"包含车架\",{\"1\":{\"49\":1}}],[\"钩子方法\",{\"1\":{\"119\":1}}],[\"办理具体业务\",{\"1\":{\"118\":1}}],[\"取值是\",{\"1\":{\"790\":1}}],[\"取二者的较小值\",{\"1\":{\"776\":1}}],[\"取得\",{\"1\":{\"528\":1}}],[\"取决于具体程序\",{\"1\":{\"413\":1}}],[\"取决于计算机的字长\",{\"1\":{\"151\":1}}],[\"取消任务\",{\"1\":{\"806\":1}}],[\"取消或关闭时会导致这个\",{\"1\":{\"792\":1}}],[\"取消\",{\"1\":{\"315\":1,\"890\":1}}],[\"取消访问检查\",{\"1\":{\"103\":1}}],[\"取数据\",{\"1\":{\"151\":1}}],[\"取款或者转账等\",{\"1\":{\"118\":1}}],[\"取号\",{\"1\":{\"118\":1}}],[\"负数\",{\"1\":{\"1025\":1}}],[\"负载均衡到下游tomcat服务器\",{\"1\":{\"955\":1}}],[\"负载因子\",{\"1\":{\"328\":3}}],[\"负载为0时\",{\"1\":{\"328\":1}}],[\"负载\",{\"1\":{\"328\":1}}],[\"负\",{\"1\":{\"116\":1}}],[\"负责发布事件\",{\"1\":{\"837\":1}}],[\"负责入站数据的分配\",{\"1\":{\"781\":1}}],[\"负责向服务器发送各种消息\",{\"1\":{\"759\":1}}],[\"负责接收用户在控制台的输入\",{\"1\":{\"759\":1}}],[\"负责接触正在访问临界资源的标志\",{\"1\":{\"140\":1}}],[\"负责收集容器中的监听器\",{\"1\":{\"703\":1}}],[\"负责实现对各种各样的\",{\"1\":{\"643\":1}}],[\"负责建立请求与控制器之间的映射关系\",{\"1\":{\"643\":1}}],[\"负责处理返回值\",{\"1\":{\"590\":1}}],[\"负责解析参数\",{\"1\":{\"590\":1}}],[\"负责参数名解析\",{\"1\":{\"590\":1}}],[\"负责对象绑定\",{\"1\":{\"590\":1}}],[\"负责对硬件设备的具体控制\",{\"1\":{\"182\":1}}],[\"负责获取\",{\"1\":{\"470\":1}}],[\"负责监控redis\",{\"1\":{\"433\":1}}],[\"负责模块\",{\"0\":{\"296\":1}}],[\"负责程序的逻辑地址与物理地址的转换\",{\"1\":{\"152\":1}}],[\"负责检查是否可以进入临界区\",{\"1\":{\"140\":1}}],[\"负责给出一个算法的轮廓和骨架\",{\"1\":{\"119\":1}}],[\"负责使用strategy角色\",{\"1\":{\"115\":1}}],[\"负责预测大物体\",{\"1\":{\"24\":1}}],[\"胜出的线程获取cpu执行权的过程\",{\"1\":{\"212\":1}}],[\"胜\",{\"1\":{\"116\":1}}],[\"平价卷由于优惠力度并不是很大\",{\"1\":{\"994\":1}}],[\"平价券可以任意购买\",{\"1\":{\"994\":1}}],[\"平台启用非池化实现\",{\"1\":{\"820\":1}}],[\"平台默认启用池化实现\",{\"1\":{\"820\":1}}],[\"平时你是如何搭配使用垃圾回收器的\",{\"1\":{\"355\":1}}],[\"平时喜欢运动\",{\"1\":{\"293\":1}}],[\"平板\",{\"1\":{\"305\":1,\"950\":1}}],[\"平均带权周转时间\",{\"1\":{\"138\":2}}],[\"平均周转时间\",{\"1\":{\"138\":2,\"139\":1}}],[\"平\",{\"1\":{\"116\":1}}],[\"计数超过阈值\",{\"1\":{\"792\":1}}],[\"计数重置为\",{\"1\":{\"792\":1}}],[\"计数加\",{\"1\":{\"792\":1}}],[\"计数变为0后\",{\"1\":{\"263\":1}}],[\"计为常驻人口\",{\"1\":{\"296\":1}}],[\"计算张三和李四有哪些共同好友\",{\"1\":{\"1029\":1}}],[\"计算张三的好友有几人\",{\"1\":{\"1029\":1}}],[\"计算完毕后向\",{\"1\":{\"809\":1}}],[\"计算完成后替换为普通node\",{\"1\":{\"249\":1}}],[\"计算等待时间\",{\"1\":{\"792\":1}}],[\"计算\",{\"1\":{\"277\":1,\"905\":1}}],[\"计算出剩余的空间大小\",{\"1\":{\"277\":1}}],[\"计算字符串长度的时候则会是\",{\"1\":{\"276\":1}}],[\"计算该列除null之外的不重复行数\",{\"1\":{\"267\":1}}],[\"计算并获取\",{\"1\":{\"232\":1}}],[\"计算机网络\",{\"0\":{\"196\":1}}],[\"计算机开机时需要进行一系列初始化工作\",{\"1\":{\"178\":1}}],[\"计算机系统中同时存在着多个运行着程序\",{\"1\":{\"127\":1}}],[\"计算机工作\",{\"1\":{\"109\":2}}],[\"计算机才能正常的运行\",{\"1\":{\"109\":1}}],[\"计分\",{\"1\":{\"116\":1}}],[\"布隆过滤\",{\"1\":{\"984\":2,\"985\":1}}],[\"布隆过滤器走的是哈希思想\",{\"1\":{\"984\":1}}],[\"布隆过滤器其实采用的是哈希思想来解决这个问题\",{\"1\":{\"984\":1}}],[\"布隆过滤器使用场景\",{\"0\":{\"274\":1}}],[\"布隆过滤器说某个元素不在\",{\"1\":{\"273\":1}}],[\"布隆过滤器说某个元素存在\",{\"1\":{\"273\":1}}],[\"布隆过滤器hash计算\",{\"1\":{\"273\":1}}],[\"布隆过滤器的原理介绍\",{\"0\":{\"273\":1}}],[\"布隆过滤器示意图\",{\"1\":{\"272\":1}}],[\"布隆过滤器\",{\"0\":{\"271\":1},\"1\":{\"271\":1,\"272\":1}}],[\"布\",{\"1\":{\"116\":1}}],[\"石头\",{\"1\":{\"116\":1}}],[\"上传安装包并解压\",{\"0\":{\"1012\":1}}],[\"上万并发\",{\"1\":{\"955\":1}}],[\"上发生的事件\",{\"1\":{\"917\":1}}],[\"上关联的附件\",{\"1\":{\"890\":1}}],[\"上源源不断的\",{\"1\":{\"796\":1}}],[\"上的可写事件\",{\"1\":{\"893\":1}}],[\"上的各种事件\",{\"1\":{\"816\":1}}],[\"上的读写\",{\"1\":{\"798\":2}}],[\"上的\",{\"1\":{\"790\":1,\"793\":1,\"794\":2,\"796\":1,\"887\":2,\"888\":1}}],[\"上是否用\",{\"1\":{\"688\":1}}],[\"上有没有指定\",{\"1\":{\"604\":1}}],[\"上加了\",{\"1\":{\"473\":1}}],[\"上一次使用时间戳\",{\"1\":{\"441\":1}}],[\"上一局的手势是否获胜\",{\"1\":{\"116\":1}}],[\"上述条件不满足\",{\"1\":{\"751\":1}}],[\"上述配置文件中\",{\"1\":{\"670\":1}}],[\"上述添加了一个联合索引\",{\"1\":{\"385\":1}}],[\"上述算法优点的集合\",{\"1\":{\"139\":1}}],[\"上述算法一般适合用于早期的批处理系统\",{\"1\":{\"139\":1}}],[\"上\",{\"1\":{\"178\":1,\"779\":1,\"790\":2,\"793\":1,\"798\":2,\"890\":1,\"893\":1,\"917\":1}}],[\"上图反应了有三个channel注册到了该selector\",{\"1\":{\"332\":1}}],[\"上图缺页中断发生了9次\",{\"1\":{\"163\":1}}],[\"上图中绿色表示已经分配的资源\",{\"1\":{\"150\":1}}],[\"上锁前可能会发生进程切换\",{\"1\":{\"141\":1}}],[\"上锁\",{\"1\":{\"140\":1}}],[\"上下文\",{\"1\":{\"115\":1,\"406\":2}}],[\"上面写的传播行为后三个会使之失效\",{\"1\":{\"723\":1}}],[\"上面一起学习了aqs中几个重要的模板方法\",{\"1\":{\"255\":1}}],[\"上面是一些校验\",{\"1\":{\"236\":1}}],[\"上面的三种更加适合于交互式系统\",{\"1\":{\"139\":1}}],[\"上面的设计我们发现了它存在的问题\",{\"1\":{\"110\":1}}],[\"上面的双重检测锁模式看上去完美无缺\",{\"1\":{\"101\":1}}],[\"上面代码创建了一个默认的\",{\"1\":{\"818\":1}}],[\"上面代码可以看到已经组装了一台电脑\",{\"1\":{\"109\":1}}],[\"上面代码运行结果是false\",{\"1\":{\"103\":2}}],[\"上面在客户端代码中构建phone对象\",{\"1\":{\"52\":1}}],[\"上面示例是\",{\"1\":{\"49\":1}}],[\"策略\",{\"1\":{\"115\":1}}],[\"策略模式\",{\"0\":{\"113\":1}}],[\"颜色\",{\"1\":{\"112\":1}}],[\"按着最优规则处理数据对性能提高很大\",{\"1\":{\"926\":1}}],[\"按注解提供的\",{\"1\":{\"695\":1}}],[\"按泛型参数类型筛选\",{\"1\":{\"695\":1}}],[\"按类型装配的步骤\",{\"0\":{\"688\":1}}],[\"按名字去获取时\",{\"1\":{\"678\":1}}],[\"按数字升序\",{\"1\":{\"466\":1}}],[\"按序转换成所有列名\",{\"1\":{\"388\":1}}],[\"按钮置灰\",{\"1\":{\"315\":1}}],[\"按信息交换的单位分类\",{\"1\":{\"179\":1}}],[\"按fcfs原则排队等待分配时间片\",{\"1\":{\"139\":1}}],[\"按照score排序后\",{\"1\":{\"1030\":2}}],[\"按照上述协议的规则\",{\"1\":{\"766\":1}}],[\"按照上述过程\",{\"1\":{\"150\":1}}],[\"按照粒度\",{\"1\":{\"396\":1}}],[\"按照每个有序文件中的下一行数据对所有文件输入流进行排序\",{\"1\":{\"291\":1}}],[\"按照实际占用字节数进行对齐\",{\"1\":{\"277\":1}}],[\"按照传输速率分类\",{\"1\":{\"179\":1}}],[\"按照使用特性分类\",{\"1\":{\"179\":1}}],[\"按照动态分区分配算法\",{\"1\":{\"154\":1}}],[\"按照152637顺序执行\",{\"1\":{\"141\":1}}],[\"按照152637\",{\"1\":{\"141\":1}}],[\"按照各个进程到达就绪队列的顺序\",{\"1\":{\"139\":1}}],[\"按照作业\",{\"1\":{\"139\":1}}],[\"按照某种方法和策略从就绪队列中选取一个进程\",{\"1\":{\"136\":1}}],[\"按一定的原则从外存上处于后备队列的作业中选中一个或多个作业\",{\"1\":{\"136\":1}}],[\"按某种顺序调用其包含的基本方法\",{\"1\":{\"119\":1}}],[\"按\",{\"1\":{\"112\":1,\"277\":1}}],[\"行级锁只在存储引擎层实现\",{\"1\":{\"401\":1}}],[\"行锁又称为记录锁\",{\"1\":{\"401\":1}}],[\"行锁\",{\"0\":{\"401\":1}}],[\"行锁则之锁定需要操作的数据\",{\"1\":{\"396\":1}}],[\"行锁以及其他位于二至之间的锁\",{\"1\":{\"396\":1}}],[\"行的第\",{\"1\":{\"194\":1}}],[\"行第\",{\"1\":{\"194\":1}}],[\"行时不可能发生变化\",{\"1\":{\"112\":1}}],[\"行李箱\",{\"1\":{\"33\":1}}],[\"子程序段x\",{\"1\":{\"413\":1}}],[\"子加载器才会尝试自己去加载\",{\"1\":{\"345\":1}}],[\"子句的\",{\"1\":{\"267\":1}}],[\"子类执行的结果会影响父类的结果\",{\"1\":{\"121\":1}}],[\"子类与父类的耦合度高\",{\"1\":{\"112\":1}}],[\"子豪兄论文精读视频\",{\"1\":{\"17\":1}}],[\"子豪兄会带你逐句精读gan开山之作经典论文\",{\"1\":{\"10\":1}}],[\"子豪兄精读论文视频\",{\"1\":{\"3\":1}}],[\"复杂了很多\",{\"1\":{\"829\":1}}],[\"复杂度是\",{\"1\":{\"279\":1}}],[\"复杂度获取字符串长度\",{\"1\":{\"277\":1}}],[\"复制分片之所以重要\",{\"1\":{\"928\":1}}],[\"复制数据阶段\",{\"1\":{\"901\":1}}],[\"复制等操作\",{\"1\":{\"830\":1}}],[\"复制内核态代码执行结果\",{\"1\":{\"406\":1}}],[\"复制用户态参数\",{\"1\":{\"406\":1}}],[\"复制文件\",{\"1\":{\"166\":1}}],[\"复制奖状\",{\"1\":{\"87\":1,\"89\":1}}],[\"复用的灵活性高\",{\"1\":{\"112\":1}}],[\"复用\",{\"1\":{\"112\":2}}],[\"父类\",{\"1\":{\"771\":2}}],[\"父类中的抽象方法由子类实现\",{\"1\":{\"121\":1}}],[\"父类中凡是已经实现好的方法\",{\"1\":{\"108\":1}}],[\"父类的实现的任何改变都会导致子类的实现发生变化\",{\"1\":{\"112\":1}}],[\"父类对子类是透明的\",{\"1\":{\"112\":1}}],[\"通用指令是部分数据类型的\",{\"1\":{\"1024\":1}}],[\"通用命令\",{\"0\":{\"1024\":1}}],[\"通用寄存器\",{\"1\":{\"129\":1}}],[\"通配符\",{\"1\":{\"643\":1}}],[\"通配符方式获取一组\",{\"1\":{\"446\":1,\"449\":1}}],[\"通知调用过程\",{\"0\":{\"547\":1}}],[\"通知对象如何创建\",{\"1\":{\"545\":1}}],[\"通知代码从哪儿来\",{\"1\":{\"545\":1}}],[\"通知和一个\",{\"1\":{\"528\":1}}],[\"通知\",{\"0\":{\"529\":1},\"1\":{\"528\":3}}],[\"通知client客户端新的master地址\",{\"1\":{\"433\":1}}],[\"通道可以从缓冲区读取数据\",{\"1\":{\"332\":1}}],[\"通道可以实现异步读写数据\",{\"1\":{\"332\":1}}],[\"通道是双向的可以进行读写\",{\"1\":{\"332\":1}}],[\"通道控制方式\",{\"1\":{\"181\":1}}],[\"通常用于解决缓存和数据库不一致问题\",{\"1\":{\"980\":1}}],[\"通常用到两种模式\",{\"1\":{\"333\":1}}],[\"通常\",{\"1\":{\"923\":1}}],[\"通常是通过类路径扫描\",{\"1\":{\"713\":1}}],[\"通常可以把页面置换算法看成是淘汰页面的规则\",{\"1\":{\"420\":1}}],[\"通常hash索引的效率更高\",{\"1\":{\"381\":1}}],[\"通常采用\",{\"1\":{\"246\":1}}],[\"通常采用连续分配方式\",{\"1\":{\"153\":1}}],[\"通常将磁盘空间分为文件区和对换区两部分\",{\"1\":{\"153\":1}}],[\"通常把覆盖了软件的机器称为扩充机器\",{\"1\":{\"126\":1}}],[\"通常在编程时算法会被写在具体的方法中\",{\"1\":{\"114\":1}}],[\"通常类的复用分为继承复用和合成复用两种\",{\"1\":{\"112\":1}}],[\"通过help\",{\"1\":{\"1024\":1}}],[\"通过handleradapter对handler进行封装\",{\"1\":{\"736\":1}}],[\"通过hash的方式\",{\"1\":{\"434\":1}}],[\"通过配置文件可以设置仓库数量\",{\"1\":{\"1021\":1}}],[\"通过配置虚拟机参数\",{\"1\":{\"714\":1}}],[\"通过加锁可以解决在单机情况下的一人一单安全问题\",{\"1\":{\"999\":1}}],[\"通过不同的前缀来区分不同业务的id\",{\"1\":{\"993\":1}}],[\"通过定义回调函数\",{\"1\":{\"990\":1}}],[\"通过一个庞大的二进制数组\",{\"1\":{\"984\":1}}],[\"通过一个父类调用其子类的操作\",{\"1\":{\"121\":1}}],[\"通过之前的淘汰\",{\"1\":{\"983\":1}}],[\"通过以上讲解\",{\"1\":{\"961\":1}}],[\"通过以上的流程分析\",{\"1\":{\"315\":1}}],[\"通过以上的分析\",{\"1\":{\"276\":1}}],[\"通过专门线程访问引用队列\",{\"1\":{\"905\":1}}],[\"通过网络把数据发送出去\",{\"1\":{\"877\":1}}],[\"通过代码里面的调用request和cancel方法交互\",{\"1\":{\"745\":1}}],[\"通过publisher\",{\"1\":{\"743\":1}}],[\"通过上图可以看出\",{\"1\":{\"738\":1}}],[\"通过上述链表可以构造出一张图\",{\"1\":{\"403\":1}}],[\"通过spring\",{\"1\":{\"729\":1}}],[\"通过system\",{\"1\":{\"357\":1}}],[\"通过run方法进行\",{\"1\":{\"728\":1}}],[\"通过在pom文件中配置aspectj编译插件实现\",{\"1\":{\"714\":1}}],[\"通过在配置文件中指定mybatis\",{\"1\":{\"366\":1}}],[\"通过构造方法实例化得到一个对象\",{\"1\":{\"711\":1}}],[\"通过构造两个gan网络和两个cycle\",{\"1\":{\"3\":1}}],[\"通过它可以知道事件和哪个channel的事件\",{\"1\":{\"890\":1}}],[\"通过它的声明\",{\"1\":{\"709\":1}}],[\"通过它完成整个调用\",{\"1\":{\"549\":1}}],[\"通过检查容器的\",{\"1\":{\"660\":1}}],[\"通过监听事件2️⃣来调用\",{\"1\":{\"652\":1}}],[\"通过类元数据\",{\"1\":{\"480\":1}}],[\"通过注解元数据\",{\"1\":{\"480\":1}}],[\"通过接口回调将\",{\"1\":{\"516\":1}}],[\"通过接口回调\",{\"1\":{\"461\":1}}],[\"通过接口或抽象类声明真实主题和代理对象实现的业务方法\",{\"1\":{\"92\":1}}],[\"通过这个示例结合\",{\"1\":{\"449\":1}}],[\"通过这个递增的序列号来区分\",{\"1\":{\"440\":1}}],[\"通过雪花算法生成下一个id\",{\"1\":{\"441\":1}}],[\"通过页号去页表查找该页号对应的块号\",{\"1\":{\"413\":1}}],[\"通过epoll\",{\"1\":{\"410\":1}}],[\"通过遍历文件描述符来获取已经就绪的socket\",{\"1\":{\"410\":1}}],[\"通过隐藏列和版本链\",{\"1\":{\"393\":1}}],[\"通过创建唯一索引\",{\"1\":{\"375\":1}}],[\"通过mybatisx插件自动生成代码\",{\"0\":{\"373\":1}}],[\"通过分步查询解决多对一映射关系\",{\"1\":{\"366\":1}}],[\"通过级联查询将结果直接映射在user实体类中\",{\"1\":{\"366\":1}}],[\"通过aop编织到模块中\",{\"1\":{\"716\":1}}],[\"通过association解决多对一映射关系\",{\"1\":{\"366\":1}}],[\"通过atomicmarkablereference判断是否被修改\",{\"1\":{\"233\":1}}],[\"通过atomicstampedreference判断是否更改了版本号\",{\"1\":{\"233\":1}}],[\"通过流所生成元素的hashcode\",{\"1\":{\"338\":1}}],[\"通过collection解决一对多映射关系和通过分步查询解决一对多映射关系如上述代码相差不大\",{\"1\":{\"366\":1}}],[\"通过compare\",{\"1\":{\"325\":1}}],[\"通过cpu的利用率计算得到\",{\"1\":{\"246\":1}}],[\"通过摄像头\",{\"1\":{\"300\":1}}],[\"通过项目可以有效地将之前学过的知识运用于代码实践\",{\"1\":{\"299\":1}}],[\"通过维护一个小顶堆来找出所有小文件中出现频率最高的100词\",{\"1\":{\"290\":1}}],[\"通过\",{\"1\":{\"277\":1,\"528\":1,\"549\":1,\"556\":1,\"617\":1,\"631\":1,\"650\":1,\"731\":1,\"816\":1,\"863\":3,\"905\":1}}],[\"通过使用二进制安全的\",{\"1\":{\"277\":1}}],[\"通过重复利用已创建的线程来降低线程创建和销毁所带来的消耗\",{\"1\":{\"240\":1}}],[\"通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异\",{\"1\":{\"182\":1}}],[\"通过执行该程序就可以找到引导块\",{\"1\":{\"178\":1}}],[\"通过旋转磁盘\",{\"1\":{\"176\":1}}],[\"通过中断\",{\"1\":{\"129\":1}}],[\"通过对子类的具体实现扩展不同的行为\",{\"1\":{\"121\":1}}],[\"通过对部件的组装可以返回一辆完整的汽车\",{\"1\":{\"55\":1}}],[\"通过输入流获取\",{\"1\":{\"105\":1}}],[\"通过源代码查看使用的是哪儿种单例模式\",{\"1\":{\"105\":1}}],[\"通过反射将\",{\"1\":{\"792\":1}}],[\"通过反射调用\",{\"1\":{\"104\":1}}],[\"通过反射创建新的单例类\",{\"1\":{\"104\":1}}],[\"通过该接口即可访问远程服务提供的功能\",{\"1\":{\"98\":1}}],[\"通过阿里巴巴开源的\",{\"1\":{\"94\":1}}],[\"通过复制该原型对象来创建一个和原型对象相同的新对象\",{\"1\":{\"84\":1}}],[\"通过实现一个新的建造者类就可以完成\",{\"1\":{\"50\":1}}],[\"通过继承或引用适配者的对象\",{\"1\":{\"40\":1}}],[\"洽淡业务\",{\"1\":{\"111\":1}}],[\"见下图\",{\"1\":{\"996\":1}}],[\"见下面代码片段\",{\"1\":{\"523\":1}}],[\"见下面的演示1\",{\"1\":{\"458\":1}}],[\"见过的有\",{\"1\":{\"665\":1}}],[\"见视频中同时加\",{\"1\":{\"454\":1}}],[\"见面了\",{\"1\":{\"111\":1}}],[\"见论文主页\",{\"1\":{\"4\":1}}],[\"与java中的treeset有些类似\",{\"1\":{\"1030\":1}}],[\"与lpop和rpop类似\",{\"1\":{\"1028\":1}}],[\"与redis服务端做心跳测试\",{\"1\":{\"1018\":1}}],[\"与前面的区别是消息存储不连续解析复杂\",{\"1\":{\"891\":1}}],[\"与前面的保护性暂停中的guardobjct不同\",{\"1\":{\"218\":1}}],[\"与其向项目的构建文件里添加一堆单独的库依赖\",{\"1\":{\"727\":1}}],[\"与其它类型相互转换\",{\"1\":{\"575\":1}}],[\"与传统类工厂不同的是\",{\"1\":{\"708\":1}}],[\"与成员变量名或方法参数名同名\",{\"1\":{\"695\":1}}],[\"与应用配置类解耦\",{\"1\":{\"671\":1}}],[\"与第一套接口直接可以通过\",{\"1\":{\"575\":1}}],[\"与第二次访问内存时间\",{\"1\":{\"413\":1}}],[\"与初始化类似\",{\"1\":{\"495\":1}}],[\"与过期数据删除策略有关\",{\"1\":{\"426\":1}}],[\"与与limit\",{\"1\":{\"338\":1}}],[\"与对应的客户端进行数据处理\",{\"1\":{\"331\":1}}],[\"与全表扫描是小巫见大巫\",{\"1\":{\"266\":1}}],[\"与wait\",{\"1\":{\"219\":1}}],[\"与可运行状态的区别是\",{\"1\":{\"208\":1}}],[\"与操作系统线程相关\",{\"1\":{\"208\":1}}],[\"与yield\",{\"0\":{\"203\":1}}],[\"与\",{\"0\":{\"447\":1,\"558\":1,\"624\":1,\"628\":1,\"632\":1},\"1\":{\"195\":1,\"454\":1,\"470\":1,\"558\":1,\"574\":1,\"576\":1,\"617\":1,\"643\":2,\"670\":1,\"672\":1,\"705\":1,\"806\":1,\"813\":1}}],[\"与设备的硬件特性无关的功能都几乎在这一层实现\",{\"1\":{\"182\":1}}],[\"与程序直接控制方式相比\",{\"1\":{\"181\":1}}],[\"与分页的最大区别\",{\"1\":{\"159\":1}}],[\"与原语的实现思想相同\",{\"1\":{\"142\":1}}],[\"与明星\",{\"1\":{\"111\":2}}],[\"与ground\",{\"1\":{\"24\":1}}],[\"媒体公司类\",{\"1\":{\"111\":1}}],[\"粉丝类\",{\"1\":{\"111\":1}}],[\"朋友圈点赞列表\",{\"1\":{\"1028\":1}}],[\"朋友\",{\"1\":{\"111\":1}}],[\"说一说你知道的spring\",{\"0\":{\"737\":1}}],[\"说一说对beanfactory的了解\",{\"0\":{\"708\":1}}],[\"说一说对spring容器的了解\",{\"0\":{\"707\":1}}],[\"说一下回收的过程\",{\"1\":{\"355\":1}}],[\"说一下gc算法\",{\"1\":{\"355\":1}}],[\"说到ioc就不得不说di\",{\"1\":{\"706\":1}}],[\"说说你对spring\",{\"0\":{\"726\":1,\"731\":1}}],[\"说说aop的应用场景\",{\"0\":{\"716\":1}}],[\"说说对mysql索引的理解\",{\"0\":{\"375\":1}}],[\"说说知识的深度与广度\",{\"1\":{\"310\":1}}],[\"说下g1的应用场景\",{\"1\":{\"355\":1}}],[\"说优点\",{\"1\":{\"303\":1}}],[\"说话\",{\"1\":{\"111\":1}}],[\"说明没有假死\",{\"1\":{\"764\":1}}],[\"说明字符串还没结束\",{\"1\":{\"276\":1}}],[\"说明该元素不在布隆过滤器中\",{\"1\":{\"273\":2}}],[\"说明\",{\"1\":{\"49\":1,\"82\":1,\"116\":1,\"265\":7,\"266\":8,\"267\":6,\"268\":7,\"353\":2,\"383\":2,\"710\":1,\"720\":1}}],[\"陌生人\",{\"1\":{\"111\":1}}],[\"迪米特法则中的\",{\"1\":{\"111\":1}}],[\"迪米特法则又叫最少知识原则\",{\"1\":{\"111\":1}}],[\"迪米特法则\",{\"0\":{\"111\":1}}],[\"防止装包以及拆包引发bug\",{\"1\":{\"988\":1}}],[\"防止缓存击穿\",{\"1\":{\"988\":1}}],[\"防止缓存穿透\",{\"1\":{\"274\":1}}],[\"防止过高的数据访问猛冲系统\",{\"1\":{\"974\":1}}],[\"防止车体加速后因惯性\",{\"1\":{\"974\":1}}],[\"防止由于一个文件句柄的阻塞读\",{\"1\":{\"410\":1}}],[\"防止核心api被随意篡改\",{\"1\":{\"345\":1}}],[\"防止因字段类型不同造成的隐式转换\",{\"1\":{\"266\":1}}],[\"防止子类无意间破坏不变性\",{\"1\":{\"236\":1}}],[\"防止进程忙等待\",{\"1\":{\"140\":1}}],[\"防止用户进行非法操作\",{\"1\":{\"130\":1}}],[\"防火\",{\"1\":{\"110\":2}}],[\"防火的功能\",{\"1\":{\"110\":1}}],[\"防火墙就将你的浏览器的请求转给互联网\",{\"1\":{\"98\":1}}],[\"防火墙\",{\"1\":{\"98\":1}}],[\"防盗\",{\"1\":{\"110\":2}}],[\"防盗功能提取成一个接口\",{\"1\":{\"110\":1}}],[\"防盗的功能\",{\"1\":{\"110\":1}}],[\"防水功能呢\",{\"1\":{\"110\":1}}],[\"防水\",{\"1\":{\"110\":4}}],[\"选择库\",{\"1\":{\"1032\":1,\"1035\":1}}],[\"选择客户\",{\"1\":{\"835\":1}}],[\"选择服务\",{\"1\":{\"834\":1}}],[\"选择走\",{\"1\":{\"576\":1}}],[\"选择现有页面中其t值最大的淘汰\",{\"1\":{\"420\":1}}],[\"选择现有页面中t值的最大的\",{\"1\":{\"163\":1}}],[\"选择器\",{\"1\":{\"332\":1}}],[\"选择\",{\"1\":{\"195\":2,\"1021\":1}}],[\"选择排序\",{\"0\":{\"189\":1}}],[\"选择响应比最高的作业\",{\"1\":{\"139\":1}}],[\"选择自己喜欢的配件\",{\"1\":{\"109\":1}}],[\"选择cpu有很多选择\",{\"1\":{\"109\":1}}],[\"k4\",{\"1\":{\"1024\":1}}],[\"k3\",{\"1\":{\"1024\":4,\"1025\":2}}],[\"k2\",{\"1\":{\"1024\":4,\"1025\":2}}],[\"k1\",{\"1\":{\"1024\":3,\"1025\":2}}],[\"koushuangbwcx\",{\"1\":{\"731\":1}}],[\"klassid=123456\",{\"1\":{\"731\":1}}],[\"klassid\",{\"1\":{\"731\":3,\"737\":3}}],[\"klasses\",{\"1\":{\"731\":2,\"737\":1}}],[\"klass\",{\"1\":{\"353\":1}}],[\"kb\",{\"1\":{\"272\":1,\"377\":1}}],[\"k++\",{\"1\":{\"195\":1}}],[\"k\",{\"1\":{\"195\":4,\"249\":4,\"300\":1,\"343\":2,\"792\":5}}],[\"kingstonmemory\",{\"1\":{\"109\":6}}],[\"ken的杂谈\",{\"1\":{\"738\":1}}],[\"kernel会给用户进程发送一个signal\",{\"1\":{\"409\":1}}],[\"kernel会等待数据准备完成\",{\"1\":{\"409\":1}}],[\"kernel会\",{\"1\":{\"409\":1}}],[\"kernel就开始了io的第一个阶段\",{\"1\":{\"409\":1}}],[\"kernel\",{\"1\":{\"406\":1,\"904\":1,\"906\":1}}],[\"keras\",{\"1\":{\"14\":1,\"32\":1}}],[\"keepalivetime\",{\"1\":{\"242\":2}}],[\"key2\",{\"1\":{\"1029\":3}}],[\"key1\",{\"1\":{\"1029\":3}}],[\"key的层级结构\",{\"0\":{\"1026\":1}}],[\"key一般是string类型\",{\"1\":{\"1023\":1}}],[\"key前缀\",{\"1\":{\"990\":2}}],[\"keyprefix\",{\"1\":{\"990\":9,\"993\":2}}],[\"key要方便携带\",{\"1\":{\"966\":1}}],[\"key要具有唯一性\",{\"1\":{\"966\":1}}],[\"keyword\",{\"1\":{\"950\":2}}],[\"keyword表示关键字不分开\",{\"1\":{\"950\":1}}],[\"key没设置过期时间为什么被redis主动删除了\",{\"0\":{\"428\":1}}],[\"key过期了为什么内存没释放\",{\"0\":{\"426\":1}}],[\"key\",{\"1\":{\"77\":3,\"249\":20,\"265\":2,\"401\":1,\"430\":2,\"435\":1,\"561\":1,\"652\":1,\"670\":1,\"695\":3,\"790\":2,\"792\":2,\"793\":2,\"881\":1,\"884\":3,\"886\":6,\"887\":1,\"888\":1,\"890\":14,\"893\":12,\"896\":8,\"968\":2,\"972\":4,\"983\":3,\"985\":3,\"988\":9,\"989\":3,\"990\":25,\"994\":1,\"1009\":1,\"1024\":6,\"1025\":3,\"1026\":1,\"1027\":2,\"1028\":5,\"1029\":4,\"1030\":11}}],[\"keyset\",{\"1\":{\"77\":1}}],[\"keys\",{\"1\":{\"77\":2,\"792\":1,\"884\":2,\"886\":2,\"888\":1,\"890\":1,\"896\":2,\"1024\":8}}],[\"海盗船等\",{\"1\":{\"109\":1}}],[\"内容如下\",{\"1\":{\"1016\":1,\"1032\":1}}],[\"内容拷贝至\",{\"1\":{\"891\":1}}],[\"内容为\",{\"1\":{\"846\":1}}],[\"内容来自于刚才的\",{\"1\":{\"829\":1}}],[\"内这个\",{\"1\":{\"825\":1}}],[\"内如果没有向服务器写数据\",{\"1\":{\"764\":1}}],[\"内如果没有收到\",{\"1\":{\"764\":1}}],[\"内的\",{\"1\":{\"682\":1}}],[\"内嵌数据库连接池\",{\"1\":{\"660\":1}}],[\"内嵌容器\",{\"0\":{\"653\":1,\"654\":1},\"1\":{\"457\":1}}],[\"内置的注入和初始化不受扩展功能的影响\",{\"1\":{\"490\":1}}],[\"内置\",{\"1\":{\"490\":2}}],[\"内部变量就减少1\",{\"1\":{\"993\":1}}],[\"内部维护的\",{\"1\":{\"993\":1}}],[\"内部工作流程是这样的\",{\"1\":{\"904\":1}}],[\"内部包含了所有发生的事件\",{\"1\":{\"890\":1}}],[\"内部包含了所有的单例\",{\"1\":{\"449\":1}}],[\"内部创建了两个\",{\"1\":{\"796\":1}}],[\"内部根据成员变量\",{\"1\":{\"473\":1}}],[\"内部实现也差不多是数组+链表\",{\"1\":{\"422\":1}}],[\"内部使用的是cas\",{\"1\":{\"230\":1}}],[\"内部采用的就是这个原理\",{\"1\":{\"217\":1}}],[\"内部碎片\",{\"1\":{\"154\":1}}],[\"内部有一些系统调用的封装\",{\"1\":{\"130\":1}}],[\"内存非常宝贵\",{\"1\":{\"1024\":1}}],[\"内存值\",{\"1\":{\"996\":2}}],[\"内存淘汰\",{\"1\":{\"980\":1}}],[\"内存的读写速度会非常快\",{\"1\":{\"1008\":1}}],[\"内存的读写性能远高于磁盘\",{\"1\":{\"975\":1}}],[\"内存的基础知识\",{\"0\":{\"151\":1}}],[\"内存回收分成两步\",{\"1\":{\"905\":1}}],[\"内存回收的时间b\",{\"1\":{\"359\":1}}],[\"内存被回收\",{\"1\":{\"825\":1}}],[\"内存被分为系统区和用户区\",{\"1\":{\"154\":1}}],[\"内存管理器会将物理内存页保存到磁盘文件\",{\"1\":{\"415\":1}}],[\"内存管理主要是做什么\",{\"0\":{\"412\":1}}],[\"内存管理的概念\",{\"0\":{\"152\":1}}],[\"内存拷贝\",{\"1\":{\"410\":1}}],[\"内存占用较大\",{\"1\":{\"1041\":1}}],[\"内存占用较少\",{\"1\":{\"984\":1}}],[\"内存占用高\",{\"1\":{\"914\":1}}],[\"内存占用多些越来越能容忍\",{\"1\":{\"359\":1}}],[\"内存占用这三者共同构成一个\",{\"1\":{\"359\":1}}],[\"内存占用\",{\"1\":{\"359\":1}}],[\"内存泄漏\",{\"1\":{\"358\":1}}],[\"内存溢出\",{\"1\":{\"358\":1}}],[\"内存溢出和内存泄漏的原因\",{\"0\":{\"358\":1}}],[\"内存分配完成后虚拟机需要将分配到内存的空间都初始化零值\",{\"1\":{\"352\":1}}],[\"内存分配的并发问题\",{\"1\":{\"352\":1}}],[\"内存分配规则\",{\"1\":{\"159\":1}}],[\"内存不足时就可能出现oom\",{\"1\":{\"348\":1}}],[\"内存大小限制是10m\",{\"1\":{\"289\":1}}],[\"内存\",{\"1\":{\"181\":6,\"417\":1,\"825\":1,\"826\":1,\"891\":1,\"905\":1}}],[\"内存映像i\",{\"1\":{\"180\":1}}],[\"内存与磁盘之间的数据交换\",{\"1\":{\"169\":1}}],[\"内存拆分为一个个大小相等的分区\",{\"1\":{\"156\":1}}],[\"内存利用率低\",{\"1\":{\"154\":1}}],[\"内存空间利用率高\",{\"1\":{\"160\":1}}],[\"内存空间非连续分配管理方式\",{\"1\":{\"156\":1}}],[\"内存空间的分配\",{\"0\":{\"154\":1}}],[\"内存空间的扩充\",{\"0\":{\"153\":1}}],[\"内存空间紧张的时候\",{\"1\":{\"153\":1}}],[\"内存中\",{\"1\":{\"905\":1}}],[\"内存中来直接访问使用\",{\"1\":{\"905\":1}}],[\"内存中的某些空闲分区由于太小难以利用\",{\"1\":{\"154\":1}}],[\"内存中只能有一道用户程序\",{\"1\":{\"154\":1}}],[\"内存中分为一个固定区和若干个覆盖区\",{\"1\":{\"153\":1}}],[\"内存中有多个进程实体\",{\"1\":{\"131\":1}}],[\"内存地址从0开始\",{\"1\":{\"151\":1}}],[\"内存地址空间是分配给进程的\",{\"1\":{\"135\":1}}],[\"内存是用于存放数据的硬件\",{\"1\":{\"151\":1}}],[\"内存缓冲区等\",{\"1\":{\"140\":1}}],[\"内存条只能是金士顿的\",{\"1\":{\"109\":1}}],[\"内存条可以选择金士顿\",{\"1\":{\"109\":1}}],[\"内存条\",{\"1\":{\"109\":1}}],[\"内核缓冲区的数据写入网卡\",{\"1\":{\"905\":1}}],[\"内核会根据传入的\",{\"1\":{\"776\":1}}],[\"内核会采用类似callback的回调机制\",{\"1\":{\"410\":1}}],[\"内核需要将消息传递到用户空间\",{\"1\":{\"410\":1}}],[\"内核才对所有监视的文件描述符进行扫描\",{\"1\":{\"410\":1}}],[\"内核就会采用类似callback的回调机制来激活该fd\",{\"1\":{\"410\":1}}],[\"内核向进程返回一个文件描述符\",{\"1\":{\"407\":1}}],[\"内核代码对用户不信任\",{\"1\":{\"406\":1}}],[\"内核级线程\",{\"1\":{\"135\":1}}],[\"内核是计算机上配置的底层软件\",{\"1\":{\"128\":1}}],[\"内核程序\",{\"1\":{\"128\":1}}],[\"内裤外穿的超人\",{\"1\":{\"54\":1}}],[\"组名\",{\"1\":{\"758\":6}}],[\"组件已经被废弃掉\",{\"1\":{\"705\":1}}],[\"组件\",{\"0\":{\"795\":1},\"1\":{\"682\":1,\"705\":1}}],[\"组件扫描等方式都是生成\",{\"1\":{\"454\":1}}],[\"组装动态表名\",{\"1\":{\"368\":1}}],[\"组装电脑\",{\"1\":{\"109\":1}}],[\"组\",{\"1\":{\"173\":2}}],[\"组成的双向链表\",{\"1\":{\"816\":1}}],[\"组成\",{\"0\":{\"821\":1},\"1\":{\"156\":1,\"160\":1}}],[\"组合查询\",{\"0\":{\"941\":1},\"1\":{\"941\":1}}],[\"组合这些\",{\"1\":{\"829\":1}}],[\"组合模式在\",{\"1\":{\"568\":1,\"600\":1}}],[\"组合并扩展了\",{\"1\":{\"449\":1}}],[\"组合索引\",{\"1\":{\"383\":1}}],[\"组合\",{\"1\":{\"108\":1,\"449\":2,\"830\":1}}],[\"两类\",{\"1\":{\"837\":1}}],[\"两者都是用于自定义排序的接口\",{\"1\":{\"325\":1}}],[\"两者都应该依赖其抽象\",{\"1\":{\"109\":1}}],[\"两部分组成的数据结构\",{\"1\":{\"272\":1}}],[\"两阶段终止模式\",{\"0\":{\"206\":1}}],[\"两级目录结构\",{\"1\":{\"168\":1}}],[\"两级页表访问内存的次数\",{\"1\":{\"158\":1}}],[\"两级页表的原理\",{\"1\":{\"158\":1}}],[\"两级页表\",{\"0\":{\"158\":1}}],[\"两个\",{\"0\":{\"870\":1}}],[\"两个事务同时写\",{\"1\":{\"396\":1}}],[\"两个收集器间有连线\",{\"1\":{\"360\":1}}],[\"两个类型的成员变量\",{\"1\":{\"277\":1}}],[\"两个线程一个i++一个i\",{\"1\":{\"228\":1}}],[\"两个相邻的空闲分区合并为一个\",{\"1\":{\"154\":1}}],[\"两个原语进行数据交换\",{\"1\":{\"134\":1}}],[\"两个进程对共享空间的访问必须是互斥的\",{\"1\":{\"134\":1}}],[\"两个citation\",{\"1\":{\"89\":1}}],[\"两种\",{\"1\":{\"816\":1}}],[\"两种解决方法\",{\"1\":{\"712\":1}}],[\"两种方法获取参数名\",{\"0\":{\"570\":1}}],[\"两种情况下生成readview的机制不一样\",{\"1\":{\"393\":1}}],[\"两种必须要使用$\",{\"1\":{\"366\":1}}],[\"两种io多路复用方案\",{\"1\":{\"333\":1}}],[\"两种程序\",{\"1\":{\"128\":1}}],[\"两种处理器状态\",{\"1\":{\"128\":1}}],[\"两种指令\",{\"1\":{\"128\":2}}],[\"高亮查询\",{\"0\":{\"944\":1},\"1\":{\"944\":1}}],[\"高亮的部分即窗口\",{\"1\":{\"751\":1}}],[\"高级查询\",{\"0\":{\"935\":1}}],[\"高级调度时间\",{\"1\":{\"138\":1}}],[\"高级调度主要指的是调入问题\",{\"1\":{\"136\":1}}],[\"高级调度是外存和内存之间的调度\",{\"1\":{\"136\":1}}],[\"高级调度\",{\"1\":{\"136\":1}}],[\"高性能的网络服务器和客户端\",{\"1\":{\"839\":1}}],[\"高性能的代码生成包\",{\"1\":{\"95\":1}}],[\"高层接口与实现\",{\"0\":{\"576\":1}}],[\"高层模块不应该依赖低层模块\",{\"1\":{\"109\":1}}],[\"高并发时\",{\"1\":{\"820\":1}}],[\"高并发分布式环境下生成不重复\",{\"1\":{\"442\":1}}],[\"高并发集群\",{\"1\":{\"267\":1}}],[\"高位都为0\",{\"1\":{\"441\":2}}],[\"高可用和分片的特性\",{\"1\":{\"434\":1}}],[\"高的适合作为索引\",{\"1\":{\"383\":1}}],[\"高达90\",{\"1\":{\"383\":1}}],[\"高峰期过去再释放许可\",{\"1\":{\"261\":1}}],[\"高16位存储共享锁的状态\",{\"1\":{\"252\":1}}],[\"高3位的值\",{\"1\":{\"241\":1}}],[\"高速缓冲技术\",{\"1\":{\"161\":1}}],[\"高响应比优先\",{\"1\":{\"139\":1}}],[\"高效的数据存储结构\",{\"1\":{\"424\":1}}],[\"高效\",{\"1\":{\"126\":1,\"142\":1}}],[\"9200\",{\"1\":{\"932\":1,\"949\":1}}],[\"92803741\",{\"1\":{\"31\":1}}],[\"9<\",{\"1\":{\"931\":1}}],[\"9000\",{\"1\":{\"889\":2}}],[\"9090\",{\"1\":{\"754\":20,\"755\":17,\"756\":20}}],[\"91\",{\"1\":{\"872\":2}}],[\"918\",{\"1\":{\"812\":1,\"815\":2}}],[\"96\",{\"1\":{\"805\":1}}],[\"9b\",{\"1\":{\"756\":3}}],[\"9b68045565ab516f5f3e723c7b11f0c\",{\"1\":{\"160\":1}}],[\"97b\",{\"1\":{\"756\":1}}],[\"955也并没有什么错\",{\"1\":{\"305\":1}}],[\"9999\",{\"1\":{\"116\":1,\"898\":2}}],[\"9\",{\"0\":{\"133\":1,\"155\":1,\"174\":1,\"505\":1,\"826\":1,\"944\":1,\"969\":1,\"970\":1,\"971\":1,\"972\":1,\"988\":1},\"1\":{\"108\":1,\"135\":1,\"163\":1,\"342\":1,\"523\":1,\"749\":2,\"750\":3,\"753\":1,\"754\":11,\"755\":11,\"756\":11,\"773\":1,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":6,\"829\":5,\"830\":3,\"846\":1,\"849\":3,\"855\":2,\"857\":3,\"858\":2,\"886\":2,\"898\":1,\"907\":1,\"931\":1,\"944\":1}}],[\"来指定密码\",{\"1\":{\"1015\":1}}],[\"来操作事务\",{\"1\":{\"998\":1}}],[\"来表示是否有线程成功插入key\",{\"1\":{\"988\":1}}],[\"来解决双写问题\",{\"1\":{\"983\":1}}],[\"来解决问题\",{\"1\":{\"108\":1}}],[\"来实现文件读\",{\"1\":{\"904\":1}}],[\"来实现各个分区的分配和回收\",{\"1\":{\"154\":1}}],[\"来跟踪\",{\"1\":{\"893\":1}}],[\"来理解非阻塞模式\",{\"1\":{\"877\":1}}],[\"来理解阻塞模式\",{\"1\":{\"876\":1}}],[\"来控制\",{\"1\":{\"872\":1}}],[\"来读取文件内容\",{\"1\":{\"846\":1}}],[\"来获取\",{\"1\":{\"863\":1}}],[\"来获取结果\",{\"1\":{\"807\":1}}],[\"来获取代理对象\",{\"1\":{\"94\":1}}],[\"来处理\",{\"1\":{\"796\":1,\"917\":1}}],[\"来封装线程和\",{\"1\":{\"790\":1}}],[\"来接收结果\",{\"1\":{\"787\":1}}],[\"来设置大小\",{\"1\":{\"776\":1}}],[\"来确定扫描的包\",{\"1\":{\"661\":1}}],[\"来决定该\",{\"1\":{\"660\":1}}],[\"来决定要不要停止操作\",{\"1\":{\"276\":1}}],[\"来开启了自动代理\",{\"1\":{\"659\":1}}],[\"来测试\",{\"1\":{\"648\":1}}],[\"来将结果转换为\",{\"1\":{\"644\":1}}],[\"来进行适配\",{\"1\":{\"575\":1}}],[\"来进行排序\",{\"1\":{\"325\":1}}],[\"来编译\",{\"1\":{\"506\":1}}],[\"来补充一些\",{\"1\":{\"454\":1}}],[\"来作为主键\",{\"1\":{\"439\":1}}],[\"来保证自己的健壮性\",{\"1\":{\"433\":1}}],[\"来注册一个文件扫描符\",{\"1\":{\"410\":1}}],[\"来找到就绪的描述符\",{\"1\":{\"410\":1}}],[\"来避免索引失效\",{\"1\":{\"395\":1}}],[\"来说\",{\"1\":{\"387\":1}}],[\"来统计数据行数\",{\"1\":{\"387\":1}}],[\"来拼接sql\",{\"1\":{\"366\":1}}],[\"来对参数进行引用\",{\"1\":{\"365\":1}}],[\"来判断是否为null值\",{\"1\":{\"267\":1}}],[\"来替代count\",{\"1\":{\"267\":1}}],[\"来使用\",{\"1\":{\"260\":1}}],[\"来引用外部的局部变量\",{\"1\":{\"232\":1}}],[\"法\",{\"1\":{\"108\":1}}],[\"继续运行\",{\"1\":{\"877\":1}}],[\"继续遍历其他小文件\",{\"1\":{\"290\":1}}],[\"继续执行\",{\"1\":{\"263\":1}}],[\"继续检查下一个页面\",{\"1\":{\"163\":1}}],[\"继承自\",{\"1\":{\"796\":1,\"806\":1}}],[\"继承了messagesource\",{\"1\":{\"707\":1}}],[\"继承复用破坏了类的封装性\",{\"1\":{\"112\":1}}],[\"继承复用虽然有简单和易实现的优点\",{\"1\":{\"112\":1}}],[\"继承实际上让两个类耦合性增强了\",{\"1\":{\"108\":1}}],[\"继承在\",{\"1\":{\"108\":1}}],[\"继承包含这样一层含义\",{\"1\":{\"108\":1}}],[\"继而就会调用我们定义的readresolve方法\",{\"1\":{\"104\":1}}],[\"适宜插入和查询的特点\",{\"1\":{\"328\":1}}],[\"适量中等分区\",{\"1\":{\"154\":1}}],[\"适用于任务量已知\",{\"1\":{\"244\":1}}],[\"适用于线程数少\",{\"1\":{\"231\":1}}],[\"适用于连续分配方式\",{\"1\":{\"170\":1}}],[\"适用于多处理机环境\",{\"1\":{\"142\":2}}],[\"适用于分时操作系统\",{\"1\":{\"139\":2}}],[\"适用场景\",{\"0\":{\"122\":1}}],[\"适合连接数特别多\",{\"1\":{\"917\":1}}],[\"适合配合池化功能一起用\",{\"1\":{\"819\":1}}],[\"适合任务数比较密集\",{\"1\":{\"244\":1}}],[\"适合分时操作系统\",{\"1\":{\"137\":1}}],[\"适合早期批处理系统\",{\"1\":{\"137\":1}}],[\"适应性广\",{\"1\":{\"107\":1}}],[\"适配为\",{\"1\":{\"549\":2}}],[\"适配器提供跟原始类不同的接口\",{\"1\":{\"45\":1}}],[\"适配器\",{\"0\":{\"45\":1},\"1\":{\"40\":1}}],[\"适配器模式适配器模式是一种事后的补救策略\",{\"1\":{\"45\":1}}],[\"适配器模式分为类适配器模式和对象适配器模式\",{\"1\":{\"39\":1}}],[\"适配器模式\",{\"0\":{\"38\":1},\"1\":{\"40\":1}}],[\"适配者\",{\"1\":{\"40\":1}}],[\"重启\",{\"1\":{\"1016\":1}}],[\"重启时可以读取redo\",{\"1\":{\"396\":1}}],[\"重新置为\",{\"1\":{\"853\":1}}],[\"重新运行起来\",{\"1\":{\"409\":1}}],[\"重写了相应事件处理方法\",{\"1\":{\"837\":1}}],[\"重置到标记位置\",{\"1\":{\"824\":1}}],[\"重建缓存\",{\"1\":{\"989\":1,\"990\":1}}],[\"重建\",{\"1\":{\"792\":1}}],[\"重点讲下cms和g1\",{\"1\":{\"355\":1}}],[\"重点讲一下cms和g1\",{\"1\":{\"355\":1}}],[\"重点查看readordinaryobject方法\",{\"1\":{\"104\":1}}],[\"重点查看readobject0方法\",{\"1\":{\"104\":1}}],[\"重大考试或者面试\",{\"1\":{\"308\":1}}],[\"重要属性和内部类\",{\"1\":{\"249\":1}}],[\"重要程度\",{\"1\":{\"139\":1}}],[\"重试失败\",{\"1\":{\"234\":1}}],[\"重试即可\",{\"1\":{\"231\":1}}],[\"重复\",{\"1\":{\"189\":1,\"847\":1}}],[\"重定位寄存器\",{\"1\":{\"152\":1}}],[\"重构完成后释放互斥锁\",{\"1\":{\"989\":1}}],[\"重构后的代码在使用起来更方便\",{\"1\":{\"52\":1}}],[\"重构后代码\",{\"1\":{\"52\":1}}],[\"重构前代码如下\",{\"1\":{\"52\":1}}],[\"问题的原因在于当前方法被spring的事务控制\",{\"1\":{\"998\":1}}],[\"问题的解决\",{\"0\":{\"104\":1}}],[\"问题就出在一个线程读取主存的值后运算完还未刷回主存就被其他线程从主存中读取到了\",{\"1\":{\"230\":1}}],[\"问题来自于上一行\",{\"1\":{\"194\":1}}],[\"问题\",{\"0\":{\"904\":1},\"1\":{\"131\":1,\"133\":1,\"143\":1,\"280\":1,\"764\":1}}],[\"问题提出\",{\"1\":{\"108\":1}}],[\"问题演示\",{\"0\":{\"103\":1}}],[\"表面上只有\",{\"1\":{\"449\":1}}],[\"表面上epoll的性能更好\",{\"1\":{\"410\":1}}],[\"表等形式簇聚存储的\",{\"1\":{\"417\":1}}],[\"表锁\",{\"0\":{\"400\":1}}],[\"表锁在操作数据时会锁定整张表\",{\"1\":{\"396\":1}}],[\"表中都为\",{\"1\":{\"383\":1}}],[\"表和\",{\"1\":{\"383\":1}}],[\"表明该association不开启延迟加载\",{\"1\":{\"366\":1}}],[\"表明它们可以搭配使用\",{\"1\":{\"360\":1}}],[\"表明序列化和反序列化已经破坏了单例设计模式\",{\"1\":{\"103\":2}}],[\"表1\",{\"1\":{\"266\":2}}],[\"表的作用\",{\"1\":{\"265\":1}}],[\"表的命名最好是加上\",{\"1\":{\"265\":1}}],[\"表必备三字段\",{\"1\":{\"265\":1}}],[\"表名不能有单引号\",{\"1\":{\"366\":1}}],[\"表名不使用复数名词\",{\"1\":{\"265\":1}}],[\"表名该单词不存在\",{\"1\":{\"282\":2}}],[\"表名应该仅仅表示表里面的实体内容\",{\"1\":{\"265\":1}}],[\"表名\",{\"1\":{\"265\":2}}],[\"表达逻辑删除的字段名is\",{\"1\":{\"265\":1}}],[\"表达是否概念的字段\",{\"1\":{\"265\":1}}],[\"表项中包含分区\",{\"1\":{\"154\":1}}],[\"表示实际写了多少字节\",{\"1\":{\"893\":1}}],[\"表示到达了文件的末尾\",{\"1\":{\"864\":1}}],[\"表示基于\",{\"1\":{\"834\":1,\"835\":1}}],[\"表示增加新的\",{\"1\":{\"829\":1}}],[\"表示调用者没用完之前\",{\"1\":{\"825\":1}}],[\"表示该由当前线程唤醒\",{\"1\":{\"791\":1}}],[\"表示由其它线程来调用\",{\"1\":{\"791\":1}}],[\"表示需要连接关闭\",{\"1\":{\"751\":1}}],[\"表示一个完整报文\",{\"1\":{\"751\":1}}],[\"表示一个处理阶段\",{\"1\":{\"742\":1}}],[\"表示一个页面近期被访问过\",{\"1\":{\"163\":1}}],[\"表示subscriber消费publisher发布的一个消息的生命周期\",{\"1\":{\"742\":1}}],[\"表示这是个控制器bean\",{\"1\":{\"731\":1}}],[\"表示这期间确实没有写操作\",{\"1\":{\"260\":1}}],[\"表示为\",{\"1\":{\"473\":1}}],[\"表示缓冲区的当前终点\",{\"1\":{\"332\":1}}],[\"表示空的hash表\",{\"1\":{\"328\":1}}],[\"表示表示字符数组长度和分配空间大小不能超过\",{\"1\":{\"277\":1}}],[\"表示字符数组长度和分配空间大小不能超过\",{\"1\":{\"277\":1}}],[\"表示的是\",{\"1\":{\"277\":1}}],[\"表示相等时带上此条件\",{\"1\":{\"268\":1}}],[\"表示某段代码最多可以有n个线程同时访问\",{\"1\":{\"261\":1}}],[\"表示加锁\",{\"1\":{\"234\":1}}],[\"表示线程执行已经完毕\",{\"1\":{\"208\":1}}],[\"表示选择第i个物品\",{\"1\":{\"194\":1}}],[\"表示不选第i个物品\",{\"1\":{\"194\":1}}],[\"表示页面被修改过\",{\"1\":{\"163\":1}}],[\"表示页面没有被修改过\",{\"1\":{\"163\":1}}],[\"表示0号进程p0现在想要进入临界区\",{\"1\":{\"141\":1}}],[\"表示进行猜拳游戏的选手类\",{\"1\":{\"116\":1}}],[\"表示\",{\"1\":{\"116\":2,\"276\":1}}],[\"表示猜拳中出的手势值\",{\"1\":{\"116\":1}}],[\"表示猜拳中的\",{\"1\":{\"116\":1}}],[\"表示猜拳游戏中的策略的类\",{\"1\":{\"116\":1}}],[\"表示以简单图示形式显示熟知的类\",{\"1\":{\"82\":1}}],[\"表示以数字形式显示数值的类\",{\"1\":{\"82\":1}}],[\"表示生成数值的对象的抽象类\",{\"1\":{\"82\":1}}],[\"表示观察者的接口\",{\"1\":{\"82\":1}}],[\"分组查询\",{\"0\":{\"946\":1},\"1\":{\"946\":1}}],[\"分片集群\",{\"1\":{\"1009\":1}}],[\"分片和复制的数量可以在索引创建的时候指定\",{\"1\":{\"928\":1}}],[\"分片置于同一节点上是非常重要的\",{\"1\":{\"928\":1}}],[\"分片很重要\",{\"1\":{\"927\":1}}],[\"分片\",{\"0\":{\"927\":1}}],[\"分两组选择器\",{\"1\":{\"896\":1}}],[\"分隔的数据\",{\"1\":{\"859\":1}}],[\"分隔符\",{\"1\":{\"755\":1}}],[\"分散读取\",{\"1\":{\"857\":1}}],[\"分钟才能执行工作\",{\"1\":{\"805\":1}}],[\"分钟\",{\"1\":{\"805\":2}}],[\"分\",{\"1\":{\"753\":1,\"837\":1}}],[\"分布式系统\",{\"1\":{\"982\":1}}],[\"分布式协调框架\",{\"1\":{\"841\":1}}],[\"分布式问题\",{\"1\":{\"391\":1}}],[\"分布式软总线可以保证设备之间的高可靠和低延迟等等\",{\"1\":{\"305\":1}}],[\"分布式软总线的提出就是为了解决所有1+8+n设备之间的互联问题\",{\"1\":{\"305\":1}}],[\"分布式软总线是在1+8+n的框架下所提出的\",{\"1\":{\"305\":1}}],[\"分代分类\",{\"1\":{\"360\":1}}],[\"分代回收说下\",{\"1\":{\"355\":1}}],[\"分别为\",{\"1\":{\"901\":1}}],[\"分别要等待\",{\"1\":{\"805\":1}}],[\"分别修改发送字符串为\",{\"1\":{\"798\":2}}],[\"分别用下面两个参数来控制\",{\"1\":{\"776\":1}}],[\"分别用来\",{\"1\":{\"558\":1}}],[\"分别测试加入和去除\",{\"1\":{\"672\":1}}],[\"分别获取其模型和视图名\",{\"1\":{\"600\":1}}],[\"分别说下\",{\"1\":{\"279\":1}}],[\"分别是writefds\",{\"1\":{\"410\":1}}],[\"分别是普通索引\",{\"1\":{\"382\":1}}],[\"分别是\",{\"1\":{\"277\":2}}],[\"分别是序列化和反射\",{\"1\":{\"103\":1}}],[\"分治递归处理子问题\",{\"1\":{\"191\":1}}],[\"分为平价券和特价券\",{\"1\":{\"994\":1}}],[\"分为入站\",{\"1\":{\"816\":1}}],[\"分为\",{\"1\":{\"173\":1,\"354\":1}}],[\"分为隐式链接和显式链接两种\",{\"1\":{\"169\":1}}],[\"分为主文件目录\",{\"1\":{\"168\":1}}],[\"分为倒油\",{\"1\":{\"120\":1}}],[\"分页查询\",{\"0\":{\"938\":1},\"1\":{\"938\":1,\"950\":1}}],[\"分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统\",{\"1\":{\"419\":1}}],[\"分页仅仅是为了满足操作系统内存管理的需求\",{\"1\":{\"413\":1}}],[\"分页机制和分段机制都是为了提高内存利用率\",{\"1\":{\"413\":1}}],[\"分页\",{\"1\":{\"160\":1}}],[\"分页管理\",{\"1\":{\"160\":1}}],[\"分页和分段的优缺点\",{\"1\":{\"160\":1}}],[\"分页与分段的区别\",{\"1\":{\"159\":1}}],[\"分段则是信息的逻辑单位\",{\"1\":{\"413\":1}}],[\"分段和分页的共同点与区别\",{\"1\":{\"413\":1}}],[\"分段对用户是可见的\",{\"1\":{\"160\":1}}],[\"分段管理\",{\"1\":{\"160\":1}}],[\"分段比分页相比更容易实现信息的共享和保护\",{\"1\":{\"159\":1}}],[\"分段系统的逻辑地址结构由\",{\"1\":{\"159\":1}}],[\"分段\",{\"1\":{\"159\":1,\"160\":1}}],[\"分区\",{\"1\":{\"923\":1}}],[\"分区起始地址\",{\"1\":{\"154\":1}}],[\"分区信息\",{\"1\":{\"154\":1}}],[\"分区说明表\",{\"1\":{\"154\":1}}],[\"分区大小不等\",{\"1\":{\"154\":1}}],[\"分区大小相等\",{\"1\":{\"154\":1}}],[\"分配合适的\",{\"1\":{\"890\":1}}],[\"分配的效率低\",{\"1\":{\"851\":1}}],[\"分配的这块内存很大一部分几乎被浪费了\",{\"1\":{\"413\":1}}],[\"分配空间\",{\"0\":{\"851\":1},\"1\":{\"851\":1}}],[\"分配内存的方式有碰撞指针和空闲列表\",{\"1\":{\"352\":1}}],[\"分配额外的\",{\"1\":{\"277\":1}}],[\"分配修改所必须要的空间\",{\"1\":{\"277\":1}}],[\"分配了足够多的内存\",{\"1\":{\"276\":1}}],[\"分配给字符数组的空间长度\",{\"1\":{\"277\":1}}],[\"分配给进程的物理块不够\",{\"1\":{\"164\":1}}],[\"分配给某进程的内存区域中\",{\"1\":{\"154\":2}}],[\"分配三个内存块时\",{\"1\":{\"163\":1}}],[\"分配\",{\"0\":{\"929\":1},\"1\":{\"133\":1}}],[\"分配i\",{\"1\":{\"129\":1}}],[\"分析器\",{\"1\":{\"926\":1}}],[\"分析出各类型人员行动规律\",{\"1\":{\"295\":1}}],[\"分析\",{\"0\":{\"500\":1},\"1\":{\"107\":1}}],[\"分离了部件的构造\",{\"1\":{\"47\":1}}],[\"有user和product两种不同类型的数据\",{\"1\":{\"1026\":1}}],[\"有很大差异的一种特殊的数据库\",{\"1\":{\"1003\":1}}],[\"有很大差异的一种数据库\",{\"1\":{\"1001\":1}}],[\"有关池化思想\",{\"1\":{\"1033\":1}}],[\"有关锁失效原因分析\",{\"1\":{\"999\":1}}],[\"有关超卖问题分析\",{\"1\":{\"996\":1}}],[\"有关当前模型\",{\"0\":{\"955\":1}}],[\"有如下几种方案\",{\"1\":{\"981\":1}}],[\"有如下区别\",{\"1\":{\"661\":1}}],[\"有用户\",{\"1\":{\"972\":1}}],[\"有助于\",{\"1\":{\"905\":1}}],[\"有事件\",{\"1\":{\"890\":1}}],[\"有因为发送能力弱\",{\"1\":{\"881\":1}}],[\"有因为接收能力弱\",{\"1\":{\"881\":1}}],[\"有可写事件才去写入\",{\"1\":{\"878\":1}}],[\"有可读事件才去读取\",{\"1\":{\"878\":1}}],[\"有可连接事件时才去连接\",{\"1\":{\"878\":1}}],[\"有可能会造成程序运行终止\",{\"1\":{\"276\":1}}],[\"有可能造成事故\",{\"1\":{\"267\":1}}],[\"有新的问题\",{\"1\":{\"876\":1}}],[\"有以下重要属性\",{\"1\":{\"848\":1}}],[\"有一定的规范\",{\"1\":{\"1026\":1}}],[\"有一点类似于\",{\"1\":{\"911\":1}}],[\"有一普通文本文件\",{\"1\":{\"846\":1}}],[\"有一个商品id恰好也是1\",{\"1\":{\"1026\":1}}],[\"有一个用户id是1\",{\"1\":{\"1026\":1}}],[\"有一个额外的线程持有锁去进行重构数据\",{\"1\":{\"987\":1}}],[\"有一个故障转移机制是非常有用并且是强烈推荐的\",{\"1\":{\"928\":1}}],[\"有一个文本文件\",{\"1\":{\"857\":1}}],[\"有一个单例对象\",{\"1\":{\"500\":1}}],[\"有一个结果需要从一个线程传递到另一个线程\",{\"1\":{\"217\":1}}],[\"有一个代码段中有很多变量\",{\"1\":{\"159\":1}}],[\"有两个线程\",{\"1\":{\"999\":1}}],[\"有两个主要原因\",{\"1\":{\"928\":1}}],[\"有两个\",{\"1\":{\"829\":1}}],[\"有两种办法\",{\"1\":{\"852\":1}}],[\"有两种共享存储的方式\",{\"1\":{\"134\":1}}],[\"有两种方式\",{\"1\":{\"103\":1}}],[\"有任务\",{\"1\":{\"791\":1}}],[\"有没有问题\",{\"1\":{\"889\":2}}],[\"有没有\",{\"1\":{\"791\":1}}],[\"有限时阻塞\",{\"1\":{\"792\":1}}],[\"有限制\",{\"1\":{\"771\":1}}],[\"有限等待三个原则\",{\"1\":{\"141\":1}}],[\"有限等待\",{\"1\":{\"140\":1}}],[\"有协议为证\",{\"1\":{\"766\":1}}],[\"有循环依赖时\",{\"1\":{\"542\":1}}],[\"有\",{\"1\":{\"539\":2,\"666\":1,\"695\":1,\"792\":2,\"911\":2}}],[\"有几种\",{\"1\":{\"499\":1}}],[\"有几个哈希函数得到几个哈希值\",{\"1\":{\"273\":1}}],[\"有些同学看到这里会有疑问\",{\"1\":{\"805\":1}}],[\"有些文章提到有\",{\"1\":{\"496\":1}}],[\"有些地方也称这种io方式为事件驱动io\",{\"1\":{\"409\":1}}],[\"有了池化\",{\"1\":{\"820\":1}}],[\"有了控制反转\",{\"1\":{\"705\":1}}],[\"有了这个\",{\"1\":{\"561\":1}}],[\"有了\",{\"1\":{\"473\":1}}],[\"有了中断才能实现多道程序并发执行\",{\"1\":{\"129\":1}}],[\"有序\",{\"1\":{\"1028\":1}}],[\"有序递增\",{\"1\":{\"442\":1}}],[\"有序集合或哈希表类型的key\",{\"1\":{\"430\":1}}],[\"有序性\",{\"1\":{\"226\":1}}],[\"有五个物理块\",{\"1\":{\"420\":1}}],[\"有主程序段main\",{\"1\":{\"413\":1}}],[\"有效期到期时该key会被自动删除\",{\"1\":{\"1024\":1}}],[\"有效访问时间为第一次访间\",{\"1\":{\"413\":1}}],[\"有效的请求才会启动线程\",{\"1\":{\"333\":1}}],[\"有效的减少内存分配次数\",{\"1\":{\"277\":1}}],[\"有数据可读\",{\"1\":{\"410\":1}}],[\"有大量重复数据的列\",{\"1\":{\"384\":1}}],[\"有副作用\",{\"1\":{\"314\":2}}],[\"有所作为\",{\"1\":{\"304\":1,\"305\":1}}],[\"有点类似于数组\",{\"1\":{\"279\":1}}],[\"有竞争发生\",{\"1\":{\"249\":1}}],[\"有返回值返回一个future的对象\",{\"1\":{\"245\":1}}],[\"有界阻塞队列\",{\"1\":{\"242\":1}}],[\"有结构文件\",{\"1\":{\"167\":1}}],[\"有内部碎片\",{\"1\":{\"154\":1}}],[\"有的返回值处理器调用了\",{\"1\":{\"644\":1}}],[\"有的计算机会让这些寄存器占用内存地址的一部分\",{\"1\":{\"180\":1}}],[\"有的系统还会考虑进程在内存中的驻留时间\",{\"1\":{\"153\":1}}],[\"有的进程可能需要同时做很多事情\",{\"1\":{\"135\":1}}],[\"有何作用\",{\"1\":{\"151\":1}}],[\"有时候不清楚\",{\"1\":{\"825\":1}}],[\"有时候我们需要对某个字段进行去重\",{\"1\":{\"383\":1}}],[\"有时候等待cpu的服务\",{\"1\":{\"132\":1}}],[\"有时是程序员故意为之\",{\"1\":{\"147\":1}}],[\"有时是因为程序bug导致的\",{\"1\":{\"147\":1}}],[\"有时进程正在被cpu处理\",{\"1\":{\"132\":1}}],[\"有美丽的\",{\"1\":{\"37\":1}}],[\"枚举的写法非常简单\",{\"1\":{\"101\":1}}],[\"枚举类实现单例模式是极力推荐的单例实现模式\",{\"1\":{\"101\":1}}],[\"枚举方式不会出现这两个问题\",{\"1\":{\"103\":1}}],[\"枚举方式除外\",{\"1\":{\"103\":1}}],[\"枚举方式属于饿汉式方式\",{\"1\":{\"101\":1}}],[\"枚举方式\",{\"1\":{\"101\":2}}],[\"保留用户态现场\",{\"1\":{\"406\":1}}],[\"保存秒杀库存到redis中\",{\"1\":{\"994\":1}}],[\"保存秒杀信息\",{\"1\":{\"994\":1}}],[\"保存优惠券\",{\"1\":{\"994\":1}}],[\"保存用户信息到\",{\"1\":{\"968\":1,\"972\":1}}],[\"保存用户信息到threadlocal\",{\"1\":{\"961\":1,\"962\":1}}],[\"保存用户信息到session中\",{\"1\":{\"960\":1,\"962\":1}}],[\"保存验证码到\",{\"1\":{\"960\":1}}],[\"保存到数据库\",{\"1\":{\"959\":1}}],[\"保存订阅关系\",{\"1\":{\"743\":1,\"744\":1}}],[\"保存\",{\"1\":{\"280\":1}}],[\"保存其运行环境\",{\"1\":{\"133\":1}}],[\"保密性强\",{\"1\":{\"173\":1}}],[\"保证文件移动的原子性\",{\"1\":{\"872\":1}}],[\"保证了\",{\"1\":{\"796\":1}}],[\"保证了多线程下的安全\",{\"1\":{\"101\":1}}],[\"保证内核的安全\",{\"1\":{\"406\":1}}],[\"保证对象实例字段在不赋值时可以直接使用\",{\"1\":{\"352\":1}}],[\"保证每个文件的大小小于10m\",{\"1\":{\"290\":1}}],[\"保证被关联的字段需要有索引\",{\"1\":{\"266\":1}}],[\"保证数据不在因mysql宕机而丢失\",{\"1\":{\"396\":1}}],[\"保证数据唯一\",{\"1\":{\"315\":1}}],[\"保证数据安全\",{\"1\":{\"260\":1}}],[\"保证数组内元素的线程安全\",{\"1\":{\"232\":1}}],[\"保证\",{\"1\":{\"246\":1}}],[\"保证池的正常工作\",{\"1\":{\"244\":1}}],[\"保证在其它线程读到它的值时不会出现为\",{\"1\":{\"237\":1}}],[\"保证多线程访问同一个对象的成员变量时\",{\"1\":{\"232\":1}}],[\"保证引用类型的共享变量是线程安全的\",{\"1\":{\"232\":1}}],[\"保证有序性\",{\"1\":{\"227\":1}}],[\"保证可见性\",{\"1\":{\"227\":1}}],[\"保证指令不会受到cpu指令并行优化的影响\",{\"1\":{\"226\":1}}],[\"保证指令不会受到线程上下文切换的影响\",{\"1\":{\"226\":1}}],[\"保证指令不会受cpu缓存的影响\",{\"1\":{\"226\":1}}],[\"保证各进程在各自存储空间内运行互不干扰\",{\"1\":{\"152\":1}}],[\"保证不会饥饿\",{\"1\":{\"140\":1}}],[\"保证只被实例化一次\",{\"1\":{\"101\":1}}],[\"保护程序安全\",{\"1\":{\"345\":1}}],[\"保护性拷贝\",{\"1\":{\"236\":2}}],[\"保护性暂停模式\",{\"0\":{\"217\":1}}],[\"保护\",{\"1\":{\"98\":1}}],[\"添加一个或多个元素到sorted\",{\"1\":{\"1030\":1}}],[\"添加一个hash类型的key的field值\",{\"1\":{\"1027\":1}}],[\"添加一个string类型的键值对\",{\"1\":{\"1025\":2}}],[\"添加或者修改hash类型key的field的值\",{\"1\":{\"1027\":1}}],[\"添加或者修改已经存在的一个string类型的键值对\",{\"1\":{\"1025\":1}}],[\"添加以下逻辑\",{\"1\":{\"998\":1}}],[\"添加优惠卷\",{\"0\":{\"994\":1}}],[\"添加商户缓存\",{\"0\":{\"977\":1}}],[\"添加处理器\",{\"1\":{\"816\":1}}],[\"添加回调\",{\"1\":{\"806\":1}}],[\"添加的任务的线程需要负责唤醒\",{\"1\":{\"791\":1}}],[\"添加的即属于这种\",{\"1\":{\"576\":1}}],[\"添加任务\",{\"1\":{\"791\":1}}],[\"添加初始化器\",{\"1\":{\"790\":1}}],[\"添加了processor进行中间处理\",{\"1\":{\"744\":1}}],[\"添加监听器\",{\"1\":{\"652\":1}}],[\"添加容器初始化器\",{\"1\":{\"652\":1}}],[\"添加命令行参数\",{\"1\":{\"650\":1}}],[\"添加自定义转换器\",{\"1\":{\"582\":2}}],[\"添加动态表名插件\",{\"1\":{\"368\":1}}],[\"添加到集合中的元素越多\",{\"1\":{\"272\":1}}],[\"添加链表头节点使用了cas\",{\"1\":{\"249\":1}}],[\"添加\",{\"1\":{\"101\":1,\"657\":1,\"793\":1,\"835\":1}}],[\"性能自然会好一些\",{\"1\":{\"1008\":1}}],[\"性能好\",{\"1\":{\"987\":1}}],[\"性能没有优势\",{\"1\":{\"906\":1}}],[\"性能没有longadder高\",{\"1\":{\"234\":1}}],[\"性能较低\",{\"1\":{\"556\":1}}],[\"性能较高\",{\"1\":{\"504\":1}}],[\"性能会更好\",{\"1\":{\"394\":1}}],[\"性能差\",{\"1\":{\"391\":1}}],[\"性能提升的原因很简单\",{\"1\":{\"234\":1}}],[\"性能相对较低\",{\"1\":{\"228\":1}}],[\"性能\",{\"1\":{\"101\":1}}],[\"性能和安全要求比较高\",{\"1\":{\"88\":1}}],[\"解压后\",{\"1\":{\"1012\":1}}],[\"解压缩后\",{\"1\":{\"1020\":1}}],[\"解压缩\",{\"1\":{\"1012\":1}}],[\"解码\",{\"1\":{\"834\":1}}],[\"解读\",{\"1\":{\"770\":1}}],[\"解绑会话\",{\"1\":{\"758\":1}}],[\"解析类得到beandefinition\",{\"1\":{\"711\":1}}],[\"解析每个单例\",{\"1\":{\"699\":1}}],[\"解析每个参数值\",{\"1\":{\"568\":1}}],[\"解析时机\",{\"1\":{\"699\":1}}],[\"解析此类的\",{\"1\":{\"588\":1,\"596\":1,\"616\":1}}],[\"解析方法参数\",{\"1\":{\"568\":1}}],[\"解析参数依赖的就是各种参数解析器\",{\"1\":{\"568\":1}}],[\"解析控制器方法参数\",{\"1\":{\"561\":1}}],[\"解析器\",{\"1\":{\"490\":1}}],[\"解析元数据是基于\",{\"1\":{\"480\":1}}],[\"解析\",{\"1\":{\"463\":2,\"470\":4,\"650\":1,\"688\":1}}],[\"解析和初始化\",{\"1\":{\"352\":1}}],[\"解析url\",{\"1\":{\"198\":1}}],[\"解法2相对解法1\",{\"1\":{\"291\":1}}],[\"解法2\",{\"0\":{\"291\":1}}],[\"解法1不适用\",{\"1\":{\"291\":1}}],[\"解法1\",{\"0\":{\"290\":1}}],[\"解密\",{\"1\":{\"173\":1}}],[\"解除死锁的主要方法\",{\"1\":{\"150\":1}}],[\"解除死锁\",{\"1\":{\"150\":1}}],[\"解锁\",{\"1\":{\"140\":1}}],[\"解决内存大小有限的问题\",{\"1\":{\"1008\":1}}],[\"解决缓存穿透问题\",{\"1\":{\"985\":1,\"988\":1,\"990\":1}}],[\"解决状态登录刷新问题\",{\"0\":{\"969\":1}}],[\"解决把订阅者压垮的问题\",{\"1\":{\"745\":1}}],[\"解决死锁问题最简单的一种方法是超时\",{\"1\":{\"403\":1}}],[\"解决了dml和ddl操作之间的一致性问题\",{\"1\":{\"400\":1}}],[\"解决了单例\",{\"1\":{\"101\":1}}],[\"解决方法虽然不同\",{\"1\":{\"503\":1}}],[\"解决方法有\",{\"1\":{\"496\":1}}],[\"解决方法\",{\"1\":{\"491\":1}}],[\"解决方法就是pull下来别人的代码\",{\"1\":{\"297\":1}}],[\"解决方案二\",{\"1\":{\"987\":1}}],[\"解决方案一\",{\"1\":{\"987\":1}}],[\"解决方案\",{\"0\":{\"752\":1},\"1\":{\"230\":1,\"366\":1,\"986\":1}}],[\"解决办法是\",{\"1\":{\"247\":1}}],[\"解决问题\",{\"1\":{\"167\":1}}],[\"解决的问题\",{\"1\":{\"167\":1,\"168\":1,\"682\":1}}],[\"解决上面第一个问题\",{\"1\":{\"158\":1}}],[\"解决\",{\"1\":{\"131\":1,\"500\":1,\"842\":1}}],[\"解耦\",{\"1\":{\"60\":1}}],[\"再查询全部的key\",{\"1\":{\"1024\":1}}],[\"再查询数据库\",{\"1\":{\"978\":1}}],[\"再提交回数据时\",{\"1\":{\"996\":1}}],[\"再释放锁\",{\"1\":{\"988\":1}}],[\"再去进行查询\",{\"1\":{\"988\":1}}],[\"再操作数据库\",{\"1\":{\"982\":1}}],[\"再删除缓存\",{\"1\":{\"982\":2,\"983\":1}}],[\"再找到tomcat端的socket\",{\"1\":{\"961\":1}}],[\"再统一返回\",{\"1\":{\"961\":1}}],[\"再分配\",{\"1\":{\"891\":1}}],[\"再分配给缺页进程\",{\"1\":{\"164\":1}}],[\"再写入时在新内容和原末尾之间会有空洞\",{\"1\":{\"867\":1}}],[\"再写入一个\",{\"1\":{\"822\":1,\"823\":1}}],[\"再读只能读那些尚未读取的部分\",{\"1\":{\"824\":1}}],[\"再经过一道道出站工序最终变成产品\",{\"1\":{\"816\":1}}],[\"再增加两个非\",{\"1\":{\"798\":1}}],[\"再来看可读事件\",{\"1\":{\"794\":1}}],[\"再来讨论一下懒汉模式中加锁的问题\",{\"1\":{\"101\":1}}],[\"再\",{\"1\":{\"756\":1}}],[\"再关闭\",{\"1\":{\"751\":1}}],[\"再以统一的适配器接口调用handler\",{\"1\":{\"736\":1}}],[\"再封装为\",{\"1\":{\"695\":1}}],[\"再根据成员名或变量名进行筛选\",{\"1\":{\"688\":1}}],[\"再根据\",{\"1\":{\"688\":1}}],[\"再根据槽位值和redis节点的对应关系就可以定位到key具体是落在哪个redis节点上\",{\"1\":{\"435\":1}}],[\"再解析\",{\"1\":{\"688\":1}}],[\"再利用默认的\",{\"1\":{\"576\":1}}],[\"再看有没有\",{\"1\":{\"576\":1}}],[\"再接下10位存储机器码\",{\"1\":{\"440\":1}}],[\"再同步到从节点\",{\"1\":{\"434\":1}}],[\"再调入即将运行的段\",{\"1\":{\"419\":1}}],[\"再调用park线程发现counter为1继续运行并将counter置为0\",{\"1\":{\"219\":1}}],[\"再通过调页功能及页面置换功能陆续地把即将运行的页面调入内存\",{\"1\":{\"419\":1}}],[\"再通过sublist取start\",{\"1\":{\"268\":1}}],[\"再过60分钟你就能了解同步异步\",{\"1\":{\"405\":1}}],[\"再把每个段分成若干个页\",{\"1\":{\"413\":1}}],[\"再把auto\",{\"1\":{\"400\":1}}],[\"再把源文件读入内存\",{\"1\":{\"166\":1}}],[\"再更新到buffer\",{\"1\":{\"396\":1}}],[\"再次进行自旋操作\",{\"1\":{\"996\":1}}],[\"再次读操作\",{\"1\":{\"826\":1}}],[\"再次调用\",{\"1\":{\"546\":1}}],[\"再次调用是否产生两笔订单\",{\"1\":{\"313\":1}}],[\"再次确认链表头节点没有被移动\",{\"1\":{\"249\":1}}],[\"再进入这个构造看看\",{\"1\":{\"236\":1}}],[\"再进行第二轮扫描\",{\"1\":{\"163\":1}}],[\"再处理\",{\"1\":{\"194\":1}}],[\"再将其放入到redis中\",{\"1\":{\"984\":1}}],[\"再将数据写回到用户端的socket\",{\"1\":{\"961\":1}}],[\"再将要访问的页\",{\"1\":{\"418\":1}}],[\"再将一个字符串的第\",{\"1\":{\"336\":1}}],[\"再将原来数组赋值过去\",{\"1\":{\"323\":1}}],[\"再将内存中的数据写入到新文件中\",{\"1\":{\"166\":1}}],[\"再将内存中的页面都通过链接指针链接成一个循环队列\",{\"1\":{\"163\":1}}],[\"再将内存空间分为大小相同的页框\",{\"1\":{\"160\":1}}],[\"再将各段分页\",{\"1\":{\"160\":1}}],[\"再按照分区大小把进程拆分为一个个小部分\",{\"1\":{\"156\":1}}],[\"再重新调入内存\",{\"1\":{\"136\":1}}],[\"再设计一个咖啡店类\",{\"1\":{\"60\":1}}],[\"恶汉式\",{\"1\":{\"101\":1}}],[\"该怎么办\",{\"1\":{\"1026\":1}}],[\"该目录已经默认配置到环境变量\",{\"1\":{\"1012\":1}}],[\"该步是异步操作\",{\"1\":{\"804\":1}}],[\"该接口中包含如下三个方法\",{\"1\":{\"738\":1}}],[\"该注解适用于绑定url中的占位符\",{\"1\":{\"737\":1}}],[\"该注解的作用就是用来处理请求地址映射的\",{\"1\":{\"737\":1}}],[\"该模块为与aspectj的集成提供支持\",{\"1\":{\"705\":1}}],[\"该\",{\"1\":{\"667\":1}}],[\"该置换算法选择在之前时期使用最少的也页面作为淘汰页\",{\"1\":{\"420\":1}}],[\"该算法是指发送端即使还有应该发送的数据\",{\"1\":{\"751\":1}}],[\"该算法赋予每个页面一个访问字段\",{\"1\":{\"420\":1}}],[\"该算法解决了进程互斥问题\",{\"1\":{\"141\":1}}],[\"该事务执行期间\",{\"1\":{\"396\":1}}],[\"该函数会被应用到每个元素上\",{\"1\":{\"339\":1}}],[\"该对象才会进行初始化以及依赖注入的操作\",{\"1\":{\"707\":1}}],[\"该对象包含了如下信息\",{\"1\":{\"545\":1}}],[\"该对象提供了一组方法\",{\"1\":{\"332\":1}}],[\"该对象头的mark\",{\"1\":{\"211\":1}}],[\"该字符串首先由多个哈希函数生成不同的哈希值\",{\"1\":{\"273\":1}}],[\"该节点迁移完成后加入forwardingnode作为当前节点的头节点\",{\"1\":{\"249\":1}}],[\"该线程可以做其他事情\",{\"1\":{\"332\":1}}],[\"该线程可以在任何时刻\",{\"1\":{\"247\":1}}],[\"该线程进入阻塞状态同时不释放自己已有的资源\",{\"1\":{\"221\":1}}],[\"该方法含义是redis中如果没有这个key\",{\"1\":{\"988\":1}}],[\"该方法的执行还是nio线程\",{\"1\":{\"803\":1}}],[\"该方法会首先切换\",{\"1\":{\"797\":1}}],[\"该方法是每次读取一个字节数据\",{\"1\":{\"123\":1}}],[\"该方式也实现了懒加载效果\",{\"1\":{\"101\":1}}],[\"该方式在成员位置声明singleton类型的静态变量\",{\"1\":{\"101\":2}}],[\"该安全门具有防火\",{\"1\":{\"110\":1}}],[\"该类自jdk\",{\"1\":{\"260\":1}}],[\"该类中的方法不能被重写\",{\"1\":{\"236\":1}}],[\"该类负责创建自己的对象\",{\"1\":{\"99\":1}}],[\"该类同时实现当前系统的业务接口\",{\"1\":{\"42\":1}}],[\"方便我们操作redis\",{\"1\":{\"1031\":1}}],[\"方便咱们继续使用缓存\",{\"1\":{\"980\":1}}],[\"方便后续获得当前登录信息\",{\"1\":{\"959\":1}}],[\"方便维护\",{\"1\":{\"268\":1}}],[\"方便文件拓展\",{\"1\":{\"169\":2}}],[\"方便用户使用\",{\"1\":{\"126\":1}}],[\"方案分析\",{\"1\":{\"987\":1}}],[\"方案二\",{\"1\":{\"148\":1,\"1042\":1}}],[\"方案一\",{\"1\":{\"148\":1,\"1042\":1}}],[\"方式分别实现\",{\"1\":{\"449\":1}}],[\"方式解决\",{\"1\":{\"266\":1}}],[\"方式来实现单例模式的\",{\"1\":{\"105\":1}}],[\"方式4\",{\"1\":{\"101\":1}}],[\"方式3\",{\"1\":{\"101\":1}}],[\"方式2\",{\"1\":{\"101\":2}}],[\"方式1\",{\"1\":{\"101\":2}}],[\"方法就会返回这些事件交给\",{\"1\":{\"917\":1}}],[\"方法就会阻塞\",{\"1\":{\"791\":1}}],[\"方法拷贝数据\",{\"1\":{\"905\":1}}],[\"方法会将接收到的数据存入\",{\"1\":{\"898\":1}}],[\"方法会间接地调用\",{\"1\":{\"866\":1}}],[\"方法会让\",{\"1\":{\"853\":1}}],[\"方法并不能保证一次将\",{\"1\":{\"865\":1}}],[\"方法将文件内容和元数据\",{\"1\":{\"869\":1}}],[\"方法将\",{\"1\":{\"853\":1}}],[\"方法将数据写入并刷出\",{\"1\":{\"802\":1}}],[\"方法将数据写入\",{\"1\":{\"802\":1}}],[\"方法为\",{\"1\":{\"851\":1}}],[\"方法等待\",{\"1\":{\"835\":1}}],[\"方法计数加\",{\"1\":{\"825\":1}}],[\"方法计数减\",{\"1\":{\"825\":1}}],[\"方法签名\",{\"1\":{\"822\":1}}],[\"方法列表\",{\"1\":{\"822\":1}}],[\"方法参考如下\",{\"1\":{\"818\":1}}],[\"方法参数值数组\",{\"1\":{\"783\":1}}],[\"方法参数类型数组\",{\"1\":{\"783\":1}}],[\"方法参数封装为\",{\"1\":{\"473\":1}}],[\"方法参数的信息\",{\"1\":{\"473\":1}}],[\"方法参数说明\",{\"1\":{\"94\":1}}],[\"方法异步处理结果\",{\"1\":{\"803\":1}}],[\"方法可以让异步操作同步以外\",{\"1\":{\"803\":1}}],[\"方法执行就返回了\",{\"1\":{\"803\":1}}],[\"方法执行结果为true\",{\"1\":{\"104\":1}}],[\"方法添加处理器\",{\"1\":{\"802\":1}}],[\"方法是同步等待连接建立完成\",{\"1\":{\"803\":1}}],[\"方法是异步非阻塞的\",{\"1\":{\"803\":1}}],[\"方法是异步等待\",{\"1\":{\"802\":1}}],[\"方法是抽象方法\",{\"1\":{\"123\":1}}],[\"方法作用是同步等待\",{\"1\":{\"802\":1}}],[\"方法判断一个线程是否属于此\",{\"1\":{\"796\":1}}],[\"方法处理\",{\"1\":{\"796\":1}}],[\"方法即使没有时间发生\",{\"1\":{\"792\":1}}],[\"方法无谓阻塞\",{\"1\":{\"791\":1}}],[\"方法不会阻塞\",{\"1\":{\"791\":1}}],[\"方法见下\",{\"1\":{\"791\":1}}],[\"方法返回类型\",{\"1\":{\"783\":1}}],[\"方法4\",{\"0\":{\"756\":1},\"1\":{\"990\":1}}],[\"方法3\",{\"0\":{\"755\":1},\"1\":{\"882\":1,\"990\":1}}],[\"方法2\",{\"0\":{\"754\":1},\"1\":{\"829\":1,\"882\":1,\"990\":1}}],[\"方法1\",{\"0\":{\"753\":1},\"1\":{\"829\":1,\"882\":1,\"990\":1}}],[\"方法均无法增强\",{\"1\":{\"686\":1}}],[\"方法均不能通过代理实现\",{\"1\":{\"516\":1}}],[\"方法测试\",{\"1\":{\"648\":1}}],[\"方法创建模型工厂\",{\"1\":{\"596\":1}}],[\"方法创建绑定工厂\",{\"1\":{\"588\":1}}],[\"方法创建具体的商品类的对象\",{\"1\":{\"78\":1}}],[\"方法调用后\",{\"1\":{\"904\":1}}],[\"方法调用链中下一个环绕通知\",{\"1\":{\"552\":1}}],[\"方法调用了\",{\"1\":{\"123\":1}}],[\"方法反射优化\",{\"0\":{\"517\":1}}],[\"方法重写可以增强逻辑\",{\"1\":{\"516\":1}}],[\"方法时\",{\"1\":{\"500\":1,\"527\":1,\"790\":1}}],[\"方法的返回值\",{\"1\":{\"893\":1}}],[\"方法的返回值代表有多少\",{\"1\":{\"882\":1}}],[\"方法的返回值即为要导入的配置类名\",{\"1\":{\"671\":1}}],[\"方法的效果\",{\"1\":{\"792\":1}}],[\"方法的目的类似\",{\"1\":{\"500\":1}}],[\"方法的区别是什么呢\",{\"0\":{\"245\":1}}],[\"方法上的目的是可以观察输出\",{\"1\":{\"500\":1}}],[\"方法上添加了synchronized关键字\",{\"1\":{\"101\":1}}],[\"方法进行基于类型的查找\",{\"1\":{\"473\":1}}],[\"方法进行等待\",{\"1\":{\"263\":1}}],[\"方法区\",{\"1\":{\"350\":1}}],[\"方法中\",{\"1\":{\"998\":1}}],[\"方法中首次创建\",{\"1\":{\"825\":1}}],[\"方法中会\",{\"1\":{\"815\":1}}],[\"方法中定义的局部变量是否线程安全\",{\"0\":{\"349\":1}}],[\"方法中又调用了invocationhandler接口的子实现类对象的invoke方法\",{\"1\":{\"94\":1}}],[\"方法和\",{\"0\":{\"245\":1},\"1\":{\"588\":1,\"596\":1}}],[\"方法之后的状态\",{\"1\":{\"208\":1}}],[\"方法二\",{\"1\":{\"152\":1}}],[\"方法一\",{\"1\":{\"152\":1}}],[\"方法后\",{\"1\":{\"104\":1,\"905\":2}}],[\"方法被调用时才会被加载\",{\"1\":{\"101\":1}}],[\"方法获取文件的大小\",{\"1\":{\"868\":1}}],[\"方法获取索引\",{\"1\":{\"853\":1}}],[\"方法获取集合中下一个\",{\"1\":{\"796\":1}}],[\"方法获取singleton类的对象的时候才创建singleton类的对象\",{\"1\":{\"101\":1}}],[\"方法获取形状类型的对象\",{\"1\":{\"58\":1}}],[\"方法来处理下一个\",{\"1\":{\"909\":2}}],[\"方法来获取\",{\"1\":{\"803\":1}}],[\"方法来绑定其中一个\",{\"1\":{\"796\":1}}],[\"方法来看看自己属于哪个\",{\"1\":{\"796\":1}}],[\"方法来排序\",{\"1\":{\"325\":1}}],[\"方法来说\",{\"1\":{\"101\":1}}],[\"方法来实现浅克隆\",{\"1\":{\"86\":1}}],[\"方法来复制新的对象\",{\"1\":{\"85\":1}}],[\"方法\",{\"1\":{\"85\":2,\"94\":3,\"104\":2,\"123\":3,\"206\":1,\"208\":1,\"260\":1,\"321\":2,\"354\":1,\"588\":2,\"596\":2,\"616\":2,\"643\":1,\"644\":4,\"650\":1,\"686\":2,\"711\":3,\"787\":1,\"791\":1,\"793\":1,\"797\":1,\"803\":1,\"830\":1,\"848\":1,\"852\":2,\"853\":2,\"863\":1,\"866\":1,\"890\":1,\"904\":1,\"905\":1,\"993\":1,\"998\":1}}],[\"方法使用的是工厂模式\",{\"1\":{\"78\":2}}],[\"本来应该去查询数据库\",{\"1\":{\"987\":1}}],[\"本地缓存与redis中的缓存并发使用\",{\"1\":{\"976\":1}}],[\"本地缓存\",{\"1\":{\"974\":1}}],[\"本地用于高并发\",{\"1\":{\"974\":1}}],[\"本地测试不走网卡\",{\"1\":{\"751\":1}}],[\"本地回环地址的\",{\"1\":{\"751\":1}}],[\"本地服务通过网络请求远程服务\",{\"1\":{\"98\":1}}],[\"本质是一个单线程执行器\",{\"1\":{\"796\":1}}],[\"本质是因为\",{\"1\":{\"751\":1}}],[\"本质上是根据成员变量或方法参数的类型进行装配\",{\"1\":{\"695\":1}}],[\"本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理\",{\"1\":{\"410\":1}}],[\"本质上并没有区别\",{\"1\":{\"387\":1}}],[\"本质上和get一样\",{\"1\":{\"314\":1}}],[\"本身并不具备\",{\"1\":{\"904\":1}}],[\"本身当作\",{\"1\":{\"627\":1}}],[\"本身也是分布式的\",{\"1\":{\"433\":1}}],[\"本组映射器和适配器\",{\"0\":{\"625\":1,\"629\":1,\"633\":1}}],[\"本例共用同一个\",{\"1\":{\"545\":1}}],[\"本文摘录自阿里巴巴java开发手册mysql数据库篇\",{\"1\":{\"264\":1}}],[\"本轮将所有扫描过的帧访问位设为0\",{\"1\":{\"163\":1}}],[\"本轮扫描不修改任何标志位\",{\"1\":{\"163\":2}}],[\"本节要介绍的抽象工厂模式将考虑多等级产品的生产\",{\"1\":{\"71\":1}}],[\"6f\",{\"1\":{\"857\":2,\"858\":1,\"886\":2,\"898\":1}}],[\"6c\",{\"1\":{\"798\":2,\"886\":3,\"898\":2}}],[\"6e\",{\"1\":{\"798\":6,\"857\":1}}],[\"6b\",{\"1\":{\"756\":1,\"798\":2}}],[\"65536\",{\"1\":{\"849\":1}}],[\"65535\",{\"1\":{\"751\":1}}],[\"65\",{\"1\":{\"755\":20,\"756\":30,\"857\":3,\"858\":1,\"886\":1,\"898\":1}}],[\"60378\",{\"1\":{\"886\":1}}],[\"60367\",{\"1\":{\"886\":1}}],[\"60f82f98\",{\"1\":{\"796\":3}}],[\"60b\",{\"1\":{\"755\":1}}],[\"60l\",{\"1\":{\"244\":1}}],[\"6a\",{\"1\":{\"754\":8,\"755\":22,\"756\":18}}],[\"69\",{\"1\":{\"754\":10,\"755\":14,\"756\":28,\"798\":4,\"858\":1}}],[\"68\",{\"1\":{\"754\":2,\"755\":8,\"756\":4,\"798\":2,\"857\":1,\"886\":1,\"898\":1}}],[\"67\",{\"1\":{\"754\":6,\"755\":14,\"756\":4,\"798\":4}}],[\"6379\",{\"1\":{\"767\":1,\"1015\":1,\"1018\":1,\"1032\":1,\"1034\":1,\"1035\":1,\"1039\":1}}],[\"6379>\",{\"1\":{\"426\":4,\"1024\":24,\"1025\":25,\"1027\":18,\"1028\":5,\"1029\":16}}],[\"63641\",{\"1\":{\"755\":15}}],[\"63\",{\"1\":{\"754\":4,\"755\":6,\"756\":12}}],[\"62\",{\"1\":{\"754\":2,\"755\":6,\"756\":18}}],[\"61\",{\"1\":{\"754\":8,\"755\":2,\"756\":18,\"798\":6,\"907\":1}}],[\"6442450941\",{\"1\":{\"870\":1}}],[\"64kib\",{\"1\":{\"849\":1}}],[\"64\",{\"1\":{\"410\":1,\"754\":2,\"755\":4,\"756\":16,\"876\":1,\"886\":1}}],[\"64位机器上就是32\",{\"1\":{\"410\":1}}],[\"64位机默认是2048个\",{\"1\":{\"410\":1}}],[\"6中新特性\",{\"1\":{\"385\":1}}],[\"6622fc65\",{\"1\":{\"500\":2}}],[\"66259338\",{\"1\":{\"12\":1}}],[\"66\",{\"1\":{\"337\":6,\"754\":8,\"755\":4,\"756\":26,\"858\":2}}],[\"6666\",{\"1\":{\"337\":1}}],[\"6之前采用的是双向循环链表\",{\"1\":{\"322\":1}}],[\"6之前比使用java反射效率要高\",{\"1\":{\"96\":1}}],[\"6和jdk1\",{\"1\":{\"96\":1}}],[\"6\",{\"0\":{\"130\":1,\"152\":1,\"171\":1,\"487\":1,\"740\":1,\"780\":1,\"788\":1,\"823\":1,\"927\":1,\"941\":1,\"963\":1,\"985\":1,\"997\":1,\"1016\":1,\"1028\":1},\"1\":{\"96\":1,\"135\":1,\"211\":1,\"342\":1,\"420\":1,\"423\":2,\"655\":1,\"743\":1,\"744\":1,\"749\":2,\"750\":3,\"753\":1,\"754\":11,\"755\":11,\"756\":11,\"770\":1,\"771\":1,\"773\":2,\"790\":1,\"798\":6,\"816\":7,\"822\":2,\"823\":2,\"824\":3,\"826\":6,\"829\":5,\"830\":4,\"834\":2,\"835\":3,\"846\":1,\"849\":1,\"855\":2,\"857\":3,\"858\":2,\"886\":2,\"898\":1,\"906\":1,\"907\":1,\"923\":1,\"941\":1,\"960\":1,\"961\":1,\"968\":1,\"972\":1,\"989\":5,\"990\":6,\"995\":4,\"998\":3,\"1012\":4,\"1015\":4,\"1016\":2,\"1024\":1,\"1027\":2,\"1028\":3}}],[\"设定当类路径下包含某个jar包才会对注解的类进行实例化操作\",{\"1\":{\"731\":1}}],[\"设备状态\",{\"1\":{\"296\":1}}],[\"设备位置\",{\"1\":{\"296\":1}}],[\"设备型号\",{\"1\":{\"296\":1}}],[\"设备类型\",{\"1\":{\"296\":1}}],[\"设备表字段\",{\"1\":{\"296\":1}}],[\"设备名称\",{\"1\":{\"296\":2}}],[\"设备编号\",{\"1\":{\"296\":2}}],[\"设备分配改进\",{\"1\":{\"185\":1}}],[\"设备分配的步骤\",{\"1\":{\"185\":1}}],[\"设备分配管理中的数据结构\",{\"1\":{\"185\":1}}],[\"设备分配中的安全性\",{\"1\":{\"185\":1}}],[\"设备分配时应考虑的因素\",{\"1\":{\"185\":1}}],[\"设备保护\",{\"1\":{\"183\":1}}],[\"设备驱动程序\",{\"1\":{\"182\":1,\"183\":1}}],[\"设备的分配算法\",{\"1\":{\"185\":1}}],[\"设备的分配与回收\",{\"0\":{\"185\":1},\"1\":{\"182\":1}}],[\"设备的固有属性\",{\"1\":{\"185\":1}}],[\"设备的保护\",{\"1\":{\"182\":1}}],[\"设备被看做是一种特殊的文件\",{\"1\":{\"182\":1,\"183\":1}}],[\"设备独立性软件\",{\"1\":{\"182\":2,\"183\":1}}],[\"设备管理模块\",{\"1\":{\"296\":1}}],[\"设备管理\",{\"1\":{\"126\":1}}],[\"设磁盘转速为r\",{\"1\":{\"176\":1}}],[\"设置value的序列化\",{\"1\":{\"1041\":1}}],[\"设置key的序列化\",{\"1\":{\"1041\":1}}],[\"设置连接工厂\",{\"1\":{\"1041\":1}}],[\"设置密码\",{\"1\":{\"1032\":1}}],[\"设置名称\",{\"1\":{\"1025\":1}}],[\"设置redis能够使用的最大内存\",{\"1\":{\"1015\":1}}],[\"设置redis缓存时添加过期时间\",{\"1\":{\"983\":1}}],[\"设置为1\",{\"1\":{\"1015\":1}}],[\"设置后访问redis必须输入密码\",{\"1\":{\"1015\":1}}],[\"设置状态码\",{\"1\":{\"972\":1}}],[\"设置token有效期\",{\"1\":{\"968\":1}}],[\"设置查询条件\",{\"1\":{\"950\":1}}],[\"设置查询分页\",{\"1\":{\"950\":2}}],[\"设置当前位置时\",{\"1\":{\"867\":1}}],[\"设置当前位置\",{\"1\":{\"867\":1}}],[\"设置回调\",{\"1\":{\"811\":1}}],[\"设置回调函数\",{\"1\":{\"95\":1}}],[\"设置失败结果\",{\"1\":{\"806\":1}}],[\"设置成功结果\",{\"1\":{\"806\":1}}],[\"设置选项\",{\"1\":{\"793\":1}}],[\"设置其是否完成\",{\"1\":{\"790\":1}}],[\"设置属性\",{\"1\":{\"758\":1}}],[\"设置太大\",{\"1\":{\"751\":1}}],[\"设置监听端口\",{\"1\":{\"655\":1}}],[\"设置了过期时间的key被没有设置过期时间的相同key覆盖了\",{\"1\":{\"426\":1}}],[\"设置了多个累加单元\",{\"1\":{\"249\":1}}],[\"设置默认的数据源或者数据源组\",{\"1\":{\"372\":1}}],[\"设置对象的对象头\",{\"1\":{\"352\":2}}],[\"设置自己的head节点\",{\"1\":{\"261\":1}}],[\"设置多个累加单元\",{\"1\":{\"234\":1}}],[\"设置多级就绪队列\",{\"1\":{\"139\":1}}],[\"设置线控器线程\",{\"1\":{\"206\":1}}],[\"设置还原点\",{\"1\":{\"150\":1}}],[\"设置同步信号量s\",{\"1\":{\"144\":1}}],[\"设置互斥信号量\",{\"1\":{\"144\":1}}],[\"设置父类的字节码对象\",{\"1\":{\"95\":1}}],[\"设计key的具体细节\",{\"0\":{\"966\":1}}],[\"设计key的结构\",{\"0\":{\"965\":1}}],[\"设计时要充分考虑别让\",{\"1\":{\"896\":1}}],[\"设计应用的横切关注点\",{\"1\":{\"716\":1}}],[\"设计不同类型的结构体\",{\"1\":{\"277\":1}}],[\"设计了\",{\"1\":{\"275\":1}}],[\"设计思想\",{\"1\":{\"153\":1}}],[\"设计也更加抽象\",{\"1\":{\"121\":1}}],[\"设计一个登录请求消息和登录响应消息\",{\"1\":{\"770\":1}}],[\"设计一个系统时知道了算法所需的关键步骤\",{\"1\":{\"118\":1}}],[\"设计一个咖啡类\",{\"1\":{\"60\":1}}],[\"设计一个咖啡店点餐系统\",{\"1\":{\"60\":1}}],[\"设计者充分的利用了枚举的这个特性来实现单例模式\",{\"1\":{\"101\":1}}],[\"设计模式\",{\"0\":{\"56\":1}}],[\"很久很久以前\",{\"1\":{\"766\":1}}],[\"很多地方都有\",{\"1\":{\"1033\":1}}],[\"很多地方体现零拷贝\",{\"1\":{\"831\":1}}],[\"很多起步依赖的命名都暗示了它们提供的某种或某类功能\",{\"1\":{\"727\":1}}],[\"很多时候major\",{\"1\":{\"350\":1}}],[\"很多业务中多有多个状态\",{\"1\":{\"315\":1}}],[\"很有可能因为网络\",{\"1\":{\"313\":1}}],[\"很喜欢南京这个地方\",{\"1\":{\"307\":1}}],[\"很看重团队的人\",{\"1\":{\"306\":1}}],[\"很希望在贵公司得到一次实习的机会\",{\"1\":{\"293\":1}}],[\"很明显\",{\"1\":{\"276\":1}}],[\"很可能在值比较时\",{\"1\":{\"265\":1}}],[\"很频繁\",{\"1\":{\"181\":1}}],[\"很方便实现信息的共享和保护\",{\"1\":{\"160\":1}}],[\"很显然如果实现safetydoor接口就违背了接口隔离原则\",{\"1\":{\"110\":1}}],[\"很显然jdk代理是无法使用了\",{\"1\":{\"95\":1}}],[\"很容易发生类爆炸情况\",{\"1\":{\"74\":1}}],[\"执行下面的命令\",{\"1\":{\"1016\":1}}],[\"执行完一个分线程就减少一个变量\",{\"1\":{\"993\":1}}],[\"执行完每个指令之后\",{\"1\":{\"129\":1}}],[\"执行计算\",{\"1\":{\"807\":1,\"808\":1}}],[\"执行到\",{\"1\":{\"803\":4}}],[\"执行中如何换人\",{\"0\":{\"799\":1}}],[\"执行后就是\",{\"1\":{\"793\":1}}],[\"执行端口绑定\",{\"1\":{\"790\":1}}],[\"执行初始化器\",{\"1\":{\"793\":1}}],[\"执行初始化\",{\"1\":{\"790\":1}}],[\"执行初始化和注册\",{\"1\":{\"790\":1}}],[\"执行aftercompletion方法\",{\"1\":{\"738\":1}}],[\"执行视图解析和视图渲染\",{\"1\":{\"738\":1}}],[\"执行posthandler方法\",{\"1\":{\"738\":1}}],[\"执行prehandle方法\",{\"1\":{\"738\":1}}],[\"执行处理器逻辑\",{\"1\":{\"738\":1}}],[\"执行环绕通知1\",{\"1\":{\"546\":1}}],[\"执行环绕通知2\",{\"1\":{\"546\":1}}],[\"执行目标方法\",{\"1\":{\"546\":1}}],[\"执行前\",{\"1\":{\"793\":1}}],[\"执行前增强\",{\"1\":{\"546\":2}}],[\"执行前需要将该程序放到内存中\",{\"1\":{\"126\":1}}],[\"执行顺序为\",{\"1\":{\"495\":1}}],[\"执行内核态代码\",{\"1\":{\"406\":1}}],[\"执行垃圾收集时\",{\"1\":{\"359\":1}}],[\"执行init方法\",{\"1\":{\"352\":1}}],[\"执行init方法进行初始化\",{\"1\":{\"352\":1}}],[\"执行实例化代码块\",{\"1\":{\"352\":1}}],[\"执行sql时\",{\"1\":{\"268\":1}}],[\"执行两个操作\",{\"1\":{\"144\":1}}],[\"执行只能一气呵成\",{\"1\":{\"143\":1}}],[\"执行过程中不允许中断\",{\"1\":{\"142\":1}}],[\"执行一个特权指令\",{\"1\":{\"129\":1}}],[\"执行的方法\",{\"1\":{\"711\":1}}],[\"执行的最基本命令\",{\"1\":{\"128\":1}}],[\"执行的是代理类\",{\"1\":{\"94\":1}}],[\"执行\",{\"0\":{\"245\":1},\"1\":{\"104\":1,\"290\":1,\"491\":1,\"650\":2,\"790\":2,\"793\":1,\"834\":1,\"835\":1}}],[\"执行流程如下\",{\"1\":{\"94\":1}}],[\"执行真实对象\",{\"1\":{\"94\":1}}],[\"程序只需要和\",{\"1\":{\"705\":1}}],[\"程序中\",{\"1\":{\"496\":1}}],[\"程序中使用的绝对地址\",{\"1\":{\"151\":1}}],[\"程序在运行时\",{\"1\":{\"418\":1}}],[\"程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区\",{\"1\":{\"415\":1}}],[\"程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区\",{\"1\":{\"415\":1}}],[\"程序较为简单容易实现\",{\"1\":{\"334\":1}}],[\"程序切换到哪个channel是由\",{\"1\":{\"332\":1}}],[\"程序内部并不会判断缓冲区大小是否足够用\",{\"1\":{\"277\":1}}],[\"程序不会对其中的数据做任何限制\",{\"1\":{\"277\":1}}],[\"程序的用户态切换至内核态\",{\"1\":{\"904\":1,\"905\":2}}],[\"程序的工作线程被暂停的时间\",{\"1\":{\"359\":1}}],[\"程序的运行时间a\",{\"1\":{\"359\":1}}],[\"程序的原子性是指整个程序中的所有操作\",{\"1\":{\"226\":1}}],[\"程序的可移植性降低\",{\"1\":{\"108\":1}}],[\"程序直接控制方式\",{\"1\":{\"181\":1}}],[\"程序按照自身的逻辑关系划分为若干个段\",{\"1\":{\"159\":1}}],[\"程序执行前需要先放到内存中才能被cpu处理\",{\"1\":{\"151\":1}}],[\"程序运行时产生的数据存储的位置\",{\"1\":{\"131\":1}}],[\"程序运行过程中动态生成的代理类\",{\"1\":{\"94\":1}}],[\"程序代码存放的位置\",{\"1\":{\"131\":1}}],[\"程序段和数据段组成的\",{\"1\":{\"131\":1}}],[\"程序段\",{\"1\":{\"131\":2}}],[\"程序\",{\"1\":{\"131\":1}}],[\"程序计数器\",{\"1\":{\"129\":1,\"137\":1}}],[\"程序接口\",{\"1\":{\"126\":1}}],[\"程序员一般只能和逻辑地址打交道\",{\"1\":{\"414\":1}}],[\"程序员编程时需要显示的给出段号\",{\"1\":{\"160\":1}}],[\"程序员常常会遇到这种情况\",{\"1\":{\"118\":1}}],[\"程序员要尽量根据6条原则来开发程序\",{\"1\":{\"106\":1}}],[\"程序媛教你一看就懂的适配器设计模式\",{\"1\":{\"38\":1}}],[\"下单核心逻辑分析\",{\"1\":{\"995\":1}}],[\"下单核心思路\",{\"1\":{\"995\":1}}],[\"下单时需要判断两点\",{\"1\":{\"995\":1}}],[\"下\",{\"1\":{\"883\":1}}],[\"下雨天\",{\"1\":{\"766\":1}}],[\"下雨天留客\",{\"1\":{\"766\":1}}],[\"下雨天留客天留我不留\",{\"1\":{\"766\":1}}],[\"下来\",{\"1\":{\"745\":1}}],[\"下一个\",{\"1\":{\"799\":1}}],[\"下一个要被读或者写的索引\",{\"1\":{\"332\":1}}],[\"下一步就是设置几个参数\",{\"1\":{\"95\":1}}],[\"下次用户过来访问这个不存在的数据\",{\"1\":{\"984\":1}}],[\"下次循环就会\",{\"1\":{\"792\":1}}],[\"下次循环计数重置\",{\"1\":{\"263\":1}}],[\"下次调用epoll\",{\"1\":{\"410\":1}}],[\"下次在操作\",{\"1\":{\"277\":1}}],[\"下图表示写入了\",{\"1\":{\"848\":1}}],[\"下图对应的是\",{\"1\":{\"705\":1}}],[\"下图就是\",{\"1\":{\"277\":1}}],[\"下图就是字符串\",{\"1\":{\"276\":1}}],[\"下图显示了\",{\"1\":{\"276\":1}}],[\"下图是旧的hash表\",{\"1\":{\"249\":1}}],[\"下图描述的是不同锁状态下mark\",{\"1\":{\"210\":1}}],[\"下图runnable中的阻塞状态应该去除\",{\"1\":{\"208\":1}}],[\"下图所示横轴是产品等级\",{\"1\":{\"71\":1}}],[\"下限地址\",{\"1\":{\"152\":1}}],[\"下限寄存器\",{\"1\":{\"152\":1}}],[\"下锅的酱料是蒜蓉\",{\"1\":{\"120\":1}}],[\"下锅的酱料是辣椒\",{\"1\":{\"120\":1}}],[\"下锅的蔬菜是菜心\",{\"1\":{\"120\":1}}],[\"下锅的蔬菜是包菜\",{\"1\":{\"120\":1}}],[\"下面的\",{\"1\":{\"791\":1}}],[\"下面一种协议较为常用\",{\"1\":{\"766\":1}}],[\"下面我们再一起学习下几个需要子类实现的方法\",{\"1\":{\"255\":1}}],[\"下面两点只是纯理论说法\",{\"1\":{\"246\":1}}],[\"下面才是真正的创建新的string对象\",{\"1\":{\"236\":1}}],[\"下面看一个例子来理解合成复用原则\",{\"1\":{\"112\":1}}],[\"下面看一个例子来理解迪米特法则\",{\"1\":{\"111\":1}}],[\"下面看一个例子来理解接口隔离原则\",{\"1\":{\"110\":1}}],[\"下面看一个例子来理解依赖倒转原则\",{\"1\":{\"109\":1}}],[\"下面以\",{\"1\":{\"107\":1}}],[\"下面是为了解决序列化反序列化破解单例模式\",{\"1\":{\"104\":1}}],[\"下面是摘取的重点代码\",{\"1\":{\"94\":1}}],[\"$3\",{\"1\":{\"767\":5}}],[\"$和\",{\"0\":{\"366\":1}}],[\"$\",{\"1\":{\"176\":1,\"366\":2,\"454\":1,\"490\":1,\"568\":1,\"617\":1,\"688\":1,\"691\":1,\"731\":2}}],[\"$proxy0\",{\"1\":{\"94\":8,\"515\":4}}],[\"$$\",{\"1\":{\"26\":2}}],[\"查数据库\",{\"1\":{\"990\":1}}],[\"查看一个key的剩余有效期\",{\"1\":{\"1024\":1}}],[\"查看符合模板的所有key\",{\"1\":{\"1024\":1}}],[\"查看状态\",{\"1\":{\"1016\":1}}],[\"查看成员\",{\"1\":{\"761\":1}}],[\"查看需要的类型\",{\"1\":{\"688\":1}}],[\"查看需要的类型是否为\",{\"1\":{\"688\":2}}],[\"查看\",{\"1\":{\"449\":1}}],[\"查看代理类的结构\",{\"1\":{\"94\":1}}],[\"查了很多资料解释是idea进行了预处理\",{\"1\":{\"365\":1}}],[\"查询速度快\",{\"1\":{\"1030\":1}}],[\"查询速度一般\",{\"1\":{\"1028\":1}}],[\"查询张三和李四的好友总共有哪些人\",{\"1\":{\"1029\":1}}],[\"查询哪些人是张三的好友却不是李四的好友\",{\"1\":{\"1029\":1}}],[\"查询以a开头的key\",{\"1\":{\"1024\":1}}],[\"查询以str为前缀的单词数量\",{\"1\":{\"282\":1}}],[\"查询性能上关系型与非关系型也都有着显著差异\",{\"1\":{\"1008\":1}}],[\"查询方式\",{\"0\":{\"1006\":1}}],[\"查询订单\",{\"1\":{\"998\":2}}],[\"查询优惠券\",{\"1\":{\"995\":1,\"998\":1}}],[\"查询到优惠卷信息\",{\"1\":{\"995\":1}}],[\"查询店铺数据\",{\"1\":{\"989\":1}}],[\"查询后将数据写入redis\",{\"1\":{\"988\":1}}],[\"查询时发现缓存中没有数据\",{\"1\":{\"983\":1}}],[\"查询时再更新缓存\",{\"1\":{\"982\":1}}],[\"查询结果\",{\"1\":{\"950\":1}}],[\"查询字段过滤\",{\"0\":{\"940\":1},\"1\":{\"940\":1}}],[\"查询排序\",{\"0\":{\"939\":1},\"1\":{\"939\":1}}],[\"查询数据库\",{\"1\":{\"998\":1}}],[\"查询数据\",{\"1\":{\"934\":1}}],[\"查询文档\",{\"1\":{\"934\":1}}],[\"查询索引中所有的数据\",{\"0\":{\"936\":1},\"1\":{\"936\":1}}],[\"查询索引\",{\"1\":{\"933\":2}}],[\"查询条件的字段\",{\"1\":{\"383\":1}}],[\"查询\",{\"1\":{\"381\":1}}],[\"查询前index位置的前缀和\",{\"1\":{\"287\":1}}],[\"查找快\",{\"1\":{\"1029\":1}}],[\"查找控制器方法\",{\"1\":{\"644\":1}}],[\"查找方式与\",{\"1\":{\"527\":1}}],[\"查找与匹配\",{\"0\":{\"341\":1}}],[\"查找该单词是否存在\",{\"1\":{\"282\":1}}],[\"查找效率低\",{\"1\":{\"169\":1}}],[\"查找第一个\",{\"1\":{\"163\":3}}],[\"查过阈值\",{\"1\":{\"25\":1}}],[\"诊断工具\",{\"1\":{\"94\":1}}],[\"接着同一时间去访问数据库\",{\"1\":{\"987\":1}}],[\"接着切换到应用程序线程\",{\"1\":{\"356\":1}}],[\"接着在堆中划分一块内存给新对象\",{\"1\":{\"352\":1}}],[\"接着统计每个小文件中出现频数最高的100个词\",{\"1\":{\"290\":1}}],[\"接下来要向网卡写数据\",{\"1\":{\"904\":1}}],[\"接下来服务器端输出\",{\"1\":{\"898\":1}}],[\"接下来的处理也移交至\",{\"1\":{\"793\":1}}],[\"接下来勾选\",{\"1\":{\"647\":1}}],[\"接下来会\",{\"1\":{\"644\":1}}],[\"接下来41位存储毫秒级时间戳\",{\"1\":{\"440\":1}}],[\"接下来看另外一种解法\",{\"1\":{\"290\":1}}],[\"接下来我们一起看看\",{\"1\":{\"276\":1}}],[\"接下来我们使用动态代理实现上面案例\",{\"1\":{\"94\":1}}],[\"接下来thread\",{\"1\":{\"261\":1}}],[\"接收缓冲区\",{\"1\":{\"900\":1}}],[\"接收缓冲区大小\",{\"1\":{\"781\":1}}],[\"接收客户端发送的数据\",{\"1\":{\"876\":1,\"877\":1}}],[\"接收结果的线程\",{\"1\":{\"809\":1}}],[\"接收结果\",{\"1\":{\"787\":1,\"808\":1}}],[\"接收响应消息\",{\"1\":{\"759\":1}}],[\"接收方也会维护一个窗口\",{\"1\":{\"751\":1}}],[\"接收方\",{\"1\":{\"751\":2}}],[\"接收到处理后的数据\",{\"1\":{\"744\":1}}],[\"接收到数据\",{\"1\":{\"743\":1}}],[\"接收到数据之后会自动将数据绑定到java对象上去\",{\"1\":{\"731\":1,\"737\":1}}],[\"接收到一个数据\",{\"1\":{\"743\":1,\"744\":1}}],[\"接收一个collector接口的实现\",{\"1\":{\"343\":1}}],[\"接收一个的函数作为参数\",{\"1\":{\"339\":1}}],[\"接收一个函数作为参数\",{\"1\":{\"339\":1}}],[\"接收lambda\",{\"1\":{\"339\":1}}],[\"接收\",{\"1\":{\"338\":1,\"751\":2}}],[\"接收新任务\",{\"1\":{\"241\":1}}],[\"接收消息\",{\"1\":{\"134\":1}}],[\"接收调度的基本单位\",{\"1\":{\"131\":1}}],[\"接口提供遍历\",{\"1\":{\"796\":1}}],[\"接口提供了一种\",{\"1\":{\"490\":2}}],[\"接口回调\",{\"1\":{\"678\":1}}],[\"接口只是作为\",{\"1\":{\"661\":1}}],[\"接口就可以被管理呢\",{\"1\":{\"661\":1}}],[\"接口时为何要提供\",{\"1\":{\"572\":1}}],[\"接口来进行初始化\",{\"1\":{\"495\":1}}],[\"接口及\",{\"0\":{\"488\":1}}],[\"接口被\",{\"1\":{\"486\":1}}],[\"接口与加了\",{\"1\":{\"466\":1}}],[\"接口的销毁方法\",{\"1\":{\"495\":1}}],[\"接口的初始化方法\",{\"1\":{\"495\":1}}],[\"接口的优先级最高\",{\"1\":{\"466\":1}}],[\"接口的实现\",{\"1\":{\"451\":1}}],[\"接口的功能\",{\"1\":{\"446\":1}}],[\"接口中声明抽象方法\",{\"1\":{\"336\":1}}],[\"接口中的成员变量只能是public\",{\"1\":{\"317\":1}}],[\"接口主要用于对类的行为进行约束\",{\"1\":{\"317\":1}}],[\"接口和抽象类有什么共同点和区别\",{\"0\":{\"317\":1}}],[\"接口隔离原则\",{\"0\":{\"110\":1}}],[\"接口是上面的类图中的抽象原型类\",{\"1\":{\"86\":1}}],[\"接口类图如下\",{\"1\":{\"85\":1}}],[\"接口\",{\"0\":{\"484\":1,\"487\":1,\"488\":1},\"1\":{\"40\":1,\"48\":1,\"110\":3,\"244\":1,\"446\":2,\"458\":1,\"476\":1,\"528\":2,\"572\":1,\"627\":1,\"631\":1,\"643\":2,\"661\":1,\"672\":1,\"699\":1,\"773\":1,\"825\":1}}],[\"坐车到火车站\",{\"1\":{\"93\":1}}],[\"控制锁粒度\",{\"1\":{\"998\":1}}],[\"控制\",{\"1\":{\"781\":1}}],[\"控制有哪些错误信息\",{\"1\":{\"622\":1}}],[\"控制器\",{\"1\":{\"734\":1}}],[\"控制器方法返回值\",{\"1\":{\"647\":1}}],[\"控制器方法会被封装为\",{\"1\":{\"644\":1}}],[\"控制器方法执行流程\",{\"0\":{\"589\":1}}],[\"控制器方法调用时\",{\"1\":{\"588\":1,\"596\":1}}],[\"控制器方法被封装为\",{\"1\":{\"568\":1}}],[\"控制器私有范围\",{\"1\":{\"582\":1}}],[\"控制器对象\",{\"1\":{\"561\":1}}],[\"控制在1000个之内\",{\"1\":{\"267\":1}}],[\"控制寄存器\",{\"1\":{\"180\":1}}],[\"控制对一个对象的访问\",{\"1\":{\"98\":1}}],[\"控制或扩展真实主题的功能\",{\"1\":{\"92\":1}}],[\"控制调用先后次序\",{\"1\":{\"49\":1}}],[\"真正执行connect是nioeventloopgroup中的线程\",{\"1\":{\"803\":1}}],[\"真正执行转换\",{\"1\":{\"576\":1}}],[\"真个是不亦乐乎\",{\"1\":{\"766\":1}}],[\"真实项目中\",{\"1\":{\"679\":1}}],[\"真实对象中的方法的method实例\",{\"1\":{\"95\":1}}],[\"真实对象所实现的接口\",{\"1\":{\"94\":1}}],[\"真实主题\",{\"1\":{\"92\":1}}],[\"真皮车座\",{\"1\":{\"49\":1}}],[\"真皮等材质\",{\"1\":{\"49\":1}}],[\"动作发生后\",{\"1\":{\"848\":2}}],[\"动过了\",{\"1\":{\"233\":1}}],[\"动态通知调用复杂程度高\",{\"1\":{\"556\":1}}],[\"动态通知调用\",{\"0\":{\"553\":1}}],[\"动态设置表名的问题\",{\"1\":{\"366\":1}}],[\"动态规划\",{\"1\":{\"194\":1,\"195\":1}}],[\"动态分配\",{\"1\":{\"185\":1}}],[\"动态分区分配算法\",{\"0\":{\"155\":1}}],[\"动态分区分配\",{\"1\":{\"154\":1}}],[\"动态重定位时允许程序在内存中发生移动\",{\"1\":{\"151\":1}}],[\"动态重定位\",{\"1\":{\"151\":1}}],[\"动态性\",{\"1\":{\"131\":1}}],[\"动态代理实现为例\",{\"1\":{\"546\":1}}],[\"动态代理原理查不多\",{\"1\":{\"523\":1}}],[\"动态代理进阶\",{\"0\":{\"514\":1}}],[\"动态代理相同\",{\"1\":{\"512\":1}}],[\"动态代理要求目标必须实现接口\",{\"1\":{\"511\":1}}],[\"动态代理\",{\"0\":{\"510\":1,\"515\":1}}],[\"动态代理与静态代理相比较\",{\"1\":{\"96\":1}}],[\"动态代理和静态代理\",{\"1\":{\"96\":1}}],[\"动态代理的执行流程是什么样\",{\"1\":{\"94\":1}}],[\"动态代理又有jdk代理和cglib代理两种\",{\"1\":{\"91\":1}}],[\"动力源\",{\"1\":{\"112\":1}}],[\"动物\",{\"1\":{\"33\":1}}],[\"访问次数最少\",{\"1\":{\"429\":1}}],[\"访问内存的有效时间为\",{\"1\":{\"413\":1}}],[\"访问内存的有效时间\",{\"1\":{\"413\":1}}],[\"访问控制\",{\"1\":{\"173\":1}}],[\"访问位\",{\"1\":{\"163\":1}}],[\"访问目标单元\",{\"1\":{\"158\":1}}],[\"访问二级页表\",{\"1\":{\"158\":1}}],[\"访问页目录表\",{\"1\":{\"158\":1}}],[\"访问速度比内存快很多的高速缓冲存储器\",{\"1\":{\"157\":1}}],[\"访问临界资源的那段代码\",{\"1\":{\"140\":1}}],[\"访问对象不适合或者不能直接引用目标对象\",{\"1\":{\"91\":1}}],[\"访问类\",{\"1\":{\"85\":1,\"100\":1}}],[\"运营商\",{\"1\":{\"296\":1}}],[\"运营商就计算出3个运营商所占比例\",{\"1\":{\"296\":1}}],[\"运营商进行组成数量统计\",{\"1\":{\"296\":1}}],[\"运算数据存放的位置不同\",{\"1\":{\"131\":1}}],[\"运行安装程序即可安装\",{\"1\":{\"1020\":1}}],[\"运行编译命令\",{\"1\":{\"1012\":1}}],[\"运行前端项目\",{\"0\":{\"958\":1}}],[\"运行前调入\",{\"1\":{\"164\":1}}],[\"运行客户端\",{\"1\":{\"898\":1}}],[\"运行非\",{\"1\":{\"791\":1}}],[\"运行用户代码的时间占总运行时间的比例\",{\"1\":{\"359\":1}}],[\"运行状态\",{\"1\":{\"208\":2}}],[\"运行结果与\",{\"1\":{\"512\":1}}],[\"运行结果\",{\"1\":{\"510\":1}}],[\"运行结果为\",{\"1\":{\"89\":2}}],[\"运行结束后归还资源\",{\"1\":{\"185\":1}}],[\"运行时请添加\",{\"1\":{\"449\":1,\"498\":1,\"502\":1,\"519\":1}}],[\"运行时元数据\",{\"1\":{\"353\":1}}],[\"运行时会调用unsafe类中的native方法\",{\"1\":{\"219\":1}}],[\"运行时调入\",{\"1\":{\"164\":1}}],[\"运行时动态链接\",{\"1\":{\"151\":1}}],[\"运行三种基本状态\",{\"1\":{\"135\":1}}],[\"运行态\",{\"1\":{\"132\":1}}],[\"运行在用户态\",{\"1\":{\"128\":1}}],[\"运行在核心态\",{\"1\":{\"128\":1}}],[\"运行一个gta需要4g内存\",{\"1\":{\"127\":1}}],[\"运动\",{\"1\":{\"33\":1}}],[\"判断张三是否是李四的好友\",{\"1\":{\"1029\":1}}],[\"判断李四是否是张三的好友\",{\"1\":{\"1029\":1}}],[\"判断一个元素是否存在于set中\",{\"1\":{\"1029\":1}}],[\"判断一个master\",{\"1\":{\"433\":1}}],[\"判断key是否存在\",{\"1\":{\"1024\":1}}],[\"判断出来库存大于1\",{\"1\":{\"996\":1}}],[\"判断库存是否充足\",{\"1\":{\"995\":1,\"998\":1}}],[\"判断秒杀是否已经结束\",{\"1\":{\"995\":1,\"998\":1}}],[\"判断秒杀是否开始\",{\"1\":{\"995\":1,\"998\":1}}],[\"判断命中的是否是空值\",{\"1\":{\"990\":1}}],[\"判断锁是否获取成功\",{\"1\":{\"989\":1,\"990\":1}}],[\"判断缓存是否过期\",{\"1\":{\"989\":1,\"990\":1}}],[\"判断缓存中是否存在\",{\"1\":{\"985\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"判断value中的过期时间是否满足\",{\"1\":{\"989\":1}}],[\"判断这个value是否是null\",{\"1\":{\"985\":1}}],[\"判断用户是否存在\",{\"1\":{\"960\":1,\"961\":1,\"968\":1,\"972\":1}}],[\"判断事件类型\",{\"1\":{\"884\":1,\"886\":1}}],[\"判断任务是否成功\",{\"1\":{\"806\":1}}],[\"判断\",{\"1\":{\"806\":1}}],[\"判断支持该事件类型才发事件\",{\"1\":{\"703\":1}}],[\"判断是否满足秒杀条件\",{\"1\":{\"995\":1}}],[\"判断是否过期\",{\"1\":{\"989\":1,\"990\":1}}],[\"判断是否命中\",{\"1\":{\"989\":1}}],[\"判断是否获取成功\",{\"1\":{\"988\":1,\"990\":1}}],[\"判断是否获得到了锁\",{\"1\":{\"988\":1}}],[\"判断是否是\",{\"1\":{\"988\":1}}],[\"判断是否是key为\",{\"1\":{\"985\":1,\"990\":1}}],[\"判断是否存在\",{\"1\":{\"983\":1,\"990\":1,\"998\":3}}],[\"判断是否存在这个数据\",{\"1\":{\"967\":1}}],[\"判断是否需要拦截\",{\"1\":{\"972\":1}}],[\"判断是否支持方法参数\",{\"1\":{\"568\":1}}],[\"判断是否要扩容\",{\"1\":{\"323\":1}}],[\"判断对象所对应的类是否加载链接初始化\",{\"1\":{\"352\":1}}],[\"判断对象对应的类是否加载\",{\"1\":{\"352\":1}}],[\"判断类元信息是否存在\",{\"1\":{\"352\":1}}],[\"判断请求的数据是否有效避免直接绕过缓存请求数据库\",{\"1\":{\"274\":1}}],[\"判断给定数据是否存在\",{\"1\":{\"274\":1}}],[\"判断当前线程是否被打断了\",{\"1\":{\"206\":1}}],[\"判断通过反射创建的两个singleton对象是否是同一个对象\",{\"1\":{\"103\":1}}],[\"判断两个反序列化后的对象是否是同一个对象\",{\"1\":{\"103\":1}}],[\"判断stu对象和stu1对象是否是同一个对象\",{\"1\":{\"89\":2}}],[\"判别器采用patchgan网络结构\",{\"1\":{\"16\":1}}],[\"西数等\",{\"1\":{\"109\":1}}],[\"西安\",{\"1\":{\"89\":2}}],[\"西兰花\",{\"1\":{\"33\":1}}],[\"李四的好友有\",{\"1\":{\"1029\":1}}],[\"李四\",{\"1\":{\"87\":1,\"89\":3,\"337\":1,\"1029\":1}}],[\"李宏毅生成对抗网络公开课\",{\"1\":{\"6\":1,\"13\":1}}],[\"奖状的案例中citation类的name属性修改为student类型的属性\",{\"1\":{\"89\":1}}],[\"奖状类\",{\"1\":{\"87\":1,\"89\":1}}],[\"奖状出来\",{\"1\":{\"87\":1}}],[\"奖状除了获奖人姓名不同\",{\"1\":{\"87\":1}}],[\"奖状\",{\"1\":{\"87\":1,\"89\":1}}],[\"案例分析\",{\"1\":{\"1032\":1}}],[\"案例实现\",{\"0\":{\"120\":1}}],[\"案例\",{\"0\":{\"87\":1},\"1\":{\"158\":1,\"1029\":1}}],[\"深度为3可以存储1000\",{\"1\":{\"377\":1}}],[\"深克隆\",{\"0\":{\"89\":1},\"1\":{\"86\":1}}],[\"深沉\",{\"1\":{\"37\":2}}],[\"浅克隆\",{\"1\":{\"86\":1}}],[\"用多占用一点空间\",{\"1\":{\"965\":1}}],[\"用时\",{\"1\":{\"870\":2}}],[\"用一字节\",{\"1\":{\"822\":1}}],[\"用一个整数型变量作为信号量\",{\"1\":{\"143\":1}}],[\"用一个已经创建的实例作为原型\",{\"1\":{\"84\":1}}],[\"用在客户端建立连接时\",{\"1\":{\"775\":1}}],[\"用在compute以及computeifabsent时\",{\"1\":{\"249\":1}}],[\"用逗号分隔\",{\"1\":{\"670\":1}}],[\"用以下命令即可获取\",{\"1\":{\"646\":1}}],[\"用了适配器模式把\",{\"1\":{\"576\":1}}],[\"用了以上手段声明了\",{\"1\":{\"495\":1}}],[\"用编号处理方法对应关系比较省内存\",{\"1\":{\"527\":1}}],[\"用的\",{\"1\":{\"834\":1}}],[\"用的这种\",{\"1\":{\"527\":1}}],[\"用的始终是第一次依赖注入的\",{\"1\":{\"500\":1}}],[\"用的是mybatisplus的wrapper\",{\"1\":{\"297\":1}}],[\"用静态工厂方法代替实例工厂方法\",{\"1\":{\"491\":1}}],[\"用内置依赖注入和初始化取代扩展依赖注入和初始化\",{\"1\":{\"491\":1}}],[\"用构造还是工厂创建\",{\"1\":{\"454\":1}}],[\"用事件方式\",{\"1\":{\"449\":1}}],[\"用cpu的计算\",{\"1\":{\"418\":1}}],[\"用compareto\",{\"1\":{\"325\":1}}],[\"用select的优势在于它可以同时处理多个connection\",{\"1\":{\"409\":1}}],[\"用or会导致索引失效\",{\"1\":{\"395\":1}}],[\"用数学语言表达就是f\",{\"1\":{\"312\":1}}],[\"用exists\",{\"1\":{\"386\":1}}],[\"用explain的结果\",{\"1\":{\"266\":1}}],[\"用equals来比较\",{\"1\":{\"249\":1}}],[\"用主键来对应\",{\"1\":{\"265\":1}}],[\"用fordwardingnode作为旧table\",{\"1\":{\"249\":1}}],[\"用磁带完成\",{\"1\":{\"184\":1}}],[\"用\",{\"1\":{\"163\":1,\"527\":1,\"572\":1,\"617\":1,\"661\":2,\"893\":1}}],[\"用二进制表示逻辑地址\",{\"1\":{\"156\":1}}],[\"用不到时调出内存\",{\"1\":{\"153\":1}}],[\"用死锁检测算法化简资源分配图之后\",{\"1\":{\"150\":1}}],[\"用某种调度算法来确定满足i\",{\"1\":{\"183\":1}}],[\"用某种算法确定一个好的顺序来处理各个i\",{\"1\":{\"183\":1}}],[\"用某种数据结构来保存资源的请求和分配信息\",{\"1\":{\"150\":1}}],[\"用某种方法阻止系统进入不安全的状态\",{\"1\":{\"147\":1}}],[\"用信号量机制实现进程互斥\",{\"0\":{\"144\":1}}],[\"用记录型数据结构表示信号量\",{\"1\":{\"143\":1}}],[\"用优先级区分紧急程度\",{\"1\":{\"139\":1}}],[\"用于数据库操作的回调函数\",{\"1\":{\"990\":1}}],[\"用于处理缓存击穿问题\",{\"1\":{\"990\":1}}],[\"用于处理缓\",{\"1\":{\"990\":1}}],[\"用于redis等缓存\",{\"1\":{\"974\":1}}],[\"用于快速开发可维护\",{\"1\":{\"839\":1}}],[\"用于通知发布者需要数据和通知发布者不再接受数据\",{\"1\":{\"745\":1}}],[\"用于读取request请求的body部分\",{\"1\":{\"731\":1,\"737\":1}}],[\"用于获取查询参数\",{\"1\":{\"731\":1}}],[\"用于获取路径参数\",{\"1\":{\"731\":1}}],[\"用于声明扫描策略\",{\"1\":{\"709\":1}}],[\"用于操作数据库\",{\"1\":{\"705\":1}}],[\"用于stream中元素做汇总的方法\",{\"1\":{\"343\":1}}],[\"用于添加资源\",{\"1\":{\"314\":1}}],[\"用于更新资源\",{\"1\":{\"314\":1}}],[\"用于删除资源\",{\"1\":{\"314\":1}}],[\"用于保存100个出现频率最多的单词\",{\"1\":{\"291\":1}}],[\"用于实现并发读\",{\"1\":{\"259\":1}}],[\"用于一个线程等待另一个线程的执行结果\",{\"1\":{\"217\":1}}],[\"用于优化轻量级锁重入\",{\"1\":{\"214\":1}}],[\"用于优化重量级锁\",{\"1\":{\"213\":1}}],[\"用于停止监控器线程\",{\"1\":{\"206\":1}}],[\"用于监控线程状态\",{\"1\":{\"206\":1}}],[\"用于暂存从输出井传来的数据\",{\"1\":{\"184\":1}}],[\"用于收容用户进程输出的数据\",{\"1\":{\"184\":1}}],[\"用于收容i\",{\"1\":{\"184\":1}}],[\"用于存放操作系统的相关数据\",{\"1\":{\"154\":1}}],[\"用于进程调度\",{\"1\":{\"139\":1}}],[\"用于进程调度时候称为\",{\"1\":{\"139\":1}}],[\"用于作业\",{\"1\":{\"139\":6}}],[\"用于加载代理类\",{\"1\":{\"94\":1}}],[\"用原语实现进程控制\",{\"1\":{\"133\":1}}],[\"用原型模式生成\",{\"1\":{\"87\":1}}],[\"用来与客户端之间通信\",{\"1\":{\"876\":1,\"877\":1}}],[\"用来获取\",{\"1\":{\"871\":1}}],[\"用来获取某个\",{\"1\":{\"473\":1}}],[\"用来处理\",{\"1\":{\"802\":1,\"816\":1}}],[\"用来缓存消息\",{\"1\":{\"793\":1}}],[\"用来接收结果的\",{\"1\":{\"788\":1}}],[\"用来分配\",{\"1\":{\"780\":1,\"794\":1}}],[\"用来在第一时间判定是否是无效数据包\",{\"1\":{\"769\":1}}],[\"用来触发特殊事件\",{\"1\":{\"764\":2}}],[\"用来判断是不是\",{\"1\":{\"764\":2}}],[\"用来执行事务的提交\",{\"1\":{\"662\":1}}],[\"用来创建\",{\"1\":{\"661\":1}}],[\"用来创建代理\",{\"1\":{\"531\":1}}],[\"用来创建代理对象\",{\"1\":{\"94\":1}}],[\"用来解放\",{\"1\":{\"904\":1}}],[\"用来解析\",{\"1\":{\"648\":1,\"667\":1}}],[\"用来解决数据复制阶段的阻塞问题\",{\"1\":{\"906\":1}}],[\"用来解决\",{\"1\":{\"277\":1}}],[\"用来解决程序大小超过物理内存总和的问题\",{\"1\":{\"153\":1}}],[\"用来存储中间\",{\"1\":{\"568\":1}}],[\"用来存放当前访问的若干页表项\",{\"1\":{\"157\":1}}],[\"用来记录一个页面自上次被访问以来所经历的时间t\",{\"1\":{\"420\":1}}],[\"用来选择淘汰哪一页的规则叫做页面置换算法\",{\"1\":{\"420\":1}}],[\"用来保证变更表结构操作的安全性\",{\"1\":{\"400\":1}}],[\"用来保存实际数据\",{\"1\":{\"277\":1}}],[\"用来表示文件路径\",{\"1\":{\"871\":1}}],[\"用来表示不同类型的\",{\"1\":{\"277\":1}}],[\"用来表示系统中某种资源的数量\",{\"1\":{\"143\":1}}],[\"用来进行线程协作\",{\"1\":{\"263\":1}}],[\"用来进行线程同步协作\",{\"1\":{\"262\":1}}],[\"用来限制能同时访问共享资源的线程上限\",{\"1\":{\"261\":1}}],[\"用来占位\",{\"1\":{\"249\":1}}],[\"用来描述进程的各种信息\",{\"1\":{\"131\":1}}],[\"用程序状态字寄存器\",{\"1\":{\"128\":1}}],[\"用户已经购买过一次\",{\"1\":{\"998\":3}}],[\"用户已经购买过了\",{\"1\":{\"998\":3}}],[\"用户id\",{\"1\":{\"995\":1,\"998\":3}}],[\"用户或者说商业对手很容易猜测出来我们的一些敏感信息\",{\"1\":{\"992\":1}}],[\"用户请求的数据在缓存中和数据库中都不存在\",{\"1\":{\"985\":1}}],[\"用户使用缓存中的过时数据\",{\"1\":{\"981\":1}}],[\"用户评价都是致命的\",{\"1\":{\"974\":1}}],[\"用户去登录会去校验用户提交的手机号和验证码\",{\"1\":{\"967\":1}}],[\"用户通过socket像互相传递数据\",{\"1\":{\"961\":1}}],[\"用户在请求时候\",{\"1\":{\"959\":1}}],[\"用户在提交手机号后\",{\"1\":{\"959\":1}}],[\"用户将验证码和手机号进行输入\",{\"1\":{\"959\":1}}],[\"用户名或密码不正确\",{\"1\":{\"759\":1,\"760\":1}}],[\"用户名\",{\"1\":{\"758\":2}}],[\"用户管理接口\",{\"1\":{\"758\":1}}],[\"用户发送请求至前端控制器dispatcherservlet\",{\"1\":{\"736\":1}}],[\"用户栈切换到内核栈\",{\"1\":{\"406\":1}}],[\"用户栈等\",{\"1\":{\"406\":2}}],[\"用户进程发起read操作之后\",{\"1\":{\"409\":1}}],[\"用户进程判断结果是一个error时\",{\"1\":{\"409\":1}}],[\"用户进程才解除block的状态\",{\"1\":{\"409\":1}}],[\"用户进程主动切换到内核态的方式\",{\"1\":{\"406\":1}}],[\"用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作\",{\"1\":{\"143\":1}}],[\"用户空间和内核空间\",{\"0\":{\"406\":1}}],[\"用户会收到一个警告信息\",{\"1\":{\"362\":1}}],[\"用户编程时只需提供逻辑设备名\",{\"1\":{\"185\":1}}],[\"用户编程时必须使用\",{\"1\":{\"185\":1}}],[\"用户编程麻烦\",{\"1\":{\"148\":1}}],[\"用户层系统\",{\"1\":{\"182\":1}}],[\"用户程序独占整个用户区空间\",{\"1\":{\"154\":1}}],[\"用户区用于存放用户进程的相关数据\",{\"1\":{\"154\":1}}],[\"用户提交请求到首次产生响应所用时间\",{\"1\":{\"138\":1}}],[\"用户级线程的切换在用户空间即可完成\",{\"1\":{\"135\":1}}],[\"用户级线程中\",{\"1\":{\"135\":1}}],[\"用户级线程\",{\"1\":{\"135\":1}}],[\"用户态与内核态的切换次数没有减少\",{\"1\":{\"905\":1}}],[\"用户态与内核态的切换发生了\",{\"1\":{\"904\":1}}],[\"用户态进程通过系统调用向操作系统申请资源完成工作\",{\"1\":{\"406\":1}}],[\"用户态和内核态\",{\"0\":{\"406\":1}}],[\"用户态\",{\"1\":{\"128\":1,\"129\":2}}],[\"用户可以对文件执行哪些操作\",{\"1\":{\"173\":1}}],[\"用户可以请求显示目录的内容\",{\"1\":{\"168\":1}}],[\"用户可以通过使用形象的图形界面进行操作\",{\"1\":{\"126\":1}}],[\"用户可以根据自己的喜爱更换自己的输入法的皮肤\",{\"1\":{\"107\":1}}],[\"用户接口\",{\"1\":{\"126\":1}}],[\"用户有了机箱肯定是想按照自己的喜好\",{\"1\":{\"109\":1}}],[\"用户窗体可以根据需要选择或者增加新的主题\",{\"1\":{\"107\":1}}],[\"用户只需要知道具体工厂的名称就可得到所要的产品\",{\"1\":{\"70\":1}}],[\"用户只需要指定复杂对象的类型就可以得到该对象\",{\"1\":{\"47\":1}}],[\"原来存在\",{\"1\":{\"1025\":1}}],[\"原来不存在\",{\"1\":{\"1025\":1}}],[\"原来运行的进程放回k级队列队尾\",{\"1\":{\"139\":1}}],[\"原本为\",{\"1\":{\"792\":1}}],[\"原本的长度在\",{\"1\":{\"280\":1}}],[\"原生的\",{\"1\":{\"790\":2}}],[\"原则\",{\"1\":{\"395\":1}}],[\"原因在于\",{\"1\":{\"982\":1}}],[\"原因是他是基于链表来存储的\",{\"1\":{\"410\":2}}],[\"原因\",{\"1\":{\"388\":1,\"751\":2,\"764\":1}}],[\"原始\",{\"1\":{\"826\":2}}],[\"原始的\",{\"1\":{\"825\":1}}],[\"原始k\",{\"1\":{\"300\":1}}],[\"原始论文\",{\"1\":{\"3\":1,\"10\":1}}],[\"原子累加器\",{\"1\":{\"232\":1}}],[\"原子数组\",{\"1\":{\"232\":1}}],[\"原子引用aba问题\",{\"0\":{\"233\":1}}],[\"原子引用的作用\",{\"1\":{\"232\":1}}],[\"原子引用\",{\"1\":{\"232\":1}}],[\"原子整数\",{\"1\":{\"232\":1}}],[\"原子类总结\",{\"1\":{\"232\":1}}],[\"原子性实现原理\",{\"1\":{\"396\":1}}],[\"原子性指整个数据库事务是不可分割的工作单位\",{\"1\":{\"396\":1}}],[\"原子性\",{\"1\":{\"226\":1,\"396\":1}}],[\"原理是因为我们需要先根据\",{\"1\":{\"383\":1}}],[\"原理是编译期优化\",{\"1\":{\"354\":1}}],[\"原理\",{\"0\":{\"679\":1},\"1\":{\"154\":1}}],[\"原理分析\",{\"1\":{\"148\":1}}],[\"原语和signal\",{\"1\":{\"143\":1}}],[\"原语\",{\"1\":{\"143\":2}}],[\"原语使用\",{\"1\":{\"133\":1}}],[\"原语的特点是执行期间不允许中断\",{\"1\":{\"133\":1}}],[\"原型模式的克隆分为浅克隆和深克隆\",{\"1\":{\"86\":1}}],[\"原型模式包含如下角色\",{\"1\":{\"85\":1}}],[\"原型模式\",{\"0\":{\"83\":1}}],[\"<exclude>\",{\"1\":{\"1038\":1}}],[\"<excludes>\",{\"1\":{\"1038\":1}}],[\"<configuration>\",{\"1\":{\"1038\":1}}],[\"<code>runtime<\",{\"1\":{\"105\":2}}],[\"<build>\",{\"1\":{\"1038\":1}}],[\"<java\",{\"1\":{\"1038\":1}}],[\"<description>demo\",{\"1\":{\"1038\":1}}],[\"<dependencies>\",{\"1\":{\"931\":1,\"948\":1,\"1038\":1}}],[\"<dependency>\",{\"1\":{\"95\":1,\"372\":2,\"648\":1,\"672\":1,\"679\":1,\"833\":1,\"931\":9,\"948\":7,\"998\":1,\"1032\":2,\"1038\":5}}],[\"<name>redis\",{\"1\":{\"1038\":1}}],[\"<plugin>\",{\"1\":{\"1038\":1}}],[\"<plugins>\",{\"1\":{\"1038\":1}}],[\"<properties>\",{\"1\":{\"1038\":1}}],[\"<project\",{\"1\":{\"1038\":1}}],[\"<parent>\",{\"1\":{\"1038\":1}}],[\"<modelversion>4\",{\"1\":{\"1038\":1}}],[\"<mybatisplus\",{\"1\":{\"372\":1}}],[\"<relativepath\",{\"1\":{\"1038\":1}}],[\"<resultmap\",{\"1\":{\"366\":2}}],[\"<r\",{\"1\":{\"990\":3}}],[\"<r>\",{\"1\":{\"990\":2}}],[\"<font\",{\"1\":{\"944\":1}}],[\"<t>\",{\"1\":{\"773\":6,\"783\":1,\"787\":1,\"990\":2}}],[\"<h1>hello\",{\"1\":{\"768\":1}}],[\"<h3>服务器内部错误<\",{\"1\":{\"622\":1}}],[\"<optional>true<\",{\"1\":{\"679\":1,\"948\":1,\"1038\":1}}],[\"<groupid>redis\",{\"1\":{\"1032\":1}}],[\"<groupid>junit<\",{\"1\":{\"931\":1,\"948\":1}}],[\"<groupid>io\",{\"1\":{\"833\":1}}],[\"<groupid>org\",{\"1\":{\"648\":1,\"679\":1,\"931\":7,\"948\":6,\"998\":1,\"1032\":1,\"1038\":7}}],[\"<groupid>com\",{\"1\":{\"372\":2,\"672\":1,\"931\":1,\"1038\":2}}],[\"<groupid>cglib<\",{\"1\":{\"95\":1}}],[\"<>\",{\"1\":{\"381\":1}}],[\"<version>0\",{\"1\":{\"1038\":1}}],[\"<version>5\",{\"1\":{\"1032\":1}}],[\"<version>3\",{\"1\":{\"1032\":1}}],[\"<version>7\",{\"1\":{\"931\":2}}],[\"<version>4\",{\"1\":{\"833\":1,\"931\":1,\"948\":1}}],[\"<version>1\",{\"1\":{\"672\":1}}],[\"<version>$\",{\"1\":{\"372\":2}}],[\"<version>2\",{\"1\":{\"95\":1,\"931\":3,\"1038\":1}}],[\"<scope>runtime<\",{\"1\":{\"948\":1}}],[\"<scope>test<\",{\"1\":{\"931\":1,\"948\":1,\"1032\":1,\"1038\":1}}],[\"<scope>provided<\",{\"1\":{\"648\":1}}],[\"<select\",{\"1\":{\"366\":3}}],[\"<stdio\",{\"1\":{\"277\":2}}],[\"<artifactid>commons\",{\"1\":{\"1038\":1}}],[\"<artifactid>cglib<\",{\"1\":{\"95\":1}}],[\"<artifactid>redis\",{\"1\":{\"1038\":1}}],[\"<artifactid>aspectjweaver<\",{\"1\":{\"998\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"931\":1,\"948\":1,\"1038\":2}}],[\"<artifactid>log4j\",{\"1\":{\"931\":2}}],[\"<artifactid>junit\",{\"1\":{\"1032\":1}}],[\"<artifactid>junit<\",{\"1\":{\"931\":1,\"948\":1}}],[\"<artifactid>jedis<\",{\"1\":{\"1032\":1}}],[\"<artifactid>jackson\",{\"1\":{\"931\":1,\"1038\":1}}],[\"<artifactid>elasticsearch\",{\"1\":{\"931\":1}}],[\"<artifactid>elasticsearch<\",{\"1\":{\"931\":1}}],[\"<artifactid>netty\",{\"1\":{\"833\":1}}],[\"<artifactid>spring\",{\"1\":{\"679\":1,\"931\":2,\"948\":5,\"1038\":4}}],[\"<artifactid>druid<\",{\"1\":{\"672\":1}}],[\"<artifactid>dynamic\",{\"1\":{\"372\":1}}],[\"<artifactid>tomcat\",{\"1\":{\"648\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"372\":1}}],[\"<association\",{\"1\":{\"366\":2}}],[\"<id>\",{\"1\":{\"990\":2}}],[\"<id\",{\"1\":{\"366\":6}}],[\"<isnotnull>表示不为null值时执行\",{\"1\":{\"268\":1}}],[\"<isnotempty>表示不为空且不为null时执行\",{\"1\":{\"268\":1}}],[\"<isequal>中的comparevalue是与属性值对比的常量\",{\"1\":{\"268\":1}}],[\"<init>\",{\"1\":{\"237\":1}}],[\"<<<<<<<<<<<销毁之前执行\",{\"1\":{\"711\":1}}],[\"<<<<<<<<<<<\",{\"1\":{\"711\":5}}],[\"<<\",{\"1\":{\"192\":2,\"283\":5,\"441\":6,\"849\":5,\"993\":1}}],[\"<=\",{\"1\":{\"192\":3,\"194\":2,\"195\":3,\"249\":1,\"441\":1,\"755\":1,\"756\":1,\"792\":1,\"794\":1,\"849\":4,\"884\":1,\"886\":1,\"995\":1}}],[\"<\",{\"1\":{\"82\":2,\"95\":1,\"116\":4,\"123\":3,\"191\":5,\"194\":4,\"195\":3,\"225\":6,\"236\":2,\"237\":1,\"249\":3,\"255\":2,\"262\":2,\"263\":2,\"282\":3,\"283\":4,\"287\":2,\"366\":9,\"372\":6,\"441\":5,\"648\":1,\"672\":1,\"679\":1,\"742\":3,\"749\":1,\"750\":1,\"753\":1,\"754\":2,\"755\":1,\"756\":1,\"768\":1,\"773\":1,\"793\":2,\"794\":2,\"833\":1,\"845\":2,\"849\":14,\"859\":1,\"890\":2,\"893\":1,\"896\":1,\"931\":10,\"944\":1,\"948\":8,\"993\":2,\"996\":1,\"998\":2,\"1032\":4,\"1038\":20}}],[\">则只会执行select\",{\"1\":{\"366\":1}}],[\"><\",{\"1\":{\"366\":6}}],[\">>>\",{\"1\":{\"849\":3}}],[\">>\",{\"1\":{\"191\":1,\"283\":2,\"655\":1,\"657\":1}}],[\">=\",{\"1\":{\"191\":1,\"194\":3,\"195\":1,\"249\":3,\"523\":1,\"744\":1,\"790\":1,\"792\":2,\"849\":1}}],[\">\",{\"1\":{\"82\":1,\"94\":1,\"123\":1,\"135\":2,\"151\":1,\"181\":10,\"191\":1,\"221\":2,\"232\":4,\"236\":1,\"249\":2,\"263\":6,\"283\":12,\"287\":1,\"336\":7,\"338\":2,\"339\":1,\"341\":1,\"343\":1,\"366\":9,\"368\":1,\"372\":2,\"441\":2,\"449\":1,\"450\":1,\"463\":2,\"491\":1,\"498\":1,\"502\":1,\"510\":1,\"512\":1,\"523\":1,\"619\":1,\"622\":1,\"626\":1,\"630\":1,\"688\":3,\"711\":1,\"731\":1,\"742\":3,\"743\":1,\"744\":1,\"759\":1,\"773\":1,\"775\":1,\"783\":5,\"785\":1,\"787\":4,\"790\":9,\"792\":2,\"793\":7,\"794\":1,\"800\":1,\"801\":1,\"804\":1,\"809\":1,\"810\":1,\"811\":2,\"812\":1,\"813\":1,\"814\":2,\"815\":2,\"816\":8,\"844\":2,\"845\":4,\"870\":1,\"873\":1,\"877\":1,\"896\":1,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":2,\"945\":1,\"946\":1,\"968\":1,\"989\":1,\"990\":1,\"993\":1,\"997\":1,\"998\":5,\"1032\":2,\"1038\":7}}],[\"名\",{\"1\":{\"480\":1,\"486\":1}}],[\"名称\",{\"1\":{\"806\":1}}],[\"名称筛选\",{\"1\":{\"695\":1}}],[\"名称基本一成不变\",{\"1\":{\"265\":1}}],[\"名称为bean\",{\"1\":{\"77\":1}}],[\"名字叫redis\",{\"1\":{\"1015\":1}}],[\"名字前面加\",{\"1\":{\"678\":1}}],[\"名字取得不好\",{\"1\":{\"650\":1}}],[\"名字\",{\"1\":{\"82\":1,\"116\":1}}],[\"示例2\",{\"0\":{\"744\":1}}],[\"示例1\",{\"0\":{\"743\":1}}],[\"示例如下\",{\"1\":{\"336\":2}}],[\"示例\",{\"0\":{\"82\":1,\"116\":1},\"1\":{\"385\":1}}],[\"会带来额外的内存开销\",{\"1\":{\"1042\":1}}],[\"会进入redis\",{\"1\":{\"1018\":1}}],[\"会进行如下操作\",{\"1\":{\"273\":2}}],[\"会进行不同的处理\",{\"1\":{\"129\":1}}],[\"会有大量的磁盘io\",{\"1\":{\"1008\":1}}],[\"会有一个版本号\",{\"1\":{\"996\":1}}],[\"会有较大的开销\",{\"1\":{\"163\":1}}],[\"会构筑多级缓存来使系统运行速度进一步提升\",{\"1\":{\"976\":1}}],[\"会去校验是否比之前的版本大1\",{\"1\":{\"996\":1}}],[\"会去携带着token进行访问\",{\"1\":{\"967\":1}}],[\"会去获取要观察的对象的最新状态\",{\"1\":{\"81\":1}}],[\"会访问我们像tomcat注册的端口\",{\"1\":{\"961\":1}}],[\"会校验手机号是否合法\",{\"1\":{\"959\":1}}],[\"会选择使用mysql集群\",{\"1\":{\"955\":1}}],[\"会为具有一组共同字段的文档定义一个类型\",{\"1\":{\"923\":1}}],[\"会阻塞整个会话窗口\",{\"1\":{\"1014\":1}}],[\"会阻塞直到\",{\"1\":{\"917\":1}}],[\"会阻塞线程池中所有线程\",{\"1\":{\"876\":1}}],[\"会参与拷贝\",{\"1\":{\"904\":2,\"905\":1}}],[\"会切换至操作系统内核态来完成真正数据读取\",{\"1\":{\"901\":1}}],[\"会拿到物理\",{\"1\":{\"897\":1}}],[\"会每次可写均会触发\",{\"1\":{\"893\":1}}],[\"会取消注册在\",{\"1\":{\"888\":1}}],[\"会取消下一次的\",{\"1\":{\"792\":1}}],[\"会返回\",{\"1\":{\"877\":2}}],[\"会抛异常\",{\"1\":{\"872\":4}}],[\"会抛出\",{\"1\":{\"775\":1}}],[\"会输出\",{\"1\":{\"871\":1}}],[\"会追加内容\",{\"1\":{\"867\":1}}],[\"会从cookie中携带者jsessionid到后台\",{\"1\":{\"959\":1}}],[\"会从\",{\"1\":{\"864\":1}}],[\"会变成其它类型对象\",{\"1\":{\"837\":1}}],[\"会始终为\",{\"1\":{\"829\":1}}],[\"会报\",{\"1\":{\"826\":1}}],[\"会报错\",{\"1\":{\"823\":1}}],[\"会负责释放未处理消息\",{\"1\":{\"825\":1}}],[\"会打印\",{\"1\":{\"816\":1}}],[\"会继续向上传播\",{\"1\":{\"815\":1}}],[\"会再用\",{\"1\":{\"812\":1}}],[\"会再次相应应用程序并通知此事件\",{\"1\":{\"410\":1}}],[\"会回调\",{\"1\":{\"803\":1}}],[\"会本次的\",{\"1\":{\"792\":1}}],[\"会唤醒当前在执行\",{\"1\":{\"792\":1}}],[\"会匹配\",{\"1\":{\"791\":1}}],[\"会执行一次\",{\"1\":{\"791\":1}}],[\"会执行到下面的\",{\"1\":{\"791\":1}}],[\"会启动\",{\"1\":{\"790\":1}}],[\"会由\",{\"1\":{\"790\":1}}],[\"会由操作系统唤醒阻塞的线程\",{\"1\":{\"208\":1}}],[\"会触发右侧的请求\",{\"1\":{\"995\":1}}],[\"会触发多次读取事件\",{\"1\":{\"883\":1}}],[\"会触发\",{\"1\":{\"767\":1,\"878\":1,\"883\":2}}],[\"会触发一个\",{\"1\":{\"764\":2}}],[\"会话绑定用户\",{\"1\":{\"758\":1}}],[\"会话管理接口\",{\"1\":{\"758\":1}}],[\"会话结束时销毁\",{\"1\":{\"496\":1}}],[\"会按照\",{\"1\":{\"751\":1}}],[\"会造成粘包\",{\"1\":{\"751\":1}}],[\"会造成严重的资源浪费\",{\"1\":{\"148\":1}}],[\"会替换掉原有对象\",{\"1\":{\"711\":1}}],[\"会替换掉原本的\",{\"1\":{\"460\":1}}],[\"会把它包装为\",{\"1\":{\"703\":1}}],[\"会创建代理对象装配\",{\"1\":{\"695\":1}}],[\"会创建新的cell来累加计数\",{\"1\":{\"249\":1}}],[\"会遍历包下所有\",{\"1\":{\"682\":1}}],[\"会认为创建\",{\"1\":{\"678\":1}}],[\"会解析\",{\"1\":{\"662\":1}}],[\"会忽略掉非\",{\"1\":{\"661\":1}}],[\"会注册\",{\"1\":{\"661\":1}}],[\"会利用系统提供的发送缓冲区\",{\"1\":{\"900\":1}}],[\"会利用\",{\"1\":{\"644\":1}}],[\"会设置\",{\"1\":{\"600\":1}}],[\"会综合利用本类的\",{\"1\":{\"588\":1,\"596\":1}}],[\"会以类为单位\",{\"1\":{\"588\":1,\"596\":1,\"616\":1}}],[\"会包含局部变量表\",{\"1\":{\"572\":1}}],[\"会准备\",{\"1\":{\"561\":1}}],[\"会收集所有\",{\"1\":{\"561\":1}}],[\"会借助\",{\"1\":{\"528\":1}}],[\"会动态生成两个类\",{\"1\":{\"527\":1}}],[\"会用到\",{\"1\":{\"576\":1}}],[\"会用\",{\"1\":{\"516\":1,\"519\":1}}],[\"会跳过依赖注入阶段\",{\"1\":{\"460\":1,\"711\":1}}],[\"会跳到19行执行异常处理部分\",{\"1\":{\"211\":1}}],[\"会在没有数据可读时让线程暂停\",{\"1\":{\"876\":1}}],[\"会在没有连接建立时让线程暂停\",{\"1\":{\"876\":1}}],[\"会在连接建立时被调用\",{\"1\":{\"803\":1}}],[\"会在连接\",{\"1\":{\"767\":1}}],[\"会在第\",{\"1\":{\"644\":1}}],[\"会在\",{\"1\":{\"458\":1,\"695\":1}}],[\"会在打断后清为false\",{\"1\":{\"204\":1}}],[\"会销毁所有单例对象\",{\"1\":{\"458\":1}}],[\"会自动触发淘汰机制\",{\"1\":{\"980\":1}}],[\"会自动转移到slave\",{\"1\":{\"433\":1}}],[\"会自动将扩大\",{\"1\":{\"277\":1}}],[\"会向cpu发出相应的中断信号\",{\"1\":{\"406\":1}}],[\"会首先写入buffer\",{\"1\":{\"396\":1}}],[\"会将数据缓存\",{\"1\":{\"869\":1}}],[\"会将数据切分发送\",{\"1\":{\"751\":1}}],[\"会将底层内存数据进行深拷贝\",{\"1\":{\"828\":1}}],[\"会将读取到的数据中的事务id与trx\",{\"1\":{\"393\":1}}],[\"会将counter置为1\",{\"1\":{\"219\":1}}],[\"会通过数据库自身的锁机制来实现\",{\"1\":{\"397\":1}}],[\"会通过查询数据字典将\",{\"1\":{\"388\":1}}],[\"会通知给观察者\",{\"1\":{\"80\":1}}],[\"会被当成字符串来处理\",{\"1\":{\"366\":1}}],[\"会被解析成\",{\"1\":{\"366\":1}}],[\"会显式触发full\",{\"1\":{\"357\":1}}],[\"会做什么事情\",{\"1\":{\"355\":1}}],[\"会存在线程安全问题\",{\"1\":{\"349\":1}}],[\"会使得垃圾回收的总成本上升\",{\"1\":{\"356\":1}}],[\"会使用key\",{\"1\":{\"387\":1}}],[\"会使用\",{\"1\":{\"279\":2}}],[\"会使用不同空间大小的\",{\"1\":{\"279\":1}}],[\"会使整个系统的效率降低\",{\"1\":{\"137\":1}}],[\"会分配\",{\"1\":{\"277\":1}}],[\"会优先检查未使用空间是否足够\",{\"1\":{\"277\":1}}],[\"会置入字段名和属性值\",{\"1\":{\"268\":3}}],[\"会统计值为null的行\",{\"1\":{\"267\":2}}],[\"会翻开第11章对应的那一页吗\",{\"1\":{\"266\":1}}],[\"会连同t3一起唤醒\",{\"1\":{\"253\":1}}],[\"会放入无界队列排队\",{\"1\":{\"244\":1}}],[\"会生成新的\",{\"1\":{\"236\":1}}],[\"会不方便实现\",{\"1\":{\"161\":1}}],[\"会导致只能在本地访问\",{\"1\":{\"1015\":1}}],[\"会导致每个线程进来都会锁住\",{\"1\":{\"998\":1}}],[\"会导致并发性问题\",{\"1\":{\"997\":1}}],[\"会导致索引失效而转向全表扫描\",{\"1\":{\"395\":1}}],[\"会导致内存重新分配\",{\"1\":{\"281\":1}}],[\"会导致线程上下文切换\",{\"1\":{\"208\":1}}],[\"会导致缺页频繁\",{\"1\":{\"164\":1}}],[\"会导致大的空闲区迅速被用完\",{\"1\":{\"155\":1}}],[\"会导致资源浪费\",{\"1\":{\"148\":1}}],[\"会产生磁盘碎片\",{\"1\":{\"169\":1}}],[\"会产生外部碎片\",{\"1\":{\"160\":1}}],[\"会产生很多的外部碎片\",{\"1\":{\"155\":1}}],[\"会产生内部碎片\",{\"1\":{\"154\":1}}],[\"会留下越来越多的又小又难利用的内存块\",{\"1\":{\"155\":1}}],[\"会\",{\"1\":{\"139\":3,\"816\":1}}],[\"会引起进程切换\",{\"1\":{\"135\":1}}],[\"会出现线程安全问题\",{\"1\":{\"101\":1}}],[\"此后\",{\"1\":{\"766\":1}}],[\"此方法可以延迟真实\",{\"1\":{\"695\":1}}],[\"此方法可以延迟\",{\"1\":{\"695\":1}}],[\"此实现会与当前线程绑定\",{\"1\":{\"661\":1}}],[\"此种操作就可以用token的机制实现防止重复提交\",{\"1\":{\"315\":1}}],[\"此种方式容易出现sql注入\",{\"1\":{\"268\":1}}],[\"此次读\",{\"1\":{\"176\":1}}],[\"此时我们再来看一看存储的数据\",{\"1\":{\"1042\":1}}],[\"此时如果使用id作为key\",{\"1\":{\"1026\":1}}],[\"此时await就不再阻塞\",{\"1\":{\"993\":1}}],[\"此时要么你去修改原来的实体类\",{\"1\":{\"989\":1}}],[\"此时线程2执行\",{\"1\":{\"996\":1}}],[\"此时线程2过来\",{\"1\":{\"982\":1,\"996\":1}}],[\"此时线程1去获得互斥锁\",{\"1\":{\"987\":1}}],[\"此时只要线程1走完这个逻辑\",{\"1\":{\"987\":1}}],[\"此时会访问到数据库\",{\"1\":{\"984\":1}}],[\"此时会帮忙扩容\",{\"1\":{\"249\":1}}],[\"此时他写入缓存\",{\"1\":{\"982\":1}}],[\"此时监听线程会从tomcat的线程池中取出一个线程执行用户请求\",{\"1\":{\"961\":1}}],[\"此时buf没有被释放\",{\"1\":{\"826\":1}}],[\"此时用的是外置\",{\"1\":{\"648\":1}}],[\"此时又分两种情况\",{\"1\":{\"617\":1}}],[\"此时走\",{\"1\":{\"600\":2}}],[\"此时需找到默认视图名\",{\"1\":{\"600\":2}}],[\"此时os将利用请求调页\",{\"1\":{\"418\":1}}],[\"此时再次调用支付\",{\"1\":{\"313\":1}}],[\"此时\",{\"1\":{\"280\":1,\"437\":1}}],[\"此时就将新值去替换\",{\"1\":{\"996\":1}}],[\"此时就能够从缓存中拿到数据了\",{\"1\":{\"987\":1}}],[\"此时就会出现库存的超卖问题\",{\"1\":{\"996\":1}}],[\"此时就会有一致性问题存在\",{\"1\":{\"981\":1}}],[\"此时就会导致以下结果\",{\"1\":{\"437\":1}}],[\"此时就可能会导致缓存中的数据过多\",{\"1\":{\"980\":1}}],[\"此时就可以利用建造者模式进行重构\",{\"1\":{\"52\":1}}],[\"此时就需要对压缩列表的空间重分配操作\",{\"1\":{\"280\":1}}],[\"此时的复杂度就是\",{\"1\":{\"279\":1}}],[\"此时i是一个静态变量\",{\"1\":{\"230\":1}}],[\"此时第一个分组已有100个块\",{\"1\":{\"170\":1}}],[\"此时缺页的进程阻塞\",{\"1\":{\"162\":1}}],[\"此时不得不采取覆盖技术来解决\",{\"1\":{\"154\":1}}],[\"此时可以换出一些进程\",{\"1\":{\"153\":1}}],[\"此时一定没有发生死锁\",{\"1\":{\"150\":1}}],[\"此时请求进程被阻塞\",{\"1\":{\"147\":1}}],[\"此时读进程的read\",{\"1\":{\"134\":1}}],[\"此时进入核心态\",{\"1\":{\"129\":1}}],[\"此时cpu只能执行非特权指令\",{\"1\":{\"128\":1}}],[\"此指令不允许用户程序使用\",{\"1\":{\"128\":1}}],[\"此处返回的是成功删除的key\",{\"1\":{\"1024\":1}}],[\"此处选择的linux版本为centos\",{\"1\":{\"1010\":1}}],[\"此处要维护\",{\"1\":{\"1005\":1}}],[\"此处的同时往往是宏观上的\",{\"1\":{\"127\":1}}],[\"此处会问java对象的创建过程\",{\"1\":{\"101\":1}}],[\"此外\",{\"1\":{\"81\":1,\"396\":1}}],[\"观察\",{\"1\":{\"499\":1,\"672\":1}}],[\"观察对象\",{\"1\":{\"81\":1}}],[\"观察者\",{\"1\":{\"80\":1,\"81\":1}}],[\"观察者模式\",{\"0\":{\"79\":1}}],[\"图形化桌面客户端\",{\"0\":{\"1019\":1},\"1\":{\"1017\":1}}],[\"图形用户接口\",{\"1\":{\"126\":1}}],[\"图3\",{\"0\":{\"592\":1}}],[\"图2\",{\"0\":{\"591\":1}}],[\"图1\",{\"0\":{\"590\":1},\"1\":{\"816\":1}}],[\"图中数字代表了处理步骤的先后次序\",{\"1\":{\"816\":1}}],[\"图中深色的部分即要发送的数据\",{\"1\":{\"751\":1}}],[\"图中不同颜色对应一次环绕通知或目标的调用起始至终结\",{\"1\":{\"546\":1}}],[\"图中\",{\"1\":{\"528\":1}}],[\"图的构建\",{\"0\":{\"284\":1}}],[\"图解设计模式\",{\"1\":{\"79\":1,\"113\":1}}],[\"图像转译和生成对抗网络gan必读论文\",{\"1\":{\"16\":1}}],[\"图像转译\",{\"1\":{\"3\":1,\"19\":1}}],[\"可排序\",{\"1\":{\"1030\":1}}],[\"可重入锁\",{\"1\":{\"996\":1}}],[\"可重入是通过不断通过cas操作将state的值+1实现的\",{\"1\":{\"252\":1}}],[\"可配合\",{\"1\":{\"900\":1}}],[\"可读性差\",{\"1\":{\"1041\":1}}],[\"可读写事件的监控\",{\"1\":{\"878\":1}}],[\"可读或可接入事件\",{\"1\":{\"792\":1}}],[\"可写\",{\"1\":{\"878\":1,\"883\":1}}],[\"可写事件\",{\"1\":{\"792\":1}}],[\"可写或者except\",{\"1\":{\"410\":1}}],[\"可是后来也就想通了\",{\"1\":{\"766\":1}}],[\"可将handlermapping看作路由控制器\",{\"1\":{\"736\":1}}],[\"可将操作系统保留的空闲物理块分配给缺页进程\",{\"1\":{\"164\":1}}],[\"可根据是否满足指定的条件来决定是否进行bean的实例化及装配\",{\"1\":{\"731\":1}}],[\"可根据自身情况做调整\",{\"1\":{\"443\":1}}],[\"可作为请求的统一入口\",{\"1\":{\"644\":1}}],[\"可用雪花算法服务上线时间戳的值\",{\"1\":{\"441\":1}}],[\"可用于进程调度\",{\"1\":{\"139\":1}}],[\"可用于作业调度也可用于进程调度\",{\"1\":{\"139\":1}}],[\"可水平扩展\",{\"1\":{\"434\":1}}],[\"可采用离散分配的方式\",{\"1\":{\"413\":1}}],[\"可采用上述二者组合的方式\",{\"1\":{\"135\":1}}],[\"可靠性不高\",{\"1\":{\"391\":1}}],[\"可我却觉得有点精致利己主义的倾向\",{\"1\":{\"305\":1}}],[\"可在子类中被重新定义\",{\"1\":{\"317\":1}}],[\"可在参数配置模块中进行修改\",{\"1\":{\"296\":1}}],[\"可在相关联的表中冗余存储类目名称\",{\"1\":{\"265\":1}}],[\"可运行状态\",{\"1\":{\"208\":2}}],[\"可同时分配给多个进程使用\",{\"1\":{\"185\":2}}],[\"可变长记录\",{\"1\":{\"167\":1}}],[\"可变分配\",{\"1\":{\"164\":2}}],[\"可变分区分配\",{\"1\":{\"154\":1}}],[\"可修改的代码不能实现共享\",{\"1\":{\"159\":1}}],[\"可换出低优先级的进程\",{\"1\":{\"153\":1}}],[\"可优先换出阻塞进程\",{\"1\":{\"153\":1}}],[\"可灵活地的调整对各种作业\",{\"1\":{\"139\":1}}],[\"可\",{\"1\":{\"139\":1}}],[\"可能造成短期的不一致\",{\"1\":{\"984\":1}}],[\"可能造成内存泄漏\",{\"1\":{\"851\":1}}],[\"可能出现服务器时钟回拨问题\",{\"1\":{\"441\":2}}],[\"可能有性能问题\",{\"1\":{\"410\":1}}],[\"可能延迟还更大\",{\"1\":{\"409\":1}}],[\"可能需要中序遍历\",{\"1\":{\"378\":1}}],[\"可能导致小文件大小超过10m\",{\"1\":{\"290\":1}}],[\"可能导致队列中的线程长期处于饥饿状态\",{\"1\":{\"258\":1}}],[\"可能会导致当前方法事务还没有提交\",{\"1\":{\"998\":1}}],[\"可能会导致后续元素的\",{\"1\":{\"280\":1}}],[\"可能会有很多在master里没过期的数据其实已经过期了\",{\"1\":{\"437\":1}}],[\"可能会遇到如下的几个问题\",{\"1\":{\"313\":1}}],[\"可能会好奇为什么最后一个字符是\",{\"1\":{\"276\":1}}],[\"可能会出现延迟\",{\"1\":{\"963\":1}}],[\"可能会出现饥饿现象\",{\"1\":{\"223\":1}}],[\"可能会出现空指针问题\",{\"1\":{\"101\":1}}],[\"可能产生多次缺页中断\",{\"1\":{\"162\":1}}],[\"可能产生饥饿现象\",{\"1\":{\"139\":1}}],[\"可能所有的分区都不能满足\",{\"1\":{\"154\":1}}],[\"可能使长作业\",{\"1\":{\"139\":1}}],[\"可见性\",{\"1\":{\"226\":1}}],[\"可见\",{\"1\":{\"79\":1,\"113\":1}}],[\"可以基于score属性对元素排序\",{\"1\":{\"1030\":1}}],[\"可以基本保持软件架构的稳定\",{\"1\":{\"107\":1}}],[\"可以针对单个字段做crud\",{\"1\":{\"1027\":1}}],[\"可以做自增\",{\"1\":{\"1025\":2}}],[\"可以查看一个命令的具体用法\",{\"1\":{\"1024\":1}}],[\"可以查看到不同的命令\",{\"1\":{\"1023\":1}}],[\"可以指定日志文件名\",{\"1\":{\"1015\":1}}],[\"可以保存海量数据\",{\"1\":{\"1008\":1}}],[\"可以保证数据库表中每一行数据的唯一性\",{\"1\":{\"375\":1}}],[\"可以分为tomcat本地缓存\",{\"1\":{\"976\":1}}],[\"可以分为表锁\",{\"1\":{\"399\":1}}],[\"可以实现基于lua直接绕开tomcat访问redis\",{\"1\":{\"955\":1}}],[\"可以被放置到集群中的任何节点上\",{\"1\":{\"927\":1}}],[\"可以定义任意多的索引\",{\"1\":{\"922\":1}}],[\"可以从\",{\"1\":{\"911\":1}}],[\"可以去执行其它\",{\"1\":{\"877\":1}}],[\"可以发现即使不写入数据\",{\"1\":{\"845\":1}}],[\"可以进行数据读写操作\",{\"1\":{\"835\":1}}],[\"可以简单理解为\",{\"1\":{\"834\":1}}],[\"可以自己设置策略方式\",{\"1\":{\"980\":1}}],[\"可以自动扩容\",{\"1\":{\"831\":1}}],[\"可以自定义属性\",{\"1\":{\"368\":1}}],[\"可以重用池中\",{\"1\":{\"831\":1}}],[\"可以循环调用\",{\"1\":{\"825\":1}}],[\"可以主动创建\",{\"1\":{\"809\":1}}],[\"可以同步等待任务结束得到结果\",{\"1\":{\"806\":1}}],[\"可以同时作为入站和出站处理器\",{\"1\":{\"764\":2}}],[\"可以计算一下\",{\"1\":{\"805\":1}}],[\"可以提高遍历性能\",{\"1\":{\"792\":1}}],[\"可以继承\",{\"1\":{\"771\":1}}],[\"可以继续遍历第二个文件\",{\"1\":{\"290\":1}}],[\"可以继续操作\",{\"1\":{\"276\":1}}],[\"可以支持协议的升级\",{\"1\":{\"769\":1}}],[\"可以调用\",{\"1\":{\"853\":1,\"869\":1}}],[\"可以调用空参\",{\"1\":{\"351\":1}}],[\"可以调节发布者发布数据的速率\",{\"1\":{\"745\":1}}],[\"可以拓展一下sso单点登录来讲项目\",{\"1\":{\"738\":1}}],[\"可以与云计算天然集成\",{\"1\":{\"726\":1}}],[\"可以极大地提高开发\",{\"1\":{\"726\":1}}],[\"可以对主流开发框架的无配置集成\",{\"1\":{\"726\":1}}],[\"可以对构造方法\",{\"1\":{\"506\":1}}],[\"可以快速构建项目\",{\"1\":{\"726\":1}}],[\"可以利用线程池进行异步发事件优化\",{\"1\":{\"703\":1}}],[\"可以利用该机制将数据缓存在某个线程内部\",{\"1\":{\"247\":1}}],[\"可以设置虚拟路径\",{\"1\":{\"653\":1}}],[\"可以设置一个初值为1的信号量\",{\"1\":{\"143\":1}}],[\"可以有多种源用来加载\",{\"1\":{\"652\":1}}],[\"可以注册多个\",{\"1\":{\"575\":1}}],[\"可以拿到参数名\",{\"1\":{\"572\":1}}],[\"可以生成调试信息\",{\"1\":{\"572\":1}}],[\"可以生成参数表\",{\"1\":{\"572\":1}}],[\"可以生成212=4096个不重复\",{\"1\":{\"440\":1}}],[\"可以省略目标对象\",{\"1\":{\"523\":1}}],[\"可以解析控制器的\",{\"1\":{\"582\":1}}],[\"可以解析\",{\"1\":{\"476\":2}}],[\"可以完成依赖注入\",{\"1\":{\"473\":1}}],[\"可以根据\",{\"1\":{\"773\":1}}],[\"可以根据xml配置\",{\"1\":{\"736\":1}}],[\"可以根据槽位定位算法定位到目标节点\",{\"1\":{\"435\":1}}],[\"可以根据情况做出适当的增加或减少\",{\"1\":{\"164\":1}}],[\"可以访问受保护的内存空间\",{\"1\":{\"406\":1}}],[\"可以增加联合索引的使用率\",{\"1\":{\"383\":1}}],[\"可以加速表和表之间的连接\",{\"1\":{\"375\":1}}],[\"可以大大加快查询速度\",{\"1\":{\"375\":1}}],[\"可以更轻松地使用内存块\",{\"1\":{\"332\":1}}],[\"可以更加精细地控制产品的创建过程\",{\"1\":{\"50\":1}}],[\"可以理解为行级别的共享锁和排他锁\",{\"1\":{\"401\":1}}],[\"可以理解为是一个容器对象\",{\"1\":{\"332\":1}}],[\"可以理解为一个标记位\",{\"1\":{\"219\":1}}],[\"可以理解为一种可供应用程序调用的特殊函数\",{\"1\":{\"130\":1}}],[\"可以选择雪花算法生成全局唯一id\",{\"1\":{\"315\":1}}],[\"可以作为一个感兴趣的点\",{\"1\":{\"305\":1}}],[\"可以得到500个小文件\",{\"1\":{\"290\":1}}],[\"可以看做是一个value为null的hashmap\",{\"1\":{\"1029\":1}}],[\"可以看做是一个双向链表结构\",{\"1\":{\"1028\":1}}],[\"可以看出他是个很感性\",{\"1\":{\"306\":1}}],[\"可以看得出\",{\"1\":{\"277\":1}}],[\"可以看到中间环节较多\",{\"1\":{\"904\":1}}],[\"可以看到两个工人轮流处理\",{\"1\":{\"798\":1}}],[\"可以看到接收的消息被分为两节\",{\"1\":{\"750\":1}}],[\"可以看到一次就接收了\",{\"1\":{\"749\":1}}],[\"可以看到\",{\"1\":{\"277\":1,\"446\":1,\"798\":1,\"816\":1,\"905\":1,\"907\":1}}],[\"可以看到调用了无参的抽象的\",{\"1\":{\"123\":1}}],[\"可以采用线程池技术来减少线程数和线程上下文切换\",{\"1\":{\"876\":1}}],[\"可以采用一下几种方式\",{\"1\":{\"395\":1}}],[\"可以采用了\",{\"1\":{\"277\":1}}],[\"可以采用覆盖技术扩充内存\",{\"1\":{\"154\":1}}],[\"可以算出剩余可用的空间大小\",{\"1\":{\"277\":1}}],[\"可以用来包装\",{\"1\":{\"830\":1}}],[\"可以用来关闭\",{\"1\":{\"802\":1}}],[\"可以用来执行定时任务\",{\"1\":{\"801\":1}}],[\"可以用来执行耗时较长的任务\",{\"1\":{\"800\":1}}],[\"可以用来判断空间是否满足修改需求\",{\"1\":{\"277\":1}}],[\"可以用\",{\"1\":{\"731\":1}}],[\"可以用一个线程处理若干个客户端连接\",{\"1\":{\"332\":1}}],[\"可以用一个信号量来表示当前系统中某种资源的数量\",{\"1\":{\"143\":1}}],[\"可以用新遍历到的词替换堆顶的词\",{\"1\":{\"290\":1}}],[\"可以容纳\",{\"1\":{\"276\":1}}],[\"可以传入一个int型整数n\",{\"1\":{\"261\":1}}],[\"可以强转后调用\",{\"1\":{\"244\":1}}],[\"可以无限创建\",{\"1\":{\"244\":1}}],[\"可以放任意数量的任务\",{\"1\":{\"244\":1}}],[\"可以放到不相邻的页框中\",{\"1\":{\"156\":1}}],[\"可以想到重试必然频繁发生\",{\"1\":{\"231\":1}}],[\"可以由此扩展\",{\"1\":{\"769\":1}}],[\"可以由自己编写\",{\"1\":{\"539\":1}}],[\"可以由cpu调度使用\",{\"1\":{\"208\":1}}],[\"可以由操作系统协助\",{\"1\":{\"148\":1}}],[\"可以让redis开机自启\",{\"1\":{\"1016\":1}}],[\"可以让事务在遇到非运行时异常时也会回滚\",{\"1\":{\"722\":1}}],[\"可以让客户端和服务端进行双向通信\",{\"1\":{\"705\":1}}],[\"可以让链表可以快速的插入\",{\"1\":{\"425\":1}}],[\"可以让多个用户共享的适用同一个文件\",{\"1\":{\"172\":1}}],[\"可以让进程尝试让对方先使用临界区\",{\"1\":{\"141\":1}}],[\"可以为每道工序指定不同的工人\",{\"1\":{\"837\":1}}],[\"可以为文件分配离散的磁盘块\",{\"1\":{\"169\":1}}],[\"可以为其定义一个抽象类\",{\"1\":{\"107\":1}}],[\"可以使用69年\",{\"1\":{\"992\":1}}],[\"可以使用下面的代码来创建池化基于堆的\",{\"1\":{\"819\":1}}],[\"可以使用\",{\"1\":{\"383\":1,\"851\":1,\"905\":1}}],[\"可以使用hashmap来实现\",{\"1\":{\"290\":1}}],[\"可以使用hash值的大小来确定加锁的先后\",{\"1\":{\"221\":1}}],[\"可以使用分治策略\",{\"1\":{\"290\":1}}],[\"可以使用如下方式来避免sum的npe问题\",{\"1\":{\"267\":2}}],[\"可以使用count\",{\"1\":{\"266\":1}}],[\"可以使用几个基本操作完成更加复杂的操作\",{\"1\":{\"166\":1}}],[\"可以使用原型模式快捷的创建对象\",{\"1\":{\"88\":1}}],[\"可以使用原型模式复制多个\",{\"1\":{\"87\":1}}],[\"可以满足不同大小的进程的需求\",{\"1\":{\"154\":1}}],[\"可以动态申请内存分配\",{\"1\":{\"151\":1}}],[\"可以是键值型\",{\"1\":{\"1004\":1}}],[\"可以是字符串\",{\"1\":{\"1001\":1}}],[\"可以是\",{\"1\":{\"773\":1}}],[\"可以是一个整数\",{\"1\":{\"143\":1}}],[\"可以是接口或者抽象类\",{\"1\":{\"48\":1}}],[\"可以允许一个请求进入临界区的进程立即进入临界区\",{\"1\":{\"140\":1}}],[\"可以适当提升其优先级\",{\"1\":{\"139\":1}}],[\"可以适当提升优先级\",{\"1\":{\"139\":1}}],[\"可以适当降低其优先级\",{\"1\":{\"139\":1}}],[\"可以优先处理紧急的\",{\"1\":{\"137\":1}}],[\"可以说进程是由pcb\",{\"1\":{\"131\":1}}],[\"可以执行特权和非特权指令\",{\"1\":{\"128\":1}}],[\"可以延迟到子类中实现\",{\"1\":{\"118\":1}}],[\"可以在\",{\"1\":{\"824\":1}}],[\"可以在这里做手脚\",{\"1\":{\"617\":1}}],[\"可以在前端拦截一部分\",{\"1\":{\"315\":1}}],[\"可以在自己的生活中体验别人的一生\",{\"1\":{\"306\":1}}],[\"可以在屏幕显示实时的定位框和具体分类\",{\"1\":{\"300\":1}}],[\"可以在编译或者汇编的时候给出\",{\"1\":{\"151\":1}}],[\"可以在资源分配之前预先判断这次分配会不会导致系统进入不安全状态\",{\"1\":{\"149\":1}}],[\"可以在父类中实现\",{\"1\":{\"118\":1}}],[\"可以在类的成员位置声明抽象\",{\"1\":{\"112\":1}}],[\"可以方便地根据棋手的选择切换ai例程的水平\",{\"1\":{\"114\":1}}],[\"可以将数据填充至多个\",{\"1\":{\"857\":1}}],[\"可以将多个\",{\"1\":{\"829\":1,\"858\":1}}],[\"可以将对象之间的耦合度降低\",{\"1\":{\"734\":1}}],[\"可以将通过\",{\"1\":{\"499\":1}}],[\"可以将雪花算法作为一个单独的服务进行部署\",{\"1\":{\"440\":1}}],[\"可以将流中元素反复结合起来\",{\"1\":{\"342\":1}}],[\"可以将程序中很快会用到的部分装入内存\",{\"1\":{\"161\":1}}],[\"可以将优先级分为静态优先级和动态优先级两种\",{\"1\":{\"139\":1}}],[\"可以将暂时不能运行的进程调至外存等待\",{\"1\":{\"136\":1}}],[\"可以将已有对象纳入新对象中\",{\"1\":{\"112\":1}}],[\"可以将防火\",{\"1\":{\"110\":1}}],[\"可以直接访问这些对象的方法\",{\"1\":{\"111\":1}}],[\"可以直接访问\",{\"1\":{\"99\":1}}],[\"可以给不同的用户提供不同级别的使用权限\",{\"1\":{\"98\":1}}],[\"可以通过select命令来选择数据库\",{\"1\":{\"1021\":1}}],[\"可以通过下面三种方法来监听是否有事件发生\",{\"1\":{\"882\":1}}],[\"可以通过下面的系统环境变量来设置\",{\"1\":{\"820\":1}}],[\"可以通过下面源码查看默认大小\",{\"1\":{\"776\":1}}],[\"可以通过修改宏定义甚至重新编译内核的方式提升这一限制\",{\"1\":{\"410\":1}}],[\"可以通过遍历fdset\",{\"1\":{\"410\":1}}],[\"可以通过设置socket使其变为non\",{\"1\":{\"409\":1}}],[\"可以通过线程池进行改善\",{\"1\":{\"331\":1}}],[\"可以通过表头三个字段的长度直接定位\",{\"1\":{\"279\":1}}],[\"可以通过一次cas同时更改两个属性的值\",{\"1\":{\"241\":1}}],[\"可以通过\",{\"1\":{\"232\":1,\"277\":1,\"454\":1,\"582\":1,\"659\":1,\"710\":1,\"776\":1}}],[\"可以通过紧凑\",{\"1\":{\"154\":1}}],[\"可以通过第三方转发该调用\",{\"1\":{\"111\":1}}],[\"可以通过聚合\",{\"1\":{\"108\":1}}],[\"可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合\",{\"1\":{\"77\":1}}],[\"可以通过参数直接获取对象\",{\"1\":{\"64\":1}}],[\"可以创建并管理各种类的对象\",{\"1\":{\"708\":1}}],[\"可以创建多个对象\",{\"1\":{\"103\":1}}],[\"可以创建多个不同等级的产品\",{\"1\":{\"73\":1}}],[\"可以创建一个抽象类adapter\",{\"1\":{\"42\":1}}],[\"可以把指挥者类和抽象建造者进行结合\",{\"1\":{\"49\":1}}],[\"消息会经过通道\",{\"1\":{\"835\":1}}],[\"消息对象\",{\"1\":{\"787\":1}}],[\"消息\",{\"1\":{\"773\":2}}],[\"消息类型字节\",{\"1\":{\"773\":2}}],[\"消息是完整的\",{\"1\":{\"771\":1,\"773\":1}}],[\"消息正文\",{\"1\":{\"769\":1}}],[\"消息正文到底采用哪种序列化反序列化方式\",{\"1\":{\"769\":1}}],[\"消息无边界\",{\"1\":{\"751\":1}}],[\"消息服务\",{\"1\":{\"705\":1}}],[\"消息转换器\",{\"1\":{\"644\":2}}],[\"消息通知\",{\"1\":{\"433\":1}}],[\"消息队列\",{\"1\":{\"422\":1}}],[\"消息队列是有容量限制的\",{\"1\":{\"218\":1}}],[\"消息补偿\",{\"1\":{\"268\":1}}],[\"消息传递方式\",{\"1\":{\"410\":1}}],[\"消息传递\",{\"1\":{\"134\":1}}],[\"消费得慢\",{\"1\":{\"745\":1}}],[\"消费得快\",{\"1\":{\"745\":1}}],[\"消费string类型数据\",{\"1\":{\"744\":1}}],[\"消费型接口\",{\"1\":{\"336\":1}}],[\"消费队列可以用来平衡生产和消费的线程资源\",{\"1\":{\"218\":1}}],[\"消费模式\",{\"0\":{\"79\":1}}],[\"消防栓\",{\"1\":{\"33\":1}}],[\"另有\",{\"1\":{\"796\":1}}],[\"另一条线是继承自\",{\"1\":{\"796\":1}}],[\"另一部分是高级的\",{\"1\":{\"539\":1}}],[\"另一种思路是用多个数组组成\",{\"1\":{\"891\":1}}],[\"另一种思路是按分隔符拆分\",{\"1\":{\"890\":1}}],[\"另一种解读\",{\"1\":{\"766\":1}}],[\"另一种调用方法\",{\"1\":{\"512\":1}}],[\"另一种就是服务方需要使用幂等的方式保证一次和多次的请求结果一致\",{\"1\":{\"313\":1}}],[\"另一方面\",{\"1\":{\"394\":1,\"716\":1}}],[\"另一个产品目录的索引\",{\"1\":{\"922\":1}}],[\"另一个线程去真正建立连接\",{\"1\":{\"805\":1}}],[\"另一个等待的事务就能继续运行\",{\"1\":{\"403\":1}}],[\"另一个为\",{\"1\":{\"383\":1}}],[\"另一个访问该临界资源的进程必须等待\",{\"1\":{\"140\":1}}],[\"另一些计算机则采用i\",{\"1\":{\"180\":1}}],[\"另外如果发送的数据大于\",{\"1\":{\"883\":1}}],[\"另外源码部分\",{\"1\":{\"775\":1}}],[\"另外两个是通过代理实现的\",{\"1\":{\"714\":1}}],[\"另外要注意的是\",{\"1\":{\"451\":1}}],[\"另外地址转换也就是将逻辑地址转换为相应物理地址等功能也是操作系统内存管理做的事情\",{\"1\":{\"412\":1}}],[\"另外使用事务的地方需要考虑各方面的回滚方案\",{\"1\":{\"268\":1}}],[\"另外\",{\"1\":{\"139\":1,\"266\":1,\"276\":1,\"279\":1,\"470\":1,\"527\":1,\"721\":1}}],[\"另\",{\"1\":{\"78\":1}}],[\"令狐冲\",{\"1\":{\"78\":1}}],[\"目前最新的\",{\"1\":{\"705\":1}}],[\"目前现在都是前后端分离的项目\",{\"1\":{\"365\":1}}],[\"目前的代码仅支持\",{\"1\":{\"773\":1}}],[\"目前的jdk版本采用什么回收算法\",{\"1\":{\"355\":1}}],[\"目前的一个创新点就是针对锚框anchor提出了一个改进方案\",{\"1\":{\"300\":1}}],[\"目前只有g1\",{\"1\":{\"350\":1}}],[\"目前\",{\"1\":{\"350\":1,\"496\":1}}],[\"目前是在web进行的开发\",{\"1\":{\"300\":1}}],[\"目前正在对垃圾和非垃圾的一个阈值判断进行改进\",{\"1\":{\"300\":1}}],[\"目前一个缺点就是摄像头前面的所有东西都会当成垃圾\",{\"1\":{\"300\":1}}],[\"目录\",{\"1\":{\"951\":1,\"1000\":1,\"1012\":1}}],[\"目录可以提高查询速度\",{\"1\":{\"922\":1}}],[\"目录和一个\",{\"1\":{\"647\":1}}],[\"目录下\",{\"1\":{\"450\":1}}],[\"目录浏览一下就好\",{\"1\":{\"266\":1}}],[\"目录结构\",{\"1\":{\"168\":4}}],[\"目的是为了查询时实现自动反序列化\",{\"1\":{\"1041\":1}}],[\"目的是为了防止一些实现比较差的hashcode方法\",{\"1\":{\"327\":1}}],[\"目的是为了加强记忆方便查询\",{\"1\":{\"264\":1}}],[\"目的就是只需要执行一次\",{\"1\":{\"77\":1}}],[\"目态\",{\"1\":{\"128\":1}}],[\"目标方法执行结束\",{\"1\":{\"546\":1}}],[\"目标类target\",{\"1\":{\"515\":1}}],[\"目标接口foo\",{\"1\":{\"515\":1}}],[\"目标对象\",{\"1\":{\"510\":1,\"512\":1}}],[\"目标模块中的指令就是内存中的绝对地址\",{\"1\":{\"151\":1}}],[\"目标\",{\"0\":{\"833\":1},\"1\":{\"40\":1,\"126\":2}}],[\"键值\",{\"1\":{\"1009\":1}}],[\"键值型\",{\"1\":{\"1001\":1}}],[\"键值对中的键是字符串类型\",{\"1\":{\"275\":1}}],[\"键入网址到网页显示\",{\"1\":{\"198\":1}}],[\"键存储的是名称\",{\"1\":{\"77\":1}}],[\"键盘\",{\"1\":{\"33\":1}}],[\"静态资源处理\",{\"1\":{\"643\":1}}],[\"静态资源\",{\"1\":{\"643\":1}}],[\"静态资源解析优化\",{\"0\":{\"637\":1}}],[\"静态通知调用\",{\"0\":{\"546\":1}}],[\"静态方法\",{\"1\":{\"516\":1}}],[\"静态方法等实现增强\",{\"1\":{\"506\":1}}],[\"静态分配\",{\"1\":{\"185\":1}}],[\"静态分配和动态分配\",{\"1\":{\"185\":1}}],[\"静态链接\",{\"1\":{\"151\":1}}],[\"静态重定位\",{\"1\":{\"151\":1}}],[\"静态属性\",{\"1\":{\"105\":1}}],[\"静态属性由于被\",{\"1\":{\"101\":1}}],[\"静态内部类单例模式是一种优秀的单例模式\",{\"1\":{\"101\":1}}],[\"静态内部类单例模式中实例由内部类创建\",{\"1\":{\"101\":1}}],[\"静态内部类的初始化时机\",{\"1\":{\"101\":1}}],[\"静态内部类方式\",{\"1\":{\"101\":2}}],[\"静态代码块\",{\"1\":{\"1034\":1}}],[\"静态代码块方式\",{\"1\":{\"101\":1}}],[\"静态代理模式除了所有实现类需要实现这个方法外\",{\"1\":{\"96\":1}}],[\"静态代理\",{\"0\":{\"93\":1}}],[\"静态代理代理类在编译期就生成\",{\"1\":{\"91\":1}}],[\"静态变量还是局部变量\",{\"1\":{\"230\":1}}],[\"静态变量创建类的对象\",{\"1\":{\"101\":1}}],[\"静态变量方式\",{\"1\":{\"101\":1}}],[\"静态成员变量用来存储创建的对象\",{\"1\":{\"77\":1}}],[\"静态工厂\",{\"1\":{\"65\":1}}],[\"为何要取消💡\",{\"0\":{\"894\":1}}],[\"为何要\",{\"0\":{\"887\":1}}],[\"为何说一般查找行记录\",{\"0\":{\"377\":1}}],[\"为啥方法叫\",{\"1\":{\"834\":1}}],[\"为现象明显\",{\"1\":{\"750\":1}}],[\"为的是让其它配置优先解析\",{\"1\":{\"671\":1}}],[\"为简洁均省略了包名\",{\"1\":{\"670\":1}}],[\"为导入器类名\",{\"1\":{\"670\":1}}],[\"为4g\",{\"1\":{\"406\":1}}],[\"为每个线程分配一块tlab\",{\"1\":{\"352\":1}}],[\"为每一个页面设置一个访问位\",{\"1\":{\"163\":1}}],[\"为对象分配内存\",{\"1\":{\"352\":2}}],[\"为下次读写做准备\",{\"1\":{\"332\":1}}],[\"为下一次扩容的阈值大小\",{\"1\":{\"249\":1}}],[\"为应对当时的局面你做了什么努力\",{\"1\":{\"310\":1}}],[\"为3\",{\"1\":{\"261\":1}}],[\"为什么不在一个线程中去执行建立连接\",{\"1\":{\"805\":1}}],[\"为什么需要协议\",{\"0\":{\"766\":1}}],[\"为什么需要幂等性\",{\"0\":{\"313\":1}}],[\"为什么我们记得过去\",{\"1\":{\"731\":1}}],[\"为什么spring还要使用jdk动态代理\",{\"0\":{\"718\":1}}],[\"为什么stampedlock可以提升并发度的性能\",{\"1\":{\"260\":1}}],[\"为什么有这么麻烦的一套东西呢\",{\"1\":{\"527\":1}}],[\"为什么用户态与内核态的转换开销大\",{\"1\":{\"406\":1}}],[\"为什么用pc寄存器记录当前线程的执行地址呢\",{\"1\":{\"347\":1}}],[\"为什么它比直接将buffer\",{\"1\":{\"396\":1}}],[\"为什么b+树比b树更适合做索引\",{\"0\":{\"378\":1}}],[\"为什么索引使用b+树\",{\"0\":{\"377\":1}}],[\"为什么\",{\"1\":{\"309\":1,\"889\":1}}],[\"为什么选择华为\",{\"0\":{\"304\":1}}],[\"为什么要使用缓存\",{\"0\":{\"975\":1}}],[\"为什么要使用单例模式详解\",{\"1\":{\"99\":1}}],[\"为什么要保证主从节点机器时钟一致\",{\"1\":{\"437\":1}}],[\"为什么要有虚拟地址空间呢\",{\"0\":{\"415\":1}}],[\"为什么要有很多收集器\",{\"1\":{\"360\":1}}],[\"为什么要有gc\",{\"1\":{\"355\":1}}],[\"为什么要停顿两次\",{\"1\":{\"355\":1}}],[\"为什么要引入管程\",{\"1\":{\"145\":1}}],[\"为例\",{\"1\":{\"236\":1,\"889\":1}}],[\"为参数1值\",{\"1\":{\"232\":1}}],[\"为参数1\",{\"1\":{\"232\":1}}],[\"为\",{\"1\":{\"232\":4,\"249\":2,\"458\":1,\"576\":3,\"600\":3,\"644\":1,\"790\":2,\"791\":2,\"793\":1}}],[\"为1则继续运行并将counter置为0\",{\"1\":{\"219\":1}}],[\"为0则进入cond阻塞\",{\"1\":{\"219\":1}}],[\"为单位\",{\"1\":{\"173\":1,\"181\":1,\"751\":1}}],[\"为其分配很大的连续空间会很不方便\",{\"1\":{\"160\":1}}],[\"为离散分配的页表再建立一张页表\",{\"1\":{\"158\":1}}],[\"为防止恶意操作\",{\"1\":{\"120\":1}}],[\"为良好的代码设计和可维护性\",{\"1\":{\"98\":1}}],[\"为了减少内存的消耗\",{\"1\":{\"1042\":1}}],[\"为了减少io\",{\"0\":{\"376\":1}}],[\"为了在反序列化时知道对象的类型\",{\"1\":{\"1042\":1}}],[\"为了增加id的安全性\",{\"1\":{\"992\":1}}],[\"为了解决这个问题\",{\"1\":{\"927\":1}}],[\"为了解决此问题\",{\"1\":{\"751\":1}}],[\"为了简化起见\",{\"1\":{\"783\":1}}],[\"为了支持更多序列化算法\",{\"1\":{\"773\":1}}],[\"为了双工通信\",{\"1\":{\"769\":1}}],[\"为了防止插入幻影记录而提出的\",{\"1\":{\"401\":1}}],[\"为了防止低优先级进程发生饥饿\",{\"1\":{\"153\":1}}],[\"为了节省内存而采用的\",{\"1\":{\"279\":1}}],[\"为了节约内存而开发的\",{\"1\":{\"279\":1}}],[\"为了兼容部分\",{\"1\":{\"277\":1}}],[\"为了能够知道进程的每一个页面在内存中的存放位置\",{\"1\":{\"156\":1}}],[\"为了能够进行有效的管理\",{\"1\":{\"131\":1}}],[\"为了能对系统死锁进行检测需要满足的条件\",{\"1\":{\"150\":1}}],[\"为了保证该进程能正常运行\",{\"1\":{\"420\":1}}],[\"为了保证用户进程不能直接操作系统内核\",{\"1\":{\"406\":1}}],[\"为了保证进程间的安全通信\",{\"1\":{\"134\":1}}],[\"为了保证安全\",{\"1\":{\"134\":1}}],[\"为了保证系统能够安全运行\",{\"1\":{\"128\":1}}],[\"为了提高内存的空间性能\",{\"1\":{\"413\":1}}],[\"为了提高cpu的利用率\",{\"1\":{\"132\":1}}],[\"为了提高软件系统的可维护性和可复用性\",{\"1\":{\"106\":1}}],[\"为了对各个进程进行管理\",{\"1\":{\"132\":1}}],[\"为了方便操作系统管理\",{\"1\":{\"131\":1}}],[\"为了实现本地到远程的通信\",{\"1\":{\"98\":1}}],[\"为了演示方便\",{\"1\":{\"77\":1}}],[\"为jdk的动态代理提供了很好的补充\",{\"1\":{\"95\":1}}],[\"为此目的\",{\"1\":{\"928\":1}}],[\"为此引入线程来增加并发度\",{\"1\":{\"135\":1}}],[\"为此\",{\"1\":{\"81\":1,\"396\":1}}],[\"为原始类定义一个代理类\",{\"1\":{\"45\":1}}],[\"第\",{\"1\":{\"519\":1,\"776\":2}}],[\"第四轮扫描一定会有一个帧被选中\",{\"1\":{\"163\":1}}],[\"第四轮\",{\"1\":{\"163\":1}}],[\"第四步\",{\"1\":{\"120\":2}}],[\"第三方的配置类\",{\"1\":{\"672\":1}}],[\"第三方\",{\"1\":{\"653\":1}}],[\"第三种情况就mmp了\",{\"1\":{\"313\":1}}],[\"第三轮\",{\"1\":{\"163\":1}}],[\"第三次握手\",{\"1\":{\"776\":1}}],[\"第三次\",{\"1\":{\"158\":1,\"798\":2}}],[\"第三步\",{\"1\":{\"120\":2,\"290\":1}}],[\"第二版\",{\"0\":{\"787\":1,\"788\":1}}],[\"第二种是通过\",{\"1\":{\"504\":1}}],[\"第二方面\",{\"1\":{\"396\":1}}],[\"第二张牌倒下\",{\"1\":{\"280\":1}}],[\"第二轮\",{\"1\":{\"163\":1}}],[\"第二轮扫描一定会有访问位为0的页面\",{\"1\":{\"163\":1}}],[\"第二次触发了\",{\"1\":{\"887\":1}}],[\"第二次握手\",{\"1\":{\"776\":1}}],[\"第二次\",{\"1\":{\"158\":1,\"750\":1,\"798\":2}}],[\"第二步\",{\"1\":{\"77\":1,\"120\":2,\"290\":1,\"291\":1}}],[\"第五步\",{\"1\":{\"120\":2}}],[\"第一版\",{\"0\":{\"786\":1}}],[\"第一种是通过\",{\"1\":{\"504\":1}}],[\"第一方面\",{\"1\":{\"396\":1}}],[\"第一张牌倒下了\",{\"1\":{\"280\":1}}],[\"第一轮\",{\"1\":{\"163\":1}}],[\"第一个读取singleton对象\",{\"1\":{\"103\":1}}],[\"第一次触发了\",{\"1\":{\"887\":1}}],[\"第一次握手\",{\"1\":{\"776\":1}}],[\"第一次读的时候会获取version的取值\",{\"1\":{\"397\":1}}],[\"第一次超时之后\",{\"1\":{\"313\":1}}],[\"第一次减库存超时\",{\"1\":{\"313\":1}}],[\"第一次调用服务超时\",{\"1\":{\"313\":1}}],[\"第一次\",{\"1\":{\"158\":1,\"750\":1,\"798\":2}}],[\"第一次排\",{\"1\":{\"155\":1}}],[\"第一次加载singleton类时不会去初始化instance\",{\"1\":{\"101\":1}}],[\"第一次判断\",{\"1\":{\"101\":2}}],[\"第一步\",{\"1\":{\"77\":1,\"120\":1,\"290\":1,\"291\":1}}],[\"第2面供我们充电\",{\"1\":{\"39\":1}}],[\"洗衣机\",{\"1\":{\"76\":1}}],[\"洗碗槽\",{\"1\":{\"33\":1}}],[\"美式甜点工厂\",{\"1\":{\"74\":1}}],[\"美式咖啡和抹茶慕斯是同一产品族\",{\"1\":{\"74\":1}}],[\"美式咖啡是一个产品等级\",{\"1\":{\"74\":1}}],[\"美式咖啡\",{\"1\":{\"60\":1}}],[\"甜点工厂类\",{\"1\":{\"74\":1}}],[\"甜甜圈\",{\"1\":{\"33\":1}}],[\"抹茶慕斯也是一个产品等级\",{\"1\":{\"74\":1}}],[\"抹茶慕斯工厂\",{\"1\":{\"74\":1}}],[\"抹茶慕斯类\",{\"1\":{\"74\":1}}],[\"抹茶慕斯等\",{\"1\":{\"74\":1}}],[\"需要存储用户\",{\"1\":{\"1026\":1}}],[\"需要缓存重建\",{\"1\":{\"989\":1,\"990\":1}}],[\"需要拦截\",{\"1\":{\"972\":1}}],[\"需要结合服务器的设计演化来理解它的用途\",{\"1\":{\"912\":1}}],[\"需要再次\",{\"1\":{\"909\":1}}],[\"需要再次调用\",{\"1\":{\"909\":2}}],[\"需要扩容\",{\"1\":{\"890\":1}}],[\"需要提前分配\",{\"1\":{\"890\":1}}],[\"需要我们自己编码删除\",{\"1\":{\"887\":1}}],[\"需要多线程支持\",{\"1\":{\"876\":1}}],[\"需要释放\",{\"1\":{\"844\":3}}],[\"需要自己构建协议\",{\"1\":{\"842\":1}}],[\"需要更复杂的规则来回收内存\",{\"1\":{\"825\":1}}],[\"需要特殊的方法来回收内存\",{\"1\":{\"825\":1}}],[\"需要分两种情况来看\",{\"1\":{\"790\":1}}],[\"需要从协议的字节中得到是哪种序列化算法\",{\"1\":{\"773\":1}}],[\"需要利用逻辑过期解决缓存击穿问题将逻辑进行封装\",{\"1\":{\"990\":1}}],[\"需要利用逻辑过期解决缓存击穿问题\",{\"1\":{\"990\":1}}],[\"需要利用\",{\"1\":{\"695\":2}}],[\"需要获取\",{\"1\":{\"695\":1}}],[\"需要获取数组元素类型\",{\"1\":{\"695\":1}}],[\"需要根据\",{\"1\":{\"695\":2}}],[\"需要用它来发布响应\",{\"1\":{\"744\":1}}],[\"需要用它来给发布者响应\",{\"1\":{\"743\":1}}],[\"需要用\",{\"1\":{\"688\":1,\"872\":1}}],[\"需要用到时调入内存\",{\"1\":{\"153\":1}}],[\"需要的组件\",{\"1\":{\"561\":1}}],[\"需要调用\",{\"1\":{\"496\":1}}],[\"需要额外设置才能解析\",{\"1\":{\"454\":1}}],[\"需要手动收集\",{\"1\":{\"636\":1}}],[\"需要手动添加\",{\"1\":{\"454\":1}}],[\"需要手动调用方法来初始化单例\",{\"1\":{\"454\":1}}],[\"需要手动调用\",{\"1\":{\"454\":1}}],[\"需要把旧节点的数据迁移一部分到新节点\",{\"1\":{\"434\":1}}],[\"需要大部分的哨兵都同意才行\",{\"1\":{\"433\":1}}],[\"需要时再调入\",{\"1\":{\"413\":1}}],[\"需要时可在缓冲区中前后移动\",{\"1\":{\"332\":1}}],[\"需要维护一个用来存放大量fd的数据结构\",{\"1\":{\"410\":1}}],[\"需要注意的是\",{\"1\":{\"401\":1,\"731\":1}}],[\"需要注意的是对于innodb引擎来说\",{\"1\":{\"398\":1}}],[\"需要等待当前事务提交或回滚后释放锁\",{\"1\":{\"396\":1}}],[\"需要先指定10位的机器码\",{\"1\":{\"440\":1}}],[\"需要先获得相应的锁\",{\"1\":{\"396\":1}}],[\"需要先在业务层中向线程变量存入province属性\",{\"1\":{\"368\":1}}],[\"需要先将其他资源分配到位\",{\"1\":{\"132\":1}}],[\"需要造成系统长时间的停顿\",{\"1\":{\"356\":1}}],[\"需要具体分析是老年代回收还是整堆回收\",{\"1\":{\"350\":1}}],[\"需要创建大量的线程来处理连接\",{\"1\":{\"331\":1}}],[\"需要通过遍历的方式来统计字符串长度\",{\"1\":{\"277\":1}}],[\"需要通过子类来决定父类算法中某个步骤是否执行\",{\"1\":{\"122\":1}}],[\"需要进行对应的修改\",{\"1\":{\"268\":1}}],[\"需要进行加读锁\",{\"1\":{\"260\":1}}],[\"需要哪些字段必须明确写明\",{\"1\":{\"268\":1}}],[\"需要仔细评估in后边的集合元素数量\",{\"1\":{\"267\":1}}],[\"需要join的字段\",{\"1\":{\"266\":1}}],[\"需要及时更新字段注释\",{\"1\":{\"265\":1}}],[\"需要重新获取读锁\",{\"1\":{\"260\":1}}],[\"需要子类实现的方法\",{\"1\":{\"255\":1}}],[\"需要子类实现\",{\"1\":{\"255\":6}}],[\"需要对数据根据某个权重进行排序的场景\",{\"1\":{\"422\":1}}],[\"需要对写加锁\",{\"1\":{\"248\":1}}],[\"需要对目录进行哪些操作\",{\"1\":{\"168\":1}}],[\"需要考虑线程安全问题\",{\"1\":{\"209\":1}}],[\"需要将json反序列化成对象\",{\"1\":{\"989\":1,\"990\":1}}],[\"需要将传入的正文数据还原成\",{\"1\":{\"773\":1}}],[\"需要将\",{\"1\":{\"773\":1}}],[\"需要将每个节点设置成集群模式\",{\"1\":{\"434\":1}}],[\"需要将超级块中的数据复制到新回收的块中\",{\"1\":{\"170\":1}}],[\"需要将一整块的空闲分区合并\",{\"1\":{\"154\":1}}],[\"需要100个空闲块\",{\"1\":{\"170\":1}}],[\"需要换出页面时选择队头页面即可\",{\"1\":{\"163\":1}}],[\"需要占用很多个连续的页框\",{\"1\":{\"158\":1}}],[\"需要新增一个空闲分区\",{\"1\":{\"154\":1}}],[\"需要常驻内存的段放入固定区\",{\"1\":{\"153\":1}}],[\"需要\",{\"1\":{\"151\":1,\"523\":1,\"590\":2}}],[\"需要在数据库服务器端生成\",{\"1\":{\"391\":1}}],[\"需要在目录中删除相应的目录项\",{\"1\":{\"168\":1}}],[\"需要在其所属的目录中增加一个目录项\",{\"1\":{\"168\":1}}],[\"需要在内核态\",{\"1\":{\"142\":1}}],[\"需要在b中使用a类的方法\",{\"1\":{\"108\":1}}],[\"需要p0进程先访问才行\",{\"1\":{\"141\":1}}],[\"需要协调他们工作的次序\",{\"1\":{\"140\":1}}],[\"需要切换到核心态\",{\"1\":{\"135\":1}}],[\"需要切换进程的运行环境\",{\"1\":{\"135\":1}}],[\"需要使用特权指令\",{\"1\":{\"129\":1}}],[\"需要实现的功能\",{\"1\":{\"126\":1}}],[\"需要实现的功能和目标\",{\"1\":{\"126\":2}}],[\"需要配件cpu\",{\"1\":{\"109\":1}}],[\"需要去火车站买票\",{\"1\":{\"93\":1}}],[\"需要定义提拉米苏类\",{\"1\":{\"74\":1}}],[\"需求也会因为commit所释放的资源而减少\",{\"1\":{\"389\":1}}],[\"需求\",{\"1\":{\"60\":1,\"989\":1,\"998\":1}}],[\"纵轴是产品族\",{\"1\":{\"71\":1}}],[\"的关系\",{\"1\":{\"1005\":1}}],[\"的关闭\",{\"1\":{\"802\":1}}],[\"的订单与商品\",{\"1\":{\"1005\":1}}],[\"的条件了\",{\"1\":{\"996\":1}}],[\"的缓存\",{\"1\":{\"985\":1,\"988\":1,\"990\":1}}],[\"的读能力\",{\"1\":{\"904\":1}}],[\"的力量被白白浪费\",{\"1\":{\"896\":1}}],[\"的注册\",{\"1\":{\"893\":1}}],[\"的注入手段\",{\"1\":{\"490\":1}}],[\"的话\",{\"1\":{\"891\":1}}],[\"的联系\",{\"1\":{\"890\":1}}],[\"的可写事件\",{\"1\":{\"878\":1,\"893\":1}}],[\"的非阻塞模式\",{\"1\":{\"878\":1}}],[\"的数目\",{\"1\":{\"872\":1}}],[\"的数据写入\",{\"1\":{\"911\":1}}],[\"的数据填充至\",{\"1\":{\"858\":1}}],[\"的数据达到\",{\"1\":{\"751\":1}}],[\"的数据类型都是\",{\"1\":{\"277\":1}}],[\"的数据\",{\"1\":{\"277\":1,\"764\":1}}],[\"的数据结构\",{\"1\":{\"277\":1}}],[\"的数据结构来表示字符串\",{\"1\":{\"275\":1}}],[\"的线程安全⚠️\",{\"0\":{\"856\":1}}],[\"的线程来调用\",{\"1\":{\"799\":1}}],[\"的位置\",{\"1\":{\"854\":1}}],[\"的双向信号传输\",{\"1\":{\"845\":1}}],[\"的开发迭代更迅速\",{\"1\":{\"842\":1}}],[\"的优势\",{\"0\":{\"842\":1}}],[\"的地位\",{\"0\":{\"841\":1}}],[\"的重要贡献者\",{\"1\":{\"840\":1}}],[\"的作者\",{\"0\":{\"840\":1}}],[\"的作用就是配合一个线程来管理多个\",{\"1\":{\"917\":1}}],[\"的作用💡\",{\"0\":{\"888\":1}}],[\"的作用\",{\"0\":{\"602\":1},\"1\":{\"539\":1,\"604\":1,\"652\":1}}],[\"的规划\",{\"1\":{\"837\":1}}],[\"的待处理任务\",{\"1\":{\"837\":1}}],[\"的加工\",{\"1\":{\"837\":1}}],[\"的客户端实现\",{\"1\":{\"835\":1}}],[\"的业务处理器\",{\"1\":{\"834\":1}}],[\"的服务器端实现\",{\"1\":{\"834\":1}}],[\"的限制\",{\"1\":{\"827\":1}}],[\"的内容\",{\"1\":{\"853\":1}}],[\"的内容发生了更改\",{\"1\":{\"826\":1}}],[\"的内存\",{\"1\":{\"826\":1}}],[\"的体现之一\",{\"1\":{\"826\":1,\"827\":1,\"829\":1}}],[\"的存在\",{\"1\":{\"825\":1}}],[\"的整数倍\",{\"1\":{\"823\":1}}],[\"的逆序执行的\",{\"1\":{\"816\":1}}],[\"的子类\",{\"1\":{\"816\":2}}],[\"的子接口\",{\"1\":{\"446\":1}}],[\"的失败结果而不会抛出\",{\"1\":{\"815\":1}}],[\"的主要作用\",{\"1\":{\"802\":1}}],[\"的事件\",{\"1\":{\"879\":1}}],[\"的事件循环是否与当前的事件循环是同一个线程\",{\"1\":{\"799\":1}}],[\"的事件注册\",{\"1\":{\"790\":1,\"793\":1}}],[\"的能力\",{\"1\":{\"796\":1}}],[\"的逻辑是如果预期读取字节与实际读取字节相等\",{\"1\":{\"794\":1}}],[\"的逻辑如下\",{\"1\":{\"791\":1}}],[\"的理念让你的项目快速的运行起来\",{\"1\":{\"726\":1}}],[\"的理解\",{\"0\":{\"357\":1}}],[\"的帮助\",{\"1\":{\"705\":1}}],[\"的处理器\",{\"1\":{\"834\":1,\"835\":1}}],[\"的处理\",{\"1\":{\"695\":2}}],[\"的职责\",{\"1\":{\"678\":1}}],[\"的导入会在最后执行\",{\"1\":{\"671\":1}}],[\"的各项组件\",{\"1\":{\"665\":1}}],[\"的实现是一个\",{\"1\":{\"816\":1}}],[\"的实现\",{\"1\":{\"661\":1,\"705\":1,\"794\":1}}],[\"的本质是向容器中添加了\",{\"1\":{\"659\":1}}],[\"的有独立的示例\",{\"1\":{\"650\":1}}],[\"的骨架\",{\"1\":{\"646\":1}}],[\"的适配调用\",{\"1\":{\"643\":1}}],[\"的适配使用的是inputstreamreader\",{\"1\":{\"44\":1}}],[\"的视图\",{\"1\":{\"622\":1}}],[\"的响应\",{\"1\":{\"617\":1}}],[\"的错误页处理手段\",{\"1\":{\"620\":1}}],[\"的错误页面\",{\"1\":{\"617\":1}}],[\"的错误处理\",{\"1\":{\"617\":2}}],[\"的顺序\",{\"1\":{\"604\":1}}],[\"的顺序执行的\",{\"1\":{\"816\":1}}],[\"的顺序执行\",{\"1\":{\"141\":1}}],[\"的解析结果都会缓存来避免重复解析\",{\"1\":{\"588\":1,\"596\":1,\"616\":1}}],[\"的转换器\",{\"1\":{\"582\":2}}],[\"的转换优先级\",{\"1\":{\"582\":1}}],[\"的属性执行绑定\",{\"1\":{\"576\":1}}],[\"的属性赋值\",{\"1\":{\"576\":2}}],[\"的编程技巧在实现拦截器\",{\"1\":{\"552\":1}}],[\"的后增强\",{\"1\":{\"546\":2}}],[\"的一项体现\",{\"1\":{\"691\":1}}],[\"的一个属性来配置\",{\"1\":{\"661\":1}}],[\"的一个重要成员变量就是\",{\"1\":{\"449\":1}}],[\"的一堆方法\",{\"1\":{\"527\":1}}],[\"的获取\",{\"1\":{\"503\":1,\"695\":2}}],[\"的四种解决方法\",{\"1\":{\"503\":1}}],[\"的销毁\",{\"1\":{\"499\":1}}],[\"的销毁时机\",{\"1\":{\"499\":1}}],[\"的初始化阶段完成的\",{\"1\":{\"659\":1}}],[\"的初始化手段\",{\"1\":{\"490\":1}}],[\"的初始化的前后\",{\"1\":{\"458\":1}}],[\"的名字匹配\",{\"1\":{\"643\":1}}],[\"的名字会被当作映射路径\",{\"1\":{\"627\":1}}],[\"的名字作为视图名\",{\"1\":{\"622\":1}}],[\"的名字找到\",{\"1\":{\"617\":1}}],[\"的名字\",{\"1\":{\"490\":1}}],[\"的名字固定为\",{\"1\":{\"450\":1}}],[\"的诡异做法\",{\"1\":{\"486\":1}}],[\"的成员变量\",{\"1\":{\"473\":1}}],[\"的成员变量填充值\",{\"1\":{\"458\":1}}],[\"的值在三次握手时通知对方自己\",{\"1\":{\"751\":1}}],[\"的值为\",{\"1\":{\"751\":1}}],[\"的值\",{\"1\":{\"470\":1,\"688\":1,\"691\":1,\"751\":1}}],[\"的生命周期\",{\"0\":{\"458\":1}}],[\"的生命周期的各种功能\",{\"1\":{\"449\":1}}],[\"的例子\",{\"1\":{\"454\":1}}],[\"的创建方法\",{\"1\":{\"457\":1}}],[\"的创建过程提供增强\",{\"1\":{\"454\":1}}],[\"的创建蓝图\",{\"1\":{\"454\":1}}],[\"的发展历史较为悠久\",{\"1\":{\"451\":1}}],[\"的用法和扩展点\",{\"1\":{\"582\":1}}],[\"的用法\",{\"1\":{\"449\":1}}],[\"的功能\",{\"1\":{\"449\":1,\"451\":1,\"806\":1}}],[\"的核心容器\",{\"1\":{\"449\":1}}],[\"的父接口\",{\"1\":{\"449\":1}}],[\"的系统\",{\"1\":{\"440\":1}}],[\"的自增原子性来生成唯一\",{\"1\":{\"439\":1}}],[\"的全局唯一性\",{\"1\":{\"439\":1}}],[\"的算法\",{\"1\":{\"425\":1}}],[\"的置换功能\",{\"1\":{\"418\":1}}],[\"的两级存储器的结构\",{\"1\":{\"417\":1}}],[\"的连接\",{\"1\":{\"410\":1}}],[\"的就绪通知方式\",{\"1\":{\"410\":1}}],[\"的函数才能知道插入的子增值\",{\"1\":{\"391\":1}}],[\"的复杂度\",{\"1\":{\"387\":2}}],[\"的索引\",{\"1\":{\"383\":1}}],[\"的操作\",{\"1\":{\"383\":1}}],[\"的列\",{\"1\":{\"383\":1}}],[\"的部分\",{\"1\":{\"366\":1}}],[\"的变化\",{\"0\":{\"362\":1}}],[\"的调用也会\",{\"1\":{\"816\":1}}],[\"的调用过程\",{\"1\":{\"568\":1}}],[\"的调用\",{\"1\":{\"357\":1}}],[\"的相应类型的缓存数据\",{\"1\":{\"320\":1}}],[\"的问题\",{\"1\":{\"281\":2}}],[\"的扩展功能\",{\"1\":{\"470\":1,\"477\":1}}],[\"的扩展\",{\"1\":{\"280\":2}}],[\"的前置节点\",{\"1\":{\"280\":1}}],[\"的长度就大于等于\",{\"1\":{\"280\":1}}],[\"的长度\",{\"1\":{\"279\":1,\"752\":1}}],[\"的构造方法或者工厂方法来创建\",{\"1\":{\"458\":1}}],[\"的构造方法创建了一个新字符串\",{\"1\":{\"236\":1}}],[\"的构成如下\",{\"1\":{\"279\":1}}],[\"的方式调用的\",{\"1\":{\"998\":1}}],[\"的方式扫描所有标注了\",{\"1\":{\"661\":1}}],[\"的方式来进行死锁检测\",{\"1\":{\"403\":1}}],[\"的方式处理数据\",{\"1\":{\"334\":1}}],[\"的方式分配内存\",{\"1\":{\"277\":1}}],[\"的方法的返回值是\",{\"1\":{\"890\":1}}],[\"的方法\",{\"1\":{\"81\":1,\"499\":1,\"523\":1}}],[\"的结构就把上面这些问题解决了\",{\"1\":{\"276\":1}}],[\"的人提出了一种来检索元素是否在给定大集合中的数据结构\",{\"1\":{\"272\":1}}],[\"的空间大小\",{\"1\":{\"277\":3}}],[\"的空间扩展至执行修改所需的大小\",{\"1\":{\"277\":1}}],[\"的空间\",{\"1\":{\"272\":1}}],[\"的老哥于\",{\"1\":{\"272\":1}}],[\"的返回结果为null\",{\"1\":{\"267\":1}}],[\"的返回结果为0\",{\"1\":{\"267\":1}}],[\"的区分度来确定\",{\"1\":{\"266\":1,\"383\":1}}],[\"的区别\",{\"0\":{\"216\":1,\"447\":1},\"1\":{\"245\":1}}],[\"的时间\",{\"1\":{\"682\":1}}],[\"的时间占总时间的比例\",{\"1\":{\"138\":1}}],[\"的时刻调用await\",{\"1\":{\"263\":1}}],[\"的头节点\",{\"1\":{\"249\":1}}],[\"的高效方案\",{\"1\":{\"439\":1}}],[\"的高\",{\"1\":{\"241\":1}}],[\"的\",{\"1\":{\"232\":1,\"275\":1,\"276\":1,\"277\":7,\"280\":1,\"383\":1,\"506\":1,\"516\":1,\"519\":1,\"527\":1,\"539\":3,\"549\":1,\"556\":1,\"604\":1,\"622\":1,\"644\":1,\"678\":1,\"688\":1,\"695\":1,\"712\":1,\"751\":1,\"791\":1,\"796\":1,\"806\":2,\"822\":2,\"826\":1,\"837\":1,\"852\":1,\"853\":1,\"866\":2,\"877\":1,\"890\":1,\"891\":1,\"904\":1,\"917\":1}}],[\"的当前值\",{\"1\":{\"232\":4}}],[\"的字节码指令\",{\"1\":{\"230\":1}}],[\"的细分\",{\"1\":{\"208\":1}}],[\"的情况下\",{\"1\":{\"996\":1}}],[\"的情况\",{\"1\":{\"194\":2,\"237\":1,\"366\":1,\"491\":2}}],[\"的元素\",{\"1\":{\"189\":1}}],[\"的帧用于替换\",{\"1\":{\"163\":4}}],[\"的形式表示各页面的状态\",{\"1\":{\"163\":1}}],[\"的技术来解决\",{\"1\":{\"154\":1}}],[\"的什么位置保存被换出的进程\",{\"1\":{\"153\":1}}],[\"的支持\",{\"1\":{\"151\":1,\"705\":2}}],[\"的组成\",{\"1\":{\"131\":1}}],[\"的标志位设置为用户态\",{\"1\":{\"129\":1}}],[\"的类都是\",{\"1\":{\"451\":1}}],[\"的类\",{\"1\":{\"116\":1}}],[\"的皮肤是输入法背景图片\",{\"1\":{\"107\":1}}],[\"的皮肤设计\",{\"1\":{\"107\":1}}],[\"的皮肤为例介绍开闭原则的应用\",{\"1\":{\"107\":1}}],[\"的产品\",{\"1\":{\"71\":1}}],[\"种类型的主要区别就在于\",{\"1\":{\"277\":1}}],[\"种类型\",{\"1\":{\"277\":2}}],[\"种类\",{\"1\":{\"71\":1}}],[\"能搜索的数据必须索引\",{\"1\":{\"922\":1}}],[\"能突破一些技术上的限制\",{\"1\":{\"504\":1}}],[\"能干点啥\",{\"1\":{\"449\":1}}],[\"能通过它获取各种来源的配置信息\",{\"1\":{\"446\":1}}],[\"能打开的fd的上限远大于1024\",{\"1\":{\"410\":1}}],[\"能选多少件就选多少件\",{\"1\":{\"195\":1}}],[\"能否根据关键字实现随机查找\",{\"1\":{\"167\":1}}],[\"能否找到第i个记录对应的地址即能否实现随机存储\",{\"1\":{\"167\":1}}],[\"能让我们轻松地以不同的算法去解决同一个问题\",{\"1\":{\"114\":1}}],[\"能够保证\",{\"1\":{\"878\":1}}],[\"能够保证在多线程的情况下线程安全也不会有性能问题\",{\"1\":{\"101\":1}}],[\"能够获得关联的切面集合与目标\",{\"1\":{\"528\":1}}],[\"能够通知程序进行相应的读写操作\",{\"1\":{\"410\":1}}],[\"能够跟踪和记录了缓冲区的状态变化情况\",{\"1\":{\"332\":1}}],[\"能够建立索引的种类分为主键索引\",{\"1\":{\"266\":1}}],[\"能够实现最优的\",{\"1\":{\"246\":1}}],[\"能够及时地被其他线程看到\",{\"1\":{\"226\":1}}],[\"能够从物理内存中找到各个逻辑段的存放位置\",{\"1\":{\"159\":1}}],[\"能够整体地替换算法\",{\"1\":{\"114\":1}}],[\"能够飞翔\",{\"1\":{\"54\":1}}],[\"能生产多等级\",{\"1\":{\"71\":1}}],[\"同名\",{\"1\":{\"806\":1}}],[\"同上\",{\"1\":{\"410\":2}}],[\"同样\",{\"1\":{\"974\":1}}],[\"同样代表了\",{\"1\":{\"871\":1}}],[\"同样有两种办法\",{\"1\":{\"853\":1}}],[\"同样可以向它提交普通任务\",{\"1\":{\"800\":1}}],[\"同样为离散分配的页表在建立一张页表\",{\"1\":{\"413\":1}}],[\"同样加以编号\",{\"1\":{\"413\":1}}],[\"同样地\",{\"1\":{\"413\":1}}],[\"同样包含\",{\"1\":{\"277\":1}}],[\"同样在这条指令之后也会加入写屏障\",{\"1\":{\"237\":1}}],[\"同样是上面的案例\",{\"1\":{\"95\":1}}],[\"同理\",{\"1\":{\"182\":1}}],[\"同\",{\"1\":{\"147\":1,\"835\":1}}],[\"同步意味着\",{\"1\":{\"906\":1}}],[\"同步多路复用\",{\"1\":{\"901\":1}}],[\"同步非阻塞\",{\"1\":{\"901\":1}}],[\"同步处理任务失败\",{\"1\":{\"812\":1,\"813\":1}}],[\"同步处理任务成功\",{\"1\":{\"810\":1}}],[\"同步处理关闭\",{\"1\":{\"804\":1}}],[\"同步方式处理关闭\",{\"1\":{\"804\":1}}],[\"同步阻塞\",{\"1\":{\"331\":1,\"901\":1}}],[\"同步\",{\"0\":{\"144\":1},\"1\":{\"263\":1,\"901\":1}}],[\"同步也称为直接制约关系\",{\"1\":{\"140\":1}}],[\"同学们在拷贝代码的时候\",{\"1\":{\"1024\":1}}],[\"同学们注意他的value\",{\"1\":{\"965\":1}}],[\"同学\",{\"1\":{\"87\":1,\"89\":1}}],[\"同一个http\",{\"1\":{\"710\":1}}],[\"同一毫秒内的最新序号\",{\"1\":{\"441\":1}}],[\"同一毫秒时间戳下\",{\"1\":{\"440\":1}}],[\"同一毫秒时间戳时\",{\"1\":{\"440\":1}}],[\"同一分片多个节点间的数据不保持强一致性\",{\"1\":{\"434\":1}}],[\"同一进程中的线程切换\",{\"1\":{\"135\":1}}],[\"同一进程中的线程间通信甚至无需系统干预\",{\"1\":{\"135\":1}}],[\"同一进程的不同线程间可以共享进程的资源\",{\"1\":{\"135\":1}}],[\"同一学校的\",{\"1\":{\"87\":1}}],[\"同一品牌的产品产自同一个工厂\",{\"1\":{\"71\":1}}],[\"同具体工厂之间是多对一的关系\",{\"1\":{\"73\":1}}],[\"同种类产品称为同等级产品\",{\"1\":{\"71\":1}}],[\"同时为了确保他线程安全\",{\"1\":{\"998\":1}}],[\"同时为了进一步降低mysql的压力\",{\"1\":{\"955\":1}}],[\"同时的去执行数据库代码\",{\"1\":{\"987\":1}}],[\"同时刷新令牌\",{\"1\":{\"971\":1}}],[\"同时刷新登录token令牌的存活时间\",{\"1\":{\"970\":1}}],[\"同时将验证码进行保存\",{\"1\":{\"959\":1}}],[\"同时使用redis集群使得redis对外提供更好的服务\",{\"1\":{\"955\":1}}],[\"同时增加访问的性能\",{\"1\":{\"955\":1}}],[\"同时增加了用于异步响应式处理的\",{\"1\":{\"705\":1}}],[\"同时nginx在部署了前端项目后\",{\"1\":{\"955\":1}}],[\"同时支持阻塞\",{\"1\":{\"900\":1}}],[\"同时维护了一个\",{\"1\":{\"796\":1}}],[\"同时会初始化它关联的\",{\"1\":{\"790\":1}}],[\"同时加了\",{\"1\":{\"582\":1}}],[\"同时把暂时不运行的页面换出到外存上\",{\"1\":{\"419\":1}}],[\"同时把这个id返回给客户端\",{\"1\":{\"315\":1}}],[\"同时连接的大量客户端在同一时刻可能只有很少的处于就绪状态\",{\"1\":{\"410\":1}}],[\"同时\",{\"1\":{\"383\":1,\"707\":1,\"996\":1,\"1042\":1}}],[\"同时对老年代和新生代进行回收\",{\"1\":{\"357\":1}}],[\"同时解决压缩列表的\",{\"1\":{\"281\":1}}],[\"同时触发成绩表中的student\",{\"1\":{\"267\":1}}],[\"同时抛弃阻塞队列中的任务\",{\"1\":{\"241\":1}}],[\"同时处理任务队列中的任务\",{\"1\":{\"241\":1}}],[\"同时只能由一个线程执行i++\",{\"1\":{\"230\":1}}],[\"同时共享方式\",{\"1\":{\"127\":1}}],[\"同时确保只有单个对象被创建\",{\"1\":{\"99\":1}}],[\"同时也控制了锁的粒度\",{\"1\":{\"998\":1}}],[\"同时也能起到流量控制的作用\",{\"1\":{\"751\":1}}],[\"同时也会与其他已经加入的对象的hashcode值进行比较\",{\"1\":{\"318\":1}}],[\"同时也对sell方法进行了增强\",{\"1\":{\"93\":1}}],[\"同时也增加了系统具体类的依赖\",{\"1\":{\"58\":1}}],[\"同时又去申请其他资源\",{\"1\":{\"221\":1}}],[\"同时又解决了线程安全问题\",{\"1\":{\"101\":1}}],[\"同时又产生了新的耦合\",{\"1\":{\"63\":1}}],[\"同时又继承现有组件库中已经存在的组件\",{\"1\":{\"41\":1}}],[\"传输数据\",{\"0\":{\"870\":1}}],[\"传输问题\",{\"1\":{\"842\":1}}],[\"传输时间ts​=r1​∗nb​=rnb​\",{\"1\":{\"176\":1}}],[\"传输时间ts​\",{\"1\":{\"176\":1}}],[\"传播给每个\",{\"1\":{\"837\":1}}],[\"传递给下一个\",{\"1\":{\"825\":1}}],[\"传递了四个参数\",{\"1\":{\"52\":1}}],[\"传入为pojo类\",{\"1\":{\"268\":1}}],[\"传入的是布尔变量\",{\"1\":{\"233\":1}}],[\"传入的是整型变量\",{\"1\":{\"233\":1}}],[\"传统关系型数据库能满足事务acid的原则\",{\"1\":{\"1007\":1}}],[\"传统关系型数据库会基于sql语句做查询\",{\"1\":{\"1006\":1}}],[\"传统关系型数据库是结构化数据\",{\"1\":{\"1004\":1}}],[\"传统数据库的表与表之间往往存在关联\",{\"1\":{\"1005\":1}}],[\"传统的\",{\"1\":{\"904\":1}}],[\"传统的进程是程序执行流的最小单位\",{\"1\":{\"135\":1}}],[\"传统异步编程的写法\",{\"1\":{\"742\":1}}],[\"传统\",{\"0\":{\"904\":1},\"1\":{\"451\":2}}],[\"传统存储管理方式的问题\",{\"1\":{\"161\":1}}],[\"传统进程间并发\",{\"1\":{\"135\":1}}],[\"传统进程中\",{\"1\":{\"135\":2}}],[\"传智播客只培养计算机软件专业的学生等\",{\"1\":{\"71\":1}}],[\"前提是这个field不存在\",{\"1\":{\"1027\":1}}],[\"前提是这个key不存在\",{\"1\":{\"1025\":1}}],[\"前言\",{\"1\":{\"974\":1}}],[\"前先做个标记\",{\"1\":{\"824\":1}}],[\"前初始化这些都是\",{\"1\":{\"678\":1}}],[\"前缀的配置项进行定制配置\",{\"1\":{\"661\":1}}],[\"前缀的\",{\"1\":{\"652\":1}}],[\"前缀树\",{\"0\":{\"282\":1}}],[\"前置通知会被转换为原始的\",{\"1\":{\"545\":1}}],[\"前\",{\"1\":{\"519\":1}}],[\"前两者采用函数式方法获取列名\",{\"1\":{\"371\":1}}],[\"前两种能接受\",{\"1\":{\"313\":1}}],[\"前面的代码只有一个选择器\",{\"1\":{\"896\":1}}],[\"前面提到的原子性\",{\"1\":{\"396\":1}}],[\"前面提到\",{\"1\":{\"280\":1}}],[\"前面介绍的工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"71\":1}}],[\"前一个节点的长度\",{\"1\":{\"279\":1}}],[\"前一个节点\",{\"1\":{\"279\":1}}],[\"前者配置了\",{\"1\":{\"662\":1}}],[\"前者现在时表示主动创建\",{\"1\":{\"265\":1}}],[\"前者类之间的耦合度比后者高\",{\"1\":{\"39\":1}}],[\"前端传来不定条件mybatis\",{\"0\":{\"370\":1}}],[\"前端传过来的参数都是json格式的\",{\"1\":{\"365\":1}}],[\"前端首页的gis插件的中心点也会自动更新到定位参数的位置\",{\"1\":{\"296\":1}}],[\"前端更改会自动更新数据库的值\",{\"1\":{\"296\":1}}],[\"前端通过echarts向用户进行可视化展示\",{\"1\":{\"296\":1}}],[\"前端\",{\"1\":{\"197\":1}}],[\"前驱关系\",{\"0\":{\"144\":1}}],[\"前台进程优先级高于后台进程\",{\"1\":{\"139\":1}}],[\"前三个是基本状态\",{\"1\":{\"132\":1}}],[\"要维护关系要么靠代码中的业务逻辑\",{\"1\":{\"1005\":1}}],[\"要支持百万连接就要\",{\"1\":{\"891\":1}}],[\"要从\",{\"1\":{\"886\":1,\"890\":1,\"904\":1,\"905\":2}}],[\"要点\",{\"1\":{\"805\":1}}],[\"要解绑会话\",{\"1\":{\"758\":1}}],[\"要解决双重检查锁模式带来空指针异常的问题\",{\"1\":{\"101\":1}}],[\"要绑定会话\",{\"1\":{\"758\":1}}],[\"要是问bean的线程安全问题需要考虑单例bean还是多例bean\",{\"1\":{\"712\":1}}],[\"要是按照工厂方法模式\",{\"1\":{\"74\":1}}],[\"要实现\",{\"1\":{\"631\":1}}],[\"要区分本章节提到的\",{\"1\":{\"531\":1}}],[\"要注入的对象\",{\"1\":{\"500\":1}}],[\"要遵循\",{\"1\":{\"395\":1}}],[\"要尽量采用二级索引\",{\"1\":{\"387\":1}}],[\"要了解这一点\",{\"1\":{\"275\":1}}],[\"要先select\",{\"1\":{\"267\":1}}],[\"要么靠数据之间的耦合\",{\"1\":{\"1005\":1}}],[\"要么你\",{\"1\":{\"989\":1}}],[\"要么是输出\",{\"1\":{\"911\":1}}],[\"要么是输入\",{\"1\":{\"911\":1}}],[\"要么是输入流要么是输出流\",{\"1\":{\"332\":1}}],[\"要么取消\",{\"1\":{\"885\":1,\"890\":1}}],[\"要么处理\",{\"1\":{\"885\":1}}],[\"要么对超过特定阈值的页数进行sql改写\",{\"1\":{\"266\":1}}],[\"要么控制返回的总页数\",{\"1\":{\"266\":1}}],[\"要么全部失败\",{\"1\":{\"226\":1}}],[\"要么全部完成\",{\"1\":{\"226\":1}}],[\"要创建链表头节点\",{\"1\":{\"249\":1}}],[\"要创建table\",{\"1\":{\"249\":1}}],[\"要创建的复杂对象\",{\"1\":{\"48\":1}}],[\"要保证该局部变量是\",{\"1\":{\"232\":1}}],[\"要花费一定时间\",{\"1\":{\"173\":1}}],[\"要找到第i个记录\",{\"1\":{\"167\":1}}],[\"要等p1释放资源\",{\"1\":{\"150\":1}}],[\"要为每一对前驱关系各设置一个同步变量\",{\"1\":{\"144\":1}}],[\"要求同一个优惠券\",{\"1\":{\"998\":1}}],[\"要求实现\",{\"1\":{\"627\":1}}],[\"要求必须将作业装入一个连续的内存区域中\",{\"1\":{\"419\":1}}],[\"要求返回出现频率最高的100个词\",{\"1\":{\"289\":1}}],[\"要求在resultmap中进行字段与属性之间的映射\",{\"1\":{\"268\":1}}],[\"要求是ref级别\",{\"1\":{\"266\":1}}],[\"要求服务时间相同时\",{\"1\":{\"139\":1}}],[\"要求服务时间短的优先\",{\"1\":{\"139\":1}}],[\"要求服务时间\",{\"1\":{\"139\":2}}],[\"要求子类必须实现\",{\"1\":{\"123\":1}}],[\"要求子类必须重写\",{\"1\":{\"123\":1}}],[\"要视频\",{\"1\":{\"135\":1}}],[\"要做的无非三类事情\",{\"1\":{\"133\":1}}],[\"要增加产品类时也要相应地增加工厂类\",{\"1\":{\"69\":1}}],[\"咖啡店类\",{\"1\":{\"69\":1}}],[\"咖啡店具有点咖啡的功能\",{\"1\":{\"60\":1}}],[\"咖啡具体类\",{\"1\":{\"69\":1}}],[\"咖啡抽象类\",{\"1\":{\"69\":1}}],[\"概念\",{\"0\":{\"67\":1,\"72\":1,\"742\":1}}],[\"概述\",{\"0\":{\"39\":1,\"47\":1,\"60\":1,\"80\":1,\"84\":1,\"91\":1,\"114\":1,\"118\":1}}],[\"完善为\",{\"1\":{\"644\":1}}],[\"完全抛弃了\",{\"1\":{\"841\":1}}],[\"完全懵逼的状态\",{\"1\":{\"313\":1}}],[\"完全背包和01背包相比就是每件物品数量无限\",{\"1\":{\"195\":1}}],[\"完全背包\",{\"0\":{\"195\":1},\"1\":{\"195\":1}}],[\"完全遵循开闭原则\",{\"1\":{\"66\":1}}],[\"完整的自举程序放在磁盘的启动块\",{\"1\":{\"178\":1}}],[\"完成整体刷新功能\",{\"1\":{\"971\":1}}],[\"完成请求和响应\",{\"1\":{\"961\":1}}],[\"完成文件\",{\"1\":{\"904\":1}}],[\"完成对多个\",{\"1\":{\"878\":1}}],[\"完成收发\",{\"1\":{\"770\":1}}],[\"完成用户注册与发送短信之间的解耦\",{\"1\":{\"449\":1}}],[\"完成扩容操作\",{\"1\":{\"323\":1}}],[\"完成之后需要cpu介入\",{\"1\":{\"181\":2}}],[\"完成一次读\",{\"1\":{\"181\":3}}],[\"完成初始化\",{\"1\":{\"178\":1}}],[\"完成的\",{\"1\":{\"178\":1}}],[\"完成各程序并发执行\",{\"1\":{\"131\":1}}],[\"完成具体产品的创建\",{\"1\":{\"68\":1,\"73\":1}}],[\"完成复杂产品的各个部件的具体创建方法\",{\"1\":{\"48\":1}}],[\"开机自启\",{\"0\":{\"1016\":1},\"1\":{\"1013\":1}}],[\"开机时计算机先运行\",{\"1\":{\"178\":1}}],[\"开机时文件分配表放入内存\",{\"1\":{\"169\":1}}],[\"开启缓存重建\",{\"1\":{\"989\":1,\"990\":1}}],[\"开启独立线程\",{\"1\":{\"989\":1,\"990\":1}}],[\"开启两个客户端\",{\"1\":{\"886\":1}}],[\"开启了nagle算法\",{\"1\":{\"778\":1}}],[\"开源的消息队列\",{\"1\":{\"841\":1}}],[\"开发中的地位\",{\"1\":{\"841\":1}}],[\"开发一个简单的服务器端和客户端\",{\"1\":{\"833\":1}}],[\"开发拦截器\",{\"1\":{\"738\":1}}],[\"开始抢购时间\",{\"1\":{\"994\":1}}],[\"开始时间戳\",{\"1\":{\"993\":1}}],[\"开始计算\",{\"1\":{\"809\":1}}],[\"开始不停的监控\",{\"1\":{\"206\":1}}],[\"开头\",{\"1\":{\"643\":1}}],[\"开头的一系列方法\",{\"1\":{\"822\":1,\"824\":1}}],[\"开头的\",{\"1\":{\"627\":1}}],[\"开头并不能命中\",{\"1\":{\"385\":1}}],[\"开区间\",{\"1\":{\"401\":1}}],[\"开关中断权限比较大\",{\"1\":{\"142\":1}}],[\"开关中断权限非常大\",{\"1\":{\"133\":1}}],[\"开\",{\"1\":{\"142\":1}}],[\"开销大\",{\"1\":{\"135\":1,\"163\":1}}],[\"开中断指令\",{\"1\":{\"133\":1}}],[\"开展管理工作\",{\"1\":{\"129\":1}}],[\"开闭原则\",{\"0\":{\"107\":1},\"1\":{\"64\":1,\"121\":1}}],[\"开放了所有\",{\"1\":{\"37\":1}}],[\"违背了忙则等待的原则\",{\"1\":{\"141\":1}}],[\"违背了\",{\"1\":{\"64\":1}}],[\"违反了开闭原则\",{\"1\":{\"63\":1}}],[\"把第二个拦截器做的事情放入到第一个拦截器中\",{\"1\":{\"971\":1}}],[\"把第一个文件中出现频率最高的100个词构造成小顶堆\",{\"1\":{\"290\":1}}],[\"把多出来的内容写入新的数组\",{\"1\":{\"891\":1}}],[\"把这条完整消息存入新的\",{\"1\":{\"890\":1}}],[\"把要调用的代码封装为一个任务对象\",{\"1\":{\"799\":1}}],[\"把跨应用的多个模块功能抽象出来\",{\"1\":{\"716\":1}}],[\"把它当做视图名\",{\"1\":{\"600\":1}}],[\"把它们都列出来\",{\"1\":{\"451\":1}}],[\"把类型\",{\"1\":{\"574\":1}}],[\"把\",{\"1\":{\"574\":1,\"575\":1,\"649\":1,\"837\":4,\"893\":1}}],[\"把其它类型转为\",{\"1\":{\"574\":1}}],[\"把slave提升为新的master\",{\"1\":{\"437\":1}}],[\"把数据改回去\",{\"1\":{\"396\":1}}],[\"把对象按照程序员的意愿进行初始化\",{\"1\":{\"352\":1}}],[\"把对象的创建和业务逻辑层分开\",{\"1\":{\"64\":1}}],[\"把一个大文件分解成多个小文件\",{\"1\":{\"290\":1}}],[\"把count加上volatile也不能解决这个问题\",{\"1\":{\"230\":1}}],[\"把用于链接文件各个物理块的指针显示的存放在一张表中\",{\"1\":{\"169\":1}}],[\"把内存分为一个个相等的小分区\",{\"1\":{\"156\":1}}],[\"把已占的内存挪位\",{\"1\":{\"154\":1}}],[\"把外存中某些已具备运行条件的进程换入内存\",{\"1\":{\"153\":1}}],[\"把只能互斥使用的资源改造为允许共享使用\",{\"1\":{\"148\":1}}],[\"把更基础的方法和成员写到base类\",{\"1\":{\"108\":1}}],[\"把适配者接口转换成目标接口\",{\"1\":{\"40\":1}}],[\"rw\",{\"1\":{\"846\":1,\"857\":1,\"858\":1}}],[\"rcvbuf\",{\"0\":{\"779\":1,\"781\":1},\"1\":{\"750\":2,\"779\":1}}],[\"r>\",{\"1\":{\"742\":1,\"990\":3}}],[\"rpcclientmanager\",{\"1\":{\"787\":1}}],[\"rpcclient\",{\"1\":{\"783\":1,\"785\":1}}],[\"rpcserver\",{\"1\":{\"783\":1}}],[\"rpcresponsemessagehandler\",{\"1\":{\"783\":2,\"785\":2,\"786\":1,\"787\":3,\"788\":1}}],[\"rpcresponsemessage\",{\"1\":{\"783\":2,\"784\":2,\"786\":1,\"788\":1}}],[\"rpcrequestmessagehandler\",{\"1\":{\"783\":2,\"784\":1}}],[\"rpcrequestmessage\",{\"1\":{\"783\":3,\"784\":1,\"785\":1,\"787\":2}}],[\"rpc\",{\"0\":{\"782\":1},\"1\":{\"783\":13,\"785\":2,\"787\":2,\"841\":2}}],[\"rpop\",{\"1\":{\"422\":1,\"1028\":2}}],[\"rpush\",{\"1\":{\"422\":1,\"1028\":2}}],[\"rt\",{\"1\":{\"346\":1}}],[\"rdcconfig\",{\"1\":{\"265\":1}}],[\"rdc\",{\"1\":{\"265\":1}}],[\"right\",{\"1\":{\"249\":1,\"283\":6,\"287\":2}}],[\"r\",{\"1\":{\"176\":2,\"191\":5,\"336\":2,\"749\":6,\"750\":7,\"754\":19,\"755\":18,\"756\":19,\"798\":18,\"803\":2,\"858\":1,\"904\":1,\"990\":21}}],[\"rose\",{\"1\":{\"1025\":2}}],[\"rowendindex\",{\"1\":{\"849\":6}}],[\"row++\",{\"1\":{\"849\":1}}],[\"row\",{\"1\":{\"849\":10}}],[\"rowprefixes\",{\"1\":{\"849\":5}}],[\"rowstartindex\",{\"1\":{\"849\":12}}],[\"rows\",{\"1\":{\"818\":2,\"849\":1}}],[\"rocketmq\",{\"1\":{\"841\":1}}],[\"rollbackfor\",{\"0\":{\"722\":1}}],[\"rolemapper\",{\"1\":{\"366\":2}}],[\"rolename\",{\"1\":{\"366\":1}}],[\"roleid\",{\"1\":{\"366\":1}}],[\"role\",{\"1\":{\"366\":19}}],[\"role表\",{\"1\":{\"366\":1}}],[\"route\",{\"1\":{\"630\":1}}],[\"routerfunction<serverresponse>\",{\"1\":{\"630\":1}}],[\"routerfunctionmapping\",{\"0\":{\"628\":1},\"1\":{\"630\":3,\"631\":1,\"643\":1}}],[\"round\",{\"1\":{\"139\":1}}],[\"roots有哪些\",{\"1\":{\"355\":1}}],[\"rooty\",{\"1\":{\"285\":3}}],[\"rootx\",{\"1\":{\"285\":3}}],[\"root\",{\"1\":{\"282\":21,\"283\":14,\"285\":7,\"372\":1}}],[\"robin\",{\"1\":{\"139\":1}}],[\"rr通过mvcc快照读的思想就已经解决了幻读的问题\",{\"1\":{\"393\":1}}],[\"rr解决了脏读\",{\"1\":{\"393\":1}}],[\"rr\",{\"1\":{\"139\":1}}],[\"rapid\",{\"1\":{\"839\":1}}],[\"radomcondition\",{\"1\":{\"370\":1}}],[\"rangequery\",{\"1\":{\"942\":5}}],[\"rangequerybuilder\",{\"1\":{\"942\":1}}],[\"range\",{\"1\":{\"265\":1,\"266\":2}}],[\"randomuuid\",{\"1\":{\"968\":1}}],[\"randomutil\",{\"1\":{\"960\":1}}],[\"randomnumbers\",{\"1\":{\"960\":1}}],[\"randomnumbergenerator\",{\"1\":{\"82\":3}}],[\"randomaccessfile\",{\"1\":{\"846\":2,\"857\":2,\"858\":2,\"863\":3,\"866\":1,\"904\":2}}],[\"randomkey随机拿出一个key后\",{\"1\":{\"436\":1}}],[\"random或者allkeys\",{\"1\":{\"428\":1}}],[\"random\",{\"1\":{\"82\":4,\"116\":10,\"429\":2,\"749\":2,\"754\":2,\"755\":2,\"756\":2}}],[\"ratio\",{\"1\":{\"139\":1}}],[\"runalltasks\",{\"1\":{\"791\":4}}],[\"run方法运行过程中还涉及启动时长统计\",{\"1\":{\"728\":1}}],[\"runner\",{\"1\":{\"650\":1}}],[\"runnable\",{\"1\":{\"208\":1,\"224\":6,\"225\":6,\"775\":1,\"790\":4,\"791\":2,\"793\":1,\"799\":1,\"896\":3,\"993\":1}}],[\"running\",{\"1\":{\"132\":1,\"241\":1,\"801\":5}}],[\"run是一个线程的具体执行内容\",{\"1\":{\"202\":1}}],[\"run\",{\"1\":{\"109\":5,\"206\":1,\"224\":6,\"225\":6,\"648\":1,\"650\":1,\"775\":1,\"790\":4,\"791\":6,\"793\":1,\"796\":1,\"799\":1,\"812\":5,\"815\":13,\"896\":3}}],[\"runtimedemo\",{\"1\":{\"105\":1}}],[\"runtime\",{\"1\":{\"105\":13,\"731\":1,\"896\":1,\"897\":1}}],[\"runtime类就是使用的单例设计模式\",{\"1\":{\"105\":1}}],[\"runtime类\",{\"0\":{\"105\":1}}],[\"runtimeexception\",{\"1\":{\"63\":1,\"82\":2,\"94\":4,\"104\":1,\"441\":1,\"515\":2,\"743\":1,\"744\":1,\"773\":2,\"787\":1,\"812\":5,\"813\":4,\"814\":4,\"932\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"r2\",{\"1\":{\"86\":2,\"147\":1}}],[\"r1​\",{\"1\":{\"176\":1}}],[\"r1\",{\"1\":{\"86\":3,\"324\":1,\"630\":3}}],[\"reload\",{\"1\":{\"1016\":1}}],[\"releases\",{\"1\":{\"1019\":1}}],[\"releaseshared\",{\"1\":{\"255\":1}}],[\"release\",{\"0\":{\"825\":1},\"1\":{\"255\":1,\"770\":1,\"794\":1,\"825\":16,\"826\":3}}],[\"rewind\",{\"1\":{\"853\":1,\"854\":1}}],[\"rebuild\",{\"1\":{\"792\":2,\"989\":2,\"990\":2}}],[\"rebuildselector0\",{\"1\":{\"791\":1}}],[\"re\",{\"1\":{\"790\":1}}],[\"regexutils\",{\"1\":{\"960\":2,\"968\":1}}],[\"regfuture\",{\"1\":{\"790\":15}}],[\"registry\",{\"1\":{\"961\":3}}],[\"registrationbean\",{\"1\":{\"657\":2}}],[\"register0\",{\"1\":{\"790\":4,\"793\":4}}],[\"register\",{\"1\":{\"790\":4,\"793\":4,\"796\":1,\"881\":1,\"884\":1,\"886\":2,\"890\":2,\"893\":3,\"896\":6}}],[\"registered\",{\"1\":{\"749\":1,\"750\":1,\"754\":2,\"755\":1,\"756\":2,\"790\":2,\"793\":1,\"798\":3}}],[\"registerbeandefinition\",{\"1\":{\"454\":1}}],[\"registerbean\",{\"1\":{\"450\":1}}],[\"revd\",{\"1\":{\"776\":1}}],[\"retain\",{\"0\":{\"825\":1},\"1\":{\"770\":1,\"825\":1,\"826\":2}}],[\"retentionpolicy\",{\"1\":{\"731\":1}}],[\"retention\",{\"1\":{\"731\":1}}],[\"retu\",{\"1\":{\"237\":1}}],[\"returnvalue\",{\"1\":{\"783\":1,\"788\":2}}],[\"returnvaluehandlers\",{\"1\":{\"587\":1}}],[\"returntype\",{\"1\":{\"783\":4}}],[\"returns\",{\"1\":{\"105\":1,\"792\":1}}],[\"return\",{\"1\":{\"41\":4,\"42\":1,\"44\":2,\"49\":6,\"52\":11,\"57\":4,\"58\":5,\"63\":1,\"65\":1,\"69\":4,\"74\":4,\"77\":1,\"82\":1,\"86\":1,\"87\":2,\"89\":4,\"94\":9,\"95\":2,\"101\":7,\"103\":5,\"104\":7,\"105\":2,\"108\":4,\"109\":7,\"111\":3,\"116\":12,\"123\":4,\"191\":1,\"192\":1,\"195\":2,\"236\":1,\"244\":3,\"249\":7,\"255\":4,\"260\":2,\"277\":2,\"282\":8,\"283\":4,\"285\":2,\"287\":3,\"336\":3,\"339\":1,\"368\":4,\"441\":4,\"450\":1,\"463\":1,\"491\":1,\"500\":1,\"510\":1,\"512\":1,\"515\":3,\"523\":1,\"619\":2,\"622\":3,\"626\":4,\"630\":3,\"635\":4,\"638\":1,\"641\":2,\"647\":1,\"670\":3,\"672\":2,\"711\":6,\"731\":1,\"732\":2,\"737\":1,\"758\":9,\"759\":2,\"773\":11,\"783\":3,\"787\":5,\"790\":11,\"791\":1,\"792\":1,\"793\":2,\"794\":2,\"807\":1,\"808\":1,\"816\":1,\"825\":2,\"849\":2,\"872\":5,\"896\":1,\"909\":1,\"932\":1,\"949\":1,\"960\":5,\"961\":2,\"962\":1,\"968\":3,\"972\":5,\"977\":1,\"983\":5,\"985\":4,\"988\":6,\"989\":3,\"990\":17,\"993\":1,\"994\":2,\"995\":5,\"996\":3,\"998\":14,\"1034\":1,\"1041\":1}}],[\"requirepass\",{\"1\":{\"1015\":1}}],[\"requires\",{\"1\":{\"720\":1}}],[\"required\",{\"1\":{\"720\":3,\"731\":1,\"737\":1}}],[\"requestoptions\",{\"1\":{\"933\":3,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"request方法\",{\"1\":{\"745\":1}}],[\"requestpredicate\",{\"1\":{\"631\":1,\"643\":1}}],[\"requestparam和\",{\"1\":{\"731\":1}}],[\"requestparam\",{\"1\":{\"568\":4,\"731\":3,\"737\":2}}],[\"requesthandled\",{\"1\":{\"600\":3}}],[\"requestheader\",{\"1\":{\"568\":1}}],[\"requestmappinginfo\",{\"1\":{\"561\":1}}],[\"requestmapping\",{\"1\":{\"558\":1,\"561\":1,\"604\":1,\"617\":1,\"643\":2,\"644\":1,\"647\":1,\"737\":1}}],[\"requestmappinghandleradapter\",{\"0\":{\"558\":1},\"1\":{\"558\":1,\"561\":1,\"568\":1,\"587\":1,\"588\":2,\"596\":2,\"643\":1,\"644\":1}}],[\"requestmappinghandlermapping\",{\"0\":{\"558\":1},\"1\":{\"558\":1,\"561\":1,\"643\":1,\"644\":1}}],[\"request\",{\"0\":{\"497\":1},\"1\":{\"496\":1,\"604\":1,\"617\":1,\"622\":1,\"626\":1,\"630\":1,\"710\":1,\"742\":1,\"743\":2,\"744\":4,\"783\":3,\"933\":6,\"934\":17,\"936\":4,\"937\":3,\"938\":4,\"939\":4,\"940\":4,\"941\":4,\"942\":4,\"943\":4,\"944\":4,\"945\":4,\"946\":4,\"961\":2,\"972\":4}}],[\"requestdatahelper\",{\"1\":{\"368\":1}}],[\"requestbody来接受数据的话\",{\"1\":{\"731\":1}}],[\"requestbody注解\",{\"1\":{\"365\":1}}],[\"requestbody是对json格式的入参进行处理\",{\"1\":{\"365\":1}}],[\"requestbody\",{\"0\":{\"365\":1},\"1\":{\"568\":1,\"644\":1,\"731\":3,\"732\":1,\"737\":2,\"994\":2}}],[\"render\",{\"1\":{\"622\":1}}],[\"reids集群模式下数据hash分片算法\",{\"0\":{\"435\":1}}],[\"receive\",{\"1\":{\"898\":2}}],[\"recently\",{\"1\":{\"429\":2}}],[\"recvbufallochandle\",{\"1\":{\"793\":1,\"794\":1}}],[\"recvbytebufallocator\",{\"1\":{\"793\":1,\"794\":1}}],[\"recvfrom\",{\"1\":{\"409\":1}}],[\"record\",{\"1\":{\"401\":2}}],[\"rectangle\",{\"1\":{\"58\":5}}],[\"red\",{\"1\":{\"944\":1}}],[\"redo\",{\"1\":{\"389\":1,\"396\":2}}],[\"reduce\",{\"1\":{\"342\":4}}],[\"redisstringtests\",{\"1\":{\"1042\":1,\"1043\":1}}],[\"redisserializer\",{\"1\":{\"1041\":2}}],[\"redisson\",{\"1\":{\"1031\":1}}],[\"redisconnectionfactory\",{\"1\":{\"1041\":1}}],[\"redisconfig\",{\"1\":{\"1041\":1}}],[\"redisconstants\",{\"1\":{\"983\":4,\"985\":5,\"988\":8,\"989\":4,\"990\":7}}],[\"redis<\",{\"1\":{\"1038\":1}}],[\"redis依赖\",{\"1\":{\"1038\":1,\"1040\":1}}],[\"redis没有类似mysql中的table的概念\",{\"1\":{\"1026\":1}}],[\"redis命令\",{\"0\":{\"1025\":1,\"1026\":1,\"1027\":1,\"1028\":1,\"1029\":1,\"1030\":1}}],[\"redis命令行客户端\",{\"0\":{\"1018\":1}}],[\"redis为了方便我们学习\",{\"1\":{\"1023\":1}}],[\"redis数据结构介绍\",{\"0\":{\"1023\":1}}],[\"redis数据本身就是共享的\",{\"1\":{\"963\":1}}],[\"redis常见命令\",{\"0\":{\"1022\":1}}],[\"redis常见数据结构以及使用场景\",{\"0\":{\"422\":1}}],[\"redis默认有16个仓库\",{\"1\":{\"1021\":1}}],[\"redisdemoapplicationtests\",{\"1\":{\"1040\":1}}],[\"redisdesktopmanager\",{\"1\":{\"1019\":2}}],[\"redisdata\",{\"1\":{\"989\":9,\"990\":9}}],[\"redisdata<>\",{\"1\":{\"989\":1,\"990\":1}}],[\"redisdata<shop>\",{\"1\":{\"989\":1}}],[\"redisdata<t>\",{\"1\":{\"989\":1,\"990\":1}}],[\"redis安装完成后就自带了命令行客户端\",{\"1\":{\"1018\":1}}],[\"redis桌面客户端\",{\"0\":{\"1017\":1}}],[\"redis是一个key\",{\"1\":{\"1023\":1}}],[\"redis是一种键值型的nosql数据库\",{\"1\":{\"1001\":1}}],[\"redis是基于c语言编写的\",{\"1\":{\"1011\":1}}],[\"redis诞生于2009年全称是remote\",{\"1\":{\"1009\":1}}],[\"redis简单介绍\",{\"0\":{\"1001\":1}}],[\"redis系列整理学习自黑马程序员redis相关课程\",{\"1\":{\"1000\":1}}],[\"redisidworker\",{\"1\":{\"993\":3,\"995\":1,\"998\":3}}],[\"redis实现全局唯一id\",{\"0\":{\"993\":1}}],[\"redis的java客户端\",{\"0\":{\"1031\":1,\"1036\":1}}],[\"redis的sortedset是一个可排序的set集合\",{\"1\":{\"1030\":1}}],[\"redis的set结构与java中的hashset类似\",{\"1\":{\"1029\":1}}],[\"redis的key允许有多个单词形成层级结构\",{\"1\":{\"1026\":1}}],[\"redis的其它常见配置\",{\"1\":{\"1015\":1}}],[\"redis的启动方式有很多种\",{\"1\":{\"1013\":1}}],[\"redis的官方网站地址\",{\"1\":{\"1009\":1}}],[\"redis的value中\",{\"1\":{\"987\":1}}],[\"redis的内存淘汰机制使用了allkeys\",{\"1\":{\"428\":1}}],[\"redistemplate的两种序列化实践方案\",{\"1\":{\"1042\":1}}],[\"redistemplate<>\",{\"1\":{\"1041\":1}}],[\"redistemplate<string\",{\"1\":{\"1040\":1,\"1041\":2}}],[\"redistemplate可以接收任意object作为值写入redis\",{\"1\":{\"1041\":1}}],[\"redistemplate\",{\"1\":{\"983\":3,\"985\":3,\"988\":5,\"989\":2,\"990\":11,\"1040\":3,\"1041\":1}}],[\"redis会以层级结构来进行存储\",{\"1\":{\"1026\":1}}],[\"redis会将超时的数据进行删除\",{\"1\":{\"980\":1}}],[\"redis会返回转向指令\",{\"1\":{\"434\":1}}],[\"redis自动进行\",{\"1\":{\"980\":1}}],[\"redis中的list类型与java中的linkedlist类似\",{\"1\":{\"1028\":1}}],[\"redis中\",{\"1\":{\"968\":1}}],[\"redis中数据大量过期\",{\"1\":{\"437\":1}}],[\"redis代替session的业务流程\",{\"0\":{\"964\":1}}],[\"redis里面有一个randomkey命令可以从redis中随机取出一个key\",{\"1\":{\"436\":1}}],[\"redis执行命令出现死循环bug\",{\"0\":{\"436\":1}}],[\"redis集群的性能和高可用性均优于之前版本的哨兵模式\",{\"1\":{\"434\":1}}],[\"redis集群不需要sentine哨兵也能完成节点移出和故障转移的功能\",{\"1\":{\"434\":1}}],[\"redis集群是由多个主从节点群组成的分布式服务器群\",{\"1\":{\"434\":1}}],[\"redis主从的部署架构\",{\"1\":{\"433\":1}}],[\"redis高可用方案\",{\"0\":{\"431\":1}}],[\"redis内存淘汰机制\",{\"0\":{\"429\":1}}],[\"redis底层数据是如何用跳表来存储的\",{\"0\":{\"425\":1}}],[\"redis单线程为什么还快\",{\"0\":{\"424\":1}}],[\"redis到底是单线程还是多线程\",{\"0\":{\"423\":1}}],[\"redis\",{\"0\":{\"421\":1,\"426\":1,\"428\":1,\"767\":1,\"951\":1,\"1000\":1,\"1024\":1,\"1060\":1},\"1\":{\"275\":5,\"276\":2,\"277\":8,\"278\":2,\"279\":2,\"281\":3,\"423\":2,\"435\":1,\"437\":1,\"439\":1,\"1009\":1,\"1012\":5,\"1014\":1,\"1015\":9,\"1016\":9,\"1018\":2,\"1023\":1,\"1031\":1,\"1036\":1,\"1039\":1},\"2\":{\"1044\":1,\"1045\":1}}],[\"rehashing过程很复杂\",{\"1\":{\"328\":1}}],[\"referencecountutil\",{\"1\":{\"825\":2}}],[\"referencecounted\",{\"1\":{\"825\":3}}],[\"refreshtokeninterceptor\",{\"1\":{\"961\":1,\"972\":3}}],[\"refresh\",{\"1\":{\"450\":1,\"650\":1}}],[\"ref\",{\"1\":{\"266\":1}}],[\"reflect=all\",{\"1\":{\"519\":2}}],[\"reflect\",{\"1\":{\"94\":4}}],[\"reentrantreadwritelock是一种读写锁\",{\"1\":{\"259\":1}}],[\"reentrantreadwritelock\",{\"0\":{\"259\":1},\"1\":{\"251\":1}}],[\"reentrantlock的非公平体现在\",{\"1\":{\"258\":1}}],[\"reentrantlock的公平锁和非公平锁\",{\"0\":{\"258\":1}}],[\"reentrantlock与synchronized的区别\",{\"0\":{\"257\":1}}],[\"reentrantlock是基于lock接口和aqs抽象类实现的可重入锁\",{\"1\":{\"256\":1}}],[\"reentrantlock\",{\"0\":{\"256\":1},\"1\":{\"224\":2,\"225\":8}}],[\"rejectedexecutionhandler\",{\"1\":{\"242\":1}}],[\"remainder\",{\"1\":{\"849\":5}}],[\"remaining\",{\"1\":{\"139\":1}}],[\"remote=\",{\"1\":{\"886\":2}}],[\"remoteaddress\",{\"1\":{\"775\":2}}],[\"remote\",{\"1\":{\"98\":1}}],[\"removeuser\",{\"1\":{\"962\":1,\"972\":1}}],[\"removereadop\",{\"1\":{\"793\":1,\"794\":1}}],[\"removegroup\",{\"1\":{\"758\":1}}],[\"removemember\",{\"1\":{\"758\":1,\"761\":1}}],[\"remove改变集合元素的操作之中\",{\"1\":{\"249\":1}}],[\"remove\",{\"0\":{\"887\":1},\"1\":{\"82\":1,\"788\":1,\"790\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":2,\"896\":2,\"962\":1}}],[\"replicas\",{\"0\":{\"928\":1}}],[\"replace\",{\"1\":{\"236\":1,\"872\":1,\"873\":1}}],[\"repository用于声明dao层的bean\",{\"1\":{\"709\":1}}],[\"repository\",{\"1\":{\"709\":1,\"950\":1,\"1038\":1}}],[\"rep\",{\"1\":{\"104\":1}}],[\"restart\",{\"1\":{\"1016\":1}}],[\"restclientbuilder\",{\"1\":{\"949\":1}}],[\"restclient\",{\"1\":{\"932\":1,\"949\":1}}],[\"restcontroller是\",{\"1\":{\"731\":1}}],[\"restcontroller\",{\"1\":{\"731\":1}}],[\"resthighlevelclient\",{\"1\":{\"932\":3,\"933\":3,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"949\":2}}],[\"rest\",{\"1\":{\"931\":1,\"932\":1}}],[\"resizable\",{\"1\":{\"891\":1}}],[\"resolvabledependencies\",{\"1\":{\"688\":1,\"695\":2}}],[\"resolveargument\",{\"1\":{\"568\":1}}],[\"resource中确保关闭\",{\"1\":{\"743\":1,\"744\":1}}],[\"resource既可以按类型注入也可以指定bean名称注入\",{\"1\":{\"709\":1}}],[\"resourcehttprequesthandler\",{\"1\":{\"635\":7,\"636\":1,\"638\":3}}],[\"resourcehttprequesthandler>\",{\"1\":{\"635\":1}}],[\"resources这些注解的功能\",{\"1\":{\"708\":1}}],[\"resources\",{\"1\":{\"450\":1,\"647\":1,\"649\":1}}],[\"resourcebundlemessagesource\",{\"1\":{\"450\":2}}],[\"resource\",{\"1\":{\"446\":1,\"449\":1,\"454\":2,\"460\":1,\"463\":2,\"470\":1,\"641\":3,\"709\":1,\"711\":1,\"961\":1}}],[\"resetreaderindex\",{\"1\":{\"824\":1}}],[\"reset\",{\"0\":{\"854\":1},\"1\":{\"793\":1,\"794\":1,\"824\":1,\"854\":1}}],[\"reservationnode<k\",{\"1\":{\"249\":1}}],[\"research\",{\"1\":{\"19\":1}}],[\"responsebody的合集\",{\"1\":{\"731\":1}}],[\"responsebodyadvice\",{\"0\":{\"605\":1,\"606\":1},\"1\":{\"607\":1,\"608\":1}}],[\"responsebody\",{\"1\":{\"600\":1,\"604\":1,\"644\":1,\"732\":1}}],[\"responseentity\",{\"1\":{\"600\":1,\"731\":2,\"732\":2,\"737\":2}}],[\"response\",{\"1\":{\"139\":1,\"622\":3,\"626\":2,\"759\":2,\"768\":4,\"783\":3,\"784\":5,\"844\":4,\"933\":8,\"934\":4,\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2,\"961\":2,\"972\":4}}],[\"respectmaybemoredata\",{\"1\":{\"794\":2}}],[\"respect\",{\"1\":{\"105\":1}}],[\"resulttype=\",{\"1\":{\"366\":1}}],[\"resultmap=\",{\"1\":{\"366\":2}}],[\"resultmap>\",{\"1\":{\"366\":2}}],[\"resultclass=\",{\"1\":{\"268\":3}}],[\"result\",{\"1\":{\"94\":4,\"95\":2,\"116\":2,\"510\":2,\"512\":3,\"515\":4,\"523\":4,\"813\":2,\"814\":2,\"907\":2,\"909\":3,\"960\":7,\"968\":4,\"977\":1,\"983\":7,\"990\":3,\"994\":4,\"995\":6,\"996\":2,\"998\":15,\"1032\":3}}],[\"reached\",{\"1\":{\"825\":1}}],[\"reactivestreamdemo2\",{\"1\":{\"744\":1}}],[\"reactivestreamdemo\",{\"1\":{\"743\":1}}],[\"reactive\",{\"0\":{\"1051\":1},\"1\":{\"451\":1,\"742\":2}}],[\"reactor模式是基于同步io\",{\"1\":{\"333\":1}}],[\"reactor和proactor\",{\"1\":{\"333\":3}}],[\"real\",{\"1\":{\"92\":1}}],[\"realizetype\",{\"1\":{\"86\":8}}],[\"readvalue\",{\"1\":{\"1042\":1}}],[\"readview\",{\"1\":{\"393\":1}}],[\"readhandler\",{\"1\":{\"909\":4}}],[\"reads分散读\",{\"0\":{\"857\":1}}],[\"readsd\",{\"1\":{\"41\":7,\"42\":3}}],[\"readline\",{\"1\":{\"845\":2}}],[\"readlock\",{\"1\":{\"260\":2}}],[\"readcomplete\",{\"1\":{\"793\":1,\"794\":1}}],[\"readbuf\",{\"1\":{\"793\":6}}],[\"readbytes\",{\"1\":{\"770\":1,\"771\":1,\"773\":2,\"798\":1,\"852\":1,\"864\":1}}],[\"readbyte\",{\"1\":{\"770\":4,\"771\":4,\"773\":4,\"824\":4,\"826\":2}}],[\"readpending\",{\"1\":{\"790\":1,\"793\":3,\"794\":3}}],[\"readifisautoread\",{\"1\":{\"790\":1,\"793\":1}}],[\"readinterestop\",{\"1\":{\"790\":3,\"793\":2}}],[\"readint\",{\"1\":{\"770\":3,\"771\":3,\"773\":3,\"824\":1}}],[\"readablebytes\",{\"1\":{\"770\":1,\"798\":1,\"818\":1,\"829\":2}}],[\"readfds和exceptfds\",{\"1\":{\"410\":1}}],[\"read之后\",{\"1\":{\"409\":1}}],[\"readtime\",{\"1\":{\"260\":1}}],[\"readtf\",{\"1\":{\"41\":3,\"42\":1}}],[\"readyops\",{\"1\":{\"792\":6}}],[\"ready\",{\"1\":{\"132\":1,\"650\":1}}],[\"readordinaryobject\",{\"1\":{\"104\":2}}],[\"readobject0\",{\"1\":{\"104\":2}}],[\"readobjectfromfile\",{\"1\":{\"103\":3}}],[\"readobject\",{\"1\":{\"89\":1,\"103\":1,\"104\":1,\"770\":1,\"771\":1,\"773\":2}}],[\"readresolve\",{\"1\":{\"104\":3}}],[\"readerindex\",{\"1\":{\"818\":1}}],[\"reader\",{\"1\":{\"44\":1,\"764\":2,\"845\":4}}],[\"read\",{\"0\":{\"794\":1,\"886\":1},\"1\":{\"41\":3,\"42\":1,\"44\":4,\"104\":1,\"105\":1,\"123\":11,\"260\":1,\"393\":1,\"749\":2,\"750\":4,\"754\":11,\"755\":11,\"756\":11,\"775\":1,\"776\":2,\"790\":4,\"792\":4,\"793\":10,\"794\":7,\"798\":12,\"818\":2,\"822\":2,\"823\":1,\"824\":5,\"825\":1,\"826\":2,\"846\":1,\"847\":1,\"849\":1,\"852\":2,\"857\":1,\"864\":1,\"876\":4,\"877\":7,\"881\":1,\"883\":1,\"884\":1,\"886\":4,\"887\":1,\"889\":4,\"890\":8,\"893\":4,\"896\":5,\"901\":2,\"904\":2,\"907\":6,\"908\":1,\"909\":7,\"981\":1}}],[\"反序列化错误\",{\"1\":{\"773\":1}}],[\"反序列化方法\",{\"1\":{\"773\":1}}],[\"反序列化\",{\"1\":{\"773\":1}}],[\"反序列化机制\",{\"1\":{\"773\":1}}],[\"反序列化时\",{\"1\":{\"773\":1}}],[\"反序列化主要用在消息正文的转换上\",{\"1\":{\"773\":1}}],[\"反序列方式破坏单例模式的解决方法\",{\"1\":{\"104\":1}}],[\"反之\",{\"1\":{\"718\":1}}],[\"反之则是线程不安全的\",{\"1\":{\"349\":1}}],[\"反之不可用\",{\"1\":{\"41\":1}}],[\"反过来\",{\"1\":{\"268\":1}}],[\"反例\",{\"1\":{\"265\":1,\"266\":2}}],[\"反而会因为频繁上下文切换导致性能降低\",{\"1\":{\"876\":1}}],[\"反而有所增加\",{\"1\":{\"805\":1}}],[\"反而效率会受影响\",{\"1\":{\"231\":1}}],[\"反而比较像是一种编程习惯\",{\"1\":{\"61\":1}}],[\"反复的申请和释放资源会增加系统的开销\",{\"1\":{\"148\":1}}],[\"反射时就可以拿到参数名\",{\"1\":{\"572\":1}}],[\"反射的知识\",{\"1\":{\"516\":1}}],[\"反射的方式\",{\"1\":{\"351\":2}}],[\"反射破解单例模式需要添加的代码\",{\"1\":{\"104\":1}}],[\"反射方式破解单例的解决方法\",{\"1\":{\"104\":1}}],[\"反射\",{\"1\":{\"103\":1,\"449\":1}}],[\"简略版本\",{\"1\":{\"736\":1}}],[\"简而言之\",{\"1\":{\"726\":1}}],[\"简称\",{\"1\":{\"546\":1,\"790\":1}}],[\"简称ts或tsl指令\",{\"1\":{\"142\":1}}],[\"简化了程序编写\",{\"1\":{\"333\":1}}],[\"简要来说包含mark\",{\"1\":{\"210\":1}}],[\"简单说明一下\",{\"1\":{\"660\":1}}],[\"简单比较的话\",{\"1\":{\"504\":1}}],[\"简单分为连续分配管理方式和非连续分配管理方式\",{\"1\":{\"413\":1}}],[\"简单来说段页式管理机制就是先把用户程序分成若干个段\",{\"1\":{\"413\":1}}],[\"简单来说\",{\"1\":{\"359\":1}}],[\"简单的解决方案就是哪怕这个数据在数据库中也不存在\",{\"1\":{\"984\":1}}],[\"简单的形式对第三方软件进行集成\",{\"1\":{\"730\":1}}],[\"简单的说就是调用方在调用接口的时候先向后端请求一个全局id\",{\"1\":{\"315\":1}}],[\"简单的说就是要求对抽象进行编程\",{\"1\":{\"109\":1}}],[\"简单的时钟置换算法仅仅考虑到一个页面最近是否被访问过\",{\"1\":{\"163\":1}}],[\"简单的clock算法实现方法\",{\"1\":{\"163\":1}}],[\"简单\",{\"1\":{\"142\":1}}],[\"简单工厂+配置文件解除耦合\",{\"1\":{\"77\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"62\":1}}],[\"简单工厂不是一种设计模式\",{\"1\":{\"61\":1}}],[\"简单工厂模式\",{\"0\":{\"61\":1},\"1\":{\"60\":1}}],[\"简言之\",{\"1\":{\"107\":1}}],[\"简笔画转真图\",{\"1\":{\"16\":1}}],[\"简笔画的猫转成真猫\",{\"1\":{\"10\":1}}],[\"假死的连接占用的资源不能自动释放\",{\"1\":{\"764\":1}}],[\"假如有一个1g大小的文件\",{\"1\":{\"289\":1}}],[\"假如我们要更换对象\",{\"1\":{\"60\":1}}],[\"假脱机技术\",{\"0\":{\"184\":1},\"1\":{\"184\":1}}],[\"假设我们不设置过期时间\",{\"1\":{\"987\":1}}],[\"假设现在线程3过来访问\",{\"1\":{\"987\":1}}],[\"假设现在线程2过来\",{\"1\":{\"987\":1}}],[\"假设现在线程1过来访问\",{\"1\":{\"987\":1}}],[\"假设线程过来\",{\"1\":{\"987\":1}}],[\"假设线程1过来查询库存\",{\"1\":{\"996\":1}}],[\"假设线程1去查询缓存\",{\"1\":{\"987\":1}}],[\"假设线程1在查询缓存之后\",{\"1\":{\"987\":1}}],[\"假设线程1先来\",{\"1\":{\"982\":1}}],[\"假设布隆过滤器判断这个数据不存在\",{\"1\":{\"984\":1}}],[\"假设当前用户访问了一些不需要拦截的路径\",{\"1\":{\"970\":1}}],[\"假设用户第一次访问第一台tomcat\",{\"1\":{\"963\":1}}],[\"假设消息一直向后传\",{\"1\":{\"825\":1}}],[\"假设病人源源不断地来\",{\"1\":{\"805\":1}}],[\"假设一个中文字符长度为\",{\"1\":{\"766\":1}}],[\"假设长度为\",{\"1\":{\"754\":1}}],[\"假设接收方的窗口只剩了\",{\"1\":{\"751\":1}}],[\"假设发送方\",{\"1\":{\"751\":1}}],[\"假设已有第三方的两个自动配置类\",{\"1\":{\"670\":1}}],[\"假设已经选取了n个初始聚类中心\",{\"1\":{\"300\":1}}],[\"假设redis中存在大量已过期但是未被清理的key\",{\"1\":{\"436\":1}}],[\"假设访问一次内存的时间为t\",{\"1\":{\"413\":1}}],[\"假设常驻人口的定义为30天出现20天及以上\",{\"1\":{\"296\":1}}],[\"假设下面这个结构体\",{\"1\":{\"277\":1}}],[\"假设有一进程\",{\"1\":{\"420\":1}}],[\"假设有如下两张表\",{\"1\":{\"366\":1}}],[\"假设有个字符串中有个\",{\"1\":{\"276\":1}}],[\"假设有1000个线程对i执行++操作\",{\"1\":{\"230\":1}}],[\"假设thread\",{\"1\":{\"261\":1}}],[\"假设磁盘转速为r\",{\"1\":{\"176\":1}}],[\"假设是匀速移动\",{\"1\":{\"176\":1}}],[\"假设每个分组最多为100个空闲块\",{\"1\":{\"170\":1}}],[\"假设采用的数据结构是空闲分区表\",{\"1\":{\"154\":1}}],[\"假设iou阈值为0\",{\"1\":{\"25\":1}}],[\"万物皆对象\",{\"1\":{\"60\":1}}],[\"都没查到\",{\"1\":{\"987\":1}}],[\"都操作缓存\",{\"1\":{\"982\":1}}],[\"都拥有\",{\"1\":{\"974\":1}}],[\"都要使用到这个名字\",{\"1\":{\"922\":1}}],[\"都要进入队列等待唤醒\",{\"1\":{\"258\":1}}],[\"都与原始\",{\"1\":{\"828\":1}}],[\"都将启用事务功能\",{\"1\":{\"721\":1}}],[\"都将无法再获取互斥锁\",{\"1\":{\"252\":1}}],[\"都实现了\",{\"1\":{\"528\":1,\"825\":1}}],[\"都由它的实现类提供\",{\"1\":{\"449\":1}}],[\"都返回\",{\"1\":{\"436\":1}}],[\"都有可能会阻塞redis\",{\"1\":{\"430\":1}}],[\"都毫无例外地建立在离散分配存储管理方式的基础上\",{\"1\":{\"419\":1}}],[\"都能保证数据的唯一性\",{\"1\":{\"326\":1}}],[\"都不存在订单\",{\"1\":{\"998\":1}}],[\"都不能被实例化\",{\"1\":{\"317\":1}}],[\"都不允许出现任何大写字母\",{\"1\":{\"265\":1}}],[\"都会同步给其他的tomcat服务器的session\",{\"1\":{\"963\":1}}],[\"都会将用户信息保存到session中\",{\"1\":{\"959\":1}}],[\"都会触发\",{\"1\":{\"883\":1}}],[\"都会清除\",{\"1\":{\"854\":1}}],[\"都会跳过\",{\"1\":{\"791\":1}}],[\"都会产生一个新的bean\",{\"1\":{\"710\":1}}],[\"都会有问题\",{\"1\":{\"496\":1}}],[\"都会让我这个南邮学子引以为傲\",{\"1\":{\"304\":1,\"305\":1}}],[\"都会一同结束\",{\"1\":{\"207\":1}}],[\"都进行update\",{\"1\":{\"268\":1}}],[\"都需要有一个线程对当前端口号进行监听\",{\"1\":{\"961\":1}}],[\"都需要一个\",{\"1\":{\"893\":1}}],[\"都需要记录可能被切分的消息\",{\"1\":{\"891\":1}}],[\"都需要内核的拷贝动作\",{\"1\":{\"410\":1}}],[\"都需要全程加锁\",{\"1\":{\"260\":1}}],[\"都需要经过cpu\",{\"1\":{\"181\":1}}],[\"都需要增加一个具体类和对象实现工厂\",{\"1\":{\"58\":1}}],[\"都是常用命令\",{\"1\":{\"1025\":1}}],[\"都是先从获得当前用户的线程\",{\"1\":{\"961\":1}}],[\"都是触发出站处理器的执行\",{\"1\":{\"816\":1}}],[\"都是推迟其它\",{\"1\":{\"503\":1}}],[\"都是它来实现\",{\"1\":{\"451\":1}}],[\"都是\",{\"1\":{\"446\":1}}],[\"都是对结果进行count\",{\"1\":{\"387\":1}}],[\"都是不安全的\",{\"1\":{\"277\":1}}],[\"都是以处理二进制的方式来处理\",{\"1\":{\"277\":1}}],[\"都是以块为单位进行的\",{\"1\":{\"169\":1}}],[\"都是基于node数组+链表+红黑树\",{\"1\":{\"249\":1}}],[\"都是java\",{\"1\":{\"208\":1}}],[\"都是thread类的方法\",{\"1\":{\"202\":1}}],[\"都是进程无法顺利向前推进的现象\",{\"1\":{\"147\":1}}],[\"都是咖啡\",{\"1\":{\"74\":1}}],[\"都无法向前推进的现象\",{\"1\":{\"147\":1}}],[\"都可以使用的指令\",{\"1\":{\"1024\":1}}],[\"都可以\",{\"1\":{\"754\":1}}],[\"都可以写成活的\",{\"1\":{\"568\":1}}],[\"都可以有默认的实现方法\",{\"1\":{\"317\":1}}],[\"都可以包含抽象方法\",{\"1\":{\"317\":1}}],[\"都可\",{\"1\":{\"139\":1}}],[\"都可称为wrapper模式\",{\"1\":{\"45\":1}}],[\"都必须通过系统调用的方式向操作系统提出服务请求\",{\"1\":{\"130\":1}}],[\"每天使用一个key\",{\"1\":{\"993\":1}}],[\"每台服务器中都有完整的一份session数据\",{\"1\":{\"963\":1}}],[\"每位工人有任务队列\",{\"1\":{\"837\":1}}],[\"每隔一段时间就检查这段时间内是否接收到客户端数据\",{\"1\":{\"764\":1}}],[\"每隔一段时间抽取一批key执行删除过期key操作\",{\"1\":{\"427\":1}}],[\"每发送一个段就需要进行一次确认应答\",{\"1\":{\"751\":1}}],[\"每一张表都有严格的约束信息\",{\"1\":{\"1004\":1}}],[\"每一份就称之为分片\",{\"1\":{\"927\":1}}],[\"每一条消息分为\",{\"1\":{\"752\":1}}],[\"每一条消息采用分隔符\",{\"1\":{\"752\":1}}],[\"每一条消息采用固定长度\",{\"1\":{\"752\":1}}],[\"每一次http请求\",{\"1\":{\"710\":1}}],[\"每一个索引还要占一定的物理空间\",{\"1\":{\"375\":1}}],[\"每一个表也必然有一个与之对应\",{\"1\":{\"268\":1}}],[\"每秒可生成百万个不重复\",{\"1\":{\"442\":1}}],[\"每份数据分片会存储在多个互为主从的多节点上\",{\"1\":{\"434\":1}}],[\"每段可定义一组相对完整的信息\",{\"1\":{\"413\":1}}],[\"每段从0开始编程\",{\"1\":{\"159\":1}}],[\"每行数据的隐藏列中包含了指向undo\",{\"1\":{\"393\":1}}],[\"每种存储引擎的索引都不一定完全相同\",{\"1\":{\"375\":1}}],[\"每跨越一个磁道耗时为m\",{\"1\":{\"176\":1}}],[\"每五位就与01001进行异或操作\",{\"1\":{\"173\":1}}],[\"每条记录又由若干个数据项组成\",{\"1\":{\"167\":1}}],[\"每当要访问的页面不在内存时\",{\"1\":{\"162\":1}}],[\"每当有进程加入的时候\",{\"1\":{\"139\":1}}],[\"每次操作数据会对版本号+1\",{\"1\":{\"996\":1}}],[\"每次更新数据库都更新缓存\",{\"1\":{\"982\":1}}],[\"每次一个字节\",{\"1\":{\"824\":1}}],[\"每次请求都会创建一个新的bean实例\",{\"1\":{\"710\":1}}],[\"每次请求用到此\",{\"1\":{\"496\":1}}],[\"每次使用时创建\",{\"1\":{\"496\":1,\"710\":1}}],[\"每次生成\",{\"1\":{\"442\":1}}],[\"每次\",{\"1\":{\"356\":1}}],[\"每次add操作都会对比add后的长度值与数组原有的长度值\",{\"1\":{\"323\":1}}],[\"每次谈到这点\",{\"1\":{\"304\":1,\"305\":1}}],[\"每次只允许一个线程独占\",{\"1\":{\"252\":1}}],[\"每次中断只能传输一个字\",{\"1\":{\"181\":1}}],[\"每次i\",{\"1\":{\"181\":1}}],[\"每次读操作都会生成一个readview所以会出现不可重复读的情况\",{\"1\":{\"393\":1}}],[\"每次读写缓冲区数据都会改变该值\",{\"1\":{\"332\":1}}],[\"每次读\",{\"1\":{\"181\":3}}],[\"每次淘汰的页面是最近最久未使用的页面\",{\"1\":{\"163\":1}}],[\"每次选择淘汰的页面是最早进入内存的页面\",{\"1\":{\"163\":1}}],[\"每次选择淘汰的页面将是以后永不使用\",{\"1\":{\"163\":1}}],[\"每次分配内存时从上次查找结束的位置开始查找空闲分区\",{\"1\":{\"155\":1}}],[\"每次分配内存时顺序查找空闲分区链或空闲分区表\",{\"1\":{\"155\":3}}],[\"每次查找从上次使用地址的下一个开始\",{\"1\":{\"155\":1}}],[\"每次都选最大的分区\",{\"1\":{\"155\":1}}],[\"每次都选最小的分区\",{\"1\":{\"155\":1}}],[\"每次从低地址开始查找\",{\"1\":{\"155\":1}}],[\"每次仅允许一个进程在管程内执行某个内部过程\",{\"1\":{\"145\":1}}],[\"每次调度时选中最短的作业\",{\"1\":{\"139\":1}}],[\"每次增加一个产品时\",{\"1\":{\"58\":1}}],[\"每个命令具备原子性\",{\"1\":{\"1009\":1}}],[\"每个店铺都可以发布优惠券\",{\"1\":{\"992\":1,\"994\":1}}],[\"每个tomcat都有一个属于自己的jvm\",{\"1\":{\"999\":1}}],[\"每个tomcat中都有一份属于自己的session\",{\"1\":{\"963\":1}}],[\"每个thread对象\",{\"1\":{\"247\":1}}],[\"每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的\",{\"1\":{\"961\":1}}],[\"每个用户进程对应m个内核级线程\",{\"1\":{\"135\":1}}],[\"每个索引就有了主分片\",{\"1\":{\"928\":1}}],[\"每个索引可以被分成多个分片\",{\"1\":{\"928\":1}}],[\"每个分片本身也是一个功能完善并且独立的\",{\"1\":{\"927\":1}}],[\"每个分区就是一个页框\",{\"1\":{\"156\":1}}],[\"每个分区的起始部分和末尾部分分别设置前向指针和后向指针\",{\"1\":{\"154\":1}}],[\"每个病人花费\",{\"1\":{\"805\":1}}],[\"每个\",{\"1\":{\"796\":1,\"816\":1,\"825\":2,\"829\":1,\"891\":1,\"893\":1}}],[\"每个消息是\",{\"1\":{\"749\":1}}],[\"每个环绕通知内部继续调用\",{\"1\":{\"552\":1}}],[\"每个会话用到此\",{\"1\":{\"496\":1}}],[\"每个后处理器各自增强什么功能\",{\"1\":{\"470\":1}}],[\"每个节点负责其中一部分槽位\",{\"1\":{\"435\":1}}],[\"每个节点均衡存储一定哈希槽\",{\"1\":{\"434\":1}}],[\"每个redis节点都要开放两个端口号\",{\"1\":{\"434\":1}}],[\"每个块只包含一个进程\",{\"1\":{\"413\":1}}],[\"每个channel对应一个buffer\",{\"1\":{\"332\":1}}],[\"每个请求都需要创建独立的线程\",{\"1\":{\"331\":1}}],[\"每个小文件的大小为2m左右\",{\"1\":{\"290\":1}}],[\"每个词的大小不超过16byte\",{\"1\":{\"289\":1}}],[\"每个红色节点的两个子节点都是黑色\",{\"1\":{\"270\":1}}],[\"每个叶子节点都是黑色的空节点\",{\"1\":{\"270\":1}}],[\"每个线程操作自己的一份数据\",{\"1\":{\"961\":1}}],[\"每个线程配一个选择器\",{\"1\":{\"896\":1}}],[\"每个线程先分配一块tlab\",{\"1\":{\"352\":1}}],[\"每个线程执行到某个需要\",{\"1\":{\"263\":1}}],[\"每个线程需要用共享变量时必须先把共享变量从主存load到自己的工作内存\",{\"1\":{\"230\":1}}],[\"每个线程都有自己的工作内存\",{\"1\":{\"230\":1}}],[\"每个线程都有一个线程id\",{\"1\":{\"135\":1}}],[\"每个线程都会和一个park对象关联起来\",{\"1\":{\"219\":1}}],[\"每个java对象都可以关联一个monitor对象\",{\"1\":{\"211\":1}}],[\"每个设备也会有对应的fcb\",{\"1\":{\"183\":1}}],[\"每个字在i\",{\"1\":{\"181\":1}}],[\"每个字的读\",{\"1\":{\"181\":1}}],[\"每个字的大小为16个二进制位\",{\"1\":{\"151\":1}}],[\"每个控制\",{\"1\":{\"180\":1}}],[\"每个磁道可存n字节的数据\",{\"1\":{\"176\":1}}],[\"每个磁盘上的字节数为n\",{\"1\":{\"176\":1}}],[\"每个盘块中都存有指向下一个盘块的指针\",{\"1\":{\"169\":1}}],[\"每个文件占一个目录项\",{\"1\":{\"168\":1}}],[\"每个记录对应一个索引表项\",{\"1\":{\"167\":1}}],[\"每个段定义了一组逻辑信息\",{\"1\":{\"413\":1}}],[\"每个段表项的长度相等\",{\"1\":{\"160\":1}}],[\"每个段表项由段号\",{\"1\":{\"160\":1}}],[\"每个段对应一个段表项\",{\"1\":{\"159\":1,\"160\":1}}],[\"每个段在内存中占据连续空间\",{\"1\":{\"159\":1}}],[\"每个段都有一个段名\",{\"1\":{\"159\":1}}],[\"每个页和段中的内存是连续的\",{\"1\":{\"413\":1}}],[\"每个页表项长度相等\",{\"1\":{\"160\":1}}],[\"每个页表项由页号\",{\"1\":{\"160\":1}}],[\"每个页面对应一个页表项\",{\"1\":{\"160\":1}}],[\"每个页面也有一个编号\",{\"1\":{\"156\":1}}],[\"每个页框有一个编号\",{\"1\":{\"156\":1}}],[\"每个空闲分区都用相同的概率被使用\",{\"1\":{\"155\":1}}],[\"每个空闲分区对应一个表项\",{\"1\":{\"154\":1}}],[\"每个表项对应一个分区\",{\"1\":{\"154\":1}}],[\"每个单元对应一个存储单元\",{\"1\":{\"151\":1}}],[\"每个进程在进入临界区之前先检查当前有没有别的进程进入临界区\",{\"1\":{\"141\":1}}],[\"每个进程访问临界资源的权限只能被另一个进程赋予\",{\"1\":{\"141\":1}}],[\"每个进程配置一个pcb\",{\"1\":{\"131\":1}}],[\"每个作业\",{\"1\":{\"139\":1}}],[\"每个作业只调入一次\",{\"1\":{\"136\":1}}],[\"每个特征的grid\",{\"1\":{\"24\":1}}],[\"每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类\",{\"1\":{\"70\":1}}],[\"屏蔽产品的具体实现\",{\"1\":{\"58\":1}}],[\"意味着可以链式调用\",{\"1\":{\"822\":1}}],[\"意味着不等连接建立\",{\"1\":{\"803\":1}}],[\"意味着什么\",{\"1\":{\"731\":1}}],[\"意味着系统中只有\",{\"1\":{\"172\":1}}],[\"意向排他锁\",{\"1\":{\"400\":4}}],[\"意向共享锁\",{\"1\":{\"400\":4}}],[\"意向锁\",{\"1\":{\"400\":1}}],[\"意思是没有复制\",{\"1\":{\"928\":1}}],[\"意思是指字符串的结束\",{\"1\":{\"276\":1}}],[\"意思是互斥锁可以降级为共享锁\",{\"1\":{\"252\":1}}],[\"意大利风味甜点工厂\",{\"1\":{\"74\":1}}],[\"意图\",{\"1\":{\"58\":1}}],[\"意在通过一步一步地精确构造创建出一个复杂的对象\",{\"1\":{\"54\":1}}],[\"双击即可运行\",{\"1\":{\"1020\":1}}],[\"双向通信\",{\"0\":{\"843\":1}}],[\"双向的\",{\"1\":{\"332\":1}}],[\"双方唇枪舌战\",{\"1\":{\"766\":1}}],[\"双方签订了一纸协议\",{\"1\":{\"766\":1}}],[\"双亲委派机制\",{\"0\":{\"345\":1}}],[\"双缓冲在通信时的区别\",{\"1\":{\"186\":1}}],[\"双缓冲\",{\"1\":{\"186\":1}}],[\"双标志发虽然解决了忙则等待的问题\",{\"1\":{\"141\":1}}],[\"双标志后检查法\",{\"1\":{\"141\":1}}],[\"双标志先检查法\",{\"1\":{\"141\":1}}],[\"双重检查方式\",{\"1\":{\"101\":2}}],[\"双重检查锁模式是一种非常好的单例实现模式\",{\"1\":{\"101\":1}}],[\"双重检查锁模式\",{\"1\":{\"101\":1}}],[\"双重检查锁\",{\"1\":{\"101\":1}}],[\"双重校验锁\",{\"1\":{\"57\":1}}],[\"双肩背包\",{\"1\":{\"33\":1}}],[\"饿汉式\",{\"1\":{\"57\":1,\"101\":4}}],[\"|world\",{\"1\":{\"886\":1}}],[\"|wangwu\",{\"1\":{\"798\":2}}],[\"|five\",{\"1\":{\"858\":1}}],[\"|four\",{\"1\":{\"858\":1}}],[\"|ff\",{\"1\":{\"755\":1,\"756\":1}}],[\"|fffffffffffff\",{\"1\":{\"756\":1}}],[\"|ffff\",{\"1\":{\"754\":1}}],[\"|three\",{\"1\":{\"857\":1}}],[\"|two\",{\"1\":{\"857\":1}}],[\"|one\",{\"1\":{\"857\":1}}],[\"|lisi\",{\"1\":{\"798\":2}}],[\"|zhangsan\",{\"1\":{\"798\":2}}],[\"|j\",{\"1\":{\"756\":1}}],[\"|jjjjjjjjj\",{\"1\":{\"756\":1}}],[\"|jjjjjjjjjjj\",{\"1\":{\"755\":2}}],[\"|jjjj\",{\"1\":{\"754\":1}}],[\"|eeee\",{\"1\":{\"756\":1}}],[\"|eeeeeeeeeeeeeee\",{\"1\":{\"756\":1}}],[\"|eeeeeeeeee\",{\"1\":{\"755\":1}}],[\"|eeeeeee\",{\"1\":{\"755\":1}}],[\"|gg\",{\"1\":{\"755\":1,\"756\":1}}],[\"|ggggggg\",{\"1\":{\"755\":1}}],[\"|ggg\",{\"1\":{\"754\":2}}],[\"|a\",{\"1\":{\"755\":2,\"907\":1}}],[\"|aaaaaaaaa\",{\"1\":{\"756\":1}}],[\"|aaaa\",{\"1\":{\"754\":2}}],[\"|hello\",{\"1\":{\"886\":1,\"898\":1}}],[\"|hh\",{\"1\":{\"756\":1}}],[\"|hhhh\",{\"1\":{\"755\":1}}],[\"|h\",{\"1\":{\"754\":1}}],[\"|dddddddd\",{\"1\":{\"756\":1}}],[\"|dddd\",{\"1\":{\"756\":1}}],[\"|dd\",{\"1\":{\"755\":1}}],[\"|d\",{\"1\":{\"754\":1}}],[\"|bbbbbbbbb\",{\"1\":{\"756\":1}}],[\"|bbbb\",{\"1\":{\"756\":1}}],[\"|bbb\",{\"1\":{\"755\":1}}],[\"|b\",{\"1\":{\"754\":1}}],[\"|iiiiiiiiiiiiii\",{\"1\":{\"756\":1}}],[\"|iiiiiii\",{\"1\":{\"755\":1,\"756\":1}}],[\"|iiiii\",{\"1\":{\"754\":2}}],[\"|cccccc\",{\"1\":{\"756\":1}}],[\"|ccc\",{\"1\":{\"755\":1}}],[\"|cc\",{\"1\":{\"754\":2}}],[\"|00000090|\",{\"1\":{\"749\":1}}],[\"|00000080|\",{\"1\":{\"749\":1,\"750\":1}}],[\"|00000070|\",{\"1\":{\"749\":1,\"750\":1}}],[\"|00000060|\",{\"1\":{\"749\":1,\"750\":1,\"756\":1}}],[\"|00000050|\",{\"1\":{\"749\":1,\"750\":1,\"756\":1}}],[\"|00000040|\",{\"1\":{\"749\":1,\"750\":1,\"754\":1,\"756\":1}}],[\"|00000030|\",{\"1\":{\"749\":1,\"750\":1,\"754\":1,\"755\":1,\"756\":1}}],[\"|00000020|\",{\"1\":{\"749\":1,\"750\":1,\"754\":1,\"755\":1,\"756\":1}}],[\"|00000010|\",{\"1\":{\"749\":1,\"750\":2,\"754\":1,\"755\":1,\"756\":1}}],[\"|00000000|\",{\"1\":{\"749\":1,\"750\":2,\"754\":11,\"755\":11,\"756\":11,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":6,\"829\":4,\"830\":2,\"855\":2,\"857\":3,\"858\":2,\"886\":2,\"898\":1,\"907\":1}}],[\"||\",{\"1\":{\"123\":2,\"249\":7,\"282\":3,\"441\":2,\"773\":1,\"790\":2,\"792\":5,\"793\":1,\"794\":1,\"849\":1,\"960\":1,\"968\":1}}],[\"|\",{\"1\":{\"57\":1,\"94\":4,\"263\":4,\"275\":1,\"278\":1,\"366\":4,\"441\":3,\"515\":2,\"647\":5,\"738\":1,\"749\":22,\"750\":26,\"754\":39,\"755\":34,\"756\":34,\"773\":1,\"783\":3,\"790\":1,\"792\":1,\"793\":1,\"798\":18,\"822\":10,\"823\":4,\"824\":12,\"826\":24,\"829\":16,\"830\":8,\"849\":12,\"855\":8,\"857\":9,\"858\":6,\"871\":4,\"886\":6,\"893\":1,\"898\":3,\"907\":3,\"993\":1}}],[\"那会由监听线程创建socket连接\",{\"1\":{\"961\":1}}],[\"那样不是也可以吗\",{\"1\":{\"805\":1}}],[\"那为什么还要使用b+树索引呢\",{\"0\":{\"381\":1}}],[\"那当offset特别大的时候\",{\"1\":{\"266\":1}}],[\"那就会冲突了\",{\"1\":{\"1026\":1}}],[\"那就从\",{\"1\":{\"194\":1}}],[\"那就是充分必要条件了\",{\"1\":{\"147\":1}}],[\"那就心甘情愿\",{\"1\":{\"37\":2}}],[\"那么此时查询出来就是\",{\"1\":{\"1024\":1}}],[\"那么此时就是安全的\",{\"1\":{\"997\":1}}],[\"那么假设在服务器a的tomcat内部\",{\"1\":{\"999\":1}}],[\"那么假设我们每次操作数据库后\",{\"1\":{\"982\":1}}],[\"那么第一个线程在操作后\",{\"1\":{\"996\":1}}],[\"那么什么时候countdownlatch\",{\"1\":{\"993\":1}}],[\"那么什么时候main线程不再阻塞呢\",{\"1\":{\"993\":1}}],[\"那么什么时候赋值的呢\",{\"1\":{\"101\":1}}],[\"那么由于程序是异步的\",{\"1\":{\"993\":1}}],[\"那么其他线程会进行阻塞\",{\"1\":{\"987\":1}}],[\"那么线程2就可以进行到休眠\",{\"1\":{\"987\":1}}],[\"那么线程1就会一个人去执行逻辑\",{\"1\":{\"987\":1}}],[\"那么这两个线程都会去扣减库存\",{\"1\":{\"996\":1}}],[\"那么这些线程都不能从缓存中查询到数据\",{\"1\":{\"987\":1}}],[\"那么这个更新动作实际上只有最后一次生效\",{\"1\":{\"982\":1}}],[\"那么这个拦截器就不会生效\",{\"1\":{\"970\":1}}],[\"那么这个循环会持续很久才结束\",{\"1\":{\"436\":1}}],[\"那么这个外部对象是不能被回收的\",{\"1\":{\"358\":1}}],[\"那么这个元素一定不在\",{\"1\":{\"273\":1}}],[\"那么这个线程就回到新的链表中get\",{\"1\":{\"249\":1}}],[\"那么到底使用哪种结构呢\",{\"1\":{\"965\":1}}],[\"那么在可视化界面中\",{\"1\":{\"1026\":1}}],[\"那么在redis中也能找到这个数据就不会进入到缓存了\",{\"1\":{\"984\":1}}],[\"那么在第二台服务器上\",{\"1\":{\"963\":1}}],[\"那么在双亲委派模式下\",{\"1\":{\"352\":1}}],[\"那么也必须\",{\"1\":{\"825\":1}}],[\"那么也就失去实现虚拟性的意义\",{\"1\":{\"127\":1}}],[\"那么便无须再传递\",{\"1\":{\"825\":1}}],[\"那么任务就会等到下次\",{\"1\":{\"792\":1}}],[\"那么必须加以区分\",{\"1\":{\"766\":1}}],[\"那么事务只会在遇到runtimeexception的时候才会回滚\",{\"1\":{\"722\":1}}],[\"那么spring\",{\"1\":{\"706\":1}}],[\"那么以自己添加的为准\",{\"1\":{\"659\":1}}],[\"那么最终也会走到\",{\"1\":{\"617\":1}}],[\"那么它们的执行顺序是\",{\"1\":{\"495\":1}}],[\"那么它并不会block用户进程\",{\"1\":{\"409\":1}}],[\"那么可将减少的位数补充给机器码用\",{\"1\":{\"443\":1}}],[\"那么可用减少时间戳占用的位数\",{\"1\":{\"443\":1}}],[\"那么可以让不同表初始化一个不同的初始值\",{\"1\":{\"439\":1}}],[\"那么可以在这些列上建立\",{\"1\":{\"383\":1}}],[\"那么可以关闭这个流\",{\"1\":{\"291\":1}}],[\"那么可以使用消息队列\",{\"1\":{\"217\":1}}],[\"那么如果是\",{\"1\":{\"617\":1}}],[\"那么如果有人问\",{\"1\":{\"361\":1}}],[\"那么如何保证水平分表后的多张表中的\",{\"1\":{\"439\":1}}],[\"那么问题会更严重\",{\"1\":{\"436\":1}}],[\"那么哨兵负责发送消息作为报警通知给管理员\",{\"1\":{\"433\":1}}],[\"那么epoll的效率并不会比select\",{\"1\":{\"410\":1}}],[\"那么整个进程会被block\",{\"1\":{\"409\":1}}],[\"那么他们的锁对象是同一个\",{\"1\":{\"999\":1}}],[\"那么他们就会同一时刻来访问查询缓存\",{\"1\":{\"987\":1}}],[\"那么他马上就将数据拷贝到了用户内存\",{\"1\":{\"409\":1}}],[\"那么他是线程安全的\",{\"1\":{\"349\":1}}],[\"那么之前已经执行成功的sql语句也必须撤销\",{\"1\":{\"396\":1}}],[\"那么对这个字段创建索引\",{\"1\":{\"383\":1}}],[\"那么盘块所能容纳的关键字数量也越多\",{\"1\":{\"378\":1}}],[\"那么会选择先进行数组扩容\",{\"1\":{\"327\":1}}],[\"那么会在队列中再往后判断下一个节点的线程时候占有的是共享锁\",{\"1\":{\"253\":1}}],[\"那么我们可以添加一个拦截器\",{\"1\":{\"971\":1}}],[\"那么我们服务获取到的数据就是\",{\"1\":{\"731\":1}}],[\"那么我们只能停留在普通工人的层面\",{\"1\":{\"305\":1}}],[\"那么我们如何进行修改呢\",{\"1\":{\"110\":1}}],[\"那么放在堆中\",{\"1\":{\"291\":1}}],[\"那么上一个单词及其频率如果大于堆顶的词的频率\",{\"1\":{\"291\":1}}],[\"那么将这个输入流再一次添加到栈中\",{\"1\":{\"291\":1}}],[\"那么\",{\"1\":{\"279\":2,\"280\":2,\"825\":1}}],[\"那么获取字符串长度的时候\",{\"1\":{\"277\":1}}],[\"那么说明这个值在布隆过滤器中\",{\"1\":{\"273\":2}}],[\"那么成绩表中的student\",{\"1\":{\"267\":1}}],[\"那么即使另一列有不同的值\",{\"1\":{\"267\":1}}],[\"那么即使a的区分度更高\",{\"1\":{\"266\":1}}],[\"那么只需要单建idx\",{\"1\":{\"266\":1}}],[\"那么索引有序性无法利用\",{\"1\":{\"266\":1}}],[\"那么无法使用此索引\",{\"1\":{\"266\":1}}],[\"那么后面公平锁和非公平锁是一样的\",{\"1\":{\"258\":1}}],[\"那么就意味着操作过程中没有人对他进行过修改\",{\"1\":{\"996\":1}}],[\"那么就能够避免这个尴尬的问题了\",{\"1\":{\"962\":1}}],[\"那么就能防止前面提到的误判\",{\"1\":{\"764\":1}}],[\"那么就直接调用\",{\"1\":{\"799\":1}}],[\"那么就直接获取到锁返回了\",{\"1\":{\"258\":1}}],[\"那么就会解析错误\",{\"1\":{\"755\":1}}],[\"那么就要通过spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中\",{\"1\":{\"720\":1}}],[\"那么就使用新的时间戳\",{\"1\":{\"441\":1}}],[\"那么就需要给这个字段创建索引了\",{\"1\":{\"383\":1}}],[\"那么就可以让垃圾收集线程和应用程序线程交替执行\",{\"1\":{\"356\":1}}],[\"那么就不应当发生直接的相互调用\",{\"1\":{\"111\":1}}],[\"那么下次poll时会再次报告该fd\",{\"1\":{\"410\":1}}],[\"那么下面就看一看这些方法是\",{\"1\":{\"236\":1}}],[\"那么下一局也出一样的手势\",{\"1\":{\"116\":1}}],[\"那么自己的cas就算失败\",{\"1\":{\"233\":1}}],[\"那么当前线程就可以不用进行上下文切换\",{\"1\":{\"212\":1}}],[\"那么当它被杀死后就再也没有机会释放锁\",{\"1\":{\"206\":1}}],[\"那么变量是安全的\",{\"1\":{\"209\":1}}],[\"那么不能保证让当前线程暂停的效果\",{\"1\":{\"203\":1}}],[\"那么不久后这条指令很有可能再次执行\",{\"1\":{\"161\":1}}],[\"那么一个磁盘块是装不下文件的整张索引表的\",{\"1\":{\"169\":1}}],[\"那么建造者模式就是一个汽车组装工厂\",{\"1\":{\"55\":1}}],[\"只剩下一个了\",{\"1\":{\"1024\":1}}],[\"只会将一些\",{\"1\":{\"905\":1}}],[\"只会产生少量的页内碎片\",{\"1\":{\"160\":1}}],[\"只发生了一次用户态与内核态的切换\",{\"1\":{\"905\":1}}],[\"只发消息\",{\"1\":{\"785\":1}}],[\"只关注\",{\"1\":{\"890\":1}}],[\"只关心什么产品由什么工厂生产即可\",{\"1\":{\"55\":1}}],[\"只适合连接数少的场景\",{\"1\":{\"914\":1}}],[\"只适合短连接\",{\"1\":{\"876\":1}}],[\"只适用于操作系统内核进程\",{\"1\":{\"142\":1}}],[\"只作为两个线程间传递结果的容器\",{\"1\":{\"806\":1}}],[\"只负责\",{\"1\":{\"798\":4}}],[\"只负责保证对象各部分完整创建或按某种顺序创建\",{\"1\":{\"48\":1}}],[\"只为添加\",{\"1\":{\"790\":1}}],[\"只不过写入前会把object序列化为字节形式\",{\"1\":{\"1041\":1}}],[\"只不过在没有元素时等待指定时间\",{\"1\":{\"1028\":1}}],[\"只不过这\",{\"1\":{\"516\":1}}],[\"只不过process是被select这个函数block\",{\"1\":{\"409\":1}}],[\"只将当前需要的部分页表项调入内存\",{\"1\":{\"413\":1}}],[\"只对外暴露了\",{\"1\":{\"244\":1}}],[\"只依赖于第\",{\"1\":{\"194\":1}}],[\"只读\",{\"1\":{\"183\":1}}],[\"只支持顺序访问\",{\"1\":{\"169\":1}}],[\"只需等\",{\"1\":{\"825\":1}}],[\"只需检查页的访问位\",{\"1\":{\"163\":1}}],[\"只需要拷贝对应的命令哦~\",{\"1\":{\"1024\":1}}],[\"只需要加入以下依赖即可\",{\"1\":{\"679\":1}}],[\"只需要将程序的一部分装入内存\",{\"1\":{\"419\":1}}],[\"只需要在service中将查询出来的role封装到user实体类中即可\",{\"1\":{\"366\":1}}],[\"只需要返回这个成员变量值就行\",{\"1\":{\"277\":1}}],[\"只需要对给定字符串再次进行相同的哈希计算\",{\"1\":{\"273\":1}}],[\"只需要访问作业的一小部分数据即可正常运行\",{\"1\":{\"161\":1}}],[\"只需要让各个进程的段表项执行同一个段即可实现共享\",{\"1\":{\"159\":1}}],[\"只需要根据需求重新派生一个实现类来扩展就可以了\",{\"1\":{\"107\":1}}],[\"只需要使用\",{\"1\":{\"101\":1}}],[\"只需要再加一个对应的工厂类即可\",{\"1\":{\"74\":1}}],[\"只是读写指针是独立的\",{\"1\":{\"827\":1}}],[\"只是\",{\"1\":{\"812\":1}}],[\"只是为了触发\",{\"1\":{\"790\":1,\"793\":1}}],[\"只是语义不同\",{\"1\":{\"709\":1}}],[\"只是用\",{\"1\":{\"671\":1}}],[\"只是统计行数\",{\"1\":{\"387\":1}}],[\"只是给出一个warning信息\",{\"1\":{\"362\":1}}],[\"只是老年代的垃圾收集\",{\"1\":{\"350\":1}}],[\"只是新生代的垃圾收集\",{\"1\":{\"350\":1}}],[\"只是获取资源\",{\"1\":{\"314\":1}}],[\"只是在逻辑上进行了扩充\",{\"1\":{\"161\":1}}],[\"只是定义了与算法相关的接口\",{\"1\":{\"114\":1}}],[\"只允许进程主动放弃处理机\",{\"1\":{\"137\":1}}],[\"只能实现基本的一致性\",{\"1\":{\"1007\":1}}],[\"只能一个人一个人的来访问数据库\",{\"1\":{\"987\":1}}],[\"只能一气呵成\",{\"1\":{\"142\":1}}],[\"只能有一种type\",{\"1\":{\"923\":1}}],[\"只能写\",{\"1\":{\"863\":1}}],[\"只能工作在阻塞模式下\",{\"1\":{\"862\":1}}],[\"只能同步等待任务结束\",{\"1\":{\"806\":1}}],[\"只能先发送前\",{\"1\":{\"751\":1}}],[\"只能通过\",{\"1\":{\"713\":1}}],[\"只能通过反射获得\",{\"1\":{\"235\":1}}],[\"只能处理发生在\",{\"1\":{\"617\":1}}],[\"只能保证redis集群的高可用性\",{\"1\":{\"433\":1}}],[\"只能保证看到最新值\",{\"1\":{\"228\":1}}],[\"只能使用$\",{\"1\":{\"366\":1}}],[\"只能调用空参的构造器\",{\"1\":{\"351\":1}}],[\"只能逐个查找\",{\"1\":{\"279\":1}}],[\"只能读\",{\"1\":{\"181\":1,\"863\":1}}],[\"只能用于单用户\",{\"1\":{\"154\":1}}],[\"只能主动释放\",{\"1\":{\"147\":1}}],[\"只能被管程中定义的过程访问\",{\"1\":{\"145\":1}}],[\"只能进程间并发\",{\"1\":{\"135\":1}}],[\"只能创建一个实例的类\",{\"1\":{\"100\":1}}],[\"只和你的直接朋友交谈\",{\"1\":{\"111\":1}}],[\"只有等到新开的线程2把重建数据构建完后\",{\"1\":{\"987\":1}}],[\"只有一开始\",{\"1\":{\"805\":1}}],[\"只有一个事务能执行写入\",{\"1\":{\"398\":1}}],[\"只有落在窗口内的数据才能允许接收\",{\"1\":{\"751\":1}}],[\"只有innodb支持事务\",{\"1\":{\"723\":1}}],[\"只有活跃的socket才会主动调用callback\",{\"1\":{\"410\":1}}],[\"只有活跃可用的fd才会调用callback函数\",{\"1\":{\"410\":1}}],[\"只有事务中的数据库操作都执行成功\",{\"1\":{\"396\":1}}],[\"只有cms\",{\"1\":{\"350\":1}}],[\"只有所有玩家都加载到100\",{\"1\":{\"262\":1}}],[\"只有当客户端对象需要访问容器中的某个对象时\",{\"1\":{\"707\":1}}],[\"只有当线程取任务时\",{\"1\":{\"244\":1}}],[\"只有当所有非守护线程执行完毕后\",{\"1\":{\"207\":1}}],[\"只有当进行大量调用的时候\",{\"1\":{\"96\":1}}],[\"只有在线的\",{\"1\":{\"758\":1}}],[\"只有在连接真正有读写事件发生时\",{\"1\":{\"332\":1}}],[\"只有在cpu比较忙的时候\",{\"1\":{\"205\":1}}],[\"只有在进程执行的过程中才能知道接下来会访问的是哪个页面\",{\"1\":{\"163\":1}}],[\"只有被淘汰的页面被修改过时\",{\"1\":{\"163\":1}}],[\"只有对必须互斥使用的资源的争抢才会导致死锁\",{\"1\":{\"147\":1}}],[\"只有第一次读操作会生成readview\",{\"1\":{\"393\":1}}],[\"只有第一次调用getinstance\",{\"1\":{\"101\":1}}],[\"只有第k级队列为空时\",{\"1\":{\"139\":1}}],[\"只有调入的时机是由操作系统来确定\",{\"1\":{\"136\":1}}],[\"只有系统拥有并发性\",{\"1\":{\"127\":1}}],[\"只有这些配置都有了\",{\"1\":{\"109\":1}}],[\"只有内部类的属性\",{\"1\":{\"101\":1}}],[\"只暴露给本地服务一个接口\",{\"1\":{\"98\":1}}],[\"只定义了trainstation\",{\"1\":{\"95\":1}}],[\"只要我扣减库存时的库存和之前我查询到的库存是一样的\",{\"1\":{\"997\":1}}],[\"只要哈希思想\",{\"1\":{\"984\":1}}],[\"只要线程不一样\",{\"1\":{\"961\":1}}],[\"只要向\",{\"1\":{\"894\":1}}],[\"只要调用\",{\"1\":{\"854\":1}}],[\"只要分别采用读线程和写线程即可\",{\"1\":{\"845\":1}}],[\"只要这个时间间隔小于服务器定义的空闲检测的时间间隔\",{\"1\":{\"764\":1}}],[\"只要返回集合不空\",{\"1\":{\"539\":1}}],[\"只要其中有一个是变量\",{\"1\":{\"354\":1}}],[\"只要节点数量足够小\",{\"1\":{\"281\":1}}],[\"只要没有唯一索引\",{\"1\":{\"266\":1}}],[\"只要有可能\",{\"1\":{\"389\":1}}],[\"只要有一个线程占有了共享锁\",{\"1\":{\"252\":1}}],[\"只要有其他线程\",{\"1\":{\"233\":1}}],[\"只要成功地通过cas操作将state的值从0变为1就获取了锁\",{\"1\":{\"252\":1}}],[\"只要能找到一个安全序列\",{\"1\":{\"149\":1}}],[\"只要抽象不变\",{\"1\":{\"109\":1}}],[\"只要抽象的合理\",{\"1\":{\"107\":1}}],[\"只要扩展一个工厂类就可以\",{\"1\":{\"58\":1}}],[\"只要知道其名称就可以了\",{\"1\":{\"58\":1}}],[\"具备校验与获取校验结果功能\",{\"1\":{\"576\":1}}],[\"具有幂等性\",{\"1\":{\"314\":1}}],[\"具有更好的hash性\",{\"1\":{\"249\":1}}],[\"具有相同编号的磁道形成的圆柱\",{\"1\":{\"175\":1}}],[\"具有对换功能的操作系统中\",{\"1\":{\"153\":1}}],[\"具有不同分类维度的产品组合\",{\"1\":{\"55\":1}}],[\"具体命令\",{\"1\":{\"1029\":1}}],[\"具体操作\",{\"1\":{\"999\":1}}],[\"具体操作逻辑如下\",{\"1\":{\"998\":1}}],[\"具体逻辑上文已经分析\",{\"1\":{\"960\":1}}],[\"具体代码如下\",{\"1\":{\"960\":1}}],[\"具体代码\",{\"1\":{\"825\":1}}],[\"具体池化还是非池化由\",{\"1\":{\"781\":1}}],[\"具体类的样式可以通过阿里巴巴的arthas插件看到\",{\"1\":{\"714\":1}}],[\"具体类的设计如下\",{\"1\":{\"60\":1}}],[\"具体异常信息会由\",{\"1\":{\"617\":1}}],[\"具体数目可以cat\",{\"1\":{\"410\":1}}],[\"具体字段\",{\"0\":{\"387\":1},\"1\":{\"387\":1}}],[\"具体和表的存储引擎相关\",{\"1\":{\"375\":1}}],[\"具体使用哪种方式得看内存是否规整\",{\"1\":{\"352\":1}}],[\"具体实现方式是客户端第一次登陆时输入账号密码以及验证码进行登录\",{\"1\":{\"296\":1}}],[\"具体个数要是需要测试得到\",{\"1\":{\"246\":1}}],[\"具体细节只有设备厂家才知道\",{\"1\":{\"182\":1}}],[\"具体如何读取一个字节数据呢\",{\"1\":{\"123\":1}}],[\"具体子类\",{\"1\":{\"119\":1}}],[\"具体方法是\",{\"1\":{\"290\":1}}],[\"具体方法\",{\"1\":{\"119\":1}}],[\"具体原型复制成功\",{\"1\":{\"86\":1}}],[\"具体原型类\",{\"1\":{\"85\":1}}],[\"具体的相关步骤是\",{\"1\":{\"300\":1}}],[\"具体的实现方式和常驻人口展示类似\",{\"1\":{\"296\":1}}],[\"具体的实现依赖于操作系统的任务调度器\",{\"1\":{\"203\":1}}],[\"具体的排序方式需要依据动态分配算法来确定\",{\"1\":{\"154\":1}}],[\"具体的策略\",{\"1\":{\"115\":1}}],[\"具体的原型对象创建完成\",{\"1\":{\"86\":1}}],[\"具体的原型类\",{\"1\":{\"86\":1}}],[\"具体的观察者\",{\"1\":{\"81\":1}}],[\"具体的观察对象\",{\"1\":{\"81\":1}}],[\"具体的代码如下\",{\"1\":{\"49\":1}}],[\"具体工厂\",{\"1\":{\"62\":1,\"68\":1,\"69\":1,\"73\":1,\"74\":1}}],[\"具体产品\",{\"1\":{\"62\":1,\"68\":1,\"73\":1}}],[\"具体建造者类\",{\"1\":{\"48\":1}}],[\"躯干等部分\",{\"1\":{\"54\":1}}],[\"脚\",{\"1\":{\"54\":1}}],[\"头占用\",{\"1\":{\"751\":2}}],[\"头后剩余能够作为数据传输的字节数\",{\"1\":{\"751\":1}}],[\"头和\",{\"1\":{\"751\":2}}],[\"头判断需要生成哪种\",{\"1\":{\"617\":1}}],[\"头有没有指定\",{\"1\":{\"604\":1}}],[\"头\",{\"1\":{\"54\":1,\"751\":1}}],[\"则是修改\",{\"1\":{\"1027\":1}}],[\"则是新增\",{\"1\":{\"1027\":1}}],[\"则是之前写入的数据\",{\"1\":{\"985\":1}}],[\"则添加成功\",{\"1\":{\"1025\":1}}],[\"则代表中间没有被人修改过\",{\"1\":{\"996\":1}}],[\"则代表自增后的序列号超过了4095\",{\"1\":{\"441\":1}}],[\"则数据被修改过\",{\"1\":{\"996\":1}}],[\"则扣减库存\",{\"1\":{\"995\":1}}],[\"则失眠并重试\",{\"1\":{\"988\":1}}],[\"则插入成功\",{\"1\":{\"988\":1}}],[\"则休眠\",{\"1\":{\"988\":1}}],[\"则查询数据库\",{\"1\":{\"979\":1,\"983\":1}}],[\"则直接返回redis中的数据\",{\"1\":{\"989\":1}}],[\"则直接返回数据\",{\"1\":{\"985\":1}}],[\"则直接返回\",{\"1\":{\"979\":1,\"984\":1}}],[\"则直接从缓存中返回\",{\"1\":{\"978\":1}}],[\"则放行\",{\"1\":{\"972\":1,\"984\":1}}],[\"则根据手机号查询用户信息\",{\"1\":{\"967\":1}}],[\"则他的value中只会存储他数据本身\",{\"1\":{\"965\":1}}],[\"则创建\",{\"1\":{\"960\":1}}],[\"则创建一个事务作为当前事务的嵌套事务来运行\",{\"1\":{\"720\":1}}],[\"则为用户创建账号信息\",{\"1\":{\"959\":1}}],[\"则为进程分配一个空闲块\",{\"1\":{\"162\":1}}],[\"则后台根据手机号查询用户\",{\"1\":{\"959\":1}}],[\"则后续提交的任务都会被丢弃\",{\"1\":{\"243\":1}}],[\"则无法通过校验\",{\"1\":{\"959\":1}}],[\"则用来缓冲读写数据\",{\"1\":{\"911\":1}}],[\"则用cas累加这个域\",{\"1\":{\"234\":1}}],[\"则影响\",{\"1\":{\"890\":1}}],[\"则扩容后\",{\"1\":{\"823\":2}}],[\"则选择下一个\",{\"1\":{\"823\":2}}],[\"则可以将对象序列化为json字符串后存储\",{\"1\":{\"1026\":1}}],[\"则可以重用池中\",{\"1\":{\"820\":1}}],[\"则可能会导致饥饿\",{\"1\":{\"139\":1}}],[\"则每次都得创建新的\",{\"1\":{\"820\":1}}],[\"则每个存储单元大小为1个字\",{\"1\":{\"151\":1}}],[\"则每个存储单元大小为1字节\",{\"1\":{\"151\":1}}],[\"则每个进程都能顺利完成\",{\"1\":{\"149\":1}}],[\"则仅会打印\",{\"1\":{\"816\":4}}],[\"则结束所有流程\",{\"1\":{\"738\":1}}],[\"则web容器将该请求转交给dispatcherservlet处理\",{\"1\":{\"736\":1}}],[\"则抛出异常\",{\"1\":{\"720\":1,\"755\":1}}],[\"则抛出classnotfoundexception异常\",{\"1\":{\"352\":1}}],[\"则以非事务方式继续运行\",{\"1\":{\"720\":1}}],[\"则以自己配置的为准\",{\"1\":{\"662\":1}}],[\"则加入该事务\",{\"1\":{\"720\":2}}],[\"则等价于propagation\",{\"1\":{\"720\":1}}],[\"则把当前事务挂起\",{\"1\":{\"720\":2}}],[\"则新建一个事务\",{\"1\":{\"720\":1}}],[\"则jdk动态代理更合适\",{\"1\":{\"718\":1}}],[\"则要求用户重新输入手机号\",{\"1\":{\"959\":1}}],[\"则要推断使用\",{\"1\":{\"711\":1}}],[\"则要将其写回外存\",{\"1\":{\"162\":1}}],[\"则按集合处理\",{\"1\":{\"688\":1}}],[\"则表示需要创建代理\",{\"1\":{\"539\":1}}],[\"则表示重复操作\",{\"1\":{\"315\":1}}],[\"则序列号重新从0开始\",{\"1\":{\"441\":1}}],[\"则自增后的序列号超过了4095\",{\"1\":{\"441\":1}}],[\"则有可能无限制的命中过期key\",{\"1\":{\"436\":1}}],[\"则有可能产生两次中断\",{\"1\":{\"162\":1}}],[\"则必须修改redis配置文件\",{\"1\":{\"1015\":1}}],[\"则必须事先为作业一次性地申请一个足以容纳整个作业的内存空间\",{\"1\":{\"419\":1}}],[\"则必是线程安全的\",{\"1\":{\"349\":1}}],[\"则还需再次访问内存中的页表\",{\"1\":{\"413\":1}}],[\"则挂起当前线程\",{\"1\":{\"410\":1}}],[\"则从磁盘读取后放入buffer\",{\"1\":{\"396\":1}}],[\"则时间就是单调递增的了\",{\"1\":{\"392\":1}}],[\"则会对cell和base的值进行递增\",{\"1\":{\"997\":1}}],[\"则会从mysql中加载最新的数据\",{\"1\":{\"983\":1}}],[\"则会把引导类范围内\",{\"1\":{\"661\":1}}],[\"则会先删除这个key然后重新选取\",{\"1\":{\"436\":1}}],[\"则会做出主从切换\",{\"1\":{\"433\":1}}],[\"则会与原表名t\",{\"1\":{\"368\":1}}],[\"则会导致内存泄露的产生\",{\"1\":{\"358\":1}}],[\"则resulttype可以设置成map\",{\"1\":{\"366\":1}}],[\"则rr退化为fcfs调度算法\",{\"1\":{\"139\":1}}],[\"则在开启独立线程后直接返回之前的数据\",{\"1\":{\"989\":1}}],[\"则在常量池中创建一份\",{\"1\":{\"354\":1}}],[\"则在选取第n+1个聚类中心时\",{\"1\":{\"300\":1}}],[\"则此数据是共享数据\",{\"1\":{\"349\":1}}],[\"则进一步判断库存是否足够\",{\"1\":{\"995\":1,\"998\":1}}],[\"则进一步向上委托\",{\"1\":{\"345\":1}}],[\"则进行操作成功\",{\"1\":{\"996\":1}}],[\"则进行互斥锁的获取\",{\"1\":{\"988\":1}}],[\"则进行拦截\",{\"1\":{\"959\":1}}],[\"则进行延迟发送\",{\"1\":{\"751\":1}}],[\"则进行封装\",{\"1\":{\"688\":2}}],[\"则进行类加载\",{\"1\":{\"352\":1}}],[\"则进程进入下一级队列队尾\",{\"1\":{\"139\":1}}],[\"则当前线程会一直阻塞在read操作上\",{\"1\":{\"331\":1}}],[\"则当这个类需要修改时\",{\"1\":{\"108\":1}}],[\"则执行下一步\",{\"1\":{\"738\":1}}],[\"则执行业务\",{\"1\":{\"315\":1}}],[\"则执行\",{\"1\":{\"290\":2}}],[\"则继续向下遍历\",{\"1\":{\"282\":2}}],[\"则都是\",{\"1\":{\"277\":1}}],[\"则返回0\",{\"1\":{\"988\":1}}],[\"则返回代理\",{\"1\":{\"688\":1}}],[\"则返回字符串在常量池中的地址\",{\"1\":{\"354\":1}}],[\"则返回一个空流\",{\"1\":{\"338\":1}}],[\"则返回对应的treenode\",{\"1\":{\"249\":1}}],[\"则返回新new出来的对象\",{\"1\":{\"104\":1}}],[\"则通过cas创建链表头节点\",{\"1\":{\"249\":1}}],[\"则线程不安全\",{\"1\":{\"209\":1}}],[\"则线程安全\",{\"1\":{\"209\":2}}],[\"则该变量属于临界资源\",{\"1\":{\"209\":1}}],[\"则不再下单\",{\"1\":{\"998\":1}}],[\"则不久后该数据可能再次被访问\",{\"1\":{\"417\":1}}],[\"则不久后该指令可能再次执行\",{\"1\":{\"417\":1}}],[\"则不会清空打断状态\",{\"1\":{\"204\":1}}],[\"则不适合使用建造者模式\",{\"1\":{\"50\":1}}],[\"则打断标记\",{\"1\":{\"204\":1}}],[\"则即使系统中还有同类型的设备\",{\"1\":{\"185\":1}}],[\"则程序无法运行\",{\"1\":{\"185\":1}}],[\"则\",{\"1\":{\"176\":1,\"279\":1}}],[\"则平均所需的延迟时间$t\",{\"1\":{\"176\":1}}],[\"则访问一个数据块只需要k\",{\"1\":{\"169\":1}}],[\"则一个磁盘块只能存放256个索引项\",{\"1\":{\"169\":1}}],[\"则一个时间段内只有一个程序运行\",{\"1\":{\"127\":1}}],[\"则又是低效的\",{\"1\":{\"164\":1}}],[\"则重新扫描\",{\"1\":{\"163\":3}}],[\"则重新放回该队列队尾\",{\"1\":{\"139\":1}}],[\"则将用户信息保存到threadlocal中\",{\"1\":{\"959\":1}}],[\"则将序列号递增1\",{\"1\":{\"441\":1}}],[\"则将这些页面的访问依次置为0\",{\"1\":{\"163\":1}}],[\"则将它置为0\",{\"1\":{\"163\":1}}],[\"则末尾k位标识页内偏移量\",{\"1\":{\"156\":1}}],[\"则修改对应分区号\",{\"1\":{\"154\":1}}],[\"则c一直不执行\",{\"1\":{\"148\":1}}],[\"则系统不会进入死锁状态\",{\"1\":{\"148\":1}}],[\"则长进程一直无法获得处理机\",{\"1\":{\"147\":1}}],[\"则设置正在访问临界资源的标志\",{\"1\":{\"140\":1}}],[\"则由处理器通知操作系统将相应的页面或段调入到内存\",{\"1\":{\"419\":1}}],[\"则由页面置换算法选择一个页面淘汰\",{\"1\":{\"162\":1}}],[\"则由于新进程处于优先级更高的队列中\",{\"1\":{\"139\":1}}],[\"则由新进程抢占处理机\",{\"1\":{\"139\":1}}],[\"则i\",{\"1\":{\"139\":1}}],[\"则剥夺处理机\",{\"1\":{\"139\":1}}],[\"则立即暂停正在执行的\",{\"1\":{\"137\":1}}],[\"则需要发送\",{\"1\":{\"751\":4}}],[\"则需要向beanfactory添加一些后置处理器来解析这些注解\",{\"1\":{\"708\":1}}],[\"则需要根据readview来确定\",{\"1\":{\"393\":1}}],[\"则需要resultmap来手动指定映射关系\",{\"1\":{\"366\":1}}],[\"则需要设置两个管道\",{\"1\":{\"134\":1}}],[\"则需要保护被中断进程的cpu环境\",{\"1\":{\"129\":1}}],[\"则需要组装手\",{\"1\":{\"54\":1}}],[\"则共享性失去存在的意义\",{\"1\":{\"127\":1}}],[\"某一个产品的一个文档\",{\"1\":{\"924\":1}}],[\"某个字段的数据类型\",{\"1\":{\"926\":1}}],[\"某个字段在\",{\"1\":{\"383\":1}}],[\"某个对象的构建过程复杂的情况\",{\"1\":{\"47\":1}}],[\"某些线程因为优先级太低\",{\"1\":{\"223\":1}}],[\"某些文件属性保存在目录中\",{\"1\":{\"168\":1}}],[\"某些死锁进程\",{\"1\":{\"150\":1}}],[\"某进程在执行的过程中一直跳不出某个循环的现象\",{\"1\":{\"147\":1}}],[\"某进程无法向前推进的现象\",{\"1\":{\"147\":1}}],[\"某种程度上也可以提高开发效率\",{\"1\":{\"52\":1}}],[\"金士顿内存条\",{\"1\":{\"109\":1}}],[\"金士顿\",{\"1\":{\"52\":2}}],[\"即把之前的逻辑再操作一次\",{\"1\":{\"996\":1}}],[\"即初始化器\",{\"1\":{\"793\":1}}],[\"即接收一个客户端连接\",{\"1\":{\"793\":1}}],[\"即首次调用\",{\"1\":{\"791\":1}}],[\"即滑动窗口\",{\"1\":{\"750\":1}}],[\"即数据访问对象\",{\"1\":{\"735\":1}}],[\"即数组中每个元素是字符串中的一个字符\",{\"1\":{\"276\":1}}],[\"即自动实例化正确的事务管理器\",{\"1\":{\"721\":1}}],[\"即调用构造方法前\",{\"1\":{\"711\":1}}],[\"即调用它们的销毁方法\",{\"1\":{\"458\":1}}],[\"即指定了\",{\"1\":{\"660\":1}}],[\"即会匹配到所有请求\",{\"1\":{\"644\":1}}],[\"即只映射\",{\"1\":{\"642\":1}}],[\"即所谓的\",{\"1\":{\"617\":1}}],[\"即是\",{\"1\":{\"590\":1}}],[\"即是哪个\",{\"1\":{\"590\":1}}],[\"即从\",{\"1\":{\"568\":1}}],[\"即对于同一台机器而言\",{\"1\":{\"440\":1}}],[\"即对事务a是否可见\",{\"1\":{\"393\":1}}],[\"即选择最近最久未使用的页面进行淘汰\",{\"1\":{\"420\":1}}],[\"即选择在内存中驻留时间最久的页面进行淘汰\",{\"1\":{\"420\":1}}],[\"即可停止\",{\"1\":{\"1015\":1}}],[\"即可实现导入\",{\"1\":{\"671\":1}}],[\"即可查看效果\",{\"1\":{\"498\":1}}],[\"即可\",{\"1\":{\"440\":1,\"877\":1,\"997\":1}}],[\"即可启动运行\",{\"1\":{\"419\":1}}],[\"即可以容纳的最大数据量\",{\"1\":{\"332\":1}}],[\"即程序在一段时间内所访问的地址可能集中在一定的范围内\",{\"1\":{\"417\":1}}],[\"即通过页号访问页表得到物理块号\",{\"1\":{\"413\":1}}],[\"即通过wrapper类二次封装原始类\",{\"1\":{\"45\":1}}],[\"即epoll使用mmap减少复制开销\",{\"1\":{\"410\":1}}],[\"即epoll最大的优点就在于他只管你\",{\"1\":{\"410\":1}}],[\"即当两个事务互相等待时\",{\"1\":{\"403\":1}}],[\"即btree和hash\",{\"1\":{\"375\":1}}],[\"即提高了吞吐量\",{\"1\":{\"359\":1}}],[\"即4个字节大小\",{\"1\":{\"352\":1}}],[\"即aio\",{\"1\":{\"333\":1}}],[\"即客户端有连接请求时\",{\"1\":{\"331\":1}}],[\"即新节点将成为\",{\"1\":{\"280\":1}}],[\"即不需要手动修改\",{\"1\":{\"277\":1}}],[\"即为要导入的配置类\",{\"1\":{\"670\":1}}],[\"即为视图完整路径\",{\"1\":{\"647\":1}}],[\"即为字符串长度\",{\"1\":{\"276\":1}}],[\"即为级联更新\",{\"1\":{\"267\":1}}],[\"即使没有连接建立\",{\"1\":{\"877\":1}}],[\"即使\",{\"1\":{\"854\":1}}],[\"即使调用了\",{\"1\":{\"825\":1}}],[\"即使发送一个字节\",{\"1\":{\"751\":1}}],[\"即使发生宕机等故障\",{\"1\":{\"396\":1}}],[\"即使发生连锁更新\",{\"1\":{\"281\":1}}],[\"即使部分哨兵节点挂掉了\",{\"1\":{\"433\":1}}],[\"即使是阻塞\",{\"1\":{\"845\":1}}],[\"即使是组合字段\",{\"1\":{\"383\":1}}],[\"即使是多个字段的组合\",{\"1\":{\"266\":1}}],[\"即使一个变量的大小不到\",{\"1\":{\"277\":1}}],[\"即使所有类属性名与数据库字段一一对应\",{\"1\":{\"268\":1}}],[\"即使双表join也要注意表索引\",{\"1\":{\"266\":1}}],[\"即使在应用层做了非常完善的校验控制\",{\"1\":{\"266\":1}}],[\"即使实现细节不断变动\",{\"1\":{\"109\":1}}],[\"即被加锁的内容要按照顺序被多个线程执行\",{\"1\":{\"229\":1}}],[\"即在\",{\"1\":{\"277\":1}}],[\"即在自旋的时候持锁的线程释放了锁\",{\"1\":{\"212\":1}}],[\"即在某进程开始访问临界区到结束访问为止都不允许被中断\",{\"1\":{\"142\":1}}],[\"即寄存器独立编址\",{\"1\":{\"180\":1}}],[\"即引导块\",{\"1\":{\"178\":1}}],[\"即文件分配表\",{\"1\":{\"169\":1}}],[\"即随机访问\",{\"1\":{\"169\":1}}],[\"即每次读入一块\",{\"1\":{\"169\":1}}],[\"即读写可以同时进行\",{\"1\":{\"900\":1}}],[\"即读\",{\"1\":{\"169\":1}}],[\"即最近最久未使用的页面\",{\"1\":{\"163\":1}}],[\"即将页表项中的物理块号与页内偏移地址拼接成实际物理地址后访问实际物理地址所耗费的时间\",{\"1\":{\"413\":1}}],[\"即将进入terminated状态\",{\"1\":{\"241\":1}}],[\"即将进程再细分为很多的线程\",{\"1\":{\"135\":1}}],[\"即将逻辑地址a中的数据复制到逻辑地址b\",{\"1\":{\"162\":1}}],[\"即页号\",{\"1\":{\"156\":1}}],[\"即8个二进制位\",{\"1\":{\"151\":1}}],[\"即1b\",{\"1\":{\"151\":1}}],[\"即必须保证\",{\"1\":{\"144\":1}}],[\"即fcfs算法对长作业有利\",{\"1\":{\"139\":1}}],[\"即\",{\"1\":{\"137\":1,\"141\":1,\"164\":2,\"360\":1,\"441\":1,\"477\":1,\"653\":2,\"655\":1,\"822\":2,\"890\":1,\"904\":1}}],[\"即用户级线程对用户不透明\",{\"1\":{\"135\":1}}],[\"即负责实现具体的策略\",{\"1\":{\"115\":1}}],[\"即产品的构建过程和最终的表示是独立的\",{\"1\":{\"51\":1}}],[\"各有什么优劣\",{\"1\":{\"355\":1}}],[\"各自的优缺点\",{\"1\":{\"355\":3}}],[\"各级页表的大小不能超过一个面\",{\"1\":{\"158\":1}}],[\"各级队列优先级从高到低\",{\"1\":{\"139\":1}}],[\"各表项的顺序不一定按照地址递增的顺序排序\",{\"1\":{\"154\":1}}],[\"各并发执行的进程以各自独立的\",{\"1\":{\"140\":1}}],[\"各作业带权周转时间之和\",{\"1\":{\"138\":1}}],[\"各作业周转时间之和\",{\"1\":{\"138\":1}}],[\"各种数据寄存器等\",{\"1\":{\"137\":1}}],[\"各种gan的keras实现\",{\"1\":{\"14\":1}}],[\"各线程间也能并发\",{\"1\":{\"135\":1}}],[\"各进程往往是宏观上同时共享使用设备\",{\"1\":{\"185\":1}}],[\"各进程并发同时访问可能造成数据不一致\",{\"1\":{\"159\":1}}],[\"各进程因竞争资源而造成的一种互相等待对方手里的资源\",{\"1\":{\"147\":1}}],[\"各进程要互斥的访问管道\",{\"1\":{\"134\":1}}],[\"各进程按各自独立的\",{\"1\":{\"131\":1}}],[\"各进程可以并发的执行\",{\"1\":{\"131\":1}}],[\"各个记录在物理上可以顺序存储或链式存储\",{\"1\":{\"167\":1}}],[\"各个段表项的长度是相同的\",{\"1\":{\"159\":1}}],[\"各个线程可占用不同的cpu\",{\"1\":{\"135\":1}}],[\"各个程序的代码\",{\"1\":{\"131\":1}}],[\"各个配件的接口\",{\"1\":{\"109\":1}}],[\"各部件面临着复杂的变化\",{\"1\":{\"51\":1}}],[\"优惠卷是为了引流\",{\"1\":{\"998\":1}}],[\"优惠卷秒杀\",{\"0\":{\"991\":1}}],[\"优惠券秒杀\",{\"0\":{\"998\":1}}],[\"优惠券的库存\",{\"1\":{\"994\":1}}],[\"优惠券的基本信息\",{\"1\":{\"994\":1}}],[\"优惠金额\",{\"1\":{\"994\":1}}],[\"优势💡\",{\"0\":{\"831\":1}}],[\"优雅关闭\",{\"1\":{\"797\":1}}],[\"优雅关闭💡\",{\"0\":{\"797\":1}}],[\"优化方案\",{\"0\":{\"971\":1}}],[\"优化\",{\"0\":{\"905\":1}}],[\"优化为非反射调用\",{\"1\":{\"519\":1}}],[\"优化重量级锁竞争\",{\"1\":{\"212\":1}}],[\"优先采用\",{\"1\":{\"582\":1}}],[\"优先队列\",{\"1\":{\"242\":1}}],[\"优先级几乎没什么用\",{\"1\":{\"205\":1}}],[\"优先级较高的线程会获得更多的时间片\",{\"1\":{\"205\":1}}],[\"优先级高者优先\",{\"1\":{\"185\":1}}],[\"优先级调度算法\",{\"1\":{\"139\":1}}],[\"优先使用最大的连续空闲区\",{\"1\":{\"155\":1}}],[\"优先使用更小的空闲区\",{\"1\":{\"155\":1}}],[\"优点是避免了拷贝引起的性能损耗\",{\"1\":{\"891\":1}}],[\"优点是消息连续容易处理\",{\"1\":{\"891\":1}}],[\"优点是可以开启延迟加载\",{\"1\":{\"366\":1}}],[\"优点有\",{\"1\":{\"820\":1}}],[\"优点\",{\"1\":{\"50\":1,\"58\":1,\"64\":1,\"70\":1,\"75\":1,\"97\":1,\"121\":1,\"135\":3,\"139\":4,\"142\":3,\"154\":2,\"160\":1,\"169\":3,\"173\":1,\"181\":3,\"345\":1,\"375\":1,\"829\":1,\"984\":2}}],[\"优缺点\",{\"0\":{\"50\":1,\"64\":1,\"70\":1,\"75\":1,\"97\":1,\"121\":1},\"1\":{\"139\":6,\"181\":3,\"355\":1}}],[\"中有两个最重要的方法\",{\"1\":{\"993\":1}}],[\"中有堆外内存的\",{\"1\":{\"825\":1}}],[\"中间的更新动作意义并不大\",{\"1\":{\"982\":1}}],[\"中所有数据都写入\",{\"1\":{\"893\":1}}],[\"中还有上次的\",{\"1\":{\"887\":1}}],[\"中调用\",{\"1\":{\"865\":1}}],[\"中很多方法都是异步的\",{\"1\":{\"835\":1}}],[\"中只有\",{\"1\":{\"793\":1}}],[\"中执行了\",{\"1\":{\"793\":1}}],[\"中如下代码\",{\"1\":{\"793\":1}}],[\"中关注\",{\"1\":{\"790\":1}}],[\"中使用\",{\"1\":{\"790\":1}}],[\"中使用其它几种\",{\"1\":{\"499\":1}}],[\"中对应着两个\",{\"1\":{\"905\":1}}],[\"中对下面的代码是怎样进行处理的\",{\"1\":{\"790\":1}}],[\"中对切点\",{\"1\":{\"528\":1}}],[\"中更容易说明\",{\"1\":{\"776\":1}}],[\"中消息传输基于流的方式\",{\"1\":{\"766\":1}}],[\"中包含\",{\"1\":{\"752\":1}}],[\"中含有\",{\"1\":{\"751\":1}}],[\"中国加油\",{\"1\":{\"731\":1}}],[\"中引入的新的响应式框架\",{\"1\":{\"705\":1}}],[\"中引用了外部的局部变量\",{\"1\":{\"232\":1}}],[\"中找有没有类型合适的对象注入\",{\"1\":{\"688\":1}}],[\"中称为\",{\"1\":{\"655\":1}}],[\"中默认顺序如上\",{\"1\":{\"643\":1}}],[\"中获取\",{\"1\":{\"568\":1}}],[\"中用的的\",{\"1\":{\"531\":1}}],[\"中方法与编号的对应关系\",{\"1\":{\"527\":2}}],[\"中已废弃\",{\"1\":{\"496\":1}}],[\"中非\",{\"1\":{\"451\":1}}],[\"中文意思为雪花\",{\"1\":{\"440\":1}}],[\"中挑选最近最少使用的数据淘汰\",{\"1\":{\"429\":1}}],[\"中大概存储16kb\",{\"1\":{\"377\":1}}],[\"中是很常用的\",{\"1\":{\"275\":1}}],[\"中是一个线程等待另一个线程结束\",{\"1\":{\"217\":1}}],[\"中都存在一个threadlocalmap\",{\"1\":{\"247\":1}}],[\"中特有的方法\",{\"1\":{\"244\":1}}],[\"中因此不必是\",{\"1\":{\"232\":1}}],[\"中途给予不同的间隔时间\",{\"1\":{\"222\":1}}],[\"中级调度就是决定将哪个处于挂起状态的进程重新调入内存\",{\"1\":{\"136\":1}}],[\"中级调度\",{\"1\":{\"136\":1,\"153\":1}}],[\"中断请求\",{\"1\":{\"418\":1}}],[\"中断正在执行的任务\",{\"1\":{\"241\":1}}],[\"中断处理程序\",{\"1\":{\"182\":1,\"183\":1}}],[\"中断驱动方式\",{\"1\":{\"181\":1}}],[\"中断屏蔽方法\",{\"1\":{\"142\":1}}],[\"中断的分类\",{\"1\":{\"129\":1}}],[\"中断可以使cpu从用户态切换为核心态\",{\"1\":{\"129\":1}}],[\"中断\",{\"0\":{\"129\":1},\"1\":{\"406\":2,\"419\":1}}],[\"中最简单的设计模式之一\",{\"1\":{\"99\":1}}],[\"中的指定元素的排名\",{\"1\":{\"1030\":3}}],[\"中的内容全部写入\",{\"1\":{\"865\":1}}],[\"中的流程\",{\"1\":{\"793\":1}}],[\"中的配置\",{\"1\":{\"652\":1}}],[\"中的哪个方法\",{\"1\":{\"590\":1}}],[\"中的体现\",{\"1\":{\"568\":1,\"600\":1}}],[\"中的统一\",{\"0\":{\"528\":1}}],[\"中的扩展功能都没有用到\",{\"1\":{\"446\":1}}],[\"中的一种错误机制\",{\"1\":{\"324\":1}}],[\"中的\",{\"1\":{\"232\":1,\"539\":1,\"588\":2,\"596\":2,\"616\":1,\"806\":2,\"905\":1}}],[\"中的某标志位来表示当前处理器处于什么状态\",{\"1\":{\"128\":1}}],[\"中的sell\",{\"1\":{\"94\":3}}],[\"中的引用类型的属性进行引用的复制\",{\"1\":{\"89\":1}}],[\"中\",{\"1\":{\"49\":1,\"290\":1,\"408\":1,\"450\":1,\"451\":2,\"617\":1,\"623\":1,\"644\":1,\"773\":1,\"775\":1,\"776\":2,\"825\":1,\"990\":1}}],[\"建组合索引的时候\",{\"1\":{\"266\":1}}],[\"建议使用\",{\"1\":{\"844\":1}}],[\"建议设置到\",{\"1\":{\"779\":1}}],[\"建议练习\",{\"1\":{\"449\":1}}],[\"建议明确字段\",{\"1\":{\"388\":1}}],[\"建议将数据拆成整数和小数分开存储\",{\"1\":{\"265\":1}}],[\"建议还是封装到\",{\"1\":{\"49\":1}}],[\"建表规约\",{\"0\":{\"265\":1}}],[\"建立\",{\"1\":{\"890\":1}}],[\"建立与客户端连接\",{\"1\":{\"876\":1,\"877\":1}}],[\"建立成功后\",{\"1\":{\"767\":1}}],[\"建立关系\",{\"1\":{\"458\":1}}],[\"建立连接完毕\",{\"1\":{\"835\":1}}],[\"建立连接后\",{\"1\":{\"834\":1,\"835\":1}}],[\"建立连接\",{\"0\":{\"1021\":1},\"1\":{\"198\":1,\"1032\":2,\"1035\":1}}],[\"建立逻辑设备名与物理设备名的映射机制\",{\"1\":{\"185\":1}}],[\"建立逻辑设备名到物理设备名的映射关系\",{\"1\":{\"182\":1}}],[\"建立进程后的等待时间\",{\"1\":{\"138\":1}}],[\"建立pcb\",{\"1\":{\"136\":1}}],[\"建造者\",{\"1\":{\"48\":1,\"51\":1}}],[\"建造者模式则是要求按照指定的蓝图建造产品\",{\"1\":{\"55\":1}}],[\"建造者模式除了上面的用途外\",{\"1\":{\"52\":1}}],[\"建造者模式很容易进行扩展\",{\"1\":{\"50\":1}}],[\"建造者模式的封装性很好\",{\"1\":{\"50\":1}}],[\"建造者模式可以将部件和其组装过程分开\",{\"1\":{\"47\":1}}],[\"建造者模式\",{\"0\":{\"46\":1}}],[\"橡胶车座\",{\"1\":{\"49\":1}}],[\"碳纤维车架\",{\"1\":{\"49\":1}}],[\"铝合金车架\",{\"1\":{\"49\":1}}],[\"铝合金等材质的\",{\"1\":{\"49\":1}}],[\"摩拜单车builder类\",{\"1\":{\"49\":1}}],[\"摩托车\",{\"1\":{\"33\":1}}],[\"抽象一个\",{\"1\":{\"773\":1}}],[\"抽象方法\",{\"1\":{\"119\":1,\"123\":1}}],[\"抽象类主要用于代码复用\",{\"1\":{\"317\":1}}],[\"抽象类\",{\"1\":{\"119\":1}}],[\"抽象不应该依赖细节\",{\"1\":{\"109\":1}}],[\"抽象主题\",{\"1\":{\"92\":1}}],[\"抽象原型类\",{\"1\":{\"85\":1}}],[\"抽象工厂\",{\"1\":{\"68\":1,\"69\":1,\"73\":1,\"74\":1}}],[\"抽象工厂模式有多个抽象产品\",{\"1\":{\"73\":1}}],[\"抽象工厂模式的主要角色如下\",{\"1\":{\"73\":1}}],[\"抽象工厂模式是工厂方法模式的升级版本\",{\"1\":{\"72\":1}}],[\"抽象工厂模式\",{\"0\":{\"71\":1},\"1\":{\"60\":1}}],[\"抽象工厂模式实现对产品家族的创建\",{\"1\":{\"55\":1}}],[\"抽象工厂模式vs建造者模式\",{\"0\":{\"55\":1}}],[\"抽象产品\",{\"1\":{\"62\":1,\"68\":1,\"73\":1}}],[\"抽象\",{\"1\":{\"49\":2}}],[\"抽象建造者类\",{\"1\":{\"48\":1}}],[\"fetchsource\",{\"1\":{\"940\":1}}],[\"ff\",{\"1\":{\"755\":1}}],[\"fffffffffff|\",{\"1\":{\"756\":1}}],[\"ffff\",{\"1\":{\"754\":1}}],[\"fd\",{\"1\":{\"790\":1}}],[\"fddi\",{\"1\":{\"751\":1}}],[\"fd剧增后带来的io效率问题\",{\"1\":{\"410\":1}}],[\"font>\",{\"1\":{\"944\":1}}],[\"foo\",{\"1\":{\"510\":10,\"512\":3,\"515\":14}}],[\"form\",{\"1\":{\"667\":1}}],[\"formattingconversionservice\",{\"1\":{\"574\":1}}],[\"formatterpropertyeditoradapter\",{\"1\":{\"575\":1}}],[\"formatter\",{\"1\":{\"574\":1,\"576\":1}}],[\"format\",{\"1\":{\"441\":3,\"993\":1}}],[\"forward\",{\"1\":{\"642\":1}}],[\"forwardingnode出现在扩容时\",{\"1\":{\"249\":1}}],[\"forwardingnode的理解\",{\"1\":{\"249\":1}}],[\"forwardingnode<k\",{\"1\":{\"249\":1}}],[\"forceclose\",{\"1\":{\"793\":2}}],[\"forceflush\",{\"1\":{\"792\":1}}],[\"force\",{\"1\":{\"265\":1,\"869\":1}}],[\"foreach\",{\"1\":{\"82\":1,\"338\":1,\"339\":3,\"340\":1,\"343\":2,\"743\":1,\"744\":1,\"873\":1,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":3}}],[\"forname\",{\"1\":{\"77\":1,\"94\":6,\"783\":2,\"784\":1,\"855\":1}}],[\"for\",{\"1\":{\"77\":1,\"82\":2,\"116\":2,\"123\":1,\"191\":2,\"192\":3,\"194\":7,\"195\":6,\"225\":6,\"249\":3,\"263\":2,\"282\":3,\"283\":4,\"287\":1,\"339\":1,\"386\":4,\"403\":2,\"441\":2,\"463\":1,\"657\":1,\"749\":1,\"750\":1,\"753\":1,\"754\":2,\"755\":2,\"756\":2,\"759\":3,\"761\":2,\"783\":1,\"790\":1,\"791\":1,\"792\":1,\"793\":2,\"796\":2,\"839\":1,\"845\":2,\"849\":18,\"859\":1,\"870\":1,\"876\":1,\"877\":1,\"890\":2,\"893\":1,\"896\":1,\"993\":2,\"1038\":1}}],[\"f$$enhancerbyspringcglib$$8b54f2bc\",{\"1\":{\"500\":1}}],[\"f2\",{\"1\":{\"500\":2,\"826\":4}}],[\"f1\",{\"1\":{\"500\":2,\"826\":7}}],[\"fs\",{\"1\":{\"410\":1}}],[\"fuzziness\",{\"1\":{\"943\":2}}],[\"fuzzyquery\",{\"1\":{\"943\":4}}],[\"fuzzyquerybuilder\",{\"1\":{\"943\":1}}],[\"future<\",{\"1\":{\"808\":1}}],[\"future<integer>\",{\"1\":{\"807\":1,\"808\":1}}],[\"future<v>\",{\"1\":{\"806\":3}}],[\"future\",{\"0\":{\"806\":1,\"807\":1,\"808\":1},\"1\":{\"775\":2,\"785\":1,\"787\":2,\"790\":2,\"793\":3,\"803\":2,\"804\":1,\"806\":10,\"807\":3,\"808\":5,\"811\":3,\"814\":1,\"816\":2,\"844\":1}}],[\"fullrows\",{\"1\":{\"849\":4}}],[\"fullname\",{\"1\":{\"731\":2}}],[\"full\",{\"0\":{\"350\":1},\"1\":{\"350\":2}}],[\"function\",{\"1\":{\"343\":1}}],[\"function<id\",{\"1\":{\"990\":3}}],[\"function<\",{\"1\":{\"336\":1}}],[\"functionalinterface\",{\"1\":{\"336\":1}}],[\"func3\",{\"1\":{\"108\":2}}],[\"func2\",{\"1\":{\"108\":1}}],[\"func1\",{\"1\":{\"108\":5}}],[\"flip\",{\"1\":{\"846\":1,\"847\":1,\"848\":1,\"854\":1,\"857\":3,\"858\":2,\"859\":1,\"865\":1,\"876\":1,\"877\":1,\"886\":1,\"890\":2,\"896\":1,\"898\":1,\"907\":1,\"909\":1}}],[\"flux\",{\"1\":{\"841\":1}}],[\"flush\",{\"1\":{\"754\":2,\"755\":1,\"756\":1,\"825\":1,\"845\":2}}],[\"flag\",{\"1\":{\"988\":2,\"990\":2}}],[\"flags\",{\"1\":{\"277\":5}}],[\"flatmap\",{\"1\":{\"339\":2}}],[\"floatbuffer\",{\"1\":{\"332\":1,\"911\":1}}],[\"float和double在存储的时候\",{\"1\":{\"265\":1}}],[\"float\",{\"1\":{\"249\":1,\"822\":2,\"1025\":1}}],[\"fh\",{\"1\":{\"249\":3}}],[\"fh是链表头结点的hash\",{\"1\":{\"249\":1}}],[\"f是链表头节点\",{\"1\":{\"249\":1}}],[\"f\",{\"1\":{\"194\":15,\"249\":9,\"312\":1,\"500\":39,\"749\":1,\"750\":2,\"754\":11,\"755\":11,\"756\":11,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":7,\"829\":4,\"830\":2,\"849\":1,\"855\":2,\"857\":3,\"858\":4,\"886\":2,\"898\":1,\"904\":2,\"907\":1}}],[\"fcb的改进\",{\"1\":{\"168\":1}}],[\"fcfs优点\",{\"1\":{\"139\":1}}],[\"fcfs\",{\"1\":{\"139\":1,\"176\":1}}],[\"f6fbed833a9af8b9e4df67b0c17c3fc\",{\"1\":{\"159\":1}}],[\"f7cd987ba102ecf12110ee6a4416034\",{\"1\":{\"158\":1}}],[\"frequently\",{\"1\":{\"429\":2}}],[\"free函数释放内存\",{\"1\":{\"412\":1}}],[\"front\",{\"1\":{\"283\":1}}],[\"fromjson\",{\"1\":{\"773\":1}}],[\"from\",{\"1\":{\"266\":2,\"267\":2,\"366\":13,\"385\":1,\"386\":4,\"791\":1,\"870\":8,\"938\":1,\"968\":1,\"1038\":1}}],[\"frac\",{\"1\":{\"176\":3}}],[\"framework\",{\"1\":{\"538\":1,\"541\":1,\"544\":1,\"548\":1,\"551\":1,\"555\":1,\"705\":1,\"839\":1}}],[\"frame\",{\"1\":{\"49\":5}}],[\"fry\",{\"1\":{\"120\":2}}],[\"friends\",{\"1\":{\"111\":1}}],[\"facade\",{\"1\":{\"576\":1}}],[\"factories中的各种autoconfiguration类\",{\"1\":{\"730\":1}}],[\"factories\",{\"1\":{\"652\":1,\"670\":2,\"671\":1}}],[\"factor\",{\"1\":{\"328\":1}}],[\"factorybeanobjectcache\",{\"1\":{\"678\":1}}],[\"factorybean\",{\"0\":{\"675\":1,\"676\":1},\"1\":{\"678\":2}}],[\"factory\",{\"1\":{\"63\":1,\"68\":1,\"69\":5,\"73\":2,\"77\":4,\"94\":4,\"95\":2}}],[\"fasterxml\",{\"1\":{\"931\":1,\"1038\":1}}],[\"fastthreadlocal\",{\"1\":{\"842\":1}}],[\"fastthreadlocalrunnable\",{\"1\":{\"812\":2,\"815\":4}}],[\"fastclass\",{\"1\":{\"527\":1}}],[\"fast事件\",{\"1\":{\"324\":1}}],[\"fast\",{\"1\":{\"324\":1,\"740\":1}}],[\"fail问题\",{\"1\":{\"740\":1}}],[\"failedchannel\",{\"1\":{\"790\":1}}],[\"failed\",{\"1\":{\"650\":1,\"907\":2,\"909\":3}}],[\"failure\",{\"1\":{\"360\":1,\"790\":1,\"812\":2,\"813\":2,\"814\":2}}],[\"fail\",{\"1\":{\"324\":1,\"960\":3,\"968\":2,\"983\":2,\"990\":1,\"995\":4,\"996\":2,\"998\":9}}],[\"fail机制\",{\"1\":{\"324\":1}}],[\"father\",{\"1\":{\"285\":11}}],[\"fat\",{\"1\":{\"169\":1}}],[\"fans\",{\"1\":{\"111\":10}}],[\"false使用默认数据源\",{\"1\":{\"372\":1}}],[\"false\",{\"1\":{\"104\":1,\"116\":2,\"224\":2,\"225\":9,\"249\":1,\"255\":2,\"320\":1,\"372\":1,\"460\":1,\"531\":1,\"711\":2,\"731\":1,\"737\":1,\"758\":1,\"759\":2,\"760\":2,\"761\":1,\"778\":1,\"790\":4,\"791\":6,\"792\":2,\"793\":4,\"794\":3,\"822\":1,\"825\":1,\"877\":2,\"881\":1,\"884\":1,\"886\":2,\"890\":2,\"893\":3,\"896\":4,\"961\":1,\"972\":2}}],[\"fixedlengthframedecoder\",{\"1\":{\"754\":1}}],[\"fillbeanwithmap\",{\"1\":{\"972\":1}}],[\"filtercharacters\",{\"1\":{\"339\":3}}],[\"filter\",{\"1\":{\"272\":1,\"338\":2,\"617\":3,\"653\":1,\"668\":1}}],[\"filevisitresult\",{\"1\":{\"872\":5}}],[\"filecount\",{\"1\":{\"872\":6}}],[\"filechannel\",{\"0\":{\"861\":1,\"862\":1},\"1\":{\"332\":1,\"846\":2,\"857\":1,\"858\":1,\"862\":1,\"863\":2,\"870\":4,\"881\":1,\"911\":1}}],[\"filealreadyexistsexception\",{\"1\":{\"872\":2}}],[\"files\",{\"0\":{\"872\":1},\"1\":{\"655\":1,\"872\":15,\"873\":5}}],[\"filesystemxmlapplicationcontext\",{\"1\":{\"451\":1}}],[\"fileinputstream\",{\"1\":{\"89\":1,\"103\":1,\"863\":2,\"866\":1,\"870\":2}}],[\"fileoutputstream\",{\"1\":{\"89\":1,\"103\":1,\"863\":2,\"866\":1,\"870\":2}}],[\"file\",{\"1\":{\"10\":1,\"407\":1,\"410\":1,\"655\":1,\"846\":2,\"857\":2,\"858\":2,\"872\":9,\"904\":5}}],[\"finishconnect\",{\"1\":{\"792\":1,\"893\":1}}],[\"finished\",{\"1\":{\"263\":2}}],[\"fin\",{\"1\":{\"751\":1}}],[\"findbypageable\",{\"1\":{\"950\":1}}],[\"findbyid\",{\"1\":{\"950\":2}}],[\"findeligibleadvisors\",{\"1\":{\"539\":2}}],[\"findall\",{\"1\":{\"950\":3}}],[\"findautowiringmetadata\",{\"1\":{\"473\":1}}],[\"findany\",{\"1\":{\"341\":1}}],[\"findfirst\",{\"1\":{\"341\":2}}],[\"find\",{\"1\":{\"249\":1,\"285\":5}}],[\"final<\",{\"1\":{\"833\":1}}],[\"final类型的\",{\"1\":{\"317\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"244\":2}}],[\"final原理\",{\"0\":{\"237\":1}}],[\"final的使用\",{\"1\":{\"236\":1}}],[\"finally\",{\"1\":{\"104\":1,\"224\":2,\"225\":2,\"260\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"775\":1,\"783\":2,\"785\":1,\"790\":1,\"791\":3,\"793\":1,\"794\":1,\"825\":3,\"988\":1,\"989\":1,\"990\":2}}],[\"final\",{\"1\":{\"52\":1,\"82\":1,\"94\":7,\"101\":1,\"103\":1,\"104\":2,\"116\":5,\"120\":2,\"211\":1,\"221\":2,\"224\":1,\"225\":2,\"232\":2,\"236\":1,\"237\":2,\"249\":5,\"255\":6,\"441\":10,\"491\":1,\"500\":2,\"504\":1,\"513\":1,\"515\":1,\"516\":1,\"686\":1,\"744\":1,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"773\":17,\"775\":4,\"783\":2,\"787\":1,\"788\":1,\"790\":24,\"791\":3,\"792\":1,\"793\":8,\"794\":5,\"799\":2,\"849\":10,\"896\":1,\"909\":3,\"932\":1,\"962\":1,\"974\":3,\"989\":1,\"990\":2,\"993\":2,\"1034\":1,\"1042\":1}}],[\"fieldvalue\",{\"1\":{\"968\":2}}],[\"fieldname\",{\"1\":{\"968\":1}}],[\"fieldtype\",{\"1\":{\"950\":4}}],[\"field\",{\"0\":{\"925\":1},\"1\":{\"235\":1,\"237\":1,\"576\":2,\"944\":1,\"945\":1,\"946\":1,\"950\":4,\"1027\":2}}],[\"fifo\",{\"1\":{\"163\":2,\"420\":1}}],[\"firstregistration\",{\"1\":{\"790\":2,\"793\":2}}],[\"first`\",{\"1\":{\"385\":1}}],[\"first\",{\"1\":{\"139\":4,\"341\":2}}],[\"fireexceptioncaught\",{\"1\":{\"793\":1}}],[\"firechannelreadcomplete\",{\"1\":{\"793\":1,\"794\":1}}],[\"firechannelread\",{\"1\":{\"793\":1,\"794\":1,\"798\":1,\"816\":1,\"825\":3}}],[\"firechannelregistered\",{\"1\":{\"790\":1,\"793\":1}}],[\"firechannelactive\",{\"1\":{\"790\":3,\"793\":2}}],[\"fireproof\",{\"1\":{\"110\":7}}],[\"firewall\",{\"1\":{\"98\":1}}],[\"fight\",{\"1\":{\"116\":3}}],[\"车座等组件\",{\"1\":{\"49\":1}}],[\"车座等组件的生产\",{\"1\":{\"49\":1}}],[\"车座有橡胶\",{\"1\":{\"49\":1}}],[\"调试工具类💡\",{\"0\":{\"849\":1}}],[\"调试时也需要通过\",{\"1\":{\"790\":1}}],[\"调入内存\",{\"1\":{\"418\":1}}],[\"调入后就不再调出\",{\"1\":{\"153\":1}}],[\"调至盘上\",{\"1\":{\"418\":1}}],[\"调优和监控\",{\"1\":{\"240\":1}}],[\"调整区间\",{\"1\":{\"191\":1}}],[\"调页完成之后再将其唤醒\",{\"1\":{\"162\":1}}],[\"调出\",{\"1\":{\"136\":1}}],[\"调出必然是作业运行结束\",{\"1\":{\"136\":1}}],[\"调出一次\",{\"1\":{\"136\":1}}],[\"调度器就一直不会考虑调度他们\",{\"1\":{\"208\":1}}],[\"调度器甚至可以忽略\",{\"1\":{\"205\":1}}],[\"调度时选择优先级最高的作业\",{\"1\":{\"139\":1}}],[\"调度算法\",{\"0\":{\"139\":1}}],[\"调度算法评价指标\",{\"0\":{\"138\":1}}],[\"调度的三个层次\",{\"1\":{\"136\":1}}],[\"调度\",{\"1\":{\"135\":1}}],[\"调用操作系统的写能力\",{\"1\":{\"904\":1}}],[\"调用下一个入站处理器\",{\"1\":{\"816\":1}}],[\"调用外部类\",{\"1\":{\"791\":1}}],[\"调用失败\",{\"1\":{\"787\":1}}],[\"调用正常\",{\"1\":{\"787\":1}}],[\"调用异常\",{\"1\":{\"784\":1}}],[\"调用成功\",{\"1\":{\"784\":1}}],[\"调用接口中的方法名\",{\"1\":{\"783\":1}}],[\"调用的接口全限定名\",{\"1\":{\"783\":1}}],[\"调用的就是自己实现的invoke方法\",{\"1\":{\"94\":1}}],[\"调用subscription\",{\"1\":{\"745\":1}}],[\"调用sleep会让当前线程从running进入timed\",{\"1\":{\"203\":1}}],[\"调用cancel告诉发布者不在调用数据\",{\"1\":{\"743\":1,\"744\":1}}],[\"调用初始化方法\",{\"1\":{\"711\":1}}],[\"调用beanpostprocessor的初始化后的方法\",{\"1\":{\"711\":1}}],[\"调用beanpostprocessor的初始化前的方法\",{\"1\":{\"711\":1}}],[\"调用blocking\",{\"1\":{\"409\":1}}],[\"调用拦截器的\",{\"1\":{\"644\":3}}],[\"调用链会断开\",{\"1\":{\"816\":1}}],[\"调用链\",{\"1\":{\"644\":1}}],[\"调用此\",{\"1\":{\"636\":1}}],[\"调用过程中所处的位置\",{\"1\":{\"587\":1,\"595\":1,\"607\":1}}],[\"调用控制器方法\",{\"1\":{\"558\":1}}],[\"调用到没有更多通知了\",{\"1\":{\"552\":1}}],[\"调用它的\",{\"1\":{\"546\":2}}],[\"调用\",{\"1\":{\"523\":1,\"546\":2,\"627\":1,\"631\":1,\"642\":1,\"644\":2,\"825\":3,\"847\":2,\"852\":2,\"853\":2,\"883\":2,\"904\":1,\"905\":3,\"917\":1}}],[\"调用目标对象的方法\",{\"1\":{\"523\":1}}],[\"调用目标时有所改进\",{\"1\":{\"523\":1}}],[\"调用代理方法时\",{\"1\":{\"528\":1}}],[\"调用代理对象的方法\",{\"1\":{\"523\":1}}],[\"调用代理\",{\"1\":{\"510\":1,\"512\":1}}],[\"调用对象的各种初始化方法\",{\"1\":{\"458\":1}}],[\"调用后select函数会阻塞\",{\"1\":{\"410\":1}}],[\"调用<select\",{\"1\":{\"366\":1}}],[\"调用类的构造方法\",{\"1\":{\"352\":1}}],[\"调用了xxxvalue\",{\"1\":{\"321\":1}}],[\"调用了无参的read方法\",{\"1\":{\"123\":1}}],[\"调用包装类的valueof\",{\"1\":{\"321\":1}}],[\"调用多次和n次的作用是相同的\",{\"1\":{\"314\":1}}],[\"调用方法\",{\"1\":{\"784\":1}}],[\"调用方可以调用n次而不用担心引起的错误\",{\"1\":{\"314\":1}}],[\"调用方调用查询接口\",{\"1\":{\"313\":1}}],[\"调用时需要的各个组件\",{\"1\":{\"561\":1}}],[\"调用时\",{\"1\":{\"246\":1}}],[\"调用unpark后将counter置为1\",{\"1\":{\"219\":1}}],[\"调用yield会让当前线程从running进入runnalbe\",{\"1\":{\"203\":1}}],[\"调用者只操作缓存\",{\"1\":{\"981\":1}}],[\"调用者只关心产品的接口\",{\"1\":{\"58\":1}}],[\"调用者通过它访问具体工厂的工厂方法来创建产品\",{\"1\":{\"68\":1}}],[\"调用者通过该方法来获取产品\",{\"1\":{\"62\":1}}],[\"调用具体建造者来创建复杂对象的各个部分\",{\"1\":{\"48\":1}}],[\"调色板生成\",{\"1\":{\"18\":1}}],[\"产品口碑等\",{\"1\":{\"981\":1}}],[\"产品类\",{\"1\":{\"48\":1}}],[\"产生时间局部性的典型原因是程序中存在着大量的循环操作\",{\"1\":{\"417\":1}}],[\"产生指定个数整数并放入集合中\",{\"1\":{\"336\":1}}],[\"产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数\",{\"1\":{\"164\":1}}],[\"产生原因与动态分区分配相似\",{\"1\":{\"160\":1}}],[\"产生的原因\",{\"1\":{\"141\":1}}],[\"产生\",{\"1\":{\"139\":1}}],[\"产生13∗13\",{\"1\":{\"24\":1}}],[\"提示\",{\"1\":{\"1000\":1}}],[\"提示💡\",{\"0\":{\"837\":1}}],[\"提示cms未来将会被废弃\",{\"1\":{\"362\":1}}],[\"提交任务\",{\"1\":{\"807\":1}}],[\"提交任务代码\",{\"1\":{\"791\":1}}],[\"提交首个任务\",{\"1\":{\"791\":1}}],[\"提出了快表的概念\",{\"1\":{\"413\":1}}],[\"提出了多级页表的概念\",{\"1\":{\"413\":1}}],[\"提出图像转译的通用框架\",{\"1\":{\"16\":1}}],[\"提升redis的i\",{\"1\":{\"424\":1}}],[\"提升的效率会更明显\",{\"1\":{\"383\":1}}],[\"提升了并发度\",{\"1\":{\"135\":1}}],[\"提到这个问题得区分i是成员变量\",{\"1\":{\"230\":1}}],[\"提高的是吞吐量\",{\"1\":{\"805\":1}}],[\"提高性能\",{\"1\":{\"527\":1}}],[\"提高垃圾收集的性能\",{\"1\":{\"360\":1}}],[\"提高线程的可管理性\",{\"1\":{\"240\":1}}],[\"提高响应速度\",{\"1\":{\"240\":1}}],[\"提高代码复用性\",{\"1\":{\"121\":1}}],[\"提高模块的相对独立性\",{\"1\":{\"111\":1}}],[\"提拉米苏\",{\"1\":{\"74\":1}}],[\"提拉米苏工厂\",{\"1\":{\"74\":1}}],[\"提供支持\",{\"1\":{\"906\":1}}],[\"提供两个实现\",{\"1\":{\"773\":1}}],[\"提供异步能力\",{\"1\":{\"769\":1}}],[\"提供运行时的应用监控\",{\"1\":{\"726\":1}}],[\"提供完整的ioc服务支持\",{\"1\":{\"707\":1}}],[\"提供对\",{\"1\":{\"705\":4}}],[\"提供对事务的支持\",{\"1\":{\"705\":1}}],[\"提供一个配置文件\",{\"1\":{\"670\":1}}],[\"提供一些扩展逻辑\",{\"1\":{\"458\":1}}],[\"提供\",{\"1\":{\"663\":1,\"664\":2}}],[\"提供的一个对atomiclong改进后的一个类\",{\"1\":{\"997\":1}}],[\"提供的\",{\"1\":{\"660\":4,\"665\":1,\"666\":1,\"791\":1}}],[\"提供的基本功能\",{\"1\":{\"446\":1}}],[\"提供增强功能\",{\"1\":{\"504\":1}}],[\"提供不同的垃圾收集器\",{\"1\":{\"360\":1}}],[\"提供了redistemplate统一api来操作redis\",{\"1\":{\"1036\":1}}],[\"提供了高可用性\",{\"1\":{\"928\":1}}],[\"提供了非池化的\",{\"1\":{\"830\":1}}],[\"提供了\",{\"1\":{\"796\":2}}],[\"提供了对不同redis客户端的整合\",{\"1\":{\"1036\":1}}],[\"提供了对\",{\"1\":{\"705\":1}}],[\"提供了对数据库访问的抽象\",{\"1\":{\"705\":1}}],[\"提供了面向切面编程的实现\",{\"1\":{\"705\":1}}],[\"提供了两种另外的\",{\"1\":{\"504\":1}}],[\"提供了多种初始化手段\",{\"1\":{\"495\":1}}],[\"提供了与真实主题相同的接口\",{\"1\":{\"92\":1}}],[\"提供了创建产品的接口\",{\"1\":{\"68\":1,\"73\":1}}],[\"提供了创建产品的方法\",{\"1\":{\"62\":1}}],[\"提供产品的实例\",{\"1\":{\"48\":1}}],[\"模型时\",{\"1\":{\"845\":1}}],[\"模型\",{\"0\":{\"901\":1},\"1\":{\"734\":1}}],[\"模型工厂\",{\"1\":{\"644\":1}}],[\"模块的\",{\"1\":{\"705\":1}}],[\"模拟缓存重建延迟\",{\"1\":{\"988\":1}}],[\"模拟实现这组映射器和适配器\",{\"1\":{\"627\":1}}],[\"模拟\",{\"0\":{\"515\":1,\"521\":1,\"550\":1}}],[\"模拟解析\",{\"0\":{\"478\":1,\"481\":1,\"484\":1}}],[\"模拟脱机输出时的外围控制机\",{\"1\":{\"184\":1}}],[\"模拟脱机输出时的磁带\",{\"1\":{\"184\":1}}],[\"模拟脱机输入时的外围控制机\",{\"1\":{\"184\":1}}],[\"模拟脱机输入时的磁带\",{\"1\":{\"184\":1}}],[\"模板设计模式\",{\"1\":{\"461\":1}}],[\"模板方法设计模式\",{\"0\":{\"462\":1}}],[\"模板方法\",{\"0\":{\"255\":1},\"1\":{\"119\":2,\"463\":1}}],[\"模板方法模式\",{\"0\":{\"117\":1}}],[\"模糊查询\",{\"0\":{\"943\":1},\"1\":{\"943\":1}}],[\"模糊查询时如果使用了\",{\"1\":{\"366\":1}}],[\"模糊图像转成高清图像等酷炫好玩的应用\",{\"1\":{\"10\":1}}],[\"模式包含以下主要角色\",{\"1\":{\"119\":1}}],[\"模式包含如下角色\",{\"1\":{\"48\":1}}],[\"模式分为三种角色\",{\"1\":{\"92\":1}}],[\"模式\",{\"0\":{\"409\":1},\"1\":{\"80\":1,\"776\":1}}],[\"模式扩展\",{\"0\":{\"52\":1,\"77\":1}}],[\"模式创建的是复杂对象\",{\"1\":{\"51\":1}}],[\"装配过程\",{\"0\":{\"689\":1,\"693\":1}}],[\"装配底层\",{\"0\":{\"687\":1,\"692\":1}}],[\"装配算法的解耦\",{\"1\":{\"47\":1}}],[\"装箱\",{\"1\":{\"321\":1}}],[\"装入时动态链接\",{\"1\":{\"151\":1}}],[\"装入时对地址进行重定位\",{\"1\":{\"151\":1}}],[\"装入程序将装入模块装入到内存之后也不会立即将逻辑地址变换为物理地址\",{\"1\":{\"151\":1}}],[\"装入程序按照装入模块中的地址\",{\"1\":{\"151\":1}}],[\"装入的三种方式\",{\"1\":{\"151\":1}}],[\"装饰器模式提供的都是跟原始类相同的接口\",{\"1\":{\"45\":1}}],[\"装饰器模式不改变原始类接口的情况下\",{\"1\":{\"45\":1}}],[\"装饰器\",{\"0\":{\"45\":1}}],[\"也叫散列\",{\"1\":{\"1027\":1}}],[\"也叫后端控制器\",{\"1\":{\"736\":1}}],[\"也没有对version的版本号+1\",{\"1\":{\"996\":1}}],[\"也没其他的事情需要操心\",{\"1\":{\"987\":1}}],[\"也称之为双写方案\",{\"1\":{\"981\":1}}],[\"也称之为注册事件\",{\"1\":{\"881\":1}}],[\"也称为exchange指令\",{\"1\":{\"142\":1}}],[\"也称为间接制约关系\",{\"1\":{\"140\":1}}],[\"也只会有一个\",{\"1\":{\"790\":1}}],[\"也作\",{\"1\":{\"766\":1}}],[\"也罢\",{\"1\":{\"766\":1}}],[\"也包含了切点功能\",{\"1\":{\"662\":1}}],[\"也被称之为前控制器\",{\"1\":{\"644\":1}}],[\"也提供了多种销毁手段\",{\"1\":{\"495\":1}}],[\"也无意义再从逻辑上扩大内存容量\",{\"1\":{\"419\":1}}],[\"也将内存空间分为若干个物理块或页框\",{\"1\":{\"413\":1}}],[\"也会受影响\",{\"1\":{\"826\":1}}],[\"也会增加\",{\"1\":{\"820\":1}}],[\"也会出现异常\",{\"1\":{\"812\":1}}],[\"也会提升查询效率\",{\"1\":{\"383\":1}}],[\"也会引发对\",{\"1\":{\"280\":1}}],[\"也都可以进行简单修改即可使用\",{\"1\":{\"368\":1}}],[\"也都需要先通过遍历字符串才能得到目标字符串的末尾\",{\"1\":{\"276\":1}}],[\"也需要加入\",{\"1\":{\"751\":1}}],[\"也需要在dao层参数名称位置指定具体名称\",{\"1\":{\"365\":1}}],[\"也需要定义\",{\"1\":{\"268\":1}}],[\"也说明该单词不存在\",{\"1\":{\"282\":1}}],[\"也返回为0\",{\"1\":{\"267\":1}}],[\"也必须存在\",{\"1\":{\"450\":1}}],[\"也必须把b放在索引的最前列\",{\"1\":{\"266\":1}}],[\"也必须建成唯一索引\",{\"1\":{\"266\":1,\"383\":1}}],[\"也有利于未来的可拓展性和可维护性\",{\"1\":{\"706\":1}}],[\"也有访问底层硬件设备的所有权限\",{\"1\":{\"406\":1}}],[\"也有一些跟修改相关的方法啊\",{\"1\":{\"236\":1}}],[\"也有可能导致饥饿\",{\"1\":{\"148\":1}}],[\"也同时能保证代码块内变量的可见性\",{\"1\":{\"228\":1}}],[\"也能增强\",{\"1\":{\"504\":1}}],[\"也能够更有效地进行文件的管理和保护\",{\"1\":{\"168\":1}}],[\"也能保证\",{\"1\":{\"101\":1}}],[\"也可能是一个xml或json串\",{\"1\":{\"736\":2}}],[\"也可在内存中同时装入更多的进程\",{\"1\":{\"418\":1}}],[\"也可通过良好的设计改善\",{\"1\":{\"410\":1}}],[\"也可被重新赋值\",{\"1\":{\"317\":1}}],[\"也可由程序员直接赋予\",{\"1\":{\"151\":1}}],[\"也可以根据自己的需求来删除或添加词条\",{\"1\":{\"1026\":1}}],[\"也可以增加负数\",{\"1\":{\"1025\":1}}],[\"也可以作为静态资源服务器\",{\"1\":{\"955\":1}}],[\"也可以拥有某个订单的一个文档\",{\"1\":{\"924\":1}}],[\"也可以将\",{\"1\":{\"911\":1}}],[\"也可以将别的进程持有的物理块置换到外存\",{\"1\":{\"164\":1}}],[\"也可以理解为硬件单元\",{\"1\":{\"904\":1}}],[\"也可以进行任务处理\",{\"1\":{\"837\":1}}],[\"也可以用来包装普通字节数组\",{\"1\":{\"830\":1}}],[\"也可以用于\",{\"1\":{\"779\":1}}],[\"也可以写入数据\",{\"1\":{\"822\":1}}],[\"也可以写入数据到缓冲区\",{\"1\":{\"332\":1}}],[\"也可以异步方式得到结果\",{\"1\":{\"806\":1}}],[\"也可以由\",{\"1\":{\"792\":1}}],[\"也可以在加入\",{\"1\":{\"649\":1}}],[\"也可以通过\",{\"1\":{\"617\":1}}],[\"也可以通过配置修改为\",{\"1\":{\"561\":1}}],[\"也可以说是下一毫秒\",{\"1\":{\"441\":1}}],[\"也可以使用下面的代码来创建池化基于直接内存的\",{\"1\":{\"819\":1}}],[\"也可以使用\",{\"1\":{\"439\":1,\"646\":1,\"648\":1,\"796\":1}}],[\"也可以称为软中断\",{\"1\":{\"406\":1}}],[\"也可以加在行上\",{\"1\":{\"398\":1}}],[\"也可以显著减少查询中分组和排序的时间\",{\"1\":{\"375\":1}}],[\"也可以不设置\",{\"1\":{\"323\":1}}],[\"也可以保存任意格式的二进制数据\",{\"1\":{\"277\":1}}],[\"也可以保存二进制数据\",{\"1\":{\"277\":1}}],[\"也可以引入快表机构\",{\"1\":{\"160\":1}}],[\"也可以是文档型\",{\"1\":{\"1004\":1}}],[\"也可以是多个字段的组合\",{\"1\":{\"315\":1}}],[\"也可以是更复杂的记录型变量\",{\"1\":{\"143\":1}}],[\"也可以是另一个进程\",{\"1\":{\"137\":1}}],[\"也可以让各进程按时间片轮流执行\",{\"1\":{\"137\":1}}],[\"也可以从网上下载新的皮肤\",{\"1\":{\"107\":1}}],[\"也可以做出不同的对象\",{\"1\":{\"47\":1}}],[\"也不妨碍前面线程读取客户端数据\",{\"1\":{\"845\":1}}],[\"也不见主人家为他交付束修金\",{\"1\":{\"766\":1}}],[\"也不会造成回收\",{\"1\":{\"825\":1}}],[\"也不会阻塞住\",{\"1\":{\"792\":1}}],[\"也不会出现幻读\",{\"1\":{\"393\":1}}],[\"也不会出现缓冲区溢出的问题\",{\"1\":{\"277\":1}}],[\"也不会出现前面所说的缓冲区溢出的问题\",{\"1\":{\"277\":1}}],[\"也不会放弃处理器\",{\"1\":{\"137\":1}}],[\"也不能保证线程之间读取到同样的值然后互相覆盖对方值的情况\",{\"1\":{\"230\":1}}],[\"也不能再申请内存空间\",{\"1\":{\"151\":1}}],[\"也不是太符合单一职责原则\",{\"1\":{\"49\":1}}],[\"也是与原始\",{\"1\":{\"827\":1}}],[\"也是利用异步的关键\",{\"1\":{\"805\":1}}],[\"也是自动配置功能的核心实现者\",{\"1\":{\"731\":1}}],[\"也是\",{\"1\":{\"720\":1,\"822\":1}}],[\"也是不反射调用\",{\"1\":{\"523\":1}}],[\"也是陈旧的说法\",{\"1\":{\"496\":1}}],[\"也是许多互联网公司在推荐使用的\",{\"1\":{\"439\":1}}],[\"也是在更新提交的时候\",{\"1\":{\"397\":1}}],[\"也是表现出了华为这种大格局\",{\"1\":{\"304\":1,\"305\":1}}],[\"也是通过饼状图展示\",{\"1\":{\"296\":1}}],[\"也是能接受的\",{\"1\":{\"281\":1}}],[\"也是为了进行内存空间的扩充\",{\"1\":{\"161\":1}}],[\"也是用硬件实现\",{\"1\":{\"142\":1}}],[\"也是程序执行流的最小单位\",{\"1\":{\"135\":1}}],[\"也是对着类的加载而创建\",{\"1\":{\"101\":1}}],[\"也就导致高地址的大分区更可能被使用\",{\"1\":{\"155\":1}}],[\"也就不能发生进程切换\",{\"1\":{\"142\":1}}],[\"也就无法并发\",{\"1\":{\"127\":1}}],[\"也就是字符串类型\",{\"1\":{\"1025\":1}}],[\"也就是运行redis\",{\"1\":{\"1015\":1}}],[\"也就是一条数据\",{\"1\":{\"924\":1}}],[\"也就是不管有没有事件\",{\"1\":{\"882\":1}}],[\"也就是总字节数会使用\",{\"1\":{\"751\":1}}],[\"也就是产品可以被代理增强\",{\"1\":{\"678\":1}}],[\"也就是只有网络请求模块和数据操作模块是单线程的\",{\"1\":{\"423\":1}}],[\"也就是只有一个进程访问临界资源后\",{\"1\":{\"141\":1}}],[\"也就是切换到了内核态\",{\"1\":{\"406\":2}}],[\"也就是都不保证线程安全\",{\"1\":{\"322\":1}}],[\"也就是都属于美式风味\",{\"1\":{\"74\":1}}],[\"也就是都属于意大利风味\",{\"1\":{\"74\":1}}],[\"也就是列表尾的偏移量\",{\"1\":{\"279\":1}}],[\"也就是\",{\"1\":{\"275\":1}}],[\"也就是地址需要用32个二进制位来表示\",{\"1\":{\"151\":1}}],[\"也就是有4\",{\"1\":{\"151\":1}}],[\"也就是同一品牌的产品\",{\"1\":{\"71\":1}}],[\"也就是同一类产品\",{\"1\":{\"71\":1}}],[\"也就是说将其中的处理器方法映射到url路径上\",{\"1\":{\"737\":1}}],[\"也就是说不管外部方法是否开启事务\",{\"1\":{\"720\":1}}],[\"也就是说当内存不足以容纳新写入数据时\",{\"1\":{\"429\":1}}],[\"也就是说段页式管理机制中段与段之间以及段的内部都是离散的\",{\"1\":{\"413\":1}}],[\"也就是说这个读写过程是阻塞的\",{\"1\":{\"410\":1}}],[\"也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的\",{\"1\":{\"409\":1}}],[\"也就是说一个页\",{\"1\":{\"377\":1}}],[\"也就是说proxypoint作为访问对象和目标对象的中介\",{\"1\":{\"93\":1}}],[\"也就是说\",{\"1\":{\"71\":1,\"408\":1}}],[\"也就是实现了构建算法\",{\"1\":{\"47\":1}}],[\"也带来了弊端\",{\"1\":{\"108\":1}}],[\"也更方便使用程序来控制创建过程\",{\"1\":{\"50\":1}}],[\"也相对独立地改变\",{\"1\":{\"45\":1}}],[\"由系统本身完成\",{\"1\":{\"981\":1}}],[\"由四部分组成\",{\"1\":{\"821\":1}}],[\"由下一个\",{\"1\":{\"799\":1}}],[\"由非\",{\"1\":{\"792\":1,\"798\":1}}],[\"由注册线程去执行\",{\"1\":{\"790\":1}}],[\"由它在目标方法调用前后加入事务操作\",{\"1\":{\"662\":1}}],[\"由\",{\"1\":{\"644\":1,\"650\":1,\"652\":1,\"792\":2,\"798\":1,\"825\":1,\"842\":1}}],[\"由解析\",{\"1\":{\"539\":1}}],[\"由代理结合通知和目标\",{\"1\":{\"504\":1}}],[\"由代理创建新的\",{\"1\":{\"500\":1}}],[\"由代码可以看出\",{\"1\":{\"261\":1}}],[\"由地址变换机构自动地将页号p送入高速缓冲寄存器\",{\"1\":{\"413\":1}}],[\"由字节码中是否跟随由invokespecial指令所决定\",{\"1\":{\"352\":1}}],[\"由executors类提供的工厂方法来创建线程池\",{\"1\":{\"244\":1}}],[\"由调用者线程自行处理该任务\",{\"1\":{\"243\":1}}],[\"由三部分组成\",{\"1\":{\"219\":1}}],[\"由一组相似的记录组成\",{\"1\":{\"167\":1}}],[\"由一组系统调用组成\",{\"1\":{\"126\":1}}],[\"由程序员指出应该先调入哪些部分\",{\"1\":{\"164\":1}}],[\"由操作系统决定\",{\"1\":{\"413\":1}}],[\"由操作系统负责将内存中暂时用不到的信息换出到外存\",{\"1\":{\"161\":1,\"162\":1}}],[\"由操作系统负责将所需信息从外存调入内存\",{\"1\":{\"161\":1,\"162\":1}}],[\"由操作系统内核程序根据用户程序大小检索该表\",{\"1\":{\"154\":1}}],[\"由操作系统代为完成\",{\"1\":{\"130\":1}}],[\"由运行态到阻塞态\",{\"1\":{\"143\":1}}],[\"由时钟装置发出时钟中断来通知cpu时间片已到\",{\"1\":{\"139\":1}}],[\"由几个用户级线程映射到几个内核级线程可引出多线程模型\",{\"1\":{\"135\":1}}],[\"由应用程序提供线程库实现\",{\"1\":{\"135\":1}}],[\"由子类实现\",{\"1\":{\"123\":1}}],[\"由其具体子类实现\",{\"1\":{\"119\":1}}],[\"由此也产生了一种新的实现模式\",{\"1\":{\"101\":1}}],[\"由于name已经存在\",{\"1\":{\"1025\":1}}],[\"由于redis中只有k1\",{\"1\":{\"1024\":1}}],[\"由于现在我们部署了多个tomcat\",{\"1\":{\"999\":1}}],[\"由于保证了互斥性\",{\"1\":{\"987\":1}}],[\"由于线程线程2持有着锁\",{\"1\":{\"987\":1}}],[\"由于我们的缓存的数据源来自于数据库\",{\"1\":{\"981\":1}}],[\"由于其又被final修饰\",{\"1\":{\"974\":1}}],[\"由于其被static修饰\",{\"1\":{\"974\":1}}],[\"由于存入的数据比较简单\",{\"1\":{\"965\":1}}],[\"由于cglib采用动态创建子类的方式生成代理对象\",{\"1\":{\"717\":1}}],[\"由于ioc这个词汇比较抽象而di却更直观\",{\"1\":{\"706\":1}}],[\"由于进程的最后一页经常装不满一块\",{\"1\":{\"413\":1}}],[\"由于hash冲突效率就会降低\",{\"1\":{\"381\":1}}],[\"由于非叶节点并不是最终指向文件内容的节点\",{\"1\":{\"378\":1}}],[\"由于维护和兼容性测试的成本\",{\"1\":{\"360\":1}}],[\"由于在垃圾回收过程中\",{\"1\":{\"356\":1}}],[\"由于内存限制\",{\"1\":{\"290\":1}}],[\"由于内存无法容纳所有作业\",{\"1\":{\"161\":1}}],[\"由于设备速度慢\",{\"1\":{\"184\":1}}],[\"由于这种策略调入的页面一定会被访问到\",{\"1\":{\"164\":1}}],[\"由于第二轮已将所有帧的访问位设为0\",{\"1\":{\"163\":1}}],[\"由于长期得不到想要的资源\",{\"1\":{\"147\":1}}],[\"由于高频率的进程切换\",{\"1\":{\"139\":1}}],[\"由于共享内存地址空间\",{\"1\":{\"135\":1}}],[\"由于操作系统的管理工作\",{\"1\":{\"129\":1}}],[\"由于\",{\"1\":{\"101\":1,\"383\":1,\"825\":1}}],[\"由于某些原因需要给某对象提供一个代理以控制对该对象的访问\",{\"1\":{\"91\":1}}],[\"由于使用了多态性\",{\"1\":{\"69\":1}}],[\"由于实现了构建和装配的解耦\",{\"1\":{\"47\":1}}],[\"由具体工厂来创建\",{\"1\":{\"68\":1,\"73\":1}}],[\"由多个部件构成\",{\"1\":{\"51\":1}}],[\"由director负责\",{\"1\":{\"47\":1}}],[\"由builder来负责\",{\"1\":{\"47\":1}}],[\"和get\",{\"1\":{\"1025\":1}}],[\"和lock都是悲观锁的代表\",{\"1\":{\"996\":1}}],[\"和对象\",{\"1\":{\"974\":1}}],[\"和新增一致\",{\"1\":{\"950\":1}}],[\"和复制分片\",{\"1\":{\"928\":1}}],[\"和可读数据\",{\"1\":{\"877\":1}}],[\"和它的子类使用了池化机制\",{\"1\":{\"825\":1}}],[\"和拦截器合在一起称为\",{\"1\":{\"644\":1}}],[\"和环绕通知链\",{\"1\":{\"546\":1}}],[\"和5位\",{\"1\":{\"440\":1}}],[\"和set相比增加了一个权重参数score\",{\"1\":{\"422\":1}}],[\"和semaphore类似\",{\"1\":{\"262\":1}}],[\"和物理块\",{\"1\":{\"413\":1}}],[\"和动态变化\",{\"1\":{\"348\":1}}],[\"和et\",{\"1\":{\"410\":1}}],[\"和equals\",{\"1\":{\"338\":1}}],[\"和executors\",{\"1\":{\"244\":1}}],[\"和贵司一起成长\",{\"1\":{\"307\":1}}],[\"和一系列随机映射函数\",{\"1\":{\"272\":1}}],[\"和count\",{\"0\":{\"387\":1},\"1\":{\"387\":3}}],[\"和countdownlatch和类似\",{\"1\":{\"263\":1}}],[\"和callable\",{\"1\":{\"245\":1}}],[\"和公平锁一样都会进入到tryacquire方法\",{\"1\":{\"258\":1}}],[\"和自己创建单线程执行任务的区别\",{\"1\":{\"244\":1}}],[\"和unpark\",{\"0\":{\"219\":1}}],[\"和wait\",{\"0\":{\"216\":1}}],[\"和notify\",{\"0\":{\"215\":1}}],[\"和klass\",{\"1\":{\"210\":1}}],[\"和runtime\",{\"1\":{\"355\":1}}],[\"和run\",{\"0\":{\"202\":1},\"1\":{\"202\":1}}],[\"和用户文件目录\",{\"1\":{\"168\":1}}],[\"和段的长度\",{\"1\":{\"159\":1}}],[\"和段内地址\",{\"1\":{\"159\":1}}],[\"和页表长度\",{\"1\":{\"157\":1}}],[\"和界地址寄存器\",{\"1\":{\"152\":1}}],[\"和\",{\"0\":{\"528\":1,\"854\":1},\"1\":{\"133\":1,\"197\":1,\"208\":1,\"219\":1,\"277\":8,\"279\":2,\"281\":1,\"383\":1,\"449\":1,\"496\":1,\"523\":1,\"527\":2,\"582\":1,\"752\":1,\"790\":1,\"798\":2,\"813\":1,\"829\":1,\"835\":1,\"837\":1,\"845\":1,\"852\":1,\"853\":1,\"854\":1,\"871\":1,\"890\":1,\"905\":1,\"1005\":1}}],[\"和时分复用技术\",{\"1\":{\"127\":1}}],[\"和媒体公司的业务洽淡等\",{\"1\":{\"111\":1}}],[\"和proxyobject是同一个对象\",{\"1\":{\"94\":1}}],[\"和拿铁咖啡\",{\"1\":{\"60\":1}}],[\"和装配\",{\"1\":{\"47\":1}}],[\"和测试类\",{\"1\":{\"42\":1}}],[\"并集\",{\"1\":{\"1029\":1,\"1030\":1}}],[\"并未提供windows安装包\",{\"1\":{\"1019\":1}}],[\"并反序列化为指定类型\",{\"1\":{\"990\":4}}],[\"并从\",{\"1\":{\"888\":1}}],[\"并\",{\"1\":{\"791\":1}}],[\"并可动态调整\",{\"1\":{\"781\":1}}],[\"并转换成string类型\",{\"1\":{\"744\":1}}],[\"并定义该拦截器匹配那些请求路径\",{\"1\":{\"738\":1}}],[\"并定义其两个子类\",{\"1\":{\"60\":1}}],[\"并让它实现webmvcconfigurer接口\",{\"1\":{\"738\":1}}],[\"并注入spring容器\",{\"1\":{\"730\":1}}],[\"并用泛型技术解析事件对象的原始类型\",{\"1\":{\"703\":1}}],[\"并演示\",{\"1\":{\"651\":1}}],[\"并结合匹配到的拦截器一起返回给\",{\"1\":{\"644\":1}}],[\"并设置超时时间\",{\"1\":{\"983\":1}}],[\"并设置唤醒状态为\",{\"1\":{\"791\":1}}],[\"并设置\",{\"1\":{\"600\":2}}],[\"并与匹配的拦截器一起返回给\",{\"1\":{\"561\":1}}],[\"并逐一调用它们的初始化\",{\"1\":{\"561\":1}}],[\"并处理方法参数与方法返回值\",{\"1\":{\"558\":1}}],[\"并暂存于二级缓存\",{\"1\":{\"542\":1}}],[\"并非继承而来\",{\"1\":{\"451\":1}}],[\"并非每次都对三个内存\",{\"1\":{\"350\":1}}],[\"并为匹配切点的目标类创建代理\",{\"1\":{\"659\":1}}],[\"并为它们进行编号\",{\"1\":{\"413\":1}}],[\"并为每个页加以编号\",{\"1\":{\"413\":1}}],[\"并防止其他用户读取正在写入的同一资源\",{\"1\":{\"398\":1}}],[\"并返回此对象的地址\",{\"1\":{\"354\":1}}],[\"并把堆内对象的首地址赋值给引用变量\",{\"1\":{\"352\":1}}],[\"并生成对应的class类对象\",{\"1\":{\"352\":1}}],[\"并在jdk9中完全取消了这些组合的支持\",{\"1\":{\"360\":1}}],[\"并在内部消亡\",{\"1\":{\"349\":1}}],[\"并在cpu运行\",{\"1\":{\"132\":1}}],[\"并对原java\",{\"1\":{\"332\":1}}],[\"并分别按归属地\",{\"1\":{\"296\":1}}],[\"并计数\",{\"1\":{\"291\":1}}],[\"并其下一行数据写入到最终排序的文件中\",{\"1\":{\"291\":1}}],[\"并查集\",{\"0\":{\"285\":1}}],[\"并进行计数\",{\"1\":{\"276\":1}}],[\"并没有获得到锁\",{\"1\":{\"987\":1}}],[\"并没有发生内存复制\",{\"1\":{\"826\":1}}],[\"并没有进行对象的赋值操作\",{\"1\":{\"101\":1}}],[\"并没能达到多线程的效果\",{\"1\":{\"202\":1}}],[\"并将该请求放入\",{\"1\":{\"776\":1}}],[\"并将预取机制集成到高速缓存控制逻辑中实现\",{\"1\":{\"417\":1}}],[\"并将此页号与高速缓冲中的所有页号进行比较\",{\"1\":{\"413\":1}}],[\"并将其映射成一个新的元素\",{\"1\":{\"339\":1}}],[\"并将其存储到数组的第一个索引位置\",{\"1\":{\"123\":1}}],[\"并将\",{\"1\":{\"280\":1}}],[\"并将完整的自举程序读入内存\",{\"1\":{\"178\":1}}],[\"并修改超级块的内容\",{\"1\":{\"170\":1}}],[\"并修改页表中相应的页表项\",{\"1\":{\"162\":1}}],[\"并常驻内存\",{\"1\":{\"169\":1}}],[\"并使用\",{\"1\":{\"770\":1}}],[\"并使用高速缓存的层次结构实现\",{\"1\":{\"417\":1}}],[\"并使用concretestrategy角色去实现需求\",{\"1\":{\"115\":1}}],[\"并使分区的大小正好适合进程的需要\",{\"1\":{\"154\":1}}],[\"并剥夺这些进程的资源\",{\"1\":{\"150\":1}}],[\"并抢占它的资源\",{\"1\":{\"150\":1}}],[\"并建立相应的进程\",{\"1\":{\"136\":1}}],[\"并不仅仅是这里会使用\",{\"1\":{\"1033\":1}}],[\"并不是真正无拷贝\",{\"1\":{\"905\":1}}],[\"并不是所有的资源都可以改造成可共享使用资源\",{\"1\":{\"148\":1}}],[\"并不需要等待\",{\"1\":{\"409\":1}}],[\"并不一定真实\",{\"1\":{\"139\":1}}],[\"并不意识到线程的存在\",{\"1\":{\"135\":1}}],[\"并不涉及具体的部件对象的创建\",{\"1\":{\"48\":1}}],[\"并由操作系统内核对中断进行处理\",{\"1\":{\"129\":1}}],[\"并行的操作\",{\"1\":{\"927\":1}}],[\"并行回收器\",{\"1\":{\"360\":1}}],[\"并行\",{\"1\":{\"127\":1}}],[\"并发过来\",{\"1\":{\"998\":1}}],[\"并发送\",{\"1\":{\"776\":1}}],[\"并发回收器\",{\"1\":{\"360\":1}}],[\"并发局限于应用中\",{\"1\":{\"334\":1}}],[\"并发编程面试必备\",{\"1\":{\"232\":1}}],[\"并发编程的三大特性\",{\"0\":{\"226\":1}}],[\"并发执行的进程p1\",{\"1\":{\"147\":1}}],[\"并发度不高\",{\"1\":{\"135\":1}}],[\"并发性能较差\",{\"1\":{\"396\":1}}],[\"并发性能好\",{\"1\":{\"393\":1,\"396\":1}}],[\"并发性能大大提升\",{\"1\":{\"249\":1}}],[\"并发性\",{\"1\":{\"131\":1}}],[\"并发和共享的关系\",{\"1\":{\"127\":1}}],[\"并发\",{\"1\":{\"127\":2}}],[\"并合理地组织调度计算机的工作和资源的分配\",{\"1\":{\"125\":1}}],[\"并符合\",{\"1\":{\"121\":1}}],[\"并初始化instance\",{\"1\":{\"101\":1}}],[\"并初始化其静态属性\",{\"1\":{\"101\":1}}],[\"并且查询时能自动把json反序列化为java对象\",{\"1\":{\"1041\":1}}],[\"并且能将java对象自动的序列化为json字符串\",{\"1\":{\"1041\":1}}],[\"并且将不同数据类型的操作api封装到了不同的类型中\",{\"1\":{\"1036\":1}}],[\"并且将value设置为空\",{\"1\":{\"985\":1}}],[\"并且使用的还是连接池对象\",{\"1\":{\"1035\":1}}],[\"并且频繁的创建和销毁连接会有性能损耗\",{\"1\":{\"1033\":1}}],[\"并且指定有效期\",{\"1\":{\"1025\":1}}],[\"并且不能自定义仓库名称\",{\"1\":{\"1021\":1}}],[\"并且不必为每个连接都创建一个线程\",{\"1\":{\"332\":1}}],[\"并且可以设置逻辑过期时间\",{\"1\":{\"990\":2}}],[\"并且可以设置ttl过期时间\",{\"1\":{\"990\":2}}],[\"并且可将程序分配到不连续的存储区\",{\"1\":{\"151\":1}}],[\"并且生成token作为redis的key\",{\"1\":{\"967\":1}}],[\"并且把自己的信息存放到第一台服务器的session中\",{\"1\":{\"963\":1}}],[\"并且把内存扩展到磁盘空间\",{\"1\":{\"418\":1}}],[\"并且访问对应的db\",{\"1\":{\"961\":1}}],[\"并且放行\",{\"1\":{\"959\":1,\"967\":1}}],[\"并且放在索引组合顺序的最后\",{\"1\":{\"266\":1}}],[\"并且需要思考如何建立映射才能对性能更好\",{\"1\":{\"926\":1}}],[\"并且当我们要对这个索引中的文档进行索引\",{\"1\":{\"922\":1}}],[\"并且线程太多\",{\"1\":{\"876\":1}}],[\"并且一旦工人负责了某个\",{\"1\":{\"837\":1}}],[\"并且没有\",{\"1\":{\"827\":1}}],[\"并且没有任何性能影响和空间的浪费\",{\"1\":{\"101\":1}}],[\"并且采用了与\",{\"1\":{\"820\":1}}],[\"并且处理病人的能力提高到了\",{\"1\":{\"805\":1}}],[\"并且遵守两者的契约\",{\"1\":{\"742\":1}}],[\"并且body携带json数据\",{\"1\":{\"731\":1}}],[\"并且content\",{\"1\":{\"731\":1,\"737\":1}}],[\"并且是将函数的返回值直接填入http响应体中\",{\"1\":{\"731\":1}}],[\"并且要求更多功能的场景中\",{\"1\":{\"707\":1}}],[\"并且功能要求不是很严格的场景\",{\"1\":{\"707\":1}}],[\"并且仅会走\",{\"1\":{\"460\":1}}],[\"并且性能和高可用性等各方面表现一般\",{\"1\":{\"433\":1}}],[\"并且redis底层会通过限制删除操作的时常和频率来减少删除操作对cpu的影响\",{\"1\":{\"427\":1}}],[\"并且又再次收到了用户进程的system\",{\"1\":{\"409\":1}}],[\"并且插入时可能造成页分裂\",{\"1\":{\"384\":1}}],[\"并且该字段在多张表中的\",{\"1\":{\"383\":1}}],[\"并且随着数据量的增加所耗费的时间也会增加\",{\"1\":{\"375\":1}}],[\"并且每种存储引擎也不一定支持所有的索引类型\",{\"1\":{\"375\":1}}],[\"并且每个元素只能是\",{\"1\":{\"272\":1}}],[\"并且长时间不能被垃圾收集器收集\",{\"1\":{\"358\":1}}],[\"并且检查这个符号引用代表的类是否已经被加载\",{\"1\":{\"352\":1}}],[\"并且都不是线程安全的\",{\"1\":{\"326\":1}}],[\"并且都不释放\",{\"1\":{\"222\":1}}],[\"并且在服务器的session对象中存储当前用户登录信息\",{\"1\":{\"296\":1}}],[\"并且在等待i\",{\"1\":{\"181\":1}}],[\"并且\",{\"1\":{\"272\":2}}],[\"并且同时5个线程来获取资源\",{\"1\":{\"261\":1}}],[\"并且只会通知一次\",{\"1\":{\"410\":1}}],[\"并且只会装载一次\",{\"1\":{\"101\":1}}],[\"并且只要某个用户修改了该文件数据\",{\"1\":{\"172\":1}}],[\"并且支持随机访问\",{\"1\":{\"169\":1}}],[\"并且支持多个装饰器的嵌套使用\",{\"1\":{\"45\":1}}],[\"并且程序的指令也是顺序的在内存中存放\",{\"1\":{\"161\":1}}],[\"并且为了系统安全\",{\"1\":{\"148\":1}}],[\"并且p\",{\"1\":{\"144\":1}}],[\"并且小于0的时候需要阻塞\",{\"1\":{\"144\":1}}],[\"并且会增大进程的响应时间\",{\"1\":{\"139\":1}}],[\"并且父类修改后\",{\"1\":{\"108\":1}}],[\"并且严格保证实例化顺序\",{\"1\":{\"101\":1}}],[\"并创建\",{\"1\":{\"793\":1}}],[\"并创建singleton类的对象instance\",{\"1\":{\"101\":1}}],[\"并创建对象进行存储\",{\"1\":{\"77\":1}}],[\"并向调用者返回完整的产品类\",{\"1\":{\"49\":1}}],[\"并通过该类进行了字节流和字符流之间的解码转换\",{\"1\":{\"44\":1}}],[\"让sorted\",{\"1\":{\"1030\":1}}],[\"让num值自增2\",{\"1\":{\"1025\":1}}],[\"让一个hash类型key的字段值自增并指定步长\",{\"1\":{\"1027\":1}}],[\"让一个浮点类型的数字自增并指定步长\",{\"1\":{\"1025\":1}}],[\"让一个整型的key自增并指定步长\",{\"1\":{\"1025\":1}}],[\"让一个整型的key自增1\",{\"1\":{\"1025\":1}}],[\"让一个用户只能下一个单\",{\"1\":{\"998\":1}}],[\"让一个或多个死锁进程回退到避免死锁的地步\",{\"1\":{\"150\":1}}],[\"让拦截器生效\",{\"1\":{\"961\":1}}],[\"让这个线程能够被充分利用\",{\"1\":{\"879\":1}}],[\"让消息传递给下一个handler\",{\"1\":{\"798\":1}}],[\"让\",{\"1\":{\"791\":1,\"793\":1,\"794\":1}}],[\"让所有数据包长度固定\",{\"1\":{\"754\":1}}],[\"让reset后回到标记位置\",{\"1\":{\"332\":1}}],[\"让请求线程阻塞\",{\"1\":{\"261\":1}}],[\"让某个线程先结束即可\",{\"1\":{\"222\":1}}],[\"让他们关联同一个guardedobject\",{\"1\":{\"217\":1}}],[\"让新回收的块成为第一个分组\",{\"1\":{\"170\":1}}],[\"让权等待\",{\"1\":{\"140\":1}}],[\"让每一个进程在一定时间间隔内都可以得到响应\",{\"1\":{\"139\":1}}],[\"让用户程序依赖于抽象\",{\"1\":{\"109\":1}}],[\"让computer类依赖抽象\",{\"1\":{\"109\":1}}],[\"让子类决定实例化哪个产品类对象\",{\"1\":{\"67\":1}}],[\"让其子类实现工厂接口\",{\"1\":{\"58\":1}}],[\"让其子类自己决定实例化哪一个工厂类\",{\"1\":{\"58\":1}}],[\"让它们更容易\",{\"1\":{\"45\":1}}],[\"让客户按目标接口的格式访问适配者\",{\"1\":{\"40\":1}}],[\"主分片的拷贝\",{\"1\":{\"928\":1}}],[\"主循环\",{\"1\":{\"791\":1}}],[\"主人把鸡鸭鱼肉的钱都会换为束修金的\",{\"1\":{\"766\":1}}],[\"主线程再走\",{\"1\":{\"993\":1}}],[\"主线程就已经执行完了\",{\"1\":{\"993\":1}}],[\"主线程并没有\",{\"1\":{\"907\":1}}],[\"主线程通过\",{\"1\":{\"807\":1}}],[\"主线程通过get方法可以等待其他线程的运行结果\",{\"1\":{\"262\":1}}],[\"主线程可能会发生阻塞\",{\"1\":{\"437\":1}}],[\"主从数据一致\",{\"1\":{\"1008\":1}}],[\"主从切换导致缓存雪崩具体场景\",{\"0\":{\"437\":1}}],[\"主从模式\",{\"0\":{\"432\":1}}],[\"主键的设计至少应该是全局唯一且是单调递增\",{\"1\":{\"392\":1}}],[\"主键如何设计\",{\"0\":{\"390\":1}}],[\"主键索引和全文索引\",{\"1\":{\"382\":1}}],[\"主键索引名为pk字段名\",{\"1\":{\"265\":1}}],[\"主键或者唯一索引\",{\"1\":{\"266\":1}}],[\"主动更新\",{\"1\":{\"980\":1}}],[\"主动清理策略再redis4\",{\"1\":{\"429\":1}}],[\"主动加入到队列等待唤醒\",{\"1\":{\"258\":1}}],[\"主动放弃处理机\",{\"1\":{\"143\":1}}],[\"主机要浪费很多时间来等待设备\",{\"1\":{\"184\":1}}],[\"主机速度很快\",{\"1\":{\"184\":1}}],[\"主机直接从i\",{\"1\":{\"184\":1}}],[\"主要原因是在于我们对key设置了过期时间\",{\"1\":{\"987\":1}}],[\"主要\",{\"1\":{\"928\":1}}],[\"主要有两方面的原因\",{\"1\":{\"927\":1}}],[\"主要有以下功能\",{\"1\":{\"433\":1}}],[\"主要对写回结果进行加工\",{\"1\":{\"816\":1}}],[\"主要任务是执行死循环\",{\"1\":{\"791\":1}}],[\"主要用来读取客户端数据\",{\"1\":{\"816\":1}}],[\"主要用在阻塞\",{\"1\":{\"775\":1}}],[\"主要用于与自增后的序列号进行位与\",{\"1\":{\"441\":1}}],[\"主要用于判断是否同一毫秒\",{\"1\":{\"441\":1}}],[\"主要用于实现条件锁\",{\"1\":{\"254\":1}}],[\"主要用于实现读写锁\",{\"1\":{\"252\":1}}],[\"主要提供ioc依赖注入功能的支持\",{\"1\":{\"705\":1}}],[\"主要的作用是同步协调在多线程的等待于唤醒问题\",{\"1\":{\"993\":1}}],[\"主要的\",{\"1\":{\"449\":1}}],[\"主要的流程步骤如下\",{\"1\":{\"315\":1}}],[\"主要基于以下奇数以及数据结构\",{\"1\":{\"393\":1}}],[\"主要抓住两点\",{\"1\":{\"359\":1}}],[\"主要是因为内存数据宝贵\",{\"1\":{\"980\":1}}],[\"主要是因为当多个线程操作同一个对象的时候存在共享资源竞争的问题\",{\"1\":{\"712\":1}}],[\"主要是存在于浏览器端的缓存\",{\"1\":{\"976\":1}}],[\"主要是探活的作用\",{\"1\":{\"314\":1}}],[\"主要是实现抽象工厂中的多个抽象方法\",{\"1\":{\"73\":1}}],[\"主要是实现抽象工厂中的抽象方法\",{\"1\":{\"68\":1}}],[\"主要包括\",{\"1\":{\"183\":1}}],[\"主要实现的功能\",{\"1\":{\"182\":1}}],[\"主要追求存储空间的利用率\",{\"1\":{\"153\":1}}],[\"主要解决接口选择的问题\",{\"1\":{\"58\":1}}],[\"主要解决\",{\"1\":{\"58\":1}}],[\"主要为控制访问\",{\"1\":{\"45\":1}}],[\"主页\",{\"0\":{\"17\":1}}],[\"桥接模式将接口部分和实现部分分离\",{\"1\":{\"45\":1}}],[\"桥接\",{\"0\":{\"45\":1}}],[\"代金券id\",{\"1\":{\"995\":1,\"998\":3}}],[\"代表只使用1个库\",{\"1\":{\"1015\":1}}],[\"代表实际写入字节数\",{\"1\":{\"893\":1}}],[\"代表了上一级路径\",{\"1\":{\"871\":1}}],[\"代表了当前路径\",{\"1\":{\"871\":1}}],[\"代表了\",{\"1\":{\"871\":2}}],[\"代表着整体中某一段的数据\",{\"1\":{\"829\":1}}],[\"代表着各类所有公共\",{\"1\":{\"721\":1}}],[\"代表关注\",{\"1\":{\"790\":1}}],[\"代表这个方法将启用事务功能\",{\"1\":{\"721\":1}}],[\"代表环绕通知\",{\"1\":{\"528\":1}}],[\"代表每毫秒内可产生最大序列号\",{\"1\":{\"441\":1}}],[\"代价是一个代理类配两个\",{\"1\":{\"527\":1}}],[\"代售点\",{\"1\":{\"93\":1}}],[\"代售点是代理对象\",{\"1\":{\"93\":1}}],[\"代理增强\",{\"1\":{\"711\":1}}],[\"代理增强是借助多态来实现\",{\"1\":{\"516\":1}}],[\"代理与目标是两个对象\",{\"1\":{\"686\":1}}],[\"代理的设计特点\",{\"1\":{\"686\":1}}],[\"代理的创建时机\",{\"1\":{\"542\":1}}],[\"代理进一步理解\",{\"0\":{\"683\":1}}],[\"代理进阶\",{\"0\":{\"520\":1}}],[\"代理方法执行时会做如下工作\",{\"1\":{\"549\":1}}],[\"代理创建时机\",{\"0\":{\"540\":1}}],[\"代理创建器\",{\"0\":{\"537\":1}}],[\"代理相关类图\",{\"1\":{\"528\":1}}],[\"代理一点都不难\",{\"1\":{\"516\":1}}],[\"代理服务器再把它转给你的浏览器\",{\"1\":{\"98\":1}}],[\"代理类中还得增加仅调用\",{\"1\":{\"527\":1}}],[\"代理类的源码\",{\"1\":{\"515\":1}}],[\"代理类$proxy0\",{\"1\":{\"515\":1}}],[\"代理类\",{\"1\":{\"94\":3}}],[\"代理对象调用流程如下\",{\"1\":{\"546\":1}}],[\"代理对象调用接口方法时传递的实际参数\",{\"1\":{\"94\":1}}],[\"代理对象虽然还是同一个\",{\"1\":{\"500\":1}}],[\"代理对象可以扩展目标对象的功能\",{\"1\":{\"97\":1}}],[\"代理对象中的方法的method实例\",{\"1\":{\"95\":1}}],[\"代理对象\",{\"1\":{\"94\":1,\"95\":1,\"510\":1,\"512\":1}}],[\"代理对象的调用处理程序\",{\"1\":{\"94\":1}}],[\"代理对象作为访问对象和目标对象之间的中介\",{\"1\":{\"91\":1}}],[\"代理工厂类\",{\"1\":{\"94\":1}}],[\"代理工厂\",{\"1\":{\"94\":1,\"95\":1}}],[\"代理点收取一些服务费用\",{\"1\":{\"93\":2,\"94\":2,\"95\":1}}],[\"代理模式能将客户端与目标对象分离\",{\"1\":{\"97\":1}}],[\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用\",{\"1\":{\"97\":1}}],[\"代理模式真实对象和代理对象实现相同的接口\",{\"1\":{\"94\":1}}],[\"代理模式\",{\"0\":{\"90\":1}}],[\"代理模式不改变原始类接口的条件下\",{\"1\":{\"45\":1}}],[\"代理\",{\"0\":{\"45\":1,\"512\":1,\"521\":1,\"684\":1},\"1\":{\"92\":2,\"98\":3,\"531\":1,\"787\":1}}],[\"代码说明\",{\"1\":{\"1034\":1,\"1035\":1}}],[\"代码分析\",{\"1\":{\"983\":1}}],[\"代码思路\",{\"1\":{\"979\":1}}],[\"代码解读\",{\"1\":{\"834\":1,\"835\":1}}],[\"代码略\",{\"1\":{\"791\":2}}],[\"代码改为\",{\"1\":{\"750\":1}}],[\"代码参考项目\",{\"1\":{\"505\":1,\"507\":1}}],[\"代码参考\",{\"0\":{\"448\":1,\"453\":1,\"456\":1,\"460\":1,\"465\":1,\"469\":1,\"472\":1,\"476\":1,\"479\":1,\"482\":1,\"485\":1,\"489\":1,\"494\":1,\"498\":1,\"502\":1,\"518\":1,\"522\":1,\"526\":1,\"530\":1,\"534\":1,\"538\":1,\"541\":1,\"544\":1,\"548\":1,\"551\":1,\"555\":1,\"560\":1,\"563\":1,\"567\":1,\"571\":1,\"578\":1,\"581\":1,\"584\":1,\"595\":1,\"599\":1,\"603\":1,\"607\":1,\"611\":1,\"615\":1,\"634\":1,\"677\":1,\"681\":1,\"685\":1,\"690\":1,\"694\":1,\"698\":1,\"702\":1}}],[\"代码中创建了大量大对象\",{\"1\":{\"358\":1}}],[\"代码模拟stampedlock读和写的过程\",{\"1\":{\"260\":1}}],[\"代码模板\",{\"0\":{\"187\":1}}],[\"代码演示\",{\"1\":{\"221\":1}}],[\"代码我们只需要修改computer类\",{\"1\":{\"109\":1}}],[\"代码的可读性及使用的成本就是比较高\",{\"1\":{\"52\":1}}],[\"代码可读性会非常差\",{\"1\":{\"52\":1}}],[\"代码结构相似\",{\"1\":{\"45\":1}}],[\"代码如下所示\",{\"1\":{\"277\":1}}],[\"代码如下\",{\"0\":{\"979\":1},\"1\":{\"41\":1,\"42\":1,\"65\":1,\"69\":1,\"74\":1,\"86\":1,\"87\":1,\"89\":2,\"93\":1,\"94\":1,\"95\":1,\"109\":1,\"110\":1,\"111\":1,\"120\":1,\"1041\":1}}],[\"代码\",{\"0\":{\"19\":1,\"972\":1},\"1\":{\"17\":1,\"837\":1,\"871\":1}}],[\"代码复现\",{\"0\":{\"7\":1,\"14\":1,\"32\":1}}],[\"代码实战\",{\"1\":{\"3\":1}}],[\"从表结构上也能看出\",{\"1\":{\"994\":1}}],[\"从表层来看\",{\"1\":{\"44\":1}}],[\"从redis查询商铺缓存\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":3}}],[\"从redis获取验证码并校验\",{\"1\":{\"968\":1}}],[\"从redis中取出token对应的value\",{\"1\":{\"967\":1}}],[\"从内核态切换回用户态\",{\"1\":{\"904\":1}}],[\"从source\",{\"1\":{\"859\":1}}],[\"从slave角度来看\",{\"1\":{\"437\":1}}],[\"从尾部开始查找出站处理器\",{\"1\":{\"816\":1}}],[\"从尾部开始触发\",{\"1\":{\"816\":1}}],[\"从tail向上找出站处理器\",{\"1\":{\"816\":1}}],[\"从当前位置向上找出站处理器\",{\"1\":{\"816\":1}}],[\"从当前位置开始扫描到第一个\",{\"1\":{\"163\":1}}],[\"从三个方法中选择合适的方法\",{\"1\":{\"738\":1}}],[\"从源码得知\",{\"1\":{\"731\":1}}],[\"从本质上来说\",{\"1\":{\"726\":1}}],[\"从配置中获取重要的事件发布器\",{\"1\":{\"652\":1}}],[\"从\",{\"0\":{\"536\":1,\"853\":1},\"1\":{\"546\":1,\"847\":1,\"890\":2}}],[\"从输出日志可以看到调用\",{\"1\":{\"500\":1}}],[\"从磁盘路径查找\",{\"1\":{\"451\":1}}],[\"从磁盘读出或向磁盘写入数据所经历的时间\",{\"1\":{\"176\":1}}],[\"从类路径查找\",{\"1\":{\"451\":1}}],[\"从数据集中任意选择数据淘汰\",{\"1\":{\"429\":1}}],[\"从数学角度推导\",{\"1\":{\"195\":1}}],[\"从已设置过期时间的数据集中挑选最不经常使用的数据淘汰\",{\"1\":{\"429\":1}}],[\"从已设置过期时间的数据集中挑选即将要过期的数据淘汰\",{\"1\":{\"429\":1}}],[\"从已设置过期时间的数据集中任意选择数据淘汰\",{\"1\":{\"429\":1}}],[\"从已设置过期时间的数据集\",{\"1\":{\"429\":1}}],[\"从进程发出指定逻辑地址的访问请求\",{\"1\":{\"413\":1}}],[\"从kernel的角度\",{\"1\":{\"409\":1}}],[\"从用户进程角度讲\",{\"1\":{\"409\":1}}],[\"从性能上来说\",{\"1\":{\"394\":1}}],[\"从物理实现方式\",{\"1\":{\"382\":1}}],[\"从功能逻辑上说\",{\"1\":{\"382\":1}}],[\"从虚拟机的角度来看\",{\"1\":{\"352\":1}}],[\"从文件中\",{\"1\":{\"351\":1}}],[\"从文件中读取对象\",{\"1\":{\"103\":1}}],[\"从流中排除某些元素\",{\"1\":{\"338\":1}}],[\"从jdk1\",{\"1\":{\"332\":1}}],[\"从主人公的起起落落\",{\"1\":{\"306\":1}}],[\"从动手能力和自学能力上入手\",{\"1\":{\"301\":1}}],[\"从原理上也解释的通\",{\"1\":{\"300\":1}}],[\"从原始人口数据表中筛选出符合常驻人口条件的去重数据到常住人口表中\",{\"1\":{\"296\":1}}],[\"从2020年开始国家开始逐步推行强制垃圾分类\",{\"1\":{\"300\":1}}],[\"从应用角度来说\",{\"1\":{\"298\":1}}],[\"从别人的代码中进行学习\",{\"1\":{\"297\":1}}],[\"从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点\",{\"1\":{\"270\":1}}],[\"从任务管理器可以看出操作系统对硬件和软件资源的分配\",{\"1\":{\"125\":1}}],[\"从每个叶子到根的所有路径上不能有两个连续的红节点\",{\"1\":{\"270\":1}}],[\"从右向左迁移bin\",{\"1\":{\"249\":1}}],[\"从0开始\",{\"1\":{\"190\":1}}],[\"从何处调入页面\",{\"1\":{\"164\":1}}],[\"从逻辑上扩充了内存的容量\",{\"1\":{\"161\":1}}],[\"从中找到一个满足条件的分区\",{\"1\":{\"154\":1}}],[\"从写程序到程序运行\",{\"1\":{\"151\":1}}],[\"从作业被提交到系统开始\",{\"1\":{\"138\":1}}],[\"从就绪队列中按照一定的算法选中一个进程并将处理机分配给它运行\",{\"1\":{\"136\":1}}],[\"从pcb恢复运行环境\",{\"1\":{\"133\":1}}],[\"从下往上看\",{\"1\":{\"125\":1,\"126\":1}}],[\"从父类继承而来的实现是静态的\",{\"1\":{\"112\":1}}],[\"从硬盘中获取的数据为\",{\"1\":{\"109\":1}}],[\"从而节约我们的内存空间\",{\"1\":{\"1042\":1}}],[\"从而避免对于数据库访问压力过大\",{\"1\":{\"987\":1}}],[\"从而避免数据库和缓存不一致的问题\",{\"1\":{\"983\":1}}],[\"从而避免了长作业饥饿问题\",{\"1\":{\"139\":1}}],[\"从而影响业务\",{\"1\":{\"981\":1}}],[\"从而确保整体应用是在正常有序的状态下退出的\",{\"1\":{\"797\":1}}],[\"从而回调\",{\"1\":{\"790\":1}}],[\"从而将相关bean加入到ioc容器中\",{\"1\":{\"708\":1}}],[\"从而会形成碎片\",{\"1\":{\"413\":1}}],[\"从而保证数据操作的排他性\",{\"1\":{\"397\":1}}],[\"从而满足了持久性要求\",{\"1\":{\"396\":1}}],[\"从而判断数据对该readview是否可见\",{\"1\":{\"393\":1}}],[\"从而形成一条版本链\",{\"1\":{\"393\":1}}],[\"从而引起\",{\"1\":{\"280\":1}}],[\"从而有效节省内存空间\",{\"1\":{\"277\":1}}],[\"从而出现内存泄漏\",{\"1\":{\"247\":1}}],[\"从而提高性能\",{\"1\":{\"234\":1}}],[\"从而提高软件开发效率\",{\"1\":{\"106\":1}}],[\"从而很方便的实现了进程互斥\",{\"1\":{\"143\":1}}],[\"从而可以构造出复杂的对象\",{\"1\":{\"47\":1}}],[\"从上往下看\",{\"1\":{\"125\":1,\"126\":1}}],[\"从上面看\",{\"1\":{\"410\":1}}],[\"从上面类图我们可以看到使用继承复用产生了很多子类\",{\"1\":{\"112\":1}}],[\"从上面源代码中可以看出runtime类使用的是饿汉式\",{\"1\":{\"105\":1}}],[\"从上面代码可以看到\",{\"1\":{\"123\":1}}],[\"从上面代码我们可以看出\",{\"1\":{\"101\":1}}],[\"从上面代码我们可以看出该方式在成员位置声明singleton类型的静态变量\",{\"1\":{\"101\":1}}],[\"从上面代码中可以看出测试类直接访问的是proxypoint类对象\",{\"1\":{\"93\":1}}],[\"从上面的类中\",{\"1\":{\"94\":1}}],[\"从上图可以看出\",{\"1\":{\"44\":1}}],[\"从以上的编写的代码可以看到\",{\"1\":{\"69\":1}}],[\"从软件设计上\",{\"1\":{\"52\":1}}],[\"实战\",{\"0\":{\"951\":1}}],[\"实战版\",{\"1\":{\"738\":1}}],[\"实验如下\",{\"1\":{\"803\":1}}],[\"实施垃圾分类也是为了响应低碳减排的号召\",{\"1\":{\"300\":1}}],[\"实习中学到了什么\",{\"0\":{\"299\":1}}],[\"实时操作系统\",{\"1\":{\"137\":1}}],[\"实际开发过程中\",{\"1\":{\"975\":1}}],[\"实际开发中\",{\"1\":{\"974\":1,\"976\":1}}],[\"实际不是物理设备级别的读写\",{\"1\":{\"904\":1}}],[\"实际写入字节\",{\"1\":{\"893\":2}}],[\"实际传输一个超大文件\",{\"1\":{\"870\":1}}],[\"实际读到了数据\",{\"1\":{\"794\":1}}],[\"实际内容\",{\"1\":{\"766\":1}}],[\"实际每次读取的一般是它的整数倍\",{\"1\":{\"750\":1}}],[\"实际应用中很少使用\",{\"1\":{\"719\":1}}],[\"实际是通过aop实现的\",{\"1\":{\"719\":1}}],[\"实际是事件发布器\",{\"1\":{\"650\":1}}],[\"实际是被作为\",{\"1\":{\"486\":1}}],[\"实际的\",{\"1\":{\"535\":1}}],[\"实际的方法实现是对sun\",{\"1\":{\"44\":1}}],[\"实际中\",{\"1\":{\"409\":1}}],[\"实际上写入的就是旧的数据\",{\"1\":{\"982\":1}}],[\"实际上是\",{\"1\":{\"790\":1}}],[\"实际上是在设定规范和契约\",{\"1\":{\"108\":1}}],[\"实际上控制反转\",{\"1\":{\"449\":1}}],[\"实际上\",{\"1\":{\"407\":1}}],[\"实际上并不是锁\",{\"1\":{\"231\":1}}],[\"实际并不是\",{\"1\":{\"230\":1}}],[\"实际用于进程推进的时间很少\",{\"1\":{\"164\":1}}],[\"实际参数\",{\"1\":{\"95\":1}}],[\"实例化该autoconfiguration类中定义的bean\",{\"1\":{\"730\":1}}],[\"实例化后执行\",{\"1\":{\"711\":1}}],[\"实例化后执行的方法\",{\"1\":{\"711\":1}}],[\"实例化前执行\",{\"1\":{\"711\":1}}],[\"实例化前\",{\"1\":{\"711\":1}}],[\"实例创建后\",{\"1\":{\"542\":1}}],[\"实例对象\",{\"1\":{\"458\":1}}],[\"实例数据\",{\"1\":{\"353\":1}}],[\"实例\",{\"0\":{\"49\":1},\"1\":{\"94\":1,\"820\":2,\"831\":1,\"871\":1}}],[\"实现数据的crud了\",{\"1\":{\"1017\":1}}],[\"实现秒杀下单\",{\"0\":{\"995\":1}}],[\"实现缓存重建\",{\"1\":{\"990\":1}}],[\"实现复杂\",{\"1\":{\"984\":1}}],[\"实现商铺和缓存与数据库双写一致\",{\"0\":{\"983\":1}}],[\"实现最终一致\",{\"1\":{\"981\":1}}],[\"实现登录拦截功能\",{\"0\":{\"961\":1}}],[\"实现发送短信验证码功能\",{\"0\":{\"960\":1}}],[\"实现多路复用\",{\"1\":{\"900\":1}}],[\"实现一个\",{\"1\":{\"844\":1}}],[\"实现一个热插拔的效果\",{\"1\":{\"107\":1}}],[\"实现类\",{\"1\":{\"834\":1,\"835\":1}}],[\"实现类中的就绪事件集合替换为\",{\"1\":{\"792\":1}}],[\"实现来讲\",{\"1\":{\"825\":1}}],[\"实现拦截时需要执行的具体业务逻辑\",{\"1\":{\"738\":1}}],[\"实现handlerinterceptor接口\",{\"1\":{\"738\":1}}],[\"实现组件重用\",{\"1\":{\"612\":1}}],[\"实现组件之间的解耦\",{\"1\":{\"446\":1}}],[\"实现增强\",{\"1\":{\"506\":1,\"508\":1}}],[\"实现之\",{\"0\":{\"505\":1,\"507\":1,\"509\":1}}],[\"实现都\",{\"1\":{\"449\":1}}],[\"实现虚拟地址向物理地址的转换\",{\"1\":{\"419\":1}}],[\"实现离散分配\",{\"1\":{\"413\":1}}],[\"实现原子性的关键\",{\"1\":{\"396\":1}}],[\"实现clone\",{\"1\":{\"351\":1}}],[\"实现用户登陆的验证接口\",{\"1\":{\"296\":1}}],[\"实现的\",{\"1\":{\"276\":1}}],[\"实现的细节也依赖于抽象\",{\"1\":{\"109\":1}}],[\"实现方法\",{\"1\":{\"163\":1}}],[\"实现方式\",{\"1\":{\"41\":1,\"42\":1}}],[\"实现保护与实现共享的原因相似\",{\"1\":{\"159\":1}}],[\"实现共享\",{\"1\":{\"159\":1}}],[\"实现起来比较复杂\",{\"1\":{\"148\":1}}],[\"实现互斥的p操作在实现同步的p操作之前\",{\"1\":{\"147\":1}}],[\"实现进程同步与互斥\",{\"1\":{\"145\":1}}],[\"实现进程状态转换\",{\"1\":{\"133\":1}}],[\"实现简单\",{\"1\":{\"137\":1,\"142\":2,\"154\":2,\"181\":1,\"984\":1}}],[\"实现操作系统的内核功能的程序就是内核程序\",{\"1\":{\"128\":1}}],[\"实现对硬件机器的拓展\",{\"1\":{\"126\":1}}],[\"实现子类对父类的反向控制\",{\"1\":{\"122\":1}}],[\"实现抽象类中所定义的抽象方法和钩子方法\",{\"1\":{\"119\":1}}],[\"实现抽象原型类的\",{\"1\":{\"85\":1}}],[\"实现了真正的异步\",{\"1\":{\"906\":1}}],[\"实现了调节发布者发布数据的速率\",{\"1\":{\"745\":1}}],[\"实现了\",{\"1\":{\"466\":2,\"796\":1}}],[\"实现了某个接口就有了相应的行为\",{\"1\":{\"317\":1}}],[\"实现了对各类型人员行动规律的分析\",{\"1\":{\"298\":1}}],[\"实现了懒惰初始化\",{\"1\":{\"249\":1}}],[\"实现了反向控制\",{\"1\":{\"121\":2}}],[\"实现了selltickets\",{\"1\":{\"94\":1}}],[\"实现了抽象主题中的具体业务\",{\"1\":{\"92\":1}}],[\"实现了抽象产品角色所定义的接口\",{\"1\":{\"68\":1,\"73\":1}}],[\"实现了更好的复用\",{\"1\":{\"47\":1}}],[\"实现或者继承抽象产品的子类\",{\"1\":{\"62\":1}}],[\"实现\",{\"0\":{\"63\":1,\"69\":1,\"74\":1,\"86\":1,\"455\":1,\"950\":1},\"1\":{\"48\":1,\"133\":1,\"142\":1,\"155\":4,\"528\":1,\"699\":1,\"773\":2,\"825\":1}}],[\"实现所有方法\",{\"1\":{\"42\":1}}],[\"如图\",{\"1\":{\"1014\":1,\"1042\":1}}],[\"如图所示\",{\"1\":{\"273\":1}}],[\"如粘包\",{\"1\":{\"842\":1}}],[\"如事务处理\",{\"1\":{\"706\":1}}],[\"如最大\",{\"1\":{\"660\":1}}],[\"如本例\",{\"1\":{\"539\":1}}],[\"如代理增强\",{\"1\":{\"460\":1}}],[\"如上图所示\",{\"1\":{\"409\":1}}],[\"如上代码中的sd\",{\"1\":{\"44\":1}}],[\"如硬盘读写操作完成\",{\"1\":{\"406\":1}}],[\"如缺页异常\",{\"1\":{\"406\":1}}],[\"如linux的\",{\"1\":{\"406\":1}}],[\"如desc\",{\"1\":{\"265\":1}}],[\"如读写文件\",{\"1\":{\"208\":1}}],[\"如释放锁\",{\"1\":{\"206\":1}}],[\"如read\",{\"1\":{\"182\":2}}],[\"如显示该目录中的所有文件及相应的属性\",{\"1\":{\"168\":1}}],[\"如cpu\",{\"1\":{\"148\":1}}],[\"如100ms\",{\"1\":{\"139\":1}}],[\"如p\",{\"1\":{\"134\":1}}],[\"如修改进程状态标志\",{\"1\":{\"133\":1}}],[\"如存储分配\",{\"1\":{\"130\":1}}],[\"如程序状态字\",{\"1\":{\"129\":1}}],[\"如0表示用户态\",{\"1\":{\"128\":1}}],[\"如内存清零指令\",{\"1\":{\"128\":1}}],[\"如下所示\",{\"1\":{\"277\":1}}],[\"如下图\",{\"1\":{\"276\":1,\"280\":2,\"965\":1}}],[\"如下表\",{\"1\":{\"265\":1}}],[\"如下\",{\"1\":{\"123\":1,\"805\":1,\"829\":1,\"998\":1}}],[\"如和粉丝的见面会\",{\"1\":{\"111\":1}}],[\"如intel\",{\"1\":{\"109\":1}}],[\"如何保证缓存与数据库的操作的同时成功或失败\",{\"1\":{\"982\":1}}],[\"如何保证不同的用户对文件由不同的操作权限\",{\"1\":{\"166\":1}}],[\"如何使用缓存\",{\"0\":{\"976\":1}}],[\"如何拿到\",{\"0\":{\"897\":1}}],[\"如何改进呢\",{\"1\":{\"896\":1}}],[\"如何写入后数据大小未超过\",{\"1\":{\"823\":1}}],[\"如何设计协议呢\",{\"1\":{\"766\":1}}],[\"如何走出人生的艰难时刻\",{\"1\":{\"731\":1}}],[\"如何拥有高质量的关系\",{\"1\":{\"731\":1}}],[\"如何让心智变得更成熟\",{\"1\":{\"731\":1}}],[\"如何养成一个新习惯\",{\"1\":{\"731\":1}}],[\"如何读取\",{\"1\":{\"652\":1}}],[\"如何工作\",{\"1\":{\"623\":1}}],[\"如何避免反射\",{\"0\":{\"525\":1}}],[\"如何将逻辑地址转换为物理地址\",{\"1\":{\"413\":1}}],[\"如何选择\",{\"1\":{\"604\":1}}],[\"如何选择需要看表的大小\",{\"1\":{\"386\":1}}],[\"如何选择合适的垃圾收集算法\",{\"1\":{\"355\":1}}],[\"如何从海量数据中找出高频词\",{\"0\":{\"288\":1},\"1\":{\"288\":1}}],[\"如何在磁盘中读\",{\"1\":{\"175\":1}}],[\"如何回收\",{\"1\":{\"170\":1}}],[\"如何实现\",{\"1\":{\"829\":1}}],[\"如何实现栈\",{\"1\":{\"740\":1}}],[\"如何实现的\",{\"1\":{\"236\":1}}],[\"如何实现文件的逻辑块号到物理块号的转换\",{\"1\":{\"169\":1}}],[\"如何实现虚拟内存技术\",{\"1\":{\"161\":1}}],[\"如何实现进程控制\",{\"1\":{\"133\":1}}],[\"如何进行处理呢\",{\"1\":{\"617\":1}}],[\"如何进行空闲块的分配\",{\"1\":{\"170\":1}}],[\"如何进行回收\",{\"1\":{\"154\":1}}],[\"如何进行分配\",{\"1\":{\"154\":1}}],[\"如何进行分区的分配和回收操作\",{\"1\":{\"154\":1}}],[\"如何区分各个程序的数据在内存的什么地方\",{\"1\":{\"151\":1}}],[\"如何合理的设置各类进程的优先级\",{\"1\":{\"139\":1}}],[\"如何正确的使用继承\",{\"1\":{\"108\":1}}],[\"如何解决\",{\"1\":{\"58\":1,\"169\":1}}],[\"如有人只喜欢穿某一个品牌的衣服和鞋\",{\"1\":{\"76\":1}}],[\"如电器工厂中的电视机\",{\"1\":{\"76\":1}}],[\"如电器厂既生产电视机又生产洗衣机或空调\",{\"1\":{\"71\":1}}],[\"如提拉米苏\",{\"1\":{\"74\":1}}],[\"如畜牧场只养动物\",{\"1\":{\"71\":1}}],[\"如要制造一个超人\",{\"1\":{\"54\":1}}],[\"如\",{\"1\":{\"44\":1,\"76\":1,\"137\":1,\"167\":1,\"183\":1,\"266\":2,\"383\":1,\"446\":1,\"460\":3,\"561\":2,\"678\":1,\"711\":4,\"835\":1,\"842\":1,\"926\":1}}],[\"如果操作存在的数据\",{\"1\":{\"1027\":1}}],[\"如果操作不存在的数据\",{\"1\":{\"1027\":1}}],[\"如果value是一个java对象\",{\"1\":{\"1026\":1}}],[\"如果key不存在\",{\"1\":{\"1025\":1}}],[\"如果key不存在则是新增\",{\"1\":{\"1025\":1}}],[\"如果kernel中的数据还没有准备好\",{\"1\":{\"409\":1}}],[\"如果做水平扩展会给数据查询带来很多麻烦\",{\"1\":{\"1008\":1}}],[\"如果下过这个订单\",{\"1\":{\"998\":1}}],[\"如果获取某个值\",{\"1\":{\"997\":1}}],[\"如果获取到了锁的线程\",{\"1\":{\"988\":1}}],[\"如果预估值\",{\"1\":{\"996\":1}}],[\"如果预计三年后数据量根本达不到这个级别\",{\"1\":{\"265\":1}}],[\"如果大1\",{\"1\":{\"996\":1}}],[\"如果大量的请求同时过来访问这种不存在的数据\",{\"1\":{\"984\":1}}],[\"如果时间充足\",{\"1\":{\"995\":1,\"998\":1}}],[\"如果时间片太小\",{\"1\":{\"139\":1}}],[\"如果时间片太大\",{\"1\":{\"139\":1}}],[\"如果尚未开始或已经结束则无法下单\",{\"1\":{\"995\":1}}],[\"如果封装数据\",{\"1\":{\"989\":1}}],[\"如果失败\",{\"1\":{\"988\":1}}],[\"如果失去共享性\",{\"1\":{\"127\":1}}],[\"如果失去并发性\",{\"1\":{\"127\":1}}],[\"如果从缓存没有查询到数据\",{\"1\":{\"988\":1}}],[\"如果布隆过滤器判断存在\",{\"1\":{\"984\":1}}],[\"如果缓存未命中\",{\"1\":{\"983\":1}}],[\"如果缓存不存在\",{\"1\":{\"979\":1}}],[\"如果缓存有\",{\"1\":{\"979\":1}}],[\"如果缓存数据不存在\",{\"1\":{\"978\":1}}],[\"如果缓存数据存在\",{\"1\":{\"978\":1}}],[\"如果小伙伴们看过threadlocal的源码\",{\"1\":{\"961\":1}}],[\"如果手机号合法\",{\"1\":{\"959\":1}}],[\"如果作为附件的\",{\"1\":{\"909\":1}}],[\"如果工作在\",{\"1\":{\"897\":1}}],[\"如果所有的数据写完了\",{\"1\":{\"893\":1}}],[\"如果内容过大\",{\"1\":{\"890\":1}}],[\"如果内存规整\",{\"1\":{\"352\":1}}],[\"如果内存中没有空闲块\",{\"1\":{\"162\":1}}],[\"如果内存中有空闲块\",{\"1\":{\"162\":1}}],[\"如果内存中空闲空间的总和本来可以满足某进程的要求\",{\"1\":{\"154\":1}}],[\"如果连接数过多\",{\"1\":{\"876\":1}}],[\"如果连续出现丢包\",{\"1\":{\"764\":1}}],[\"如果文件不存在\",{\"1\":{\"872\":1}}],[\"如果文件已存在\",{\"1\":{\"872\":1}}],[\"如果希望用\",{\"1\":{\"872\":1}}],[\"如果设置为文件的末尾\",{\"1\":{\"867\":1}}],[\"如果设备就绪则在设备等待队列中加入一项并继续遍历\",{\"1\":{\"410\":1}}],[\"如果原始\",{\"1\":{\"826\":1}}],[\"如果执行\",{\"1\":{\"826\":1}}],[\"如果执行了程序中的某条指令\",{\"1\":{\"161\":1}}],[\"如果计数为\",{\"1\":{\"825\":1}}],[\"如果计算机按字节编址\",{\"1\":{\"151\":1}}],[\"如果写入后数据大小超过\",{\"1\":{\"823\":1}}],[\"如果改为\",{\"1\":{\"816\":2}}],[\"如果注释掉\",{\"1\":{\"816\":4}}],[\"如果期间又有\",{\"1\":{\"792\":1}}],[\"如果超时\",{\"1\":{\"792\":2}}],[\"如果超出指定长度仍未出现分隔符\",{\"1\":{\"755\":1}}],[\"如果线程由于\",{\"1\":{\"791\":1}}],[\"如果已经存在则更新其score值\",{\"1\":{\"1030\":1}}],[\"如果已经\",{\"1\":{\"791\":1}}],[\"如果已经完成\",{\"1\":{\"790\":1}}],[\"如果已存在一个事务\",{\"1\":{\"720\":1}}],[\"如果能确保编解码器不会保存状态\",{\"1\":{\"771\":1}}],[\"如果能收到客户端数据\",{\"1\":{\"764\":1}}],[\"如果登录失败\",{\"1\":{\"759\":1}}],[\"如果登录成功\",{\"1\":{\"759\":1}}],[\"如果组不存在返回\",{\"1\":{\"758\":3}}],[\"如果为\",{\"1\":{\"791\":1}}],[\"如果为true\",{\"1\":{\"738\":1}}],[\"如果为false\",{\"1\":{\"738\":1}}],[\"如果匹配dispatcherservlet的请求路径\",{\"1\":{\"736\":1}}],[\"如果你在方法内部加锁\",{\"1\":{\"998\":1}}],[\"如果你选择第一种方案\",{\"1\":{\"982\":1}}],[\"如果你的集群中至少有两个节点\",{\"1\":{\"928\":1}}],[\"如果你的方法必须要用两个\",{\"1\":{\"731\":1}}],[\"如果你想要最小化gc的中断或停顿时间\",{\"1\":{\"361\":1}}],[\"如果你想要最小化地使用内存和并行开销\",{\"1\":{\"361\":1}}],[\"如果你想要最大化应用程序的吞吐量\",{\"1\":{\"361\":1}}],[\"如果代理对象实现了某个接口\",{\"1\":{\"706\":1}}],[\"如果待装配类型有\",{\"1\":{\"695\":1}}],[\"如果待装配类型有泛型参数\",{\"1\":{\"695\":1}}],[\"如果待装配类型是数组\",{\"1\":{\"695\":1}}],[\"如果待装配类型是\",{\"1\":{\"695\":3}}],[\"如果待装配的成员变量或方法参数上用\",{\"1\":{\"695\":1}}],[\"如果待装配的类型是\",{\"1\":{\"695\":1}}],[\"如果待排序的列有多个\",{\"1\":{\"383\":1}}],[\"如果结果仍\",{\"1\":{\"688\":1}}],[\"如果结果\",{\"1\":{\"688\":1}}],[\"如果自己配置了\",{\"1\":{\"662\":1}}],[\"如果知道数据源的实现类类型\",{\"1\":{\"660\":1}}],[\"如果用户不存在\",{\"1\":{\"959\":1}}],[\"如果用\",{\"1\":{\"648\":1}}],[\"如果用的是runnable则执行的是runnable中的run方法\",{\"1\":{\"202\":1}}],[\"如果返回的\",{\"1\":{\"644\":2}}],[\"如果编译时添加了\",{\"1\":{\"572\":2}}],[\"如果目录还有内容\",{\"1\":{\"872\":1}}],[\"如果目录已存在\",{\"1\":{\"872\":1}}],[\"如果目标是接口类型或已经是\",{\"1\":{\"531\":1}}],[\"如果目前没有可用数据时\",{\"1\":{\"332\":1}}],[\"如果指定了接口\",{\"1\":{\"531\":1}}],[\"如果同一个\",{\"1\":{\"495\":1}}],[\"如果同时考虑这两种分类\",{\"1\":{\"112\":1}}],[\"如果值为0\",{\"1\":{\"441\":1}}],[\"如果值都为\",{\"1\":{\"273\":2}}],[\"如果还是借助数据库主键自增的形式\",{\"1\":{\"439\":1}}],[\"如果还有大进程到来\",{\"1\":{\"155\":1}}],[\"如果发送的事件对象不是\",{\"1\":{\"703\":1}}],[\"如果发现数据不够\",{\"1\":{\"891\":1}}],[\"如果发现\",{\"1\":{\"682\":1}}],[\"如果发现锁这个时候被释放了\",{\"1\":{\"258\":1}}],[\"如果发生在slave节点中\",{\"1\":{\"436\":1}}],[\"如果redis中有大量的key已经过期\",{\"1\":{\"436\":1}}],[\"如果过期\",{\"1\":{\"436\":1,\"989\":1}}],[\"如果故障转移发生了\",{\"1\":{\"433\":1}}],[\"如果master\",{\"1\":{\"433\":1}}],[\"如果master节点异常\",{\"1\":{\"433\":1}}],[\"如果mysql宕机\",{\"1\":{\"396\":2}}],[\"如果mybatis版本低于3\",{\"1\":{\"366\":1}}],[\"如果需执行的指令或访问的数据尚未在内存\",{\"1\":{\"419\":1}}],[\"如果需要重复读取\",{\"1\":{\"824\":1}}],[\"如果需要的值是字符串\",{\"1\":{\"688\":1}}],[\"如果需要扩容\",{\"1\":{\"323\":1}}],[\"如果需要请走搜索引擎来解决\",{\"1\":{\"266\":1}}],[\"如果需要主线程汇总结果\",{\"1\":{\"262\":1}}],[\"如果需要实现双向同时通信\",{\"1\":{\"134\":1}}],[\"如果需要\",{\"1\":{\"98\":1,\"617\":1}}],[\"如果他所要访问的页\",{\"1\":{\"418\":1}}],[\"如果某数据被访问过\",{\"1\":{\"417\":1}}],[\"如果某个redis实例有故障\",{\"1\":{\"433\":1}}],[\"如果某个词词频过高或者整个文件都是同一个词的话\",{\"1\":{\"291\":1}}],[\"如果某个数据被访问过\",{\"1\":{\"161\":1}}],[\"如果程序中的某条指令被执行\",{\"1\":{\"417\":1}}],[\"如果程序运行只需要很小的空间的话\",{\"1\":{\"413\":1}}],[\"如果程序运行需要内存的话\",{\"1\":{\"413\":1}}],[\"如果直接把物理地址暴露出来的话会带来严重的问题\",{\"1\":{\"415\":1}}],[\"如果报告了fd后没有被处理\",{\"1\":{\"410\":1}}],[\"如果遍历完所有fd后没有发现就绪设备\",{\"1\":{\"410\":1}}],[\"如果遍历到的词的出现次数大于堆顶上词的出现次数\",{\"1\":{\"290\":1}}],[\"如果立即返回设为null即可\",{\"1\":{\"410\":1}}],[\"如果处理的连接数不是很高的话\",{\"1\":{\"409\":1}}],[\"如果buffer\",{\"1\":{\"396\":1}}],[\"如果事务执行失败或者调用了rollback\",{\"1\":{\"396\":1}}],[\"如果进行更新的时候\",{\"1\":{\"383\":1}}],[\"如果进行范围查询\",{\"1\":{\"381\":1}}],[\"如果进程占用处理机很长时间\",{\"1\":{\"139\":1}}],[\"如果进程在就绪队列中等待了很长时间\",{\"1\":{\"139\":1}}],[\"如果把所有同一内部节点的关键字存放在同一块盘中\",{\"1\":{\"378\":1}}],[\"如果数据量很大\",{\"1\":{\"376\":1}}],[\"如果未来业务有其他拼接字段\",{\"1\":{\"368\":1}}],[\"如果想重复读取数据\",{\"1\":{\"853\":1}}],[\"如果想要通过beanfactory实现这些功能\",{\"1\":{\"708\":1}}],[\"如果想要细粒度控制则需要设置association的fetchtype=\",{\"1\":{\"366\":1}}],[\"如果想随机查看redis中的一个key\",{\"1\":{\"436\":1}}],[\"如果想增加一个产品\",{\"1\":{\"58\":1}}],[\"如果dao层查询出来的数据没有一个实体类对象与之一一对应\",{\"1\":{\"366\":1}}],[\"如果对\",{\"1\":{\"383\":1}}],[\"如果对jdk9及以上版本的hotspot虚拟机使用参数\",{\"1\":{\"362\":1}}],[\"如果对象是在内部产生\",{\"1\":{\"349\":1}}],[\"如果持有对外部对象的引用的话\",{\"1\":{\"358\":1}}],[\"如果字符串常量池中不存在该字符串\",{\"1\":{\"354\":1}}],[\"如果字长为16位的计算机按字编址\",{\"1\":{\"151\":1}}],[\"如果拼接的结果调用intern\",{\"1\":{\"354\":1}}],[\"如果实例成员变量是引用变量\",{\"1\":{\"352\":1}}],[\"如果找到\",{\"1\":{\"352\":1}}],[\"如果只有一个线程操作此数据\",{\"1\":{\"349\":1}}],[\"如果只有读操作\",{\"1\":{\"209\":1}}],[\"如果父类加载器可以完成类加载任务\",{\"1\":{\"345\":1}}],[\"如果父类加载器还存在父类加载器\",{\"1\":{\"345\":1}}],[\"如果相同的话直接覆盖\",{\"1\":{\"327\":1}}],[\"如果重写了\",{\"1\":{\"319\":1}}],[\"如果查到了就走成功的流程\",{\"1\":{\"313\":1}}],[\"如果再问就说目前正在针对这点写个小论文\",{\"1\":{\"300\":1}}],[\"如果成功登陆了就会生成sessionid存在客户端的cookie中\",{\"1\":{\"296\":1}}],[\"如果校验失败\",{\"1\":{\"315\":1}}],[\"如果校验成功\",{\"1\":{\"315\":1}}],[\"如果校验不通过则会返回账号或密码错误信息\",{\"1\":{\"296\":1}}],[\"如果校验通过\",{\"1\":{\"260\":1}}],[\"如果拿出来的输入流中还有数据的话\",{\"1\":{\"291\":1}}],[\"如果第一个文件中词的个数小于100\",{\"1\":{\"290\":1}}],[\"如果count==0\",{\"1\":{\"282\":1}}],[\"如果construct\",{\"1\":{\"49\":1}}],[\"如果该分支不存在\",{\"1\":{\"282\":3}}],[\"如果该对象逃离了方法的作用范围\",{\"1\":{\"209\":1}}],[\"如果该对象没有逃离方法的作用范围\",{\"1\":{\"209\":1}}],[\"如果该对象足够大的话\",{\"1\":{\"101\":1}}],[\"如果将一个长度大于等于\",{\"1\":{\"280\":1}}],[\"如果将抽象工厂模式看成汽车配件生产工厂\",{\"1\":{\"55\":1}}],[\"如果空间不不够\",{\"1\":{\"280\":1}}],[\"如果前一个节点的长度大于等于\",{\"1\":{\"279\":1,\"280\":1}}],[\"如果前一个节点的长度小于\",{\"1\":{\"279\":1,\"280\":1}}],[\"如果\",{\"1\":{\"277\":1,\"449\":1,\"498\":1,\"502\":1,\"644\":1,\"751\":4,\"776\":1,\"825\":1,\"826\":1}}],[\"如果不大1\",{\"1\":{\"996\":1}}],[\"如果不是\",{\"1\":{\"985\":1}}],[\"如果不是特别在意内存\",{\"1\":{\"965\":1}}],[\"如果不符合\",{\"1\":{\"960\":2,\"968\":1}}],[\"如果不一致\",{\"1\":{\"959\":1}}],[\"如果不合法\",{\"1\":{\"959\":1}}],[\"如果不取消\",{\"1\":{\"893\":1}}],[\"如果不用\",{\"1\":{\"878\":1}}],[\"如果不调用\",{\"1\":{\"816\":1,\"825\":1}}],[\"如果不希望永远阻塞\",{\"1\":{\"775\":1}}],[\"如果不存在才能创建成功\",{\"1\":{\"758\":1}}],[\"如果不存在则抛出异常\",{\"1\":{\"720\":1}}],[\"如果不指定扫描具体包\",{\"1\":{\"661\":1}}],[\"如果不处理\",{\"1\":{\"410\":1}}],[\"如果不考虑同步机制的话\",{\"1\":{\"349\":1}}],[\"如果不同的话\",{\"1\":{\"318\":1}}],[\"如果不想编译器使用字节对齐的方式进行分配内存\",{\"1\":{\"277\":1}}],[\"如果不够的话\",{\"1\":{\"277\":1}}],[\"如果不满足的话\",{\"1\":{\"277\":1}}],[\"如果不能陪你到最后\",{\"1\":{\"37\":1}}],[\"如果存在则是修改\",{\"1\":{\"1025\":1}}],[\"如果存在则将其保存到threadlocal中\",{\"1\":{\"967\":1}}],[\"如果存在\",{\"1\":{\"282\":2,\"354\":1}}],[\"如果存在返回数量\",{\"1\":{\"282\":1}}],[\"如果存在一个值不为\",{\"1\":{\"273\":2}}],[\"如果存储长度大于此值\",{\"1\":{\"265\":1}}],[\"如果存储的字符串长度几乎相等\",{\"1\":{\"265\":1}}],[\"如果存储的数据范围查过decimal的范围\",{\"1\":{\"265\":1}}],[\"如果更新学生表中的student\",{\"1\":{\"267\":1}}],[\"如果其中一列全为null\",{\"1\":{\"267\":1}}],[\"如果其中出现了错误也会释放锁\",{\"1\":{\"211\":1}}],[\"如果where\",{\"1\":{\"266\":1}}],[\"如果可以是consts最好\",{\"1\":{\"266\":1}}],[\"如果可以进入\",{\"1\":{\"140\":1}}],[\"如果左边的值未确定\",{\"1\":{\"266\":1}}],[\"如果修改字段含义或对应字段表示的状态追加时\",{\"1\":{\"265\":1}}],[\"如果检验没通过\",{\"1\":{\"260\":1}}],[\"如果检测到外部中断信号\",{\"1\":{\"129\":1}}],[\"如果两者都满足\",{\"1\":{\"995\":1}}],[\"如果两者一致则更新成功\",{\"1\":{\"397\":1}}],[\"如果两者相同\",{\"1\":{\"318\":1}}],[\"如果两次cas都不成功\",{\"1\":{\"258\":1}}],[\"如果两个\",{\"1\":{\"799\":1}}],[\"如果两个进程都想着进入临界区\",{\"1\":{\"141\":1}}],[\"如果两个软件实体无须直接通信\",{\"1\":{\"111\":1}}],[\"如果技术竞争比较激烈\",{\"1\":{\"249\":1}}],[\"如果链表长度大于等于阈值8\",{\"1\":{\"249\":1}}],[\"如果链表头节点不为空则通过synchronized来加锁遍历链表\",{\"1\":{\"249\":1}}],[\"如果链表头节点为空\",{\"1\":{\"249\":1}}],[\"如果头节点已经是要查找的key\",{\"1\":{\"249\":1}}],[\"如果扩容过程中\",{\"1\":{\"249\":1}}],[\"如果任务失败\",{\"1\":{\"806\":2}}],[\"如果任务执行失败而终止那么没有任何补救措施\",{\"1\":{\"244\":1}}],[\"如果任务队列已满\",{\"1\":{\"243\":1}}],[\"如果无限制的创建\",{\"1\":{\"240\":1}}],[\"如果主线程希望\",{\"1\":{\"233\":1}}],[\"如果在操作过程中\",{\"1\":{\"996\":1}}],[\"如果在这个\",{\"1\":{\"825\":1}}],[\"如果在这个位置\",{\"1\":{\"791\":1}}],[\"如果在指定毫秒内无法连接\",{\"1\":{\"775\":1}}],[\"如果在引导类上自己添加了\",{\"1\":{\"659\":1}}],[\"如果在快表中未找到对应地页表项\",{\"1\":{\"413\":1}}],[\"如果在数据量非常大的情况下\",{\"1\":{\"383\":1}}],[\"如果在jdk14中使用xx\",{\"1\":{\"362\":1}}],[\"如果在map中不存在\",{\"1\":{\"290\":1}}],[\"如果在main线程中调用了t1线程的run方法\",{\"1\":{\"202\":1}}],[\"如果在扩容过程中其他线程来get\",{\"1\":{\"249\":1}}],[\"如果在线程池中使用threadlocal会造成内存泄漏\",{\"1\":{\"247\":1}}],[\"如果在\",{\"1\":{\"232\":1,\"496\":1,\"825\":1}}],[\"如果先调用unpark再调用park不会阻塞线程\",{\"1\":{\"219\":1}}],[\"如果当数据库中数据发生变化\",{\"1\":{\"981\":1}}],[\"如果当前存在事务\",{\"1\":{\"720\":6}}],[\"如果当前没有事务\",{\"1\":{\"720\":3}}],[\"如果当前创建的bean是单例的则会放入单例池\",{\"1\":{\"711\":1}}],[\"如果当前数组的长度小于64\",{\"1\":{\"327\":1}}],[\"如果当前位置存在元素的话\",{\"1\":{\"327\":1}}],[\"如果当前节点的数据是字符串\",{\"1\":{\"279\":1}}],[\"如果当前节点的数据是整数\",{\"1\":{\"279\":1}}],[\"如果当前字符是\",{\"1\":{\"276\":1}}],[\"如果当前字符不是\",{\"1\":{\"276\":1}}],[\"如果当前线程暂时没有数据可读\",{\"1\":{\"331\":1}}],[\"如果当前线程独占着锁\",{\"1\":{\"255\":1}}],[\"如果当前线程自旋成功\",{\"1\":{\"212\":1}}],[\"如果当初\",{\"1\":{\"37\":1}}],[\"如果当初没能遇见你\",{\"1\":{\"37\":1}}],[\"如果thread\",{\"1\":{\"211\":1}}],[\"如果this输给了h返回true\",{\"1\":{\"116\":1}}],[\"如果this战胜了h返回true\",{\"1\":{\"116\":1}}],[\"如果使用哈希\",{\"1\":{\"965\":1}}],[\"如果使用string\",{\"1\":{\"965\":1}}],[\"如果使用synchronized给对象上锁之后\",{\"1\":{\"211\":1}}],[\"如果使用工厂方法模式\",{\"1\":{\"54\":1}}],[\"如果变量在线程中共享\",{\"1\":{\"209\":1}}],[\"如果变量没有在线程间共享\",{\"1\":{\"209\":1}}],[\"如果调用了阻塞api\",{\"1\":{\"208\":1}}],[\"如果调用线程的stop\",{\"1\":{\"206\":1}}],[\"如果此时操作主从切换\",{\"1\":{\"437\":1}}],[\"如果此时内存已满\",{\"1\":{\"418\":1}}],[\"如果此时已经有事务对这条数据进行了更改\",{\"1\":{\"397\":1}}],[\"如果此时已经是在最下级的队列\",{\"1\":{\"139\":1}}],[\"如果此时线程锁住了共享资源\",{\"1\":{\"206\":1}}],[\"如果打断的是正常运行的线程\",{\"1\":{\"204\":1}}],[\"如果打断的是阻塞线程\",{\"1\":{\"204\":1}}],[\"如果这两个方法都是要保证事务的\",{\"1\":{\"720\":1}}],[\"如果这个数据不存在\",{\"1\":{\"985\":1}}],[\"如果这个连接不做任何事情就会造成不必要的开销\",{\"1\":{\"331\":1}}],[\"如果这个1g的大文件中有某个词词频过高\",{\"1\":{\"290\":1}}],[\"如果这个时候锁恰好没有被占用\",{\"1\":{\"258\":1}}],[\"如果这时没有同优先级的线程\",{\"1\":{\"203\":1}}],[\"如果这局猜拳获胜\",{\"1\":{\"116\":1}}],[\"如果被淘汰的页面没有被修改过\",{\"1\":{\"163\":1}}],[\"如果采用第一个方案\",{\"1\":{\"982\":1}}],[\"如果采用的是myisam存储引擎\",{\"1\":{\"387\":1}}],[\"如果采用连续分配的方式\",{\"1\":{\"161\":1,\"419\":1}}],[\"如果采用方案一\",{\"1\":{\"148\":1}}],[\"如果段过大\",{\"1\":{\"160\":1}}],[\"如果每周只工作40小时\",{\"1\":{\"305\":1}}],[\"如果每个页面大小是2^k\",{\"1\":{\"156\":1}}],[\"如果每类资源只有1个\",{\"1\":{\"147\":1}}],[\"如果缺页率明显下降\",{\"1\":{\"153\":1}}],[\"如果多道程序的话会冲突\",{\"1\":{\"151\":1}}],[\"如果按照字节编址的话\",{\"1\":{\"151\":1}}],[\"如果系统进入不安全状态\",{\"1\":{\"149\":1}}],[\"如果系统处于安全状态\",{\"1\":{\"149\":1}}],[\"如果分配资源后\",{\"1\":{\"149\":1}}],[\"如果源源不断的有短进程到达\",{\"1\":{\"139\":1}}],[\"如果源源不断的有短作业\",{\"1\":{\"139\":1}}],[\"如果让i\",{\"1\":{\"139\":1}}],[\"如果一致\",{\"1\":{\"959\":1,\"967\":1}}],[\"如果一次性将所有的垃圾进行处理\",{\"1\":{\"356\":1}}],[\"如果一本书需要知道第11章是什么标题\",{\"1\":{\"266\":1}}],[\"如果一直重复这样会导致饥饿\",{\"1\":{\"148\":1}}],[\"如果一直得不到服务\",{\"1\":{\"139\":1}}],[\"如果一个类加载器收到了类加载的请求\",{\"1\":{\"345\":1}}],[\"如果一个类被其他的类所继承\",{\"1\":{\"108\":1}}],[\"如果一个文件的大小超过了256块\",{\"1\":{\"169\":1}}],[\"如果一个进程频繁的进行i\",{\"1\":{\"139\":1}}],[\"如果新到达的进程剩余时间比当前运行的进程剩余时间更短\",{\"1\":{\"139\":1}}],[\"如果有一个条件不满足则直接结束\",{\"1\":{\"995\":1}}],[\"如果有这个key则插入失败\",{\"1\":{\"988\":1}}],[\"如果有session信息\",{\"1\":{\"959\":1}}],[\"如果有剩余未读字节\",{\"1\":{\"893\":1}}],[\"如果有很多连接建立\",{\"1\":{\"876\":1}}],[\"如果有\",{\"1\":{\"792\":1}}],[\"如果有拦截器则生成\",{\"1\":{\"736\":1}}],[\"如果有多个构造方法\",{\"1\":{\"711\":1}}],[\"如果有多个二级索引\",{\"1\":{\"387\":1}}],[\"如果有多个线程操作此数据\",{\"1\":{\"349\":1}}],[\"如果有大量的索引\",{\"1\":{\"375\":1}}],[\"如果有事件发生\",{\"1\":{\"332\":1}}],[\"如果有机会进入华为的话\",{\"1\":{\"307\":1}}],[\"如果有全球化需要\",{\"1\":{\"267\":1}}],[\"如果有order\",{\"1\":{\"266\":1}}],[\"如果有则不去抢锁\",{\"1\":{\"258\":1}}],[\"如果有空闲线程\",{\"1\":{\"240\":1}}],[\"如果有结果不断从一个线程到另一个线程\",{\"1\":{\"217\":1}}],[\"如果有写操作\",{\"1\":{\"209\":1}}],[\"如果有些部分没有用上\",{\"1\":{\"154\":2}}],[\"如果有进程提前归还了一些资源\",{\"1\":{\"149\":1}}],[\"如果有源源不断的进程使用1或者2\",{\"1\":{\"148\":1}}],[\"如果有更加紧急的进程需要cpu\",{\"1\":{\"137\":1}}],[\"如果有新的需求\",{\"1\":{\"50\":1}}],[\"如果是基于redis\",{\"1\":{\"1021\":1}}],[\"如果是null\",{\"1\":{\"985\":1}}],[\"如果是副本\",{\"1\":{\"929\":1}}],[\"如果是正常断开\",{\"1\":{\"890\":1}}],[\"如果是可读\",{\"1\":{\"792\":1}}],[\"如果是可接入\",{\"1\":{\"792\":1}}],[\"如果是\",{\"1\":{\"646\":1,\"793\":1,\"890\":2}}],[\"如果是innodb\",{\"1\":{\"387\":1}}],[\"如果是数组\",{\"1\":{\"353\":1}}],[\"如果是数组的话还会包含数组长度\",{\"1\":{\"210\":1}}],[\"如果是动态变化的\",{\"1\":{\"348\":1}}],[\"如果是固定的就可能出现stackoverflowerror\",{\"1\":{\"348\":1}}],[\"如果是共享锁的话会将连着的占有共享锁的线程一同释放\",{\"1\":{\"253\":1}}],[\"如果是互斥锁+共享锁的情况下\",{\"1\":{\"253\":1}}],[\"如果是前者需要考虑\",{\"1\":{\"230\":1}}],[\"如果是在休眠的时候被打断\",{\"1\":{\"206\":1}}],[\"如果是1就是负数了\",{\"1\":{\"440\":1}}],[\"如果是1\",{\"1\":{\"163\":1,\"996\":1}}],[\"如果是0\",{\"1\":{\"163\":1}}],[\"如果是同一进程内的线程切换\",{\"1\":{\"135\":1}}],[\"如果是多线程环境\",{\"1\":{\"101\":1}}],[\"如果没这个判断\",{\"1\":{\"792\":1}}],[\"如果没抢到\",{\"1\":{\"258\":1}}],[\"如果没读空\",{\"1\":{\"134\":1}}],[\"如果没有设置过期时间\",{\"1\":{\"1024\":1}}],[\"如果没有出错\",{\"1\":{\"1012\":1}}],[\"如果没有过期\",{\"1\":{\"989\":1}}],[\"如果没有命中则直接返回空数据\",{\"1\":{\"989\":1}}],[\"如果没有获得到\",{\"1\":{\"988\":1}}],[\"如果没有缓存来作为\",{\"1\":{\"975\":1}}],[\"如果没有则拦截\",{\"1\":{\"967\":1}}],[\"如果没有则需要在双亲委派模式下对相应的类进行加载\",{\"1\":{\"352\":1}}],[\"如果没有session信息\",{\"1\":{\"959\":1}}],[\"如果没有读到数据\",{\"1\":{\"877\":1}}],[\"如果没有连接建立\",{\"1\":{\"877\":1}}],[\"如果没有失败\",{\"1\":{\"806\":1}}],[\"如果没有特殊指定\",{\"1\":{\"707\":1}}],[\"如果没有指定接口\",{\"1\":{\"531\":1}}],[\"如果没有大量的闲置连接和死亡连接\",{\"1\":{\"410\":1}}],[\"如果没有找到文件\",{\"1\":{\"352\":1}}],[\"如果没有\",{\"1\":{\"352\":1,\"617\":1}}],[\"如果没有相符的hashcode\",{\"1\":{\"318\":1}}],[\"如果没有竞争\",{\"1\":{\"234\":1}}],[\"如果没有足够的内存空间\",{\"1\":{\"151\":1}}],[\"如果没有就把自身的标志位置为true\",{\"1\":{\"141\":1}}],[\"如果没有并发性\",{\"1\":{\"127\":1}}],[\"如果没有定义\",{\"1\":{\"104\":1}}],[\"如果没有定义selltickets接口\",{\"1\":{\"95\":1}}],[\"如果没有接口使用cglib代理\",{\"1\":{\"96\":1}}],[\"如果管道没写满\",{\"1\":{\"134\":1}}],[\"如果提供vx和qq同时发送文件则不能实现\",{\"1\":{\"127\":1}}],[\"如果现在又有新的动力源或者新的颜色的话\",{\"1\":{\"112\":1}}],[\"如果定义了这个方法\",{\"1\":{\"104\":1}}],[\"如果instance不为null\",{\"1\":{\"101\":2}}],[\"如果接口增加一个方法\",{\"1\":{\"96\":1}}],[\"如果要降序则在命令的z后面添加rev即可\",{\"1\":{\"1030\":1}}],[\"如果要让redis以后台方式启动\",{\"1\":{\"1015\":1}}],[\"如果要的不是\",{\"1\":{\"617\":1}}],[\"如果要读写多个离散存储的数据块\",{\"1\":{\"181\":1}}],[\"如果要买火车票的话\",{\"1\":{\"93\":1}}],[\"如果要加同一个产品族的话\",{\"1\":{\"74\":1}}],[\"如果要实现新产品直接修改工厂类\",{\"1\":{\"64\":1}}],[\"如果要更换对象\",{\"1\":{\"60\":1}}],[\"如果我们直接使用userid\",{\"1\":{\"998\":1}}],[\"如果我们的id具有太明显的规则\",{\"1\":{\"992\":1}}],[\"如果我们采用phone\",{\"1\":{\"966\":1}}],[\"如果我们请求的url是\",{\"1\":{\"731\":1}}],[\"如果我们给某一行数据加上了排他锁\",{\"1\":{\"400\":1}}],[\"如果我们要查找定位第一个元素和最后一个元素\",{\"1\":{\"279\":1}}],[\"如果我们需要判断某个字符串是否在布隆过滤器中时\",{\"1\":{\"273\":1}}],[\"如果我们使用工厂来生产对象\",{\"1\":{\"60\":1}}],[\"如果我能\",{\"1\":{\"37\":1}}],[\"如果创建的时候直接new该对象\",{\"1\":{\"60\":1}}],[\"如果创建这个类的实例\",{\"1\":{\"52\":1}}],[\"如果参数更多呢\",{\"1\":{\"52\":1}}],[\"如果产品之间的差异性很大\",{\"1\":{\"50\":1}}],[\"如果去欧洲国家去旅游的话\",{\"1\":{\"39\":1}}],[\"字母的地形上飞跃\",{\"1\":{\"974\":1}}],[\"字典树\",{\"0\":{\"282\":1}}],[\"字符来标识字符串结尾了\",{\"1\":{\"277\":1}}],[\"字符标识\",{\"1\":{\"276\":1}}],[\"字符将被误认为是字符串结尾\",{\"1\":{\"276\":1}}],[\"字符串与\",{\"0\":{\"855\":1}}],[\"字符串不加单引号会导致索引失效\",{\"1\":{\"395\":1}}],[\"字符串拼接\",{\"0\":{\"354\":1}}],[\"字符串拼接到\",{\"1\":{\"276\":1}}],[\"字符串结尾还是会加上\",{\"1\":{\"277\":1}}],[\"字符串操作函数不高效且不安全\",{\"1\":{\"276\":1}}],[\"字符串里面不能包含有\",{\"1\":{\"276\":1}}],[\"字符串里面不能含有\",{\"1\":{\"276\":1}}],[\"字符串的结尾是以\",{\"1\":{\"276\":1}}],[\"字符串中的所有内容\",{\"1\":{\"276\":1}}],[\"字符串后面\",{\"1\":{\"276\":1}}],[\"字符串\",{\"1\":{\"276\":1,\"277\":1,\"1036\":1}}],[\"字符串在\",{\"1\":{\"275\":1}}],[\"字符\",{\"1\":{\"276\":3,\"277\":1}}],[\"字符作为结尾标记有个缺陷\",{\"1\":{\"276\":1}}],[\"字符数组\",{\"1\":{\"277\":1}}],[\"字符数组的结构\",{\"1\":{\"275\":1,\"276\":1}}],[\"字符数组存在一些缺陷\",{\"1\":{\"275\":1}}],[\"字符数组来实现字符串\",{\"1\":{\"275\":1}}],[\"字符流\",{\"1\":{\"44\":1}}],[\"字段约束等等信息\",{\"1\":{\"1004\":1}}],[\"字段数据类型\",{\"1\":{\"1004\":1}}],[\"字段\",{\"0\":{\"925\":1}}],[\"字段上建立索引时\",{\"1\":{\"383\":1}}],[\"字段需要创建索引\",{\"1\":{\"383\":1}}],[\"字段创建了索引\",{\"1\":{\"383\":1}}],[\"字段的数值有唯一性的限制\",{\"1\":{\"383\":1}}],[\"字段长度短\",{\"1\":{\"265\":1}}],[\"字段允许适当冗余\",{\"1\":{\"265\":1}}],[\"字段名\",{\"1\":{\"265\":1,\"1004\":1}}],[\"字段名必须使用小写字母或数字\",{\"1\":{\"265\":1}}],[\"字段更新器\",{\"1\":{\"232\":1}}],[\"字节数据常常会有此情况\",{\"1\":{\"755\":1}}],[\"字节就会缓冲在接收方的滑动窗口中\",{\"1\":{\"751\":1}}],[\"字节跳动\",{\"1\":{\"355\":1}}],[\"字节扩展至\",{\"1\":{\"280\":1}}],[\"字节大小\",{\"1\":{\"280\":2}}],[\"字节大小扩展为\",{\"1\":{\"280\":1}}],[\"字节的指令类型\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"字节的序列化方式\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"字节的版本\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"字节的魔数\",{\"1\":{\"770\":1,\"771\":1,\"773\":1}}],[\"字节的新节点加入到压缩列表的表头节点\",{\"1\":{\"280\":1}}],[\"字节的空间进行编码\",{\"1\":{\"279\":1}}],[\"字节的空间来保存这个长度值\",{\"1\":{\"279\":2,\"280\":3}}],[\"字节对齐\",{\"1\":{\"277\":1}}],[\"字节对齐的方式给变量分配内存\",{\"1\":{\"277\":1}}],[\"字节\",{\"1\":{\"265\":1,\"277\":1,\"279\":3,\"280\":3,\"749\":1,\"750\":3,\"754\":1}}],[\"字节码层面分析synchronized\",{\"1\":{\"211\":1}}],[\"字节流\",{\"1\":{\"44\":1}}],[\"但依然存在一些问题\",{\"1\":{\"1042\":1}}],[\"但底层数据结构却差别很大\",{\"1\":{\"1030\":1}}],[\"但拆分表了之后\",{\"1\":{\"992\":1}}],[\"但内存读写速度没有跟上\",{\"1\":{\"976\":1}}],[\"但内存已无空闲空间时\",{\"1\":{\"420\":1}}],[\"但流量低的场景\",{\"1\":{\"917\":1}}],[\"但非阻塞模式下\",{\"1\":{\"877\":1}}],[\"但长时间\",{\"1\":{\"876\":1}}],[\"但治标不治本\",{\"1\":{\"876\":1}}],[\"但多线程下\",{\"1\":{\"876\":1}}],[\"但线程不必阻塞\",{\"1\":{\"877\":1}}],[\"但线程相当于闲置\",{\"1\":{\"876\":1}}],[\"但线程池中的线程不会回收\",{\"1\":{\"247\":1}}],[\"但实际上\",{\"1\":{\"845\":1}}],[\"但实际上observer角色并非主动地去观察\",{\"1\":{\"80\":1}}],[\"但经过\",{\"1\":{\"837\":1}}],[\"但不会在处理完后从\",{\"1\":{\"887\":1}}],[\"但不会改变写指针位置\",{\"1\":{\"822\":1}}],[\"但不会超过cpu的核心数\",{\"1\":{\"234\":1}}],[\"但也要注意及时主动释放\",{\"1\":{\"819\":1}}],[\"但读写性能高\",{\"1\":{\"819\":1}}],[\"但都是要等任务结束\",{\"1\":{\"806\":1}}],[\"但只要后续病人源源不断地来\",{\"1\":{\"805\":1}}],[\"但工人与\",{\"1\":{\"798\":1}}],[\"但除了第一个处于\",{\"1\":{\"776\":1}}],[\"但主人家则总是给私塾先生以白菜豆腐为菜\",{\"1\":{\"766\":1}}],[\"但应用程序没有感知到\",{\"1\":{\"764\":1}}],[\"但发生超时\",{\"1\":{\"751\":1}}],[\"但发生死锁的时候就一定是处于不安全状态\",{\"1\":{\"149\":1}}],[\"但这也会影响查询的性能\",{\"1\":{\"987\":1}}],[\"但这样又会导致占用内存过多\",{\"1\":{\"893\":1}}],[\"但这样做的一个最大问题是无法订制每种数据源的详细配置\",{\"1\":{\"660\":1}}],[\"但这时\",{\"1\":{\"887\":1}}],[\"但这种说法是不完整的\",{\"1\":{\"458\":1}}],[\"但会走\",{\"1\":{\"617\":1}}],[\"但具体转换工作是\",{\"1\":{\"604\":1}}],[\"但分为两种情况\",{\"1\":{\"572\":1}}],[\"但碰到循环依赖会提前至依赖注入之前执行\",{\"1\":{\"539\":1}}],[\"但避免了反射\",{\"1\":{\"527\":1}}],[\"但\",{\"1\":{\"504\":1,\"678\":1}}],[\"但理念上殊途同归\",{\"1\":{\"503\":1}}],[\"但加在\",{\"1\":{\"500\":1}}],[\"但要注意如果\",{\"1\":{\"867\":1}}],[\"但要注意对于编解码器类\",{\"1\":{\"771\":1}}],[\"但要注意\",{\"1\":{\"496\":1}}],[\"但要解决的问题\",{\"1\":{\"45\":1}}],[\"但它们是组合了\",{\"1\":{\"451\":1}}],[\"但它也存在以下缺点\",{\"1\":{\"112\":1}}],[\"但低效也是相对的\",{\"1\":{\"410\":1}}],[\"但sc是null\",{\"1\":{\"877\":1}}],[\"但select\",{\"1\":{\"410\":1}}],[\"但sum\",{\"1\":{\"267\":1}}],[\"但写redo\",{\"1\":{\"396\":1}}],[\"但如果数据报文超过\",{\"1\":{\"898\":1}}],[\"但如果内容本身包含了分隔符\",{\"1\":{\"755\":1}}],[\"但如果这部分数据很少的话\",{\"1\":{\"751\":1}}],[\"但如果这么做\",{\"1\":{\"751\":1}}],[\"但如果程序所要访问的页\",{\"1\":{\"418\":1}}],[\"但如果每次读写数据都需要磁盘io\",{\"1\":{\"396\":1}}],[\"但如果提前调入的页面大多数都没被访问过\",{\"1\":{\"164\":1}}],[\"但并非为了挑选一个最好的收集器出来\",{\"1\":{\"360\":1}}],[\"但通过分隔符来断句不是很好\",{\"1\":{\"766\":1}}],[\"但通过你的积极应对\",{\"0\":{\"311\":1}}],[\"但通常都是编译或汇编时在转换为绝对地址\",{\"1\":{\"151\":1}}],[\"但缺点是具有一定的错误识别率和删除难度\",{\"1\":{\"272\":1}}],[\"但缺点是synchronized属于重量级锁\",{\"1\":{\"228\":1}}],[\"但truncate无事务且不触发trigger\",{\"1\":{\"267\":1}}],[\"但提高查找速度是明显的\",{\"1\":{\"266\":1,\"383\":1}}],[\"但必须考虑数据一致\",{\"1\":{\"265\":1}}],[\"但在linux下默认是区分大小写\",{\"1\":{\"265\":1}}],[\"但在实际过程中\",{\"1\":{\"163\":1}}],[\"但当每次使用代理对象的任意方法时\",{\"1\":{\"500\":1}}],[\"但当你执行\",{\"1\":{\"246\":1}}],[\"但当非守护线程执行完毕后\",{\"1\":{\"207\":1}}],[\"但每个任务执行时间较短的情况\",{\"1\":{\"244\":1}}],[\"但每次只使用其中的某一族产品\",{\"1\":{\"76\":1}}],[\"但因为其不在\",{\"1\":{\"232\":1}}],[\"但函数需要无副作用\",{\"1\":{\"232\":4}}],[\"但wait需要和synchronized一起使用\",{\"1\":{\"216\":1}}],[\"但条件不满足进入waiting状态的线程\",{\"1\":{\"211\":1}}],[\"但没有修改过的页面\",{\"1\":{\"163\":1}}],[\"但修改过的页面\",{\"1\":{\"163\":1}}],[\"但各段之间可以不相邻\",{\"1\":{\"159\":1}}],[\"但各个进程之间信息交换又是必须的\",{\"1\":{\"134\":1}}],[\"但代价有点大\",{\"1\":{\"150\":1}}],[\"但又必须彻底释放\",{\"1\":{\"825\":1}}],[\"但又对自己已有的资源保持不放\",{\"1\":{\"147\":1}}],[\"但又提出了新的资源请求\",{\"1\":{\"147\":1}}],[\"但由于某种原因这些数据在接收时\",{\"1\":{\"859\":1}}],[\"但由于接收方处理不及时且窗口大小足够大\",{\"1\":{\"751\":1}}],[\"但由于每次只能调入一页\",{\"1\":{\"164\":1}}],[\"但由于该进程需要连续的内存空间\",{\"1\":{\"154\":1}}],[\"但由于没有空闲cpu\",{\"1\":{\"132\":1}}],[\"但由于资源有限\",{\"1\":{\"127\":1}}],[\"但我们能够同时运行gta和其他软件\",{\"1\":{\"127\":1}}],[\"但我们知道他们对构造方法中的字节流类\",{\"1\":{\"44\":1}}],[\"但一个时间段内只允许一个进程访问该资源\",{\"1\":{\"127\":1}}],[\"但微观上是交替发生的\",{\"1\":{\"127\":1}}],[\"但其底层实现还是用多路复用模拟了异步\",{\"1\":{\"906\":1}}],[\"但其中个别部分易变时\",{\"1\":{\"122\":1}}],[\"但其接口同新系统的接口不一致\",{\"1\":{\"43\":1}}],[\"但某些步骤的具体实现还未知\",{\"1\":{\"118\":1}}],[\"但构件间的建造顺序是稳定的\",{\"1\":{\"51\":1}}],[\"但将它们组合在一起的算法却相对稳定\",{\"1\":{\"51\":1}}],[\"但同时也加重了抽象建造者类的职责\",{\"1\":{\"49\":1}}],[\"但是却无法和线程1和线程2实现互斥\",{\"1\":{\"999\":1}}],[\"但是锁对象却不是同一个\",{\"1\":{\"999\":1}}],[\"但是锁已经释放也会导致问题\",{\"1\":{\"998\":1}}],[\"但是以上做法依然有问题\",{\"1\":{\"998\":1}}],[\"但是以上代码还是存在问题\",{\"1\":{\"998\":1}}],[\"但是以上这种方式通过测试发现会有很多失败的情况\",{\"1\":{\"997\":1}}],[\"但是乐观锁比较适合更新数据\",{\"1\":{\"998\":1}}],[\"但是目前的情况是\",{\"1\":{\"998\":1}}],[\"但是100个人中只有1个人能扣减成功\",{\"1\":{\"997\":1}}],[\"但是现在由于线程1已经操作过了\",{\"1\":{\"996\":1}}],[\"但是现在这个拦截器他只是拦截需要被拦截的路径\",{\"1\":{\"970\":1}}],[\"但是他们的锁对象写的虽然和服务器a一样\",{\"1\":{\"999\":1}}],[\"但是他自己满足version=1\",{\"1\":{\"996\":1}}],[\"但是他没有最大连接数的限制\",{\"1\":{\"410\":1}}],[\"但是还没有来得及去扣减\",{\"1\":{\"996\":1}}],[\"但是还没有调用start\",{\"1\":{\"208\":1}}],[\"但是此时他获得到了锁的资源\",{\"1\":{\"987\":1}}],[\"但是此时redis中没有数据\",{\"1\":{\"984\":1}}],[\"但是此时r1已经分配出去三个了\",{\"1\":{\"150\":1}}],[\"但是假设在线程1没有走完的时候\",{\"1\":{\"987\":1}}],[\"但是数据库中一定存在这个数据\",{\"1\":{\"984\":1}}],[\"但是数据库中也没有数据\",{\"1\":{\"984\":1}}],[\"但是中间如果没有人查询\",{\"1\":{\"982\":1}}],[\"但是方案一调用者如何处理呢\",{\"1\":{\"982\":1}}],[\"但是缓存也会增加代码复杂度和运营的成本\",{\"1\":{\"975\":1}}],[\"但是redis的key是共享的\",{\"1\":{\"966\":1}}],[\"但是关于key的处理\",{\"1\":{\"966\":1}}],[\"但是每当任意一台服务器的session修改时\",{\"1\":{\"963\":1}}],[\"但是第二次这个用户访问到了第二台tomcat\",{\"1\":{\"963\":1}}],[\"但是你事后不能改变分片的数量\",{\"1\":{\"928\":1}}],[\"但是是两个接口\",{\"1\":{\"806\":1}}],[\"但是channel对象并没有正确连接\",{\"1\":{\"803\":1}}],[\"但是可以有多个\",{\"1\":{\"731\":1}}],[\"但是可以获取共享锁\",{\"1\":{\"252\":1}}],[\"但是会造成太多过期key没有被删除\",{\"1\":{\"427\":1}}],[\"但是其string底层并没有采用c的字符串\",{\"1\":{\"422\":1}}],[\"但是其内部的同步代码还是会发生重排序\",{\"1\":{\"229\":1}}],[\"但是页式管理其中的页并无任何实际意义\",{\"1\":{\"413\":1}}],[\"但是空间性能的提升是以时间为代价的\",{\"1\":{\"413\":1}}],[\"但是所有socket都很活跃的情况下\",{\"1\":{\"410\":1}}],[\"但是同样有缺点\",{\"1\":{\"410\":1}}],[\"但是这样添加锁\",{\"1\":{\"998\":1}}],[\"但是这样我们分析过\",{\"1\":{\"997\":1}}],[\"但是这样也会造成效率的降低\",{\"1\":{\"410\":1}}],[\"但是这种方案具有两个大问题\",{\"1\":{\"963\":1}}],[\"但是这种方式业内比较少用\",{\"1\":{\"439\":1}}],[\"但是这回降低系统性能\",{\"1\":{\"154\":1}}],[\"但是文件描述符这一个概念往往只适用于unix\",{\"1\":{\"407\":1}}],[\"但是也带来了新的问题\",{\"1\":{\"396\":1}}],[\"但是也有抢占式的版本\",{\"1\":{\"139\":1}}],[\"但是具体要恢复到哪个版本\",{\"1\":{\"393\":1}}],[\"但是因为联合索引中有lastname\",{\"1\":{\"385\":1}}],[\"但是user实体类中具有role实体类\",{\"1\":{\"366\":1}}],[\"但是并不能正确删除\",{\"1\":{\"366\":1}}],[\"但是从java程序的视角来看\",{\"1\":{\"352\":1}}],[\"但是流是单向的只能读或者写\",{\"1\":{\"332\":1}}],[\"但是limit是可以修改的\",{\"1\":{\"332\":1}}],[\"但是需要flip\",{\"1\":{\"332\":1}}],[\"但是能实现多个接口\",{\"1\":{\"317\":1}}],[\"但是工程量和实现难度比较大\",{\"1\":{\"315\":1}}],[\"但是前端进行拦截器显然是针对普通用户\",{\"1\":{\"315\":1}}],[\"但是接口反馈超时\",{\"1\":{\"313\":1}}],[\"但是没有被即使清理\",{\"1\":{\"436\":1}}],[\"但是没有收到任何的信息\",{\"1\":{\"313\":1}}],[\"但是没有遵循让权等待\",{\"1\":{\"141\":1}}],[\"但是想要进一步发展\",{\"1\":{\"305\":1}}],[\"但是很大\",{\"1\":{\"410\":1}}],[\"但是很容易可以发现问题\",{\"1\":{\"290\":1}}],[\"但是很适合用于用一台计算机控制多个相同对象的场合\",{\"1\":{\"154\":1}}],[\"但是它仅能得到当前可用数据\",{\"1\":{\"332\":1}}],[\"但是它应该满足幂等性\",{\"1\":{\"314\":2}}],[\"但是它没有直接使用\",{\"1\":{\"275\":1}}],[\"但是它自己可以获取共享锁\",{\"1\":{\"252\":1}}],[\"但是缺点是其返回的结果是概率性的\",{\"1\":{\"272\":1}}],[\"但是值的类型不可控\",{\"1\":{\"268\":3}}],[\"但是由于人们目前无法预知进程的若干个页面中\",{\"1\":{\"420\":1}}],[\"但是由于加锁本身也需要消耗资源\",{\"1\":{\"396\":1}}],[\"但是由于成员变量里有\",{\"1\":{\"277\":1}}],[\"但是由于state=0\",{\"1\":{\"261\":1}}],[\"但是由于300号块内存放了再下一组的信息\",{\"1\":{\"170\":1}}],[\"但是不超过16\",{\"1\":{\"1021\":1}}],[\"但是不设置过期时间\",{\"1\":{\"987\":1}}],[\"但是不会exit\",{\"1\":{\"362\":1}}],[\"但是不能取代reentrantlock\",{\"1\":{\"260\":1}}],[\"但是不抛出异常\",{\"1\":{\"243\":1}}],[\"但是公平锁会判断队列中是否有线程处于等待状态\",{\"1\":{\"258\":1}}],[\"但是处理任务队列中的任务\",{\"1\":{\"241\":1}}],[\"但是如果现在是服务器b的tomcat内部\",{\"1\":{\"999\":1}}],[\"但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适\",{\"1\":{\"966\":1}}],[\"但是如果进行水平分表之后\",{\"1\":{\"439\":1}}],[\"但是如果很多的话\",{\"1\":{\"410\":1}}],[\"但是如果发现有相同hashcode值的对象\",{\"1\":{\"318\":1}}],[\"但是如果保存的元素数量增加了\",{\"1\":{\"281\":1}}],[\"但是如果竞争激烈\",{\"1\":{\"231\":1}}],[\"但是如果子类对这些已经实现的方法任意修改\",{\"1\":{\"108\":1}}],[\"但是实现困难\",{\"1\":{\"163\":1}}],[\"但是有如下区别\",{\"1\":{\"332\":1}}],[\"但是有外部碎片\",{\"1\":{\"154\":1}}],[\"但是有些情况下需要简化系统结构\",{\"1\":{\"49\":1}}],[\"但是之后p1进程又申请资源r2\",{\"1\":{\"147\":1}}],[\"但是发生循环等待的时候未必死锁\",{\"1\":{\"147\":1}}],[\"但是又违背了空闲让进以及有限等待原则\",{\"1\":{\"141\":1}}],[\"但是办理具体业务却因人而异\",{\"1\":{\"118\":1}}],[\"但是似乎组装的电脑的cpu只能是intel的\",{\"1\":{\"109\":1}}],[\"但是在集群模式下就不行了\",{\"1\":{\"999\":1}}],[\"但是在重构数据完成前\",{\"1\":{\"987\":1}}],[\"但是在连接数少并且连接都十分活跃的情况下\",{\"1\":{\"410\":1}}],[\"但是在加载自定义string类的时候会率先使用引导类加载器进行加载\",{\"1\":{\"346\":1}}],[\"但是在getinstance\",{\"1\":{\"101\":1}}],[\"但是在现实生活中许多工厂是综合型的工厂\",{\"1\":{\"71\":1}}],[\"但是\",{\"1\":{\"101\":1,\"168\":1,\"277\":1,\"278\":1,\"356\":1,\"409\":2,\"413\":1,\"439\":1,\"718\":1,\"731\":1}}],[\"但是到jdk1\",{\"1\":{\"96\":1}}],[\"但是与ground\",{\"1\":{\"25\":1}}],[\"但组件接口定义和自己要求的接口定义不同\",{\"1\":{\"43\":1}}],[\"当这个key过期了\",{\"1\":{\"1024\":1}}],[\"当这一切都完成之后\",{\"1\":{\"409\":1}}],[\"当过期时间到了之后\",{\"1\":{\"1024\":1}}],[\"当分线程全部走完\",{\"1\":{\"993\":1}}],[\"当分配四个内存块的时候\",{\"1\":{\"163\":1}}],[\"当countdownlatch\",{\"1\":{\"993\":1}}],[\"当cpu在执行用户态的进程时\",{\"1\":{\"406\":2}}],[\"当异步程序没有执行完时\",{\"1\":{\"993\":1}}],[\"当他写入缓存后\",{\"1\":{\"982\":1}}],[\"当他标注在类上时\",{\"1\":{\"721\":1}}],[\"当代计算机最大的问题是\",{\"1\":{\"976\":1}}],[\"当注册完成后\",{\"1\":{\"967\":1}}],[\"当监听线程知道用户想要和tomcat连接连接时\",{\"1\":{\"961\":1}}],[\"当消息处理器第一次写入消息时\",{\"1\":{\"893\":1}}],[\"当包装\",{\"1\":{\"830\":1}}],[\"当计数为\",{\"1\":{\"825\":1}}],[\"当出现异常时触发\",{\"1\":{\"762\":1}}],[\"当连接断开时触发\",{\"1\":{\"762\":1}}],[\"当应答未到达前\",{\"1\":{\"751\":1}}],[\"当发送的数据超过\",{\"1\":{\"751\":1}}],[\"当发生回滚时\",{\"1\":{\"396\":1}}],[\"当发生了缓冲区溢出就有可能造成程序异常结束\",{\"1\":{\"277\":1}}],[\"当发生重量级锁竞争的时候\",{\"1\":{\"212\":1}}],[\"当滑动窗口中缓冲了多个报文就会粘包\",{\"1\":{\"751\":1}}],[\"当订阅者的缓冲池满了之后\",{\"1\":{\"745\":1}}],[\"当得到真实的视图对象view后\",{\"1\":{\"736\":1}}],[\"当dispatcherservlet根据handlermapping得到对应请求的handler后\",{\"1\":{\"736\":1}}],[\"当浏览器发送一个请求\",{\"1\":{\"644\":1}}],[\"当\",{\"1\":{\"617\":1,\"771\":1,\"792\":2}}],[\"当中\",{\"1\":{\"454\":1}}],[\"当中断发生后\",{\"1\":{\"129\":1}}],[\"当中断发生时\",{\"1\":{\"129\":1}}],[\"当master和slave机器始终严重不一致时\",{\"1\":{\"437\":1}}],[\"当master节点挂掉后需要运维介入切换节点\",{\"1\":{\"432\":1}}],[\"当redis内存达到咱们设定的max\",{\"1\":{\"980\":1}}],[\"当redis\",{\"1\":{\"435\":1}}],[\"当redis已用内存超过maxmemory限定时\",{\"1\":{\"429\":1}}],[\"当客户端操作的key没有分配在该节点上时\",{\"1\":{\"434\":1}}],[\"当客户端下次访问服务器端时\",{\"1\":{\"296\":1}}],[\"当删除的key是所占内存很大时\",{\"1\":{\"430\":1}}],[\"当删除一个文件时\",{\"1\":{\"168\":1}}],[\"当存在大量的热点缓存数据时\",{\"1\":{\"429\":1}}],[\"当内存不足以容纳新写入的数据时\",{\"1\":{\"429\":1}}],[\"当内存不足以容纳新写入数据时\",{\"1\":{\"429\":1}}],[\"当需淘汰一个页面时\",{\"1\":{\"420\":1}}],[\"当需要修改对象某个字段时很不方便\",{\"1\":{\"1027\":1}}],[\"当需要时做类型转换\",{\"1\":{\"576\":3}}],[\"当需要淘汰一个页面时\",{\"1\":{\"163\":2}}],[\"当需要创建的对象是一系列相互关联或相互依赖的产品族时\",{\"1\":{\"76\":1}}],[\"当物理内存的供应量变小时\",{\"1\":{\"415\":1}}],[\"当epoll\",{\"1\":{\"410\":2}}],[\"当select函数返回后\",{\"1\":{\"410\":1}}],[\"当它标注在方法上时\",{\"1\":{\"721\":1}}],[\"当它收到一个asynchronous\",{\"1\":{\"409\":1}}],[\"当它的update方法被调用后\",{\"1\":{\"81\":1}}],[\"当任何一个socket中的数据准备好了\",{\"1\":{\"409\":1}}],[\"当任务执行完毕\",{\"1\":{\"244\":1}}],[\"当任务到达时\",{\"1\":{\"240\":1}}],[\"当kernel一直等到数据准备好了\",{\"1\":{\"409\":1}}],[\"当程序打开一个现有文件或者创建一个新文件时\",{\"1\":{\"407\":1}}],[\"当要对表做结构变更操作的时候\",{\"1\":{\"400\":1}}],[\"当对一个non\",{\"1\":{\"409\":1}}],[\"当对一个表做增删改查操作的时候\",{\"1\":{\"400\":1}}],[\"当对表中的数据进行增删改操作的时候\",{\"1\":{\"375\":1}}],[\"当事务提交时\",{\"1\":{\"396\":1}}],[\"当事务对数据库进行修改时\",{\"1\":{\"396\":1}}],[\"当数据修改时\",{\"1\":{\"396\":1}}],[\"当向数据库写入数据时\",{\"1\":{\"396\":1}}],[\"当从数据库读取数据时\",{\"1\":{\"396\":1}}],[\"当没有二级索引的时候\",{\"1\":{\"387\":1}}],[\"当a小于b时\",{\"1\":{\"386\":1}}],[\"当aqs需要同时实现为互斥锁+共享锁的时候\",{\"1\":{\"252\":1}}],[\"当aqs只实现为互斥锁的时候\",{\"1\":{\"252\":1}}],[\"当延迟加载开启后\",{\"1\":{\"366\":1}}],[\"当有事件触发时\",{\"1\":{\"333\":1}}],[\"当有设备接入时\",{\"1\":{\"296\":1}}],[\"当并发数很大时\",{\"1\":{\"331\":1}}],[\"当hash表的负载达到了指定的\",{\"1\":{\"328\":1}}],[\"当链表长度大于阈值\",{\"1\":{\"327\":1}}],[\"当链表长度大于8并且node数组长度大于64的时候\",{\"1\":{\"249\":1}}],[\"当多个线程对同一个集合的内容进行操作时\",{\"1\":{\"324\":1}}],[\"当多个磁盘i\",{\"1\":{\"183\":1}}],[\"当时的情况是怎么样的\",{\"1\":{\"311\":1}}],[\"当时的具体情况是怎样的\",{\"1\":{\"310\":1}}],[\"当imsi满足最近30天出现20天及以上\",{\"1\":{\"296\":1}}],[\"当遍历完所有小文件后\",{\"1\":{\"290\":1}}],[\"当我们关闭连接其实并不是关闭\",{\"1\":{\"1035\":1}}],[\"当我们使用了连接池后\",{\"1\":{\"1035\":1}}],[\"当我们点击抢购时\",{\"1\":{\"995\":1}}],[\"当我们客户端访问不存在的数据时\",{\"1\":{\"984\":1}}],[\"当我们修改了数据之后\",{\"1\":{\"983\":1}}],[\"当我们给redis设置了过期时间ttl之后\",{\"1\":{\"980\":1}}],[\"当我们向redis插入太多数据\",{\"1\":{\"980\":1}}],[\"当我们校验用户是否登录时\",{\"1\":{\"967\":1}}],[\"当我们调用一个业务方法时\",{\"1\":{\"720\":1}}],[\"当我们利用索引查询时候\",{\"1\":{\"376\":1}}],[\"当我们只查询user信息时\",{\"1\":{\"366\":1}}],[\"当我们往压缩列表中插入数据时\",{\"1\":{\"279\":1}}],[\"当我们需要判断一个元素是否存在于布隆过滤器的时候\",{\"1\":{\"273\":1}}],[\"当判断出缓冲区大小不够用时\",{\"1\":{\"277\":1}}],[\"当第二次存储相同字符串时\",{\"1\":{\"273\":1}}],[\"当位数组初始化时\",{\"1\":{\"273\":1}}],[\"当字符串存储要加入到布隆过滤器中时\",{\"1\":{\"273\":1}}],[\"当等待的线程数满足计数个数\",{\"1\":{\"263\":1}}],[\"当线程想要获取锁时\",{\"1\":{\"258\":1}}],[\"当队列为空时\",{\"1\":{\"254\":1}}],[\"当条件成立时\",{\"1\":{\"254\":1}}],[\"当tomcat端的socket接受到数据后\",{\"1\":{\"961\":1}}],[\"当t1释放锁t2被唤醒后\",{\"1\":{\"253\":1}}],[\"当thread\",{\"1\":{\"211\":1}}],[\"当可重入时\",{\"1\":{\"252\":1}}],[\"当初始化或扩容完成后\",{\"1\":{\"249\":1}}],[\"当初始化时\",{\"1\":{\"249\":1}}],[\"当扩容是\",{\"1\":{\"249\":1}}],[\"当使用了threadlocal对象之后\",{\"1\":{\"247\":1}}],[\"当你创建一个索引的时候\",{\"1\":{\"927\":1}}],[\"当你添加了数据库访问框架的起步依赖时\",{\"1\":{\"721\":1}}],[\"当你执行业务计算时\",{\"1\":{\"246\":1}}],[\"当你将浏览器配置成使用代理功能时\",{\"1\":{\"98\":1}}],[\"当活动线程数等于最大线程数且阻塞队列满的情况下采取的策略\",{\"1\":{\"243\":1}}],[\"当活动线程数==最大线程数且阻塞队列满的情况下采取的策略\",{\"1\":{\"242\":1}}],[\"当局部变量是引用变量时则需要进行逃逸分析判断\",{\"1\":{\"209\":1}}],[\"当调用一次\",{\"1\":{\"901\":1}}],[\"当调用\",{\"1\":{\"527\":1}}],[\"当调用unpark时\",{\"1\":{\"219\":1}}],[\"当调用park时会查看counter是否为0\",{\"1\":{\"219\":1}}],[\"当调用了start\",{\"1\":{\"208\":1}}],[\"当调用getinstance\",{\"1\":{\"101\":1}}],[\"当java进程中有多个线程执行时\",{\"1\":{\"207\":1}}],[\"当某个autoconfiguration类满足其注解\",{\"1\":{\"730\":1}}],[\"当某个socket有数据到达了就通知用户进程\",{\"1\":{\"409\":1}}],[\"当某个进程需要的资源被其他进程所占有的时候\",{\"1\":{\"148\":1}}],[\"当某个进程请求的资源得不到满足的时候\",{\"1\":{\"148\":1}}],[\"当某一列的值全是null时\",{\"1\":{\"267\":1}}],[\"当某页被访问时\",{\"1\":{\"163\":1}}],[\"当为进程分配的物理块数增大时\",{\"1\":{\"163\":1}}],[\"当所访问的信息不在内存时\",{\"1\":{\"161\":1,\"162\":1}}],[\"当大量作业要求运行时\",{\"1\":{\"161\":1}}],[\"当页表很大的时候\",{\"1\":{\"158\":1}}],[\"当进程调用epoll\",{\"1\":{\"410\":1}}],[\"当进程被调度时\",{\"1\":{\"157\":1}}],[\"当进程不能进入临界区时\",{\"1\":{\"140\":1}}],[\"当很多个空闲分区都能满足需求时\",{\"1\":{\"154\":1}}],[\"当用户开始进行下单\",{\"1\":{\"995\":1}}],[\"当用户开始查询redis时\",{\"1\":{\"989\":1}}],[\"当用户抢购时\",{\"1\":{\"992\":1}}],[\"当用户发起请求时\",{\"1\":{\"961\":1}}],[\"当用户发出read操作时\",{\"1\":{\"409\":1}}],[\"当用户进程调用了select\",{\"1\":{\"409\":1}}],[\"当用户进程调用了recvfrom这个系统调用\",{\"1\":{\"409\":1}}],[\"当用户进程要装入内存时\",{\"1\":{\"154\":1}}],[\"当用户请求访问某个设备时\",{\"1\":{\"183\":1}}],[\"当用户想要访问文件时\",{\"1\":{\"173\":1}}],[\"当用户需要使用一个文件的时候\",{\"1\":{\"168\":1}}],[\"当用户程序太大时\",{\"1\":{\"154\":1}}],[\"当然我们也可以通过help命令来帮助我们去查看命令\",{\"1\":{\"1023\":1}}],[\"当然我们可以对其进行修改\",{\"1\":{\"410\":1}}],[\"当然这也比我们直接使用syn来的好\",{\"1\":{\"997\":1}}],[\"当然乐观锁还有一些变种的处理方式比如cas\",{\"1\":{\"996\":1}}],[\"当然就会慢下来了\",{\"1\":{\"745\":1}}],[\"当然也可以使用aspectj\",{\"1\":{\"706\":1}}],[\"当然也可以配置关注哪个注解\",{\"1\":{\"661\":1}}],[\"当然也有人使用\",{\"1\":{\"439\":1}}],[\"当然还有其他解决方案\",{\"1\":{\"439\":1}}],[\"当然\",{\"1\":{\"258\":1,\"617\":1,\"668\":1,\"728\":1,\"825\":1,\"924\":1}}],[\"当然安全序列可能有多个\",{\"1\":{\"149\":1}}],[\"当然该方式也存在内存浪费问题\",{\"1\":{\"101\":1}}],[\"当该类资源又进程释放的时候\",{\"1\":{\"147\":1}}],[\"当资源已经分配完毕\",{\"1\":{\"143\":1}}],[\"当已有进程进入临界区\",{\"1\":{\"140\":1}}],[\"当临界区空闲的时候\",{\"1\":{\"140\":1}}],[\"当一个key过期时\",{\"1\":{\"436\":1}}],[\"当一个read操作发生时\",{\"1\":{\"409\":1}}],[\"当一个等待时间超过设置的某一阈值时\",{\"1\":{\"403\":1}}],[\"当一个元素加入布隆过滤器中的时候\",{\"1\":{\"273\":1}}],[\"当一个进程访问某临界资源的时候\",{\"1\":{\"140\":1}}],[\"当一个进程正在cpu上执行的时候\",{\"1\":{\"137\":1}}],[\"当一个线程被阻塞以后\",{\"1\":{\"135\":1}}],[\"当一个用户级线程被阻塞以后\",{\"1\":{\"135\":1}}],[\"当一个产品族中的多个对象被设计成一起工作时\",{\"1\":{\"75\":1}}],[\"当读进程将数据全部取走以后\",{\"1\":{\"134\":1}}],[\"当管道写满的时候\",{\"1\":{\"134\":1}}],[\"当前时间`\",{\"1\":{\"792\":1}}],[\"当前时间小于上一次生成id使用的时间\",{\"1\":{\"441\":1}}],[\"当前服务器时间戳\",{\"1\":{\"441\":1}}],[\"当前数据库还普遍采用wait\",{\"1\":{\"403\":1}}],[\"当前写操作没有完成前\",{\"1\":{\"398\":1}}],[\"当前类需要实现cloneable接口\",{\"1\":{\"351\":1}}],[\"当前位置\",{\"1\":{\"332\":1}}],[\"当前hash表中的元素数量\",{\"1\":{\"328\":1}}],[\"当前线程再加入到队列中等待唤醒\",{\"1\":{\"258\":1}}],[\"当前线程运行结束\",{\"1\":{\"208\":1}}],[\"当前有两个进程都要访问临界资源\",{\"1\":{\"141\":1}}],[\"当前运行进程重新回到就绪队列\",{\"1\":{\"139\":1}}],[\"当前运行的进程暂停运行\",{\"1\":{\"129\":1}}],[\"当前对象的方法参数等\",{\"1\":{\"111\":1}}],[\"当前对象的成员对象\",{\"1\":{\"111\":1}}],[\"当前对象所创建的对象\",{\"1\":{\"111\":1}}],[\"当前对象本身\",{\"1\":{\"111\":1}}],[\"当前系统业务所期待的接口\",{\"1\":{\"40\":1}}],[\"当软件需要发生变化时\",{\"1\":{\"107\":1}}],[\"当通过反射方式调用构造方法进行创建创建时\",{\"1\":{\"104\":1}}],[\"当互联网返回响应时\",{\"1\":{\"98\":1}}],[\"当自身状态发生变化后\",{\"1\":{\"81\":1}}],[\"当观察对象的状态发生变化时\",{\"1\":{\"80\":1}}],[\"当产品族中需要增加一个新的产品时\",{\"1\":{\"75\":1}}],[\"当不希望实现一个接口中所有的方法时\",{\"1\":{\"42\":1}}],[\"创建json序列化工具\",{\"1\":{\"1041\":1}}],[\"创建jedis的连接池\",{\"0\":{\"1034\":1}}],[\"创建redistemplate对象\",{\"1\":{\"1041\":1}}],[\"创建连接池对象\",{\"1\":{\"1034\":1}}],[\"创建连接器\",{\"1\":{\"655\":1}}],[\"创建工程\",{\"1\":{\"1032\":1}}],[\"创建订单\",{\"1\":{\"995\":2,\"998\":3}}],[\"创建订单时\",{\"1\":{\"313\":1}}],[\"创建新用户并保存\",{\"1\":{\"968\":1}}],[\"创建数据模型\",{\"1\":{\"934\":1}}],[\"创建es客户端\",{\"1\":{\"932\":1}}],[\"创建enhancer对象\",{\"1\":{\"95\":1}}],[\"创建多级目录用\",{\"1\":{\"872\":1}}],[\"创建一级目录\",{\"1\":{\"872\":1}}],[\"创建一个独立的\",{\"1\":{\"798\":1}}],[\"创建一个聊天组\",{\"1\":{\"758\":1}}],[\"创建一个新的事务\",{\"1\":{\"720\":1}}],[\"创建一个新的进程执行指定的字符串命令\",{\"1\":{\"105\":1}}],[\"创建一个新节点\",{\"1\":{\"282\":1}}],[\"创建一个新文件时\",{\"1\":{\"168\":1}}],[\"创建一个新对象\",{\"1\":{\"86\":2}}],[\"创建一个读卡器\",{\"1\":{\"41\":1}}],[\"创建时初始化好\",{\"1\":{\"790\":1}}],[\"创建了服务器\",{\"1\":{\"876\":1,\"877\":1}}],[\"创建了\",{\"1\":{\"790\":1}}],[\"创建成功\",{\"1\":{\"761\":1}}],[\"创建群聊\",{\"1\":{\"761\":1}}],[\"创建spring\",{\"1\":{\"731\":1}}],[\"创建singleton类的对象s2\",{\"1\":{\"103\":1}}],[\"创建singleton类的对象s1\",{\"1\":{\"103\":1}}],[\"创建并初始化容器\",{\"1\":{\"728\":1}}],[\"创建的产品\",{\"1\":{\"678\":1}}],[\"创建的对象较复杂\",{\"1\":{\"51\":1}}],[\"创建项目文件夹\",{\"1\":{\"655\":1}}],[\"创建模块\",{\"1\":{\"647\":1}}],[\"创建前后的增强\",{\"1\":{\"460\":1}}],[\"创建\",{\"0\":{\"818\":1,\"880\":1},\"1\":{\"458\":1,\"549\":1,\"644\":1,\"655\":2,\"790\":2,\"830\":1,\"834\":1,\"835\":1,\"844\":1,\"890\":1,\"896\":1}}],[\"创建容器\",{\"1\":{\"451\":2,\"650\":1}}],[\"创建普通索引就可以大幅提升数据查询的效率\",{\"1\":{\"383\":1}}],[\"创建索引\",{\"1\":{\"933\":2,\"950\":2}}],[\"创建索引注意事项\",{\"1\":{\"383\":1}}],[\"创建索引和维护索引要耗费时间\",{\"1\":{\"375\":1}}],[\"创建索引时避免有如下极端误解\",{\"1\":{\"266\":1}}],[\"创建hash表时指定的初始容量\",{\"1\":{\"328\":1}}],[\"创建文件\",{\"1\":{\"168\":1,\"171\":1}}],[\"创建态\",{\"1\":{\"132\":1}}],[\"创建代理类\",{\"1\":{\"787\":1}}],[\"创建代理的工作一般是在\",{\"1\":{\"659\":1}}],[\"创建代理工厂对象\",{\"1\":{\"95\":1}}],[\"创建代理对象\",{\"1\":{\"95\":1,\"528\":1}}],[\"创建对象\",{\"1\":{\"1042\":1}}],[\"创建对象的步骤\",{\"0\":{\"352\":1}}],[\"创建对象的方式\",{\"0\":{\"351\":1}}],[\"创建对象输出流\",{\"1\":{\"103\":1}}],[\"创建对象输出流对象\",{\"1\":{\"89\":1}}],[\"创建对象输入流对象\",{\"1\":{\"103\":1}}],[\"创建对象出入流对象\",{\"1\":{\"89\":1}}],[\"创建者模式对比\",{\"0\":{\"53\":1}}],[\"创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式\",{\"1\":{\"51\":1}}],[\"创建共享单车\",{\"1\":{\"49\":1}}],[\"创建适配器对象\",{\"1\":{\"42\":1}}],[\"对性能有一定影响\",{\"1\":{\"1008\":1}}],[\"对版本号进行+1\",{\"1\":{\"996\":1}}],[\"对产品口碑\",{\"1\":{\"974\":1}}],[\"对文档数据根据不同属性进行的分类标识\",{\"1\":{\"925\":1}}],[\"对自己感兴趣的事件进行处理\",{\"1\":{\"837\":1}}],[\"对方用户不存在或者不在线\",{\"1\":{\"760\":1}}],[\"对方考取的学校\",{\"1\":{\"731\":1}}],[\"对某些数据包又显得不够\",{\"1\":{\"754\":1}}],[\"对加了\",{\"1\":{\"711\":1}}],[\"对静态方法\",{\"1\":{\"504\":1}}],[\"对依赖注入阶段的扩展\",{\"1\":{\"463\":1}}],[\"对业务的影响非常大\",{\"1\":{\"437\":1}}],[\"对socket进行扫描时是线性扫描\",{\"1\":{\"410\":1}}],[\"对redo\",{\"1\":{\"396\":1}}],[\"对用于连接的字段创建索引\",{\"1\":{\"383\":1}}],[\"对用户不透明\",{\"1\":{\"153\":1}}],[\"对\",{\"1\":{\"383\":1,\"504\":1,\"705\":1,\"842\":1}}],[\"对分组或者排序的字段进行索引\",{\"1\":{\"383\":1}}],[\"对数据库访问压力过大\",{\"1\":{\"987\":1}}],[\"对数据库进行恢复\",{\"1\":{\"396\":1}}],[\"对数据被其他事务修改持乐观态度\",{\"1\":{\"397\":1}}],[\"对数据被其他事务修改持保守态度\",{\"1\":{\"397\":1}}],[\"对数据按照某个条件进行查询后再进行\",{\"1\":{\"383\":1}}],[\"对数据进行过滤\",{\"1\":{\"744\":1}}],[\"对数据进行排序的时候\",{\"1\":{\"383\":1}}],[\"对数据进行分组查询\",{\"1\":{\"383\":1}}],[\"对数据结构操作的一组过程\",{\"1\":{\"145\":1}}],[\"对拦截器代码进行了相关优化\",{\"1\":{\"368\":1}}],[\"对延迟反而带来负面效果\",{\"1\":{\"359\":1}}],[\"对齐填充\",{\"1\":{\"353\":1,\"770\":1,\"771\":1,\"773\":1}}],[\"对资源本身没有任何副作用\",{\"1\":{\"314\":1}}],[\"对华为价值观的认同\",{\"1\":{\"304\":1}}],[\"对知识的好奇心以及动手能力\",{\"1\":{\"303\":1}}],[\"对常驻人口统计完成后需要基于常住人口表统计常驻人口总人数\",{\"1\":{\"296\":1}}],[\"对人员行为进行统计分析\",{\"1\":{\"295\":1}}],[\"对500个小文件进行多路排序的思路如下\",{\"1\":{\"291\":1}}],[\"对500个小文件进行多路排序\",{\"1\":{\"291\":1}}],[\"对遍历到的每个词x\",{\"1\":{\"290\":1}}],[\"对字符串的操作效率不高\",{\"1\":{\"276\":1}}],[\"对字符串操作时\",{\"1\":{\"276\":1}}],[\"对程序员很不友好\",{\"1\":{\"276\":1}}],[\"对程序员的要求比较高\",{\"1\":{\"52\":1}}],[\"对给定元素再次进行相同的哈希计算\",{\"1\":{\"273\":1}}],[\"对索引进行范围检索\",{\"1\":{\"266\":1}}],[\"对外是一个虚拟视图\",{\"1\":{\"829\":1}}],[\"对外暴露的接口容易暴露信息\",{\"1\":{\"391\":1}}],[\"对外暴露的是\",{\"1\":{\"244\":1}}],[\"对外提供静态方法获取该对象\",{\"1\":{\"101\":7,\"103\":2,\"104\":2}}],[\"对内容进行复制\",{\"1\":{\"236\":1}}],[\"对i++操作的方法加同步锁\",{\"1\":{\"230\":1}}],[\"对volatile变量之间会加入读屏障\",{\"1\":{\"227\":1}}],[\"对volatile变量的写指令后会加入写屏障\",{\"1\":{\"227\":1}}],[\"对共享变量的读取\",{\"1\":{\"227\":1}}],[\"对共享变量的改动都会同步到主存中\",{\"1\":{\"227\":1,\"237\":1}}],[\"对共享数据设置初始值\",{\"1\":{\"145\":1}}],[\"对比\",{\"1\":{\"219\":1,\"490\":1}}],[\"对阻塞状态的线程来说只要他们一直不唤醒\",{\"1\":{\"208\":1}}],[\"对一些设备的错误进行处理\",{\"1\":{\"182\":1}}],[\"对设备的访问权限也不一样\",{\"1\":{\"182\":1}}],[\"对换性\",{\"1\":{\"161\":1}}],[\"对换区空间只占磁盘空间的小部分\",{\"1\":{\"153\":1}}],[\"对应配置\",{\"1\":{\"668\":1}}],[\"对应第2\",{\"1\":{\"651\":1}}],[\"对应第1步\",{\"1\":{\"651\":1}}],[\"对应\",{\"1\":{\"651\":1,\"790\":1}}],[\"对应的解析器\",{\"1\":{\"691\":2}}],[\"对应的自动配置类为\",{\"1\":{\"660\":1}}],[\"对应的控制器方法\",{\"1\":{\"644\":1}}],[\"对应的低级通知\",{\"0\":{\"543\":1}}],[\"对应代码\",{\"1\":{\"491\":1}}],[\"对应于do类名也是单数形式\",{\"1\":{\"265\":1}}],[\"对应于在代理对象上调用的接口方法的\",{\"1\":{\"94\":1}}],[\"对应分区的大小\",{\"1\":{\"154\":1}}],[\"对可剥夺的资源不会产生\",{\"1\":{\"147\":1}}],[\"对系统资源的竞争\",{\"1\":{\"147\":1}}],[\"对不可剥夺资源的竞争可能会引起死锁\",{\"1\":{\"147\":1}}],[\"对不同的临界资源需要设置不同的互斥信号量\",{\"1\":{\"144\":1}}],[\"对不起\",{\"1\":{\"63\":1}}],[\"对信号量的操作只有三种\",{\"1\":{\"143\":1}}],[\"对请求访问的进程\",{\"1\":{\"140\":1}}],[\"对其他调度算法的折中权衡\",{\"1\":{\"139\":1}}],[\"对长作业不利\",{\"1\":{\"139\":1}}],[\"对短作业有利\",{\"1\":{\"139\":1}}],[\"对短作业不利\",{\"1\":{\"139\":1}}],[\"对短作业来说用户体验不好\",{\"1\":{\"139\":1}}],[\"对新的进程各种数据的恢复\",{\"1\":{\"137\":1}}],[\"对原来代码没有侵入性\",{\"1\":{\"989\":1}}],[\"对原来运行进程各种数据的保存\",{\"1\":{\"137\":1}}],[\"对原始\",{\"1\":{\"825\":1,\"826\":1}}],[\"对原始类功能进行增强\",{\"1\":{\"45\":1}}],[\"对操作系统不透明\",{\"1\":{\"135\":1}}],[\"对操作系统透明\",{\"1\":{\"135\":1}}],[\"对每个不同的实现都需要定义一个子类\",{\"1\":{\"121\":1}}],[\"对银行工作人员进行评分等\",{\"1\":{\"118\":1}}],[\"对修改关闭\",{\"1\":{\"107\":1}}],[\"对扩展开放\",{\"1\":{\"107\":1}}],[\"对接口进行代理\",{\"1\":{\"95\":1}}],[\"对具体原型类\",{\"1\":{\"89\":1}}],[\"对象被垃圾回收\",{\"1\":{\"905\":1}}],[\"对象仅维护了此内存的虚引用\",{\"1\":{\"905\":1}}],[\"对象还在\",{\"1\":{\"825\":1}}],[\"对象中不能\",{\"1\":{\"803\":1}}],[\"对象中显示的都是李四\",{\"1\":{\"89\":1}}],[\"对象异步接收结果线程\",{\"1\":{\"787\":1}}],[\"对象变为要传输的数据\",{\"1\":{\"773\":1}}],[\"对象装配\",{\"1\":{\"695\":2}}],[\"对象绑定与类型转换\",{\"0\":{\"573\":1}}],[\"对象也能够销毁\",{\"1\":{\"458\":1}}],[\"对象注册到\",{\"1\":{\"454\":1}}],[\"对象真正存储的有效数据\",{\"1\":{\"353\":1}}],[\"对象的初始计数为\",{\"1\":{\"825\":1}}],[\"对象的类型是代理类型\",{\"1\":{\"500\":1}}],[\"对象的内部结构\",{\"1\":{\"449\":1}}],[\"对象的内存布局\",{\"0\":{\"353\":1}}],[\"对象的创建非常复杂\",{\"1\":{\"88\":1}}],[\"对象创建才刚刚开始\",{\"1\":{\"352\":1}}],[\"对象\",{\"1\":{\"244\":1,\"265\":1,\"278\":4,\"454\":1,\"500\":1,\"545\":1,\"549\":1,\"575\":1,\"622\":1,\"644\":2,\"650\":1,\"655\":1,\"703\":1,\"773\":1,\"787\":2,\"788\":1,\"803\":3,\"804\":1,\"809\":1,\"825\":1,\"835\":1}}],[\"对象头\",{\"0\":{\"210\":1},\"1\":{\"353\":1}}],[\"对象间的耦合度低\",{\"1\":{\"112\":1}}],[\"对象r1和r2是同一个对象\",{\"1\":{\"86\":1}}],[\"对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中\",{\"1\":{\"42\":1}}],[\"对象适配器模式\",{\"0\":{\"42\":1}}],[\"对上面的代码大家应该很熟\",{\"1\":{\"78\":1}}],[\"对组件进行一定顺序的组装\",{\"1\":{\"49\":1}}],[\"对于一些数据\",{\"1\":{\"1024\":1}}],[\"对于一次i\",{\"1\":{\"409\":1}}],[\"对于存储的数据\",{\"1\":{\"1001\":1}}],[\"对于作为用户的你来说\",{\"1\":{\"927\":1}}],[\"对于作业来说\",{\"1\":{\"138\":1}}],[\"对于声明式事务\",{\"1\":{\"721\":1}}],[\"对于多例的对象因为要频繁创建代理对象\",{\"1\":{\"718\":1}}],[\"对于单例的对象无需频繁创建代理对象\",{\"1\":{\"718\":1}}],[\"对于单例对象来讲\",{\"1\":{\"500\":1}}],[\"对于不受容器管理的对象不能增强\",{\"1\":{\"717\":1}}],[\"对于不同的中断信号\",{\"1\":{\"129\":1}}],[\"对于aspectj的实现也有两种\",{\"1\":{\"714\":1}}],[\"对于beanfactory而言\",{\"1\":{\"707\":1}}],[\"对于资源有限\",{\"1\":{\"707\":1}}],[\"对于资源的分配\",{\"1\":{\"135\":1}}],[\"对于没有实现接口的对象\",{\"1\":{\"706\":1}}],[\"对于部署的不同雪花算法服务中\",{\"1\":{\"443\":1}}],[\"对于机器码\",{\"1\":{\"443\":1}}],[\"对于水平分表就需要保证表中\",{\"1\":{\"439\":1}}],[\"对于段式管理\",{\"1\":{\"413\":1}}],[\"对于页表所需的内存空间\",{\"1\":{\"413\":1}}],[\"对于每一个雪花算法服务\",{\"1\":{\"440\":1}}],[\"对于每一个socket\",{\"1\":{\"409\":1}}],[\"对于每个人都是唯一的\",{\"1\":{\"296\":1}}],[\"对于缓存i\",{\"1\":{\"409\":1}}],[\"对于32位操作系统而言\",{\"1\":{\"406\":1}}],[\"对于update\",{\"1\":{\"396\":1}}],[\"对于delete\",{\"1\":{\"396\":1}}],[\"对于insert\",{\"1\":{\"396\":1}}],[\"对于可重复读\",{\"1\":{\"393\":1}}],[\"对于可变长记录文件\",{\"1\":{\"167\":1}}],[\"对于核心业务\",{\"1\":{\"392\":1}}],[\"对于count\",{\"1\":{\"387\":1}}],[\"对于等值查询来说\",{\"1\":{\"381\":1}}],[\"对于联合索引的情况\",{\"1\":{\"381\":1}}],[\"对于引用类型来说\",{\"1\":{\"319\":2}}],[\"对于基本类型来说\",{\"1\":{\"319\":1}}],[\"对于客户端交互的接口\",{\"1\":{\"315\":1}}],[\"对于遍历到的词x\",{\"1\":{\"290\":1}}],[\"对于队列中的线程是公平的\",{\"1\":{\"258\":1}}],[\"对于jdk\",{\"1\":{\"249\":2}}],[\"对于局部变量不管是基本类型还是包装类型都不需要考虑\",{\"1\":{\"230\":1}}],[\"对于临界资源的互斥访问可以分为四个部分\",{\"1\":{\"140\":1}}],[\"对于临界资源的访问\",{\"1\":{\"140\":1}}],[\"对于抢占式还需要在就绪队列变化时\",{\"1\":{\"139\":1}}],[\"对于非抢占式只需要在进程主动放弃处理机时进程调度即可\",{\"1\":{\"139\":1}}],[\"对于非基本类型属性\",{\"1\":{\"86\":1}}],[\"对于长作业来说\",{\"1\":{\"139\":1}}],[\"对于进程来说\",{\"1\":{\"138\":1}}],[\"对于系统开销\",{\"1\":{\"135\":1}}],[\"对于并发性\",{\"1\":{\"135\":1}}],[\"对于\",{\"1\":{\"101\":1,\"439\":2,\"649\":1,\"825\":1}}],[\"对于自行车的生产就可以使用建造者模式\",{\"1\":{\"49\":1}}],[\"对于输入是416∗416的图像\",{\"1\":{\"24\":1}}],[\"对于输入为256∗256的图像\",{\"1\":{\"22\":1}}],[\"对他中的抽象的未实现的方法给出实现\",{\"1\":{\"44\":1}}],[\"测试代码\",{\"0\":{\"1040\":1}}],[\"测试方法\",{\"1\":{\"515\":1}}],[\"测试\",{\"0\":{\"648\":1},\"1\":{\"500\":1,\"770\":1,\"1032\":1}}],[\"测试访问类\",{\"1\":{\"86\":1,\"87\":1,\"94\":1}}],[\"测试类用来组装电脑\",{\"1\":{\"109\":1}}],[\"测试类\",{\"1\":{\"41\":1,\"42\":1,\"49\":1,\"89\":1,\"93\":1,\"94\":1,\"95\":1,\"109\":1,\"993\":1}}],[\"测试过程\",{\"0\":{\"28\":1}}],[\"=1\",{\"1\":{\"996\":1}}],[\"=1k个键值\",{\"1\":{\"377\":1}}],[\"=69\",{\"1\":{\"440\":1}}],[\"=f\",{\"1\":{\"312\":1}}],[\"=max\",{\"1\":{\"195\":1}}],[\"=>\",{\"1\":{\"108\":1,\"834\":1,\"835\":1,\"842\":2}}],[\"=new\",{\"1\":{\"95\":1}}],[\"========================\",{\"1\":{\"826\":1}}],[\"==================================\",{\"1\":{\"759\":2}}],[\"==比较的是两个引用是否指向同一个对象地址\",{\"1\":{\"319\":1}}],[\"==比较的是值是否相等\",{\"1\":{\"319\":1}}],[\"==与equals的区别\",{\"0\":{\"319\":1}}],[\"==\",{\"1\":{\"41\":1,\"57\":4,\"58\":1,\"86\":1,\"89\":2,\"101\":6,\"103\":2,\"104\":1,\"116\":4,\"123\":4,\"236\":2,\"244\":1,\"249\":14,\"258\":1,\"282\":10,\"283\":1,\"285\":1,\"336\":1,\"386\":2,\"441\":2,\"761\":1,\"764\":2,\"773\":2,\"790\":1,\"791\":3,\"792\":2,\"793\":2,\"818\":1,\"846\":1,\"849\":1,\"859\":1,\"886\":1,\"889\":1,\"890\":3,\"896\":1,\"909\":1,\"960\":2,\"961\":1,\"968\":2,\"972\":1,\"983\":1,\"990\":2,\"996\":1}}],[\"=\",{\"0\":{\"722\":1},\"1\":{\"41\":5,\"42\":5,\"49\":7,\"52\":18,\"57\":4,\"63\":3,\"65\":3,\"69\":2,\"77\":7,\"78\":3,\"82\":10,\"86\":2,\"87\":3,\"89\":15,\"93\":2,\"94\":16,\"95\":5,\"101\":7,\"103\":14,\"104\":10,\"105\":6,\"108\":3,\"109\":8,\"111\":3,\"116\":32,\"120\":2,\"123\":5,\"126\":2,\"138\":5,\"139\":1,\"141\":1,\"151\":5,\"156\":2,\"160\":1,\"163\":2,\"170\":1,\"176\":2,\"191\":12,\"192\":6,\"194\":27,\"195\":17,\"206\":2,\"211\":2,\"221\":2,\"224\":13,\"225\":34,\"232\":21,\"235\":2,\"236\":1,\"237\":1,\"242\":1,\"249\":45,\"255\":3,\"260\":7,\"261\":1,\"262\":1,\"263\":6,\"268\":1,\"272\":2,\"282\":14,\"283\":17,\"285\":10,\"287\":6,\"321\":2,\"328\":1,\"336\":3,\"337\":1,\"339\":4,\"341\":2,\"342\":4,\"343\":5,\"359\":1,\"366\":8,\"368\":4,\"370\":3,\"371\":4,\"381\":1,\"385\":1,\"386\":1,\"435\":1,\"441\":27,\"450\":2,\"463\":3,\"491\":1,\"496\":1,\"500\":7,\"503\":2,\"510\":3,\"512\":4,\"515\":6,\"523\":5,\"531\":2,\"622\":1,\"635\":4,\"638\":1,\"641\":1,\"655\":5,\"657\":1,\"731\":4,\"732\":2,\"737\":2,\"743\":3,\"744\":6,\"745\":1,\"749\":13,\"750\":2,\"751\":2,\"753\":6,\"754\":11,\"755\":9,\"756\":10,\"759\":26,\"760\":8,\"761\":11,\"764\":2,\"767\":7,\"768\":6,\"770\":17,\"771\":13,\"773\":42,\"775\":8,\"776\":4,\"783\":28,\"784\":4,\"785\":8,\"787\":17,\"788\":6,\"790\":36,\"791\":10,\"792\":23,\"793\":25,\"794\":12,\"796\":2,\"798\":8,\"799\":2,\"800\":1,\"801\":1,\"803\":4,\"804\":5,\"805\":1,\"807\":2,\"808\":3,\"809\":3,\"810\":2,\"811\":2,\"812\":3,\"813\":3,\"814\":3,\"815\":2,\"816\":5,\"818\":4,\"819\":2,\"825\":1,\"826\":5,\"829\":4,\"830\":4,\"844\":7,\"845\":9,\"846\":4,\"849\":44,\"851\":2,\"852\":1,\"853\":2,\"855\":3,\"857\":5,\"858\":4,\"859\":4,\"864\":1,\"865\":1,\"867\":2,\"870\":11,\"871\":5,\"872\":15,\"873\":5,\"876\":5,\"877\":6,\"880\":1,\"881\":1,\"882\":3,\"884\":10,\"886\":12,\"889\":6,\"890\":19,\"893\":19,\"896\":29,\"898\":5,\"904\":4,\"907\":2,\"909\":5,\"932\":1,\"933\":10,\"934\":19,\"936\":4,\"937\":4,\"938\":5,\"939\":5,\"940\":7,\"941\":6,\"942\":6,\"943\":6,\"944\":7,\"945\":6,\"946\":6,\"949\":2,\"950\":22,\"960\":6,\"961\":2,\"962\":1,\"968\":10,\"972\":5,\"974\":4,\"983\":4,\"985\":5,\"988\":7,\"989\":10,\"990\":28,\"993\":17,\"994\":1,\"995\":6,\"996\":2,\"997\":6,\"998\":25,\"1032\":8,\"1034\":2,\"1035\":3,\"1040\":2,\"1041\":2,\"1042\":8,\"1043\":2}}],[\"=pdata\",{\"1\":{\"8\":1}}],[\"而springdataredis又对这两种做了抽象和封装\",{\"1\":{\"1031\":1}}],[\"而synchronized关键字解决的是多个线程之间访问资源的同步性\",{\"1\":{\"228\":1}}],[\"而value的形式多种多样\",{\"1\":{\"1001\":1}}],[\"而现在是插入数据\",{\"1\":{\"998\":1}}],[\"而对于加锁\",{\"1\":{\"996\":1}}],[\"而对象的创建是在静态代码块中\",{\"1\":{\"101\":1}}],[\"而特价券需要秒杀抢购\",{\"1\":{\"994\":1}}],[\"而订单表如果使用数据库自增id就存在一些问题\",{\"1\":{\"992\":1}}],[\"而线程1直接进行返回\",{\"1\":{\"987\":1}}],[\"而线程对象是通过强引用指向threadlocalmap\",{\"1\":{\"247\":1}}],[\"而缓存却没有同步\",{\"1\":{\"981\":1}}],[\"而数据库的数据是会发生变化的\",{\"1\":{\"981\":1}}],[\"而数据库字段必须加is\",{\"1\":{\"268\":1}}],[\"而代金券由于优惠力度大\",{\"1\":{\"994\":1}}],[\"而代码运行在内存中\",{\"1\":{\"975\":1}}],[\"而代理类是程序在运行过程中动态的在内存中生成的类\",{\"1\":{\"94\":1}}],[\"而代理模式\",{\"1\":{\"45\":1}}],[\"而任一节点都可能没有这样大的磁盘空间\",{\"1\":{\"927\":1}}],[\"而json是一个到处存在的互联网数据交互格式\",{\"1\":{\"924\":1}}],[\"而之前的\",{\"1\":{\"911\":1}}],[\"而后面要讲的\",{\"1\":{\"816\":1}}],[\"而提交的任务会被包装为\",{\"1\":{\"815\":1}}],[\"而意思却是完全不同\",{\"1\":{\"766\":1}}],[\"而reactive\",{\"1\":{\"742\":1}}],[\"而redo\",{\"1\":{\"396\":1}}],[\"而非关系型数据库往往不支持事务\",{\"1\":{\"1007\":1}}],[\"而非关系型数据库不存在关联关系\",{\"1\":{\"1005\":1}}],[\"而非分\",{\"1\":{\"749\":1}}],[\"而非真正的视图对象\",{\"1\":{\"736\":1}}],[\"而非未来\",{\"1\":{\"731\":1}}],[\"而非加强功能\",{\"1\":{\"45\":1}}],[\"而实现依赖注入的关键是ioc容器\",{\"1\":{\"706\":1}}],[\"而实现了cloneable接口的子实现类就是具体的原型类\",{\"1\":{\"86\":1}}],[\"而内嵌\",{\"1\":{\"648\":1}}],[\"而内存的扩大\",{\"1\":{\"359\":1}}],[\"而言\",{\"1\":{\"439\":1}}],[\"而键值对读写命令仍然是单线程处理的\",{\"1\":{\"423\":1}}],[\"而其他的持久化\",{\"1\":{\"423\":1}}],[\"而需把它们调入内存\",{\"1\":{\"420\":1}}],[\"而分页存储管理不能提供虚存\",{\"1\":{\"419\":1}}],[\"而仅需将那些当前要运行的少数页面或段先装入内存便可运行\",{\"1\":{\"418\":1}}],[\"而物理地址指的是真实物理内存中的地址\",{\"1\":{\"414\":1}}],[\"而段的大小不固定\",{\"1\":{\"413\":1}}],[\"而跟连接总数无关\",{\"1\":{\"410\":1}}],[\"而异步io则无需自己负责进行读写\",{\"1\":{\"410\":1}}],[\"而另一方面\",{\"1\":{\"409\":1}}],[\"而这些文件描述符\",{\"1\":{\"409\":1}}],[\"而同时\",{\"1\":{\"409\":1}}],[\"而innodb同时支持表锁和行锁\",{\"1\":{\"396\":1}}],[\"而此时的\",{\"1\":{\"491\":1}}],[\"而此时buffer\",{\"1\":{\"396\":1}}],[\"而此时我们只需要继承该抽象类即可\",{\"1\":{\"42\":1}}],[\"而树型的依然能够保持o\",{\"1\":{\"381\":1}}],[\"而在用户进程这边\",{\"1\":{\"409\":1}}],[\"而在b树中则需要通过中序遍历才能完成范围查询\",{\"1\":{\"378\":1}}],[\"而在微观上交替使用\",{\"1\":{\"185\":1}}],[\"而blocking\",{\"1\":{\"409\":1}}],[\"而b\",{\"1\":{\"378\":1}}],[\"而bio是单向的\",{\"1\":{\"332\":1}}],[\"而只是叶子节点中关键字的索引\",{\"1\":{\"378\":1}}],[\"而$\",{\"1\":{\"366\":1}}],[\"而引导类加载器在加载的过程中会先加载jdk自带的文件\",{\"1\":{\"346\":1}}],[\"而抽象类的成员变量默认default\",{\"1\":{\"317\":1}}],[\"而抽象工厂模式可生产多个等级的产品\",{\"1\":{\"72\":1}}],[\"而k\",{\"1\":{\"300\":1}}],[\"而我们自己的\",{\"1\":{\"798\":1}}],[\"而我们使用的插头如下图最右边的\",{\"1\":{\"39\":1}}],[\"而我做的部分就是进行编写设备展示接口以及设备按条件复合查询接口\",{\"1\":{\"296\":1}}],[\"而扩展功能受某些情况影响可能会失效\",{\"1\":{\"490\":1}}],[\"而扩展\",{\"1\":{\"280\":1}}],[\"而当新插入的元素较大时\",{\"1\":{\"280\":1}}],[\"而查找其他元素时\",{\"1\":{\"279\":1}}],[\"而无须执行内存分配\",{\"1\":{\"277\":1}}],[\"而无须知道其内部的具体构造细节\",{\"1\":{\"47\":1}}],[\"而一旦命中后\",{\"1\":{\"989\":1}}],[\"而一旦这个假定不成立\",{\"1\":{\"276\":1}}],[\"而一致性则由表级锁来保证\",{\"1\":{\"387\":1}}],[\"而一直没有使用就会造成内存的浪费\",{\"1\":{\"101\":1}}],[\"而字符数组的结尾位置就用\",{\"1\":{\"276\":1}}],[\"而count\",{\"1\":{\"267\":2}}],[\"而覆盖索引只是一种查询的一种效果\",{\"1\":{\"266\":1}}],[\"而thread\",{\"1\":{\"261\":1}}],[\"而test\",{\"1\":{\"142\":1}}],[\"而nosql则对数据库格式没有严格约束\",{\"1\":{\"1004\":1}}],[\"而nosql则是相对于传统关系型数据库而言\",{\"1\":{\"1001\":1}}],[\"而non\",{\"1\":{\"409\":1}}],[\"而notify只能随机唤醒一个等待线程\",{\"1\":{\"219\":1}}],[\"而nio基于channel和buffer进行操作\",{\"1\":{\"334\":1}}],[\"而nio是非阻塞的\",{\"1\":{\"334\":1}}],[\"而nio以块\",{\"1\":{\"334\":1}}],[\"而newsinglethreadexecutor线程池还会新建一个线程\",{\"1\":{\"244\":1}}],[\"而导致代码一直在运行\",{\"1\":{\"222\":1}}],[\"而wait\",{\"1\":{\"219\":1}}],[\"而park和unpark不必\",{\"1\":{\"219\":1}}],[\"而p0又不需要访问\",{\"1\":{\"141\":1}}],[\"而消费者专心处理结果数据\",{\"1\":{\"218\":1}}],[\"而频繁的中断处理会消耗较多的cpu时间\",{\"1\":{\"181\":1}}],[\"而转速是硬件固有的属性\",{\"1\":{\"176\":1}}],[\"而读取又分为两个阶段\",{\"1\":{\"901\":1}}],[\"而读取配置文件以及创建对象写在静态代码块中\",{\"1\":{\"77\":1}}],[\"而读\",{\"1\":{\"176\":1}}],[\"而每条undo\",{\"1\":{\"393\":1}}],[\"而每次调页都要磁盘i\",{\"1\":{\"164\":1}}],[\"而每个具体的皮肤\",{\"1\":{\"107\":1}}],[\"而aspectj基于字节码操作\",{\"1\":{\"715\":1}}],[\"而aspectj是编译时或者类加载时增强\",{\"1\":{\"715\":1}}],[\"而a\",{\"1\":{\"162\":1}}],[\"而系统负荷降低就暂停\",{\"1\":{\"153\":1}}],[\"而该资源又被其他进程占有\",{\"1\":{\"147\":1}}],[\"而该安全门只具有防盗\",{\"1\":{\"110\":1}}],[\"而传统的进程只能串行的执行一系列程序\",{\"1\":{\"135\":1}}],[\"而暂时不能够运行\",{\"1\":{\"132\":1}}],[\"而逻辑上的对应物是用户感受到的\",{\"1\":{\"127\":1}}],[\"而\",{\"1\":{\"123\":1,\"234\":1,\"277\":1,\"705\":1,\"713\":1,\"791\":1,\"802\":1,\"806\":1,\"816\":1,\"878\":1}}],[\"而将其他部分留在外存\",{\"1\":{\"419\":1}}],[\"而将较低的3g字节供各个进程使用\",{\"1\":{\"406\":1}}],[\"而将各段分页是对用户不可见的\",{\"1\":{\"160\":1}}],[\"而将不同的代码放入不同的子类中\",{\"1\":{\"121\":1}}],[\"而将算法的一些步骤延迟到子类中\",{\"1\":{\"118\":1}}],[\"而粉丝和媒体公司是陌生人\",{\"1\":{\"111\":1}}],[\"而软件中易变的细节可以从抽象派生来的实现类来进行扩展\",{\"1\":{\"107\":1}}],[\"而不用直接去new对象\",{\"1\":{\"1035\":1}}],[\"而不同的非关系数据库查询语法差异极大\",{\"1\":{\"1006\":1}}],[\"而不管这样的复制是否有意义\",{\"1\":{\"410\":1}}],[\"而不能一个为\",{\"1\":{\"383\":1}}],[\"而不是直接返回nil\",{\"1\":{\"1028\":1}}],[\"而不是让一个用户下多个单\",{\"1\":{\"998\":1}}],[\"而不是容器申请时的个数\",{\"1\":{\"897\":1}}],[\"而不是给\",{\"1\":{\"834\":1}}],[\"而不是等\",{\"1\":{\"825\":1}}],[\"而不是期望的多例对象\",{\"1\":{\"500\":1}}],[\"而不是被socket\",{\"1\":{\"409\":1}}],[\"而不是转换为红黑树\",{\"1\":{\"327\":1}}],[\"而不是\",{\"1\":{\"277\":1}}],[\"而不是非常准确的\",{\"1\":{\"272\":1}}],[\"而不是true\",{\"1\":{\"267\":2}}],[\"而不是false\",{\"1\":{\"267\":1}}],[\"而不是操作系统\",{\"1\":{\"134\":1}}],[\"而不是依赖于各个组件具体的实现类\",{\"1\":{\"109\":1}}],[\"而不必过多关心通信部分的细节\",{\"1\":{\"98\":1}}],[\"而不需要修改原代码\",{\"1\":{\"107\":1}}],[\"而不需要像静态代理那样每一个方法进行中转\",{\"1\":{\"96\":1}}],[\"而不需要在原代码中修改\",{\"1\":{\"64\":1}}],[\"而动态代理不会出现该问题\",{\"1\":{\"96\":1}}],[\"而动态代理代理类则是在java运行时动态生成\",{\"1\":{\"91\":1}}],[\"而是直接使用\",{\"1\":{\"1042\":1}}],[\"而是直接使用threadpoolexecutor构造方法\",{\"1\":{\"244\":1}}],[\"而是我们自己来控制序列化的动作\",{\"1\":{\"1042\":1}}],[\"而是我们后续通过逻辑去处理\",{\"1\":{\"987\":1}}],[\"而是将jedis还回连接池的\",{\"1\":{\"1035\":1}}],[\"而是将来由操作系统来通过回调方式由另外的线程来获得结果\",{\"1\":{\"906\":1}}],[\"而是拼接一些其它信息\",{\"1\":{\"992\":1}}],[\"而是在不会拷贝重复数据到\",{\"1\":{\"905\":1}}],[\"而是在于能处理更多的连接\",{\"1\":{\"409\":1}}],[\"而是缓存的复制\",{\"1\":{\"904\":1}}],[\"而是由其它线程送结果\",{\"1\":{\"901\":1}}],[\"而是通过\",{\"1\":{\"806\":1}}],[\"而是通过程序来实现\",{\"1\":{\"397\":1}}],[\"而是作为spring的脚手架框架\",{\"1\":{\"726\":1}}],[\"而是用\",{\"1\":{\"695\":1}}],[\"而是另一个\",{\"1\":{\"678\":1}}],[\"而是每个接口会对应一个\",{\"1\":{\"661\":1}}],[\"而是需要当前服务器时间戳减去某一个初始时间戳值\",{\"1\":{\"443\":1}}],[\"而是自己构建了一种简单动态字符串\",{\"1\":{\"422\":1}}],[\"而是自己封装了一个名为简单动态字符串\",{\"1\":{\"275\":1}}],[\"而是马上就得到了一个结果\",{\"1\":{\"409\":1}}],[\"而是立刻返回一个error\",{\"1\":{\"409\":1}}],[\"而是把这个请求委托给父类的加载器去执行\",{\"1\":{\"345\":1}}],[\"而是把地址转换推迟到程序真正要执行时才进行\",{\"1\":{\"151\":1}}],[\"而是有个专门的\",{\"1\":{\"277\":1}}],[\"而是取offset+n行\",{\"1\":{\"266\":1}}],[\"而是表示unsafe类中的操作不安全\",{\"1\":{\"235\":1}}],[\"而是允许在作业运行过程中\",{\"1\":{\"161\":1}}],[\"而是被允许分成多次调入内存\",{\"1\":{\"161\":1}}],[\"而是被动地接受来自subject角色的通知\",{\"1\":{\"80\":1}}],[\"而是会常驻内存\",{\"1\":{\"136\":1}}],[\"而是走走停停\",{\"1\":{\"127\":1}}],[\"而是首次使用该对象时才会创建\",{\"1\":{\"101\":1}}],[\"而是提供了一个创建代理对象的静态方法\",{\"1\":{\"94\":1}}],[\"而火车站在多个地方都有代售点\",{\"1\":{\"93\":1}}],[\"而进行深克隆需要使用对象流\",{\"1\":{\"89\":1}}],[\"而单列集合获取迭代器的方法就使用到了工厂方法模式\",{\"1\":{\"78\":1}}],[\"而且支持跨进程的同步机制\",{\"1\":{\"1031\":1}}],[\"而且redis官方也没有提供windows版本的安装包\",{\"1\":{\"1010\":1}}],[\"而且脱离了任务独立存在\",{\"1\":{\"806\":1}}],[\"而且医生看病的过程中是以病人为单位的\",{\"1\":{\"805\":1}}],[\"而且很多地方我们只能通过\",{\"1\":{\"713\":1}}],[\"而且很容易引入错误\",{\"1\":{\"52\":1}}],[\"而且大数据量也导致分库分表的产生\",{\"1\":{\"439\":1}}],[\"而且哨兵模式只有一个主节点对外提供服务\",{\"1\":{\"433\":1}}],[\"而且无法\",{\"1\":{\"419\":1}}],[\"而且非常消耗性能\",{\"1\":{\"328\":1}}],[\"而且会针对不同长度的数据\",{\"1\":{\"278\":1}}],[\"而且\",{\"1\":{\"276\":1,\"277\":1,\"279\":1}}],[\"而且确定了这些步骤的执行顺序\",{\"1\":{\"118\":1}}],[\"而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式\",{\"1\":{\"101\":1}}],[\"而且克服了它的缺点\",{\"1\":{\"69\":1}}],[\"而如果使用建造者模式\",{\"1\":{\"54\":1}}],[\"而建造者模式注重的是部件构建的过程\",{\"1\":{\"54\":1}}],[\"而车架又有碳纤维\",{\"1\":{\"49\":1}}],[\"而从如上sun\",{\"1\":{\"44\":1}}],[\"而要读取tf卡中的内容的话就需要使用到适配器模式\",{\"1\":{\"41\":1}}],[\"现象分析\",{\"0\":{\"751\":1}}],[\"现象\",{\"1\":{\"139\":1,\"164\":1,\"751\":2}}],[\"现通过模板方法模式来用代码模拟\",{\"1\":{\"120\":1}}],[\"现要组装一台电脑\",{\"1\":{\"109\":1}}],[\"现咖啡店业务发生改变\",{\"1\":{\"74\":1}}],[\"现在\",{\"1\":{\"1016\":1}}],[\"现在都是多核\",{\"1\":{\"896\":1}}],[\"现在要求你编写程序\",{\"1\":{\"859\":1}}],[\"现在需要一个新的\",{\"1\":{\"829\":1}}],[\"现在把它拆开来看\",{\"1\":{\"803\":1}}],[\"现在的问题还是和之前一样\",{\"1\":{\"998\":1}}],[\"现在的问题在于\",{\"1\":{\"998\":1}}],[\"现在的方案是\",{\"1\":{\"988\":1}}],[\"现在的逻辑中\",{\"1\":{\"985\":1}}],[\"现在的服务基本是分布式\",{\"1\":{\"439\":1}}],[\"现在的操作系统都是采用虚拟存储器\",{\"1\":{\"406\":1}}],[\"现在的我不会为谁停留\",{\"1\":{\"37\":1}}],[\"现在的我在哪里逗留\",{\"1\":{\"37\":1}}],[\"现在回顾此事\",{\"1\":{\"310\":1,\"311\":1}}],[\"现在假设一个压缩列表中有多个连续的\",{\"1\":{\"280\":1}}],[\"现在不使用了\",{\"1\":{\"153\":1}}],[\"现在使用\",{\"1\":{\"151\":1}}],[\"现在使用简单工厂对上面案例进行改进\",{\"1\":{\"63\":1}}],[\"现在如果我们还需要再创建一个传智品牌的安全门\",{\"1\":{\"110\":1}}],[\"现有一台电脑只能读取sd卡\",{\"1\":{\"41\":1}}],[\"例6\",{\"0\":{\"815\":1}}],[\"例5\",{\"0\":{\"814\":1}}],[\"例4\",{\"0\":{\"813\":1}}],[\"例3\",{\"0\":{\"812\":1},\"1\":{\"974\":3}}],[\"例2\",{\"0\":{\"811\":1},\"1\":{\"974\":1}}],[\"例1\",{\"0\":{\"810\":1},\"1\":{\"974\":1}}],[\"例外\",{\"1\":{\"531\":1}}],[\"例子中通过反射查看了它的成员变量\",{\"1\":{\"449\":1}}],[\"例如map\",{\"1\":{\"1031\":1}}],[\"例如myisam只支持表锁\",{\"1\":{\"396\":1}}],[\"例如两个集合\",{\"1\":{\"1029\":1}}],[\"例如一个user对象\",{\"1\":{\"1026\":1}}],[\"例如我们的项目名称叫\",{\"1\":{\"1026\":1}}],[\"例如外键\",{\"1\":{\"1005\":1}}],[\"例如目录结构如下\",{\"1\":{\"871\":1}}],[\"例如原始数据有3条为\",{\"1\":{\"859\":1}}],[\"例如调用\",{\"1\":{\"847\":2}}],[\"例如在这个位置加入\",{\"1\":{\"845\":1}}],[\"例如读了\",{\"1\":{\"824\":1}}],[\"例如写入后大小为\",{\"1\":{\"823\":2}}],[\"例如网卡\",{\"1\":{\"764\":1}}],[\"例如根据\",{\"1\":{\"644\":1}}],[\"例如控制器内\",{\"1\":{\"617\":1}}],[\"例如有参构造\",{\"1\":{\"582\":1}}],[\"例如有3张拆分表\",{\"1\":{\"439\":1}}],[\"例如对构造\",{\"1\":{\"504\":1}}],[\"例如通过解析\",{\"1\":{\"454\":1}}],[\"例如机房号\",{\"1\":{\"443\":1}}],[\"例如机房号+机器号\",{\"1\":{\"440\":1}}],[\"例如你的业务可能达不到69年之久\",{\"1\":{\"443\":1}}],[\"例如fork\",{\"1\":{\"406\":1}}],[\"例如计算\",{\"1\":{\"395\":1}}],[\"例如身份证\",{\"1\":{\"384\":1}}],[\"例如select\",{\"1\":{\"366\":1}}],[\"例如提交订单\",{\"1\":{\"315\":1}}],[\"例如防止表单重复提交\",{\"1\":{\"315\":1}}],[\"例如\",{\"1\":{\"118\":1,\"153\":1,\"246\":1,\"413\":1,\"454\":1,\"490\":1,\"644\":1,\"751\":1,\"752\":1,\"766\":2,\"769\":1,\"831\":1,\"845\":1,\"887\":1,\"891\":1,\"974\":1,\"976\":1,\"1012\":1,\"1013\":1,\"1018\":1,\"1024\":1,\"1025\":1,\"1026\":1,\"1028\":1,\"1030\":1}}],[\"例如使用strategy模式编写象棋程序时\",{\"1\":{\"114\":1}}],[\"例\",{\"1\":{\"41\":1,\"42\":1,\"93\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"120\":1,\"826\":1}}],[\"它就是读写数据的双向通道\",{\"1\":{\"911\":1}}],[\"它就是一个标准\",{\"1\":{\"617\":1}}],[\"它不会阻塞\",{\"1\":{\"890\":1}}],[\"它不会移动读指针\",{\"1\":{\"853\":1}}],[\"它不需要\",{\"1\":{\"705\":1}}],[\"它即为通道抽象\",{\"1\":{\"835\":1}}],[\"它既可以由提交任务的线程来调用\",{\"1\":{\"792\":1}}],[\"它既是订阅者也是发布者\",{\"1\":{\"742\":1}}],[\"它取值为\",{\"1\":{\"791\":1}}],[\"它用统一的接口对各种handler方法进行调用\",{\"1\":{\"736\":1}}],[\"它用于指导具体构建者如何构建产品\",{\"1\":{\"49\":1}}],[\"它实现\",{\"1\":{\"672\":1}}],[\"它实现了condition接口\",{\"1\":{\"254\":1}}],[\"它实现了读操作无锁\",{\"1\":{\"248\":1}}],[\"它只影响非\",{\"1\":{\"668\":1}}],[\"它主要配置了两个\",{\"1\":{\"661\":1}}],[\"它使用的是标准\",{\"1\":{\"644\":1}}],[\"它内部维护了一个\",{\"1\":{\"829\":1}}],[\"它内部采用了条件装配\",{\"1\":{\"660\":1}}],[\"它内部调用\",{\"1\":{\"539\":1}}],[\"它内置的\",{\"1\":{\"642\":1}}],[\"它能够找到容器中所有切面\",{\"1\":{\"659\":1}}],[\"它能够支持嵌套异常\",{\"1\":{\"612\":1}}],[\"它能够重用参数解析器\",{\"1\":{\"612\":1}}],[\"它能保证客户端始终只使用同一个产品族中的对象\",{\"1\":{\"75\":1}}],[\"它与之前\",{\"1\":{\"531\":1}}],[\"它会返回一个布尔值\",{\"1\":{\"738\":1}}],[\"它会读取配置文件中带\",{\"1\":{\"661\":1}}],[\"它会正常\",{\"1\":{\"523\":2}}],[\"它会通知所有已经注册的observer角色\",{\"1\":{\"81\":1}}],[\"它生成的代理类是目标的子类\",{\"1\":{\"513\":1}}],[\"它才是\",{\"1\":{\"449\":1}}],[\"它扩展了\",{\"1\":{\"446\":1}}],[\"它也会得到一份集群的槽位配置信息并将其缓存在客户端本地\",{\"1\":{\"435\":1}}],[\"它也不是23种设计模式中的\",{\"1\":{\"65\":1}}],[\"它具有复制\",{\"1\":{\"434\":1}}],[\"它具有创建新进程\",{\"1\":{\"133\":1}}],[\"它允许用户程序只要装入少数段的程序和数据即可启动运行\",{\"1\":{\"419\":1}}],[\"它允许用户程序只装入少数页面的程序\",{\"1\":{\"419\":1}}],[\"它同时具有两者的优点\",{\"1\":{\"413\":1}}],[\"它同具体工厂之间一一对应\",{\"1\":{\"68\":1}}],[\"它把用户程序的地址空间分为若干个大小不同的段\",{\"1\":{\"413\":1}}],[\"它由fd\",{\"1\":{\"410\":1}}],[\"它由一个模板方法和若干个基本方法构成\",{\"1\":{\"119\":1}}],[\"它发起一个read操作后\",{\"1\":{\"409\":1}}],[\"它记录的是sql执行相关的信息\",{\"1\":{\"396\":1}}],[\"它最大的优点就是读不加锁\",{\"1\":{\"393\":1}}],[\"它里面的gc按照回收区域又分为两大种类型\",{\"1\":{\"350\":1}}],[\"它里面定义了一系列的模板方法\",{\"1\":{\"255\":1}}],[\"它并不会自己先去加载\",{\"1\":{\"345\":1}}],[\"它占用了\",{\"1\":{\"277\":1}}],[\"它占用空间更少并且效率更高\",{\"1\":{\"272\":1}}],[\"它有两个成员变量\",{\"1\":{\"277\":1}}],[\"它有以下两种使用方法\",{\"1\":{\"252\":1}}],[\"它有以下优点\",{\"1\":{\"112\":1}}],[\"它们都有\",{\"1\":{\"863\":1}}],[\"它们都有两个重要方法\",{\"1\":{\"568\":1}}],[\"它们都实现了\",{\"1\":{\"576\":1}}],[\"它们的根本区别在于是否将程序所需的全部地址空间都装入主存\",{\"1\":{\"419\":1}}],[\"它们的定义分别如下\",{\"1\":{\"277\":1}}],[\"它们数据结构中的\",{\"1\":{\"277\":1}}],[\"它们是一个顶级逻辑的组成步骤\",{\"1\":{\"119\":1}}],[\"它被读取时就是什么样的\",{\"1\":{\"277\":1}}],[\"它为java中大部分锁和同步器提供一个基础框架\",{\"1\":{\"251\":1}}],[\"它为没有实现接口的类提供代理\",{\"1\":{\"95\":1}}],[\"它的key和value的序列化方式默认就是string方式\",{\"1\":{\"1042\":1}}],[\"它的文档怎样聚合和搜索请求\",{\"1\":{\"927\":1}}],[\"它的\",{\"1\":{\"815\":1}}],[\"它的继承关系比较复杂\",{\"1\":{\"796\":1}}],[\"它的内部可能会调用其他的业务方法\",{\"1\":{\"720\":1}}],[\"它的本质就是一个工厂\",{\"1\":{\"706\":1}}],[\"它的作用就是配置外置\",{\"1\":{\"648\":1}}],[\"它的作用是待客户端\",{\"1\":{\"834\":1,\"835\":1}}],[\"它的作用是利用\",{\"1\":{\"803\":1}}],[\"它的作用是用制造创建过程较为复杂的产品\",{\"1\":{\"678\":1}}],[\"它的作用是\",{\"1\":{\"277\":1}}],[\"它的调用时机通常在原始对象初始化后执行\",{\"1\":{\"539\":1}}],[\"它的特点是在使用读锁和写锁时都必须配合\",{\"1\":{\"260\":1}}],[\"它的线程安全是由cas+volatile和synchronized来实现的\",{\"1\":{\"249\":1}}],[\"它的主要目的是通过组装零配件而产生一个新产品\",{\"1\":{\"55\":1}}],[\"它必须立即释放保持的所有资源\",{\"1\":{\"148\":1}}],[\"它提供了\",{\"1\":{\"667\":1}}],[\"它提供了一种创建对象的最佳方式\",{\"1\":{\"99\":1}}],[\"它提高了代码阅读的难度\",{\"1\":{\"121\":1}}],[\"它可能是存款\",{\"1\":{\"118\":1}}],[\"它可以访问\",{\"1\":{\"92\":1}}],[\"它可以是抽象类或接口\",{\"1\":{\"40\":1}}],[\"它维持了类的封装性\",{\"1\":{\"112\":1}}],[\"它限制了复用的灵活性\",{\"1\":{\"112\":1}}],[\"它声明了update方法\",{\"1\":{\"81\":1}}],[\"它还声明了\",{\"1\":{\"81\":1}}],[\"它\",{\"1\":{\"73\":1}}],[\"它包含控制器的功能\",{\"1\":{\"738\":1}}],[\"它包含多个创建产品的方法\",{\"1\":{\"73\":1}}],[\"它包含了车架\",{\"1\":{\"49\":1}}],[\"它是model和view这两层的桥梁\",{\"1\":{\"734\":1}}],[\"它是\",{\"1\":{\"449\":1,\"751\":1}}],[\"它是由连续内存块组成的顺序型数据结构\",{\"1\":{\"279\":1}}],[\"它是指为完成某种任务而建立的两个或多个进程\",{\"1\":{\"140\":1}}],[\"它是可被复制的对象\",{\"1\":{\"85\":1}}],[\"它是一个转换器\",{\"1\":{\"40\":1}}],[\"它是被访问和适配的现存组件库中的组件接口\",{\"1\":{\"40\":1}}],[\"类也有该方法\",{\"1\":{\"851\":1}}],[\"类如其名\",{\"1\":{\"830\":1}}],[\"类路径下必须有\",{\"1\":{\"672\":1}}],[\"类无法被\",{\"1\":{\"513\":1}}],[\"类文件时\",{\"1\":{\"504\":1}}],[\"类中编写方法使用接口作为参数\",{\"1\":{\"336\":1}}],[\"类中的\",{\"1\":{\"104\":1}}],[\"类型发生了不同的变化\",{\"1\":{\"923\":1}}],[\"类型和长度已知的情况下\",{\"1\":{\"890\":1}}],[\"类型转换与数据绑定\",{\"0\":{\"577\":1}}],[\"类型转换\",{\"1\":{\"395\":1,\"590\":1}}],[\"类型必须一致\",{\"1\":{\"383\":1}}],[\"类型指针\",{\"1\":{\"353\":1}}],[\"类型分配内存时\",{\"1\":{\"277\":1}}],[\"类型分别是\",{\"1\":{\"277\":1}}],[\"类型只占一个字节\",{\"1\":{\"277\":1}}],[\"类型的唯一\",{\"1\":{\"440\":1}}],[\"类型的\",{\"1\":{\"277\":2}}],[\"类型\",{\"0\":{\"923\":1},\"1\":{\"265\":1,\"277\":2,\"383\":2,\"473\":1,\"527\":1,\"561\":2,\"695\":1,\"703\":1,\"710\":1,\"890\":1}}],[\"类型为unsigned\",{\"1\":{\"265\":1}}],[\"类用final修饰保证了类不能被继承\",{\"1\":{\"236\":1}}],[\"类以及代码块\",{\"1\":{\"228\":1}}],[\"类似的内存分配算法提升分配效率\",{\"1\":{\"820\":1}}],[\"类似的\",{\"1\":{\"816\":1}}],[\"类似的还有\",{\"1\":{\"545\":1}}],[\"类似\",{\"1\":{\"527\":1,\"661\":1}}],[\"类似于java中的hashmap结构\",{\"1\":{\"1027\":1}}],[\"类似于java中的hashset\",{\"1\":{\"422\":1}}],[\"类似于jdk1\",{\"1\":{\"422\":1}}],[\"类似于jdk动态代理的proxy类\",{\"1\":{\"95\":1}}],[\"类似于\",{\"1\":{\"232\":4}}],[\"类似内存分页\",{\"1\":{\"169\":1}}],[\"类似类\",{\"1\":{\"145\":1}}],[\"类的唯一性\",{\"1\":{\"101\":1}}],[\"类加载阶段\",{\"1\":{\"714\":1}}],[\"类加载时可以通过\",{\"1\":{\"508\":1}}],[\"类加载\",{\"0\":{\"507\":1}}],[\"类加载不会导致该单实例对象被创建\",{\"1\":{\"101\":1}}],[\"类加载就会导致该单实例对象被创建\",{\"1\":{\"101\":1}}],[\"类加载器\",{\"1\":{\"94\":1}}],[\"类和接口一览表\",{\"1\":{\"82\":1}}],[\"类结构图如下\",{\"1\":{\"44\":1}}],[\"类适配器是客户类有一个接口规范的情况下可用\",{\"1\":{\"41\":1}}],[\"类适配器模式的代码\",{\"1\":{\"42\":1}}],[\"类适配器模式违背了合成复用原则\",{\"1\":{\"41\":1}}],[\"类适配器模式\",{\"0\":{\"41\":1}}],[\"类图如下\",{\"1\":{\"41\":1,\"42\":1,\"48\":1,\"49\":1,\"63\":1,\"69\":1,\"74\":1,\"87\":1,\"93\":1,\"109\":2,\"110\":1,\"111\":1,\"112\":1,\"120\":1}}],[\"类\",{\"1\":{\"40\":2,\"49\":2,\"92\":3,\"110\":2,\"527\":1,\"871\":1}}],[\"且实现起来麻烦\",{\"1\":{\"987\":1}}],[\"且实现简单\",{\"1\":{\"987\":1}}],[\"且只能串行执行性能肯定受到影响\",{\"1\":{\"987\":1}}],[\"且只是偶尔写的并发场景\",{\"1\":{\"248\":1}}],[\"且在未来版本中会被删除\",{\"1\":{\"932\":1}}],[\"且开启的事务互相独立\",{\"1\":{\"720\":1}}],[\"且\",{\"1\":{\"531\":1}}],[\"且需要学习新的\",{\"1\":{\"504\":1}}],[\"且集群配置非常简单\",{\"1\":{\"434\":1}}],[\"且单个主节点内存也不宜设的过大\",{\"1\":{\"433\":1}}],[\"且处于性能考虑\",{\"1\":{\"396\":1}}],[\"且使用的系统和事务日志资源少\",{\"1\":{\"267\":1}}],[\"且扩大了表示范围\",{\"1\":{\"265\":1}}],[\"且当一个线程独占时\",{\"1\":{\"252\":1}}],[\"且是静默丢弃\",{\"1\":{\"243\":1}}],[\"且这些块读入内存后在\",{\"1\":{\"181\":1}}],[\"且这些寄存器都要有相应的地址\",{\"1\":{\"180\":1}}],[\"且为线性相关\",{\"1\":{\"176\":1}}],[\"且顶级索引表未调入内存\",{\"1\":{\"169\":1}}],[\"且修改过的页面\",{\"1\":{\"163\":1}}],[\"且被修改过\",{\"1\":{\"163\":1}}],[\"且所有产品的接口相同\",{\"1\":{\"76\":1}}],[\"且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构\",{\"1\":{\"72\":1}}],[\"且要求程序员了解现有组件库中的相关组件的内部结构\",{\"1\":{\"39\":1}}],[\"且与ground\",{\"1\":{\"25\":1}}],[\"使它们并发执行\",{\"1\":{\"418\":1}}],[\"使程序继续执行下去\",{\"1\":{\"418\":1}}],[\"使每个页面的大小与内存物理块的大小相同\",{\"1\":{\"413\":1}}],[\"使其元素不超过给定数量\",{\"1\":{\"338\":1}}],[\"使一个线程从某通道发送请求读取数据\",{\"1\":{\"332\":1}}],[\"使之更易用\",{\"1\":{\"842\":1}}],[\"使之能够在手机等终端上使用\",{\"1\":{\"300\":1}}],[\"使之成为新对象的一部分\",{\"1\":{\"112\":1}}],[\"使字段与do类解耦\",{\"1\":{\"268\":1}}],[\"使磁头定位到目标扇区所需要的时间\",{\"1\":{\"176\":1}}],[\"使多个用户可以共享使用一个文件\",{\"1\":{\"166\":1}}],[\"使操作系统获得计算机的控制权\",{\"1\":{\"129\":1}}],[\"使上面定义的单例类\",{\"1\":{\"103\":1}}],[\"使得集合中的元素可以根据score进行有序排列\",{\"1\":{\"422\":1}}],[\"使得\",{\"1\":{\"277\":1}}],[\"使得每个进程都可以在一个时间片内完成\",{\"1\":{\"139\":1}}],[\"使得一个进程内可以并发处理各种任务\",{\"1\":{\"135\":1}}],[\"使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤\",{\"1\":{\"118\":1}}],[\"使得系统中类的个数成倍增加\",{\"1\":{\"58\":1}}],[\"使得创建过程更加清晰\",{\"1\":{\"50\":1}}],[\"使得相同的创建过程可以创建不同的产品对象\",{\"1\":{\"50\":1}}],[\"使得同样的构建过程可以创建不同的表示\",{\"1\":{\"47\":1}}],[\"使得原本由于接口不兼容而不能一起工作的那些类能一起工作\",{\"1\":{\"39\":1}}],[\"使用非常简单\",{\"1\":{\"1037\":1}}],[\"使用方式如下\",{\"1\":{\"1018\":1}}],[\"使用规则等\",{\"1\":{\"994\":1}}],[\"使用锁来解决\",{\"1\":{\"987\":1}}],[\"使用完成后再进行回收\",{\"1\":{\"961\":1}}],[\"使用如下方式写入\",{\"1\":{\"858\":1}}],[\"使用如下方式读取\",{\"1\":{\"857\":1}}],[\"使用上一个处理器的处理结果\",{\"1\":{\"834\":1}}],[\"使用上较为古怪\",{\"1\":{\"678\":1}}],[\"使用更流畅\",{\"1\":{\"831\":1}}],[\"使用更方便的机器\",{\"1\":{\"126\":1}}],[\"使用同一块底层内存\",{\"1\":{\"827\":1}}],[\"使用它调整超时时间\",{\"1\":{\"775\":1}}],[\"使用它可以提供非阻塞的高伸缩性网络\",{\"1\":{\"332\":1}}],[\"使用该注解表示开启了全局异常的捕获\",{\"1\":{\"732\":1}}],[\"使用bean\",{\"1\":{\"711\":1}}],[\"使用不同的bean\",{\"1\":{\"710\":1}}],[\"使用的线程都是守护线程\",{\"1\":{\"908\":1}}],[\"使用的还是\",{\"1\":{\"905\":1}}],[\"使用的就是直接内存了\",{\"1\":{\"825\":1}}],[\"使用的是操作系统内存\",{\"1\":{\"905\":1}}],[\"使用的是\",{\"1\":{\"825\":1}}],[\"使用的\",{\"1\":{\"648\":1}}],[\"使用默认转换器\",{\"1\":{\"582\":1}}],[\"使用掩码\",{\"1\":{\"441\":1}}],[\"使用虚拟地址访问内存有以下优势\",{\"1\":{\"415\":1}}],[\"使用epoll没有前面两者的线性下降的性能问题\",{\"1\":{\"410\":1}}],[\"使用能减少回表的次数\",{\"1\":{\"395\":1}}],[\"使用联合索引时\",{\"1\":{\"395\":1}}],[\"使用where约束来自数据库的数据\",{\"1\":{\"394\":1}}],[\"使用最频繁的字段放到联合索引左侧\",{\"1\":{\"383\":1}}],[\"使用列数据类型小的字段创建索引\",{\"1\":{\"383\":1}}],[\"使用hash索引还需要对数据重新排序\",{\"1\":{\"381\":1}}],[\"使用hashmap统计每个小文件单词出现的频次\",{\"1\":{\"290\":1}}],[\"使用lambdaquerywrapper的情况\",{\"1\":{\"371\":1}}],[\"使用lambdaquerywrapper和lambdaupdatewrapper替代querywrapper和updatewrapper\",{\"1\":{\"371\":1}}],[\"使用querywrapper的情况\",{\"1\":{\"371\":1}}],[\"使用这种方式\",{\"1\":{\"356\":1}}],[\"使用当前类加载器以classloader+包名+类名为key进行查找对应的\",{\"1\":{\"352\":1}}],[\"使用反序列化\",{\"1\":{\"351\":1}}],[\"使用propagation属性声明事物的传播行为\",{\"1\":{\"721\":1}}],[\"使用proxy获取代理对象\",{\"1\":{\"94\":1}}],[\"使用pc寄存器存储字节码指令地址有什么用呢\",{\"0\":{\"347\":1}}],[\"使用一个大小为500大小的堆\",{\"1\":{\"291\":1}}],[\"使用一个atomicinteger来表示状态和数量\",{\"1\":{\"241\":1}}],[\"使用10mb内存分别对\",{\"1\":{\"291\":1}}],[\"使用多路归并排序对大文件进行排序\",{\"1\":{\"291\":1}}],[\"使用小顶堆\",{\"1\":{\"290\":1}}],[\"使用布隆过滤器中的哈希函数对元素值进行计算\",{\"1\":{\"273\":1}}],[\"使用isnull\",{\"1\":{\"267\":1}}],[\"使用intel处理器\",{\"1\":{\"109\":1}}],[\"使用clone\",{\"1\":{\"351\":1}}],[\"使用char定长字符串类型\",{\"1\":{\"265\":1}}],[\"使用cglib实现动态代理\",{\"1\":{\"96\":1}}],[\"使用stringredistemplate\",{\"1\":{\"1042\":1}}],[\"使用strategy模式可以整体地替换算法的实现部分\",{\"1\":{\"114\":1}}],[\"使用spring\",{\"1\":{\"726\":2,\"730\":1}}],[\"使用select\",{\"1\":{\"409\":1}}],[\"使用semaphore限流\",{\"1\":{\"261\":1}}],[\"使用线程池可以进行统一的分配\",{\"1\":{\"240\":1}}],[\"使用字符串前缀创建索引\",{\"1\":{\"383\":1}}],[\"使用字符串时\",{\"1\":{\"236\":1}}],[\"使用字节码技术生成代理类\",{\"1\":{\"96\":1}}],[\"使用支持原子类型操作的类\",{\"1\":{\"230\":1}}],[\"使用可释放的定时锁\",{\"1\":{\"221\":1}}],[\"使用单\",{\"1\":{\"186\":1}}],[\"使用单例类\",{\"1\":{\"100\":1}}],[\"使用户看到的内存容量\",{\"1\":{\"161\":1}}],[\"使用开关中断实现\",{\"1\":{\"143\":1}}],[\"使用委托这种弱关联关系可以很方便地整体替换算法\",{\"1\":{\"114\":1}}],[\"使用金士顿作为内存条\",{\"1\":{\"109\":1}}],[\"使用希捷希捷硬盘取数据\",{\"1\":{\"109\":1}}],[\"使用希捷硬盘存储数据\",{\"1\":{\"109\":1}}],[\"使用组合关系\",{\"1\":{\"108\":1}}],[\"使用runtime类中的方法\",{\"1\":{\"105\":1}}],[\"使用真实对象的类加载器即可\",{\"1\":{\"94\":1}}],[\"使用具体原型类中的\",{\"1\":{\"85\":1}}],[\"使用迭代器遍历集合\",{\"1\":{\"78\":1}}],[\"使用迭代器遍历\",{\"1\":{\"78\":1}}],[\"使用工厂方法模式对上例进行改进\",{\"1\":{\"69\":1}}],[\"使用工厂方法模式就可以完美的解决\",{\"1\":{\"66\":1}}],[\"使用\",{\"1\":{\"58\":1,\"241\":1,\"277\":1,\"383\":1,\"450\":1,\"531\":3,\"644\":2,\"731\":1,\"803\":1,\"841\":1,\"846\":1,\"868\":1,\"871\":1,\"876\":1,\"877\":1,\"897\":1,\"904\":1,\"905\":3}}],[\"使用场景\",{\"0\":{\"51\":1,\"76\":1,\"88\":1,\"98\":1},\"1\":{\"244\":1}}],[\"使用建造者模式可以有效的封装变化\",{\"1\":{\"50\":1}}],[\"使用第三方提供的组件\",{\"1\":{\"43\":1}}],[\"使用了多尺度特征\",{\"1\":{\"24\":1}}],[\"使用条件式生成对抗网络\",{\"1\":{\"16\":1}}],[\"读事件由\",{\"1\":{\"909\":1}}],[\"读指针向后走\",{\"1\":{\"853\":1}}],[\"读模式\",{\"1\":{\"846\":1}}],[\"读到字节数\",{\"1\":{\"846\":4}}],[\"读不会阻塞写\",{\"1\":{\"845\":1}}],[\"读和写是可以同时进行的\",{\"1\":{\"845\":1}}],[\"读和写的误解💡\",{\"0\":{\"845\":1}}],[\"读和写等\",{\"1\":{\"183\":1}}],[\"读\",{\"1\":{\"837\":1,\"859\":1,\"890\":1}}],[\"读写\",{\"1\":{\"905\":1}}],[\"读写能力\",{\"1\":{\"904\":1}}],[\"读写效率高\",{\"1\":{\"851\":1}}],[\"读写效率较低\",{\"1\":{\"851\":1}}],[\"读写才不会相互阻塞\",{\"1\":{\"845\":1}}],[\"读写指针分离\",{\"1\":{\"831\":1}}],[\"读写锁之间\",{\"1\":{\"400\":1}}],[\"读过的内容\",{\"1\":{\"824\":1}}],[\"读空闲时间过长\",{\"1\":{\"764\":2}}],[\"读锁之间不互斥\",{\"1\":{\"400\":1}}],[\"读锁不能升级为写锁\",{\"1\":{\"259\":1}}],[\"读屏障会确保指令重排序时\",{\"1\":{\"227\":1}}],[\"读屏障保证在该屏障之后\",{\"1\":{\"227\":1}}],[\"读操作\",{\"1\":{\"181\":3}}],[\"读操作是线程安全的\",{\"1\":{\"101\":1}}],[\"读文件\",{\"1\":{\"171\":1}}],[\"读取redis时\",{\"1\":{\"1042\":1}}],[\"读取数据填充\",{\"1\":{\"864\":1}}],[\"读取数据\",{\"0\":{\"853\":1},\"1\":{\"847\":1}}],[\"读取数据时\",{\"1\":{\"434\":1}}],[\"读取完成\",{\"1\":{\"837\":1}}],[\"读取完毕后需要做一次戳校验\",{\"1\":{\"260\":1}}],[\"读取\",{\"0\":{\"824\":1,\"864\":1},\"1\":{\"794\":1,\"848\":1}}],[\"读取的最小单位\",{\"1\":{\"750\":1}}],[\"读取比较简单的配置信息\",{\"1\":{\"731\":1}}],[\"读取自动配置类名\",{\"1\":{\"670\":1}}],[\"读取1号盘面的0扇区时无法立即开始读\",{\"1\":{\"177\":1}}],[\"读取len个字节数据\",{\"1\":{\"123\":1}}],[\"读取对象\",{\"1\":{\"89\":1}}],[\"读取tf卡方法\",{\"1\":{\"41\":1}}],[\"读取sd卡方法\",{\"1\":{\"41\":1}}],[\"读卡器\",{\"1\":{\"41\":1,\"42\":1}}],[\"读卡器等\",{\"1\":{\"39\":1}}],[\"读前须知\",{\"0\":{\"34\":1}}],[\"将李四从张三的好友列表中移除\",{\"1\":{\"1029\":1}}],[\"将下列数据用redis的set集合来存储\",{\"1\":{\"1029\":1}}],[\"将操作不同数据类型的命令也做了分组\",{\"1\":{\"1023\":1}}],[\"将逻辑进行封装\",{\"1\":{\"990\":1}}],[\"将逻辑地址变换为物理地址\",{\"1\":{\"151\":1}}],[\"将任意java对象序列化为json并存储在string类型的key中\",{\"1\":{\"990\":4}}],[\"将value取出\",{\"1\":{\"989\":1}}],[\"将空值写入redis\",{\"1\":{\"985\":1,\"988\":1,\"990\":2}}],[\"将缓存与数据库操作放在一个事务\",{\"1\":{\"982\":1}}],[\"将缓存中的数据加载出来\",{\"1\":{\"982\":1}}],[\"将查询到的hash数据转为userdto\",{\"1\":{\"972\":1}}],[\"将user对象转为hashmap存储\",{\"1\":{\"968\":1}}],[\"将user对象换成userdto\",{\"1\":{\"962\":1}}],[\"将分片分配给某个节点的过程\",{\"1\":{\"929\":1}}],[\"将虚引用加入引用队列\",{\"1\":{\"905\":1}}],[\"将堆外内存映射到\",{\"1\":{\"905\":1}}],[\"将错乱的数据恢复成原始的按\",{\"1\":{\"859\":1}}],[\"将原始\",{\"1\":{\"825\":1}}],[\"将原有的对象重新分配\",{\"1\":{\"328\":1}}],[\"将要执行的代码作为任务提交给下一个事件循环处理\",{\"1\":{\"799\":1}}],[\"将线程池的当前线程保存在成员变量中\",{\"1\":{\"791\":1}}],[\"将消息对象发送出去\",{\"1\":{\"787\":1}}],[\"将方法调用转换为\",{\"1\":{\"787\":1}}],[\"将发送一个拒绝连接的错误信息到\",{\"1\":{\"776\":1}}],[\"将该请求从\",{\"1\":{\"776\":1}}],[\"将该词出现的次数加1\",{\"1\":{\"290\":1}}],[\"将返回一个modelandview给dispatcherservlet\",{\"1\":{\"736\":1}}],[\"将返回值作为模型\",{\"1\":{\"600\":2}}],[\"将返回值赋值给rep变量\",{\"1\":{\"104\":1}}],[\"将handler看作目标主机\",{\"1\":{\"736\":1}}],[\"将根据请求的信息\",{\"1\":{\"736\":1}}],[\"将软件分层的好处是\",{\"1\":{\"734\":1}}],[\"将当前方法的返回值存入ioc容器\",{\"1\":{\"713\":1}}],[\"将当前数据的时间戳和更新之前取得的时间戳进行比较\",{\"1\":{\"397\":1}}],[\"将需要的可变成员变量保存在threadlocal中\",{\"1\":{\"712\":1}}],[\"将需排序的元素与已排序序列进行比较\",{\"1\":{\"190\":1}}],[\"将那些与业务无关却为业务模块共同调用的逻辑或责任\",{\"1\":{\"706\":1}}],[\"将来此类被导入时就会做条件检查\",{\"1\":{\"672\":1}}],[\"将来\",{\"1\":{\"647\":1,\"842\":1}}],[\"将结果返回给环绕通知2\",{\"1\":{\"546\":1}}],[\"将结果为i的词存放到文件f\",{\"1\":{\"290\":1}}],[\"将高级\",{\"1\":{\"539\":1}}],[\"将通知统一转为环绕通知\",{\"1\":{\"528\":1}}],[\"将通知notempty条件\",{\"1\":{\"254\":1}}],[\"将不同部分的数值移动到指定的位置\",{\"1\":{\"441\":1}}],[\"将数据库结果写入缓存\",{\"1\":{\"983\":1}}],[\"将数据读入\",{\"1\":{\"911\":1}}],[\"将数据读入内核缓冲区\",{\"1\":{\"904\":1}}],[\"将数据传递给下个\",{\"1\":{\"816\":1}}],[\"将数据分片\",{\"1\":{\"434\":1}}],[\"将数据从内核缓冲区读入用户缓冲区\",{\"1\":{\"904\":1}}],[\"将数据从内核拷贝到进程中\",{\"1\":{\"409\":1}}],[\"将数据从kernel拷贝到用户进程\",{\"1\":{\"409\":1}}],[\"将某一台slave作为master\",{\"1\":{\"433\":1}}],[\"将有用户敏感信息的user对象转化成没有敏感信息的userdto对象\",{\"1\":{\"962\":1}}],[\"将有序链表改造为支持类似\",{\"1\":{\"425\":1}}],[\"将有来的引用指向新副本\",{\"1\":{\"248\":1}}],[\"将内存中暂时不用的页\",{\"1\":{\"418\":1}}],[\"将内存分为几个固定大校的块\",{\"1\":{\"413\":1}}],[\"将页表进行分页\",{\"1\":{\"413\":1}}],[\"将页表继续根据页框大小进行拆分\",{\"1\":{\"158\":1}}],[\"将用户的敏感信息进行隐藏\",{\"1\":{\"962\":1}}],[\"将用户程序的地址空间分为若干个固定大小的区域\",{\"1\":{\"413\":1}}],[\"将用户关系的文件描述符的时间存放到内核的一个事件表中\",{\"1\":{\"410\":1}}],[\"将用户空间划分为若干个固定大小的分区\",{\"1\":{\"154\":1}}],[\"将最高的1g字节供内核使用\",{\"1\":{\"406\":1}}],[\"将buffer\",{\"1\":{\"396\":2}}],[\"将json格式数据封装成具体的vo或者po实体类\",{\"1\":{\"365\":1}}],[\"将流转换为其他形式\",{\"1\":{\"343\":1}}],[\"将流中的每个值都换成另一个流\",{\"1\":{\"339\":1}}],[\"将元素转换成其他形式或提取信息\",{\"1\":{\"339\":1}}],[\"将满足条件的字符串添加到集合中去\",{\"1\":{\"336\":1}}],[\"将链表转化为红黑树\",{\"1\":{\"327\":1}}],[\"将链表转换成红黑树之前会判断\",{\"1\":{\"327\":1}}],[\"将包装类型转换为基本数据类型\",{\"1\":{\"321\":1}}],[\"将基本类型用他们的引用类型包装起来\",{\"1\":{\"321\":1}}],[\"将会从以下几个方面介绍\",{\"1\":{\"315\":1}}],[\"将理论应用于实践\",{\"1\":{\"311\":1}}],[\"将参数更新至数据库\",{\"1\":{\"296\":1}}],[\"将文件按照顺序切分成大小不超过2m的小文件\",{\"1\":{\"291\":1}}],[\"将\",{\"1\":{\"276\":1,\"549\":2,\"644\":1,\"891\":1,\"904\":1,\"905\":2}}],[\"将之前的arraylist拷贝一份\",{\"1\":{\"248\":1}}],[\"将修改后的值存入静态变量i\",{\"1\":{\"230\":1}}],[\"将待排序元素插入到后移序列的前方\",{\"1\":{\"190\":1}}],[\"将此位置起的所有已排序序列后移一位\",{\"1\":{\"190\":1}}],[\"将其注入到类中使用\",{\"1\":{\"731\":1}}],[\"将其他通知统一转换为\",{\"1\":{\"549\":1,\"556\":1}}],[\"将其队列中的元素移动到aqs队列中等待被唤醒\",{\"1\":{\"254\":1}}],[\"将其移动到aqs的队列中\",{\"1\":{\"254\":1}}],[\"将其前方的序列视为已排序序列\",{\"1\":{\"190\":1}}],[\"将其与最后一个元素进行交换\",{\"1\":{\"189\":1}}],[\"将上层发出的一系列命令\",{\"1\":{\"182\":1}}],[\"将上面的\",{\"1\":{\"89\":1}}],[\"将磁头移动到指定磁盘所花的时间\",{\"1\":{\"176\":1}}],[\"将所有可能被置换的页面排成一个循环队列\",{\"1\":{\"163\":1}}],[\"将所缺页面装入该块\",{\"1\":{\"162\":1}}],[\"将调入内存的页面根据调入的先后顺序排成一个队列\",{\"1\":{\"163\":1}}],[\"将作业换入\",{\"1\":{\"161\":1}}],[\"将近期会频繁访问到的数据放到更高速的存储器中\",{\"1\":{\"161\":1}}],[\"将进程中的若干个页分别装入到多个可以不相邻接的物理块中\",{\"1\":{\"413\":1}}],[\"将进程按逻辑模块分段\",{\"1\":{\"160\":1}}],[\"将进程重新方法就绪队列队尾重新排队\",{\"1\":{\"139\":1}}],[\"将各个目标模块装入内存时\",{\"1\":{\"151\":1}}],[\"将各个目标模块连接到装入模块\",{\"1\":{\"151\":1}}],[\"将装入模块装入到内存的适当位置\",{\"1\":{\"151\":1}}],[\"将程序分为多个段\",{\"1\":{\"153\":1}}],[\"将程序和数据装入内存\",{\"1\":{\"151\":1}}],[\"将程序状态字\",{\"1\":{\"129\":1}}],[\"将这些资源分配给其他死锁进程\",{\"1\":{\"150\":1}}],[\"将想要的资源强行剥夺\",{\"1\":{\"148\":1}}],[\"将被强行剥夺处理机使用权\",{\"1\":{\"139\":1}}],[\"将cpu分给紧急的那个进程\",{\"1\":{\"137\":1}}],[\"将c1对象写出到文件中\",{\"1\":{\"89\":1}}],[\"将处理机分配给它\",{\"1\":{\"136\":1}}],[\"将n各用户及线程映射到m各内核级线程上\",{\"1\":{\"135\":1}}],[\"将pcb插入合适的队列\",{\"1\":{\"133\":1}}],[\"将运行环境保存到pcb\",{\"1\":{\"133\":1}}],[\"将裸机改造为功能更强\",{\"1\":{\"126\":1}}],[\"将容易变的部分抽象出来\",{\"1\":{\"122\":1}}],[\"将相同部分的代码放在抽象的父类中\",{\"1\":{\"121\":1}}],[\"将相同尺度的特征沿通道方向摞起来\",{\"1\":{\"23\":1}}],[\"将instance对象写出到文件中\",{\"1\":{\"103\":1}}],[\"将我们提供了的匿名内部类对象传递给了父类\",{\"1\":{\"94\":1}}],[\"将奖状的名字修改李四\",{\"1\":{\"87\":1}}],[\"将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族\",{\"1\":{\"71\":1}}],[\"将复杂产品的创建步骤分解在不同的方法中\",{\"1\":{\"50\":1}}],[\"将产品本身与产品的创建过程解耦\",{\"1\":{\"50\":1}}],[\"将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性\",{\"1\":{\"50\":1}}],[\"将一个文件通过\",{\"1\":{\"904\":1}}],[\"将一个\",{\"1\":{\"890\":1}}],[\"将一个字符串转换成大写并作为方法的返回值\",{\"1\":{\"336\":1}}],[\"将一个复杂对象的构建与表示分离\",{\"1\":{\"47\":1}}],[\"将一个类的接口转换成客户希望的另外一个接口\",{\"1\":{\"39\":1}}],[\"将tf卡中的内容读取出来\",{\"1\":{\"41\":1}}],[\"将220v转换为5v的电压\",{\"1\":{\"39\":1}}],[\"这需要用到redis客户端\",{\"1\":{\"1017\":1}}],[\"这需要进一步测试\",{\"1\":{\"410\":1}}],[\"这套机制的核心逻辑在于\",{\"1\":{\"996\":1}}],[\"这明显不合适\",{\"1\":{\"992\":1}}],[\"这么大数据量\",{\"1\":{\"975\":1}}],[\"这在实际开发中对企业讲\",{\"1\":{\"974\":1}}],[\"这块内存不受\",{\"1\":{\"905\":1}}],[\"这项能力\",{\"1\":{\"904\":1}}],[\"这期间\",{\"1\":{\"904\":1}}],[\"这期间用户线程阻塞\",{\"1\":{\"904\":1}}],[\"这边的\",{\"1\":{\"898\":1}}],[\"这边说的请求分页存储管理和操作系统内存管理中的分页存储管理有何不同\",{\"1\":{\"419\":1}}],[\"这称之为多路复用\",{\"1\":{\"878\":1}}],[\"这行代码完成的事实是\",{\"1\":{\"790\":1,\"793\":1}}],[\"这白纸黑字明摆着的\",{\"1\":{\"766\":1}}],[\"这句话有数种拆解方式\",{\"1\":{\"766\":1}}],[\"这便是spring\",{\"1\":{\"730\":1}}],[\"这儿\",{\"1\":{\"661\":1}}],[\"这体现的是适配器设计模式\",{\"1\":{\"549\":1}}],[\"这不仅会使相当一部分内存空间都处于暂时或\",{\"1\":{\"419\":1}}],[\"这不利于类的扩展与维护\",{\"1\":{\"112\":1}}],[\"这部分数据是锁定的\",{\"1\":{\"396\":1}}],[\"这点有待商榷\",{\"1\":{\"393\":1}}],[\"这会带来额外的内存开销\",{\"1\":{\"1041\":1}}],[\"这会进行aop\",{\"1\":{\"711\":1}}],[\"这会大大消耗资源和时间\",{\"1\":{\"388\":1}}],[\"这会导致类的个数增加\",{\"1\":{\"121\":1}}],[\"这使得范围查找可以通过指针连接查找\",{\"1\":{\"378\":1}}],[\"这三项里\",{\"1\":{\"359\":1}}],[\"这一\",{\"1\":{\"496\":1}}],[\"这一操作保证了对象的实例字段在java代码中不赋值就可以使用\",{\"1\":{\"352\":1}}],[\"这一策略的类\",{\"1\":{\"116\":2}}],[\"这成为rehashing\",{\"1\":{\"328\":1}}],[\"这件事情的具体情况如何\",{\"1\":{\"309\":1}}],[\"这件事情为什么会让你如此紧张\",{\"1\":{\"308\":1}}],[\"这只是生存\",{\"1\":{\"305\":1}}],[\"这只是静态图片阶段\",{\"1\":{\"300\":1}}],[\"这其中有异常\",{\"1\":{\"650\":1}}],[\"这其中其实涉及到了生存和发展的问题\",{\"1\":{\"305\":1}}],[\"这其实是redis\",{\"1\":{\"436\":1}}],[\"这其实也是急功近利的表现\",{\"1\":{\"302\":1}}],[\"这两种数据结构的设计目标\",{\"1\":{\"281\":1}}],[\"这两个主要是提供了redis命令对应的api\",{\"1\":{\"1031\":1}}],[\"这两个线程由于使用的是同一份代码\",{\"1\":{\"999\":1}}],[\"这两个注解\",{\"1\":{\"672\":1}}],[\"这两个元素里保存的信息\",{\"1\":{\"279\":1}}],[\"这两个类型\",{\"1\":{\"277\":1}}],[\"这意味着\",{\"1\":{\"277\":1,\"928\":1}}],[\"这\",{\"1\":{\"277\":1,\"751\":1}}],[\"这几个方法为什么不直接定义成抽象方法呢\",{\"1\":{\"255\":1}}],[\"这唯一的线程也不会被释放\",{\"1\":{\"244\":1}}],[\"这也可以说是redis为什么快的一个原因\",{\"1\":{\"277\":1}}],[\"这也是典型适配器模式体现\",{\"1\":{\"643\":1}}],[\"这也是\",{\"1\":{\"572\":1}}],[\"这也是创建索引的主要原因\",{\"1\":{\"375\":1}}],[\"这也是万物互联的初步实现把\",{\"1\":{\"305\":1}}],[\"这也是一个可以改进的地方\",{\"1\":{\"276\":1}}],[\"这也是经典的内存不可见问题\",{\"1\":{\"230\":1}}],[\"这也就印证了我们之前说的真实类和代理类实现同样的接口\",{\"1\":{\"94\":1}}],[\"这次你get了么\",{\"1\":{\"197\":1}}],[\"这要求系统记录进程的历史信息\",{\"1\":{\"150\":1}}],[\"这是为了解决\",{\"1\":{\"792\":1}}],[\"这是为了满足用户要求而形成的一种存储管理方式\",{\"1\":{\"413\":1}}],[\"这是一种习惯\",{\"1\":{\"706\":1}}],[\"这是一个可以改进的地方\",{\"1\":{\"276\":2}}],[\"这是分页和分段两种存储管理方式相结合的产物\",{\"1\":{\"413\":1}}],[\"这是因为\",{\"1\":{\"668\":1,\"885\":1}}],[\"这是因为这些版本的\",{\"1\":{\"449\":1}}],[\"这是因为指令通常是顺序存放\",{\"1\":{\"417\":1}}],[\"这是因为每张myisam的数据表都有一个meta信息存储了row\",{\"1\":{\"387\":1}}],[\"这是因为索引会对数据按照某种顺序进行排序\",{\"1\":{\"383\":1}}],[\"这是因为非索引字段更新不需要对索引进行维护\",{\"1\":{\"383\":1}}],[\"这是因为默认情况下\",{\"1\":{\"277\":1}}],[\"这是个很敏感的话题\",{\"1\":{\"305\":1}}],[\"这是我第一次系统进行合作开发也是第一个java项目\",{\"1\":{\"297\":1}}],[\"这是按照实际占用字节数进行分配内存的\",{\"1\":{\"277\":1}}],[\"这是不对的\",{\"1\":{\"268\":1}}],[\"这是默认策略\",{\"1\":{\"243\":1}}],[\"这是效率提升的因素之一\",{\"1\":{\"231\":1}}],[\"这是银行家算法核心思想\",{\"1\":{\"149\":1}}],[\"这是和装饰器模式的最大不同\",{\"1\":{\"45\":1}}],[\"这就造成了半包\",{\"1\":{\"751\":1}}],[\"这就增加了处理过程中的灵活性\",{\"1\":{\"332\":1}}],[\"这就会直接影响到压缩列表的访问性能\",{\"1\":{\"281\":1}}],[\"这就导致了内存中会驻留大量的\",{\"1\":{\"161\":1}}],[\"这就意味着之后可能所有进程都无法顺利执行下去\",{\"1\":{\"149\":1}}],[\"这就是\",{\"1\":{\"751\":1,\"999\":1}}],[\"这就是索引下推\",{\"1\":{\"385\":1}}],[\"这就是沙箱安全机制\",{\"1\":{\"346\":1}}],[\"这就是双亲委派机制\",{\"1\":{\"345\":1}}],[\"这就是两个函数\",{\"1\":{\"143\":1}}],[\"这就是浅克隆的效果\",{\"1\":{\"89\":1}}],[\"这违背了空闲让进的原则\",{\"1\":{\"141\":1}}],[\"这导致一种反向的控制结构\",{\"1\":{\"121\":1}}],[\"这类方法名一般为isxxx\",{\"1\":{\"119\":1}}],[\"这里采用了json序列化来代替默认的jdk序列化方式\",{\"1\":{\"1041\":1}}],[\"这里采用了引用计数法来控制回收内存\",{\"1\":{\"825\":1}}],[\"这里是直接查询数据库\",{\"1\":{\"977\":1}}],[\"这里是将\",{\"1\":{\"835\":1}}],[\"这里具体逻辑就不分析了\",{\"1\":{\"968\":1}}],[\"这里这么写\",{\"1\":{\"889\":2}}],[\"这里仅介绍其跟\",{\"1\":{\"830\":1}}],[\"这里要知道\",{\"1\":{\"792\":1}}],[\"这里有两个关键字\",{\"1\":{\"1001\":1}}],[\"这里有几个问题\",{\"1\":{\"982\":1}}],[\"这里有个费解的地方就是\",{\"1\":{\"792\":1}}],[\"这里有同学有疑问\",{\"1\":{\"661\":1}}],[\"这里\",{\"1\":{\"790\":1,\"793\":1}}],[\"这里为啥要切点\",{\"1\":{\"545\":1}}],[\"这里返回的对象会替换掉原本的bean\",{\"1\":{\"711\":2}}],[\"这里返回的对象会替换掉原本的\",{\"1\":{\"460\":2}}],[\"这里返回的对象若不为\",{\"1\":{\"460\":1}}],[\"这里如果返回\",{\"1\":{\"460\":1,\"711\":1}}],[\"这里出于怀旧的原因\",{\"1\":{\"451\":1}}],[\"这里n指的是数组的长度\",{\"1\":{\"327\":1}}],[\"这里的\",{\"1\":{\"811\":1}}],[\"这里的束修金\",{\"1\":{\"766\":1}}],[\"这里的优雅指的是给t2一个处理其他事情的机会\",{\"1\":{\"206\":1}}],[\"这里的经纪人是明星的朋友\",{\"1\":{\"111\":1}}],[\"这里bike是产品\",{\"1\":{\"49\":1}}],[\"这大大降低了客户程序与实现细节的耦合度\",{\"1\":{\"109\":1}}],[\"这对用户肯定是不友好的\",{\"1\":{\"109\":1}}],[\"这种用法比较普遍\",{\"1\":{\"1042\":1}}],[\"这种启动属于前台启动\",{\"1\":{\"1014\":1}}],[\"这种业务方法嵌套调用的时候\",{\"1\":{\"720\":1}}],[\"这种集群模式没有中心节点\",{\"1\":{\"434\":1}}],[\"这种项目就是理论与实践结合的桥梁\",{\"1\":{\"299\":1}}],[\"这种解法的主要思路如下\",{\"1\":{\"290\":1}}],[\"这种在特殊情况下产生的连续多次空间扩展操作就叫做\",{\"1\":{\"280\":1}}],[\"这种根据数据大小和类型进行不同的空间大小分配的设计思想\",{\"1\":{\"279\":1}}],[\"这种方案巧妙在于\",{\"1\":{\"987\":1}}],[\"这种方法好不好\",{\"1\":{\"829\":1}}],[\"这种方法可以有效地节省内存开销\",{\"1\":{\"278\":1}}],[\"这种方式优点在于节约内存空间\",{\"1\":{\"984\":1}}],[\"这种方式相对麻烦\",{\"1\":{\"719\":1}}],[\"这种方式对服务器资源要求比较高\",{\"1\":{\"334\":1}}],[\"这种方式需要一个重定位寄存器\",{\"1\":{\"151\":1}}],[\"这种方式需要考虑进程的优先级\",{\"1\":{\"148\":1}}],[\"这种方式的优点是实现简单\",{\"1\":{\"150\":1}}],[\"这种方式速度更快\",{\"1\":{\"134\":1}}],[\"这种方式速度慢\",{\"1\":{\"134\":1}}],[\"这种方式比较好理解\",{\"1\":{\"104\":1}}],[\"这种情况下\",{\"1\":{\"712\":1,\"928\":1}}],[\"这种情况下该怎么处理呢\",{\"1\":{\"290\":1}}],[\"这种情况占位符\",{\"1\":{\"366\":1}}],[\"这种情况一般有如下两种解决方式\",{\"1\":{\"313\":1}}],[\"这种情况我们可以适当增加位数组大小或者调整我们的哈希函数\",{\"1\":{\"273\":1}}],[\"这种情况需要使用深克隆\",{\"1\":{\"89\":1}}],[\"这种数据结构是高效且性能很好的\",{\"1\":{\"272\":1}}],[\"这种通过创建副本对象来避免共享的手段称之为\",{\"1\":{\"236\":1}}],[\"这种频繁的页面调度行为称为抖动\",{\"1\":{\"164\":1}}],[\"这种不可被中断的操作就是原子操作\",{\"1\":{\"133\":1}}],[\"这种模式就是strategy模式\",{\"1\":{\"114\":1}}],[\"这种模式涉及到一个单一的类\",{\"1\":{\"99\":1}}],[\"这种复用可以在运行时动态进行\",{\"1\":{\"112\":1}}],[\"这种类型的设计模式属于创建型模式\",{\"1\":{\"99\":1}}],[\"这时将数据从用户缓冲区\",{\"1\":{\"904\":1}}],[\"这时将剩余数据发送\",{\"1\":{\"751\":1}}],[\"这时写入\",{\"1\":{\"867\":1}}],[\"这时读取会返回\",{\"1\":{\"867\":1}}],[\"这时需要使用\",{\"1\":{\"835\":1}}],[\"这时需要向\",{\"1\":{\"791\":1}}],[\"这时调用\",{\"1\":{\"826\":1}}],[\"这时调用find方法来查找\",{\"1\":{\"249\":1}}],[\"这时无须\",{\"1\":{\"825\":1}}],[\"这时即使\",{\"1\":{\"825\":1}}],[\"这时要重复读取的话\",{\"1\":{\"824\":1}}],[\"这时要重新设置打断标记\",{\"1\":{\"206\":1}}],[\"这时会引发扩容\",{\"1\":{\"823\":1}}],[\"这时会调用equals方法来检查hashcode相等的对象是否真的相同\",{\"1\":{\"318\":1}}],[\"这时刚才的客户端代码\",{\"1\":{\"803\":1}}],[\"这时的\",{\"1\":{\"793\":1,\"826\":1}}],[\"这时是处理\",{\"1\":{\"793\":1,\"794\":1}}],[\"这时现象就是客户端数据发不出去\",{\"1\":{\"764\":1}}],[\"这时放不下了\",{\"1\":{\"751\":1}}],[\"这时最常见的选择\",{\"1\":{\"720\":1}}],[\"这时cpu会暂时执行下一个即将要执行的指令\",{\"1\":{\"406\":1}}],[\"这时当前运行进程会切换到处理此异常的内核相关进程\",{\"1\":{\"406\":1}}],[\"这时一种主动的死锁检测方法\",{\"1\":{\"403\":1}}],[\"这时打印的结果是\",{\"1\":{\"277\":1}}],[\"这时在操作这个字符串时就会提早结束\",{\"1\":{\"276\":1}}],[\"这时thread\",{\"1\":{\"261\":1}}],[\"这时仅比较值是不够的\",{\"1\":{\"233\":1}}],[\"这时候切换回来以后\",{\"1\":{\"347\":1}}],[\"这时候\",{\"1\":{\"246\":1,\"793\":1}}],[\"这时候会使用\",{\"1\":{\"246\":1}}],[\"这时候其他线程读取的数据就是脏数据了\",{\"1\":{\"230\":1}}],[\"这时候可以使用模板方法模式\",{\"1\":{\"122\":1}}],[\"这时该线程实际不会用到cpu\",{\"1\":{\"208\":1}}],[\"这时sleep方法会抛出interruptedexception\",{\"1\":{\"203\":1}}],[\"这时\",{\"1\":{\"91\":1,\"280\":1,\"644\":1,\"824\":1,\"825\":1,\"826\":1}}],[\"这些请求就都会访问到数据库\",{\"1\":{\"984\":1}}],[\"这些请求都会打到数据库\",{\"1\":{\"984\":1}}],[\"这些功能都得靠nginx起作用\",{\"1\":{\"955\":1}}],[\"这些拷贝叫做复制分片\",{\"1\":{\"928\":1}}],[\"这些事件发生\",{\"1\":{\"917\":1}}],[\"这些事件宏观上是同时发生的\",{\"1\":{\"127\":1}}],[\"这些方法不会改变\",{\"1\":{\"824\":1}}],[\"这些方法的未指明返回值的\",{\"1\":{\"822\":1}}],[\"这些方法的执行流程如下图\",{\"1\":{\"738\":1}}],[\"这些代码可以认为是现成的\",{\"1\":{\"783\":1}}],[\"这些东西加在一起即支持某项功能\",{\"1\":{\"727\":1}}],[\"这些被创建和管理的对象叫做bean\",{\"1\":{\"708\":1}}],[\"这些流程都不会走\",{\"1\":{\"678\":1}}],[\"这些\",{\"1\":{\"627\":1,\"917\":1}}],[\"这些通知调用时因为要为通知方法绑定参数\",{\"1\":{\"556\":1}}],[\"这些通知调用时无需再次检查切点\",{\"1\":{\"549\":1}}],[\"这些扩展功能由不同的\",{\"1\":{\"477\":1}}],[\"这些扩展功能由\",{\"1\":{\"470\":1}}],[\"这些段在内存中可以不相邻接\",{\"1\":{\"413\":1}}],[\"这些在每块中未被利用的空间\",{\"1\":{\"413\":1}}],[\"这些数据拷贝操作所带来的cpu以及内存开销是非常大的\",{\"1\":{\"408\":1}}],[\"这些都是池化思想的体现\",{\"1\":{\"1033\":1}}],[\"这些都是透明的\",{\"1\":{\"927\":1}}],[\"这些都是映射里面可以设置的\",{\"1\":{\"926\":1}}],[\"这些都是我调节情绪的方式\",{\"1\":{\"309\":1}}],[\"这些都会造成线程资源的浪费\",{\"1\":{\"331\":1}}],[\"这些具体数据传向前端\",{\"1\":{\"296\":1}}],[\"这些初始化工作是通过执行\",{\"1\":{\"178\":1}}],[\"这些指令会告诉cpu去内存的哪个地址存\",{\"1\":{\"151\":1}}],[\"这些进程都无法向前推进\",{\"1\":{\"147\":1}}],[\"这些进程为了完成某种任务\",{\"1\":{\"140\":1}}],[\"这些信息一般保存在进程控制块中\",{\"1\":{\"137\":1}}],[\"这些对象同当前对象存在关联\",{\"1\":{\"111\":1}}],[\"这些对象都需要创建\",{\"1\":{\"60\":1}}],[\"这些皮肤有共同的特点\",{\"1\":{\"107\":1}}],[\"这些工厂只生产同种类产品\",{\"1\":{\"71\":1}}],[\"这增加了系统的复杂度\",{\"1\":{\"70\":1}}],[\"这显然违背了软件设计的开闭原则\",{\"1\":{\"60\":1}}],[\"这并不是什么好事\",{\"1\":{\"58\":1}}],[\"这样数据不就一直占用我们内存了吗\",{\"1\":{\"987\":1}}],[\"这样是会存在缓存穿透问题的\",{\"1\":{\"985\":1}}],[\"这样缓存永远不会生效\",{\"1\":{\"984\":1}}],[\"这样极为不靠谱\",{\"1\":{\"962\":1}}],[\"这样连接建立到连接断开之间就是消息的边界\",{\"1\":{\"752\":1}}],[\"这样通过拦截器就可以增强处理器的功能\",{\"1\":{\"738\":1}}],[\"这样我们的后端就可以直接把json格式的数据映射到我们的userregisterrequest类上\",{\"1\":{\"731\":1}}],[\"这样当客户端要查找某个key时\",{\"1\":{\"435\":1}}],[\"这样对cpu友好\",{\"1\":{\"427\":1}}],[\"这样可将用户程序的任一页放入任一物理块中\",{\"1\":{\"413\":1}}],[\"这样可以保证获得最低的缺页率\",{\"1\":{\"420\":1}}],[\"这样可以保证对java核心源代码的保护\",{\"1\":{\"346\":1}}],[\"这样可以保证系统的稳定性和安全性\",{\"1\":{\"130\":1}}],[\"这样可以节省内存空间\",{\"1\":{\"277\":1}}],[\"这样会使得用户空间和内核空间在传递该结构时复制开销大\",{\"1\":{\"410\":1}}],[\"这样会导致死锁\",{\"1\":{\"147\":1}}],[\"这样所带来的缺点是\",{\"1\":{\"410\":1}}],[\"这样uuid就是有序的uuid了\",{\"1\":{\"392\":1}}],[\"这样程序的性能能够得到提高\",{\"1\":{\"389\":1}}],[\"这样也可以较少的建立一些索引\",{\"1\":{\"383\":1}}],[\"这样也就解除了和coffee实现类的耦合\",{\"1\":{\"63\":1}}],[\"这样降低了数据的维护速度\",{\"1\":{\"375\":1}}],[\"这样一个真正可用的对象才算完全创建出来\",{\"1\":{\"352\":1}}],[\"这样一来\",{\"1\":{\"277\":1}}],[\"这样相同的单词肯定是紧挨着的\",{\"1\":{\"291\":1}}],[\"这样在用户空间和内核空间的copy只需一次\",{\"1\":{\"410\":1}}],[\"这样在对字符串做修改操作的时候\",{\"1\":{\"277\":1}}],[\"这样在修改字符串的时候\",{\"1\":{\"277\":1}}],[\"这样获取字符串长度的时候\",{\"1\":{\"277\":1}}],[\"这样申请一个\",{\"1\":{\"272\":1}}],[\"这样加锁的好处是对于链表头节点加锁\",{\"1\":{\"249\":1}}],[\"这样的话\",{\"1\":{\"963\":1}}],[\"这样的话每个索引总共就有2个分片\",{\"1\":{\"928\":1}}],[\"这样的话就可以保证多线程同时访问的线程安全问题\",{\"1\":{\"249\":1}}],[\"这样的多路复用\",{\"1\":{\"845\":1}}],[\"这样的好处是可以提高查询速度\",{\"1\":{\"922\":1}}],[\"这样的好处是\",{\"1\":{\"277\":1}}],[\"这样的代码可实现共享\",{\"1\":{\"159\":1}}],[\"这样它们在累加时操作的不同的\",{\"1\":{\"234\":1}}],[\"这样留下的空闲区就不会太小\",{\"1\":{\"155\":1}}],[\"这样做的目的是提高内存的利用率和系统吞吐量\",{\"1\":{\"136\":1}}],[\"这样做确实简化了系统结构\",{\"1\":{\"49\":1}}],[\"这样多次调用objectinputstream类中的readobject方法\",{\"1\":{\"104\":1}}],[\"这样不仅能确保线程安全\",{\"1\":{\"101\":1}}],[\"这样\",{\"1\":{\"96\":1,\"277\":1,\"418\":1,\"984\":1,\"1042\":1}}],[\"这样就能保证事务的特性\",{\"1\":{\"998\":1}}],[\"这样就能确保在给定的时间里\",{\"1\":{\"398\":1}}],[\"这样就屏蔽了数据库的影响\",{\"1\":{\"705\":1}}],[\"这样就不会达到等待统计两个线程运行结束的预期了\",{\"1\":{\"263\":1}}],[\"这样就不会产生循环等待\",{\"1\":{\"148\":1}}],[\"这样就形成了最早的\",{\"1\":{\"154\":1}}],[\"这样就降低了客户与实现模块间的耦合\",{\"1\":{\"109\":1}}],[\"这样就降低了客户代码修改的可能性\",{\"1\":{\"64\":1}}],[\"这样就实现了懒加载的效果\",{\"1\":{\"101\":1}}],[\"这样就解决了简单工厂模式的缺点\",{\"1\":{\"69\":1}}],[\"这样以后就避免了修改客户代码\",{\"1\":{\"64\":1}}],[\"这样只需要修改工厂类的代码\",{\"1\":{\"63\":1}}],[\"这样使得我们的插头在当地能使用\",{\"1\":{\"39\":1}}],[\"这个代码咱们就不再解释啦\",{\"1\":{\"1043\":1}}],[\"这个格式并非固定\",{\"1\":{\"1026\":1}}],[\"这个方法是从常量池中拿到数据\",{\"1\":{\"998\":1}}],[\"这个方案\",{\"1\":{\"989\":1}}],[\"这个过期时间并不会直接作用于redis\",{\"1\":{\"987\":1}}],[\"这个过程是由master节点完成的\",{\"1\":{\"929\":1}}],[\"这个过程没法固定死\",{\"1\":{\"527\":1}}],[\"这个过程需要等待\",{\"1\":{\"409\":1}}],[\"这个请求会去访问redis\",{\"1\":{\"984\":1}}],[\"这个数据穿透了缓存\",{\"1\":{\"984\":1}}],[\"这个数据应该做什么样的处理\",{\"1\":{\"151\":1}}],[\"这个userdto对象就没有敏感信息了\",{\"1\":{\"962\":1}}],[\"这个操作比较重量级\",{\"1\":{\"904\":1}}],[\"这个操作对直接内存代价昂贵\",{\"1\":{\"820\":1}}],[\"这个问题直到\",{\"1\":{\"897\":1}}],[\"这个问题直到8\",{\"1\":{\"391\":1}}],[\"这个事件会频繁触发\",{\"1\":{\"894\":1}}],[\"这个设置便被忽略\",{\"1\":{\"776\":1}}],[\"这个限制称之为\",{\"1\":{\"751\":1}}],[\"这个限制使得\",{\"1\":{\"276\":1}}],[\"这个段的数据\",{\"1\":{\"751\":1}}],[\"这个消息是\",{\"1\":{\"750\":1}}],[\"这个注解时spring\",{\"1\":{\"731\":1}}],[\"这个注解可以标注在类或者方法上\",{\"1\":{\"721\":1}}],[\"这个\",{\"1\":{\"659\":1,\"672\":1,\"927\":1}}],[\"这个自动配置类提供\",{\"1\":{\"644\":1}}],[\"这个地址\",{\"1\":{\"617\":1}}],[\"这个后处理器配置错误页面地址\",{\"1\":{\"617\":1}}],[\"这个高层转换接口\",{\"1\":{\"576\":1}}],[\"这个视频中没有展示\",{\"1\":{\"449\":1}}],[\"这个根据自身业务进行设定即可\",{\"1\":{\"440\":1}}],[\"这个流程是发生在master节点中的\",{\"1\":{\"436\":1}}],[\"这个命令可能导致redis死循环阻塞\",{\"1\":{\"436\":1}}],[\"这个图和blocking\",{\"1\":{\"409\":1}}],[\"这个时候用户进程再调用read操作\",{\"1\":{\"409\":1}}],[\"这个哈希码的作用是确定对象在哈希表中的索引位置\",{\"1\":{\"318\":1}}],[\"这个系统就是一个创新\",{\"1\":{\"298\":1}}],[\"这个30和20就是可以设置的点\",{\"1\":{\"296\":1}}],[\"这个项目就是选择人流复杂类型的点位\",{\"1\":{\"295\":1}}],[\"这个小顶堆中的词就是出现频率最高的100词\",{\"1\":{\"290\":1}}],[\"这个结构体大小计算出来是\",{\"1\":{\"277\":1}}],[\"这个index级别比较range还低\",{\"1\":{\"266\":1}}],[\"这个目录就是起到覆盖索引的作用\",{\"1\":{\"266\":1}}],[\"这个速度损耗可以忽略\",{\"1\":{\"266\":1,\"383\":1}}],[\"这个队列主要用于等待条件的成立\",{\"1\":{\"254\":1}}],[\"这个进程可以是刚刚被暂停执行的进程\",{\"1\":{\"137\":1}}],[\"这个类提供了一种访问其唯一的对象的方式\",{\"1\":{\"99\":1}}],[\"这个例子其实就是典型的代理模式\",{\"1\":{\"93\":1}}],[\"这个就是静态工厂模式\",{\"1\":{\"65\":1}}],[\"这个接口\",{\"1\":{\"48\":1}}],[\"这个模式适用于\",{\"1\":{\"47\":1}}],[\"这夜晚\",{\"1\":{\"37\":1}}],[\"所在线程\",{\"1\":{\"883\":1}}],[\"所需要的资源有限\",{\"1\":{\"707\":1}}],[\"所管理\",{\"1\":{\"661\":1}}],[\"所访问的页面的页面序号为\",{\"1\":{\"420\":1}}],[\"所要花费的总时间\",{\"1\":{\"413\":1}}],[\"所属地区\",{\"1\":{\"296\":1}}],[\"所组成\",{\"1\":{\"159\":1}}],[\"所谓的\",{\"1\":{\"905\":1}}],[\"所谓的1+8+n\",{\"1\":{\"305\":1}}],[\"所谓动态通知\",{\"1\":{\"556\":1}}],[\"所谓静态通知\",{\"1\":{\"549\":1}}],[\"所谓readview\",{\"1\":{\"393\":1}}],[\"所谓扰动函数指的就是hashmap中的hash方法\",{\"1\":{\"327\":1}}],[\"所谓幂等性通俗的将就是一次请求和多次请求同一个资源产生相同的副作用\",{\"1\":{\"312\":1}}],[\"所谓安全序列\",{\"1\":{\"149\":1}}],[\"所谓最短\",{\"1\":{\"139\":1}}],[\"所谓创建进程就是创建pcb\",{\"1\":{\"131\":1}}],[\"所以操作成功\",{\"1\":{\"1025\":1}}],[\"所以lisi的操作失败\",{\"1\":{\"1025\":1}}],[\"所以只成功删除3个\",{\"1\":{\"1024\":1}}],[\"所以只允许在核心态下执行特权指令\",{\"1\":{\"133\":1}}],[\"所以利用这么一个类\",{\"1\":{\"997\":1}}],[\"所以没有问题\",{\"1\":{\"996\":1}}],[\"所以没有额外的内存消耗\",{\"1\":{\"987\":1}}],[\"所以像第二种卷\",{\"1\":{\"994\":1}}],[\"所以是可以任意领取\",{\"1\":{\"994\":1}}],[\"所以他们的id是不能一样的\",{\"1\":{\"992\":1}}],[\"所以数据一致\",{\"1\":{\"987\":1}}],[\"所以线程3和线程4可以实现互斥\",{\"1\":{\"999\":1}}],[\"所以线程3无法获得锁\",{\"1\":{\"987\":1}}],[\"所以线程2无法执行成功\",{\"1\":{\"996\":1}}],[\"所以线程2\",{\"1\":{\"996\":1}}],[\"所以线程不会陷入阻塞\",{\"1\":{\"231\":1}}],[\"所以为了适应当下的情况\",{\"1\":{\"976\":1}}],[\"所以企业会大量运用到缓存技术\",{\"1\":{\"975\":1}}],[\"所以企业非常重视缓存技术\",{\"1\":{\"974\":1}}],[\"所以其引用\",{\"1\":{\"974\":1}}],[\"所以随着类的加载而被加载到内存之中\",{\"1\":{\"974\":1}}],[\"所以随着fd的增加会造成遍历速度慢的\",{\"1\":{\"410\":1}}],[\"所以咱们后来采用的方案都是基于redis来完成\",{\"1\":{\"963\":1}}],[\"所以此时其他线程都会失败\",{\"1\":{\"997\":1}}],[\"所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可\",{\"1\":{\"971\":1}}],[\"所以此时令牌刷新的动作实际上就不会执行\",{\"1\":{\"970\":1}}],[\"所以此时\",{\"1\":{\"963\":1}}],[\"所以可以通过这种方式来做到线程隔离\",{\"1\":{\"961\":1}}],[\"所以可存储包含\",{\"1\":{\"277\":1}}],[\"所以nginx是整个项目中重要的一环\",{\"1\":{\"955\":1}}],[\"所以最后要执行\",{\"1\":{\"908\":1}}],[\"所以常被用作讲述标点符号的重要性\",{\"1\":{\"766\":1}}],[\"所以很多时候我们就用di来替代它\",{\"1\":{\"706\":1}}],[\"所以很容易知道此值已经存在\",{\"1\":{\"273\":1}}],[\"所以处理异常的职责就又回到了\",{\"1\":{\"617\":1}}],[\"所以一定要保证主从节点的机器时钟一致性\",{\"1\":{\"437\":1}}],[\"所以redis会对部分数据进行更新\",{\"1\":{\"980\":1}}],[\"所以redis采用两者结合的方式进行过期数据删除\",{\"1\":{\"427\":1}}],[\"所以redis仍然是并发安全的\",{\"1\":{\"423\":1}}],[\"所以两者都是离散分配内存的方式\",{\"1\":{\"413\":1}}],[\"所以也同样实现了离散分配\",{\"1\":{\"413\":1}}],[\"所以无法像myisam一样\",{\"1\":{\"387\":1}}],[\"所以会先在联合索引中通过lastname进行过滤\",{\"1\":{\"385\":1}}],[\"所以任何关键字的查找必须走一条从根节点到叶子节点的路\",{\"1\":{\"378\":1}}],[\"所以即使不报错\",{\"1\":{\"365\":1}}],[\"所以就需要针对不同的场景\",{\"1\":{\"360\":1}}],[\"所以就需要一个插座转换器\",{\"1\":{\"39\":1}}],[\"所以单例程序中\",{\"1\":{\"358\":1}}],[\"所以能减少系统的停顿时间\",{\"1\":{\"356\":1}}],[\"所以指定一个合适的\",{\"1\":{\"328\":1}}],[\"所以后端幂等性很重要\",{\"1\":{\"315\":1}}],[\"所以我们把这种松散结构的数据库\",{\"1\":{\"1001\":1}}],[\"所以我们选择将当前方法整体包裹起来\",{\"1\":{\"998\":1}}],[\"所以我们选择的只是对具体应用最合适的收集器\",{\"1\":{\"360\":1}}],[\"所以我们需要使用intern\",{\"1\":{\"998\":1}}],[\"所以我们需要使用悲观锁操作\",{\"1\":{\"998\":1}}],[\"所以我们需要去控制锁的粒度\",{\"1\":{\"998\":1}}],[\"所以我们需要增加缓存\",{\"1\":{\"977\":1}}],[\"所以我们还是需要加锁\",{\"1\":{\"998\":1}}],[\"所以我们应当增加一层逻辑\",{\"1\":{\"998\":1}}],[\"所以我们应当在返回用户信息之前\",{\"1\":{\"962\":1}}],[\"所以我们的乐观锁需要变一下\",{\"1\":{\"997\":1}}],[\"所以我们此时需要使用到countdownlatch\",{\"1\":{\"993\":1}}],[\"所以我们在后台生成一个随机串token\",{\"1\":{\"966\":1}}],[\"所以我们在高并发场景下\",{\"1\":{\"955\":1}}],[\"所以我们可以使用string结构\",{\"1\":{\"966\":1}}],[\"所以我们没必让每个线程必须持有锁才能调用该方法\",{\"1\":{\"101\":1}}],[\"所以我觉得我的动手能力还算可以\",{\"1\":{\"293\":1}}],[\"所以复杂度只有\",{\"1\":{\"277\":1}}],[\"所以使用await可以让main线程阻塞\",{\"1\":{\"993\":1}}],[\"所以使用\",{\"1\":{\"277\":1}}],[\"所以\",{\"1\":{\"276\":1,\"277\":2,\"280\":1,\"409\":1,\"419\":1,\"707\":2,\"718\":1}}],[\"所以字段名称需要慎重考虑\",{\"1\":{\"265\":1}}],[\"所以不能在这里善后\",{\"1\":{\"804\":1}}],[\"所以不能对final修饰的类进行代理\",{\"1\":{\"717\":1}}],[\"所以不会对用户进程产生任何block\",{\"1\":{\"409\":1}}],[\"所以不会出现可重复读\",{\"1\":{\"393\":1}}],[\"所以不需要定义成抽象方法\",{\"1\":{\"255\":1}}],[\"所以不计入等待时间\",{\"1\":{\"138\":1}}],[\"所以归结于同步模式\",{\"1\":{\"217\":1}}],[\"所以算法性能较差\",{\"1\":{\"163\":1}}],[\"所以对换区空间的管理主要追求换入换出速度\",{\"1\":{\"153\":1}}],[\"所以p2进入阻塞的状态\",{\"1\":{\"150\":1}}],[\"所以中级调度发生的频率比高级调度高\",{\"1\":{\"136\":1}}],[\"所以内核级线程的切换必须要在核心态下完成\",{\"1\":{\"135\":1}}],[\"所以在每个用户去访问我们的工程时\",{\"1\":{\"961\":1}}],[\"所以在活跃的socket较少的情况下\",{\"1\":{\"410\":1}}],[\"所以在去重的时候也会快很多\",{\"1\":{\"383\":1}}],[\"所以在controller层实体类型的参数前需要加上\",{\"1\":{\"365\":1}}],[\"所以在成员变量为\",{\"1\":{\"277\":1}}],[\"所以在此处重点看的方法是带三个参数的方法\",{\"1\":{\"123\":1}}],[\"所以在运\",{\"1\":{\"112\":1}}],[\"所以直接实现\",{\"1\":{\"120\":2}}],[\"所以这个地方\",{\"1\":{\"998\":1}}],[\"所以这个方案他是存在问题的\",{\"1\":{\"970\":1}}],[\"所以这个案例可以使用抽象工厂模式实现\",{\"1\":{\"74\":1}}],[\"所以这里我们采用高级\",{\"1\":{\"932\":1}}],[\"所以这种复用又称为\",{\"1\":{\"112\":2}}],[\"所以适合使用迪米特法则\",{\"1\":{\"111\":1}}],[\"所以许多日常事务由经纪人负责处理\",{\"1\":{\"111\":1}}],[\"所以它是满足开闭原则的\",{\"1\":{\"107\":1}}],[\"所以它通常在以下场合使用\",{\"1\":{\"51\":1}}],[\"所以返回的是同一个对象\",{\"1\":{\"104\":1}}],[\"所以和饿汉式的方式1基本上一样\",{\"1\":{\"101\":1}}],[\"所以如果有接口使用jdk动态代理\",{\"1\":{\"96\":1}}],[\"所以需要两圈\",{\"1\":{\"177\":1}}],[\"所以需要引入jar包的坐标\",{\"1\":{\"95\":1}}],[\"所以需要实现selltickets接口\",{\"1\":{\"93\":1,\"94\":1}}],[\"所以说\",{\"1\":{\"60\":1,\"281\":1,\"409\":1}}],[\"所以应用相对较少些\",{\"1\":{\"39\":1}}],[\"所有内容\",{\"1\":{\"827\":1}}],[\"所有\",{\"1\":{\"816\":1}}],[\"所有异常然后设置为\",{\"1\":{\"815\":1}}],[\"所有单例初始化完成后\",{\"1\":{\"699\":1}}],[\"所有接口当做\",{\"1\":{\"661\":1}}],[\"所有select负责的socket\",{\"1\":{\"409\":1}}],[\"所有修改先写入日志\",{\"1\":{\"396\":1}}],[\"所有二级索引都引用主键索引\",{\"1\":{\"379\":1}}],[\"所有关键字查询的路径长度相同\",{\"1\":{\"378\":1}}],[\"所有属性设置默认值\",{\"1\":{\"352\":1}}],[\"所有位置均为\",{\"1\":{\"273\":1}}],[\"所有线程都运行完了进行汇总\",{\"1\":{\"262\":1}}],[\"所有线程\",{\"1\":{\"252\":1}}],[\"所有创建的线程都是救急线程\",{\"1\":{\"244\":1}}],[\"所有淘汰一个页面最多进行四轮扫描\",{\"1\":{\"163\":1}}],[\"所有涉及到子类的功能都有可能产生故障\",{\"1\":{\"108\":1}}],[\"所有代理类也需要实现此方法\",{\"1\":{\"96\":1}}],[\"所有的排名默认都是升序\",{\"1\":{\"1030\":1}}],[\"所有的拦截器都需要实现handlerinterceptor接口\",{\"1\":{\"738\":1}}],[\"所有的字符存储与表示\",{\"1\":{\"267\":1}}],[\"所有的线程管理工作都是由应用程序负责\",{\"1\":{\"135\":1}}],[\"所有的工厂类都需要进行修改\",{\"1\":{\"75\":1}}],[\"所有的爱都是冒险\",{\"1\":{\"37\":2}}],[\"所有new对象的地方都需要修改一遍\",{\"1\":{\"60\":1}}],[\"所有悬念\",{\"1\":{\"37\":2}}],[\"因而该算法无法实现\",{\"1\":{\"420\":1}}],[\"因争夺所资源而造成的一种相互等待的现象\",{\"1\":{\"403\":1}}],[\"因等待某一事件而暂时不能运行\",{\"1\":{\"132\":1}}],[\"因为sortedset的可排序特性\",{\"1\":{\"1030\":1}}],[\"因为也是一个hash表\",{\"1\":{\"1029\":1}}],[\"因为之前配置了密码\",{\"1\":{\"1015\":1}}],[\"因为你调用的方法\",{\"1\":{\"998\":1}}],[\"因为如果锁的粒度太大\",{\"1\":{\"998\":1}}],[\"因为如果同类资源的数量大于1\",{\"1\":{\"147\":1}}],[\"因为现在redis中存储的数据的value需要带上过期时间\",{\"1\":{\"989\":1}}],[\"因为仅仅只需要加一把锁而已\",{\"1\":{\"987\":1}}],[\"因为此时会让查询的性能从并行变成了串行\",{\"1\":{\"987\":1}}],[\"因为此时用的还是内嵌\",{\"1\":{\"648\":1}}],[\"因为锁能实现互斥性\",{\"1\":{\"987\":1}}],[\"因为速度快\",{\"1\":{\"975\":1}}],[\"因为第一个拦截器有了threadlocal的数据\",{\"1\":{\"971\":1}}],[\"因为早期版本的客户端对象已经不再推荐使用\",{\"1\":{\"932\":1}}],[\"因为搜索可以在所有的副本上并行运行\",{\"1\":{\"928\":1}}],[\"因为容器不是物理隔离的\",{\"1\":{\"897\":1}}],[\"因为客户端断开了\",{\"1\":{\"890\":1}}],[\"因为进行了数据的内存复制操作\",{\"1\":{\"829\":1}}],[\"因为进程在一段时间内可能只需要访问某几个特定的页面\",{\"1\":{\"158\":1}}],[\"因为底层都是同一块内存\",{\"1\":{\"826\":1}}],[\"因为它们有网络通信需求\",{\"1\":{\"841\":1}}],[\"因为它有独立的读写指针\",{\"1\":{\"826\":1}}],[\"因为它的吞吐量比较大\",{\"1\":{\"258\":1}}],[\"因为节点3\",{\"1\":{\"816\":1}}],[\"因为只有一个\",{\"1\":{\"790\":1}}],[\"因为是\",{\"1\":{\"790\":1}}],[\"因为是对于底层的操作\",{\"1\":{\"235\":1}}],[\"因为分隔符本身如果用于传输\",{\"1\":{\"766\":1}}],[\"因为接收方的缓冲区大小是有限的\",{\"1\":{\"753\":1}}],[\"因为在启动时就完成所有初始化\",{\"1\":{\"707\":1}}],[\"因为内嵌了\",{\"1\":{\"617\":1}}],[\"因为目前的\",{\"1\":{\"506\":1}}],[\"因为生成的\",{\"1\":{\"440\":1}}],[\"因为不用代理\",{\"1\":{\"504\":1}}],[\"因为不会删除过期key\",{\"1\":{\"436\":1}}],[\"因为不能同时访问硬盘资源\",{\"1\":{\"127\":1}}],[\"因为epoll内核中实现是根据每个fd上的callback函数来实现的\",{\"1\":{\"410\":1}}],[\"因为exists的实现\",{\"1\":{\"386\":1}}],[\"因为他们需要在读写事件就绪后自己负责进行读写\",{\"1\":{\"410\":1}}],[\"因为这个命令在key过多的情况下\",{\"1\":{\"1024\":1}}],[\"因为这个原因\",{\"1\":{\"928\":1}}],[\"因为这部分内存不受\",{\"1\":{\"819\":1}}],[\"因为这里需要使用两个system\",{\"1\":{\"409\":1}}],[\"因为这些节点长度值小于\",{\"1\":{\"280\":1}}],[\"因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证\",{\"1\":{\"277\":1}}],[\"因为每次调用时都会对连接进行线性遍历\",{\"1\":{\"410\":1}}],[\"因为每次修改的数据位置随机\",{\"1\":{\"396\":1}}],[\"因为每增加一张表就相当于增加了一次嵌套的循环\",{\"1\":{\"383\":1}}],[\"因为where可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据\",{\"1\":{\"394\":1}}],[\"因为主键采用的索引是聚簇索引\",{\"1\":{\"387\":1}}],[\"因为数据页对应着索引树的节点\",{\"1\":{\"376\":1}}],[\"因为有sql注入的风险\",{\"1\":{\"366\":1}}],[\"因为java的使用场景很多\",{\"1\":{\"360\":1}}],[\"因为jdk动态代理要求必须定义接口\",{\"1\":{\"95\":1}}],[\"因为随着硬件发展\",{\"1\":{\"359\":1}}],[\"因为线程和上下文切换的消耗\",{\"1\":{\"356\":1}}],[\"因为cpu需要不停的切换各个线程\",{\"1\":{\"347\":1}}],[\"因为cglib原理是动态生成被代理类的子类\",{\"1\":{\"96\":1}}],[\"因为我觉得这能稍微减缓我的压力以及所带来的负面情绪\",{\"1\":{\"309\":1}}],[\"因为我是南京人\",{\"1\":{\"307\":1}}],[\"因为很重视重大考试或者面试当然也重视其结果\",{\"1\":{\"308\":1}}],[\"因为很多数据在内存中都是连续存放的\",{\"1\":{\"161\":1}}],[\"因为刚才的扩展空间\",{\"1\":{\"280\":1}}],[\"因为先前的对应位置已设置为\",{\"1\":{\"273\":1}}],[\"因为无法进行预发布\",{\"1\":{\"265\":1}}],[\"因为aqs中队列满足fifo的特性\",{\"1\":{\"258\":1}}],[\"因为子类只要实现这几个方法中的一部分就可以实现一个同步器了\",{\"1\":{\"255\":1}}],[\"因为当threadlocal对象使用完之后\",{\"1\":{\"247\":1}}],[\"因为当p1进程想访问资源\",{\"1\":{\"141\":1}}],[\"因为没有使用synchronized\",{\"1\":{\"231\":1}}],[\"因为volatile只能保证可见性并不能保证原子性\",{\"1\":{\"230\":1}}],[\"因为其他资源被别的线程所使用\",{\"1\":{\"221\":1}}],[\"因为一个线程需要等待另一个线程的执行结果\",{\"1\":{\"217\":1}}],[\"因为异常表中当在6\",{\"1\":{\"211\":1}}],[\"因为\",{\"1\":{\"194\":1,\"277\":1,\"280\":1,\"383\":1,\"791\":2,\"805\":1,\"816\":1,\"825\":1,\"887\":1,\"891\":1}}],[\"因为要一个隔着一个的读\",{\"1\":{\"177\":1}}],[\"因为程序中存在着大量的循环\",{\"1\":{\"161\":1}}],[\"因为需要对换的速度\",{\"1\":{\"153\":1}}],[\"因为地址已经写死\",{\"1\":{\"151\":1}}],[\"因为可能需要重新分配所有的编号\",{\"1\":{\"148\":1}}],[\"因为开关中断只是相对一个处理机来说的\",{\"1\":{\"142\":1}}],[\"因为innodb支持事务\",{\"1\":{\"387\":1}}],[\"因为i\",{\"1\":{\"139\":1}}],[\"因为成分对象的内部细节是新对象看不见的\",{\"1\":{\"112\":1}}],[\"因为继承会将父类的实现细节暴露给子类\",{\"1\":{\"112\":1}}],[\"因为抽象灵活性好\",{\"1\":{\"107\":1}}],[\"因为枚举类型是线程安全的\",{\"1\":{\"101\":1}}],[\"因为小尺度每个grid\",{\"1\":{\"24\":1}}],[\"因此springdataredis就提供了redistemplate的子类\",{\"1\":{\"1042\":1}}],[\"因此我们推荐大家使用jedis连接池代替jedis的直连方式\",{\"1\":{\"1033\":1}}],[\"因此我们后期会直接以springdataredis来学习\",{\"1\":{\"1031\":1}}],[\"因此我们的笔记本电脑\",{\"1\":{\"39\":1}}],[\"因此具备与hashset类似的特征\",{\"1\":{\"1029\":1}}],[\"因此具有可重入锁的特性\",{\"1\":{\"249\":1}}],[\"因此首先需要安装redis所需要的gcc依赖\",{\"1\":{\"1011\":1}}],[\"因此课程中我们会基于linux系统来安装redis\",{\"1\":{\"1010\":1}}],[\"因此才需要建立映射\",{\"1\":{\"926\":1}}],[\"因此内存地址固定\",{\"1\":{\"905\":1}}],[\"因此又得从用户态切换至内核态\",{\"1\":{\"904\":1}}],[\"因此应当只在\",{\"1\":{\"894\":1}}],[\"因此需要通过\",{\"1\":{\"1015\":1}}],[\"因此需要追踪\",{\"1\":{\"893\":1}}],[\"因此需要设计大小可变的\",{\"1\":{\"891\":1}}],[\"因此需要为每个\",{\"1\":{\"891\":1}}],[\"因此需要将\",{\"1\":{\"890\":1}}],[\"因此需要采用扫描全表\",{\"1\":{\"387\":1}}],[\"因此不用担心赋值\",{\"1\":{\"974\":1}}],[\"因此不适合长连接\",{\"1\":{\"876\":1}}],[\"因此不能配合\",{\"1\":{\"881\":1}}],[\"因此不能追加\",{\"1\":{\"826\":1}}],[\"因此不能保存二进制数据\",{\"1\":{\"276\":1}}],[\"因此不能调用\",{\"1\":{\"244\":1}}],[\"因此无论读写\",{\"1\":{\"828\":1}}],[\"因此可以在任意目录下运行这些命令\",{\"1\":{\"1012\":1}}],[\"因此可以做如下优化\",{\"1\":{\"805\":1}}],[\"因此可以配置\",{\"1\":{\"617\":1}}],[\"因此执行到\",{\"1\":{\"803\":1}}],[\"因此包含了线程池中所有的方法\",{\"1\":{\"796\":1}}],[\"因此会触发多次\",{\"1\":{\"794\":1}}],[\"因此会产生饥饿现象\",{\"1\":{\"141\":1}}],[\"因此下面的\",{\"1\":{\"791\":1}}],[\"因此策略就可以定为\",{\"1\":{\"764\":1}}],[\"因此为了提高网络利用率\",{\"1\":{\"751\":1}}],[\"因此为了补充损失的时间性能\",{\"1\":{\"413\":1}}],[\"因此以太网\",{\"1\":{\"751\":1}}],[\"因此成员变量\",{\"1\":{\"516\":1}}],[\"因此代理与目标之间是子父关系\",{\"1\":{\"513\":1}}],[\"因此代理与目标之间是平级兄弟关系\",{\"1\":{\"511\":1}}],[\"因此没有广泛流行\",{\"1\":{\"504\":1}}],[\"因此要创建其中的\",{\"1\":{\"491\":1}}],[\"因此很多资料还在讲解它较旧的实现\",{\"1\":{\"451\":1}}],[\"因此效率要比lt模式高\",{\"1\":{\"410\":1}}],[\"因此随着监视的文件描述符数量的增长\",{\"1\":{\"410\":1}}],[\"因此你可以有多个线程同时对一张表增删改查\",{\"1\":{\"400\":1}}],[\"因此在实际的网络环境中\",{\"1\":{\"410\":1}}],[\"因此在锁定数据较多的情况下使用表锁可以节省大量资源\",{\"1\":{\"396\":1}}],[\"因此在用户程序中\",{\"1\":{\"130\":1}}],[\"因此读写不冲突\",{\"1\":{\"393\":1}}],[\"因此当我们使用\",{\"1\":{\"383\":1}}],[\"因此其内部节点相对b树更小\",{\"1\":{\"378\":1}}],[\"因此其使用范围受到一定的限制\",{\"1\":{\"50\":1}}],[\"因此出现错误\",{\"1\":{\"366\":1}}],[\"因此一般来说\",{\"1\":{\"352\":1}}],[\"因此一般只适用于易保存和恢复状态的资源\",{\"1\":{\"148\":1}}],[\"因此使用了一个原子布尔对象\",{\"1\":{\"791\":1}}],[\"因此使用单个线程可以监听多个客户端通道\",{\"1\":{\"334\":1}}],[\"因此使用sum\",{\"1\":{\"267\":1}}],[\"因此连锁更新一旦发生\",{\"1\":{\"281\":1}}],[\"因此原本\",{\"1\":{\"280\":1}}],[\"因此压缩列表不适合保存过多的元素\",{\"1\":{\"279\":1}}],[\"因此thread\",{\"1\":{\"261\":1}}],[\"因此也称之为非关系型数据库\",{\"1\":{\"1003\":1}}],[\"因此也是具有幂等性的\",{\"1\":{\"314\":1}}],[\"因此也无需超时时间\",{\"1\":{\"244\":1}}],[\"因此也就不会发生两个同时访问临界区的情况\",{\"1\":{\"142\":1}}],[\"因此也就不会对原有功能引入风险\",{\"1\":{\"50\":1}}],[\"因此减少了\",{\"1\":{\"234\":1}}],[\"因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序\",{\"1\":{\"182\":1}}],[\"因此操作系统也无法优化延迟时间和传输时间\",{\"1\":{\"176\":1}}],[\"因此b字节的数据需要b\",{\"1\":{\"176\":1}}],[\"因此乘21​\",{\"1\":{\"176\":1}}],[\"因此300号块的数据需要复制到超级块中\",{\"1\":{\"170\":1}}],[\"因此文件的访问效率更高\",{\"1\":{\"169\":1}}],[\"因此文件区空间的管理采用离散分配方式\",{\"1\":{\"153\":1}}],[\"因此这些属性变化时需要修改相应的目录项\",{\"1\":{\"168\":1}}],[\"因此这些碎片不能满足进程的需求\",{\"1\":{\"154\":1}}],[\"因此索引表可能会很大\",{\"1\":{\"167\":1}}],[\"因此i\",{\"1\":{\"164\":1}}],[\"因此经过第三轮\",{\"1\":{\"163\":1}}],[\"因此最佳置换算法是无法实现的\",{\"1\":{\"163\":1}}],[\"因此页面置换算法应该追求更少的缺页率\",{\"1\":{\"163\":1}}],[\"因此属于内中断\",{\"1\":{\"162\":1}}],[\"因此只有少量作业能运行\",{\"1\":{\"161\":1}}],[\"因此只有内核级线程才是处理机分配的单位\",{\"1\":{\"135\":1}}],[\"因此系统分区的大小和数目是可变的\",{\"1\":{\"154\":1}}],[\"因此装入到内存中的地址依旧是逻辑地址\",{\"1\":{\"151\":1}}],[\"因此该机制遵循了让权等待\",{\"1\":{\"143\":1}}],[\"因此新进程会抢占处理机\",{\"1\":{\"139\":1}}],[\"因此时间片不能太大\",{\"1\":{\"139\":1}}],[\"因此时间片rr属于抢占式算法\",{\"1\":{\"139\":1}}],[\"因此有一定的开销\",{\"1\":{\"139\":1}}],[\"因此过于频繁的进行进程调度\",{\"1\":{\"137\":1}}],[\"因此线程管理成本高\",{\"1\":{\"135\":1}}],[\"因此线程调度\",{\"1\":{\"135\":1}}],[\"因此各进程拥有的内存地址空间相互独立\",{\"1\":{\"134\":1}}],[\"因此cpu要从用户态转为核心态\",{\"1\":{\"129\":1}}],[\"因此\",{\"1\":{\"50\":1,\"80\":1,\"161\":1,\"163\":1,\"265\":1,\"276\":2,\"277\":1,\"278\":1,\"281\":1,\"375\":1,\"490\":1,\"500\":1,\"617\":1,\"686\":1,\"766\":1,\"790\":1,\"803\":1,\"904\":1,\"981\":1}}],[\"就用到了工厂设计模式\",{\"1\":{\"1034\":1}}],[\"就在我们之前解压的redis安装包下\",{\"1\":{\"1015\":1}}],[\"就在这夜晚\",{\"1\":{\"37\":1}}],[\"就意味着没有人在中间修改过库存\",{\"1\":{\"997\":1}}],[\"就意味着需要操作系统介入\",{\"1\":{\"129\":1}}],[\"就得限制数量\",{\"1\":{\"994\":1}}],[\"就得知道接着从哪条指令开始继续执行\",{\"1\":{\"347\":1}}],[\"就取消\",{\"1\":{\"893\":1}}],[\"就取最近30天的数据进行分析\",{\"1\":{\"296\":1}}],[\"就有两阶段策略\",{\"1\":{\"893\":1}}],[\"就能回到\",{\"1\":{\"854\":1}}],[\"就能大幅提升效率\",{\"1\":{\"383\":1}}],[\"就好比截取了原始\",{\"1\":{\"827\":1}}],[\"就没用了\",{\"1\":{\"825\":1}}],[\"就没有这么高效了\",{\"1\":{\"279\":1}}],[\"就没有内存分区可以用了\",{\"1\":{\"155\":1}}],[\"就失去了传递性\",{\"1\":{\"825\":1}}],[\"就属于废弃部分了\",{\"1\":{\"824\":1}}],[\"就一条消息\",{\"1\":{\"793\":1}}],[\"就一定不会发生死锁\",{\"1\":{\"149\":1}}],[\"就这么一直耗着\",{\"1\":{\"764\":1}}],[\"就要负责到底\",{\"1\":{\"837\":1}}],[\"就要使用与之对应的事务管理器\",{\"1\":{\"721\":1}}],[\"就要停止操作\",{\"1\":{\"276\":1}}],[\"就为\",{\"1\":{\"644\":1}}],[\"就问恶心不\",{\"1\":{\"617\":1}}],[\"就调用目标方法\",{\"1\":{\"552\":1}}],[\"就把通知的增强功能\",{\"1\":{\"504\":1}}],[\"就代表存在死锁\",{\"1\":{\"403\":1}}],[\"就需要\",{\"1\":{\"383\":1}}],[\"就需要再定义新的类\",{\"1\":{\"112\":1}}],[\"就成功返回\",{\"1\":{\"345\":1}}],[\"就判断该元素与要存入的hash以及key是否相同\",{\"1\":{\"327\":1}}],[\"就比如前两天毕业生照片采集的时候\",{\"1\":{\"305\":1}}],[\"就比如我除了学习一些java的相关知识外\",{\"1\":{\"293\":1}}],[\"就比如自己搭博客并且给博客上了自己的域名\",{\"1\":{\"293\":1}}],[\"就闲下来了\",{\"1\":{\"246\":1}}],[\"就以\",{\"1\":{\"236\":1}}],[\"就算是堆内存\",{\"1\":{\"820\":1}}],[\"就算改了也没关系\",{\"1\":{\"231\":1}}],[\"就算保证其他线程的可见性\",{\"1\":{\"230\":1}}],[\"就获得了锁\",{\"1\":{\"212\":1}}],[\"就相当于main线程运行了一个普通的run方法\",{\"1\":{\"202\":1}}],[\"就选择该页换出\",{\"1\":{\"163\":1}}],[\"就可能存在哈希冲突\",{\"1\":{\"984\":1}}],[\"就可能会产生fail\",{\"1\":{\"324\":1}}],[\"就可能发生死锁\",{\"1\":{\"149\":1}}],[\"就可以通过工厂来获得\",{\"1\":{\"1035\":1}}],[\"就可以执行static的操作完成对\",{\"1\":{\"1034\":1}}],[\"就可以避免session共享的问题了\",{\"1\":{\"963\":1}}],[\"就可以实现session的共享了\",{\"1\":{\"963\":1}}],[\"就可以方便获取消息大小\",{\"1\":{\"890\":1}}],[\"就可以监控多个\",{\"1\":{\"879\":1}}],[\"就可以安全地在多线程下被共享\",{\"1\":{\"771\":1}}],[\"就可以像使用普通的bean一样\",{\"1\":{\"731\":1}}],[\"就可以完成依赖框架的自动配置\",{\"1\":{\"730\":1}}],[\"就可以在请求到达时\",{\"1\":{\"561\":1}}],[\"就可以再联动调用目标方法\",{\"1\":{\"516\":1}}],[\"就可以利用\",{\"1\":{\"473\":1}}],[\"就可以由程序内部判断缓冲区大小是否足够用\",{\"1\":{\"277\":1}}],[\"就可以让程序开始执行\",{\"1\":{\"161\":1}}],[\"就可以暂停换出\",{\"1\":{\"153\":1}}],[\"就说明内存紧张\",{\"1\":{\"153\":1}}],[\"就不再阻塞\",{\"1\":{\"993\":1}}],[\"就不会被接收方弄错意思了\",{\"1\":{\"766\":1}}],[\"就不会被其他线程所打断\",{\"1\":{\"226\":1}}],[\"就不需要执行i\",{\"1\":{\"163\":1}}],[\"就不用进行页面置换\",{\"1\":{\"163\":1}}],[\"就不能装入该作业\",{\"1\":{\"151\":1}}],[\"就不允许写\",{\"1\":{\"134\":1}}],[\"就不允许读\",{\"1\":{\"134\":1}}],[\"就称这个图是可完全简化的\",{\"1\":{\"150\":1}}],[\"就称为饿死\",{\"1\":{\"139\":1}}],[\"就绪状态有机会被任务调度器调用\",{\"1\":{\"203\":1}}],[\"就绪状态\",{\"1\":{\"203\":1,\"208\":1}}],[\"就绪队列改变时就需要调度\",{\"1\":{\"139\":1}}],[\"就绪态\",{\"1\":{\"132\":1}}],[\"就从管道中被抛弃\",{\"1\":{\"134\":1}}],[\"就是不借助默认的序列化器\",{\"1\":{\"1042\":1}}],[\"就是修改\",{\"1\":{\"1025\":1}}],[\"就是cas\",{\"1\":{\"996\":1}}],[\"就是数据交换的缓冲区\",{\"1\":{\"974\":1}}],[\"就是数据存放在内存中的实际位置\",{\"1\":{\"151\":1}}],[\"就是说虽然每个tomcat上都有不同的session\",{\"1\":{\"963\":1}}],[\"就是流水线上的各道工序\",{\"1\":{\"816\":1}}],[\"就是上面的\",{\"1\":{\"811\":1}}],[\"就是通过这样的机制\",{\"1\":{\"745\":1}}],[\"就是通过字符数组中的每一个字符\",{\"1\":{\"276\":1}}],[\"就是根据一些特定条件来控制实例化的行为\",{\"1\":{\"731\":1}}],[\"就是根据前端select表单的省市区选择\",{\"1\":{\"296\":1}}],[\"就是\",{\"1\":{\"731\":1,\"816\":1}}],[\"就是将来事件发生后\",{\"1\":{\"890\":1}}],[\"就是将对象的控制权交由spring框架来管理\",{\"1\":{\"706\":1}}],[\"就是将某些进程挂起\",{\"1\":{\"153\":1}}],[\"就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了\",{\"1\":{\"987\":1}}],[\"就是一个简单的key\",{\"1\":{\"966\":1}}],[\"就是一个创建新进程的系统调用\",{\"1\":{\"406\":1}}],[\"就是一个指令序列\",{\"1\":{\"131\":1}}],[\"就是因为加载的是rt\",{\"1\":{\"346\":1}}],[\"就是请求方调用了你的服务\",{\"1\":{\"313\":1}}],[\"就是我在学习一个知识时必须要知道底层原理\",{\"1\":{\"302\":1}}],[\"就是每天早上6点启动定时任务\",{\"1\":{\"296\":1}}],[\"就是什么意思呢\",{\"1\":{\"296\":1}}],[\"就是平时在学习的时候喜欢捣鼓一些东西\",{\"1\":{\"293\":1}}],[\"就是尽可能地保持压缩列表节省内存的优势\",{\"1\":{\"281\":1}}],[\"就是它被设计成一种内存紧凑型的数据结构\",{\"1\":{\"278\":1}}],[\"就是在有竞争时\",{\"1\":{\"234\":1}}],[\"就是页框号\",{\"1\":{\"156\":1}}],[\"就是内部碎片\",{\"1\":{\"154\":1}}],[\"就是为用户进程分配的必须是一个连续的内存空间\",{\"1\":{\"154\":1}}],[\"就是决定将哪个处于挂起状态的进程重新调入内存\",{\"1\":{\"153\":1}}],[\"就是指系统按照这种序列分配资源\",{\"1\":{\"149\":1}}],[\"就是服务时间最短\",{\"1\":{\"139\":1}}],[\"就是撤销进程实体中的pcb\",{\"1\":{\"131\":1}}],[\"就是让cpu能够识别\",{\"1\":{\"128\":1}}],[\"就是当一个类构造器需要传入很多参数时\",{\"1\":{\"52\":1}}],[\"就返回这个方法的值\",{\"1\":{\"104\":1}}],[\"就会生成订单并保存到tb\",{\"1\":{\"992\":1}}],[\"就会产生类似多线程数据安全问题\",{\"1\":{\"981\":1}}],[\"就会产生将stu1对象中name属性值改为\",{\"1\":{\"89\":1}}],[\"就会将相关的\",{\"1\":{\"887\":1}}],[\"就会将monitor的所有者owner置为thread\",{\"1\":{\"211\":1}}],[\"就会造成半包\",{\"1\":{\"751\":1}}],[\"就会开始大量清理过期key\",{\"1\":{\"437\":1}}],[\"就会发现epoll的效率大大高于select\",{\"1\":{\"410\":1}}],[\"就会发生缓冲区溢出将可能会造成程序运行终止\",{\"1\":{\"276\":1}}],[\"就会在更大一级的空间加上意向排他锁\",{\"1\":{\"400\":1}}],[\"就会在更大一级的空间加上意向共享锁\",{\"1\":{\"400\":1}}],[\"就会使用到selector\",{\"1\":{\"332\":1}}],[\"就会重新散列到其他位置\",{\"1\":{\"318\":1}}],[\"就会导致空指针异常\",{\"1\":{\"887\":1}}],[\"就会导致数据的丢失\",{\"1\":{\"396\":1}}],[\"就会导致压缩列表占用的内存空间要多次重新分配\",{\"1\":{\"281\":1}}],[\"就会导致缓冲区溢出\",{\"1\":{\"276\":1}}],[\"就会直接使用\",{\"1\":{\"277\":1}}],[\"就会自动将\",{\"1\":{\"277\":1}}],[\"就会停止遍历\",{\"1\":{\"276\":1}}],[\"就会进入entrylist\",{\"1\":{\"211\":1}}],[\"就会一直驻留在内存中\",{\"1\":{\"161\":1}}],[\"就会饥饿\",{\"1\":{\"139\":1}}],[\"就会对整个继承体系造成破坏\",{\"1\":{\"108\":1}}],[\"就会对该对象耦合严重\",{\"1\":{\"60\":1}}],[\"就变成此对象的客户\",{\"1\":{\"63\":1}}],[\"就像自行车\",{\"1\":{\"974\":1}}],[\"就像多米诺牌的效应一样\",{\"1\":{\"280\":1}}],[\"就像runnable\",{\"1\":{\"245\":1}}],[\"就像\",{\"1\":{\"37\":1}}],[\"就像是带着露水的清晨\",{\"1\":{\"37\":1}}],[\"就像将相同大小的作业本摞起来\",{\"1\":{\"23\":1}}],[\"聆听寂静\",{\"1\":{\"37\":1}}],[\"是redis中最简单的存储类型\",{\"1\":{\"1025\":1}}],[\"是redis的哨兵启动脚本\",{\"1\":{\"1012\":1}}],[\"是redis的服务端启动脚本\",{\"1\":{\"1012\":1}}],[\"是redis提供的命令行客户端\",{\"1\":{\"1012\":1}}],[\"是rest风格的控制器\",{\"1\":{\"731\":1}}],[\"是相对于传统关系型数据库而言\",{\"1\":{\"1003\":1}}],[\"是可以实现互斥的\",{\"1\":{\"999\":1}}],[\"是预估值\",{\"1\":{\"996\":1}}],[\"是操作前读取的内存值\",{\"1\":{\"996\":1}}],[\"是操作系统最基本\",{\"1\":{\"128\":1}}],[\"是阻塞方法\",{\"1\":{\"993\":1}}],[\"是完全由elasticsearch管理的\",{\"1\":{\"927\":1}}],[\"是完全异步\",{\"1\":{\"705\":1}}],[\"是无连接的\",{\"1\":{\"898\":1}}],[\"是普通文件\",{\"1\":{\"873\":1}}],[\"是目录\",{\"1\":{\"873\":1}}],[\"是目前应用较广泛的一种存储管理方式\",{\"1\":{\"413\":1}}],[\"是工具类\",{\"1\":{\"871\":1}}],[\"是因为\",{\"1\":{\"865\":1}}],[\"是非线程安全的\",{\"1\":{\"856\":1}}],[\"是把未读完的部分向前压缩\",{\"1\":{\"848\":1}}],[\"是写入位置\",{\"1\":{\"848\":1}}],[\"是全双工的\",{\"1\":{\"845\":1}}],[\"是全局唯一性的呢\",{\"1\":{\"439\":1}}],[\"是接下来添加的处理器都是给\",{\"1\":{\"834\":1}}],[\"是对字节数据的封装\",{\"1\":{\"817\":1}}],[\"是从原始\",{\"1\":{\"826\":1}}],[\"是从尾部开始查找\",{\"1\":{\"816\":1}}],[\"是从当前节点找上一个出站处理器\",{\"1\":{\"816\":1}}],[\"是按照\",{\"1\":{\"816\":2}}],[\"是原材料\",{\"1\":{\"816\":1}}],[\"是车间中的流水线\",{\"1\":{\"816\":1}}],[\"是让非\",{\"1\":{\"792\":1}}],[\"是登录\",{\"1\":{\"769\":1}}],[\"是中文一句著名的无标点符号句子\",{\"1\":{\"766\":1}}],[\"是最大段长度\",{\"1\":{\"751\":1}}],[\"是最终要引用的对象\",{\"1\":{\"92\":1}}],[\"是流式协议\",{\"1\":{\"751\":1}}],[\"是将请求参数绑定到控制器的方法参数上\",{\"1\":{\"737\":1}}],[\"是我们存在于时间之内\",{\"1\":{\"731\":1}}],[\"是使用\",{\"1\":{\"721\":1}}],[\"是beanfactory的子接口\",{\"1\":{\"707\":1}}],[\"是ioc的顶层接口\",{\"1\":{\"707\":1}}],[\"是基础类型的ioc容器\",{\"1\":{\"707\":1}}],[\"是其对应对象\",{\"1\":{\"695\":1}}],[\"是其子类\",{\"1\":{\"107\":1}}],[\"是特殊类型\",{\"1\":{\"695\":1}}],[\"是后者被\",{\"1\":{\"661\":1}}],[\"是利用了自动配置类来简化了\",{\"1\":{\"659\":1}}],[\"是这么实现的\",{\"1\":{\"617\":1}}],[\"是返回值处理器解析的\",{\"1\":{\"604\":1}}],[\"是在redis基础上实现了分布式的可伸缩的java数据结构\",{\"1\":{\"1031\":1}}],[\"是在读取时\",{\"1\":{\"854\":1}}],[\"是在第一次被访问时执行初始化\",{\"1\":{\"561\":1}}],[\"是在查询结果返回集以后对查询结果进行过滤的操作\",{\"1\":{\"394\":1}}],[\"是反射调用\",{\"1\":{\"523\":1}}],[\"是多态调用\",{\"1\":{\"516\":1}}],[\"是什么\",{\"0\":{\"839\":1},\"1\":{\"454\":1}}],[\"是什么意思\",{\"1\":{\"151\":1}}],[\"是正整数\",{\"1\":{\"440\":1}}],[\"是内存单元真正的地址\",{\"1\":{\"414\":1}}],[\"是物理单位\",{\"1\":{\"413\":1}}],[\"是计算机科学中的一个术语\",{\"1\":{\"407\":1}}],[\"是当事务回滚时能够撤销所有已经成功执行的sql语句\",{\"1\":{\"396\":1}}],[\"是mysql\",{\"1\":{\"385\":1}}],[\"是不同的接口\",{\"1\":{\"531\":1}}],[\"是不反射调用\",{\"1\":{\"523\":1}}],[\"是不保证数据零丢失的\",{\"1\":{\"433\":1}}],[\"是不可能将全部几个g的索引都加载进内存的\",{\"1\":{\"376\":1}}],[\"是不会加载静态内部类的\",{\"1\":{\"101\":1}}],[\"是同步非阻塞的\",{\"1\":{\"332\":1}}],[\"是华为的企业价值观之一\",{\"1\":{\"305\":1}}],[\"是南京邮电大学物联网学院的一名研二的学生\",{\"1\":{\"293\":1}}],[\"是如何根据数据的大小和类型来进行不同的空间大小分配\",{\"1\":{\"279\":1}}],[\"是如何解决的\",{\"1\":{\"276\":1}}],[\"是则说明字符串结束了\",{\"1\":{\"276\":1}}],[\"是用\",{\"1\":{\"275\":1}}],[\"是用软件的方式模拟脱机技术\",{\"1\":{\"184\":1}}],[\"是必须的\",{\"1\":{\"268\":1}}],[\"是保证当线程由于页缺失故障\",{\"1\":{\"246\":1}}],[\"是保证编译器优化的时候不会让指令乱序\",{\"1\":{\"229\":1}}],[\"是executor\",{\"1\":{\"244\":1}}],[\"是线程安全的\",{\"1\":{\"230\":1}}],[\"是转动一圈需要的时间\",{\"1\":{\"176\":1}}],[\"是为了在操作失败时\",{\"1\":{\"996\":1}}],[\"是为了能灵活保存不同大小的字符串\",{\"1\":{\"277\":1}}],[\"是为了进一步优化读性能\",{\"1\":{\"260\":1}}],[\"是为了解决让权等待问题\",{\"1\":{\"143\":1}}],[\"是为了使程序的扩展性好\",{\"1\":{\"107\":1}}],[\"是一组\",{\"1\":{\"796\":1}}],[\"是一个基于内存的键值型nosql数据库\",{\"1\":{\"1009\":1}}],[\"是一个非常重要的事情\",{\"1\":{\"998\":1}}],[\"是一个异步的\",{\"1\":{\"839\":1}}],[\"是一个工具类\",{\"1\":{\"830\":1}}],[\"是一个组合的\",{\"1\":{\"829\":1}}],[\"是一个产品的加工车间\",{\"1\":{\"816\":1}}],[\"是一个\",{\"1\":{\"793\":1}}],[\"是一个用于表述指向文件的引用的抽象化概念\",{\"1\":{\"407\":1}}],[\"是一个叫做\",{\"1\":{\"272\":1}}],[\"是一个抽象类\",{\"1\":{\"251\":1}}],[\"是一段特殊的程序段\",{\"1\":{\"143\":1}}],[\"是一种在分布式系统下用来生成全局唯一id的工具\",{\"1\":{\"992\":1}}],[\"是一种在存储引擎层使用索引过滤数据的一种优化方式\",{\"1\":{\"385\":1}}],[\"是一种读写分离的并发策略\",{\"1\":{\"248\":1}}],[\"是一种高级通信的方式\",{\"1\":{\"134\":1}}],[\"是一种低级通信方式\",{\"1\":{\"134\":1}}],[\"是一种为访问类提供一个创建一组相关或相互依赖对象的接口\",{\"1\":{\"72\":1}}],[\"是双标志先检查法的改良版本\",{\"1\":{\"141\":1}}],[\"是进程最基本的特征\",{\"1\":{\"131\":1}}],[\"是进程实体的运行过程\",{\"1\":{\"131\":1}}],[\"是动态的产生\",{\"1\":{\"131\":1}}],[\"是系统进行资源分配和调度的一个独立单位\",{\"1\":{\"131\":1}}],[\"是系统的管理者\",{\"1\":{\"128\":1}}],[\"是模板方法的组成部分\",{\"1\":{\"119\":1}}],[\"是实现算法各个步骤的方法\",{\"1\":{\"119\":1}}],[\"是指redis中存储的数据都是以key\",{\"1\":{\"1001\":1}}],[\"是指事务\",{\"1\":{\"393\":1}}],[\"是指控制和管理整个计算机系统的硬件和软件资源\",{\"1\":{\"125\":1}}],[\"是指\",{\"1\":{\"111\":1,\"449\":1}}],[\"是开源项目中比较常用的一种单例模式\",{\"1\":{\"101\":1}}],[\"是\",{\"1\":{\"99\":1,\"249\":1,\"446\":1,\"451\":1,\"561\":2,\"688\":4,\"695\":1,\"705\":1,\"731\":1,\"751\":3,\"793\":2,\"799\":1,\"816\":1,\"823\":2,\"890\":2}}],[\"是代理对象所代表的真实对象\",{\"1\":{\"92\":1}}],[\"是spring\",{\"1\":{\"737\":2}}],[\"是sql92定义的标准统计行数的语法\",{\"1\":{\"267\":1}}],[\"是streamdecoder的设计实现在实际上采用了适配器模式\",{\"1\":{\"44\":1}}],[\"是sun\",{\"1\":{\"44\":1}}],[\"是欧洲标准\",{\"1\":{\"39\":1}}],[\"是她最美的年华\",{\"1\":{\"37\":1}}],[\"是否可以为null等等\",{\"1\":{\"1001\":1}}],[\"是否可抢占式\",{\"1\":{\"139\":1}}],[\"是否可抢占\",{\"1\":{\"139\":5}}],[\"是否一致\",{\"1\":{\"967\":1}}],[\"是否被索引等等\",{\"1\":{\"926\":1}}],[\"是否开启\",{\"1\":{\"898\":1}}],[\"是否能读写根据构造\",{\"1\":{\"863\":1}}],[\"是否要继续循环\",{\"1\":{\"794\":1}}],[\"是否存在于容器\",{\"1\":{\"672\":1}}],[\"是否生效\",{\"1\":{\"660\":1}}],[\"是否保证线程安全\",{\"1\":{\"322\":1}}],[\"是否对\",{\"1\":{\"236\":1}}],[\"是否相等\",{\"1\":{\"167\":1}}],[\"是否已分配\",{\"1\":{\"154\":1}}],[\"是否会多扣一笔呢\",{\"1\":{\"313\":1}}],[\"是否会多扣一次\",{\"1\":{\"313\":1}}],[\"是否会导致饥饿\",{\"1\":{\"139\":6}}],[\"是否会发生从一个事件到另一个事件转换的时候出现中断\",{\"1\":{\"133\":1}}],[\"是否原谅我\",{\"1\":{\"37\":1}}],[\"是否后悔当初我们牵手\",{\"1\":{\"37\":1}}],[\"恋人\",{\"1\":{\"37\":1}}],[\"生命周期阶段\",{\"1\":{\"470\":1}}],[\"生命周期各个阶段\",{\"1\":{\"461\":1}}],[\"生命周期\",{\"0\":{\"459\":1}}],[\"生命周期中还有一类\",{\"1\":{\"458\":1}}],[\"生命周期主要阶段有\",{\"1\":{\"458\":1}}],[\"生命周期已经结束\",{\"1\":{\"208\":1}}],[\"生命的热忱\",{\"1\":{\"37\":1}}],[\"生产环境不要设置为0\",{\"1\":{\"1015\":1}}],[\"生产数据并发布\",{\"1\":{\"743\":1,\"744\":1}}],[\"生产者仅负责产生结果数据\",{\"1\":{\"218\":1}}],[\"生产者消费者模式\",{\"0\":{\"218\":1},\"1\":{\"217\":1}}],[\"生产\",{\"0\":{\"79\":1}}],[\"生产一个产品族的产品\",{\"1\":{\"55\":1}}],[\"生产自行车是一个复杂的过程\",{\"1\":{\"49\":1}}],[\"生活中这样的例子很多\",{\"1\":{\"39\":1}}],[\"生成序列号\",{\"1\":{\"993\":1}}],[\"生成时间戳\",{\"1\":{\"993\":1}}],[\"生成验证码\",{\"1\":{\"960\":1}}],[\"生成就快\",{\"1\":{\"745\":1}}],[\"生成处理器对象以及处理器拦截器\",{\"1\":{\"736\":1}}],[\"生成的代理类实现相同接口\",{\"1\":{\"511\":1}}],[\"生成的是一个无序的字符串\",{\"1\":{\"439\":1}}],[\"生成代理\",{\"1\":{\"500\":1}}],[\"生成\",{\"1\":{\"480\":1,\"682\":1}}],[\"生成50个id\",{\"1\":{\"441\":1}}],[\"生成http请求信息\",{\"1\":{\"198\":1}}],[\"生成随机数的类\",{\"1\":{\"82\":1}}],[\"生成不同操作系统的程序\",{\"1\":{\"76\":1}}],[\"生成器采用u\",{\"1\":{\"16\":1}}],[\"生成对抗网络之父\",{\"1\":{\"10\":1}}],[\"生成对抗网络gan开山之作\",{\"0\":{\"10\":1}}],[\"生成对抗神经网络gan开山之作论文\",{\"1\":{\"10\":1}}],[\"付出\",{\"1\":{\"37\":1}}],[\"灵魂\",{\"1\":{\"37\":1}}],[\"爱人\",{\"1\":{\"37\":1}}],[\"漫无目的地\",{\"1\":{\"37\":1}}],[\"曾经放开的手\",{\"1\":{\"37\":1}}],[\"陪你到最后\",{\"1\":{\"37\":1}}],[\"不指定commond时\",{\"1\":{\"1018\":1}}],[\"不记录日志\",{\"1\":{\"1015\":1}}],[\"不够优雅\",{\"1\":{\"1005\":1}}],[\"不足则无法下单\",{\"1\":{\"995\":1}}],[\"不查询数据库\",{\"1\":{\"989\":1}}],[\"不一致\",{\"1\":{\"960\":1,\"968\":1}}],[\"不一定需要采取内存保护\",{\"1\":{\"154\":1}}],[\"不一定能做到真正的短作业优先\",{\"1\":{\"139\":1}}],[\"不分词\",{\"1\":{\"950\":1}}],[\"不利用\",{\"1\":{\"905\":1}}],[\"不受gc影响\",{\"1\":{\"851\":1}}],[\"不受影响\",{\"1\":{\"826\":1}}],[\"不返回\",{\"1\":{\"833\":1}}],[\"不做处理\",{\"1\":{\"825\":1}}],[\"不必再执行\",{\"1\":{\"792\":1}}],[\"不断发起这样的请求\",{\"1\":{\"985\":1}}],[\"不断看有没有新任务\",{\"1\":{\"791\":1}}],[\"不断地轮询所负责的所有socket\",{\"1\":{\"409\":1}}],[\"不用\",{\"1\":{\"776\":1}}],[\"不用维护多个线程\",{\"1\":{\"332\":1}}],[\"不保存状态时\",{\"1\":{\"771\":1}}],[\"不得不冗余的将这两个商品保存在张三的订单文档中\",{\"1\":{\"1005\":1}}],[\"不得束修金\",{\"1\":{\"766\":1}}],[\"不得使用外键与级联\",{\"1\":{\"267\":1}}],[\"不满足则不管理\",{\"1\":{\"672\":1}}],[\"不满足让权等待\",{\"1\":{\"142\":2,\"143\":1}}],[\"不为null且存在\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"990\":1}}],[\"不为\",{\"1\":{\"644\":1}}],[\"不走第\",{\"1\":{\"644\":1}}],[\"不增强\",{\"1\":{\"527\":3}}],[\"不依赖第三方库或者中间件\",{\"1\":{\"442\":1}}],[\"不在线\",{\"1\":{\"760\":1}}],[\"不在同一毫秒内\",{\"1\":{\"441\":1}}],[\"不在索引列上做任何操作\",{\"1\":{\"395\":1}}],[\"不处理边界的问题⚠️\",{\"0\":{\"889\":1}}],[\"不处理\",{\"1\":{\"429\":1}}],[\"不论使快表还是多级页表实际上都利用到了程序的局部性原理\",{\"1\":{\"413\":1}}],[\"不包含记录本身\",{\"1\":{\"401\":1}}],[\"不这么做的话\",{\"1\":{\"400\":1}}],[\"不兼容\",{\"1\":{\"398\":3,\"400\":3}}],[\"不采用数据库本身的锁机制\",{\"1\":{\"397\":1}}],[\"不建议使用无序的值作为索引\",{\"1\":{\"384\":1}}],[\"不到万不得已不要使用\",{\"1\":{\"366\":1}}],[\"不规整\",{\"1\":{\"352\":1}}],[\"不调用任何构造器\",{\"1\":{\"351\":1}}],[\"不相同就通过拉链表解决冲突\",{\"1\":{\"327\":1}}],[\"不设置的情况下\",{\"1\":{\"323\":1}}],[\"不然就记不住\",{\"1\":{\"302\":1}}],[\"不存在则新建\",{\"1\":{\"967\":1}}],[\"不存在\",{\"1\":{\"960\":1,\"961\":1,\"968\":1,\"983\":1,\"985\":1,\"989\":1,\"990\":3,\"1025\":1}}],[\"不存在线程安全问题\",{\"1\":{\"352\":1}}],[\"不存在返回\",{\"1\":{\"282\":1}}],[\"不存在的梗图\",{\"1\":{\"11\":1}}],[\"不存在的花瓶\",{\"1\":{\"11\":1}}],[\"不存在的人脸\",{\"1\":{\"11\":1}}],[\"不管是string还是其他的数据类型\",{\"1\":{\"430\":1}}],[\"不管是上面那种实现方式\",{\"1\":{\"419\":1}}],[\"不管是不是自己的目标更新字段\",{\"1\":{\"268\":1}}],[\"不管这夜晚\",{\"1\":{\"37\":1}}],[\"不允许直接拿hashmap与hashtable作为查询结果集的输出\",{\"1\":{\"268\":1}}],[\"不推荐使用keys\",{\"1\":{\"1024\":1}}],[\"不推荐使用\",{\"1\":{\"268\":1,\"1014\":1}}],[\"不适合分布式\",{\"1\":{\"267\":1}}],[\"不适用于用户进程\",{\"1\":{\"142\":1}}],[\"不适用在多处理机\",{\"1\":{\"142\":1}}],[\"不要求目标实现接口\",{\"1\":{\"513\":1}}],[\"不要定义冗余或重复的索引\",{\"1\":{\"384\":1}}],[\"不要更新无改动的字段\",{\"1\":{\"268\":1}}],[\"不要写一个大而全的数据更新接口\",{\"1\":{\"268\":1}}],[\"不要使用\",{\"1\":{\"388\":1}}],[\"不要使用$\",{\"1\":{\"268\":1}}],[\"不要使用count\",{\"1\":{\"267\":1}}],[\"不要用resultclass当返回参数\",{\"1\":{\"268\":1}}],[\"不要以为唯一索引影响了insert速度\",{\"1\":{\"266\":1,\"383\":1}}],[\"不要对实现进行编程\",{\"1\":{\"109\":1}}],[\"不但节约数据库表空间\",{\"1\":{\"265\":1}}],[\"不是立刻写入磁盘\",{\"1\":{\"869\":1}}],[\"不是我们想象的\",{\"1\":{\"825\":1}}],[\"不是\",{\"1\":{\"799\":1}}],[\"不是读取数据\",{\"1\":{\"790\":1}}],[\"不是字符串\",{\"1\":{\"688\":1}}],[\"不是轮询的方式\",{\"1\":{\"410\":1}}],[\"不是完整收集整个java堆的垃圾收集\",{\"1\":{\"350\":1}}],[\"不是varchar超长字段\",{\"1\":{\"265\":1}}],[\"不是频繁修改的字段\",{\"1\":{\"265\":1}}],[\"不预先分配存储空间\",{\"1\":{\"265\":1}}],[\"不应该表示实体数量\",{\"1\":{\"265\":1}}],[\"不支持可重入\",{\"1\":{\"260\":1}}],[\"不支持条件变量\",{\"1\":{\"260\":1}}],[\"不支持随机访问\",{\"1\":{\"169\":1}}],[\"不总是处于繁忙状态\",{\"1\":{\"246\":1}}],[\"不接受新任务\",{\"1\":{\"241\":1}}],[\"不怕别的线程来修复共享变量\",{\"1\":{\"231\":1}}],[\"不关心数据该如何处理\",{\"1\":{\"218\":1}}],[\"不过这个前缀不是随便加的\",{\"1\":{\"1026\":1}}],[\"不过根据字符串的格式不同\",{\"1\":{\"1025\":1}}],[\"不过value的类型多种多样\",{\"1\":{\"1023\":1}}],[\"不过该仓库提供的是redisdesktopmanager的源码\",{\"1\":{\"1019\":1}}],[\"不过调用了\",{\"1\":{\"866\":1}}],[\"不过使用\",{\"1\":{\"731\":1}}],[\"不过\",{\"1\":{\"527\":1,\"712\":1,\"1041\":1}}],[\"不过需要容器这边主动调用\",{\"1\":{\"458\":1}}],[\"不过当索引列的重复值过多\",{\"1\":{\"381\":1}}],[\"不过join\",{\"1\":{\"217\":1}}],[\"不过操作系统会负责检测出死锁的产生\",{\"1\":{\"147\":1}}],[\"不加入monitor的阻塞队列entrylist中\",{\"1\":{\"212\":1}}],[\"不加synchronized的对象不会关联监视器\",{\"1\":{\"211\":1}}],[\"不遵从上述规则\",{\"1\":{\"211\":1}}],[\"不考虑第\",{\"1\":{\"195\":2}}],[\"不忙碌则将通道分配个进程\",{\"1\":{\"185\":1}}],[\"不忙碌则将控制器分配给进程\",{\"1\":{\"185\":1}}],[\"不忙碌则将设备分配给进程\",{\"1\":{\"185\":1}}],[\"不再赘述\",{\"1\":{\"905\":1}}],[\"不再需要经过cpu\",{\"1\":{\"181\":1}}],[\"不再指向原有对象地址\",{\"1\":{\"86\":1}}],[\"不久后该数据很可能再次被访问\",{\"1\":{\"161\":1}}],[\"不方便编程\",{\"1\":{\"185\":1}}],[\"不方便文件拓展\",{\"1\":{\"169\":1}}],[\"不方便实现信息的共享和保护\",{\"1\":{\"160\":1}}],[\"不方便增加新设备\",{\"1\":{\"148\":1}}],[\"不占存储空间\",{\"1\":{\"159\":1}}],[\"不常用的段放在覆盖区\",{\"1\":{\"153\":1}}],[\"不常用的段在需要时调入内存\",{\"1\":{\"153\":1}}],[\"不能改变\",{\"1\":{\"974\":1}}],[\"不能太大\",{\"1\":{\"891\":1}}],[\"不能被多个\",{\"1\":{\"891\":1}}],[\"不能被修改且必须有初始值\",{\"1\":{\"317\":1}}],[\"不能被修改的代码称为纯代码或可重入代码\",{\"1\":{\"159\":1}}],[\"不能置之不理\",{\"1\":{\"890\":1}}],[\"不能什么都不做\",{\"1\":{\"885\":1}}],[\"不能一次创建多级目录\",{\"1\":{\"872\":1}}],[\"不能直接打开\",{\"1\":{\"863\":1}}],[\"不能直接根据\",{\"1\":{\"695\":1}}],[\"不能区分成功失败\",{\"1\":{\"806\":1}}],[\"不能在这里善后\",{\"1\":{\"804\":1}}],[\"不能继承\",{\"1\":{\"771\":1}}],[\"不能用images来查询\",{\"1\":{\"950\":1}}],[\"不能用\",{\"1\":{\"686\":1}}],[\"不能写死在代理内部\",{\"1\":{\"516\":1}}],[\"不能对缓冲区超过limit的位置进行读写操作\",{\"1\":{\"332\":1}}],[\"不能保证高可用\",{\"1\":{\"432\":1}}],[\"不能保证原子性\",{\"1\":{\"228\":1}}],[\"不能保存过多的元素\",{\"1\":{\"278\":1}}],[\"不能保存像图片\",{\"1\":{\"276\":1}}],[\"不能修改\",{\"1\":{\"236\":1,\"244\":1}}],[\"不能感知到这种从a改为b又改回a的情况\",{\"1\":{\"233\":1}}],[\"不能解决指令交错的问题\",{\"1\":{\"228\":1}}],[\"不能全部装入内存\",{\"1\":{\"161\":1}}],[\"不能由其他进程强行夺走\",{\"1\":{\"147\":1}}],[\"不能去修改原有的代码\",{\"1\":{\"107\":1}}],[\"不剥夺条件\",{\"1\":{\"147\":1}}],[\"不可重复读和幻读的问题\",{\"1\":{\"393\":1}}],[\"不可能三角\",{\"1\":{\"359\":1}}],[\"不可能滞留在中间某个环节\",{\"1\":{\"226\":1}}],[\"不可点击等方式\",{\"1\":{\"315\":1}}],[\"不可变类\",{\"0\":{\"236\":1}}],[\"不可抢占条件\",{\"1\":{\"221\":1}}],[\"不可以大编号资源的进程逆向申请小编号的资源\",{\"1\":{\"148\":1}}],[\"不可中断\",{\"1\":{\"143\":1}}],[\"不可预知的速度向前推进\",{\"1\":{\"131\":1,\"140\":1}}],[\"不区分任务的紧急程度\",{\"1\":{\"139\":1}}],[\"不公平\",{\"1\":{\"139\":1}}],[\"不透明就是能看见\",{\"1\":{\"135\":1}}],[\"不同任务分别在不同的线程中执行\",{\"1\":{\"742\":1}}],[\"不同\",{\"1\":{\"705\":1}}],[\"不同互联网公司也有自己内部的实现方案\",{\"1\":{\"439\":1}}],[\"不同进程使用的虚拟地址彼此隔离\",{\"1\":{\"415\":1}}],[\"不同进程中的线程切换\",{\"1\":{\"135\":1}}],[\"不同i\",{\"1\":{\"409\":1}}],[\"不同在于concurrenthashmap有大数组和小数组\",{\"1\":{\"249\":1}}],[\"不同用户对各个文件的访问权限是不一样的\",{\"1\":{\"182\":1}}],[\"不同的版本\",{\"1\":{\"923\":1}}],[\"不同的链路设备的\",{\"1\":{\"751\":1}}],[\"不同的浏览器\",{\"1\":{\"710\":1}}],[\"不同的http\",{\"1\":{\"710\":1}}],[\"不同的数据库都有自己独立的\",{\"1\":{\"705\":1}}],[\"不同的字符串可能哈希出来的位置相同\",{\"1\":{\"273\":1}}],[\"不同的用户对各个文件有不同的访问权限\",{\"1\":{\"183\":1}}],[\"不同的i\",{\"1\":{\"182\":1}}],[\"不同的装配顺序也可以做出不同的对象\",{\"1\":{\"47\":1}}],[\"不同的构建器\",{\"1\":{\"47\":1}}],[\"不仅仅是sql\",{\"1\":{\"1003\":1}}],[\"不仅仅是乔布斯\",{\"1\":{\"306\":1}}],[\"不仅有\",{\"1\":{\"806\":1}}],[\"不仅可以利用\",{\"1\":{\"278\":1}}],[\"不仅可以保存文本数据\",{\"1\":{\"277\":1}}],[\"不仅可以保存字符串\",{\"1\":{\"277\":1}}],[\"不仅会为\",{\"1\":{\"277\":1}}],[\"不仅会消耗系统资源\",{\"1\":{\"240\":1}}],[\"不仅是进程之间可以并发\",{\"1\":{\"135\":1}}],[\"不仅要生产咖啡还要生产甜点\",{\"1\":{\"74\":1}}],[\"不会让线程吊死在一个\",{\"1\":{\"917\":1}}],[\"不会使用\",{\"1\":{\"904\":1,\"905\":4}}],[\"不会自动缓冲数据\",{\"1\":{\"900\":1}}],[\"不会自动销毁\",{\"1\":{\"496\":1}}],[\"不会阻塞\",{\"1\":{\"882\":1}}],[\"不会产生内存复制\",{\"1\":{\"829\":1}}],[\"不会产生外部碎片\",{\"1\":{\"160\":1}}],[\"不会抛异常\",{\"1\":{\"806\":1,\"813\":1}}],[\"不会匹配到\",{\"1\":{\"644\":1}}],[\"不会在初始化时收集映射信息\",{\"1\":{\"636\":1}}],[\"不会走\",{\"1\":{\"617\":1}}],[\"不会包含局部变量表\",{\"1\":{\"572\":1}}],[\"不会调用\",{\"1\":{\"506\":1}}],[\"不会再次相应应用程序并通知此事件\",{\"1\":{\"410\":1}}],[\"不会再转换为其他状态\",{\"1\":{\"208\":1}}],[\"不会随着fd数目的增加使得效率降低\",{\"1\":{\"410\":1}}],[\"不会保持线程阻塞\",{\"1\":{\"332\":1}}],[\"不会发生缓冲区溢出\",{\"1\":{\"277\":1}}],[\"不会发生死锁\",{\"1\":{\"185\":1}}],[\"不会统计此列为null值的行\",{\"1\":{\"267\":2}}],[\"不会存在后面的指令跑到前面的指令之前来执行\",{\"1\":{\"229\":1}}],[\"不会将读屏障之后的代码排在读屏障之前\",{\"1\":{\"227\":1}}],[\"不会将写屏障之前的代码排在写屏障之后\",{\"1\":{\"227\":1,\"237\":1}}],[\"不会将打断标记设置为true\",{\"1\":{\"206\":1}}],[\"不会有碎片问题\",{\"1\":{\"169\":2}}],[\"不会被换出内存\",{\"1\":{\"153\":1}}],[\"不会引起进程切换\",{\"1\":{\"135\":1}}],[\"不会\",{\"1\":{\"133\":1,\"139\":2}}],[\"不跟\",{\"1\":{\"111\":1}}],[\"不运行此中操作\",{\"1\":{\"104\":1}}],[\"不进入抢锁阶段\",{\"1\":{\"101\":2}}],[\"不需要像\",{\"1\":{\"831\":1}}],[\"不需要目标对象实例\",{\"1\":{\"512\":1}}],[\"不需要显示使用\",{\"1\":{\"400\":1}}],[\"不需要用\",{\"1\":{\"277\":1}}],[\"不需要产生结果和消费结果的线程一一对应\",{\"1\":{\"218\":1}}],[\"不需要再系统中存储\",{\"1\":{\"173\":1}}],[\"不需要返回值\",{\"1\":{\"142\":1}}],[\"不需要切换到核心态\",{\"1\":{\"135\":1}}],[\"不需要切换进程环境\",{\"1\":{\"135\":1}}],[\"不需要记忆复杂的指令\",{\"1\":{\"126\":1}}],[\"不需要实例化该类的对象\",{\"1\":{\"99\":1}}],[\"不需要修改其他的类\",{\"1\":{\"74\":1}}],[\"不需要修改工厂类的代码了\",{\"1\":{\"69\":1}}],[\"不属于gof的23种经典设计模式\",{\"1\":{\"60\":1}}],[\"等于容量\",{\"1\":{\"848\":1}}],[\"等都是无限等待的\",{\"1\":{\"775\":1}}],[\"等都是可使用的\",{\"1\":{\"443\":1}}],[\"等特殊类型\",{\"1\":{\"695\":1}}],[\"等工具实现\",{\"1\":{\"646\":1}}],[\"等设置选择\",{\"1\":{\"528\":1}}],[\"等注解中的参数名\",{\"1\":{\"568\":1}}],[\"等注解失效\",{\"1\":{\"491\":1}}],[\"等注解的解析属于核心容器\",{\"1\":{\"477\":1}}],[\"等注解的解析属于\",{\"1\":{\"470\":1}}],[\"等注解的解析都是\",{\"1\":{\"454\":1}}],[\"等注解\",{\"1\":{\"454\":1}}],[\"等到遍历的单词和上一个单词不同的话\",{\"1\":{\"291\":1}}],[\"等到操作共享变量的时候才加锁\",{\"1\":{\"221\":1}}],[\"等遇到字符为\",{\"1\":{\"276\":1}}],[\"等等\",{\"1\":{\"274\":1,\"454\":1,\"731\":1,\"996\":1}}],[\"等数据结构\",{\"1\":{\"272\":1}}],[\"等方法进行修改\",{\"1\":{\"244\":1}}],[\"等\",{\"1\":{\"236\":1,\"470\":1,\"561\":1,\"568\":1,\"657\":1,\"705\":2,\"707\":1,\"773\":1,\"791\":1}}],[\"等完成对共享变量的操作时再save到主内存\",{\"1\":{\"230\":1}}],[\"等读写完毕\",{\"1\":{\"208\":1}}],[\"等它重新具备运行条件并且内存有空闲\",{\"1\":{\"136\":1}}],[\"等待再次查询时\",{\"1\":{\"982\":1}}],[\"等待数据阶段\",{\"1\":{\"901\":1}}],[\"等待数据准备\",{\"1\":{\"409\":1}}],[\"等待结果\",{\"1\":{\"807\":1,\"808\":1,\"809\":1}}],[\"等待任务结束\",{\"1\":{\"806\":2}}],[\"等待后续操作\",{\"1\":{\"759\":1}}],[\"等待\",{\"1\":{\"751\":1,\"787\":1,\"811\":1}}],[\"等待图\",{\"1\":{\"403\":1}}],[\"等待线程满足某个计数\",{\"1\":{\"263\":1}}],[\"等待所有线程完成倒计时后再恢复运行\",{\"1\":{\"262\":1}}],[\"等待所释放后唤醒下一个排队的线程\",{\"1\":{\"253\":1}}],[\"等待占有锁的线程释放后被唤醒\",{\"1\":{\"254\":1}}],[\"等待i\",{\"1\":{\"181\":1}}],[\"等待当前访问临界资源的进程结束才可以访问\",{\"1\":{\"140\":1}}],[\"等待时间长的邮箱\",{\"1\":{\"139\":1}}],[\"等待时间相同时\",{\"1\":{\"139\":1}}],[\"等待时间为\",{\"1\":{\"138\":1}}],[\"等待时间就是进程建立以后等待被服务的时间之和\",{\"1\":{\"138\":1}}],[\"等待时间\",{\"1\":{\"138\":1,\"139\":1}}],[\"等待读进程将数据取走\",{\"1\":{\"134\":1}}],[\"等待读取磁盘\",{\"1\":{\"132\":1}}],[\"等待分配打印机\",{\"1\":{\"132\":1}}],[\"等待我们一生中\",{\"1\":{\"37\":2}}],[\"等侯寂寞\",{\"1\":{\"37\":1}}],[\"我放到了\",{\"1\":{\"1012\":1}}],[\"我最初在认识上有这样的误区\",{\"1\":{\"845\":1}}],[\"我这里直接将实现加入了枚举类\",{\"1\":{\"773\":1}}],[\"我不留\",{\"1\":{\"766\":1}}],[\"我相信一切都会过去\",{\"1\":{\"731\":1}}],[\"我从这学期每天都有运动\",{\"1\":{\"309\":1}}],[\"我会秉持华为艰苦奋斗的企业价值观努力工作\",{\"1\":{\"307\":1}}],[\"我是最近才喜欢上自传的\",{\"1\":{\"306\":1}}],[\"我记得没错的话\",{\"1\":{\"305\":1}}],[\"我目前有注意到这点\",{\"1\":{\"302\":1}}],[\"我觉得这不仅可以锻炼身体\",{\"1\":{\"309\":1}}],[\"我觉得这十分有趣\",{\"1\":{\"305\":1}}],[\"我觉得这是一个挺致命的缺点\",{\"1\":{\"302\":1}}],[\"我觉得我的一个缺点就是在学习知识的时候必要要有一个拓扑顺序\",{\"1\":{\"302\":1}}],[\"我觉得我最大的难点就是业务操作不熟练\",{\"1\":{\"297\":1}}],[\"我的课题是将目标检测用于垃圾分类\",{\"1\":{\"300\":1}}],[\"我的自我介绍结束了\",{\"1\":{\"293\":1}}],[\"我的真\",{\"1\":{\"37\":2}}],[\"我也是个很乐观的热\",{\"1\":{\"293\":1}}],[\"我对于知识也有着蛮强烈的好奇心\",{\"1\":{\"293\":1}}],[\"我叫赵和月\",{\"1\":{\"293\":1}}],[\"我用\",{\"1\":{\"277\":1}}],[\"我先直接说答案\",{\"1\":{\"277\":1}}],[\"我改完了解开锁\",{\"1\":{\"231\":1}}],[\"我上了锁你们都别想改\",{\"1\":{\"231\":1}}],[\"我们只采用string的序列化器\",{\"1\":{\"1042\":1}}],[\"我们只需要编写对应的controller即可\",{\"1\":{\"995\":1}}],[\"我们只需要调用一次countdown\",{\"1\":{\"993\":1}}],[\"我们只需要修改适配器类\",{\"1\":{\"42\":1}}],[\"我们只需再自定义一个方法使用\",{\"1\":{\"732\":1}}],[\"我们只需引入对应的starter\",{\"1\":{\"730\":1}}],[\"我们在获得连接时\",{\"1\":{\"1035\":1}}],[\"我们在加载当前工厂类的时候\",{\"1\":{\"1034\":1}}],[\"我们在返回前\",{\"1\":{\"962\":1}}],[\"我们该如何区分不同类型的key呢\",{\"1\":{\"1026\":1}}],[\"我们先将这个配置文件备份一份\",{\"1\":{\"1015\":1}}],[\"我们将服务启动两份\",{\"1\":{\"999\":1}}],[\"我们将网络通信部分隐藏起来\",{\"1\":{\"98\":1}}],[\"我们通常有两种解决方案\",{\"1\":{\"996\":1}}],[\"我们通过浏览器观察到此时用户的全部信息都在\",{\"1\":{\"962\":1}}],[\"我们通过案例来感受一下静态代理\",{\"1\":{\"93\":1}}],[\"我们应当给他一些过期时间\",{\"1\":{\"1024\":1}}],[\"我们应当去查询优惠卷信息\",{\"1\":{\"995\":1}}],[\"我们应当是先操作数据库\",{\"1\":{\"982\":1}}],[\"我们让分线程和变量绑定\",{\"1\":{\"993\":1}}],[\"我们担心分线程没有执行完时\",{\"1\":{\"993\":1}}],[\"我们要进行拆库拆表\",{\"1\":{\"992\":1}}],[\"我们采用第二个方案\",{\"1\":{\"989\":1}}],[\"我们把过期时间设置在\",{\"1\":{\"987\":1}}],[\"我们把session换成redis\",{\"1\":{\"963\":1}}],[\"我们之所以会出现这个缓存击穿问题\",{\"1\":{\"987\":1}}],[\"我们之前讲过需要满足两点\",{\"1\":{\"966\":1}}],[\"我们不会返回404\",{\"1\":{\"985\":1}}],[\"我们如果没有countdownlatch\",{\"1\":{\"993\":1}}],[\"我们如果发现命中之后\",{\"1\":{\"985\":1}}],[\"我们如果发现这个数据在mysql中不存在\",{\"1\":{\"985\":1}}],[\"我们如果让tomcat直接去访问mysql\",{\"1\":{\"955\":1}}],[\"我们也可以通过配置来实现开机自启\",{\"1\":{\"1016\":1}}],[\"我们也把这个数据存入到redis中去\",{\"1\":{\"984\":1}}],[\"我们也会加入redis\",{\"1\":{\"955\":1}}],[\"我们确定了采用删除策略\",{\"1\":{\"983\":1}}],[\"我们是直接操作从数据库中去进行查询的\",{\"1\":{\"977\":1}}],[\"我们是通过该类的main方法启动spring\",{\"1\":{\"728\":1}}],[\"我们能如何解决这个问题呢\",{\"1\":{\"963\":1}}],[\"我们能做的就是逐一加载每个磁盘页\",{\"1\":{\"376\":1}}],[\"我们仅仅只需要按照提示的逻辑写出代码即可\",{\"1\":{\"960\":1}}],[\"我们都知道数据库能够承载的并发不如redis这么高\",{\"1\":{\"984\":1}}],[\"我们都知道一台4核8g的tomcat\",{\"1\":{\"955\":1}}],[\"我们都需要\",{\"1\":{\"419\":1}}],[\"我们就不需要在内存中就不用多存储数据\",{\"1\":{\"1042\":1}}],[\"我们就可以操作redis\",{\"1\":{\"1017\":1}}],[\"我们就需要使用分布式锁来解决这个问题\",{\"1\":{\"999\":1}}],[\"我们就来看看\",{\"1\":{\"790\":1}}],[\"我们就只和工厂打交道就可以了\",{\"1\":{\"60\":1}}],[\"我们发送post请求到这个接口\",{\"1\":{\"731\":1}}],[\"我们有个注册的接口\",{\"1\":{\"731\":1}}],[\"我们知道\",{\"1\":{\"617\":1}}],[\"我们平时使用的配置类\",{\"1\":{\"454\":1}}],[\"我们课上讲的\",{\"1\":{\"446\":1}}],[\"我们假设\",{\"1\":{\"437\":1}}],[\"我们称之为碎片\",{\"1\":{\"413\":1}}],[\"我们还可以自己定义函数式接口完成相关操作\",{\"1\":{\"336\":1}}],[\"我们尽可能给arraylist一个初始长度\",{\"1\":{\"323\":1}}],[\"我们这样可以大大减少了equals的次数\",{\"1\":{\"318\":1}}],[\"我们大多数人其实都是普通人\",{\"1\":{\"305\":1}}],[\"我们无法直接将大文件的所有词一次性读到内存中\",{\"1\":{\"290\":1}}],[\"我们恰恰需要上一行的旧值\",{\"1\":{\"194\":1}}],[\"我们必须让\",{\"1\":{\"194\":1}}],[\"我们写的代码最终被翻译成cpu能够识别的指令\",{\"1\":{\"151\":1}}],[\"我们同时运行多个程序\",{\"1\":{\"127\":1}}],[\"我们试着将继承复用改为聚合复用看一下\",{\"1\":{\"112\":1}}],[\"我们需要获得原始的事务对象\",{\"1\":{\"998\":1}}],[\"我们需要慢慢的来思考\",{\"1\":{\"998\":1}}],[\"我们需要根据索引需要确定分片个数\",{\"1\":{\"928\":1}}],[\"我们需要了解布隆过滤器的概念\",{\"1\":{\"272\":1}}],[\"我们需要创建一个黑马品牌的安全门\",{\"1\":{\"110\":1}}],[\"我们需要使用接口和抽象类\",{\"1\":{\"107\":1}}],[\"我们需要调整加锁的时机\",{\"1\":{\"101\":1}}],[\"我们需要实现网络通信\",{\"1\":{\"98\":1}}],[\"我们可以自定义redistemplate的序列化方式\",{\"1\":{\"1041\":1}}],[\"我们可以这样定义key\",{\"1\":{\"1026\":1}}],[\"我们可以用下面这组命令来操作redis了\",{\"1\":{\"1016\":1}}],[\"我们可以不直接使用redis自增的数值\",{\"1\":{\"992\":1}}],[\"我们可以通过给key添加前缀加以区分\",{\"1\":{\"1026\":1}}],[\"我们可以通过true\",{\"1\":{\"988\":1}}],[\"我们可以通过xml配置或者注解来进行配置\",{\"1\":{\"709\":1}}],[\"我们可以采用手动序列化的方式\",{\"1\":{\"1042\":1}}],[\"我们可以采用逻辑过期方案\",{\"1\":{\"987\":1}}],[\"我们可以采用trylock方法\",{\"1\":{\"987\":1}}],[\"我们可以手动调用方法把缓存删掉\",{\"1\":{\"980\":1}}],[\"我们可以考虑使用string\",{\"1\":{\"965\":1}}],[\"我们可以把缓存删除\",{\"1\":{\"982\":1}}],[\"我们可以把\",{\"1\":{\"731\":1}}],[\"我们可以把它看作由二进制向量\",{\"1\":{\"272\":1}}],[\"我们可以使用工厂\",{\"1\":{\"1034\":1}}],[\"我们可以使用longaddr这个类去解决\",{\"1\":{\"997\":1}}],[\"我们可以使用threadlocal来做到线程隔离\",{\"1\":{\"961\":1}}],[\"我们可以使用isolation属性声明事物的隔离级别\",{\"1\":{\"721\":1}}],[\"我们可以使用版本号机制或时间戳机制来实现\",{\"1\":{\"397\":1}}],[\"我们可以得知\",{\"1\":{\"276\":1,\"961\":1}}],[\"我们可以得出\",{\"1\":{\"273\":1}}],[\"我们可以进行灵活处理\",{\"1\":{\"96\":1}}],[\"我们可以看到以下几个信息\",{\"1\":{\"94\":1}}],[\"我们再次使用cglib代理实现\",{\"1\":{\"95\":1}}],[\"我们去代售点买票就方便很多了\",{\"1\":{\"93\":1}}],[\"我们看通过类图看看结构\",{\"1\":{\"78\":1}}],[\"我们使用锁必须保证锁必须是同一把\",{\"1\":{\"998\":1}}],[\"我们使用不同的数据库访问框架\",{\"1\":{\"721\":1}}],[\"我们使用properties文件作为配置文件\",{\"1\":{\"77\":1}}],[\"我们使用对象适配器模式将读卡器的案例进行改写\",{\"1\":{\"42\":1}}],[\"我们势必要需求修改simplecoffeefactory的代码\",{\"1\":{\"63\":1}}],[\"我们明确地计划不同条件下创建不同实例时\",{\"1\":{\"58\":1}}],[\"我们举个简单例子来说明两者的差异\",{\"1\":{\"54\":1}}],[\"我愿和她\",{\"1\":{\"37\":1}}],[\"我愿为她\",{\"1\":{\"37\":2}}],[\"我一往情深的\",{\"1\":{\"37\":1}}],[\"我一往情深的恋人\",{\"1\":{\"37\":3}}],[\"我心疼的爱人\",{\"1\":{\"37\":1}}],[\"我心疼的\",{\"1\":{\"37\":1}}],[\"我多想给她\",{\"1\":{\"37\":2}}],[\"我多想给她我的真\",{\"1\":{\"37\":1}}],[\"我在和她相遇以前\",{\"1\":{\"37\":1}}],[\"我单纯的爱人\",{\"1\":{\"37\":1}}],[\"她说与我相爱以后\",{\"1\":{\"37\":1}}],[\"她向我\",{\"1\":{\"37\":1}}],[\"她给我的爱\",{\"1\":{\"37\":1}}],[\"她是我的爱人\",{\"1\":{\"37\":3}}],[\"一人一单逻辑\",{\"1\":{\"998\":1}}],[\"一人一单\",{\"0\":{\"998\":1}}],[\"一句话\",{\"1\":{\"975\":1}}],[\"一致\",{\"1\":{\"960\":1,\"968\":1}}],[\"一致性的实现也需要在应用层面进行保障\",{\"1\":{\"396\":1}}],[\"一致性是事务追求的最终目标\",{\"1\":{\"396\":1}}],[\"一致性是指事务将数据库从一种状态转变为另一种一致的状态\",{\"1\":{\"396\":1}}],[\"一致性实现原理\",{\"1\":{\"396\":1}}],[\"一致性\",{\"1\":{\"396\":1}}],[\"一开始\",{\"1\":{\"848\":1}}],[\"一开始需要树立正确的观念\",{\"1\":{\"837\":1}}],[\"一样切换读写模式\",{\"1\":{\"831\":1}}],[\"一直向前传\",{\"1\":{\"825\":1}}],[\"一直持续到结尾\",{\"1\":{\"280\":1}}],[\"一条线是继承自\",{\"1\":{\"796\":1}}],[\"一条指令在执行期间\",{\"1\":{\"162\":1}}],[\"一位私塾先生到一家任教\",{\"1\":{\"766\":1}}],[\"一并返回给dispatcherservlet\",{\"1\":{\"736\":1}}],[\"一方面\",{\"1\":{\"716\":1}}],[\"一不留神就会用错\",{\"1\":{\"678\":1}}],[\"一部分是低级的\",{\"1\":{\"539\":1}}],[\"一部分为用户空间\",{\"1\":{\"406\":1}}],[\"一部分为内核空间\",{\"1\":{\"406\":1}}],[\"一定要用\",{\"1\":{\"506\":1}}],[\"一定要保证这笔订单是已支付的状态\",{\"1\":{\"315\":1}}],[\"一定容量的内存和外存\",{\"1\":{\"419\":1}}],[\"一级页表\",{\"1\":{\"413\":1}}],[\"一些检查\",{\"1\":{\"790\":1,\"793\":1}}],[\"一些资料会提到\",{\"1\":{\"458\":1}}],[\"一些涉及底层的程序编写往往会围绕着文件描述符展开\",{\"1\":{\"407\":1}}],[\"一些提供close的资源未关闭导致内存泄漏\",{\"1\":{\"358\":1}}],[\"一款优秀的收集器通常最多同时满足其中的两项\",{\"1\":{\"359\":1}}],[\"一种思路是首先分配一个较小的\",{\"1\":{\"891\":1}}],[\"一种思路是固定消息长度\",{\"1\":{\"890\":1}}],[\"一种解读\",{\"1\":{\"766\":1}}],[\"一种在类加载阶段实现\",{\"1\":{\"714\":1}}],[\"一种在编译阶段实现\",{\"1\":{\"714\":1}}],[\"一种是整堆收集\",{\"1\":{\"350\":1}}],[\"一种是部分收集\",{\"1\":{\"350\":1}}],[\"一种资源只能被一个线程所使用\",{\"1\":{\"221\":1}}],[\"一共设计了\",{\"1\":{\"277\":2}}],[\"一共9个anchor\",{\"1\":{\"24\":1}}],[\"一是易出错\",{\"1\":{\"268\":1}}],[\"一律不要使用\",{\"1\":{\"268\":1}}],[\"一切外键概念必须在应用层解决\",{\"1\":{\"267\":1}}],[\"一下都是基于jdk\",{\"1\":{\"249\":1}}],[\"一段时间申请不到锁的权限了\",{\"1\":{\"221\":1}}],[\"一起使用\",{\"1\":{\"219\":1,\"771\":1,\"773\":1,\"881\":1}}],[\"一次减少2个\",{\"1\":{\"1025\":1}}],[\"一次增加2\",{\"1\":{\"1025\":1}}],[\"一次无法写完例子\",{\"0\":{\"893\":1}}],[\"一次只能穿2g\",{\"1\":{\"870\":1}}],[\"一次事件会触发一次\",{\"1\":{\"794\":1}}],[\"一次事件内会触发多次\",{\"1\":{\"794\":1}}],[\"一次性读入内存中的需要查找的关键字也就越多\",{\"1\":{\"378\":1}}],[\"一次磁盘读\",{\"1\":{\"176\":1}}],[\"一次调入若干个相邻的页面可能比一次调入一个页面更加高效\",{\"1\":{\"164\":1}}],[\"一份\",{\"1\":{\"172\":1}}],[\"一台手机有4gb内存\",{\"1\":{\"151\":1}}],[\"一前一后\",{\"1\":{\"144\":1}}],[\"一对原语\",{\"1\":{\"143\":1}}],[\"一对一模型\",{\"1\":{\"135\":1}}],[\"一般要满足下列特性\",{\"1\":{\"992\":1}}],[\"一般从数据库中获取\",{\"1\":{\"974\":1}}],[\"一般需要将\",{\"1\":{\"825\":1}}],[\"一般情况下\",{\"1\":{\"825\":1}}],[\"一般情况下抽象的变化概率很小\",{\"1\":{\"109\":1}}],[\"一般会调用\",{\"1\":{\"796\":1}}],[\"一般为\",{\"1\":{\"751\":1,\"794\":1}}],[\"一般为10g\",{\"1\":{\"433\":1}}],[\"一般使用prehandle方法\",{\"1\":{\"738\":1}}],[\"一般使用自增的方式\",{\"1\":{\"439\":1}}],[\"一般用来声明配置类\",{\"1\":{\"731\":1}}],[\"一般用于需要计数的场景\",{\"1\":{\"422\":1}}],[\"一般用于连接数较多且连接时长较长的应用\",{\"1\":{\"333\":1}}],[\"一般可以使用服务上线时间作为初始时间戳值\",{\"1\":{\"443\":1}}],[\"一般不使用\",{\"1\":{\"432\":1}}],[\"一般不适用\",{\"1\":{\"244\":1}}],[\"一般作为衡量其他置换算法的方法\",{\"1\":{\"420\":1}}],[\"一般来说这个数目和系统内存关系很大\",{\"1\":{\"410\":1}}],[\"一般是16或32\",{\"1\":{\"955\":1}}],[\"一般是读就绪或者写就绪\",{\"1\":{\"410\":1}}],[\"一般是数字\",{\"1\":{\"268\":1}}],[\"一般都设置成为non\",{\"1\":{\"409\":1}}],[\"一般都可以使用分布查询来解决\",{\"1\":{\"366\":1}}],[\"一般表的逐渐类型为int\",{\"1\":{\"377\":1}}],[\"一般放在请求头上\",{\"1\":{\"315\":1}}],[\"一般对字符串类型数据\",{\"1\":{\"266\":1,\"383\":1}}],[\"一般几十毫秒一次\",{\"1\":{\"136\":1}}],[\"一般模板方法都加上\",{\"1\":{\"120\":1}}],[\"一般钩子方法是用于判断的逻辑方法\",{\"1\":{\"119\":1}}],[\"一般产品类和建造者类是比较稳定的\",{\"1\":{\"50\":1}}],[\"一旦我们向redis采用这样的方式存储\",{\"1\":{\"1026\":1}}],[\"一旦复制了\",{\"1\":{\"928\":1}}],[\"一旦\",{\"1\":{\"878\":1}}],[\"一旦超时会退出\",{\"1\":{\"791\":1}}],[\"一旦基于某个文件扫描符就绪时\",{\"1\":{\"410\":1}}],[\"一旦该fd就绪\",{\"1\":{\"410\":1}}],[\"一旦某个描述符就绪\",{\"1\":{\"410\":1}}],[\"一旦kernel中的数据准备好了\",{\"1\":{\"409\":1}}],[\"一旦队列中添加了一个元素\",{\"1\":{\"254\":1}}],[\"一旦程序访问了某个存储单元\",{\"1\":{\"161\":1,\"417\":1}}],[\"一旦作业被装入内存\",{\"1\":{\"161\":1}}],[\"一旦初始化完成就不存在了\",{\"1\":{\"101\":1}}],[\"一旦有了simplecoffeefactory\",{\"1\":{\"63\":1}}],[\"一整套一起换\",{\"1\":{\"76\":1}}],[\"一个人可以无限制的抢这个优惠卷\",{\"1\":{\"998\":1}}],[\"一个字符不同也能匹配成功\",{\"1\":{\"943\":1}}],[\"一个具有10亿文档数据的索引占据1tb的磁盘空间\",{\"1\":{\"927\":1}}],[\"一个具体方法由一个抽象类或具体类声明并实现\",{\"1\":{\"119\":1}}],[\"一个文档是一个可被索引的基础信息单元\",{\"1\":{\"924\":1}}],[\"一个索引也可以被复制0次\",{\"1\":{\"928\":1}}],[\"一个索引可以存储超出单个节点硬件限制的大量数据\",{\"1\":{\"927\":1}}],[\"一个索引由一个名字来标识\",{\"1\":{\"922\":1}}],[\"一个索引就是一个拥有几分相似特征的文档的集合\",{\"1\":{\"922\":1}}],[\"一个索引表项4b\",{\"1\":{\"169\":1}}],[\"一个数组不够\",{\"1\":{\"891\":1}}],[\"一个线程配合\",{\"1\":{\"879\":1}}],[\"一个线程\",{\"1\":{\"876\":2,\"901\":1}}],[\"一个线程对应一个selector\",{\"1\":{\"332\":1}}],[\"一个线程对volatile变量的修改对另一个线程可见\",{\"1\":{\"228\":1}}],[\"一个线程对共享变量值的修改\",{\"1\":{\"226\":1}}],[\"一个病人看完了\",{\"1\":{\"805\":1}}],[\"一个学年段亦告结束\",{\"1\":{\"766\":1}}],[\"一个请求方法只可以有一个\",{\"1\":{\"731\":1}}],[\"一个错误处理搞得这么复杂\",{\"1\":{\"617\":1}}],[\"一个受\",{\"1\":{\"458\":1}}],[\"一个表中的主键\",{\"1\":{\"439\":1}}],[\"一个用于节点间通信\",{\"1\":{\"434\":1}}],[\"一个用于连接\",{\"1\":{\"434\":1}}],[\"一个用户只能下一单\",{\"1\":{\"998\":1}}],[\"一个用户进程会占用多个内核级线程\",{\"1\":{\"135\":1}}],[\"一个用户级线程映射到一个内核级线程\",{\"1\":{\"135\":1}}],[\"一个段就是一个连续的物理地址空间\",{\"1\":{\"413\":1}}],[\"一个典型的读操作流程如上图所示\",{\"1\":{\"409\":1}}],[\"一个事务写时\",{\"1\":{\"396\":1}}],[\"一个事务读\",{\"1\":{\"396\":1}}],[\"一个页上一个小修改都要整页写入\",{\"1\":{\"396\":1}}],[\"一个不够吗\",{\"1\":{\"360\":1}}],[\"一个对象从诞生到被回收所经历的时间\",{\"1\":{\"359\":1}}],[\"一个新的对象已经产生了\",{\"1\":{\"352\":1}}],[\"一个selector对应多个channel\",{\"1\":{\"332\":1}}],[\"一个类型是你的索引的一个逻辑上的分类\",{\"1\":{\"923\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"317\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口上\",{\"1\":{\"110\":1}}],[\"一个单词一个单词的从文件中取出来\",{\"1\":{\"291\":1}}],[\"一个单核cpu同一时刻只能执行一个程序\",{\"1\":{\"127\":1}}],[\"一个名叫\",{\"1\":{\"272\":1}}],[\"一个操作一旦开始\",{\"1\":{\"226\":1}}],[\"一个操作时另一个不能够访问\",{\"1\":{\"134\":1}}],[\"一个锁对象对应着一个monitor\",{\"1\":{\"211\":1}}],[\"一个时段只能分配一个进程\",{\"1\":{\"185\":1}}],[\"一个时间段内只允许一个进程使用的资源\",{\"1\":{\"140\":1}}],[\"一个i\",{\"1\":{\"180\":1}}],[\"一个磁盘只会建立一张文件分配表\",{\"1\":{\"169\":1}}],[\"一个作业装入内存时\",{\"1\":{\"151\":1}}],[\"一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存\",{\"1\":{\"415\":1}}],[\"一个进程对应一个页表\",{\"1\":{\"156\":1}}],[\"一个进程只有已经占有小编号的资源时\",{\"1\":{\"148\":1}}],[\"一个进程可能会多次调入\",{\"1\":{\"136\":1}}],[\"一个进程不能直接访问另一个进程的地址空间\",{\"1\":{\"134\":1}}],[\"一个系统中有很多个pcb\",{\"1\":{\"131\":1}}],[\"一个电脑供4g运行内存\",{\"1\":{\"127\":1}}],[\"一个物理上的实体变为若干个逻辑上的对应物\",{\"1\":{\"127\":1}}],[\"一个是下菜心\",{\"1\":{\"120\":1}}],[\"一个下包菜\",{\"1\":{\"120\":1}}],[\"一个抽象方法由抽象类声明\",{\"1\":{\"119\":1}}],[\"一个调用者想创建一个对象\",{\"1\":{\"58\":1}}],[\"一个产品家族是这样的一系列产品\",{\"1\":{\"55\":1}}],[\"一步一步创建一个复杂的对象\",{\"1\":{\"47\":1}}],[\"一往情深的恋人\",{\"1\":{\"37\":1}}],[\"🤪😒🎈🔥😊😂💕😘👌😍❤️🤣👍✌️🤞🙌🤦‍♀️😉😎🤦‍♂️🤷‍♀️🎶🎆🎈🧨✨🎉🎎🎁🎀🎍🎋🧧🍟🌭🧇🍳🥗🍞🥨🥖🫓❤️🧡💛💚💙💜❤️‍🩹❤️‍🔥💔🤍🖤🤎🚗🚓🚘🚜🚎🚑🚑🚔\",{\"1\":{\"36\":1}}],[\"牙刷\",{\"1\":{\"33\":1}}],[\"电动汽车等\",{\"1\":{\"112\":1}}],[\"电脑\",{\"1\":{\"109\":2}}],[\"电脑类\",{\"1\":{\"41\":1}}],[\"电吹风\",{\"1\":{\"33\":1}}],[\"电视机厂只生产电视机\",{\"1\":{\"71\":1}}],[\"电视\",{\"1\":{\"33\":1}}],[\"泰迪熊\",{\"1\":{\"33\":1}}],[\"剪刀\",{\"1\":{\"33\":1,\"116\":1}}],[\"花瓶\",{\"1\":{\"33\":1}}],[\"钟表\",{\"1\":{\"33\":1}}],[\"书\",{\"1\":{\"33\":1}}],[\"冰箱\",{\"1\":{\"33\":1}}],[\"烤吐司炉\",{\"1\":{\"33\":1}}],[\"烤箱\",{\"1\":{\"33\":1}}],[\"手环\",{\"1\":{\"305\":1}}],[\"手表\",{\"1\":{\"305\":2}}],[\"手动把读取到的json反序列化为对象\",{\"1\":{\"1042\":1}}],[\"手动把对象序列化为json\",{\"1\":{\"1042\":1}}],[\"手动反序列化\",{\"1\":{\"1042\":1}}],[\"手动序列化\",{\"1\":{\"1042\":1}}],[\"手动清除entry对象\",{\"1\":{\"247\":1}}],[\"手动调用threadlocal的remove方法\",{\"1\":{\"247\":1}}],[\"手工操作阶段\",{\"1\":{\"184\":1}}],[\"手势\",{\"1\":{\"116\":1}}],[\"手机号这个的数据来存储当然是可以的\",{\"1\":{\"966\":1}}],[\"手机号格式错误\",{\"1\":{\"960\":2,\"968\":1}}],[\"手机或者app端发起请求\",{\"1\":{\"955\":1}}],[\"手机上的小程序可以调用电脑的摄像头和麦克风实现拍照\",{\"1\":{\"305\":1}}],[\"手机充电器\",{\"1\":{\"39\":1}}],[\"手机在当地不能直接充电\",{\"1\":{\"39\":1}}],[\"手机\",{\"1\":{\"33\":1,\"305\":1,\"950\":2}}],[\"手提包\",{\"1\":{\"33\":1}}],[\"遥控器\",{\"1\":{\"33\":1}}],[\"鼠标\",{\"1\":{\"33\":1}}],[\"笔记本电脑\",{\"1\":{\"33\":1}}],[\"厕所\",{\"1\":{\"33\":1}}],[\"餐桌\",{\"1\":{\"33\":1}}],[\"餐刀\",{\"1\":{\"33\":1}}],[\"床\",{\"1\":{\"33\":1}}],[\"床单充电线作画gommy\",{\"1\":{\"18\":1}}],[\"盆栽\",{\"1\":{\"33\":1}}],[\"椅子\",{\"1\":{\"33\":1}}],[\"家具\",{\"1\":{\"33\":1}}],[\"蛋糕\",{\"1\":{\"33\":1}}],[\"胡萝卜\",{\"1\":{\"33\":1}}],[\"橘子\",{\"1\":{\"33\":1}}],[\"三大组件\",{\"0\":{\"910\":1}}],[\"三者总体的表现会随着技术进步而越来越好\",{\"1\":{\"359\":1}}],[\"三者的主要区别在于底层数据结构不同\",{\"1\":{\"326\":1}}],[\"三是增加binlog存储\",{\"1\":{\"268\":1}}],[\"三次握手\",{\"1\":{\"198\":1}}],[\"三种\",{\"1\":{\"523\":1}}],[\"三种装入方式\",{\"1\":{\"152\":1}}],[\"三种硬件实现方式\",{\"1\":{\"142\":1}}],[\"三种代理的对比\",{\"0\":{\"96\":1}}],[\"三好学生\",{\"1\":{\"87\":3,\"89\":1}}],[\"三星\",{\"1\":{\"52\":1}}],[\"三星屏幕\",{\"1\":{\"52\":1}}],[\"三明治\",{\"1\":{\"33\":1}}],[\"三个尺度的特征\",{\"1\":{\"24\":1}}],[\"苹果\",{\"1\":{\"33\":1}}],[\"香蕉\",{\"1\":{\"33\":1}}],[\"食物\",{\"1\":{\"33\":1}}],[\"碗\",{\"1\":{\"33\":1}}],[\"勺子\",{\"1\":{\"33\":1}}],[\"叉子\",{\"1\":{\"33\":1}}],[\"茶杯\",{\"1\":{\"33\":1}}],[\"玻璃酒杯\",{\"1\":{\"33\":1}}],[\"瓶子\",{\"1\":{\"33\":1}}],[\"器皿餐具\",{\"1\":{\"33\":1}}],[\"网络\",{\"0\":{\"909\":1},\"1\":{\"900\":1}}],[\"网络编程\",{\"0\":{\"874\":1},\"1\":{\"902\":1}}],[\"网络上有多条数据发送给服务端\",{\"1\":{\"859\":1}}],[\"网络应用框架中的地位就好比\",{\"1\":{\"841\":1}}],[\"网络传输\",{\"1\":{\"822\":1}}],[\"网络设备出现故障\",{\"1\":{\"764\":1}}],[\"网络中获取一个对象的二进制流\",{\"1\":{\"351\":1}}],[\"网络制式等\",{\"1\":{\"296\":1}}],[\"网络协议\",{\"1\":{\"197\":1}}],[\"网络结构\",{\"0\":{\"21\":1}}],[\"网球拍\",{\"1\":{\"33\":1}}],[\"冲浪板\",{\"1\":{\"33\":1}}],[\"滑动窗口\",{\"1\":{\"751\":3}}],[\"滑板\",{\"1\":{\"33\":1}}],[\"滑雪板\",{\"1\":{\"33\":1}}],[\"棒球手套\",{\"1\":{\"33\":1}}],[\"棒球棒\",{\"1\":{\"33\":1}}],[\"风清扬\",{\"1\":{\"78\":1}}],[\"风筝\",{\"1\":{\"33\":1}}],[\"风格迁移\",{\"1\":{\"10\":1}}],[\"篮球\",{\"1\":{\"33\":1}}],[\"飞盘\",{\"1\":{\"33\":1}}],[\"飞机\",{\"1\":{\"33\":1}}],[\"领带\",{\"1\":{\"33\":1}}],[\"领域的经典深度学习算法\",{\"1\":{\"3\":1}}],[\"雨伞\",{\"1\":{\"33\":1}}],[\"长度\",{\"1\":{\"770\":1,\"771\":1,\"773\":1,\"890\":1}}],[\"长度调整\",{\"1\":{\"756\":1}}],[\"长度占用字节\",{\"1\":{\"756\":1}}],[\"长度偏移\",{\"1\":{\"756\":1}}],[\"长度定的太小\",{\"1\":{\"754\":1}}],[\"长度定的太大\",{\"1\":{\"754\":1}}],[\"长度为\",{\"1\":{\"383\":1}}],[\"长度为20的索引\",{\"1\":{\"266\":1}}],[\"长度在\",{\"1\":{\"280\":1}}],[\"长度不要超过5000\",{\"1\":{\"265\":1}}],[\"长期处于\",{\"1\":{\"181\":1}}],[\"长颈鹿\",{\"1\":{\"33\":1}}],[\"长椅\",{\"1\":{\"33\":1}}],[\"斑马\",{\"1\":{\"33\":1}}],[\"熊\",{\"1\":{\"33\":1}}],[\"大key是\",{\"1\":{\"1027\":1}}],[\"大量线程并发更新一个原子性的时候\",{\"1\":{\"997\":1}}],[\"大量的fd数组被整体复制于用户空间和内核空间\",{\"1\":{\"410\":1}}],[\"大致逻辑是这样\",{\"1\":{\"977\":1}}],[\"大不了就处理1000左右的并发\",{\"1\":{\"955\":1}}],[\"大数据分布式存储框架\",{\"1\":{\"841\":1}}],[\"大数据分布式计算框架\",{\"1\":{\"841\":1}}],[\"大数组就是segment数组\",{\"1\":{\"249\":1}}],[\"大端写入\",{\"1\":{\"822\":1}}],[\"大小分配\",{\"0\":{\"891\":1}}],[\"大小的文件传输\",{\"1\":{\"870\":1}}],[\"大小通过\",{\"1\":{\"776\":1}}],[\"大小包括了两个队列的大小\",{\"1\":{\"776\":1}}],[\"大小将数据进行分割发送\",{\"1\":{\"751\":1}}],[\"大小\",{\"0\":{\"868\":1},\"1\":{\"750\":1,\"898\":1}}],[\"大小就是有序小文件的个数500\",{\"1\":{\"291\":1}}],[\"大概就是4000起~7000左右\",{\"1\":{\"955\":1}}],[\"大概率是你的数据库设计或者系统设计出问题了\",{\"1\":{\"731\":1}}],[\"大概可以使用69年\",{\"1\":{\"440\":1}}],[\"大部分步骤与优化前相同\",{\"1\":{\"905\":1}}],[\"大部分bean实际都是无状态\",{\"1\":{\"712\":1}}],[\"大部分时候回收的都是指新生代\",{\"1\":{\"350\":1}}],[\"大屏\",{\"1\":{\"305\":1}}],[\"大家猜猜这个结构体大小是多少\",{\"1\":{\"277\":1}}],[\"大于\",{\"1\":{\"277\":1}}],[\"大于等于x的放在区间右边\",{\"1\":{\"191\":1}}],[\"大多数企业都是基于linux服务器来部署项目\",{\"1\":{\"1010\":1}}],[\"大多数文件系统的默认i\",{\"1\":{\"408\":1}}],[\"大多数\",{\"1\":{\"277\":1}}],[\"大学既有软件专业又有生物专业等\",{\"1\":{\"71\":1}}],[\"大象\",{\"1\":{\"33\":1}}],[\"大尺度特征负责预测小物体\",{\"1\":{\"24\":1}}],[\"奶牛\",{\"1\":{\"33\":1}}],[\"绵羊\",{\"1\":{\"33\":1}}],[\"马上就开始新的篇章~~~进入到我们的redis实战篇\",{\"1\":{\"1043\":1}}],[\"马\",{\"1\":{\"33\":1}}],[\"狗\",{\"1\":{\"33\":1}}],[\"猫\",{\"1\":{\"33\":1}}],[\"鸟\",{\"1\":{\"33\":1}}],[\"市政\",{\"1\":{\"33\":1}}],[\"船\",{\"1\":{\"33\":1}}],[\"火车站类\",{\"1\":{\"95\":1}}],[\"火车站具有卖票功能\",{\"1\":{\"93\":1,\"94\":1}}],[\"火车站\",{\"1\":{\"93\":1,\"94\":1,\"95\":1}}],[\"火车站是目标对象\",{\"1\":{\"93\":1}}],[\"火车站卖票\",{\"1\":{\"93\":2,\"94\":1,\"95\":1}}],[\"火车\",{\"1\":{\"33\":1}}],[\"汽车按\",{\"1\":{\"112\":1}}],[\"汽车分类管理程序\",{\"1\":{\"112\":1}}],[\"汽车\",{\"1\":{\"33\":1}}],[\"人工编码方式\",{\"1\":{\"981\":1}}],[\"人机速度矛盾明显\",{\"1\":{\"184\":1}}],[\"人\",{\"1\":{\"33\":1,\"265\":1}}],[\"人脸简笔画转肖像画\",{\"1\":{\"18\":1}}],[\"人脸图像自动戴口罩\",{\"1\":{\"4\":1}}],[\"交集\",{\"1\":{\"1030\":1}}],[\"交给调用者自己处理\",{\"1\":{\"990\":1}}],[\"交互\",{\"1\":{\"705\":1}}],[\"交互多\",{\"1\":{\"391\":1}}],[\"交互式命令接口\",{\"1\":{\"126\":1}}],[\"交互式趣味demo\",{\"1\":{\"17\":1}}],[\"交互式可视化gan\",{\"1\":{\"11\":2}}],[\"交替编号\",{\"1\":{\"177\":1}}],[\"交换通常发生在许多进程运行且内存吃紧时进行\",{\"1\":{\"153\":1}}],[\"交换技术\",{\"1\":{\"152\":1,\"153\":1}}],[\"交通\",{\"1\":{\"33\":1}}],[\"3l\",{\"1\":{\"950\":1}}],[\"3parts\",{\"1\":{\"857\":2,\"858\":1}}],[\"3s\",{\"1\":{\"764\":2}}],[\"3b\",{\"1\":{\"755\":2}}],[\"36\",{\"0\":{\"644\":1},\"1\":{\"756\":2,\"798\":2,\"800\":1,\"815\":1}}],[\"35f983a6\",{\"1\":{\"796\":2}}],[\"35\",{\"0\":{\"632\":1},\"1\":{\"801\":5}}],[\"3500\",{\"1\":{\"206\":1}}],[\"3a6f2de3\",{\"1\":{\"500\":1}}],[\"320k\",{\"1\":{\"876\":1}}],[\"32位机默认是1024个\",{\"1\":{\"410\":1}}],[\"32\",{\"0\":{\"617\":1},\"1\":{\"277\":1,\"410\":1,\"859\":1,\"876\":1,\"898\":1,\"955\":1,\"993\":1}}],[\"32bit\",{\"1\":{\"210\":3,\"992\":1}}],[\"3在尝试不成功后再次进入park状态\",{\"1\":{\"261\":1}}],[\"3节点\",{\"1\":{\"261\":1}}],[\"3竞争失败\",{\"1\":{\"261\":1}}],[\"37\",{\"0\":{\"646\":1},\"1\":{\"756\":21}}],[\"37989980\",{\"1\":{\"213\":1,\"214\":1,\"215\":1,\"219\":1}}],[\"37541097\",{\"1\":{\"31\":1}}],[\"3306\",{\"1\":{\"372\":1}}],[\"3333\",{\"1\":{\"337\":1}}],[\"33\",{\"0\":{\"624\":1},\"1\":{\"194\":2,\"337\":2}}],[\"3361d94ab3623353f7997137296d8eb\",{\"1\":{\"158\":1}}],[\"3dd975466ed41bb250ad2f71beec3fb\",{\"1\":{\"159\":1}}],[\"31bit\",{\"1\":{\"992\":1}}],[\"31\",{\"0\":{\"613\":1},\"1\":{\"811\":2}}],[\"31fd5ca9ccd980db93b6088ea0e1d58\",{\"1\":{\"159\":1}}],[\"314\",{\"1\":{\"116\":1}}],[\"300\",{\"1\":{\"775\":1,\"993\":2}}],[\"3000000\",{\"1\":{\"893\":1}}],[\"3000\",{\"1\":{\"263\":1}}],[\"30\",{\"0\":{\"609\":1},\"1\":{\"296\":1,\"338\":1,\"776\":2,\"800\":2,\"811\":1,\"812\":1,\"815\":2,\"934\":2,\"937\":1,\"942\":1}}],[\"3080\",{\"1\":{\"116\":2}}],[\"3079\",{\"1\":{\"116\":1}}],[\"3474980866\",{\"1\":{\"870\":1}}],[\"34795071\",{\"1\":{\"31\":1}}],[\"34\",{\"0\":{\"628\":1},\"1\":{\"798\":1,\"812\":1}}],[\"3493\",{\"1\":{\"116\":3}}],[\"3=\",{\"1\":{\"108\":2}}],[\"3999\",{\"1\":{\"950\":1,\"1005\":1}}],[\"39\",{\"0\":{\"650\":1},\"1\":{\"82\":1,\"833\":1,\"846\":17,\"886\":3}}],[\"384\",{\"1\":{\"815\":2}}],[\"38\",{\"0\":{\"647\":1},\"1\":{\"82\":1,\"798\":6,\"800\":1,\"815\":2}}],[\"3\",{\"0\":{\"37\":1,\"127\":1,\"149\":1,\"168\":1,\"458\":1,\"777\":1,\"785\":1,\"820\":1,\"924\":1,\"933\":1,\"935\":1,\"936\":1,\"937\":1,\"938\":2,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":1,\"956\":1,\"960\":1,\"967\":1,\"972\":1,\"980\":1,\"981\":1,\"982\":1,\"991\":1,\"992\":1,\"993\":1,\"994\":2,\"995\":1,\"996\":1,\"997\":1,\"998\":1,\"999\":1,\"1006\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1013\":2,\"1014\":1,\"1015\":1,\"1016\":1,\"1020\":1,\"1022\":1,\"1023\":1,\"1024\":1,\"1025\":2,\"1026\":1,\"1027\":1,\"1028\":1,\"1029\":1,\"1030\":1,\"1040\":1,\"1042\":1},\"1\":{\"58\":1,\"108\":2,\"116\":5,\"132\":1,\"133\":1,\"134\":2,\"135\":4,\"139\":1,\"140\":2,\"147\":3,\"148\":2,\"150\":1,\"151\":2,\"156\":1,\"158\":1,\"211\":1,\"241\":1,\"263\":3,\"265\":1,\"266\":2,\"267\":1,\"277\":2,\"281\":1,\"282\":1,\"336\":1,\"342\":1,\"366\":2,\"383\":1,\"433\":1,\"439\":1,\"495\":1,\"651\":1,\"653\":1,\"655\":1,\"743\":2,\"744\":3,\"749\":7,\"750\":10,\"753\":1,\"754\":25,\"755\":23,\"756\":25,\"764\":1,\"766\":1,\"767\":1,\"770\":2,\"771\":2,\"773\":3,\"776\":1,\"787\":1,\"790\":14,\"793\":1,\"798\":12,\"803\":2,\"805\":2,\"807\":1,\"809\":1,\"815\":2,\"816\":8,\"822\":3,\"823\":1,\"824\":4,\"826\":7,\"829\":5,\"830\":4,\"834\":2,\"835\":2,\"842\":2,\"846\":1,\"849\":2,\"855\":2,\"857\":5,\"858\":2,\"876\":1,\"877\":1,\"886\":2,\"890\":1,\"893\":1,\"898\":1,\"904\":1,\"905\":1,\"907\":1,\"933\":4,\"934\":1,\"938\":1,\"950\":2,\"960\":3,\"961\":1,\"968\":2,\"972\":1,\"983\":1,\"985\":1,\"988\":2,\"989\":3,\"990\":5,\"993\":1,\"995\":2,\"998\":4,\"1024\":2,\"1025\":1,\"1027\":16,\"1028\":3,\"1029\":6,\"1032\":2,\"1034\":1}}],[\"7<\",{\"1\":{\"1038\":1}}],[\"76\",{\"1\":{\"858\":1}}],[\"76802514\",{\"1\":{\"31\":1}}],[\"724\",{\"1\":{\"872\":1}}],[\"72\",{\"1\":{\"857\":1,\"858\":1,\"886\":1}}],[\"745\",{\"1\":{\"812\":1,\"815\":2}}],[\"74\",{\"1\":{\"812\":1,\"815\":2,\"857\":2}}],[\"70\",{\"1\":{\"808\":1}}],[\"7769948160\",{\"1\":{\"870\":1}}],[\"77\",{\"1\":{\"798\":4,\"857\":1,\"886\":1}}],[\"73\",{\"1\":{\"798\":4,\"815\":2}}],[\"7a\",{\"1\":{\"798\":2}}],[\"7b\",{\"1\":{\"755\":2}}],[\"7种经典的垃圾回收器\",{\"0\":{\"360\":1}}],[\"7开始支持\",{\"1\":{\"334\":1}}],[\"7中\",{\"1\":{\"329\":1}}],[\"7的死链问题\",{\"0\":{\"329\":1}}],[\"75\",{\"1\":{\"328\":1,\"798\":2,\"858\":1}}],[\"7取消了循环\",{\"1\":{\"322\":1}}],[\"7而言\",{\"1\":{\"249\":1}}],[\"7比cglib代理效率低一点\",{\"1\":{\"96\":1}}],[\"7\",{\"0\":{\"131\":1,\"153\":1,\"172\":1,\"492\":1,\"781\":1,\"824\":1,\"928\":1,\"942\":1,\"964\":1,\"965\":1,\"966\":1,\"967\":1,\"986\":1,\"998\":1,\"1029\":1},\"1\":{\"96\":1,\"135\":1,\"237\":1,\"342\":1,\"420\":2,\"651\":1,\"743\":1,\"744\":1,\"749\":2,\"750\":3,\"753\":1,\"754\":11,\"755\":11,\"756\":11,\"770\":1,\"771\":1,\"773\":2,\"790\":2,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":6,\"829\":5,\"830\":3,\"835\":2,\"846\":1,\"849\":1,\"855\":2,\"857\":3,\"858\":2,\"886\":2,\"898\":1,\"907\":1,\"923\":1,\"942\":1,\"960\":1,\"962\":1,\"968\":5,\"972\":1,\"990\":1,\"998\":13,\"1010\":1,\"1025\":1,\"1032\":2}}],[\"7991651743003\",{\"1\":{\"3\":1}}],[\"8<\",{\"1\":{\"1038\":1}}],[\"8k\",{\"1\":{\"891\":2}}],[\"8888\",{\"1\":{\"776\":2,\"845\":2}}],[\"8b\",{\"1\":{\"754\":10,\"756\":1,\"798\":2}}],[\"8b+8b\",{\"1\":{\"377\":1}}],[\"8到12步\",{\"1\":{\"651\":1}}],[\"80\",{\"1\":{\"809\":1,\"818\":1}}],[\"80b\",{\"1\":{\"754\":1}}],[\"8080\",{\"1\":{\"498\":1,\"644\":1,\"655\":1,\"749\":8,\"750\":8,\"753\":1,\"759\":2,\"768\":1,\"773\":1,\"775\":1,\"783\":2,\"785\":1,\"787\":1,\"790\":1,\"798\":21,\"803\":6,\"804\":1,\"816\":2,\"834\":1,\"835\":1,\"844\":2,\"876\":2,\"877\":1,\"884\":2,\"886\":4,\"890\":2,\"893\":2,\"896\":1,\"909\":1}}],[\"80h\",{\"1\":{\"406\":1}}],[\"8个字节\",{\"1\":{\"377\":1}}],[\"8时将serial+cms\",{\"1\":{\"360\":1}}],[\"8之后在解决哈希冲突时有了较大的变化\",{\"1\":{\"327\":1}}],[\"8之前的hashmap\",{\"1\":{\"422\":1}}],[\"8之前hashmap底层采用的是数组和链表\",{\"1\":{\"327\":1}}],[\"8之前链表采用头插法\",{\"1\":{\"327\":1}}],[\"8采用了尾插法\",{\"1\":{\"327\":1}}],[\"8可以用default关键字在接口中定义默认方法\",{\"1\":{\"317\":1}}],[\"8指的是是车机\",{\"1\":{\"305\":1}}],[\"8编码\",{\"1\":{\"267\":1}}],[\"8加入\",{\"1\":{\"260\":1}}],[\"8而言\",{\"1\":{\"249\":1}}],[\"8\",{\"0\":{\"132\":1,\"154\":1,\"173\":1,\"496\":1,\"825\":1,\"929\":1,\"943\":1,\"968\":1,\"987\":1,\"999\":1,\"1030\":1},\"1\":{\"135\":1,\"194\":2,\"249\":1,\"265\":1,\"272\":1,\"277\":1,\"328\":1,\"342\":1,\"372\":1,\"449\":1,\"450\":1,\"498\":1,\"502\":1,\"506\":1,\"622\":1,\"668\":2,\"743\":1,\"749\":2,\"750\":3,\"753\":1,\"754\":15,\"755\":11,\"756\":11,\"770\":1,\"771\":1,\"773\":4,\"790\":1,\"798\":6,\"805\":3,\"822\":3,\"823\":1,\"824\":4,\"826\":6,\"829\":5,\"830\":3,\"835\":2,\"846\":1,\"849\":1,\"855\":5,\"857\":3,\"858\":2,\"870\":1,\"872\":2,\"886\":2,\"898\":2,\"907\":1,\"931\":4,\"943\":1,\"968\":1,\"972\":1,\"990\":1,\"1024\":1,\"1025\":1,\"1034\":2,\"1038\":1,\"1039\":2}}],[\"8的时候\",{\"1\":{\"96\":1}}],[\"8逐步对jdk动态代理优化之后\",{\"1\":{\"96\":1}}],[\"81214953\",{\"1\":{\"31\":1}}],[\"82660381\",{\"1\":{\"31\":1}}],[\"826065030944870400\",{\"1\":{\"18\":1}}],[\"q\",{\"1\":{\"191\":14,\"283\":8,\"804\":1,\"844\":1}}],[\"quithandler\",{\"1\":{\"762\":1}}],[\"quit\",{\"1\":{\"759\":2}}],[\"quicklist\",{\"1\":{\"281\":1}}],[\"quick\",{\"1\":{\"191\":4}}],[\"querywithlogicalexpire\",{\"1\":{\"989\":1,\"990\":3}}],[\"querywithmutex\",{\"1\":{\"988\":2,\"990\":3}}],[\"querywithpassthrough\",{\"1\":{\"985\":1,\"990\":3}}],[\"querywrapper\",{\"1\":{\"371\":2}}],[\"querywrapper<>\",{\"1\":{\"370\":1,\"371\":1}}],[\"querywrapper<user>\",{\"1\":{\"370\":1,\"371\":1}}],[\"querybyid\",{\"1\":{\"977\":1}}],[\"querybuilders\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":3,\"942\":1,\"943\":1,\"944\":1,\"950\":1}}],[\"queryshopbyid\",{\"1\":{\"977\":1}}],[\"query\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":5,\"942\":1,\"943\":1,\"944\":1,\"960\":1,\"968\":1,\"998\":3}}],[\"queue等\",{\"1\":{\"1031\":1}}],[\"queue\",{\"1\":{\"776\":7}}],[\"queue<treenode\",{\"1\":{\"283\":1}}],[\"qualifier指定bean名称注入需要与\",{\"1\":{\"709\":1}}],[\"qualifier\",{\"1\":{\"470\":1,\"688\":1,\"695\":1,\"709\":1}}],[\"quad\",{\"1\":{\"26\":2}}],[\"quasimondo\",{\"1\":{\"18\":1}}],[\"qqwweee\",{\"1\":{\"32\":1}}],[\"qq\",{\"1\":{\"31\":2,\"194\":1,\"195\":1,\"232\":1}}],[\"木盏\",{\"1\":{\"31\":1}}],[\"郭冠华\",{\"1\":{\"31\":1}}],[\"江大白\",{\"1\":{\"31\":1}}],[\"v3\",{\"1\":{\"1024\":1,\"1025\":2}}],[\"v2\",{\"1\":{\"1024\":1,\"1025\":2}}],[\"v1\",{\"1\":{\"1024\":1,\"1025\":2}}],[\"vm的实现\",{\"1\":{\"350\":1}}],[\"vr\",{\"1\":{\"305\":1}}],[\"verify\",{\"1\":{\"1042\":1}}],[\"version=\",{\"1\":{\"1038\":1}}],[\"version\",{\"1\":{\"372\":2,\"770\":2,\"771\":2,\"773\":2}}],[\"version>1\",{\"1\":{\"1038\":1}}],[\"version>3\",{\"1\":{\"372\":1}}],[\"version>\",{\"1\":{\"95\":1,\"372\":3,\"672\":1,\"833\":1,\"931\":6,\"948\":1,\"1032\":2,\"1038\":3}}],[\"vecnode\",{\"1\":{\"283\":9}}],[\"vector<treenode\",{\"1\":{\"283\":1}}],[\"vector<int>\",{\"1\":{\"283\":2}}],[\"vec\",{\"1\":{\"283\":7}}],[\"var4\",{\"1\":{\"996\":1}}],[\"var2\",{\"1\":{\"996\":2}}],[\"var1\",{\"1\":{\"996\":2}}],[\"var5\",{\"1\":{\"996\":6}}],[\"varchar\",{\"1\":{\"383\":2}}],[\"varchar是可变长字符串\",{\"1\":{\"265\":1}}],[\"valsdkf\",{\"1\":{\"950\":2}}],[\"valid\",{\"1\":{\"731\":1}}],[\"validate\",{\"1\":{\"260\":2}}],[\"value的数据库\",{\"1\":{\"1023\":1}}],[\"value支持多种不同数据结构\",{\"1\":{\"1009\":1}}],[\"value对的形式存储\",{\"1\":{\"1001\":1}}],[\"value键值对的方式\",{\"1\":{\"966\":1}}],[\"valueof\",{\"1\":{\"773\":1,\"845\":2}}],[\"value和\",{\"1\":{\"731\":1}}],[\"value适用于注入基本类型\",{\"1\":{\"709\":1}}],[\"value用于注入bean\",{\"1\":{\"709\":1}}],[\"values\",{\"1\":{\"657\":1,\"773\":2}}],[\"value进行对比\",{\"1\":{\"323\":1}}],[\"value是该词出现的频率\",{\"1\":{\"290\":1}}],[\"value也就是entry对象进行回收\",{\"1\":{\"247\":1}}],[\"value\",{\"0\":{\"687\":1,\"689\":1},\"1\":{\"236\":5,\"244\":2,\"249\":9,\"458\":1,\"460\":1,\"470\":2,\"473\":1,\"503\":1,\"561\":1,\"568\":1,\"652\":1,\"688\":1,\"691\":1,\"695\":1,\"711\":1,\"731\":3,\"732\":1,\"737\":2,\"758\":2,\"773\":6,\"822\":9,\"823\":1,\"890\":1,\"990\":6,\"1009\":1,\"1025\":2,\"1026\":1,\"1027\":1}}],[\"val\",{\"1\":{\"52\":8,\"249\":7,\"283\":4,\"287\":5}}],[\"v>\",{\"1\":{\"249\":22,\"974\":3}}],[\"vs\",{\"0\":{\"819\":1,\"820\":1,\"875\":1,\"899\":1,\"900\":1},\"1\":{\"151\":1,\"816\":1,\"842\":2,\"901\":1}}],[\"v必须成对的出现\",{\"1\":{\"144\":1}}],[\"v操作\",{\"1\":{\"134\":1,\"143\":2}}],[\"voucherorder\",{\"1\":{\"995\":7,\"998\":21}}],[\"voucherorderserviceimpl\",{\"1\":{\"995\":1,\"997\":1,\"998\":1}}],[\"voucherid\",{\"1\":{\"995\":4,\"996\":1,\"997\":2,\"998\":15}}],[\"voucherserviceimpl\",{\"1\":{\"994\":1}}],[\"voucherservice\",{\"1\":{\"994\":2}}],[\"vouchercontroller\",{\"1\":{\"994\":2}}],[\"voucher\",{\"1\":{\"961\":1,\"992\":1,\"994\":19,\"995\":1,\"996\":2,\"997\":3,\"998\":10}}],[\"vocation\",{\"1\":{\"341\":1}}],[\"volatile的有序性是通过插入内存屏障来保证指令按照顺序执行\",{\"1\":{\"229\":1}}],[\"volatile的底层实现原理是内存屏障\",{\"1\":{\"227\":1}}],[\"volatile关键字主要用于解决变量在多个线程之间的可见性\",{\"1\":{\"228\":1}}],[\"volatile关键字只能修饰变量\",{\"1\":{\"228\":1}}],[\"volatile和synchronized在有序性上的不同\",{\"0\":{\"229\":1}}],[\"volatile和synchronized\",{\"0\":{\"228\":1}}],[\"volatile原理\",{\"0\":{\"227\":1}}],[\"volatile\",{\"1\":{\"57\":1,\"101\":4,\"103\":1,\"104\":1,\"225\":2,\"234\":3,\"249\":3,\"429\":4,\"776\":1,\"896\":2}}],[\"voidpromise\",{\"1\":{\"775\":1,\"792\":1,\"793\":1}}],[\"void\",{\"1\":{\"41\":6,\"42\":2,\"49\":12,\"52\":6,\"58\":4,\"69\":2,\"78\":1,\"82\":9,\"86\":1,\"87\":3,\"89\":6,\"93\":4,\"94\":6,\"95\":2,\"103\":3,\"105\":1,\"108\":1,\"109\":12,\"110\":8,\"111\":5,\"116\":7,\"120\":11,\"191\":2,\"192\":1,\"194\":2,\"206\":4,\"211\":1,\"221\":1,\"224\":9,\"225\":9,\"232\":1,\"255\":4,\"260\":2,\"282\":2,\"283\":2,\"285\":2,\"287\":2,\"336\":2,\"339\":1,\"370\":1,\"441\":1,\"450\":1,\"463\":3,\"491\":2,\"500\":2,\"510\":3,\"512\":2,\"515\":4,\"523\":1,\"622\":1,\"655\":2,\"657\":1,\"711\":1,\"742\":7,\"743\":5,\"744\":9,\"749\":8,\"753\":4,\"754\":3,\"755\":3,\"756\":3,\"758\":3,\"759\":7,\"760\":2,\"761\":5,\"762\":2,\"764\":2,\"767\":5,\"768\":3,\"770\":2,\"771\":2,\"773\":2,\"775\":3,\"776\":2,\"783\":4,\"784\":1,\"785\":2,\"786\":1,\"787\":3,\"788\":1,\"790\":14,\"791\":5,\"792\":3,\"793\":8,\"794\":1,\"798\":7,\"799\":2,\"803\":5,\"804\":3,\"808\":1,\"816\":9,\"818\":1,\"825\":2,\"826\":1,\"834\":2,\"835\":1,\"844\":4,\"845\":2,\"846\":1,\"849\":4,\"859\":2,\"870\":1,\"872\":1,\"884\":2,\"886\":1,\"889\":2,\"890\":2,\"893\":2,\"896\":5,\"898\":2,\"907\":3,\"909\":8,\"932\":2,\"950\":10,\"961\":1,\"962\":2,\"972\":1,\"988\":1,\"989\":2,\"990\":3,\"993\":1,\"994\":1,\"1032\":4,\"1035\":2,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"v\",{\"0\":{\"45\":3},\"1\":{\"194\":19,\"195\":7,\"237\":1,\"249\":6,\"343\":2,\"858\":1}}],[\"v=mpu2histivi\",{\"1\":{\"30\":1}}],[\"vi\",{\"1\":{\"1016\":1}}],[\"visitfile\",{\"1\":{\"872\":6}}],[\"viewreslover解析后返回具体view\",{\"1\":{\"736\":1}}],[\"viewresolver\",{\"1\":{\"622\":2,\"644\":1}}],[\"view代表的是用户界面\",{\"1\":{\"734\":1}}],[\"view\",{\"1\":{\"617\":2,\"622\":3,\"647\":2,\"734\":1}}],[\"vingkin\",{\"1\":{\"194\":2,\"366\":1,\"368\":1,\"426\":2,\"949\":1}}],[\"vimeo\",{\"1\":{\"18\":1}}],[\"video\",{\"1\":{\"3\":2,\"6\":1,\"11\":1,\"13\":1,\"17\":1}}],[\"训练过程\",{\"0\":{\"27\":1}}],[\"+buf2\",{\"1\":{\"829\":1}}],[\"+t\",{\"1\":{\"413\":1}}],[\"+useconcmarksweepgc的话\",{\"1\":{\"362\":1}}],[\"+useconcmarksweepgc来开启cms收集器的话\",{\"1\":{\"362\":1}}],[\"+1\",{\"1\":{\"246\":1,\"290\":1,\"755\":1}}],[\"+k∗w\",{\"1\":{\"195\":1}}],[\"++bincount\",{\"1\":{\"249\":1}}],[\"++i\",{\"1\":{\"232\":1}}],[\"++\",{\"1\":{\"116\":2,\"792\":1,\"793\":1}}],[\"+=\",{\"1\":{\"116\":1,\"192\":1,\"287\":3,\"893\":1}}],[\"+\",{\"1\":{\"26\":6,\"41\":2,\"52\":26,\"82\":1,\"86\":1,\"87\":1,\"89\":3,\"108\":4,\"109\":2,\"111\":6,\"116\":15,\"123\":1,\"138\":1,\"139\":2,\"142\":1,\"151\":1,\"156\":1,\"160\":1,\"169\":1,\"186\":1,\"191\":4,\"194\":5,\"195\":4,\"221\":1,\"232\":3,\"246\":1,\"249\":2,\"277\":1,\"283\":3,\"287\":4,\"343\":2,\"359\":1,\"368\":1,\"401\":1,\"409\":1,\"433\":1,\"441\":4,\"463\":3,\"523\":2,\"600\":1,\"647\":2,\"732\":2,\"743\":1,\"744\":2,\"749\":10,\"750\":20,\"754\":110,\"755\":110,\"756\":111,\"761\":7,\"766\":1,\"775\":1,\"776\":4,\"792\":2,\"798\":60,\"803\":2,\"816\":4,\"818\":2,\"822\":20,\"823\":10,\"824\":30,\"825\":1,\"826\":60,\"829\":40,\"830\":20,\"834\":1,\"835\":1,\"849\":38,\"855\":20,\"857\":30,\"858\":20,\"859\":2,\"870\":4,\"886\":20,\"890\":1,\"893\":3,\"896\":1,\"898\":10,\"907\":10,\"968\":2,\"972\":1,\"983\":3,\"985\":3,\"987\":1,\"988\":5,\"989\":3,\"990\":5,\"993\":5,\"994\":1,\"996\":1,\"1014\":1,\"1032\":2,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"+pg​\",{\"1\":{\"8\":1}}],[\"^2\",{\"1\":{\"26\":4}}],[\"^\",{\"1\":{\"26\":10}}],[\"损失函数\",{\"0\":{\"26\":1},\"1\":{\"31\":1}}],[\"其value是一个无序字典\",{\"1\":{\"1027\":1}}],[\"其value是字符串\",{\"1\":{\"1025\":1}}],[\"其后果是\",{\"1\":{\"981\":1}}],[\"其语义完全由你来定\",{\"1\":{\"923\":1}}],[\"其间也不会使用\",{\"1\":{\"904\":1}}],[\"其各个方法均无法正常使用\",{\"1\":{\"825\":1}}],[\"其返回值都是\",{\"1\":{\"822\":1}}],[\"其大小通过\",{\"1\":{\"776\":1}}],[\"其大小是32个整数的大小\",{\"1\":{\"410\":1}}],[\"其处理流程是\",{\"1\":{\"644\":1}}],[\"其它就是处理es里面数据的一些使用规则设置也叫做映射\",{\"1\":{\"926\":1}}],[\"其它网络应用框架\",{\"1\":{\"842\":1}}],[\"其它实现还有\",{\"1\":{\"834\":1,\"835\":1}}],[\"其它两个都处于\",{\"1\":{\"776\":1}}],[\"其它代码不变\",{\"1\":{\"750\":1}}],[\"其它有路径的\",{\"1\":{\"644\":1}}],[\"其它\",{\"0\":{\"674\":1},\"1\":{\"499\":1,\"825\":1,\"851\":1}}],[\"其它的排在最后\",{\"1\":{\"466\":1}}],[\"其演示图如下\",{\"1\":{\"420\":1}}],[\"其重要意义在于定义了一个连续的虚拟地址空间\",{\"1\":{\"418\":1}}],[\"其附近的存储单元也将被访问\",{\"1\":{\"417\":1}}],[\"其附近的存储单元也很有可能被访问\",{\"1\":{\"161\":1}}],[\"其目的是为了更好地满足用户的需求\",{\"1\":{\"413\":1}}],[\"其目的是降低类之间的耦合度\",{\"1\":{\"111\":1}}],[\"其余部分暂留在盘上\",{\"1\":{\"418\":1}}],[\"其余部分就是页号\",{\"1\":{\"156\":1}}],[\"其余的页表项仍然驻留在磁盘上\",{\"1\":{\"413\":1}}],[\"其效率也会线性下降\",{\"1\":{\"410\":1}}],[\"其良好跨平台支持也是他的一个优点\",{\"1\":{\"410\":1}}],[\"其结果就是永久的\",{\"1\":{\"396\":1}}],[\"其次看\",{\"1\":{\"604\":1}}],[\"其次使用\",{\"1\":{\"582\":1}}],[\"其次\",{\"1\":{\"383\":1,\"672\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"112\":1}}],[\"其wrapper方法中第一个参数为condition\",{\"1\":{\"370\":1}}],[\"其区别在于参数和返回值有所区别\",{\"1\":{\"336\":1}}],[\"其相关的类和接口在java\",{\"1\":{\"331\":1}}],[\"其访问位置为1\",{\"1\":{\"163\":1}}],[\"其响应比也会越来越大\",{\"1\":{\"139\":1}}],[\"其频率很高\",{\"1\":{\"136\":1}}],[\"其他的人在处理时\",{\"1\":{\"997\":1}}],[\"其他的线程只能返回之前的数据\",{\"1\":{\"987\":1}}],[\"其他详见\",{\"1\":{\"729\":1}}],[\"其他事务如果需要修改数据\",{\"1\":{\"396\":1}}],[\"其他人对此事的看法是什么\",{\"1\":{\"309\":1}}],[\"其他线程才能走返回正确的数据\",{\"1\":{\"987\":1}}],[\"其他线程就都能从缓存中加载这些数据了\",{\"1\":{\"987\":1}}],[\"其他线程去异步处理数据库\",{\"1\":{\"981\":1}}],[\"其他线程将signal这个队列中的元素\",{\"1\":{\"254\":1}}],[\"其他线程将无法再获取互斥锁及共享锁\",{\"1\":{\"252\":1}}],[\"其他线程来put\",{\"1\":{\"249\":1}}],[\"其他线程永远无法获取锁\",{\"1\":{\"206\":1}}],[\"其他线程可以使用interrupt方法打断正在睡眠的线程\",{\"1\":{\"203\":1}}],[\"其他用户\",{\"1\":{\"173\":1}}],[\"其他用户也可以看到文件数据的变化\",{\"1\":{\"172\":1}}],[\"其他需要操作系统实现的文件管理功能\",{\"1\":{\"166\":1}}],[\"其他试图进入临界区的进程必须等待\",{\"1\":{\"140\":1}}],[\"其他条件全部具备\",{\"1\":{\"132\":1}}],[\"其他都相同\",{\"1\":{\"87\":1}}],[\"其子类可以进行覆盖也可以直接继承\",{\"1\":{\"119\":1}}],[\"其组合就很多\",{\"1\":{\"112\":1}}],[\"其组成部分相似\",{\"1\":{\"50\":1}}],[\"其含义是\",{\"1\":{\"111\":1}}],[\"其实就不会有缓存击穿的问题\",{\"1\":{\"987\":1}}],[\"其实就是给网络传输的信息加上\",{\"1\":{\"766\":1}}],[\"其实就是说上面的\",{\"1\":{\"708\":1}}],[\"其实就是在初始化instance的时候才会出现线程安全问题\",{\"1\":{\"101\":1}}],[\"其实就是使用到了适配器模式\",{\"1\":{\"39\":1}}],[\"其实使用string就可以啦\",{\"1\":{\"965\":1}}],[\"其实\",{\"1\":{\"889\":1}}],[\"其实这些认识都比较片面\",{\"1\":{\"805\":1}}],[\"其实并非将接口交给\",{\"1\":{\"661\":1}}],[\"其实并没有用到栈的特性\",{\"1\":{\"420\":1}}],[\"其实主要就是补充了一些\",{\"1\":{\"477\":1}}],[\"其实雪花算法每一部分占用的比特位数量并不是固定死的\",{\"1\":{\"443\":1}}],[\"其实是this\",{\"1\":{\"998\":1}}],[\"其实是从\",{\"1\":{\"528\":1}}],[\"其实是由额外的线程执行的\",{\"1\":{\"423\":1}}],[\"其实是存在问题\",{\"1\":{\"101\":1}}],[\"其实会有很多感悟\",{\"1\":{\"306\":1}}],[\"其实对于现在\",{\"1\":{\"305\":1}}],[\"其实现方式是在数据库取到statementname对应的sql语句的所有记录\",{\"1\":{\"268\":1}}],[\"其实得根据主键类型进行动态判断\",{\"1\":{\"265\":1}}],[\"其内部含有对真实主题的引用\",{\"1\":{\"92\":1}}],[\"其产品的各个部分经常面临着剧烈的变化\",{\"1\":{\"51\":1}}],[\"其中记录了序列化时对应的class名称\",{\"1\":{\"1041\":1}}],[\"其中记录了该段在内存中的起始位置\",{\"1\":{\"159\":1}}],[\"其中封装了各种对redis的操作\",{\"1\":{\"1036\":1}}],[\"其中对redis的集成模块就叫做springdataredis\",{\"1\":{\"1036\":1}}],[\"其中java客户端也包含很多\",{\"1\":{\"1031\":1}}],[\"其中的commonds就是redis的操作命令\",{\"1\":{\"1018\":1}}],[\"其中的任意一个进入读就绪状态\",{\"1\":{\"409\":1}}],[\"其中常见的options有\",{\"1\":{\"1018\":1}}],[\"其中键值型\",{\"1\":{\"1001\":1}}],[\"其中do\",{\"1\":{\"996\":1}}],[\"其中队列使用了\",{\"1\":{\"791\":1}}],[\"其中确定具体消息类型\",{\"1\":{\"773\":1}}],[\"其中被\",{\"1\":{\"709\":1}}],[\"其中\",{\"1\":{\"561\":1,\"728\":1,\"776\":1,\"803\":1,\"818\":1,\"834\":1,\"1012\":1}}],[\"其中m为以上数据类型种元素的数量\",{\"1\":{\"430\":1}}],[\"其中n为被删除key的数量\",{\"1\":{\"430\":1}}],[\"其中λ为访问快表所需时间\",{\"1\":{\"413\":1}}],[\"其中一个事务进行回滚\",{\"1\":{\"403\":1}}],[\"其中serial\",{\"1\":{\"360\":1}}],[\"其中又分为\",{\"1\":{\"350\":1}}],[\"其中我印象比较深的就是鸿蒙的分布式软总线\",{\"1\":{\"305\":1}}],[\"其中涉及到了万物互联\",{\"1\":{\"305\":1}}],[\"其中第三步\",{\"1\":{\"291\":1}}],[\"其中key是词\",{\"1\":{\"290\":1}}],[\"其中这多余的\",{\"1\":{\"277\":1}}],[\"其中无符号值可以避免误存负数\",{\"1\":{\"265\":1}}],[\"其中id必为主键\",{\"1\":{\"265\":1}}],[\"其中运用了设计模式中的模板方法\",{\"1\":{\"251\":1}}],[\"其中用到的原理和longadder差不多使用了cell\",{\"1\":{\"249\":1}}],[\"其中函数中的操作能保证原子\",{\"1\":{\"232\":4}}],[\"其中后几位为001表示无锁\",{\"1\":{\"210\":1}}],[\"其中association中的select对应rolemapper\",{\"1\":{\"366\":1}}],[\"其中a\",{\"1\":{\"148\":1}}],[\"其中pcb不会被调到外存\",{\"1\":{\"136\":1}}],[\"其中并发和共享是两个最基本的特征\",{\"1\":{\"127\":1}}],[\"其中取号\",{\"1\":{\"118\":1}}],[\"其中拿铁咖啡\",{\"1\":{\"74\":1}}],[\"其中与ground\",{\"1\":{\"25\":1}}],[\"其中在9个anchor中\",{\"1\":{\"24\":1}}],[\"其中小尺度特征\",{\"1\":{\"24\":1}}],[\"其中concat就是在上采样之后\",{\"1\":{\"23\":1}}],[\"其backbone如下图所示\",{\"1\":{\"22\":1}}],[\"56\",{\"1\":{\"907\":3}}],[\"5622464513\",{\"1\":{\"870\":1}}],[\"56303b57\",{\"1\":{\"500\":1}}],[\"54\",{\"1\":{\"810\":2,\"812\":1,\"813\":2,\"815\":2}}],[\"541a75aa1efce984b24df67aea29aa4\",{\"1\":{\"157\":1}}],[\"57\",{\"1\":{\"814\":1}}],[\"57351\",{\"1\":{\"803\":1}}],[\"57191\",{\"1\":{\"803\":1}}],[\"52625\",{\"1\":{\"798\":6}}],[\"52612\",{\"1\":{\"798\":6}}],[\"52588\",{\"1\":{\"798\":6}}],[\"52∗52三个尺度的特征\",{\"1\":{\"24\":1}}],[\"59\",{\"1\":{\"776\":1,\"886\":3}}],[\"59221\",{\"1\":{\"750\":7}}],[\"5s\",{\"1\":{\"764\":2}}],[\"513\",{\"1\":{\"823\":1}}],[\"512mb\",{\"1\":{\"1015\":1}}],[\"512\",{\"1\":{\"792\":1,\"823\":2}}],[\"51\",{\"1\":{\"754\":2,\"756\":1,\"810\":4}}],[\"58\",{\"1\":{\"776\":1,\"814\":2}}],[\"58177\",{\"1\":{\"749\":5}}],[\"58063\",{\"1\":{\"372\":1}}],[\"55\",{\"1\":{\"749\":5}}],[\"5555\",{\"1\":{\"337\":1}}],[\"5l\",{\"1\":{\"441\":2,\"950\":1}}],[\"5倍长度进行扩容\",{\"1\":{\"323\":1}}],[\"5字节的空间进行编码\",{\"1\":{\"279\":1}}],[\"5也来执行synchronized\",{\"1\":{\"211\":1}}],[\"5e6+5\",{\"1\":{\"192\":1}}],[\"500000l\",{\"1\":{\"792\":1}}],[\"500\",{\"1\":{\"290\":1,\"291\":1}}],[\"50\",{\"1\":{\"82\":1,\"441\":1,\"756\":1,\"791\":1,\"798\":3,\"807\":1,\"822\":2,\"942\":1,\"988\":1,\"990\":1}}],[\"5\",{\"0\":{\"129\":1,\"151\":1,\"170\":1,\"474\":1,\"779\":1,\"787\":1,\"822\":1,\"926\":1,\"940\":1,\"958\":1,\"962\":1,\"984\":1,\"996\":1,\"1008\":1,\"1015\":1,\"1027\":1,\"1036\":1,\"1037\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":1},\"1\":{\"25\":1,\"132\":1,\"134\":1,\"135\":1,\"194\":2,\"232\":4,\"237\":1,\"274\":1,\"277\":5,\"279\":1,\"280\":3,\"281\":1,\"336\":1,\"342\":1,\"372\":1,\"385\":1,\"436\":1,\"655\":1,\"705\":2,\"743\":2,\"744\":2,\"749\":2,\"750\":3,\"753\":1,\"754\":11,\"755\":23,\"756\":11,\"764\":1,\"770\":1,\"771\":1,\"773\":2,\"790\":1,\"793\":1,\"798\":6,\"805\":2,\"816\":2,\"822\":3,\"823\":1,\"824\":5,\"826\":11,\"829\":7,\"830\":6,\"834\":2,\"835\":3,\"841\":1,\"842\":1,\"846\":1,\"849\":1,\"855\":2,\"857\":4,\"858\":2,\"876\":1,\"877\":1,\"886\":2,\"890\":1,\"898\":1,\"907\":3,\"923\":1,\"934\":1,\"940\":1,\"960\":2,\"961\":1,\"962\":1,\"968\":1,\"972\":1,\"983\":1,\"989\":3,\"990\":4,\"995\":1,\"996\":1,\"998\":7,\"1025\":2,\"1027\":2,\"1028\":1,\"1029\":1,\"1038\":1}}],[\"53155\",{\"1\":{\"754\":17}}],[\"53\",{\"0\":{\"22\":1},\"1\":{\"337\":2,\"776\":2,\"810\":2,\"813\":2}}],[\"5ca3e9b122f61f8f06494c97b1afccf3\",{\"1\":{\"10\":2}}],[\"yml配置redis信息\",{\"1\":{\"1040\":1}}],[\"ymlreturnvaluehandler\",{\"1\":{\"563\":1}}],[\"yes\",{\"1\":{\"1015\":1}}],[\"yum\",{\"1\":{\"1011\":1}}],[\"yyyy\",{\"1\":{\"993\":1}}],[\"yield没有时间参数\",{\"1\":{\"203\":1}}],[\"yield\",{\"1\":{\"203\":1}}],[\"you\",{\"1\":{\"859\":3}}],[\"young\",{\"1\":{\"350\":1}}],[\"your\",{\"1\":{\"111\":1,\"825\":1}}],[\"youtube\",{\"1\":{\"30\":1}}],[\"yolo3\",{\"1\":{\"32\":2}}],[\"yolo\",{\"1\":{\"30\":1}}],[\"yolov3目标检测demo视频\",{\"1\":{\"30\":1}}],[\"yolov3的head部分\",{\"1\":{\"24\":1}}],[\"yolov3\",{\"0\":{\"20\":1},\"1\":{\"32\":2}}],[\"y\",{\"1\":{\"26\":2,\"195\":6,\"285\":4,\"1011\":1}}],[\"yan\",{\"1\":{\"5\":1}}],[\"卫星航拍图转地图等图像转译任务上表现优秀\",{\"1\":{\"16\":1}}],[\"融合底层细粒度特征和高层抽象语义特征\",{\"1\":{\"16\":1}}],[\"nginx基于七层模型走的事http协议\",{\"1\":{\"955\":1}}],[\"n456789abcdef\",{\"1\":{\"890\":1}}],[\"nworld\",{\"1\":{\"890\":1}}],[\"nhaha\",{\"1\":{\"859\":1}}],[\"nho\",{\"1\":{\"859\":2}}],[\"n指的是其他iot设备\",{\"1\":{\"305\":1}}],[\"ni\",{\"1\":{\"859\":2}}],[\"nil节点\",{\"1\":{\"270\":1}}],[\"nioworkers\",{\"1\":{\"800\":2,\"801\":2}}],[\"niobyteunsafe\",{\"1\":{\"792\":1,\"794\":1,\"825\":1}}],[\"niomessageunsafe\",{\"1\":{\"792\":1,\"793\":1}}],[\"niounsafe\",{\"1\":{\"792\":1}}],[\"nioeventloop\",{\"0\":{\"791\":1,\"798\":1,\"800\":1,\"801\":1},\"1\":{\"776\":1,\"791\":4,\"792\":4,\"800\":1}}],[\"nioeventloopgroup\",{\"1\":{\"749\":11,\"750\":7,\"753\":2,\"754\":23,\"755\":21,\"756\":23,\"759\":6,\"767\":2,\"768\":4,\"775\":2,\"783\":6,\"785\":2,\"787\":2,\"790\":1,\"798\":29,\"800\":3,\"801\":6,\"803\":4,\"804\":2,\"808\":2,\"809\":1,\"816\":2,\"834\":2,\"835\":2,\"844\":3}}],[\"niosocketchannel\",{\"1\":{\"749\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":1,\"767\":1,\"775\":1,\"783\":1,\"785\":1,\"787\":1,\"793\":5,\"794\":1,\"798\":4,\"803\":4,\"804\":2,\"816\":2,\"834\":1,\"835\":2,\"844\":3}}],[\"nioserversocketchannel\",{\"1\":{\"749\":1,\"759\":1,\"768\":1,\"783\":1,\"790\":14,\"798\":2,\"816\":1,\"834\":2,\"844\":1}}],[\"nio方式适用于连接数目多且连接比较短的架构\",{\"1\":{\"334\":1}}],[\"nio的通道类似于流\",{\"1\":{\"332\":1}}],[\"nio的非阻塞模式\",{\"1\":{\"332\":1}}],[\"nio三大核心组件\",{\"1\":{\"332\":2}}],[\"nio是面向缓冲区编程的\",{\"1\":{\"332\":1}}],[\"nio有三大核心部分\",{\"1\":{\"332\":1}}],[\"nio包下\",{\"1\":{\"332\":1}}],[\"nio相关类都放在了java\",{\"1\":{\"332\":1}}],[\"nio全称java\",{\"1\":{\"332\":1}}],[\"nio基本介绍\",{\"1\":{\"332\":1}}],[\"nio\",{\"0\":{\"330\":1,\"332\":1,\"899\":1,\"905\":1,\"1057\":1},\"1\":{\"44\":1,\"330\":1,\"334\":2,\"775\":1,\"776\":1,\"790\":9,\"791\":2,\"792\":7,\"793\":7,\"794\":2,\"798\":6,\"803\":1,\"822\":1,\"825\":2,\"834\":1,\"835\":1,\"842\":1,\"845\":1,\"855\":1,\"876\":1,\"877\":1,\"883\":1,\"885\":1,\"886\":3,\"889\":1}}],[\"nthreads\",{\"1\":{\"244\":3}}],[\"n个磁道才能存储\",{\"1\":{\"176\":1}}],[\"n个用户级线程映射到m个内核级线程\",{\"1\":{\"135\":1}}],[\"nru\",{\"1\":{\"163\":1}}],[\"num\",{\"1\":{\"1025\":1}}],[\"nums下标从0开始\",{\"1\":{\"287\":1}}],[\"nums\",{\"1\":{\"287\":9}}],[\"number\",{\"1\":{\"82\":3,\"744\":2}}],[\"numbergenerator\",{\"1\":{\"82\":6}}],[\"nunbergenerator\",{\"1\":{\"82\":1}}],[\"null<>1的返回结果是null\",{\"1\":{\"267\":1}}],[\"null<>null的返回结果是null\",{\"1\":{\"267\":1}}],[\"null=null的返回结果是null\",{\"1\":{\"267\":1}}],[\"null与任何值的直接比较都为null\",{\"1\":{\"267\":1}}],[\"nullpointerexception\",{\"1\":{\"41\":1,\"123\":1,\"249\":1,\"791\":1}}],[\"null\",{\"1\":{\"41\":2,\"57\":4,\"58\":3,\"63\":1,\"65\":1,\"94\":4,\"101\":6,\"103\":2,\"104\":6,\"123\":1,\"235\":1,\"249\":21,\"255\":1,\"282\":6,\"283\":5,\"285\":2,\"370\":1,\"371\":2,\"450\":3,\"460\":1,\"626\":1,\"641\":1,\"644\":3,\"670\":1,\"672\":1,\"711\":1,\"758\":5,\"760\":1,\"761\":3,\"770\":1,\"773\":2,\"775\":1,\"787\":3,\"788\":2,\"790\":6,\"791\":2,\"792\":1,\"793\":2,\"794\":3,\"798\":2,\"806\":1,\"810\":1,\"812\":1,\"813\":1,\"877\":2,\"890\":1,\"893\":1,\"896\":3,\"907\":1,\"909\":2,\"960\":2,\"961\":1,\"968\":2,\"972\":1,\"983\":1,\"985\":5,\"988\":5,\"989\":2,\"990\":12,\"1032\":1,\"1035\":1}}],[\"nagle\",{\"1\":{\"751\":3}}],[\"nanotime\",{\"1\":{\"791\":2,\"792\":2,\"870\":2}}],[\"nanjing\",{\"1\":{\"169\":1}}],[\"nan355655600\",{\"1\":{\"31\":1}}],[\"name>\",{\"1\":{\"1038\":1}}],[\"name2\",{\"1\":{\"1025\":3}}],[\"name=\",{\"1\":{\"816\":1}}],[\"name=name\",{\"1\":{\"111\":3}}],[\"name就是在handler处理链中传递的数据\",{\"1\":{\"816\":1}}],[\"name被覆盖\",{\"1\":{\"426\":1}}],[\"names\",{\"1\":{\"343\":2,\"783\":2}}],[\"namespace\",{\"1\":{\"192\":1,\"283\":1}}],[\"name\",{\"1\":{\"77\":2,\"87\":6,\"89\":8,\"111\":9,\"116\":7,\"265\":2,\"366\":12,\"370\":3,\"371\":3,\"372\":2,\"426\":4,\"731\":5,\"758\":16,\"759\":5,\"783\":4,\"816\":7,\"934\":1,\"940\":1,\"943\":1,\"944\":2,\"1005\":1,\"1024\":3,\"1025\":12,\"1026\":2,\"1027\":9,\"1032\":6,\"1040\":5,\"1042\":4,\"1043\":1}}],[\"nowsecond\",{\"1\":{\"993\":2}}],[\"now\",{\"1\":{\"989\":2,\"990\":2,\"993\":4,\"995\":2,\"998\":2}}],[\"nosql可以翻译做not\",{\"1\":{\"1003\":1}}],[\"nosql\",{\"1\":{\"841\":1,\"1001\":1}}],[\"nosuchfileexception\",{\"1\":{\"872\":2}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"688\":1}}],[\"nosuchmethoderror\",{\"1\":{\"94\":1,\"515\":1}}],[\"nosuchmethodexception\",{\"1\":{\"94\":3,\"515\":1}}],[\"noargsconstructor\",{\"1\":{\"731\":1,\"950\":1}}],[\"nouniquebeandefinitionexception\",{\"1\":{\"688\":1}}],[\"nonblocking\",{\"1\":{\"409\":2}}],[\"nonematch\",{\"1\":{\"341\":2}}],[\"non\",{\"1\":{\"332\":1}}],[\"nonfairsync\",{\"1\":{\"261\":2}}],[\"normalize\",{\"1\":{\"871\":1}}],[\"normal\",{\"1\":{\"266\":1,\"800\":2}}],[\"nodelay\",{\"0\":{\"778\":1},\"1\":{\"751\":1}}],[\"node是否宕机了\",{\"1\":{\"433\":1}}],[\"node上\",{\"1\":{\"433\":1}}],[\"node挂掉了\",{\"1\":{\"433\":1}}],[\"node\",{\"1\":{\"255\":2,\"283\":9}}],[\"node<k\",{\"1\":{\"249\":16}}],[\"no\",{\"1\":{\"249\":1,\"429\":1}}],[\"noclassdeffounderror\",{\"1\":{\"94\":1}}],[\"notation\",{\"1\":{\"924\":1}}],[\"notblank\",{\"1\":{\"731\":3}}],[\"notify不能先notify\",{\"1\":{\"219\":1}}],[\"notifyall是唤醒所有等待线程\",{\"1\":{\"219\":1}}],[\"notify和notifyall必须配合object\",{\"1\":{\"219\":1}}],[\"notify\",{\"1\":{\"219\":1,\"224\":2,\"225\":3}}],[\"notifyobservers\",{\"1\":{\"82\":2}}],[\"not\",{\"1\":{\"111\":1,\"720\":1,\"1025\":1}}],[\"notes\",{\"1\":{\"14\":1}}],[\"noobj\",{\"1\":{\"26\":2}}],[\"n\",{\"0\":{\"777\":1},\"1\":{\"26\":1,\"135\":2,\"191\":4,\"194\":12,\"195\":10,\"249\":6,\"276\":2,\"277\":3,\"279\":1,\"283\":3,\"321\":1,\"327\":2,\"338\":2,\"381\":1,\"387\":1,\"430\":1,\"742\":1,\"749\":7,\"750\":9,\"752\":1,\"754\":23,\"755\":22,\"756\":23,\"798\":18,\"846\":17,\"849\":2,\"859\":8,\"886\":6,\"890\":4,\"909\":3}}],[\"needstoselectagain\",{\"1\":{\"791\":1}}],[\"neverregistered\",{\"1\":{\"790\":2,\"793\":2}}],[\"never\",{\"1\":{\"720\":1}}],[\"nested\",{\"1\":{\"104\":1,\"720\":2}}],[\"nextline\",{\"1\":{\"759\":3,\"804\":1,\"844\":1}}],[\"nextid\",{\"1\":{\"441\":3,\"787\":1,\"993\":2,\"995\":1,\"998\":3}}],[\"nextint\",{\"1\":{\"82\":1,\"116\":2,\"191\":2,\"194\":8,\"754\":1,\"755\":1,\"756\":1}}],[\"nextnode\",{\"1\":{\"282\":8}}],[\"nexttable\",{\"1\":{\"249\":1}}],[\"nexthand2\",{\"1\":{\"116\":3}}],[\"nexthand1\",{\"1\":{\"116\":3}}],[\"nexthand\",{\"1\":{\"116\":7}}],[\"next\",{\"1\":{\"78\":1,\"139\":2,\"249\":3,\"401\":1,\"793\":1,\"796\":4,\"799\":6,\"808\":1,\"809\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":2,\"896\":2}}],[\"new出来的对象\",{\"1\":{\"998\":1}}],[\"newr\",{\"1\":{\"990\":2}}],[\"newbuilder\",{\"1\":{\"974\":1}}],[\"newbuffer\",{\"1\":{\"890\":3}}],[\"newpos\",{\"1\":{\"867\":2}}],[\"newpromise\",{\"1\":{\"790\":1}}],[\"newproxyinstance\",{\"1\":{\"94\":3,\"510\":1,\"787\":1}}],[\"newproxyinstance方法\",{\"1\":{\"94\":1}}],[\"newline\",{\"1\":{\"818\":1,\"845\":2,\"849\":5}}],[\"newattrarray\",{\"1\":{\"790\":1}}],[\"newoptionarray\",{\"1\":{\"790\":1}}],[\"new修饰的内部方法都会开启自己的新事务\",{\"1\":{\"720\":1}}],[\"new指令之后会接着就是执行方法\",{\"1\":{\"352\":1}}],[\"new的时候可以给arraylist设置数组的长度值\",{\"1\":{\"323\":1}}],[\"newnode\",{\"1\":{\"282\":7}}],[\"newdata\",{\"1\":{\"260\":1}}],[\"newsinglethreadexecutor\",{\"1\":{\"244\":3}}],[\"newchannel\",{\"1\":{\"790\":1}}],[\"newcachedthreadpool\",{\"1\":{\"244\":2}}],[\"newcondition\",{\"1\":{\"224\":1,\"225\":1}}],[\"newfixedthreadpool\",{\"1\":{\"244\":4,\"263\":2,\"807\":1,\"989\":1,\"990\":1}}],[\"newinstance\",{\"1\":{\"77\":1,\"103\":2,\"104\":2,\"783\":1}}],[\"new\",{\"1\":{\"41\":4,\"42\":4,\"49\":5,\"52\":3,\"57\":4,\"58\":3,\"63\":3,\"65\":2,\"69\":2,\"74\":4,\"77\":2,\"78\":1,\"82\":8,\"86\":1,\"87\":1,\"89\":8,\"93\":2,\"94\":17,\"95\":2,\"101\":7,\"103\":6,\"104\":3,\"105\":3,\"108\":3,\"109\":4,\"116\":9,\"120\":2,\"123\":2,\"132\":1,\"191\":2,\"194\":8,\"195\":2,\"206\":2,\"208\":1,\"211\":1,\"221\":4,\"224\":14,\"225\":15,\"232\":1,\"236\":4,\"244\":7,\"249\":4,\"255\":7,\"260\":1,\"261\":1,\"262\":2,\"263\":2,\"268\":1,\"282\":3,\"283\":1,\"285\":1,\"287\":1,\"337\":6,\"339\":1,\"343\":1,\"351\":1,\"368\":3,\"370\":1,\"371\":2,\"441\":5,\"450\":2,\"463\":3,\"510\":2,\"512\":1,\"515\":8,\"523\":3,\"619\":2,\"622\":5,\"626\":2,\"630\":2,\"635\":6,\"638\":6,\"641\":2,\"655\":5,\"657\":1,\"670\":3,\"672\":1,\"720\":1,\"743\":3,\"744\":4,\"749\":13,\"750\":1,\"753\":6,\"754\":8,\"755\":7,\"756\":7,\"759\":29,\"760\":4,\"761\":9,\"764\":5,\"767\":5,\"768\":9,\"770\":12,\"771\":6,\"773\":20,\"775\":5,\"776\":6,\"783\":18,\"784\":1,\"785\":10,\"787\":12,\"788\":1,\"790\":12,\"791\":2,\"793\":2,\"796\":2,\"798\":18,\"799\":1,\"800\":1,\"801\":1,\"803\":19,\"804\":9,\"807\":1,\"808\":3,\"809\":3,\"810\":2,\"811\":2,\"812\":3,\"813\":3,\"814\":3,\"815\":2,\"816\":15,\"818\":1,\"822\":1,\"826\":2,\"829\":2,\"830\":4,\"834\":5,\"835\":5,\"844\":11,\"845\":14,\"846\":1,\"849\":12,\"857\":2,\"858\":4,\"870\":4,\"872\":6,\"876\":3,\"877\":2,\"884\":2,\"886\":1,\"889\":3,\"890\":2,\"893\":3,\"896\":9,\"898\":2,\"904\":3,\"907\":1,\"909\":4,\"932\":3,\"933\":3,\"934\":14,\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":3,\"945\":2,\"946\":2,\"949\":2,\"950\":3,\"961\":2,\"962\":1,\"968\":1,\"972\":1,\"974\":3,\"988\":1,\"989\":2,\"990\":3,\"993\":1,\"994\":1,\"995\":1,\"998\":3,\"1032\":1,\"1034\":2,\"1035\":1,\"1041\":2,\"1042\":2}}],[\"neck部分就是多尺度特征融合的过程\",{\"1\":{\"23\":1}}],[\"neck\",{\"0\":{\"23\":1}}],[\"neurips\",{\"1\":{\"10\":2}}],[\"network\",{\"1\":{\"839\":1}}],[\"networks\",{\"1\":{\"3\":1,\"6\":1,\"13\":1,\"14\":1}}],[\"netutil\",{\"1\":{\"776\":1}}],[\"netty概述\",{\"0\":{\"838\":1}}],[\"netty<\",{\"1\":{\"833\":1}}],[\"netty源码分析\",{\"0\":{\"789\":1}}],[\"netty优化\",{\"0\":{\"772\":1}}],[\"netty\",{\"0\":{\"808\":1,\"839\":1,\"840\":1,\"841\":1,\"842\":1,\"1054\":1},\"1\":{\"750\":2,\"751\":1,\"770\":1,\"775\":1,\"776\":2,\"781\":1,\"790\":15,\"791\":4,\"792\":6,\"793\":8,\"794\":4,\"796\":7,\"799\":1,\"805\":1,\"806\":7,\"812\":5,\"815\":18,\"820\":1,\"822\":1,\"825\":5,\"830\":1,\"835\":1,\"839\":2,\"841\":3,\"842\":4,\"845\":1}}],[\"net\",{\"1\":{\"31\":4,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"776\":3}}],[\"netron可视化yolov3网络结构\",{\"1\":{\"31\":1}}],[\"net网络结构\",{\"1\":{\"16\":1}}],[\"nets\",{\"1\":{\"10\":1,\"16\":1}}],[\"w3\",{\"1\":{\"1038\":1}}],[\"wuhan2020\",{\"1\":{\"731\":3}}],[\"welcomepagehandlermapping\",{\"1\":{\"641\":3,\"642\":1,\"643\":1}}],[\"web应用服务器接受到这个请求\",{\"1\":{\"736\":1}}],[\"websocket\",{\"1\":{\"705\":3}}],[\"webserverfactory\",{\"1\":{\"619\":2}}],[\"webmvcconfigurer\",{\"1\":{\"961\":1}}],[\"webmvc\",{\"1\":{\"705\":1}}],[\"webmvcautoconfiguration\",{\"0\":{\"665\":1}}],[\"webflux\",{\"0\":{\"746\":1},\"1\":{\"705\":4}}],[\"webapplicationcontext\",{\"1\":{\"657\":1}}],[\"webapp\",{\"1\":{\"647\":2}}],[\"webdatabinderfactory\",{\"1\":{\"590\":1}}],[\"web\",{\"0\":{\"557\":1},\"1\":{\"451\":3,\"496\":1,\"561\":1,\"634\":1,\"647\":1,\"653\":2,\"667\":1,\"668\":1,\"705\":4}}],[\"wrappedbuffer\",{\"1\":{\"830\":3}}],[\"wrapper\",{\"1\":{\"370\":3,\"371\":2}}],[\"wrapifnecessary\",{\"1\":{\"539\":1}}],[\"writevalueasstring\",{\"1\":{\"934\":4,\"1042\":1}}],[\"writehandler\",{\"1\":{\"909\":4}}],[\"writeclient\",{\"1\":{\"893\":1}}],[\"writecharsequence\",{\"1\":{\"822\":1}}],[\"writechar\",{\"1\":{\"822\":1}}],[\"writedouble\",{\"1\":{\"822\":1}}],[\"writefloat\",{\"1\":{\"822\":1}}],[\"writelong\",{\"1\":{\"822\":1}}],[\"writelock\",{\"1\":{\"260\":2}}],[\"writeserver\",{\"1\":{\"893\":1}}],[\"writes集中写\",{\"0\":{\"858\":1}}],[\"writeshort\",{\"1\":{\"822\":1}}],[\"writesd\",{\"1\":{\"41\":3,\"42\":1}}],[\"writeboolean\",{\"1\":{\"822\":1}}],[\"writebyte\",{\"1\":{\"755\":2,\"756\":2,\"770\":4,\"771\":4,\"773\":4,\"822\":1,\"826\":1}}],[\"writebytes\",{\"1\":{\"749\":1,\"750\":1,\"753\":1,\"754\":1,\"767\":24,\"768\":1,\"770\":2,\"771\":2,\"773\":2,\"798\":2,\"816\":3,\"822\":4,\"826\":2,\"829\":4,\"830\":2,\"844\":1,\"853\":1}}],[\"writeinbound\",{\"1\":{\"770\":2}}],[\"writeintle\",{\"1\":{\"822\":1}}],[\"writeint\",{\"1\":{\"770\":2,\"771\":2,\"773\":2,\"822\":2,\"823\":1}}],[\"writeoutbound\",{\"1\":{\"770\":1}}],[\"writeobject2file\",{\"1\":{\"103\":2}}],[\"writeobject\",{\"1\":{\"89\":1,\"103\":1,\"770\":1,\"771\":1,\"773\":2}}],[\"writerindex\",{\"1\":{\"818\":1}}],[\"writer\",{\"1\":{\"764\":2,\"845\":8}}],[\"writeandflush\",{\"1\":{\"749\":1,\"750\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":8,\"760\":3,\"761\":9,\"764\":1,\"767\":2,\"768\":1,\"784\":1,\"785\":1,\"787\":1,\"798\":2,\"802\":1,\"803\":3,\"804\":1,\"816\":4,\"835\":1,\"844\":2}}],[\"write系统调用\",{\"1\":{\"182\":1}}],[\"writetf\",{\"1\":{\"41\":3,\"42\":1}}],[\"write\",{\"0\":{\"892\":1,\"894\":1},\"1\":{\"41\":3,\"42\":1,\"182\":1,\"260\":1,\"396\":1,\"754\":1,\"755\":1,\"756\":1,\"776\":1,\"792\":1,\"802\":1,\"816\":16,\"818\":2,\"822\":2,\"823\":1,\"824\":3,\"826\":3,\"829\":2,\"845\":2,\"853\":2,\"858\":1,\"865\":3,\"881\":1,\"883\":1,\"884\":1,\"889\":3,\"890\":3,\"893\":12,\"904\":2,\"909\":3,\"981\":2}}],[\"which\",{\"1\":{\"849\":2}}],[\"whitelabelerrorview\",{\"1\":{\"617\":1}}],[\"while中的var1+var2\",{\"1\":{\"996\":1}}],[\"while\",{\"1\":{\"78\":1,\"191\":3,\"206\":1,\"224\":2,\"225\":4,\"234\":1,\"249\":1,\"283\":1,\"285\":2,\"287\":2,\"441\":1,\"759\":1,\"793\":2,\"794\":1,\"804\":1,\"844\":1,\"845\":2,\"846\":2,\"865\":2,\"876\":1,\"877\":1,\"884\":2,\"886\":2,\"889\":2,\"890\":2,\"893\":4,\"896\":4,\"996\":2}}],[\"where中不能使用聚合函数\",{\"1\":{\"394\":1}}],[\"where是在结果返回之前起作用的\",{\"1\":{\"394\":1}}],[\"where是一个约束声明\",{\"1\":{\"394\":1}}],[\"where和having的区别\",{\"0\":{\"394\":1}}],[\"where\",{\"1\":{\"266\":5,\"267\":1,\"366\":11,\"383\":8,\"385\":1,\"386\":3,\"968\":1,\"997\":2,\"998\":2}}],[\"when\",{\"1\":{\"249\":1}}],[\"wantedby=multi\",{\"1\":{\"1016\":1}}],[\"wangwu\",{\"1\":{\"787\":1,\"798\":8,\"934\":1,\"943\":1,\"944\":1,\"1029\":5}}],[\"walk\",{\"1\":{\"873\":1}}],[\"walkfiletree\",{\"1\":{\"872\":3}}],[\"wakenup\",{\"1\":{\"791\":5,\"792\":3}}],[\"wakeup\",{\"1\":{\"791\":9,\"792\":4,\"883\":1,\"896\":1}}],[\"wakesupfortask\",{\"1\":{\"791\":1}}],[\"was\",{\"1\":{\"790\":1,\"793\":1}}],[\"wasactive\",{\"1\":{\"790\":2}}],[\"warn\",{\"1\":{\"791\":1}}],[\"war\",{\"1\":{\"647\":1}}],[\"war项目\",{\"0\":{\"647\":1}}],[\"wait时\",{\"1\":{\"410\":2}}],[\"wait检测到描述符事件发生并将此事件通知应用程序\",{\"1\":{\"410\":2}}],[\"wait便可以收到通知\",{\"1\":{\"410\":1}}],[\"waitstatus\",{\"1\":{\"255\":1}}],[\"wait会释放锁对象\",{\"1\":{\"216\":1}}],[\"wait是object方法\",{\"1\":{\"216\":1}}],[\"wait\",{\"0\":{\"215\":1},\"1\":{\"143\":2,\"204\":1,\"219\":1,\"224\":2,\"225\":3,\"403\":1,\"410\":1,\"759\":3,\"791\":1,\"1039\":1}}],[\"waiting\",{\"1\":{\"132\":1,\"203\":1,\"208\":2,\"216\":1,\"804\":1,\"876\":1,\"898\":2}}],[\"waterproof\",{\"1\":{\"110\":5}}],[\"watch\",{\"1\":{\"30\":1}}],[\"woman\",{\"1\":{\"1027\":3}}],[\"world\",{\"0\":{\"832\":1},\"1\":{\"768\":1,\"803\":3,\"816\":1,\"833\":1,\"835\":1,\"859\":3,\"884\":1,\"889\":1}}],[\"work\",{\"1\":{\"441\":2}}],[\"workid值必须大于0并且小于\",{\"1\":{\"441\":1}}],[\"workid位需要左移的位数\",{\"1\":{\"441\":1}}],[\"workid\",{\"1\":{\"441\":1}}],[\"workid占用5个比特位\",{\"1\":{\"441\":1}}],[\"workid占用的位数\",{\"1\":{\"441\":1}}],[\"workers\",{\"1\":{\"896\":4}}],[\"workereventloops\",{\"1\":{\"896\":4}}],[\"workereventloop\",{\"1\":{\"896\":7}}],[\"worker\",{\"1\":{\"441\":7,\"749\":6,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"759\":3,\"767\":3,\"768\":3,\"783\":3,\"793\":3,\"798\":5,\"896\":9}}],[\"workerid\",{\"1\":{\"440\":1,\"441\":7}}],[\"workqueue\",{\"1\":{\"242\":2}}],[\"word中就被设置成指向monitor对象的指针\",{\"1\":{\"211\":1}}],[\"word的形式\",{\"1\":{\"210\":1}}],[\"word\",{\"1\":{\"41\":2,\"210\":2,\"353\":2}}],[\"won\",{\"1\":{\"116\":3}}],[\"windows\",{\"1\":{\"906\":1,\"1019\":1}}],[\"winner\",{\"1\":{\"116\":3}}],[\"winningstrategy\",{\"1\":{\"116\":4}}],[\"wincount++\",{\"1\":{\"116\":1}}],[\"wincount\",{\"1\":{\"116\":2}}],[\"win\",{\"1\":{\"116\":12}}],[\"with\",{\"1\":{\"14\":1,\"16\":1,\"105\":3}}],[\"w\",{\"1\":{\"26\":2,\"194\":8,\"195\":5,\"859\":2}}],[\"www\",{\"1\":{\"3\":2,\"4\":1,\"5\":1,\"6\":1,\"11\":2,\"13\":1,\"17\":1,\"30\":1,\"950\":2,\"1038\":1}}],[\"snapshot<\",{\"1\":{\"1038\":1}}],[\"snipaste\",{\"1\":{\"873\":2}}],[\"sndbuf\",{\"0\":{\"779\":1},\"1\":{\"751\":2,\"779\":1}}],[\"snowflakeidgenerator\",{\"1\":{\"441\":7}}],[\"snowflake\",{\"0\":{\"440\":1},\"1\":{\"438\":1,\"440\":1}}],[\"ss=new\",{\"1\":{\"889\":1}}],[\"ssckey\",{\"1\":{\"887\":3,\"890\":4,\"896\":2}}],[\"ssc\",{\"1\":{\"790\":1,\"876\":3,\"877\":4,\"890\":4,\"893\":5,\"896\":4,\"909\":9}}],[\"ss\",{\"1\":{\"776\":2,\"845\":2,\"889\":1}}],[\"sso\",{\"1\":{\"738\":1}}],[\"ssm\",{\"1\":{\"451\":2}}],[\"sstf\",{\"1\":{\"176\":1}}],[\"slice\",{\"0\":{\"826\":1},\"1\":{\"770\":2,\"826\":13,\"831\":1}}],[\"slf4j\",{\"1\":{\"711\":1,\"759\":2,\"762\":1,\"770\":1,\"771\":1,\"775\":1,\"783\":1,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"804\":1,\"816\":1,\"846\":1,\"884\":1,\"886\":1,\"896\":2,\"907\":1,\"950\":1,\"990\":1}}],[\"slave成为新的master后\",{\"1\":{\"437\":1}}],[\"slave的机器时钟比master走得快很多\",{\"1\":{\"437\":1}}],[\"slave是不会主动清理过期key的\",{\"1\":{\"436\":1}}],[\"slot\",{\"1\":{\"435\":1}}],[\"sleep不会释放锁对象\",{\"1\":{\"216\":1}}],[\"sleep不需要强制和synchronized配合使用\",{\"1\":{\"216\":1}}],[\"sleep是thread方法\",{\"1\":{\"216\":1}}],[\"sleep有休眠时间\",{\"1\":{\"203\":1}}],[\"sleep\",{\"0\":{\"203\":1,\"216\":1},\"1\":{\"82\":2,\"203\":1,\"204\":1,\"206\":2,\"221\":2,\"263\":2,\"743\":1,\"744\":1,\"798\":1,\"800\":1,\"801\":1,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"988\":2,\"990\":1}}],[\"smartinitializingsingleton\",{\"1\":{\"699\":1}}],[\"smallint\",{\"1\":{\"265\":1}}],[\"smembers\",{\"1\":{\"422\":1,\"1029\":3}}],[\"safesetsuccess\",{\"1\":{\"790\":2,\"793\":1}}],[\"safesetfailure\",{\"1\":{\"790\":3,\"793\":2}}],[\"sayhello\",{\"1\":{\"785\":1,\"787\":4}}],[\"sadd\",{\"1\":{\"422\":1,\"1029\":4}}],[\"saveshop2redis\",{\"1\":{\"989\":3}}],[\"savesuper\",{\"1\":{\"527\":3}}],[\"saveuser\",{\"1\":{\"961\":1,\"962\":2,\"972\":1}}],[\"saveall\",{\"1\":{\"950\":2}}],[\"save\",{\"1\":{\"109\":3,\"523\":1,\"527\":6,\"731\":1,\"732\":1,\"737\":1,\"950\":2,\"994\":3,\"995\":1,\"998\":3}}],[\"skiplist\",{\"1\":{\"1030\":1}}],[\"skip\",{\"1\":{\"338\":1}}],[\"sql汇总学生总成绩\",{\"1\":{\"740\":1}}],[\"sqlsessiontemplate\",{\"1\":{\"661\":1}}],[\"sqlsession\",{\"1\":{\"661\":2}}],[\"sqlsessionfactory\",{\"1\":{\"661\":1,\"678\":1}}],[\"sql会变成select\",{\"1\":{\"366\":1}}],[\"sql\",{\"1\":{\"268\":1,\"368\":1,\"1003\":2}}],[\"sql语句\",{\"0\":{\"267\":1}}],[\"sql性能优化的目标\",{\"1\":{\"266\":1}}],[\"sql性能\",{\"1\":{\"266\":1}}],[\"square\",{\"1\":{\"58\":5}}],[\"source\",{\"1\":{\"859\":14,\"871\":3,\"872\":6,\"873\":3,\"890\":8,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"somaxconn\",{\"1\":{\"776\":2}}],[\"something\",{\"1\":{\"260\":3}}],[\"so\",{\"0\":{\"776\":1,\"779\":2},\"1\":{\"750\":2,\"751\":2,\"775\":1,\"776\":1,\"779\":2,\"790\":1}}],[\"socket都是成对出现的\",{\"1\":{\"961\":1}}],[\"sockettimeoutexception\",{\"1\":{\"776\":1}}],[\"socket\",{\"1\":{\"776\":3,\"790\":3,\"835\":1,\"845\":4,\"884\":5,\"889\":3,\"894\":2,\"898\":1,\"904\":6,\"905\":3,\"916\":1}}],[\"socketaddress\",{\"1\":{\"775\":2,\"790\":4,\"890\":1}}],[\"socketchannal\",{\"1\":{\"775\":1,\"778\":1,\"779\":2,\"780\":1,\"781\":1}}],[\"socketchannel\",{\"1\":{\"332\":1,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"783\":2,\"785\":1,\"787\":1,\"793\":1,\"798\":2,\"834\":4,\"835\":2,\"865\":1,\"876\":6,\"877\":5,\"884\":1,\"886\":5,\"890\":5,\"893\":5,\"896\":4,\"911\":1}}],[\"socket执行读操作时\",{\"1\":{\"409\":1}}],[\"socketserverchannel\",{\"1\":{\"332\":1}}],[\"solution\",{\"1\":{\"195\":2}}],[\"sortorder\",{\"1\":{\"939\":1}}],[\"sortedset的常见命令有\",{\"1\":{\"1030\":1}}],[\"sortedset具备下列特性\",{\"1\":{\"1030\":1}}],[\"sortedset中的每一个元素都带有一个score属性\",{\"1\":{\"1030\":1}}],[\"sortedset类型\",{\"0\":{\"1030\":1}}],[\"sorted\",{\"1\":{\"340\":3,\"341\":1,\"422\":1}}],[\"sort的情况\",{\"1\":{\"266\":1}}],[\"sort\",{\"1\":{\"191\":4,\"336\":1,\"939\":1,\"950\":5}}],[\"spark\",{\"1\":{\"841\":1}}],[\"split\",{\"1\":{\"759\":2,\"859\":3,\"890\":2}}],[\"spop\",{\"1\":{\"422\":1}}],[\"spooling技术\",{\"1\":{\"184\":1}}],[\"spring对象的数据序列化及反序列化\",{\"1\":{\"1036\":1}}],[\"springdatajpa使用起来非常简单\",{\"1\":{\"1040\":1}}],[\"springdata是spring中数据操作的模块\",{\"1\":{\"1036\":1}}],[\"springdataredis的使用步骤\",{\"1\":{\"1040\":1}}],[\"springdataredis中提供了redistemplate工具类\",{\"1\":{\"1036\":1}}],[\"springdataredis\",{\"0\":{\"1036\":1}}],[\"springmvc\",{\"0\":{\"733\":1}}],[\"spring是怎么解决循环依赖的\",{\"0\":{\"724\":1}}],[\"spring是如何管理事务的\",{\"0\":{\"719\":1}}],[\"spring是如何管理bean的\",{\"0\":{\"709\":1}}],[\"spring的事务如何配置\",{\"0\":{\"721\":1}}],[\"spring的核心是ioc和aop\",{\"1\":{\"706\":1}}],[\"spring在transactiondefinition接口中规定了其中类型的事务传播行为\",{\"1\":{\"720\":1}}],[\"spring中的事务传播行为\",{\"0\":{\"720\":1}}],[\"spring提供了transactiontemplate和transactionmanager手动管理事务\",{\"1\":{\"719\":1}}],[\"spring容器关闭时调用disposablebean中的destory\",{\"1\":{\"711\":1}}],[\"spring就知道要哪些包下带声明的类需要被扫描\",{\"1\":{\"709\":1}}],[\"spring通过ioc来管理bean\",{\"1\":{\"709\":1}}],[\"spring为beanfactory提供了很多实现\",{\"1\":{\"708\":1}}],[\"spring主要提供了两种类型的容器\",{\"1\":{\"707\":1}}],[\"spring其他功能基本都需要依赖于该类库\",{\"1\":{\"705\":1}}],[\"spring4\",{\"1\":{\"705\":1}}],[\"springfactoriesloader\",{\"1\":{\"670\":1}}],[\"springframework<\",{\"1\":{\"679\":1,\"948\":1}}],[\"springframework\",{\"1\":{\"538\":1,\"541\":1,\"544\":1,\"548\":1,\"551\":1,\"555\":1,\"634\":1,\"651\":5,\"659\":1,\"660\":1,\"662\":2,\"667\":1,\"668\":1,\"931\":2,\"948\":4,\"1038\":4}}],[\"springcontext\",{\"1\":{\"657\":2}}],[\"springapplicationrunlisteners\",{\"1\":{\"650\":1,\"652\":1}}],[\"springapplication\",{\"1\":{\"648\":1,\"650\":2,\"651\":1,\"652\":2}}],[\"springboot已经提供了对springdataredis的支持\",{\"1\":{\"1037\":1}}],[\"springboottest\",{\"1\":{\"950\":1,\"1040\":1,\"1042\":1,\"1043\":1}}],[\"springboot实现登录拦截器\",{\"1\":{\"738\":1}}],[\"springbootconfiguration\",{\"1\":{\"731\":2}}],[\"springbootapplication看作是\",{\"1\":{\"731\":1}}],[\"springbootapplication\",{\"1\":{\"731\":1}}],[\"springboot\",{\"0\":{\"725\":1},\"1\":{\"450\":1}}],[\"spring\",{\"0\":{\"528\":1,\"656\":1,\"704\":1,\"715\":1,\"717\":1,\"727\":1,\"729\":1,\"730\":1,\"732\":1},\"1\":{\"372\":2,\"449\":1,\"451\":4,\"458\":1,\"461\":1,\"480\":1,\"486\":2,\"490\":1,\"495\":2,\"496\":3,\"523\":1,\"527\":1,\"528\":1,\"561\":1,\"568\":1,\"585\":1,\"600\":1,\"617\":4,\"623\":1,\"646\":3,\"647\":3,\"648\":1,\"650\":2,\"652\":2,\"659\":2,\"660\":2,\"661\":4,\"668\":1,\"670\":2,\"671\":1,\"672\":1,\"682\":2,\"686\":1,\"703\":1,\"705\":19,\"706\":2,\"715\":2,\"716\":1,\"717\":1,\"726\":4,\"727\":1,\"728\":1,\"729\":1,\"730\":2,\"731\":1,\"738\":3,\"841\":2,\"1036\":2,\"1038\":1,\"1039\":1}}],[\"spread方法会综合高位地位\",{\"1\":{\"249\":1}}],[\"spread方法能保证返回结果是正数\",{\"1\":{\"249\":1}}],[\"spread\",{\"1\":{\"249\":2}}],[\"spf\",{\"1\":{\"139\":1}}],[\"sweep\",{\"1\":{\"361\":1}}],[\"swap需要两个参数\",{\"1\":{\"142\":1}}],[\"swap指令和swap指令的区别\",{\"1\":{\"142\":1}}],[\"swap指令\",{\"1\":{\"142\":1}}],[\"switch\",{\"1\":{\"104\":1,\"527\":2,\"759\":1,\"791\":2}}],[\"srem\",{\"1\":{\"1029\":3}}],[\"src\",{\"1\":{\"276\":3,\"450\":1,\"647\":1,\"822\":3,\"1012\":1,\"1015\":2,\"1016\":1}}],[\"srnt\",{\"1\":{\"139\":1}}],[\"srtn\",{\"1\":{\"139\":1}}],[\"srome\",{\"1\":{\"14\":1}}],[\"sjf优点\",{\"1\":{\"139\":1}}],[\"sjf和spf都是非抢占式算法\",{\"1\":{\"139\":1}}],[\"sjf\",{\"1\":{\"139\":1}}],[\"s2\",{\"1\":{\"103\":4,\"336\":2,\"770\":2,\"1029\":2}}],[\"s1和s2\",{\"1\":{\"1029\":1}}],[\"s1\",{\"1\":{\"103\":4,\"336\":2,\"770\":3,\"1029\":8}}],[\"sb\",{\"1\":{\"82\":1,\"893\":3}}],[\"shards\",{\"0\":{\"927\":1}}],[\"sharable💡\",{\"0\":{\"771\":1}}],[\"sharable\",{\"1\":{\"760\":2,\"761\":5,\"762\":1,\"771\":2,\"784\":1,\"786\":1,\"788\":1}}],[\"shapetype\",{\"1\":{\"58\":5}}],[\"shapefactory\",{\"1\":{\"58\":2}}],[\"shape\",{\"1\":{\"58\":6}}],[\"shuangkou\",{\"1\":{\"731\":1}}],[\"shutdowngracefully\",{\"1\":{\"749\":3,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":3,\"767\":1,\"768\":2,\"775\":1,\"783\":3,\"785\":1,\"787\":1,\"797\":1,\"804\":1,\"844\":1}}],[\"shutdown\",{\"1\":{\"241\":1,\"791\":1,\"1015\":2}}],[\"shift\",{\"1\":{\"441\":6}}],[\"shopmap\",{\"1\":{\"983\":1}}],[\"shopjson\",{\"1\":{\"983\":2,\"985\":4,\"988\":4,\"989\":3,\"990\":4}}],[\"shopserviceimpl\",{\"1\":{\"989\":1}}],[\"shopservice\",{\"1\":{\"977\":1,\"989\":1}}],[\"shop\",{\"1\":{\"961\":2,\"983\":17,\"985\":14,\"988\":17,\"989\":14,\"990\":21}}],[\"should\",{\"1\":{\"941\":1}}],[\"shouldbreakreadready\",{\"1\":{\"794\":1}}],[\"shortbuffer\",{\"1\":{\"332\":1,\"911\":1}}],[\"short\",{\"1\":{\"320\":1,\"822\":1,\"849\":2}}],[\"shortest\",{\"1\":{\"139\":3}}],[\"show\",{\"1\":{\"87\":3,\"89\":5}}],[\"showbike\",{\"1\":{\"49\":3}}],[\"syn锁失效的原因\",{\"1\":{\"999\":1}}],[\"syn\",{\"1\":{\"776\":5}}],[\"syncookies\",{\"1\":{\"776\":1}}],[\"sync\",{\"1\":{\"261\":2,\"262\":2,\"749\":4,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"759\":4,\"767\":2,\"768\":2,\"775\":2,\"776\":3,\"783\":4,\"785\":2,\"787\":1,\"798\":2,\"802\":1,\"803\":5,\"804\":2,\"806\":1,\"812\":2,\"813\":1,\"835\":2,\"844\":1}}],[\"synchronousqueue是一种特殊的队列\",{\"1\":{\"244\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"244\":1}}],[\"synchronizedqueue\",{\"1\":{\"242\":1}}],[\"synchronized是基于悲观锁的思想\",{\"1\":{\"231\":1}}],[\"synchronized代码块内部是不能保证指令重排的\",{\"1\":{\"229\":1}}],[\"synchronized的有序性是持有相同锁的两个同步块只能串行的进入\",{\"1\":{\"229\":1}}],[\"synchronized还可以修饰方法\",{\"1\":{\"228\":1}}],[\"synchronized语句块既能保证代码块的原子性\",{\"1\":{\"228\":1}}],[\"synchronized必须是进入同一个锁对象的monitor才有上述的效果\",{\"1\":{\"211\":1}}],[\"synchronized\",{\"1\":{\"57\":2,\"101\":3,\"103\":1,\"104\":1,\"211\":1,\"219\":1,\"221\":4,\"224\":2,\"225\":2,\"249\":1,\"441\":1,\"787\":1,\"790\":4,\"998\":4}}],[\"sys快照比较\",{\"1\":{\"393\":1}}],[\"sys\",{\"1\":{\"393\":1,\"410\":1,\"776\":2}}],[\"systemctl\",{\"1\":{\"1016\":6}}],[\"systemd\",{\"1\":{\"1016\":1}}],[\"system\",{\"0\":{\"357\":1},\"1\":{\"41\":7,\"42\":5,\"49\":2,\"52\":2,\"58\":3,\"69\":2,\"78\":1,\"82\":4,\"86\":3,\"87\":1,\"89\":3,\"93\":2,\"94\":3,\"95\":2,\"103\":2,\"105\":3,\"108\":2,\"109\":7,\"110\":5,\"111\":2,\"116\":6,\"120\":7,\"125\":1,\"191\":2,\"194\":4,\"206\":2,\"232\":10,\"235\":1,\"282\":2,\"336\":2,\"338\":1,\"339\":3,\"340\":1,\"341\":2,\"342\":3,\"343\":9,\"355\":1,\"441\":8,\"450\":3,\"463\":5,\"500\":2,\"510\":3,\"512\":3,\"515\":4,\"523\":2,\"622\":1,\"647\":1,\"732\":1,\"743\":2,\"744\":4,\"759\":15,\"767\":1,\"776\":6,\"787\":3,\"791\":2,\"792\":2,\"796\":4,\"798\":1,\"804\":1,\"815\":4,\"818\":1,\"824\":5,\"826\":8,\"829\":3,\"830\":3,\"834\":1,\"844\":3,\"845\":2,\"849\":6,\"855\":2,\"859\":1,\"870\":4,\"871\":2,\"872\":6,\"873\":3,\"876\":1,\"884\":3,\"886\":1,\"889\":1,\"890\":1,\"893\":4,\"898\":1,\"907\":1,\"908\":1,\"909\":5,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":3,\"993\":4,\"1016\":1,\"1032\":3,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"signup\",{\"1\":{\"731\":1,\"732\":1,\"737\":1}}],[\"sign\",{\"1\":{\"731\":1,\"732\":1,\"737\":1}}],[\"signal\",{\"1\":{\"224\":2,\"225\":3,\"409\":1}}],[\"signal原语简称为p\",{\"1\":{\"143\":1}}],[\"sismember\",{\"1\":{\"422\":1,\"1029\":5}}],[\"simplefilevisitor<path>\",{\"1\":{\"872\":3}}],[\"simplechannelinboundhandler<string>\",{\"1\":{\"834\":1}}],[\"simplechannelinboundhandler<rpcresponsemessage>\",{\"1\":{\"786\":1,\"788\":1}}],[\"simplechannelinboundhandler<rpcrequestmessage>\",{\"1\":{\"784\":1}}],[\"simplechannelinboundhandler<httprequest>\",{\"1\":{\"768\":1}}],[\"simplechannelinboundhandler<groupmembersrequestmessage>\",{\"1\":{\"761\":1}}],[\"simplechannelinboundhandler<groupquitrequestmessage>\",{\"1\":{\"761\":1}}],[\"simplechannelinboundhandler<groupjoinrequestmessage>\",{\"1\":{\"761\":1}}],[\"simplechannelinboundhandler<groupchatrequestmessage>\",{\"1\":{\"761\":1}}],[\"simplechannelinboundhandler<groupcreaterequestmessage>\",{\"1\":{\"761\":1}}],[\"simplechannelinboundhandler<chatrequestmessage>\",{\"1\":{\"760\":1}}],[\"simplechannelinboundhandler<loginrequestmessage>\",{\"1\":{\"759\":1,\"760\":1}}],[\"simplecontrollerhandleradapter\",{\"0\":{\"624\":1},\"1\":{\"626\":3,\"627\":1,\"641\":3,\"642\":1,\"643\":1}}],[\"simplecoffeefactory\",{\"1\":{\"63\":1,\"65\":1}}],[\"simpleurlhandlermapping\",{\"0\":{\"632\":1},\"1\":{\"635\":4,\"636\":2,\"643\":1}}],[\"simpletypeconverter\",{\"1\":{\"576\":1,\"579\":1}}],[\"simple\",{\"1\":{\"275\":1}}],[\"size的子集合\",{\"1\":{\"268\":1}}],[\"size计算实际发生在put\",{\"1\":{\"249\":1}}],[\"size计算流程\",{\"1\":{\"249\":1}}],[\"size\",{\"1\":{\"249\":3,\"268\":3,\"283\":3,\"328\":2,\"441\":1,\"751\":1,\"793\":3,\"868\":1,\"870\":6,\"938\":1}}],[\"sizectl\",{\"1\":{\"249\":2}}],[\"sizeof\",{\"1\":{\"192\":1,\"277\":2}}],[\"sinter\",{\"1\":{\"1029\":3}}],[\"sinterstore\",{\"1\":{\"422\":1}}],[\"singlethreadeventexecutor$5\",{\"1\":{\"812\":1,\"815\":2}}],[\"singlethreadeventexecutor\",{\"1\":{\"791\":4,\"812\":1,\"815\":2}}],[\"singletonobjects\",{\"1\":{\"449\":1,\"678\":1}}],[\"singleton类\",{\"1\":{\"103\":2,\"104\":1}}],[\"singletonholder\",{\"1\":{\"101\":2,\"103\":2,\"104\":3,\"932\":3}}],[\"singleton\",{\"0\":{\"500\":1},\"1\":{\"99\":1,\"101\":39,\"103\":24,\"104\":12,\"496\":2,\"499\":1,\"710\":1}}],[\"singleton4\",{\"1\":{\"57\":6}}],[\"singleton3\",{\"1\":{\"57\":5}}],[\"singleton2\",{\"1\":{\"57\":5}}],[\"singleton1\",{\"1\":{\"57\":5}}],[\"since\",{\"1\":{\"194\":2,\"1024\":2,\"1025\":1}}],[\"site\",{\"1\":{\"19\":1}}],[\"sckey\",{\"1\":{\"887\":1,\"890\":4,\"893\":5,\"896\":2}}],[\"score\",{\"1\":{\"1030\":1}}],[\"scoket\",{\"1\":{\"834\":1}}],[\"scope注解修改bean的作用域\",{\"1\":{\"710\":1}}],[\"scope用于声明bean的作用域\",{\"1\":{\"709\":1}}],[\"scope>\",{\"1\":{\"648\":1,\"931\":1,\"948\":2,\"1032\":1,\"1038\":1}}],[\"scopedproxymode\",{\"1\":{\"496\":1,\"503\":1}}],[\"scope\",{\"0\":{\"496\":1,\"500\":1},\"1\":{\"454\":1,\"496\":4,\"499\":3,\"500\":1,\"503\":3}}],[\"scattering\",{\"0\":{\"857\":1}}],[\"scala\",{\"1\":{\"440\":1}}],[\"scard\",{\"1\":{\"422\":1,\"1029\":3}}],[\"scavenge和serial\",{\"1\":{\"360\":1}}],[\"scavenge\",{\"1\":{\"360\":4}}],[\"scanner\",{\"1\":{\"191\":2,\"194\":6,\"759\":6,\"804\":4,\"844\":4}}],[\"scan\",{\"1\":{\"176\":2}}],[\"schemalocation=\",{\"1\":{\"1038\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"801\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"796\":1}}],[\"scheduledtask\",{\"1\":{\"792\":2}}],[\"scheduled注解实现的\",{\"1\":{\"296\":1}}],[\"schedule\",{\"1\":{\"775\":2}}],[\"schmidhuber在2016年nips大会上打断goodfellow的gan\",{\"1\":{\"12\":1}}],[\"sc\",{\"1\":{\"191\":3,\"194\":10,\"876\":5,\"877\":5,\"884\":2,\"886\":7,\"890\":10,\"893\":12,\"896\":11,\"909\":23}}],[\"screen=\",{\"1\":{\"52\":2}}],[\"screen\",{\"1\":{\"52\":17}}],[\"s\",{\"0\":{\"45\":3,\"1048\":1},\"1\":{\"143\":2,\"144\":2,\"336\":4,\"341\":2,\"398\":3,\"400\":1,\"574\":1,\"742\":2,\"759\":11,\"776\":3,\"845\":6,\"889\":2,\"907\":2,\"909\":6}}],[\"seckillvoucherservice\",{\"1\":{\"994\":1,\"995\":2,\"996\":1,\"997\":2,\"998\":4}}],[\"seckillvoucher\",{\"1\":{\"994\":8,\"995\":6,\"998\":2}}],[\"seckill\",{\"1\":{\"994\":3}}],[\"seconds\",{\"1\":{\"244\":1,\"801\":1,\"988\":1,\"990\":1}}],[\"sex\",{\"1\":{\"934\":2,\"941\":1,\"1027\":7}}],[\"sexyyolo\",{\"1\":{\"31\":1}}],[\"sendcode\",{\"1\":{\"960\":1}}],[\"sendfile\",{\"1\":{\"905\":1}}],[\"send\",{\"1\":{\"753\":2,\"759\":2,\"776\":1,\"898\":1}}],[\"sending\",{\"1\":{\"749\":1,\"753\":1,\"754\":2,\"755\":2,\"756\":2}}],[\"sentinel\",{\"1\":{\"433\":1,\"1012\":1}}],[\"session他是每个用户都有自己的session\",{\"1\":{\"966\":1}}],[\"session拷贝数据时\",{\"1\":{\"963\":1}}],[\"session共享问题\",{\"0\":{\"963\":1}}],[\"session共享一个bean\",{\"1\":{\"710\":1}}],[\"sessionfactory\",{\"1\":{\"760\":2,\"762\":2}}],[\"session的工作原理和使用经验\",{\"1\":{\"738\":1}}],[\"session\",{\"0\":{\"497\":1},\"1\":{\"496\":1,\"499\":2,\"710\":2,\"758\":1,\"960\":6,\"961\":2,\"962\":1,\"968\":1}}],[\"sequenceidgenerator\",{\"1\":{\"787\":1}}],[\"sequenceid\",{\"1\":{\"770\":2,\"771\":2,\"773\":4,\"783\":2,\"787\":3}}],[\"sequence\",{\"1\":{\"441\":13,\"822\":1}}],[\"searchhits\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"searchresponse\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"searchrequest\",{\"1\":{\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"searchsourcebuilder\",{\"1\":{\"936\":1,\"937\":1,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"searchprefix\",{\"1\":{\"282\":2}}],[\"search\",{\"1\":{\"282\":2,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":1}}],[\"seat\",{\"1\":{\"49\":5}}],[\"selectedselectionkeyset\",{\"1\":{\"792\":2}}],[\"selectedkeys\",{\"1\":{\"792\":4,\"793\":1,\"884\":1,\"886\":2,\"887\":3,\"890\":3,\"893\":2,\"896\":2}}],[\"selectrebuildselector\",{\"1\":{\"792\":1}}],[\"selectdeadlinenanos\",{\"1\":{\"792\":2}}],[\"selectcnt\",{\"1\":{\"792\":11}}],[\"selectstrategy\",{\"1\":{\"791\":5}}],[\"selectnowsupplier\",{\"1\":{\"791\":1}}],[\"selectnow\",{\"1\":{\"791\":1,\"792\":2,\"882\":1,\"884\":1,\"886\":1,\"896\":1}}],[\"selectionkey\",{\"1\":{\"790\":10,\"792\":5,\"793\":8,\"881\":1,\"884\":2,\"886\":3,\"890\":8,\"893\":9,\"896\":6}}],[\"selectimports\",{\"1\":{\"670\":1,\"671\":1}}],[\"select低效是因为每次它都需要轮询\",{\"1\":{\"410\":1}}],[\"select和poll的性能可能比epoll好\",{\"1\":{\"410\":1}}],[\"select和poll都需要在返回后\",{\"1\":{\"410\":1}}],[\"select和recvfrom\",{\"1\":{\"409\":1}}],[\"select最大的缺陷就是单个进程所打开的fd数量是有一定限制的\",{\"1\":{\"410\":1}}],[\"select的一个缺点在于单个进程能够监视文件描述符的数量存在最大限制\",{\"1\":{\"410\":1}}],[\"select目前几乎在所有的平台上支持\",{\"1\":{\"410\":1}}],[\"select函数监视的文件描述符分3类\",{\"1\":{\"410\":1}}],[\"select函数就可以返回\",{\"1\":{\"409\":1}}],[\"select就会返回\",{\"1\":{\"409\":1}}],[\"select语句只有zipcode命中了联合索引\",{\"1\":{\"385\":1}}],[\"selectlist\",{\"1\":{\"370\":1}}],[\"select=\",{\"1\":{\"366\":1}}],[\"select>\",{\"1\":{\"366\":3}}],[\"selectorautorebuildthreshold\",{\"1\":{\"792\":1}}],[\"selector用于监听多个通道事件\",{\"1\":{\"334\":1}}],[\"selector能够检测到多个注册通道上是否有事件发生\",{\"1\":{\"332\":1}}],[\"selector会根据不同的事件\",{\"1\":{\"332\":1}}],[\"selector\",{\"0\":{\"879\":1,\"912\":1,\"917\":1},\"1\":{\"332\":2,\"790\":9,\"791\":2,\"792\":13,\"793\":3,\"796\":1,\"834\":1,\"878\":4,\"879\":1,\"880\":3,\"881\":3,\"882\":3,\"883\":3,\"884\":7,\"886\":8,\"888\":1,\"890\":10,\"893\":16,\"896\":4,\"900\":1,\"912\":1,\"917\":2}}],[\"select\",{\"0\":{\"410\":1,\"883\":1},\"1\":{\"266\":2,\"267\":4,\"366\":7,\"383\":1,\"385\":1,\"386\":4,\"405\":1,\"409\":2,\"410\":3,\"791\":9,\"792\":8,\"793\":1,\"882\":2,\"884\":2,\"886\":6,\"887\":1,\"890\":3,\"893\":2,\"896\":2,\"917\":2,\"968\":1,\"1021\":1,\"1032\":1,\"1035\":1}}],[\"selfinterrupt\",{\"1\":{\"255\":1}}],[\"sell\",{\"1\":{\"93\":5,\"94\":8,\"95\":2}}],[\"selltickets\",{\"1\":{\"93\":3,\"94\":17}}],[\"semaphore等待\",{\"1\":{\"1031\":1}}],[\"semaphore传入的参数permits最终设置为state的个数\",{\"1\":{\"261\":1}}],[\"semaphore的构造函数\",{\"1\":{\"261\":1}}],[\"semaphore有一个构造函数\",{\"1\":{\"261\":1}}],[\"semaphore\",{\"0\":{\"261\":1},\"1\":{\"251\":1,\"261\":1}}],[\"segment\",{\"1\":{\"751\":2}}],[\"segment继承了reentrancelock\",{\"1\":{\"249\":1}}],[\"segmentfault\",{\"1\":{\"197\":2}}],[\"servletwebserverfactory\",{\"1\":{\"663\":1}}],[\"servletwebserverfactoryautoconfiguration\",{\"0\":{\"663\":1}}],[\"servletregistrationbean\",{\"1\":{\"657\":3}}],[\"servletrequestdatabinderfactory\",{\"1\":{\"582\":1}}],[\"servletrequestdatabinder\",{\"1\":{\"576\":1,\"579\":1}}],[\"servletexception\",{\"1\":{\"655\":1,\"657\":1}}],[\"servletcontext\",{\"1\":{\"655\":1,\"657\":1}}],[\"servletcontextscope\",{\"1\":{\"499\":1}}],[\"servletcontainerinitializer\",{\"1\":{\"655\":1,\"657\":1}}],[\"servletinitializer\",{\"1\":{\"648\":1}}],[\"servletinvocablehandlermethod\",{\"1\":{\"590\":1,\"644\":2}}],[\"servlet\",{\"1\":{\"451\":1,\"499\":1,\"634\":1,\"644\":2,\"653\":2,\"655\":1,\"657\":1,\"668\":2,\"705\":1}}],[\"serviceclass\",{\"1\":{\"787\":4}}],[\"servicesfactory\",{\"1\":{\"783\":1,\"784\":1}}],[\"service用于声明业务层的bean\",{\"1\":{\"709\":1}}],[\"serviceimpl<usermapper\",{\"1\":{\"372\":1}}],[\"service\",{\"1\":{\"372\":1,\"653\":1,\"709\":1,\"712\":1,\"783\":4,\"784\":3,\"785\":1,\"787\":4,\"807\":2,\"961\":1,\"1016\":2}}],[\"server时的命令\",{\"1\":{\"1015\":1}}],[\"server命令即可启动redis\",{\"1\":{\"1014\":1}}],[\"servers\",{\"1\":{\"839\":1}}],[\"serversocket\",{\"1\":{\"776\":2,\"845\":2,\"887\":1,\"889\":2}}],[\"serversocketchannelimpl\",{\"1\":{\"886\":1}}],[\"serversocketchannel\",{\"1\":{\"790\":7,\"793\":1,\"798\":2,\"834\":2,\"876\":3,\"877\":4,\"884\":4,\"886\":4,\"890\":4,\"893\":2,\"896\":4,\"911\":1}}],[\"serversocketchannelconfig\",{\"1\":{\"776\":1}}],[\"serversocketchannal\",{\"1\":{\"776\":1,\"779\":2}}],[\"serverbootstrapacceptor\",{\"1\":{\"790\":3,\"793\":2}}],[\"serverbootstrap\",{\"1\":{\"749\":7,\"750\":2,\"759\":7,\"768\":7,\"783\":7,\"790\":2,\"793\":2,\"798\":2,\"816\":1,\"834\":1,\"844\":1}}],[\"server\",{\"1\":{\"429\":1,\"499\":1,\"617\":1,\"653\":1,\"668\":1,\"749\":1,\"759\":1,\"768\":1,\"773\":1,\"776\":7,\"783\":3,\"785\":1,\"790\":1,\"800\":2,\"801\":2,\"816\":3,\"835\":1,\"844\":2,\"889\":1,\"890\":1,\"898\":2,\"909\":1,\"1009\":1,\"1012\":1,\"1014\":1,\"1015\":1,\"1016\":2}}],[\"server性能更好\",{\"1\":{\"409\":1}}],[\"server不一定比使用multi\",{\"1\":{\"409\":1}}],[\"servertimezone=gmt\",{\"1\":{\"372\":1}}],[\"serve\",{\"1\":{\"139\":1}}],[\"serialize\",{\"1\":{\"773\":4}}],[\"serializeralgorithm\",{\"1\":{\"773\":9}}],[\"serializer\",{\"1\":{\"773\":11,\"783\":1}}],[\"serializertype\",{\"1\":{\"770\":2,\"771\":2,\"773\":1}}],[\"serializable\",{\"1\":{\"94\":1,\"103\":1,\"104\":1,\"773\":1,\"783\":1}}],[\"serial\",{\"1\":{\"360\":9,\"361\":1}}],[\"seed2\",{\"1\":{\"116\":2}}],[\"seed1\",{\"1\":{\"116\":2}}],[\"seed\",{\"1\":{\"116\":4}}],[\"setvalueserializer\",{\"1\":{\"1041\":1}}],[\"setvoucherid\",{\"1\":{\"994\":1,\"995\":1,\"998\":3}}],[\"sethashvalueserializer\",{\"1\":{\"1041\":1}}],[\"sethashkeyserializer\",{\"1\":{\"1041\":1}}],[\"setharddisk\",{\"1\":{\"109\":3}}],[\"setkeyserializer\",{\"1\":{\"1041\":1}}],[\"set中的指定元素自增\",{\"1\":{\"1030\":1}}],[\"set中的指定元素的score值\",{\"1\":{\"1030\":1}}],[\"set中的元素个数\",{\"1\":{\"1030\":1}}],[\"set中的一个指定元素\",{\"1\":{\"1030\":1}}],[\"set类型的常见命令\",{\"1\":{\"1029\":1}}],[\"set命令\",{\"0\":{\"1029\":1}}],[\"setnx\",{\"1\":{\"1025\":6}}],[\"setname\",{\"1\":{\"87\":3,\"89\":3}}],[\"setendtime\",{\"1\":{\"994\":1}}],[\"setex\",{\"1\":{\"1025\":3}}],[\"setexpiretime\",{\"1\":{\"989\":1,\"990\":1}}],[\"setexceptionvalue\",{\"1\":{\"784\":1}}],[\"setex等\",{\"1\":{\"422\":1}}],[\"setwithlogicexpire\",{\"1\":{\"990\":2}}],[\"setdata\",{\"1\":{\"989\":1,\"990\":1}}],[\"setdefaultencoding\",{\"1\":{\"450\":1}}],[\"setid\",{\"1\":{\"995\":1,\"998\":3}}],[\"setifabsent\",{\"1\":{\"988\":1,\"990\":1}}],[\"setignorenullvalue\",{\"1\":{\"968\":1}}],[\"setint\",{\"1\":{\"768\":1}}],[\"setincludeexception\",{\"1\":{\"622\":1}}],[\"setup\",{\"1\":{\"1032\":1,\"1035\":1}}],[\"setuserid\",{\"1\":{\"995\":1,\"998\":3}}],[\"setuncancellable\",{\"1\":{\"790\":2,\"793\":1}}],[\"seturlmap\",{\"1\":{\"635\":1}}],[\"setreturnvalue\",{\"1\":{\"784\":1}}],[\"setresourceresolvers\",{\"1\":{\"638\":1}}],[\"setter\",{\"1\":{\"731\":1}}],[\"setter方法注入\",{\"1\":{\"706\":1}}],[\"settablenamehandler\",{\"1\":{\"368\":1}}],[\"setport\",{\"1\":{\"655\":1}}],[\"setlocations\",{\"1\":{\"635\":2,\"638\":1}}],[\"setbegintime\",{\"1\":{\"994\":1}}],[\"setbyte\",{\"1\":{\"826\":2}}],[\"setbasedir\",{\"1\":{\"655\":1}}],[\"setbasename\",{\"1\":{\"450\":1}}],[\"setblockdatamode\",{\"1\":{\"104\":1}}],[\"set<selectionkey>\",{\"1\":{\"884\":1,\"886\":1,\"896\":1}}],[\"set<string>\",{\"1\":{\"758\":2,\"759\":1,\"761\":2,\"783\":1}}],[\"set<class<\",{\"1\":{\"655\":1,\"657\":1}}],[\"set<long>\",{\"1\":{\"441\":1}}],[\"set<object>\",{\"1\":{\"77\":1}}],[\"set的底层实现\",{\"1\":{\"425\":1}}],[\"set\",{\"1\":{\"268\":1,\"272\":1,\"422\":3,\"426\":2,\"441\":5,\"500\":2,\"758\":1,\"759\":4,\"767\":3,\"790\":1,\"793\":1,\"810\":2,\"811\":2,\"812\":2,\"813\":2,\"814\":2,\"822\":1,\"962\":1,\"983\":1,\"985\":2,\"988\":2,\"989\":1,\"990\":7,\"994\":1,\"997\":1,\"998\":2,\"1024\":2,\"1025\":6,\"1030\":4,\"1032\":1,\"1040\":1,\"1042\":2}}],[\"set则是需要借助一个共享变量来实现互斥\",{\"1\":{\"142\":1}}],[\"setfieldvalueeditor\",{\"1\":{\"968\":1}}],[\"setfailure\",{\"1\":{\"788\":1,\"790\":3,\"806\":1,\"809\":1,\"812\":1,\"813\":1,\"814\":1}}],[\"setfans\",{\"1\":{\"111\":1}}],[\"setf\",{\"1\":{\"500\":6}}],[\"setframe\",{\"1\":{\"49\":3}}],[\"setattribute\",{\"1\":{\"758\":1,\"960\":2,\"962\":1}}],[\"setapplicationcontext\",{\"1\":{\"491\":1}}],[\"setaccessible\",{\"1\":{\"103\":1,\"235\":1}}],[\"setaddress\",{\"1\":{\"89\":1}}],[\"setcharat\",{\"1\":{\"849\":2}}],[\"setchanneloptions\",{\"1\":{\"790\":1,\"793\":1}}],[\"setclosed\",{\"1\":{\"790\":2,\"793\":2}}],[\"setconnectionfactory\",{\"1\":{\"1041\":1}}],[\"setconnector\",{\"1\":{\"655\":1}}],[\"setcontenttype\",{\"1\":{\"622\":1}}],[\"setcorepoolsize\",{\"1\":{\"244\":1}}],[\"setcompany\",{\"1\":{\"111\":1}}],[\"setcallbacks\",{\"1\":{\"523\":1}}],[\"setcallback\",{\"1\":{\"95\":1}}],[\"setcpu\",{\"1\":{\"52\":1,\"109\":3}}],[\"setminidle\",{\"1\":{\"1034\":1}}],[\"setmaxwaitmillis\",{\"1\":{\"1034\":1}}],[\"setmaxidle\",{\"1\":{\"1034\":1}}],[\"setmaxtotal\",{\"1\":{\"1034\":1}}],[\"setmainboard\",{\"1\":{\"52\":1}}],[\"setmemory\",{\"1\":{\"52\":1,\"109\":3}}],[\"setsql\",{\"1\":{\"995\":1,\"996\":1,\"997\":2,\"998\":3}}],[\"setsuccess\",{\"1\":{\"788\":1,\"806\":1,\"809\":1,\"810\":1,\"811\":1}}],[\"setsuperclass\",{\"1\":{\"95\":1}}],[\"setsequenceid\",{\"1\":{\"773\":1,\"783\":1,\"784\":1}}],[\"setseat\",{\"1\":{\"49\":3}}],[\"setsize宏定义\",{\"1\":{\"410\":1}}],[\"setsize设置\",{\"1\":{\"410\":1}}],[\"setstock\",{\"1\":{\"994\":1}}],[\"setstatus\",{\"1\":{\"961\":1,\"972\":1}}],[\"setstate\",{\"1\":{\"261\":1}}],[\"setstar\",{\"1\":{\"111\":1}}],[\"setstu\",{\"1\":{\"89\":3}}],[\"setscreen\",{\"1\":{\"52\":1}}],[\"se\",{\"1\":{\"44\":1}}],[\"sdiff\",{\"1\":{\"1029\":3}}],[\"sdshdr64\",{\"1\":{\"277\":2}}],[\"sdshdr32\",{\"1\":{\"277\":5}}],[\"sdshdr16\",{\"1\":{\"277\":6}}],[\"sdshdr8\",{\"1\":{\"277\":2}}],[\"sdshdr5\",{\"1\":{\"277\":2}}],[\"sds\",{\"0\":{\"275\":1,\"277\":1},\"1\":{\"275\":3,\"276\":1,\"277\":28}}],[\"sdadaptertf\",{\"1\":{\"41\":3,\"42\":5}}],[\"sd兼容tf\",{\"1\":{\"41\":1,\"42\":1}}],[\"sd\",{\"1\":{\"41\":4,\"44\":2}}],[\"sd卡实现类\",{\"1\":{\"41\":1}}],[\"sd卡的接口\",{\"1\":{\"41\":1}}],[\"sdcardimpl\",{\"1\":{\"41\":2,\"42\":1}}],[\"sdcard\",{\"1\":{\"41\":10,\"42\":4}}],[\"stock=\",{\"1\":{\"996\":1,\"997\":2,\"998\":1}}],[\"stock\",{\"1\":{\"994\":1,\"995\":2,\"996\":1,\"997\":8,\"998\":13}}],[\"stoped\",{\"1\":{\"749\":1}}],[\"stop\",{\"1\":{\"206\":2,\"241\":1,\"1016\":1}}],[\"stop标志\",{\"1\":{\"33\":1}}],[\"step7\",{\"1\":{\"651\":1}}],[\"step6\",{\"1\":{\"651\":1}}],[\"step5\",{\"1\":{\"651\":1}}],[\"step4\",{\"1\":{\"651\":1}}],[\"step3\",{\"1\":{\"651\":1}}],[\"std\",{\"1\":{\"192\":1,\"283\":1}}],[\"stdc++\",{\"1\":{\"192\":1,\"283\":1}}],[\"standardopenoption\",{\"1\":{\"907\":1}}],[\"standardcopyoption\",{\"1\":{\"872\":4}}],[\"standardconfigdatalocationresolver\",{\"1\":{\"650\":1}}],[\"standardcharsets\",{\"1\":{\"773\":2,\"855\":2,\"898\":1}}],[\"standardservletmultipartresolver\",{\"1\":{\"667\":1}}],[\"stamp别修改过了\",{\"1\":{\"260\":1}}],[\"stamp\",{\"1\":{\"260\":12}}],[\"stampedlock的缺点\",{\"1\":{\"260\":1}}],[\"stampedlock支持tryoptimisticread\",{\"1\":{\"260\":1}}],[\"stampedlock\",{\"0\":{\"260\":1}}],[\"startindex\",{\"1\":{\"849\":3}}],[\"starting\",{\"1\":{\"650\":1}}],[\"startthread\",{\"1\":{\"791\":1}}],[\"starttime\",{\"1\":{\"441\":2}}],[\"starters提供的依赖\",{\"1\":{\"730\":1}}],[\"starter导入包\",{\"1\":{\"729\":1}}],[\"starter\",{\"1\":{\"727\":1,\"931\":1,\"948\":2,\"1038\":3,\"1040\":1}}],[\"starter有什么用\",{\"0\":{\"727\":1},\"1\":{\"729\":1}}],[\"starter<\",{\"1\":{\"372\":2,\"931\":1}}],[\"started\",{\"1\":{\"650\":1}}],[\"start是启动线程作用是将线程变为就绪状态\",{\"1\":{\"202\":1}}],[\"start\",{\"0\":{\"202\":1},\"1\":{\"202\":1,\"206\":3,\"221\":2,\"224\":6,\"225\":6,\"268\":3,\"646\":2,\"655\":1,\"749\":2,\"759\":1,\"800\":2,\"801\":2,\"804\":1,\"809\":1,\"810\":2,\"811\":2,\"812\":2,\"813\":2,\"814\":2,\"844\":1,\"845\":4,\"849\":1,\"870\":2,\"873\":2,\"896\":9,\"1016\":1}}],[\"star\",{\"1\":{\"111\":11,\"1028\":1}}],[\"statementname\",{\"1\":{\"268\":1}}],[\"state再次设置为0\",{\"1\":{\"261\":1}}],[\"state\",{\"1\":{\"258\":1,\"261\":1,\"764\":2}}],[\"state枚举描述的\",{\"1\":{\"208\":1}}],[\"station\",{\"1\":{\"93\":2,\"94\":8}}],[\"static\",{\"1\":{\"41\":1,\"42\":1,\"49\":2,\"52\":3,\"57\":8,\"65\":1,\"77\":3,\"78\":1,\"82\":1,\"86\":1,\"87\":1,\"89\":2,\"93\":1,\"94\":9,\"95\":1,\"101\":17,\"103\":9,\"104\":5,\"105\":3,\"108\":1,\"109\":1,\"116\":7,\"120\":1,\"191\":2,\"194\":2,\"206\":1,\"211\":3,\"221\":1,\"224\":8,\"225\":13,\"232\":1,\"244\":3,\"249\":5,\"282\":5,\"317\":1,\"336\":2,\"337\":1,\"339\":2,\"441\":11,\"450\":1,\"463\":3,\"491\":1,\"500\":2,\"510\":2,\"512\":2,\"515\":4,\"523\":1,\"635\":1,\"638\":1,\"641\":1,\"655\":1,\"670\":4,\"672\":2,\"686\":1,\"721\":1,\"731\":1,\"743\":1,\"744\":2,\"749\":4,\"753\":3,\"754\":2,\"755\":2,\"756\":2,\"759\":2,\"773\":24,\"775\":1,\"776\":2,\"783\":9,\"785\":1,\"787\":6,\"788\":1,\"790\":1,\"798\":1,\"799\":1,\"804\":1,\"816\":2,\"818\":1,\"825\":1,\"826\":1,\"845\":2,\"846\":1,\"849\":12,\"859\":2,\"870\":1,\"872\":1,\"884\":2,\"886\":1,\"889\":2,\"890\":2,\"893\":2,\"896\":3,\"898\":2,\"907\":1,\"909\":5,\"932\":5,\"962\":4,\"974\":3,\"989\":1,\"990\":1,\"993\":2,\"1034\":3,\"1042\":1}}],[\"statusenum\",{\"1\":{\"337\":6,\"341\":1}}],[\"status\",{\"1\":{\"18\":1,\"1016\":1}}],[\"study\",{\"1\":{\"116\":5}}],[\"student\",{\"1\":{\"89\":12,\"816\":17}}],[\"stu对象和stu1对象是同一个对象\",{\"1\":{\"89\":1}}],[\"stu和stu1是同一个对象\",{\"1\":{\"89\":2}}],[\"stu1\",{\"1\":{\"89\":6}}],[\"stu\",{\"1\":{\"89\":12}}],[\"strutil\",{\"1\":{\"972\":1,\"983\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":3}}],[\"struct\",{\"1\":{\"277\":5,\"283\":1}}],[\"strict\",{\"1\":{\"372\":1}}],[\"string结构是将对象序列化为json字符串后存储\",{\"1\":{\"1027\":1}}],[\"string的常见命令有\",{\"1\":{\"1025\":1}}],[\"string类型\",{\"1\":{\"1025\":1}}],[\"string命令\",{\"0\":{\"1025\":1}}],[\"stringredistemplate\",{\"0\":{\"1042\":1},\"1\":{\"961\":3,\"968\":3,\"972\":8,\"990\":4,\"993\":7,\"994\":1,\"1042\":7,\"1043\":5}}],[\"stringutil\",{\"1\":{\"849\":1}}],[\"stringutils\",{\"1\":{\"370\":1,\"371\":2}}],[\"stringdecoder\",{\"1\":{\"834\":1}}],[\"stringencoder\",{\"1\":{\"803\":4,\"804\":1,\"816\":1,\"835\":1,\"844\":1}}],[\"stringpropertynames\",{\"1\":{\"783\":1}}],[\"string>\",{\"1\":{\"744\":1,\"1032\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"236\":3}}],[\"stringbuilder\",{\"1\":{\"82\":2,\"368\":2,\"818\":2,\"849\":12,\"893\":2}}],[\"string\",{\"1\":{\"41\":14,\"42\":3,\"49\":7,\"52\":32,\"58\":1,\"63\":1,\"65\":1,\"69\":2,\"77\":4,\"78\":2,\"82\":1,\"86\":1,\"87\":4,\"89\":10,\"93\":1,\"94\":4,\"95\":1,\"103\":2,\"105\":2,\"108\":1,\"109\":4,\"111\":9,\"116\":6,\"120\":1,\"191\":1,\"194\":2,\"206\":1,\"211\":1,\"221\":1,\"224\":3,\"225\":3,\"232\":1,\"236\":2,\"268\":1,\"275\":2,\"282\":4,\"336\":10,\"339\":2,\"345\":1,\"346\":1,\"366\":2,\"368\":1,\"370\":1,\"422\":1,\"441\":4,\"450\":1,\"463\":1,\"510\":1,\"512\":1,\"515\":1,\"523\":1,\"574\":2,\"575\":1,\"600\":1,\"647\":1,\"655\":1,\"670\":3,\"711\":6,\"731\":10,\"732\":1,\"737\":1,\"743\":1,\"744\":3,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"758\":14,\"759\":8,\"760\":3,\"761\":1,\"773\":3,\"775\":1,\"776\":2,\"783\":7,\"785\":3,\"787\":1,\"798\":2,\"804\":2,\"816\":4,\"826\":1,\"834\":2,\"835\":1,\"844\":1,\"845\":4,\"846\":1,\"849\":8,\"859\":1,\"870\":3,\"872\":1,\"873\":3,\"884\":2,\"886\":1,\"889\":3,\"890\":1,\"893\":2,\"896\":1,\"898\":2,\"907\":1,\"909\":1,\"934\":3,\"940\":2,\"949\":1,\"950\":3,\"960\":4,\"968\":5,\"972\":2,\"983\":1,\"985\":1,\"988\":3,\"989\":2,\"990\":15,\"993\":2,\"1025\":2,\"1032\":2,\"1041\":2,\"1042\":2}}],[\"streams\",{\"1\":{\"742\":1}}],[\"streams就是为了解决该问题\",{\"1\":{\"742\":1}}],[\"streams为我们提供了java中的reactive\",{\"1\":{\"742\":1}}],[\"streamstream\",{\"1\":{\"339\":2}}],[\"stream<character>\",{\"1\":{\"339\":2}}],[\"stream<stream<character>>\",{\"1\":{\"339\":1}}],[\"stream\",{\"0\":{\"337\":1,\"900\":1},\"1\":{\"338\":1,\"339\":3,\"340\":1,\"341\":2,\"342\":3,\"343\":6,\"688\":1,\"743\":1,\"744\":1,\"900\":2,\"901\":1,\"911\":3}}],[\"streamdecoder不是java\",{\"1\":{\"44\":1}}],[\"streamdecoder类的同名方法的调用封装\",{\"1\":{\"44\":1}}],[\"streamdecoder类对象\",{\"1\":{\"44\":1}}],[\"strhandler\",{\"1\":{\"336\":3}}],[\"str\",{\"1\":{\"282\":12,\"336\":7,\"339\":4}}],[\"strcat\",{\"1\":{\"276\":5,\"277\":1}}],[\"strlen\",{\"1\":{\"276\":3,\"277\":1,\"422\":1}}],[\"strat只能调用一次\",{\"1\":{\"202\":1}}],[\"strategy角色负责决定实现策略所必需的接口\",{\"1\":{\"115\":1}}],[\"strategy\",{\"1\":{\"115\":1,\"116\":13}}],[\"strategy模式却特意将算法与其他部分分离开\",{\"1\":{\"114\":1}}],[\"strategy模式篇\",{\"1\":{\"113\":1}}],[\"strangers\",{\"1\":{\"111\":1}}],[\"s^2\",{\"1\":{\"26\":3}}],[\"success\",{\"1\":{\"791\":2,\"810\":2,\"811\":2,\"995\":2,\"996\":2,\"997\":2,\"998\":6}}],[\"suspend\",{\"1\":{\"790\":1}}],[\"suffix\",{\"1\":{\"647\":1}}],[\"suffix=\",{\"1\":{\"647\":1}}],[\"suppresswarnings\",{\"1\":{\"790\":1}}],[\"supported\",{\"1\":{\"720\":1}}],[\"supports\",{\"1\":{\"720\":1}}],[\"supportseventtype\",{\"1\":{\"703\":1}}],[\"supportsparameter\",{\"1\":{\"568\":1}}],[\"support\",{\"1\":{\"667\":1}}],[\"supplier<\",{\"1\":{\"336\":1}}],[\"super\",{\"1\":{\"86\":1,\"87\":1,\"89\":1,\"94\":2,\"261\":1,\"527\":4,\"742\":1,\"749\":2,\"783\":1,\"808\":2,\"816\":8,\"872\":5}}],[\"sunion\",{\"1\":{\"1029\":2}}],[\"sunion等\",{\"1\":{\"422\":1}}],[\"sun\",{\"1\":{\"94\":1,\"886\":1}}],[\"sunday\",{\"1\":{\"18\":1}}],[\"submissionpublisher<string>\",{\"1\":{\"744\":1}}],[\"submissionpublisher<>\",{\"1\":{\"743\":1,\"744\":1}}],[\"submissionpublisher<integer>\",{\"1\":{\"743\":1,\"744\":1}}],[\"submit方法就会继续执行下去\",{\"1\":{\"745\":1}}],[\"submit是一个阻塞式方法\",{\"1\":{\"744\":1}}],[\"submit\",{\"0\":{\"245\":1},\"1\":{\"245\":1,\"263\":4,\"743\":1,\"744\":2,\"807\":1,\"808\":1,\"815\":2,\"989\":1,\"990\":1,\"993\":1}}],[\"sub\",{\"1\":{\"502\":1,\"584\":1}}],[\"sublen\",{\"1\":{\"236\":4}}],[\"subscription\",{\"1\":{\"742\":2,\"743\":10,\"744\":19}}],[\"subscriber<string>\",{\"1\":{\"744\":1}}],[\"subscriber<>\",{\"1\":{\"743\":1,\"744\":1}}],[\"subscriber<integer>\",{\"1\":{\"743\":1}}],[\"subscriber<t>\",{\"1\":{\"742\":1}}],[\"subscriber和subscription完成一个发布\",{\"1\":{\"743\":1}}],[\"subscriber\",{\"1\":{\"742\":2,\"743\":2,\"744\":2}}],[\"subscribe\",{\"1\":{\"80\":1,\"742\":1,\"743\":1,\"744\":2}}],[\"substring\",{\"1\":{\"236\":2,\"336\":1}}],[\"subject角色定义了注册观察者和删除观察者的方法\",{\"1\":{\"81\":1}}],[\"subject角色表示观察对象\",{\"1\":{\"81\":1}}],[\"subject\",{\"1\":{\"81\":1,\"82\":1,\"92\":2}}],[\"sugar\",{\"1\":{\"69\":1}}],[\"summary\",{\"1\":{\"1024\":2,\"1025\":1}}],[\"summarizingdouble\",{\"1\":{\"342\":1}}],[\"sumrange\",{\"1\":{\"287\":1}}],[\"sum\",{\"1\":{\"26\":7,\"116\":3,\"267\":4,\"287\":3,\"342\":4}}],[\"扒一下低调的yoshua\",{\"1\":{\"12\":1}}],[\"etc\",{\"1\":{\"1016\":1}}],[\"et模式在很大程度上减少了epoll事件被重复触发的次数\",{\"1\":{\"410\":1}}],[\"et模式\",{\"1\":{\"410\":1}}],[\"es\",{\"1\":{\"993\":1}}],[\"esspringbootapplicationtests\",{\"1\":{\"950\":1}}],[\"esspringboot\",{\"1\":{\"949\":1}}],[\"estestclient\",{\"1\":{\"932\":2,\"933\":6,\"934\":8,\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"established\",{\"1\":{\"776\":2}}],[\"estimated\",{\"1\":{\"249\":1}}],[\"e5\",{\"1\":{\"855\":2}}],[\"echo\",{\"1\":{\"844\":1}}],[\"email\",{\"1\":{\"731\":1}}],[\"embeddedchannel\",{\"1\":{\"770\":2}}],[\"embeddeddatabase\",{\"1\":{\"660\":1}}],[\"embeddedvalueresolveraware\",{\"1\":{\"490\":1}}],[\"embed\",{\"1\":{\"648\":1}}],[\"embed<\",{\"1\":{\"648\":1}}],[\"employee\",{\"1\":{\"337\":6,\"340\":1,\"341\":1,\"342\":2,\"343\":9}}],[\"employees\",{\"1\":{\"336\":1,\"337\":1,\"338\":1,\"340\":1,\"341\":2,\"342\":2,\"343\":6}}],[\"emptyset\",{\"1\":{\"655\":1,\"657\":1}}],[\"empty\",{\"1\":{\"249\":1,\"283\":1,\"758\":1,\"1024\":1}}],[\"epoch\",{\"1\":{\"441\":2}}],[\"epoll通过内核空间和用户空间共享一块内存来实现\",{\"1\":{\"410\":1}}],[\"epoll实现通过epoll\",{\"1\":{\"410\":1}}],[\"epoll工作在et模式的时候\",{\"1\":{\"410\":1}}],[\"epoll对文件描述符的操作有两种模式\",{\"1\":{\"410\":1}}],[\"epoll使用\",{\"1\":{\"410\":1}}],[\"epoll使用一个文件描述符管理多个描述符\",{\"1\":{\"410\":1}}],[\"epoll支持水平触发和边缘触发\",{\"1\":{\"410\":1}}],[\"epoll更加灵活\",{\"1\":{\"410\":1}}],[\"epoll是select和poll的增强版本\",{\"1\":{\"410\":1}}],[\"epoll\",{\"1\":{\"410\":3,\"424\":1,\"842\":1}}],[\"epoll本质上都是同步io\",{\"1\":{\"410\":1}}],[\"epoll的效率就会远远高于select和poll\",{\"1\":{\"410\":1}}],[\"epoll的优点\",{\"1\":{\"410\":1}}],[\"epoll的优势并不是对于单个连接能处理得更快\",{\"1\":{\"409\":1}}],[\"epoll的web\",{\"1\":{\"409\":1}}],[\"epoll的好处就在于单个process就可以同时处理多个网络的io\",{\"1\":{\"409\":1}}],[\"epoll等概念啦\",{\"1\":{\"405\":1}}],[\"evt\",{\"1\":{\"764\":4}}],[\"eviction\",{\"1\":{\"429\":1}}],[\"eventexecutors\",{\"1\":{\"810\":3,\"811\":3,\"812\":3,\"813\":3,\"814\":3,\"815\":4}}],[\"eventexecutor\",{\"1\":{\"796\":1,\"799\":1}}],[\"eventexecutorgroup\",{\"1\":{\"796\":1}}],[\"eventloops\",{\"1\":{\"896\":1}}],[\"eventlooptest2\",{\"1\":{\"800\":2,\"801\":5}}],[\"eventlooptest\",{\"1\":{\"798\":12}}],[\"eventloopgroup\",{\"1\":{\"790\":1,\"796\":3,\"797\":1,\"798\":2}}],[\"eventloop\",{\"0\":{\"796\":1},\"1\":{\"775\":1,\"787\":1,\"790\":8,\"791\":3,\"792\":5,\"793\":7,\"796\":11,\"808\":3,\"809\":4,\"837\":1,\"896\":2}}],[\"eventlistener\",{\"1\":{\"699\":1}}],[\"eventpublishingrunlistener\",{\"1\":{\"652\":1}}],[\"event\",{\"1\":{\"332\":1,\"409\":1,\"764\":4,\"791\":1,\"839\":1}}],[\"even\",{\"1\":{\"116\":4}}],[\"each\",{\"1\":{\"849\":1}}],[\"eat=a×λ+\",{\"1\":{\"413\":1}}],[\"eat=t+t=2t\",{\"1\":{\"413\":1}}],[\"eat\",{\"1\":{\"413\":1}}],[\"eager\",{\"1\":{\"366\":1}}],[\"effective\",{\"1\":{\"413\":1}}],[\"edge\",{\"1\":{\"410\":2}}],[\"edu\",{\"1\":{\"5\":1}}],[\"eq\",{\"1\":{\"370\":1,\"960\":1,\"968\":1,\"995\":1,\"996\":1,\"997\":3,\"998\":9}}],[\"equals与==作用一样\",{\"1\":{\"319\":1}}],[\"equals方法如果没有被重写\",{\"1\":{\"319\":1}}],[\"equals和hashcode都是object类中的方法\",{\"1\":{\"318\":1}}],[\"equals和hashcode\",{\"0\":{\"318\":1}}],[\"equals\",{\"1\":{\"63\":2,\"65\":2,\"94\":2,\"249\":3,\"341\":1,\"711\":6,\"790\":1,\"804\":1,\"844\":1,\"960\":1,\"968\":1}}],[\"equalsignorecase\",{\"1\":{\"58\":3}}],[\"equation\",{\"1\":{\"26\":2}}],[\"e4\",{\"1\":{\"280\":1,\"855\":2}}],[\"e3\",{\"1\":{\"280\":2}}],[\"e2\",{\"1\":{\"280\":3,\"336\":4}}],[\"e1\",{\"1\":{\"280\":7,\"336\":4}}],[\"ek\",{\"1\":{\"249\":11}}],[\"eh\",{\"1\":{\"249\":3}}],[\"eeeeeeeeeee|\",{\"1\":{\"756\":1}}],[\"eee|\",{\"1\":{\"755\":1}}],[\"ee\",{\"1\":{\"123\":1}}],[\"ergou\",{\"1\":{\"1029\":2}}],[\"errormvcautoconfiguration\",{\"0\":{\"666\":1}}],[\"errorproperties\",{\"1\":{\"622\":5}}],[\"errorpage\",{\"1\":{\"619\":1}}],[\"errorpageregistrar\",{\"1\":{\"619\":3}}],[\"errorpageregistrarbeanpostprocessor\",{\"1\":{\"617\":1,\"619\":3}}],[\"errorattributes\",{\"1\":{\"622\":1}}],[\"errorviewresolver\",{\"1\":{\"617\":1}}],[\"error\",{\"1\":{\"94\":4,\"515\":2,\"617\":5,\"619\":1,\"622\":2,\"749\":4,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"759\":4,\"767\":2,\"768\":2,\"783\":4,\"785\":4,\"787\":2,\"812\":4,\"813\":3,\"814\":3}}],[\"eriklindernoren\",{\"1\":{\"14\":1}}],[\"elasticsearchresttemplate\",{\"1\":{\"950\":3}}],[\"elasticsearchrepository<product\",{\"1\":{\"950\":1}}],[\"elasticsearchclient\",{\"1\":{\"949\":1}}],[\"elasticsearchconfig\",{\"1\":{\"949\":1}}],[\"elasticsearch<\",{\"1\":{\"931\":1,\"948\":1}}],[\"elasticsearch中的每个索引被分片1个主分片和1个复制\",{\"1\":{\"928\":1}}],[\"elasticsearch允许你创建分片的一份或多份拷贝\",{\"1\":{\"928\":1}}],[\"elasticsearch提供了将索引划分成多份的能力\",{\"1\":{\"927\":1}}],[\"elasticsearch\",{\"0\":{\"918\":1,\"920\":1,\"1058\":1},\"1\":{\"841\":1,\"931\":1,\"949\":2}}],[\"element\",{\"1\":{\"1028\":2}}],[\"elementtype\",{\"1\":{\"731\":1}}],[\"ele\",{\"1\":{\"78\":2}}],[\"else\",{\"1\":{\"58\":2,\"63\":2,\"65\":1,\"105\":1,\"116\":6,\"123\":2,\"194\":1,\"249\":5,\"283\":1,\"441\":1,\"673\":1,\"759\":1,\"760\":2,\"761\":3,\"768\":1,\"773\":2,\"787\":1,\"788\":1,\"790\":6,\"791\":1,\"792\":2,\"793\":2,\"799\":1,\"849\":2,\"873\":1,\"886\":2,\"890\":2,\"893\":2,\"896\":1}}],[\"exe文件\",{\"1\":{\"1020\":1}}],[\"execstart=\",{\"1\":{\"1016\":1}}],[\"executionexception\",{\"1\":{\"812\":2}}],[\"executor\",{\"1\":{\"791\":2,\"799\":4,\"989\":2,\"990\":2}}],[\"executorservice\",{\"1\":{\"244\":4,\"263\":8,\"807\":1,\"989\":1,\"990\":1}}],[\"executors\",{\"1\":{\"244\":3,\"263\":2,\"807\":1,\"989\":1,\"990\":1}}],[\"executors创建的线程池\",{\"0\":{\"244\":1}}],[\"execute\",{\"0\":{\"245\":1},\"1\":{\"82\":3,\"790\":4,\"791\":4,\"793\":1,\"799\":1,\"800\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1}}],[\"exec\",{\"1\":{\"105\":1}}],[\"exist\",{\"1\":{\"1025\":1}}],[\"existing\",{\"1\":{\"872\":1}}],[\"exists\",{\"1\":{\"386\":1,\"422\":1,\"872\":1,\"1024\":7}}],[\"exists和in的区分\",{\"0\":{\"386\":1}}],[\"exposeproxy\",{\"1\":{\"998\":1}}],[\"expiretime\",{\"1\":{\"989\":3,\"990\":11}}],[\"expire\",{\"1\":{\"968\":1,\"972\":1,\"1024\":3}}],[\"expireseconds\",{\"1\":{\"989\":2}}],[\"expires\",{\"1\":{\"429\":1}}],[\"expected\",{\"1\":{\"849\":1}}],[\"explain表的结果\",{\"1\":{\"266\":1}}],[\"ex\",{\"1\":{\"426\":1,\"972\":1}}],[\"extra列会出现\",{\"1\":{\"266\":1}}],[\"extends\",{\"1\":{\"41\":1,\"49\":2,\"69\":1,\"82\":1,\"94\":2,\"108\":2,\"120\":2,\"249\":4,\"372\":1,\"742\":1,\"744\":1,\"760\":2,\"761\":5,\"762\":1,\"770\":1,\"771\":1,\"773\":4,\"776\":1,\"783\":2,\"784\":1,\"786\":1,\"788\":1,\"806\":2,\"949\":1,\"950\":1}}],[\"exc\",{\"1\":{\"872\":2,\"907\":1,\"909\":6}}],[\"excludes>\",{\"1\":{\"1038\":1}}],[\"exclude>\",{\"1\":{\"1038\":1}}],[\"excludepathpatterns\",{\"1\":{\"961\":1}}],[\"excludename\",{\"1\":{\"731\":1}}],[\"exclude\",{\"1\":{\"731\":1,\"940\":2}}],[\"exclusive\",{\"1\":{\"255\":1}}],[\"exceptionvalue\",{\"1\":{\"783\":1,\"788\":3}}],[\"exceptionininitializererror\",{\"1\":{\"773\":1,\"783\":1}}],[\"exceptioncaught\",{\"1\":{\"762\":1,\"790\":1}}],[\"exception分为运行时异常和非运行时异常\",{\"1\":{\"722\":1}}],[\"exceptionhandler注解\",{\"1\":{\"732\":1}}],[\"exceptionhandler\",{\"0\":{\"613\":1,\"614\":1},\"1\":{\"616\":3,\"617\":2,\"644\":1,\"732\":1}}],[\"exceptionhandlerexceptionresolver\",{\"0\":{\"610\":1},\"1\":{\"616\":2,\"644\":1}}],[\"exception\",{\"0\":{\"722\":1},\"1\":{\"77\":1,\"89\":1,\"103\":4,\"515\":1,\"622\":1,\"732\":2,\"749\":5,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"759\":6,\"760\":2,\"761\":5,\"762\":2,\"764\":2,\"767\":1,\"768\":3,\"770\":2,\"771\":2,\"773\":2,\"775\":1,\"783\":4,\"784\":1,\"785\":2,\"786\":1,\"787\":2,\"788\":2,\"790\":6,\"791\":1,\"793\":7,\"798\":4,\"803\":1,\"804\":2,\"807\":1,\"808\":2,\"809\":1,\"812\":1,\"815\":2,\"816\":7,\"844\":1,\"898\":1,\"961\":1,\"972\":4,\"989\":1,\"990\":1}}],[\"entries\",{\"1\":{\"972\":1,\"1043\":4}}],[\"entrance\",{\"1\":{\"790\":1}}],[\"entryset\",{\"1\":{\"790\":3}}],[\"entry<channeloption<\",{\"1\":{\"790\":1}}],[\"entry<attributekey<\",{\"1\":{\"790\":2,\"793\":1}}],[\"entry<k\",{\"1\":{\"249\":1}}],[\"entry\",{\"1\":{\"279\":1}}],[\"entry对象就不会被回收\",{\"1\":{\"247\":1}}],[\"ensureopen\",{\"1\":{\"790\":2,\"793\":1}}],[\"env\",{\"1\":{\"650\":1}}],[\"environmentpostprocessor\",{\"1\":{\"652\":1}}],[\"environmentpostprocessorapplicationlistener\",{\"1\":{\"650\":1}}],[\"environment\",{\"1\":{\"446\":1,\"449\":1,\"650\":2}}],[\"english\",{\"1\":{\"450\":1}}],[\"enabled\",{\"1\":{\"731\":1}}],[\"enabled=true来手动开启\",{\"1\":{\"366\":1}}],[\"enableautoconfiguration注解的组成部分\",{\"1\":{\"731\":1}}],[\"enableautoconfiguration注解开启自动配置\",{\"1\":{\"730\":1}}],[\"enableautoconfiguration的关键功能就是通过\",{\"1\":{\"731\":1}}],[\"enableautoconfiguration\",{\"1\":{\"731\":4}}],[\"enableaspectjautoproxy\",{\"1\":{\"659\":3,\"998\":1}}],[\"enableasync\",{\"1\":{\"449\":1}}],[\"enable\",{\"1\":{\"671\":1,\"1016\":1}}],[\"enabletransactionmanagement\",{\"1\":{\"662\":2}}],[\"encode\",{\"1\":{\"770\":3,\"771\":1,\"773\":1,\"855\":2,\"890\":3,\"893\":1,\"898\":1,\"909\":1}}],[\"encodedresourceresolver\",{\"1\":{\"638\":1}}],[\"encoding=\",{\"1\":{\"1038\":1}}],[\"encoding\",{\"1\":{\"279\":6,\"668\":1}}],[\"enclosing\",{\"1\":{\"104\":1}}],[\"enum\",{\"1\":{\"101\":1,\"773\":1}}],[\"enhancer\",{\"1\":{\"95\":6,\"512\":1}}],[\"endian\",{\"1\":{\"822\":3}}],[\"endindex\",{\"1\":{\"236\":5}}],[\"endswith\",{\"1\":{\"783\":1,\"872\":1}}],[\"endl\",{\"1\":{\"192\":1,\"283\":1}}],[\"end\",{\"1\":{\"26\":1,\"870\":2,\"873\":2,\"993\":2,\"1028\":1}}],[\"en\",{\"1\":{\"19\":1,\"450\":1}}],[\"e\",{\"1\":{\"11\":1,\"19\":1,\"77\":2,\"82\":4,\"206\":2,\"221\":4,\"224\":4,\"225\":8,\"249\":19,\"263\":8,\"500\":13,\"515\":10,\"732\":3,\"743\":2,\"744\":2,\"749\":5,\"750\":2,\"753\":2,\"754\":13,\"755\":13,\"756\":13,\"759\":6,\"767\":2,\"768\":2,\"773\":6,\"775\":2,\"776\":2,\"783\":6,\"784\":3,\"785\":2,\"787\":2,\"790\":3,\"791\":2,\"792\":1,\"793\":3,\"798\":6,\"809\":3,\"810\":2,\"811\":2,\"812\":5,\"813\":5,\"814\":5,\"815\":4,\"822\":2,\"823\":1,\"824\":3,\"826\":8,\"829\":4,\"830\":2,\"845\":8,\"846\":2,\"849\":1,\"855\":2,\"857\":5,\"858\":10,\"870\":4,\"873\":2,\"884\":4,\"886\":4,\"890\":2,\"896\":8,\"898\":5,\"907\":3,\"909\":6,\"932\":2,\"988\":2,\"989\":2,\"990\":4}}],[\"2l\",{\"1\":{\"950\":2}}],[\"2g\",{\"1\":{\"870\":1}}],[\"2b\",{\"1\":{\"755\":2,\"756\":2}}],[\"2b8\",{\"1\":{\"372\":1}}],[\"2个方法\",{\"1\":{\"745\":1}}],[\"2个和第\",{\"1\":{\"336\":1}}],[\"2暑期实习一面\",{\"0\":{\"740\":1}}],[\"28\",{\"0\":{\"601\":1},\"1\":{\"776\":2}}],[\"24\",{\"0\":{\"586\":1},\"1\":{\"749\":7,\"750\":4,\"798\":2,\"859\":1}}],[\"241\",{\"1\":{\"440\":1}}],[\"22\",{\"0\":{\"569\":1},\"1\":{\"798\":30,\"800\":2,\"801\":5,\"1027\":2}}],[\"2222\",{\"1\":{\"337\":2}}],[\"232\",{\"1\":{\"406\":1}}],[\"23\",{\"0\":{\"573\":1},\"1\":{\"337\":1,\"750\":3}}],[\"256\",{\"1\":{\"745\":1,\"751\":3,\"849\":6}}],[\"25\",{\"0\":{\"589\":1},\"1\":{\"798\":3}}],[\"250～253\",{\"1\":{\"280\":2}}],[\"254\",{\"1\":{\"279\":2,\"280\":5}}],[\"2字节\",{\"1\":{\"279\":1}}],[\"29=512\",{\"1\":{\"823\":1}}],[\"29\",{\"0\":{\"605\":1},\"1\":{\"241\":1}}],[\"2执行完同步代码块的内容\",{\"1\":{\"211\":1}}],[\"2执行synchronized\",{\"1\":{\"211\":1}}],[\"2上锁的过程中\",{\"1\":{\"211\":1}}],[\"2r\",{\"1\":{\"176\":1}}],[\"2^n\",{\"1\":{\"823\":1}}],[\"2^12\",{\"1\":{\"441\":2}}],[\"2^10\",{\"1\":{\"151\":1}}],[\"2^32个地址才能一一标识\",{\"1\":{\"151\":1}}],[\"2^32\",{\"1\":{\"151\":1}}],[\"2^30\",{\"1\":{\"151\":3}}],[\"2^20\",{\"1\":{\"151\":1}}],[\"2147483647\",{\"1\":{\"870\":1}}],[\"210=1024\",{\"1\":{\"823\":1}}],[\"212\",{\"1\":{\"815\":2}}],[\"21\",{\"0\":{\"145\":1,\"186\":1,\"565\":1},\"1\":{\"776\":4,\"886\":6,\"1026\":1,\"1027\":1,\"1032\":1,\"1042\":1,\"1043\":1}}],[\"27\",{\"0\":{\"597\":1},\"1\":{\"798\":3,\"812\":1,\"815\":1}}],[\"27行\",{\"1\":{\"123\":1}}],[\"27159510\",{\"1\":{\"12\":1}}],[\"2<\",{\"1\":{\"95\":1,\"931\":2}}],[\"26\",{\"0\":{\"593\":1},\"1\":{\"282\":1}}],[\"26∗26\",{\"1\":{\"24\":1}}],[\"260612034\",{\"1\":{\"18\":1}}],[\"20l\",{\"1\":{\"989\":1}}],[\"2001\",{\"1\":{\"1038\":1}}],[\"200\",{\"1\":{\"988\":1,\"1042\":2}}],[\"2008\",{\"1\":{\"842\":1}}],[\"2004\",{\"1\":{\"842\":1}}],[\"200ms\",{\"1\":{\"751\":1}}],[\"2000\",{\"1\":{\"221\":1,\"798\":1,\"800\":1,\"801\":1}}],[\"20b\",{\"1\":{\"750\":1}}],[\"20211211082225509\",{\"1\":{\"1015\":1}}],[\"20211211080339076\",{\"1\":{\"1012\":1}}],[\"20230920153903868\",{\"1\":{\"992\":1}}],[\"2020\",{\"1\":{\"776\":4}}],[\"2020年初武汉爆发了新型冠状病毒\",{\"1\":{\"731\":1}}],[\"2022\",{\"0\":{\"740\":1},\"1\":{\"194\":2,\"441\":1,\"993\":1}}],[\"20220610221431032\",{\"1\":{\"186\":1}}],[\"20220610221353573\",{\"1\":{\"186\":1}}],[\"20220610220150678\",{\"1\":{\"186\":1}}],[\"20220610220013207\",{\"1\":{\"186\":1}}],[\"20220610215848171\",{\"1\":{\"186\":1}}],[\"20220610215815431\",{\"1\":{\"186\":1}}],[\"20220610215055371\",{\"1\":{\"186\":1}}],[\"20220610214717158\",{\"1\":{\"186\":1}}],[\"20220610214210814\",{\"1\":{\"186\":1}}],[\"20220610213728733\",{\"1\":{\"186\":1}}],[\"20220610213442230\",{\"1\":{\"186\":1}}],[\"20220610213119470\",{\"1\":{\"186\":1}}],[\"20220610212917960\",{\"1\":{\"186\":1}}],[\"20220610212527979\",{\"1\":{\"185\":1}}],[\"20220610212414867\",{\"1\":{\"185\":1}}],[\"20220609102817435\",{\"1\":{\"1031\":1}}],[\"20220609104330037\",{\"1\":{\"185\":1}}],[\"20220609104233122\",{\"1\":{\"185\":1}}],[\"20220609104134198\",{\"1\":{\"185\":1}}],[\"20220609103942129\",{\"1\":{\"185\":1}}],[\"20220609103645775\",{\"1\":{\"185\":1}}],[\"20220609103338474\",{\"1\":{\"185\":1}}],[\"20220609101958603\",{\"1\":{\"184\":1}}],[\"20220609101720564\",{\"1\":{\"184\":1}}],[\"20220609101627441\",{\"1\":{\"184\":1}}],[\"20220609100750640\",{\"1\":{\"184\":1}}],[\"20220609095722677\",{\"1\":{\"184\":1}}],[\"20220609095427515\",{\"1\":{\"184\":1}}],[\"20220609095039255\",{\"1\":{\"184\":1}}],[\"20220608154426249\",{\"1\":{\"183\":1}}],[\"20220608153523239\",{\"1\":{\"182\":1}}],[\"20220608152211751\",{\"1\":{\"182\":1}}],[\"20220608150637422\",{\"1\":{\"182\":1}}],[\"20220608150624784\",{\"1\":{\"182\":1}}],[\"20220608150454000\",{\"1\":{\"182\":1}}],[\"20220608145040522\",{\"1\":{\"182\":1}}],[\"20220608144448647\",{\"1\":{\"181\":1}}],[\"20220608144250495\",{\"1\":{\"181\":1}}],[\"20220608144106793\",{\"1\":{\"181\":1}}],[\"20220608140914035\",{\"1\":{\"181\":1}}],[\"20220608133444265\",{\"1\":{\"181\":1}}],[\"20220608132930223\",{\"1\":{\"181\":1}}],[\"20220608110604462\",{\"1\":{\"180\":1}}],[\"20220608110542490\",{\"1\":{\"180\":1}}],[\"20220608105835197\",{\"1\":{\"180\":1}}],[\"20220608105259812\",{\"1\":{\"180\":1}}],[\"20220608104719687\",{\"1\":{\"179\":1}}],[\"20220608104632049\",{\"1\":{\"179\":1}}],[\"20220608104500993\",{\"1\":{\"179\":1}}],[\"20220608104012756\",{\"1\":{\"179\":1}}],[\"20220608103332891\",{\"1\":{\"178\":1}}],[\"20220608103307481\",{\"1\":{\"178\":1}}],[\"20220607113400305\",{\"1\":{\"178\":1}}],[\"20220607112703160\",{\"1\":{\"177\":1}}],[\"20220607112458312\",{\"1\":{\"177\":1}}],[\"20220607112210165\",{\"1\":{\"177\":1}}],[\"20220531223412094\",{\"1\":{\"177\":1}}],[\"20220531223117841\",{\"1\":{\"177\":1}}],[\"20220531201414435\",{\"1\":{\"177\":1}}],[\"20220531200459574\",{\"1\":{\"177\":1}}],[\"20220531115101881\",{\"1\":{\"176\":1}}],[\"20220531115047482\",{\"1\":{\"176\":1}}],[\"20220531114848212\",{\"1\":{\"176\":1}}],[\"20220531114605608\",{\"1\":{\"176\":1}}],[\"20220531114050634\",{\"1\":{\"176\":1}}],[\"20220531113725569\",{\"1\":{\"176\":1}}],[\"20220530224610670\",{\"1\":{\"176\":1}}],[\"20220530220453740\",{\"1\":{\"175\":1}}],[\"20220530220421638\",{\"1\":{\"175\":1}}],[\"20220530220354717\",{\"1\":{\"175\":1}}],[\"20220530220243511\",{\"1\":{\"175\":1}}],[\"20220530214532180\",{\"1\":{\"175\":1}}],[\"20220530214006044\",{\"1\":{\"174\":1}}],[\"20220530213756966\",{\"1\":{\"174\":1}}],[\"20220530212817688\",{\"1\":{\"173\":1}}],[\"20220530212539209\",{\"1\":{\"173\":1}}],[\"20220530212222775\",{\"1\":{\"173\":1}}],[\"20220530210923203\",{\"1\":{\"173\":1}}],[\"20220530210706405\",{\"1\":{\"173\":1}}],[\"20220530210456044\",{\"1\":{\"172\":1}}],[\"20220530210336394\",{\"1\":{\"172\":1}}],[\"20220530210148637\",{\"1\":{\"172\":1}}],[\"20220530205956876\",{\"1\":{\"172\":1}}],[\"20220530205021424\",{\"1\":{\"171\":1}}],[\"20220530204953730\",{\"1\":{\"171\":1}}],[\"20220530204655334\",{\"1\":{\"171\":1}}],[\"20220530202718681\",{\"1\":{\"171\":1}}],[\"20220530202619445\",{\"1\":{\"171\":1}}],[\"20220530201818071\",{\"1\":{\"171\":1}}],[\"20220530201342594\",{\"1\":{\"171\":1}}],[\"20220530201101036\",{\"1\":{\"171\":1}}],[\"20220530195918540\",{\"1\":{\"170\":1}}],[\"20220530195708965\",{\"1\":{\"170\":1}}],[\"20220530195308743\",{\"1\":{\"170\":1}}],[\"20220530195251537\",{\"1\":{\"170\":1}}],[\"20220530194728231\",{\"1\":{\"170\":1}}],[\"20220530193750402\",{\"1\":{\"170\":1}}],[\"20220530193511600\",{\"1\":{\"170\":1}}],[\"20220530193310886\",{\"1\":{\"170\":1}}],[\"20220530145757007\",{\"1\":{\"170\":1}}],[\"20220530145536142\",{\"1\":{\"170\":1}}],[\"20220530145400964\",{\"1\":{\"170\":1}}],[\"20220530145112083\",{\"1\":{\"170\":1}}],[\"20220530144632343\",{\"1\":{\"170\":1}}],[\"20220530144020397\",{\"1\":{\"169\":1}}],[\"20220530143548528\",{\"1\":{\"169\":1}}],[\"20220529222421721\",{\"1\":{\"169\":1}}],[\"20220529215048681\",{\"1\":{\"169\":1}}],[\"20220529214611813\",{\"1\":{\"169\":1}}],[\"20220529213416885\",{\"1\":{\"169\":1}}],[\"20220529212901703\",{\"1\":{\"169\":1}}],[\"20220529212212817\",{\"1\":{\"169\":1}}],[\"20220529212115224\",{\"1\":{\"169\":1}}],[\"20220524142132631\",{\"1\":{\"169\":2}}],[\"20220524134541056\",{\"1\":{\"169\":1}}],[\"20220524134337470\",{\"1\":{\"169\":1}}],[\"20220524133535599\",{\"1\":{\"169\":1}}],[\"20220522214148310\",{\"1\":{\"168\":1}}],[\"20220522214100918\",{\"1\":{\"168\":1}}],[\"20220522213950345\",{\"1\":{\"168\":1}}],[\"20220522213646590\",{\"1\":{\"168\":1}}],[\"20220522204512602\",{\"1\":{\"168\":1}}],[\"20220522203842838\",{\"1\":{\"168\":1}}],[\"20220522203520109\",{\"1\":{\"168\":1}}],[\"20220522202312578\",{\"1\":{\"168\":1}}],[\"20220522144900273\",{\"1\":{\"168\":1}}],[\"20220522144708324\",{\"1\":{\"168\":1}}],[\"20220522143959739\",{\"1\":{\"168\":1}}],[\"20220522142638847\",{\"1\":{\"167\":1}}],[\"20220522142404913\",{\"1\":{\"167\":1}}],[\"20220522142220989\",{\"1\":{\"167\":1}}],[\"20220522141420657\",{\"1\":{\"167\":1}}],[\"20220522135220091\",{\"1\":{\"167\":1}}],[\"20220522134405761\",{\"1\":{\"167\":1}}],[\"20220522132423543\",{\"1\":{\"167\":1}}],[\"20220522131805969\",{\"1\":{\"167\":1}}],[\"20220522131645588\",{\"1\":{\"167\":1}}],[\"20220522125936141\",{\"1\":{\"167\":1}}],[\"20220522125526046\",{\"1\":{\"167\":1}}],[\"20220521221810990\",{\"1\":{\"166\":1}}],[\"20220521221245106\",{\"1\":{\"166\":1}}],[\"20220521220941143\",{\"1\":{\"166\":1}}],[\"20220521220755154\",{\"1\":{\"166\":1}}],[\"20220521203500688\",{\"1\":{\"164\":1}}],[\"20220521202834105\",{\"1\":{\"164\":1}}],[\"20220521200544645\",{\"1\":{\"164\":1}}],[\"20220521141844658\",{\"1\":{\"163\":1}}],[\"20220521133823507\",{\"1\":{\"163\":1}}],[\"20220521132954826\",{\"1\":{\"163\":1}}],[\"20220521131041972\",{\"1\":{\"163\":1}}],[\"20220521130218677\",{\"1\":{\"163\":1}}],[\"20220515204850109\",{\"1\":{\"162\":1}}],[\"20220515204309592\",{\"1\":{\"162\":1}}],[\"20220515160709826\",{\"1\":{\"162\":1}}],[\"20220515155622275\",{\"1\":{\"161\":1}}],[\"20220515155525114\",{\"1\":{\"161\":1}}],[\"20220513193835377\",{\"1\":{\"160\":1}}],[\"20220513154609606\",{\"1\":{\"160\":1}}],[\"20220513153925493\",{\"1\":{\"160\":1}}],[\"20220513152328116\",{\"1\":{\"160\":1}}],[\"20220518144241994\",{\"1\":{\"28\":1}}],[\"20220518144159747\",{\"1\":{\"27\":1}}],[\"20220518142711194\",{\"1\":{\"21\":1}}],[\"20220508143045462\",{\"1\":{\"155\":1}}],[\"20为初始化数字\",{\"1\":{\"296\":1}}],[\"20\",{\"0\":{\"144\":1,\"185\":1,\"558\":1},\"1\":{\"82\":1,\"163\":1,\"194\":2,\"237\":2,\"266\":1,\"383\":1,\"750\":1,\"751\":2,\"776\":4,\"798\":16,\"801\":1,\"805\":1,\"934\":1,\"1005\":1,\"1027\":5}}],[\"2011\",{\"1\":{\"870\":1}}],[\"2013\",{\"1\":{\"842\":1}}],[\"2014\",{\"1\":{\"10\":2}}],[\"2017\",{\"1\":{\"3\":1,\"6\":1,\"13\":1,\"16\":1}}],[\"2\",{\"0\":{\"36\":1,\"126\":1,\"148\":1,\"167\":1,\"451\":1,\"776\":1,\"784\":1,\"819\":1,\"923\":1,\"930\":1,\"931\":1,\"932\":2,\"933\":1,\"934\":1,\"937\":1,\"949\":1,\"955\":1,\"959\":1,\"966\":1,\"971\":1,\"973\":1,\"974\":1,\"975\":1,\"976\":2,\"977\":2,\"978\":2,\"979\":2,\"980\":1,\"981\":1,\"982\":2,\"983\":1,\"984\":1,\"985\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"990\":1,\"993\":1,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":2,\"1006\":1,\"1007\":1,\"1008\":1,\"1009\":2,\"1010\":1,\"1011\":1,\"1012\":2,\"1013\":1,\"1014\":1,\"1015\":1,\"1016\":1,\"1017\":1,\"1018\":1,\"1019\":2,\"1020\":1,\"1021\":1,\"1024\":1,\"1033\":1,\"1034\":1,\"1035\":2,\"1039\":1,\"1041\":1},\"1\":{\"11\":2,\"58\":1,\"95\":1,\"116\":3,\"132\":1,\"133\":1,\"134\":3,\"135\":4,\"137\":1,\"139\":1,\"140\":2,\"147\":3,\"148\":3,\"150\":1,\"151\":2,\"154\":1,\"156\":2,\"158\":1,\"164\":1,\"176\":1,\"192\":2,\"211\":1,\"224\":3,\"225\":3,\"232\":7,\"237\":1,\"249\":1,\"261\":1,\"263\":5,\"265\":2,\"266\":2,\"267\":1,\"268\":1,\"277\":5,\"281\":1,\"283\":5,\"336\":2,\"338\":1,\"366\":2,\"420\":2,\"439\":1,\"441\":1,\"527\":2,\"544\":1,\"651\":1,\"655\":1,\"743\":2,\"744\":3,\"749\":2,\"750\":3,\"753\":1,\"754\":18,\"755\":18,\"756\":18,\"759\":3,\"767\":1,\"770\":3,\"771\":2,\"773\":4,\"776\":6,\"787\":1,\"790\":18,\"793\":1,\"796\":2,\"798\":25,\"800\":2,\"801\":5,\"803\":6,\"804\":1,\"805\":1,\"807\":2,\"809\":1,\"815\":2,\"816\":8,\"818\":1,\"822\":3,\"823\":1,\"824\":4,\"826\":8,\"829\":5,\"830\":4,\"834\":2,\"835\":2,\"842\":1,\"846\":1,\"849\":1,\"855\":2,\"857\":3,\"858\":2,\"873\":2,\"876\":1,\"877\":1,\"886\":2,\"890\":3,\"896\":1,\"898\":1,\"905\":3,\"906\":1,\"907\":3,\"933\":4,\"934\":6,\"937\":1,\"938\":1,\"960\":2,\"961\":1,\"963\":1,\"966\":1,\"968\":2,\"972\":1,\"983\":3,\"985\":2,\"988\":2,\"989\":4,\"990\":7,\"993\":5,\"995\":2,\"998\":6,\"999\":1,\"1005\":1,\"1012\":2,\"1015\":2,\"1016\":1,\"1024\":5,\"1025\":5,\"1027\":9,\"1028\":3,\"1029\":5,\"1032\":2,\"1034\":1,\"1035\":1}}],[\"ls\",{\"1\":{\"1029\":5}}],[\"l3级的缓存\",{\"1\":{\"976\":1}}],[\"l2\",{\"1\":{\"976\":1}}],[\"ld�\",{\"1\":{\"889\":1}}],[\"llen等\",{\"1\":{\"422\":1}}],[\"lrange\",{\"1\":{\"422\":1,\"1028\":3}}],[\"lru或者allkeys\",{\"1\":{\"428\":1}}],[\"lru置换算法是选择最近最久未使用的页面予以淘汰\",{\"1\":{\"420\":1}}],[\"lru\",{\"1\":{\"163\":2,\"420\":1,\"429\":2}}],[\"lpop和rpop\",{\"1\":{\"1028\":1}}],[\"lpop\",{\"1\":{\"422\":1,\"1028\":2}}],[\"lpush和rpush\",{\"1\":{\"1028\":1}}],[\"lpush\",{\"1\":{\"422\":1,\"1028\":2}}],[\"lfu可能更好点\",{\"1\":{\"429\":1}}],[\"lfu\",{\"1\":{\"420\":1,\"428\":1,\"429\":2}}],[\"lte\",{\"1\":{\"942\":1}}],[\"ltv\",{\"1\":{\"890\":1}}],[\"lt模式\",{\"1\":{\"410\":1}}],[\"lt模式是默认模式\",{\"1\":{\"410\":1}}],[\"lt和et的区别如下\",{\"1\":{\"410\":1}}],[\"lt\",{\"1\":{\"410\":1}}],[\"lucy\",{\"1\":{\"1027\":4}}],[\"lu\",{\"1\":{\"277\":2}}],[\"lilei\",{\"1\":{\"1027\":5}}],[\"little\",{\"1\":{\"822\":1}}],[\"lisi\",{\"1\":{\"787\":1,\"798\":6,\"934\":1,\"1025\":3,\"1029\":5}}],[\"list的常见命令有\",{\"1\":{\"1028\":1}}],[\"list命令\",{\"0\":{\"1028\":1}}],[\"listen\",{\"1\":{\"776\":1}}],[\"listener\",{\"1\":{\"653\":1}}],[\"list删除元素\",{\"1\":{\"324\":1,\"740\":1}}],[\"list删除元素问题\",{\"0\":{\"324\":1}}],[\"list移除元素\",{\"1\":{\"324\":1}}],[\"listpack\",{\"1\":{\"281\":1}}],[\"list<product>\",{\"1\":{\"950\":1}}],[\"list<socketchannel>\",{\"1\":{\"876\":1,\"877\":1}}],[\"list<string>\",{\"1\":{\"78\":1,\"339\":1,\"343\":1}}],[\"list<object>\",{\"1\":{\"770\":1,\"771\":2,\"773\":2}}],[\"list<observer>\",{\"1\":{\"82\":1}}],[\"list<channel>\",{\"1\":{\"758\":1,\"761\":2}}],[\"list<character>\",{\"1\":{\"339\":1}}],[\"list<book>\",{\"1\":{\"731\":1}}],[\"list<beanpostprocessor>\",{\"1\":{\"463\":1}}],[\"list<teacher>\",{\"1\":{\"731\":1,\"737\":1}}],[\"list<user>\",{\"1\":{\"370\":1}}],[\"list<integer>\",{\"1\":{\"342\":1}}],[\"list<employee>>\",{\"1\":{\"343\":1}}],[\"list<employee>\",{\"1\":{\"337\":1}}],[\"list\",{\"1\":{\"78\":5,\"272\":1,\"278\":1,\"339\":6,\"342\":2,\"422\":1,\"635\":2,\"638\":2,\"1024\":1}}],[\"libraryproperties\",{\"1\":{\"731\":3}}],[\"library\",{\"1\":{\"731\":2}}],[\"lifecyclebean\",{\"1\":{\"711\":6}}],[\"lifecycleexception\",{\"1\":{\"655\":1}}],[\"line\",{\"1\":{\"767\":13,\"804\":3,\"825\":1,\"844\":3}}],[\"linebasedframedecoder\",{\"1\":{\"755\":1}}],[\"linux\",{\"1\":{\"646\":1,\"776\":1,\"883\":1,\"905\":2,\"906\":1}}],[\"linux下的asynchronous\",{\"1\":{\"409\":1}}],[\"linux系统产生了下面五种网络模式的方案\",{\"1\":{\"409\":1}}],[\"linux这样的操作系统\",{\"1\":{\"407\":1}}],[\"linkedhashset用于保证元素的插入和取出满足fifo场景\",{\"1\":{\"326\":1}}],[\"linkedhashset底层采用的是链表和哈希表\",{\"1\":{\"326\":1}}],[\"linkedhashset和treeset都是set接口的实现类\",{\"1\":{\"326\":1}}],[\"linkedhashset和treeset三者的异同\",{\"0\":{\"326\":1}}],[\"linkedlist采用的是双向链表\",{\"1\":{\"322\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"244\":2}}],[\"linkedblockingqueue\",{\"1\":{\"242\":1}}],[\"like以通配符开头\",{\"1\":{\"395\":1}}],[\"like\",{\"1\":{\"366\":2,\"370\":1,\"371\":2,\"385\":2}}],[\"limit\",{\"1\":{\"266\":1,\"332\":1,\"338\":2,\"848\":3,\"849\":7,\"859\":4,\"890\":3}}],[\"l\",{\"1\":{\"191\":5,\"283\":1,\"749\":10,\"750\":14,\"754\":36,\"755\":31,\"756\":36,\"798\":36,\"803\":2}}],[\"low\",{\"1\":{\"917\":1}}],[\"lowbit\",{\"1\":{\"287\":3}}],[\"location\",{\"1\":{\"731\":2}}],[\"local\",{\"1\":{\"1012\":2,\"1015\":2,\"1016\":2}}],[\"localdatetime\",{\"1\":{\"989\":4,\"990\":3,\"993\":2,\"995\":2,\"998\":2}}],[\"local=\",{\"1\":{\"886\":2}}],[\"localread\",{\"1\":{\"793\":5}}],[\"localaddress\",{\"1\":{\"775\":1,\"790\":12}}],[\"locale\",{\"1\":{\"450\":3}}],[\"localhost\",{\"1\":{\"372\":2,\"498\":1,\"644\":1,\"653\":1,\"753\":1,\"759\":1,\"767\":1,\"776\":1,\"783\":1,\"785\":1,\"787\":1,\"798\":1,\"804\":1,\"845\":1,\"876\":1,\"884\":1,\"889\":1,\"890\":1,\"893\":1,\"898\":1,\"932\":1,\"949\":1}}],[\"lockkey\",{\"1\":{\"989\":3,\"990\":6}}],[\"locks\",{\"1\":{\"401\":5}}],[\"locksupport\",{\"1\":{\"224\":2,\"225\":4}}],[\"lock\",{\"1\":{\"211\":2,\"224\":13,\"225\":10,\"249\":1,\"260\":12,\"398\":2,\"787\":2,\"988\":3,\"989\":2,\"990\":3,\"1031\":1}}],[\"long>\",{\"1\":{\"950\":1}}],[\"longbuffer\",{\"1\":{\"332\":1,\"911\":1}}],[\"long这四种包装类默认创建了数值\",{\"1\":{\"320\":1}}],[\"long\",{\"1\":{\"234\":1,\"242\":1,\"249\":4,\"260\":5,\"366\":1,\"440\":1,\"441\":22,\"527\":3,\"731\":1,\"737\":1,\"742\":1,\"791\":2,\"792\":4,\"822\":2,\"849\":2,\"867\":2,\"870\":4,\"873\":2,\"882\":1,\"950\":1,\"977\":1,\"983\":2,\"985\":1,\"988\":1,\"989\":3,\"990\":6,\"993\":8,\"995\":3,\"998\":10}}],[\"longaccumulator\",{\"1\":{\"232\":1}}],[\"longadder来进行优化\",{\"1\":{\"997\":1}}],[\"longadder原理\",{\"0\":{\"234\":1}}],[\"longadder\",{\"1\":{\"232\":1,\"997\":1}}],[\"lookup\",{\"1\":{\"849\":5,\"1038\":1}}],[\"lookupexception\",{\"1\":{\"104\":1}}],[\"look调度算法\",{\"1\":{\"176\":2}}],[\"lose\",{\"1\":{\"116\":7}}],[\"losecount++\",{\"1\":{\"116\":1}}],[\"losecount\",{\"1\":{\"116\":2}}],[\"loading\",{\"1\":{\"366\":1}}],[\"loadfactorynames\",{\"1\":{\"670\":1}}],[\"loadfactor\",{\"1\":{\"249\":3}}],[\"loader\",{\"1\":{\"94\":1,\"787\":2}}],[\"load\",{\"1\":{\"77\":1,\"328\":3,\"773\":1,\"783\":1}}],[\"logfile\",{\"1\":{\"1015\":1}}],[\"log4j<\",{\"1\":{\"931\":2}}],[\"logininterceptor\",{\"1\":{\"961\":2,\"972\":2}}],[\"loginform\",{\"1\":{\"960\":3,\"968\":3}}],[\"loginformdto\",{\"1\":{\"960\":1,\"968\":1}}],[\"loginresponsemessage\",{\"1\":{\"759\":6,\"760\":3,\"773\":3}}],[\"loginrequestmessagehandler\",{\"1\":{\"760\":1}}],[\"loginrequestmessage\",{\"1\":{\"759\":3,\"760\":1,\"770\":2,\"773\":3}}],[\"login\",{\"1\":{\"758\":1,\"759\":9,\"760\":3,\"960\":1,\"961\":1,\"968\":4,\"972\":2}}],[\"loglevel\",{\"1\":{\"749\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"768\":1,\"783\":2,\"785\":1,\"787\":1,\"798\":1,\"804\":1}}],[\"loggerfactory\",{\"1\":{\"491\":1,\"500\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1}}],[\"logger\",{\"1\":{\"491\":1,\"500\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"790\":1,\"791\":1,\"793\":1,\"825\":1}}],[\"logginghandler\",{\"1\":{\"749\":5,\"750\":6,\"753\":1,\"754\":19,\"755\":17,\"756\":19,\"759\":4,\"767\":1,\"768\":1,\"770\":1,\"775\":1,\"783\":4,\"785\":2,\"787\":2,\"798\":20,\"804\":1}}],[\"logging\",{\"1\":{\"396\":1,\"759\":4,\"783\":4,\"785\":2,\"787\":2,\"793\":1,\"931\":2,\"949\":1}}],[\"log中只包含真正需要写入的部分\",{\"1\":{\"396\":1}}],[\"log中的数据\",{\"1\":{\"396\":1}}],[\"log中的信息将数据回滚到修改之前的样子\",{\"1\":{\"396\":1}}],[\"log是追加操作\",{\"1\":{\"396\":1}}],[\"log也需要在事务提交时将日志写入磁盘\",{\"1\":{\"396\":1}}],[\"log也会指向更早版本的undo\",{\"1\":{\"393\":1}}],[\"log采用wal\",{\"1\":{\"396\":1}}],[\"log进行刷盘\",{\"1\":{\"396\":1}}],[\"log记录这次操作\",{\"1\":{\"396\":1}}],[\"log被引入来解决这个问题\",{\"1\":{\"396\":1}}],[\"log属于逻辑日志\",{\"1\":{\"396\":1}}],[\"log的内容做与之前相反的工作\",{\"1\":{\"396\":1}}],[\"log的指针\",{\"1\":{\"393\":1}}],[\"log的指针等\",{\"1\":{\"393\":1}}],[\"log的版本链\",{\"1\":{\"393\":1}}],[\"log2n\",{\"1\":{\"381\":1}}],[\"log\",{\"1\":{\"26\":2,\"224\":6,\"225\":6,\"263\":6,\"389\":1,\"393\":1,\"396\":2,\"491\":4,\"500\":6,\"711\":6,\"749\":11,\"753\":4,\"754\":4,\"755\":4,\"756\":4,\"759\":3,\"762\":2,\"764\":2,\"767\":1,\"768\":3,\"770\":2,\"771\":2,\"773\":2,\"775\":1,\"783\":2,\"785\":2,\"786\":1,\"787\":1,\"788\":1,\"798\":3,\"800\":2,\"801\":2,\"803\":4,\"804\":5,\"807\":3,\"808\":4,\"809\":3,\"810\":4,\"811\":3,\"812\":3,\"813\":4,\"814\":3,\"816\":6,\"818\":3,\"822\":2,\"823\":1,\"824\":3,\"826\":7,\"846\":2,\"876\":4,\"877\":2,\"884\":2,\"886\":2,\"890\":4,\"896\":3,\"907\":4,\"933\":5,\"950\":2,\"960\":1,\"1015\":1}}],[\"lework\",{\"1\":{\"1019\":1}}],[\"less\",{\"1\":{\"849\":1}}],[\"level\",{\"1\":{\"265\":1,\"410\":2,\"931\":1,\"949\":1}}],[\"level3\",{\"1\":{\"265\":1}}],[\"leviopku\",{\"1\":{\"31\":1}}],[\"leak\",{\"1\":{\"790\":1}}],[\"least\",{\"1\":{\"249\":1,\"429\":4}}],[\"learning\",{\"1\":{\"11\":1}}],[\"left\",{\"1\":{\"249\":1,\"266\":1,\"283\":6,\"287\":2,\"366\":1,\"383\":1,\"870\":13}}],[\"len小的二级索引进行扫描\",{\"1\":{\"387\":1}}],[\"len\",{\"1\":{\"123\":6,\"277\":11,\"283\":2,\"798\":1,\"846\":3}}],[\"lengthfieldbasedframedecoder\",{\"1\":{\"756\":1,\"770\":1,\"771\":1,\"773\":1}}],[\"length\",{\"1\":{\"44\":2,\"123\":2,\"236\":2,\"249\":2,\"267\":2,\"282\":6,\"287\":3,\"756\":3,\"768\":2,\"770\":5,\"771\":5,\"773\":6,\"818\":3,\"849\":17,\"890\":4,\"896\":2,\"904\":1,\"905\":1}}],[\"lettuce\",{\"1\":{\"1039\":1}}],[\"lettuce和jedis\",{\"1\":{\"1036\":1}}],[\"let\",{\"1\":{\"105\":1}}],[\"latch\",{\"1\":{\"993\":3}}],[\"latte=com\",{\"1\":{\"77\":1}}],[\"latte\",{\"1\":{\"63\":1,\"65\":1,\"69\":1}}],[\"lattecoffeefactory\",{\"1\":{\"69\":1}}],[\"lattecoffee\",{\"1\":{\"60\":1,\"63\":1,\"65\":1,\"69\":2,\"74\":1,\"77\":1}}],[\"lastbytesread\",{\"1\":{\"794\":3}}],[\"lasttimemillis\",{\"1\":{\"441\":9}}],[\"lastname因为\",{\"1\":{\"385\":1}}],[\"lastname\",{\"1\":{\"385\":1}}],[\"last\",{\"1\":{\"385\":1,\"849\":1}}],[\"lazy\",{\"1\":{\"366\":1,\"470\":1,\"496\":1,\"500\":3,\"503\":1,\"688\":1,\"695\":1}}],[\"lang=all\",{\"1\":{\"449\":1,\"498\":1,\"502\":1,\"523\":1}}],[\"lang\",{\"1\":{\"94\":8,\"237\":1,\"325\":1,\"345\":1,\"346\":1,\"519\":1,\"812\":4,\"813\":2,\"814\":2,\"815\":2,\"825\":2}}],[\"lambda$main$1\",{\"1\":{\"815\":1}}],[\"lambda$main$0\",{\"1\":{\"812\":1,\"815\":1}}],[\"lambdaquerywrapper<>\",{\"1\":{\"371\":1}}],[\"lambdaquerywrapper<user>\",{\"1\":{\"371\":1}}],[\"lambda针对函数式接口进行简化编程\",{\"1\":{\"336\":1}}],[\"lambda\",{\"0\":{\"336\":1},\"1\":{\"26\":2,\"232\":2,\"338\":1}}],[\"lab视频讲解\",{\"1\":{\"11\":1}}],[\"lab\",{\"1\":{\"11\":1}}],[\"ml\",{\"0\":{\"1046\":1}}],[\"mget\",{\"1\":{\"1025\":2}}],[\"mtu\",{\"1\":{\"751\":6}}],[\"mvn\",{\"1\":{\"648\":2}}],[\"mvc拦截器的开发步骤如下\",{\"1\":{\"738\":1}}],[\"mvc拦截器的执行流程如下\",{\"1\":{\"738\":1}}],[\"mvc中\",{\"1\":{\"738\":1}}],[\"mvc中的接收普通参数的注解\",{\"1\":{\"737\":1}}],[\"mvc的拦截器\",{\"0\":{\"738\":1}}],[\"mvc的执行流程\",{\"0\":{\"736\":1}}],[\"mvc支持rest风格的一个重要标志\",{\"1\":{\"737\":1}}],[\"mvc注解\",{\"0\":{\"737\":1}}],[\"mvc框架的接口\",{\"1\":{\"736\":1}}],[\"mvc是一种设计模式\",{\"1\":{\"734\":1}}],[\"mvc\",{\"0\":{\"644\":1},\"1\":{\"617\":2,\"647\":2,\"705\":2}}],[\"mvcconfig\",{\"1\":{\"961\":1}}],[\"mvcc保证隔离性\",{\"1\":{\"396\":1}}],[\"mvcc的意思是多版本并发控制\",{\"1\":{\"393\":1}}],[\"mvcc只存在读已提交和可重复读的情况下\",{\"1\":{\"393\":1}}],[\"mpsc\",{\"1\":{\"791\":1}}],[\"mp\",{\"1\":{\"523\":5}}],[\"md5\",{\"1\":{\"384\":1}}],[\"middleware\",{\"0\":{\"1059\":1}}],[\"microservice\",{\"0\":{\"1052\":1}}],[\"mi\",{\"1\":{\"546\":7}}],[\"mixed\",{\"1\":{\"350\":1}}],[\"minutes\",{\"1\":{\"968\":1,\"972\":1,\"983\":1,\"985\":2,\"988\":2,\"990\":4}}],[\"mina\",{\"1\":{\"840\":1,\"842\":1}}],[\"minor\",{\"0\":{\"350\":1},\"1\":{\"350\":1}}],[\"min\",{\"1\":{\"341\":1,\"343\":1,\"792\":1,\"1030\":3,\"1039\":1}}],[\"millis\",{\"0\":{\"775\":1},\"1\":{\"775\":1}}],[\"milliseconds\",{\"1\":{\"244\":2,\"775\":1,\"792\":1}}],[\"milk\",{\"1\":{\"69\":1}}],[\"multicastevent\",{\"1\":{\"703\":1}}],[\"multipart\",{\"1\":{\"667\":2}}],[\"multipartautoconfiguration\",{\"0\":{\"667\":1}}],[\"multipartfile\",{\"1\":{\"568\":1}}],[\"multiplexing就是我们说的select\",{\"1\":{\"409\":1}}],[\"multiplexing\",{\"1\":{\"409\":2}}],[\"mutex\",{\"1\":{\"219\":1}}],[\"must\",{\"1\":{\"105\":1,\"941\":1}}],[\"myprocessor\",{\"1\":{\"744\":3}}],[\"my\",{\"1\":{\"731\":1,\"793\":1}}],[\"myimportselector\",{\"1\":{\"670\":4}}],[\"myimportselector=\",{\"1\":{\"670\":1}}],[\"myisam和innodb的存储引擎只支持btree索引\",{\"1\":{\"375\":1}}],[\"mycondition1\",{\"1\":{\"672\":3}}],[\"mycontroller\",{\"1\":{\"647\":1}}],[\"myconfig1\",{\"1\":{\"491\":2}}],[\"mybeanpostprocessor\",{\"1\":{\"711\":1}}],[\"mybeanfactory\",{\"1\":{\"463\":3}}],[\"mybatisproperties\",{\"1\":{\"661\":1}}],[\"mybatisplus\",{\"1\":{\"372\":3}}],[\"mybatisplusinterceptor\",{\"1\":{\"368\":4}}],[\"mybatisplusconfig\",{\"1\":{\"368\":1}}],[\"mybatisautoconfiguration\",{\"0\":{\"661\":1},\"1\":{\"661\":3}}],[\"mybatisx\",{\"1\":{\"373\":1}}],[\"mybatis动态表模式实现\",{\"0\":{\"368\":1}}],[\"mybatis+pagehelper插件即可实现分页操作\",{\"1\":{\"367\":1}}],[\"mybatis分页操作\",{\"0\":{\"367\":1}}],[\"mybatis\",{\"0\":{\"363\":2,\"364\":1,\"369\":1,\"372\":1},\"1\":{\"370\":1,\"372\":2,\"572\":1,\"646\":1,\"661\":5}}],[\"myfunction\",{\"1\":{\"336\":2}}],[\"mysql的单表的容量不宜超过500w\",{\"1\":{\"992\":1}}],[\"mysql的悲观锁和乐观锁\",{\"0\":{\"397\":1}}],[\"mysql服务器层并没有实现行锁机制\",{\"1\":{\"401\":1}}],[\"mysql中不同的存储引擎支持的锁是不一样的\",{\"1\":{\"396\":1}}],[\"mysql中索引的存储类型有两种\",{\"1\":{\"375\":1}}],[\"mysql默认页为16kb\",{\"1\":{\"396\":1}}],[\"mysql索引会失效变成全表扫描\",{\"1\":{\"395\":1}}],[\"mysql可以将数据恢复到指定版本\",{\"1\":{\"393\":1}}],[\"mysql事务隔离级别和mvcc\",{\"1\":{\"393\":1}}],[\"mysql8\",{\"1\":{\"392\":1}}],[\"mysql在使用不等于的时候无法使用索引会导致全表扫描\",{\"1\":{\"395\":1}}],[\"mysql在解析的过程中\",{\"1\":{\"388\":1}}],[\"mysql在windows下不区分大小写\",{\"1\":{\"265\":1}}],[\"mysql\",{\"0\":{\"374\":1},\"1\":{\"372\":5,\"439\":2,\"646\":1}}],[\"mysql并不是跳过offset行\",{\"1\":{\"266\":1}}],[\"myqcloud\",{\"1\":{\"169\":1}}],[\"myheritage\",{\"1\":{\"11\":1}}],[\"mfd\",{\"1\":{\"168\":1}}],[\"m\",{\"1\":{\"135\":2,\"186\":1,\"430\":1,\"523\":2,\"799\":3,\"859\":3}}],[\"m0\",{\"1\":{\"94\":3,\"213\":1,\"214\":1,\"215\":1,\"219\":1}}],[\"m3\",{\"1\":{\"94\":6,\"759\":1}}],[\"m2\",{\"1\":{\"94\":3,\"759\":1}}],[\"m1\",{\"1\":{\"94\":3,\"759\":1}}],[\"mbuilder\",{\"1\":{\"49\":5}}],[\"mbike\",{\"1\":{\"49\":8}}],[\"move\",{\"1\":{\"872\":3}}],[\"moved\",{\"1\":{\"249\":1}}],[\"mothod\",{\"1\":{\"737\":1}}],[\"module\",{\"1\":{\"449\":1}}],[\"mode\",{\"1\":{\"360\":1}}],[\"modelversion>\",{\"1\":{\"1038\":1}}],[\"model代表的是数据\",{\"1\":{\"734\":1}}],[\"modelandview中包含的是\",{\"1\":{\"736\":1}}],[\"modelandview包含了视图逻辑名和模型数据信息\",{\"1\":{\"736\":1}}],[\"modelandview\",{\"1\":{\"600\":1,\"644\":4}}],[\"modelandviewcontainer\",{\"1\":{\"568\":1,\"600\":7,\"644\":2}}],[\"modelattribute\",{\"0\":{\"593\":1,\"594\":1},\"1\":{\"568\":2,\"595\":1,\"596\":5,\"600\":2}}],[\"model中\",{\"1\":{\"409\":1}}],[\"modeling\",{\"1\":{\"32\":1}}],[\"model\",{\"1\":{\"11\":1,\"568\":1,\"622\":2,\"727\":1}}],[\"modified字段值为当前时间\",{\"1\":{\"268\":1}}],[\"modified的类型均为datetime类型\",{\"1\":{\"265\":1}}],[\"modified\",{\"1\":{\"265\":1}}],[\"monitorexit是退出synchronized语句\",{\"1\":{\"211\":1}}],[\"monitorenter是进入synchronized语句\",{\"1\":{\"211\":1}}],[\"monitor中只能有一个owner\",{\"1\":{\"211\":1}}],[\"monitor的结构如下\",{\"1\":{\"211\":1}}],[\"monitor被翻译成监视器或管程\",{\"1\":{\"211\":1}}],[\"monitor原理\",{\"0\":{\"211\":1}}],[\"monitor\",{\"1\":{\"206\":10,\"219\":1}}],[\"most\",{\"1\":{\"105\":1}}],[\"mobikebuilder\",{\"1\":{\"49\":2}}],[\"mobikebuilder和ofobuilder是具体的建造者\",{\"1\":{\"49\":1}}],[\"mset和mget\",{\"1\":{\"1025\":1}}],[\"mset\",{\"1\":{\"1024\":1,\"1025\":2}}],[\"mss\",{\"1\":{\"751\":10}}],[\"msg\",{\"1\":{\"41\":16,\"42\":2,\"759\":8,\"760\":7,\"761\":19,\"767\":2,\"768\":7,\"770\":4,\"771\":4,\"773\":4,\"786\":2,\"787\":2,\"788\":5,\"793\":3,\"798\":8,\"799\":3,\"816\":15,\"825\":8,\"834\":2,\"837\":1,\"844\":4}}],[\"ms\",{\"0\":{\"33\":1},\"1\":{\"450\":4,\"882\":1}}],[\"mediatype\",{\"1\":{\"604\":1,\"617\":1}}],[\"messageclasses\",{\"1\":{\"773\":16,\"783\":2}}],[\"messageclass\",{\"1\":{\"773\":2}}],[\"messagecodec\",{\"1\":{\"770\":3}}],[\"messagecodecsharable\",{\"1\":{\"759\":4,\"771\":1,\"773\":1,\"783\":4,\"785\":2,\"787\":2}}],[\"messageconverter\",{\"0\":{\"601\":1,\"602\":1},\"1\":{\"600\":2,\"604\":3,\"617\":1}}],[\"message>>\",{\"1\":{\"773\":1}}],[\"message>\",{\"1\":{\"771\":1,\"773\":3}}],[\"messagetomessagecodec<bytebuf\",{\"1\":{\"771\":1,\"773\":1}}],[\"messagetomessagecodec\",{\"1\":{\"771\":1}}],[\"messagetype\",{\"1\":{\"770\":2,\"771\":2,\"773\":7}}],[\"message\",{\"1\":{\"759\":10,\"760\":4,\"770\":9,\"771\":6,\"773\":12,\"783\":13,\"784\":6,\"785\":2,\"787\":2,\"825\":1,\"896\":1}}],[\"messages\",{\"1\":{\"450\":7}}],[\"messagesource\",{\"1\":{\"450\":4}}],[\"means算法最开始随机选取数据集中k个点作为聚类中心\",{\"1\":{\"300\":1}}],[\"means++按照如下的思想选取k个聚类中心\",{\"1\":{\"300\":1}}],[\"means++\",{\"1\":{\"300\":1}}],[\"means++的遗传算法生成与真实框更贴切的anchor\",{\"1\":{\"300\":1}}],[\"merge\",{\"1\":{\"285\":1}}],[\"meeting\",{\"1\":{\"111\":1}}],[\"methodname\",{\"1\":{\"783\":4}}],[\"methodbeforeadviceinterceptor\",{\"1\":{\"549\":1}}],[\"methodbeforeadviceadapter\",{\"1\":{\"549\":1}}],[\"methodinvocation\",{\"0\":{\"550\":1},\"1\":{\"546\":1,\"549\":1,\"552\":1}}],[\"methodinterceptor\",{\"1\":{\"95\":1,\"512\":1,\"523\":2,\"528\":2,\"531\":2,\"549\":1,\"556\":1}}],[\"methods\",{\"1\":{\"105\":2}}],[\"methodproxy\",{\"1\":{\"95\":4,\"512\":3,\"523\":2,\"527\":1,\"686\":1}}],[\"method\",{\"1\":{\"58\":3,\"94\":14,\"95\":3,\"119\":4,\"237\":1,\"463\":1,\"510\":2,\"512\":1,\"515\":7,\"523\":1,\"590\":1,\"784\":3,\"787\":4}}],[\"metadata\",{\"1\":{\"672\":1}}],[\"meta\",{\"1\":{\"32\":1,\"649\":1,\"670\":2,\"671\":1,\"682\":2}}],[\"member\",{\"1\":{\"758\":4,\"1029\":3,\"1030\":6}}],[\"members\",{\"1\":{\"758\":2,\"761\":4}}],[\"memset\",{\"1\":{\"192\":1}}],[\"memory存储引擎支持hash和btree索引\",{\"1\":{\"375\":1}}],[\"memory=\",{\"1\":{\"52\":2}}],[\"memory\",{\"1\":{\"52\":17,\"109\":15,\"904\":1}}],[\"memeber\",{\"1\":{\"1030\":1}}],[\"memery的时候\",{\"1\":{\"980\":1}}],[\"meme\",{\"1\":{\"11\":1}}],[\"megvii\",{\"1\":{\"32\":1}}],[\"mazi\",{\"1\":{\"1029\":2}}],[\"make\",{\"1\":{\"1012\":2}}],[\"maybemoredatasupplier\",{\"1\":{\"794\":3}}],[\"maybesuperuser\",{\"1\":{\"790\":1}}],[\"magicnum\",{\"1\":{\"770\":2,\"771\":2,\"773\":2}}],[\"man\",{\"1\":{\"1027\":5}}],[\"mandatory\",{\"1\":{\"720\":2}}],[\"many\",{\"1\":{\"249\":1}}],[\"maven\",{\"1\":{\"506\":2,\"1038\":5}}],[\"mask\",{\"1\":{\"441\":2}}],[\"master大量清理过期key\",{\"1\":{\"437\":1}}],[\"master里设置了过期时间的key\",{\"1\":{\"437\":1}}],[\"master会先清理删除它\",{\"1\":{\"436\":1}}],[\"master和slave进程是否正常工作\",{\"1\":{\"433\":1}}],[\"master\",{\"1\":{\"19\":1,\"32\":1}}],[\"malloc函数申请内存\",{\"1\":{\"412\":1}}],[\"major\",{\"0\":{\"350\":1},\"1\":{\"350\":1}}],[\"markreaderindex\",{\"1\":{\"824\":1}}],[\"mark\",{\"0\":{\"854\":1},\"1\":{\"332\":1,\"353\":1,\"361\":1,\"824\":1,\"854\":3}}],[\"maxage\",{\"1\":{\"945\":1}}],[\"maxmessageperread\",{\"1\":{\"794\":2}}],[\"maxmessagehandle\",{\"1\":{\"794\":1}}],[\"maxmemory\",{\"1\":{\"105\":1,\"1015\":1}}],[\"max查看\",{\"1\":{\"410\":1}}],[\"maximum\",{\"1\":{\"249\":2,\"751\":2}}],[\"maximumpoolsize\",{\"1\":{\"242\":3}}],[\"maxk\",{\"1\":{\"195\":2}}],[\"maxvalue\",{\"1\":{\"195\":2}}],[\"max\",{\"1\":{\"194\":2,\"195\":3,\"244\":2,\"323\":1,\"341\":1,\"343\":1,\"441\":6,\"776\":1,\"823\":2,\"826\":1,\"827\":1,\"889\":3,\"945\":1,\"1030\":3,\"1039\":3}}],[\"maxn\",{\"1\":{\"192\":4}}],[\"map就不一样\",{\"1\":{\"961\":1}}],[\"mapping是处理数据的方式和规则方面做一些限制\",{\"1\":{\"926\":1}}],[\"mapping\",{\"0\":{\"926\":1}}],[\"mappedbytebuffer\",{\"1\":{\"911\":1}}],[\"mapperfactorybean\",{\"1\":{\"486\":1,\"661\":2}}],[\"mapperpostprocessor\",{\"1\":{\"485\":1}}],[\"mapper\",{\"0\":{\"484\":1},\"1\":{\"368\":1,\"476\":1,\"477\":1,\"486\":1,\"572\":1,\"661\":4,\"934\":6,\"1042\":3}}],[\"mapperscannerconfigurer\",{\"1\":{\"476\":1,\"661\":1}}],[\"mapperscan\",{\"1\":{\"368\":1,\"661\":3}}],[\"mapreduce和hive等有相关了解\",{\"1\":{\"293\":1}}],[\"map<k\",{\"1\":{\"974\":1}}],[\"map<object\",{\"1\":{\"972\":1,\"1043\":1}}],[\"map<attributekey<\",{\"1\":{\"790\":1}}],[\"map<channeloption<\",{\"1\":{\"790\":1}}],[\"map<class<\",{\"1\":{\"783\":1}}],[\"map<statusenum\",{\"1\":{\"343\":1}}],[\"map<string\",{\"1\":{\"77\":1,\"268\":1,\"368\":1,\"622\":1,\"635\":1,\"968\":1,\"1032\":1}}],[\"map<integer\",{\"1\":{\"285\":1,\"773\":1,\"788\":1}}],[\"map的value为需要缓存的值\",{\"1\":{\"247\":1}}],[\"map的key为threadlocal对象\",{\"1\":{\"247\":1}}],[\"map\",{\"1\":{\"77\":3,\"249\":1,\"268\":3,\"272\":1,\"290\":3,\"339\":2,\"342\":1,\"343\":3,\"561\":2,\"635\":2,\"688\":1,\"695\":1,\"783\":3,\"974\":3,\"1032\":2}}],[\"matchquery\",{\"1\":{\"941\":2}}],[\"matchallquery\",{\"1\":{\"936\":1,\"938\":1,\"939\":1,\"940\":1}}],[\"matchamousse\",{\"1\":{\"74\":1}}],[\"matches\",{\"1\":{\"672\":1}}],[\"match\",{\"1\":{\"265\":1}}],[\"math\",{\"1\":{\"194\":2,\"195\":3}}],[\"mathbb\",{\"1\":{\"26\":3}}],[\"main线程就先执行\",{\"1\":{\"993\":1}}],[\"maintainable\",{\"1\":{\"839\":1}}],[\"mainboard=\",{\"1\":{\"52\":2}}],[\"mainboard\",{\"1\":{\"52\":17}}],[\"main\",{\"1\":{\"19\":1,\"41\":1,\"42\":1,\"49\":1,\"52\":2,\"78\":1,\"82\":2,\"86\":1,\"87\":1,\"89\":2,\"93\":1,\"94\":2,\"95\":1,\"103\":2,\"105\":1,\"108\":1,\"109\":1,\"116\":2,\"120\":1,\"191\":2,\"192\":1,\"194\":4,\"206\":1,\"211\":1,\"221\":1,\"224\":3,\"225\":3,\"232\":1,\"277\":2,\"282\":1,\"283\":1,\"336\":1,\"339\":1,\"441\":1,\"450\":1,\"463\":1,\"510\":1,\"512\":1,\"515\":1,\"523\":1,\"647\":1,\"648\":1,\"650\":1,\"652\":1,\"655\":1,\"743\":1,\"744\":1,\"749\":4,\"750\":2,\"753\":1,\"754\":3,\"755\":1,\"756\":3,\"759\":2,\"775\":1,\"776\":2,\"783\":2,\"785\":1,\"787\":1,\"790\":1,\"798\":1,\"800\":1,\"801\":1,\"803\":1,\"804\":1,\"810\":3,\"811\":1,\"812\":4,\"813\":3,\"814\":1,\"816\":1,\"826\":1,\"845\":2,\"846\":18,\"859\":1,\"870\":1,\"872\":1,\"884\":2,\"886\":7,\"889\":2,\"890\":1,\"893\":2,\"896\":1,\"898\":2,\"907\":3,\"909\":1}}],[\"machine\",{\"1\":{\"11\":1}}],[\"mm\",{\"1\":{\"993\":1}}],[\"mmgeneration\",{\"1\":{\"7\":1,\"10\":1,\"14\":1,\"19\":1}}],[\"mmlab\",{\"1\":{\"7\":1,\"10\":1,\"14\":1}}],[\"英伟达gaugan2神笔马良\",{\"1\":{\"11\":1}}],[\"照片转动漫animegan\",{\"1\":{\"11\":1}}],[\"趣味案例\",{\"0\":{\"18\":1}}],[\"趣味demo\",{\"0\":{\"11\":1}}],[\"趣味应用\",{\"0\":{\"4\":1}}],[\"黑名单功能等等\",{\"1\":{\"274\":1}}],[\"黑色汽车和红色汽车等\",{\"1\":{\"112\":1}}],[\"黑箱\",{\"1\":{\"112\":1}}],[\"黑马品牌的安全门具有防盗\",{\"1\":{\"110\":1}}],[\"黑白图像上色\",{\"1\":{\"16\":1}}],[\"黑白老照片上色\",{\"1\":{\"11\":3}}],[\"黑白老照片上色修复\",{\"1\":{\"10\":1}}],[\"黑夜转成白天\",{\"1\":{\"10\":1}}],[\"野马转成斑马\",{\"1\":{\"10\":1}}],[\"野马转斑马花纹\",{\"1\":{\"3\":1}}],[\"论文地址\",{\"1\":{\"30\":1}}],[\"论文\",{\"1\":{\"17\":1}}],[\"论文作者为\",{\"1\":{\"10\":1}}],[\"论文主页\",{\"1\":{\"3\":1,\"10\":1,\"17\":1}}],[\"​\\t2\",{\"1\":{\"78\":1}}],[\"​\",{\"1\":{\"8\":3,\"39\":2,\"44\":1,\"78\":1,\"101\":3,\"162\":1}}],[\"xsd\",{\"1\":{\"1038\":2}}],[\"xsi\",{\"1\":{\"1038\":1}}],[\"xsi=\",{\"1\":{\"1038\":1}}],[\"xzf\",{\"1\":{\"1012\":1}}],[\"xcontenttype\",{\"1\":{\"934\":5}}],[\"x64aaa\",{\"1\":{\"873\":1}}],[\"x64\",{\"1\":{\"873\":1}}],[\"xmlschema\",{\"1\":{\"1038\":1}}],[\"xmlns\",{\"1\":{\"1038\":1}}],[\"xmlns=\",{\"1\":{\"1038\":1}}],[\"xmlwebapplicationcontext\",{\"1\":{\"451\":1}}],[\"xml\",{\"1\":{\"366\":2,\"451\":3,\"454\":1,\"646\":3,\"653\":2,\"1038\":1}}],[\"xml配置参数使用\",{\"1\":{\"268\":1}}],[\"xx\",{\"1\":{\"362\":1}}],[\"xxx\",{\"1\":{\"351\":1}}],[\"xxx的方式命名\",{\"1\":{\"265\":1}}],[\"xiao\",{\"1\":{\"276\":1}}],[\"xiaolin\",{\"1\":{\"276\":1}}],[\"xiaolincoding\",{\"1\":{\"275\":1,\"278\":1}}],[\"xijieharddisk\",{\"1\":{\"109\":6}}],[\"x→∞lim​x222​−∫15​xdx+n=1∑20​n2=j=1∏3​yj​+x→−2lim​xx−2​\",{\"1\":{\"35\":1}}],[\"x\",{\"1\":{\"8\":4,\"26\":2,\"191\":3,\"232\":6,\"283\":2,\"285\":13,\"287\":3,\"290\":4,\"312\":2,\"398\":3,\"400\":1,\"705\":2,\"826\":1,\"841\":1,\"842\":5,\"923\":3}}],[\"d2\",{\"1\":{\"872\":1}}],[\"d1\",{\"1\":{\"872\":3}}],[\"dump\",{\"1\":{\"849\":31}}],[\"dubbo\",{\"1\":{\"841\":1}}],[\"duplicate\",{\"0\":{\"827\":1},\"1\":{\"831\":1}}],[\"dd\",{\"1\":{\"755\":1,\"993\":1}}],[\"dddd|\",{\"1\":{\"756\":1}}],[\"ddd\",{\"1\":{\"339\":1}}],[\"d\",{\"1\":{\"441\":4,\"646\":1,\"749\":1,\"750\":2,\"754\":12,\"755\":11,\"756\":11,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":8,\"829\":4,\"830\":2,\"846\":1,\"849\":5,\"855\":2,\"857\":3,\"858\":7,\"871\":10,\"872\":1,\"873\":2,\"886\":2,\"898\":1,\"907\":1}}],[\"dbrollback\",{\"1\":{\"990\":3}}],[\"dbfallback\",{\"1\":{\"990\":6}}],[\"dbcp2\",{\"1\":{\"660\":1}}],[\"db\",{\"1\":{\"429\":1}}],[\"ds\",{\"1\":{\"372\":2}}],[\"dss\",{\"1\":{\"342\":2}}],[\"druiddatasource\",{\"1\":{\"672\":1}}],[\"druid\",{\"1\":{\"672\":3}}],[\"driven\",{\"1\":{\"409\":2,\"839\":1}}],[\"driver\",{\"1\":{\"372\":4}}],[\"draw\",{\"1\":{\"58\":7}}],[\"dns解析\",{\"1\":{\"198\":1}}],[\"dp\",{\"1\":{\"195\":14}}],[\"dma将数据读入内核缓冲区\",{\"1\":{\"905\":2}}],[\"dma\",{\"1\":{\"904\":4,\"905\":2}}],[\"dma控制器\",{\"1\":{\"181\":1}}],[\"dma方式\",{\"1\":{\"181\":1}}],[\"does\",{\"1\":{\"1025\":1}}],[\"dostartthread\",{\"1\":{\"791\":3}}],[\"dobeginread\",{\"1\":{\"790\":2,\"793\":2}}],[\"dobind0\",{\"1\":{\"790\":9}}],[\"dobind\",{\"1\":{\"790\":5}}],[\"docdelete\",{\"1\":{\"950\":1}}],[\"document\",{\"0\":{\"924\":1},\"1\":{\"950\":2}}],[\"documented\",{\"1\":{\"731\":1}}],[\"doc\",{\"1\":{\"923\":1,\"934\":1}}],[\"docker\",{\"1\":{\"897\":1}}],[\"docbase\",{\"1\":{\"653\":1,\"655\":4}}],[\"docsave\",{\"1\":{\"950\":1}}],[\"docs\",{\"1\":{\"19\":1,\"1031\":1}}],[\"doreadbytes\",{\"1\":{\"794\":1}}],[\"doreadmessages\",{\"1\":{\"793\":2}}],[\"doregister\",{\"1\":{\"790\":1,\"793\":1}}],[\"doresolvedependency\",{\"1\":{\"473\":1}}],[\"doreleaseshared\",{\"1\":{\"255\":1}}],[\"doublesummarystatistics\",{\"1\":{\"342\":1}}],[\"double\",{\"1\":{\"342\":2,\"343\":2,\"822\":2,\"950\":2,\"987\":1}}],[\"doublebuffer\",{\"1\":{\"332\":1,\"911\":1}}],[\"doubleaccumulator\",{\"1\":{\"232\":1}}],[\"doubleadder\",{\"1\":{\"232\":1}}],[\"doacquiresharedinterruptibly\",{\"1\":{\"255\":1}}],[\"doacquireshared\",{\"1\":{\"255\":1}}],[\"doacquireinterruptibly\",{\"1\":{\"255\":1}}],[\"do\",{\"1\":{\"191\":2,\"260\":3,\"793\":1,\"794\":1,\"846\":1,\"907\":2,\"996\":1}}],[\"don\",{\"1\":{\"105\":1}}],[\"dynamicinterceptionadvice\",{\"1\":{\"556\":1}}],[\"dynamictablenameinnerinterceptor\",{\"1\":{\"368\":5}}],[\"dynamictable\",{\"1\":{\"368\":1}}],[\"dynamic\",{\"1\":{\"94\":3,\"275\":1,\"372\":1}}],[\"dictionary\",{\"1\":{\"1009\":1}}],[\"dircount\",{\"1\":{\"872\":3}}],[\"dir\",{\"1\":{\"871\":1,\"872\":6,\"1015\":1}}],[\"direction\",{\"1\":{\"950\":1}}],[\"directbytebuffer\",{\"1\":{\"905\":1,\"911\":1}}],[\"directbytebuf\",{\"1\":{\"905\":4}}],[\"directbuffer\",{\"1\":{\"819\":1}}],[\"directly\",{\"1\":{\"790\":1}}],[\"direct\",{\"1\":{\"781\":1,\"904\":1}}],[\"directfieldaccess\",{\"1\":{\"576\":1}}],[\"directfieldaccessor\",{\"1\":{\"576\":1,\"579\":1}}],[\"directorynotemptyexception\",{\"1\":{\"872\":1}}],[\"director是指挥者\",{\"1\":{\"49\":1}}],[\"director\",{\"1\":{\"48\":1,\"49\":8}}],[\"dio\",{\"1\":{\"820\":1}}],[\"di主要有两种注入方式\",{\"1\":{\"706\":1}}],[\"digits\",{\"1\":{\"849\":3}}],[\"digitobserver\",{\"1\":{\"82\":7}}],[\"diginautowired\",{\"1\":{\"472\":1}}],[\"disconnect\",{\"1\":{\"749\":1}}],[\"discarded\",{\"1\":{\"825\":1}}],[\"discardoldestpolicy弃老策略\",{\"1\":{\"243\":1}}],[\"discardpolicy丢弃策略\",{\"1\":{\"243\":1}}],[\"disposablebean\",{\"1\":{\"495\":1}}],[\"dispatcherservlet根据view进行渲染视图\",{\"1\":{\"736\":1}}],[\"dispatcherservlet将modelandview传给viewreslover视图解析器\",{\"1\":{\"736\":1}}],[\"dispatcherservlet调用handleradapter处理器适配器\",{\"1\":{\"736\":1}}],[\"dispatcherservlet收到请求调用handllermapping处理器映射器\",{\"1\":{\"736\":1}}],[\"dispatcherservlet就用这个view对象对modelandview中的模型数据进行视图渲染\",{\"1\":{\"736\":1}}],[\"dispatcherservlet借由viewresolver完成逻辑视图名到真实视图对象的解析工作\",{\"1\":{\"736\":1}}],[\"dispatcherservlet接收到这个请求后\",{\"1\":{\"736\":1}}],[\"dispatcherservletregistrationbean\",{\"1\":{\"664\":1}}],[\"dispatcherservletautoconfiguration\",{\"0\":{\"664\":1},\"1\":{\"644\":1}}],[\"dispatcherservlet\",{\"0\":{\"559\":1},\"1\":{\"457\":1,\"561\":2,\"644\":8,\"657\":1,\"664\":1,\"665\":1}}],[\"distinct\",{\"1\":{\"266\":1,\"267\":2,\"338\":2,\"383\":3}}],[\"daemon\",{\"1\":{\"1016\":1}}],[\"daemonize\",{\"1\":{\"1015\":1}}],[\"dao中\",{\"1\":{\"961\":1}}],[\"dao层是data\",{\"1\":{\"735\":1}}],[\"dao层是做什么的\",{\"0\":{\"735\":1}}],[\"dao\",{\"1\":{\"366\":1}}],[\"datetimeformatter\",{\"1\":{\"993\":1}}],[\"date\",{\"1\":{\"776\":3,\"803\":2,\"835\":1,\"993\":2}}],[\"dateforamt类中的getinstance\",{\"1\":{\"78\":1}}],[\"databases\",{\"1\":{\"1015\":1}}],[\"databind<\",{\"1\":{\"931\":1,\"1038\":1}}],[\"datacenterid值必须大于0并且小于\",{\"1\":{\"441\":1}}],[\"datacenterid位需要左移的位数\",{\"1\":{\"441\":1}}],[\"datacenterid占用5个比特位\",{\"1\":{\"441\":1}}],[\"datacenterid占用的位数\",{\"1\":{\"441\":1}}],[\"datacenterid\",{\"1\":{\"440\":1,\"441\":8}}],[\"datasourcetransactionmanager\",{\"1\":{\"662\":2}}],[\"datasourcetransactionmanagerautoconfiguration\",{\"1\":{\"662\":1}}],[\"datasourceautoconfiguration\",{\"0\":{\"660\":1},\"1\":{\"660\":1}}],[\"datasource1\",{\"1\":{\"372\":1}}],[\"datasource\",{\"1\":{\"372\":8,\"660\":2,\"672\":1}}],[\"datagramchannel\",{\"1\":{\"332\":1,\"898\":4,\"911\":1}}],[\"data\",{\"1\":{\"109\":4,\"260\":4,\"279\":1,\"441\":8,\"667\":1,\"705\":1,\"731\":2,\"773\":1,\"783\":2,\"816\":1,\"846\":2,\"870\":2,\"871\":6,\"872\":4,\"904\":1,\"948\":1,\"949\":1,\"950\":1,\"989\":2,\"1036\":1,\"1038\":1,\"1040\":1}}],[\"darknet\",{\"0\":{\"22\":1},\"1\":{\"30\":2}}],[\"dall\",{\"1\":{\"11\":1}}],[\"dalle\",{\"1\":{\"11\":1}}],[\"danieltakeshi\",{\"1\":{\"6\":1,\"13\":1}}],[\"determine\",{\"1\":{\"1024\":1}}],[\"details\",{\"1\":{\"31\":4,\"213\":1,\"214\":1,\"215\":1,\"219\":1}}],[\"devtools<\",{\"1\":{\"948\":1}}],[\"development\",{\"1\":{\"839\":1}}],[\"deallocate\",{\"1\":{\"825\":1}}],[\"decode\",{\"1\":{\"770\":2,\"771\":1,\"773\":1,\"855\":1,\"909\":1}}],[\"decr\",{\"1\":{\"422\":1,\"1025\":1}}],[\"decrementandget\",{\"1\":{\"232\":1}}],[\"delaynanos\",{\"1\":{\"792\":1}}],[\"delayed等\",{\"1\":{\"265\":1}}],[\"delegate\",{\"1\":{\"576\":1}}],[\"deletebyid\",{\"1\":{\"950\":1}}],[\"deleteindex\",{\"1\":{\"950\":2}}],[\"deleteindexrequest\",{\"1\":{\"933\":2}}],[\"deleteonexit\",{\"1\":{\"655\":1}}],[\"deleteobserver\",{\"1\":{\"82\":1}}],[\"delete\",{\"1\":{\"267\":2,\"314\":1,\"366\":3,\"383\":2,\"872\":4,\"933\":1,\"983\":1,\"988\":1,\"990\":1,\"1024\":1}}],[\"deleted\",{\"1\":{\"265\":1}}],[\"del\",{\"1\":{\"430\":1,\"1024\":6}}],[\"def\",{\"1\":{\"751\":2}}],[\"deferredimportselector\",{\"1\":{\"670\":1,\"671\":2}}],[\"defensive\",{\"1\":{\"236\":1}}],[\"definition\",{\"1\":{\"454\":4,\"682\":1}}],[\"defaultpromisetest\",{\"1\":{\"815\":4}}],[\"defaultpromisetest2\",{\"1\":{\"810\":4,\"811\":3,\"812\":7,\"813\":4,\"814\":3}}],[\"defaultpromise\",{\"1\":{\"815\":10}}],[\"defaultpromise<integer>\",{\"1\":{\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":1}}],[\"defaultpromise<>\",{\"1\":{\"787\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":1}}],[\"defaultpromise<object>\",{\"1\":{\"787\":1}}],[\"defaulteventloop\",{\"1\":{\"796\":5,\"810\":3,\"811\":4,\"812\":5,\"813\":3,\"814\":4,\"815\":6}}],[\"defaulteventloopgroup\",{\"1\":{\"796\":4,\"798\":7}}],[\"defaulterrorattributes\",{\"1\":{\"617\":1,\"622\":1}}],[\"defaultmaxmessagesrecvbytebufallocator\",{\"1\":{\"794\":1}}],[\"defaultchannelpipeline\",{\"1\":{\"790\":1,\"793\":1,\"825\":1}}],[\"defaultchannelpromise\",{\"1\":{\"790\":1}}],[\"defaultchannelconfig\",{\"1\":{\"776\":1}}],[\"defaultcharset\",{\"1\":{\"767\":1,\"798\":2,\"816\":1,\"844\":2,\"890\":3,\"893\":1,\"909\":2}}],[\"defaultserversocketchannelconfig\",{\"1\":{\"776\":1}}],[\"defaultspecificskin和heimaspecificskin\",{\"1\":{\"107\":1}}],[\"defaultfullhttpresponse\",{\"1\":{\"768\":2}}],[\"defaultbuffersize\",{\"1\":{\"745\":1}}],[\"default\",{\"1\":{\"731\":2,\"770\":1,\"791\":1,\"798\":2,\"818\":1,\"819\":2,\"826\":2,\"829\":4,\"830\":2,\"933\":3,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"defaultvalue\",{\"1\":{\"568\":1}}],[\"defaultlistablebeanfactory\",{\"0\":{\"452\":1},\"1\":{\"451\":2,\"496\":1}}],[\"debugread\",{\"1\":{\"849\":1,\"876\":1,\"877\":1}}],[\"debugall\",{\"1\":{\"849\":1,\"859\":1,\"890\":1,\"896\":1}}],[\"debug\",{\"1\":{\"224\":6,\"225\":6,\"263\":6,\"449\":1,\"491\":3,\"711\":6,\"749\":15,\"750\":9,\"753\":3,\"754\":26,\"755\":22,\"756\":26,\"759\":3,\"762\":2,\"764\":2,\"768\":3,\"770\":2,\"771\":2,\"773\":2,\"775\":1,\"776\":1,\"783\":2,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"798\":34,\"800\":4,\"801\":7,\"803\":4,\"804\":6,\"807\":3,\"808\":4,\"809\":3,\"810\":8,\"811\":6,\"812\":6,\"813\":8,\"814\":6,\"816\":6,\"825\":1,\"846\":19,\"855\":2,\"857\":3,\"858\":2,\"876\":4,\"877\":2,\"884\":2,\"886\":9,\"890\":4,\"896\":3,\"898\":1,\"907\":8,\"949\":1,\"960\":1}}],[\"dependencies>\",{\"1\":{\"931\":1,\"948\":1,\"1038\":1}}],[\"dependencies=web\",{\"1\":{\"646\":1}}],[\"dependencydescriptor\",{\"1\":{\"473\":2}}],[\"dependency>\",{\"1\":{\"95\":1,\"372\":2,\"648\":1,\"672\":1,\"679\":1,\"833\":1,\"931\":9,\"948\":7,\"998\":1,\"1032\":2,\"1038\":5}}],[\"depth\",{\"1\":{\"104\":1}}],[\"designmode\",{\"0\":{\"1047\":1}}],[\"deserialize\",{\"1\":{\"773\":4}}],[\"destructionawarebeanpostprocessor\",{\"1\":{\"711\":1}}],[\"destroybean\",{\"1\":{\"496\":1}}],[\"destroymethod\",{\"1\":{\"495\":1}}],[\"dest\",{\"1\":{\"276\":3}}],[\"description>\",{\"1\":{\"1038\":1}}],[\"description=redis\",{\"1\":{\"1016\":1}}],[\"description\",{\"1\":{\"731\":4}}],[\"descriptor\",{\"1\":{\"407\":1}}],[\"desc\",{\"1\":{\"104\":6,\"950\":1}}],[\"desktop\",{\"1\":{\"89\":2,\"103\":2}}],[\"dessert\",{\"1\":{\"74\":3}}],[\"dessertfactory\",{\"1\":{\"74\":3}}],[\"demo<\",{\"1\":{\"1038\":2}}],[\"demo6\",{\"1\":{\"505\":1,\"507\":1}}],[\"demo\",{\"1\":{\"78\":1,\"500\":5}}],[\"deoldify\",{\"1\":{\"11\":1}}],[\"deepai\",{\"1\":{\"11\":1}}],[\"dg∗​\",{\"1\":{\"8\":1}}],[\"other\",{\"1\":{\"907\":2}}],[\"owor\",{\"1\":{\"889\":1}}],[\"owner为空\",{\"1\":{\"212\":1}}],[\"oom\",{\"1\":{\"876\":1}}],[\"oos\",{\"1\":{\"89\":3,\"103\":2,\"770\":2,\"771\":2}}],[\"oio\",{\"1\":{\"776\":1,\"812\":2,\"815\":2}}],[\"ois\",{\"1\":{\"89\":2,\"103\":2,\"770\":2,\"771\":2}}],[\"oxm\",{\"1\":{\"705\":2}}],[\"ok\",{\"1\":{\"426\":2,\"630\":1,\"731\":1,\"732\":1,\"737\":1,\"768\":1,\"960\":2,\"968\":1,\"983\":3,\"990\":1,\"994\":2,\"995\":1,\"998\":3,\"1024\":2,\"1025\":5,\"1027\":2}}],[\"o利用率\",{\"1\":{\"424\":1}}],[\"o采用了多线程\",{\"1\":{\"423\":1}}],[\"o和键值对读写是有一个线程完成的\",{\"1\":{\"423\":1}}],[\"o对比\",{\"1\":{\"409\":1}}],[\"o多路复用\",{\"1\":{\"409\":2}}],[\"o访问\",{\"1\":{\"409\":1}}],[\"o的缺点\",{\"1\":{\"408\":1}}],[\"o的数据缓存在文件系统的页缓存\",{\"1\":{\"408\":1}}],[\"o的新特性\",{\"1\":{\"332\":1}}],[\"o机制中\",{\"1\":{\"408\":1}}],[\"o又被称作标准i\",{\"1\":{\"408\":1}}],[\"o编程时\",{\"1\":{\"333\":1}}],[\"o方式\",{\"1\":{\"332\":1}}],[\"onunhandledinboundmessage\",{\"1\":{\"825\":2}}],[\"oncomplete\",{\"1\":{\"742\":1,\"743\":1,\"744\":2}}],[\"onnext\",{\"1\":{\"742\":1,\"743\":1,\"744\":2}}],[\"onsubscribe\",{\"1\":{\"742\":1,\"743\":1,\"744\":2}}],[\"onstartup\",{\"1\":{\"655\":1,\"657\":2}}],[\"on\",{\"1\":{\"305\":1,\"366\":1,\"790\":1}}],[\"onetwothreefourfive\",{\"1\":{\"858\":1}}],[\"onetwothree\",{\"1\":{\"857\":1}}],[\"onerror\",{\"1\":{\"742\":1,\"743\":1,\"744\":2}}],[\"one\",{\"1\":{\"305\":1,\"943\":1,\"960\":1,\"968\":1}}],[\"onlyifabsent\",{\"1\":{\"249\":3}}],[\"only\",{\"1\":{\"111\":1,\"1003\":1,\"1025\":1}}],[\"oldlimit\",{\"1\":{\"849\":3,\"859\":3}}],[\"oldwakenup\",{\"1\":{\"791\":3,\"792\":2}}],[\"old这两个组合声明为废弃\",{\"1\":{\"360\":1}}],[\"old作为cms出现\",{\"1\":{\"360\":1}}],[\"old\",{\"1\":{\"350\":1,\"360\":9}}],[\"oldval\",{\"1\":{\"249\":5}}],[\"oldmode\",{\"1\":{\"104\":1}}],[\"o请求的顺序\",{\"1\":{\"183\":1}}],[\"o请求到来时\",{\"1\":{\"183\":1}}],[\"o请求\",{\"1\":{\"183\":1}}],[\"o调度\",{\"1\":{\"183\":1}}],[\"o系统\",{\"1\":{\"183\":1}}],[\"o核心子系统\",{\"0\":{\"183\":1},\"1\":{\"183\":1}}],[\"o软件层次结构\",{\"0\":{\"182\":1}}],[\"o指令\",{\"1\":{\"181\":2}}],[\"o已完成\",{\"1\":{\"181\":1}}],[\"o完成的过程中cpu可以切换到别的进程执行\",{\"1\":{\"181\":1}}],[\"o完成的过程中cpu需要不断的轮询检查\",{\"1\":{\"181\":1}}],[\"o控制方式\",{\"0\":{\"181\":1}}],[\"o控制器会通过中断信号主动报告i\",{\"1\":{\"181\":1}}],[\"o控制器可能会对应多个设备\",{\"1\":{\"180\":1}}],[\"o控制器的组成\",{\"1\":{\"180\":1}}],[\"o控制器\",{\"0\":{\"180\":1},\"1\":{\"180\":1}}],[\"o与寄存器独立编址\",{\"1\":{\"180\":1}}],[\"o专用地址\",{\"1\":{\"180\":1}}],[\"o开销较大\",{\"1\":{\"164\":1}}],[\"opsforhash\",{\"1\":{\"968\":1,\"972\":1,\"1043\":3}}],[\"opsforvalue\",{\"1\":{\"968\":1,\"983\":2,\"985\":3,\"988\":4,\"989\":2,\"990\":8,\"993\":1,\"994\":1,\"1040\":2,\"1042\":4}}],[\"ops\",{\"1\":{\"792\":3}}],[\"op\",{\"1\":{\"790\":2,\"792\":5,\"793\":1,\"884\":1,\"886\":2,\"890\":2,\"893\":6,\"896\":2}}],[\"optimization\",{\"0\":{\"1055\":1}}],[\"option\",{\"1\":{\"750\":2,\"775\":1,\"776\":1}}],[\"optional\",{\"1\":{\"688\":1,\"695\":3}}],[\"optional>\",{\"1\":{\"679\":1,\"948\":1,\"1038\":1}}],[\"optional<employee>\",{\"1\":{\"341\":1}}],[\"options0\",{\"1\":{\"790\":1}}],[\"options\",{\"1\":{\"314\":1,\"790\":3,\"1018\":1}}],[\"opt\",{\"1\":{\"163\":2,\"420\":1}}],[\"operationcomplete\",{\"1\":{\"790\":1,\"793\":1,\"803\":3,\"804\":1,\"808\":1}}],[\"operating\",{\"1\":{\"125\":1}}],[\"opens\",{\"1\":{\"449\":1,\"498\":1,\"502\":1,\"519\":2,\"523\":1}}],[\"openai\",{\"1\":{\"11\":2}}],[\"openmmlab图像生成开源算法库mmgeneration\",{\"1\":{\"10\":1}}],[\"openmmlab开源图像生成算法库mmgeneration\",{\"1\":{\"7\":1,\"14\":1}}],[\"open\",{\"1\":{\"7\":1,\"10\":1,\"14\":1,\"790\":2,\"876\":2,\"877\":1,\"880\":1,\"884\":2,\"886\":2,\"890\":3,\"893\":4,\"896\":3,\"898\":2,\"907\":1,\"909\":1}}],[\"o速度比文件区的更快\",{\"1\":{\"153\":1}}],[\"o设备输入的数据\",{\"1\":{\"184\":1}}],[\"o设备获得数据\",{\"1\":{\"184\":1}}],[\"o设备有不同的硬件特性\",{\"1\":{\"182\":1}}],[\"o设备与内存之间的传输\",{\"1\":{\"181\":1}}],[\"o设备可并行工作\",{\"1\":{\"181\":1}}],[\"o设备可以尽早投入使用\",{\"1\":{\"139\":1}}],[\"o设备可以和cpu并行工作\",{\"1\":{\"139\":1}}],[\"o设备只能串行工作\",{\"1\":{\"181\":1}}],[\"o设备\",{\"1\":{\"181\":6}}],[\"o设备的并行性得到提升\",{\"1\":{\"181\":1}}],[\"o设备的电子部件\",{\"1\":{\"180\":1}}],[\"o设备的机械部件\",{\"1\":{\"180\":1}}],[\"o设备的分类\",{\"1\":{\"179\":1}}],[\"o设备的基本概念和分类\",{\"0\":{\"179\":1}}],[\"o设备介绍\",{\"1\":{\"179\":1}}],[\"o设备等\",{\"1\":{\"129\":1}}],[\"o繁忙型进程优先运行\",{\"1\":{\"139\":1}}],[\"o繁忙型进程\",{\"1\":{\"139\":1}}],[\"o型进程\",{\"1\":{\"139\":1}}],[\"o操作都是缓存i\",{\"1\":{\"408\":1}}],[\"o操作开始之前\",{\"1\":{\"181\":2}}],[\"o操作写回外存\",{\"1\":{\"163\":1}}],[\"o操作完成的时间\",{\"1\":{\"138\":1}}],[\"o操作\",{\"1\":{\"130\":1,\"139\":1,\"163\":1,\"164\":1}}],[\"os还须再利用页\",{\"1\":{\"418\":1}}],[\"os的运行机制和体系结构\",{\"0\":{\"128\":1}}],[\"os\",{\"1\":{\"125\":1}}],[\"o\",{\"0\":{\"408\":1,\"409\":1,\"1048\":1},\"1\":{\"82\":6,\"95\":3,\"163\":1,\"169\":1,\"180\":1,\"246\":1,\"276\":2,\"277\":4,\"279\":2,\"331\":1,\"333\":1,\"387\":1,\"408\":2,\"409\":8,\"430\":1,\"646\":1,\"787\":2,\"798\":12,\"800\":2,\"801\":5,\"810\":4,\"811\":3,\"812\":3,\"813\":4,\"814\":3,\"858\":1}}],[\"observer2\",{\"1\":{\"82\":2}}],[\"observer1\",{\"1\":{\"82\":2}}],[\"observers\",{\"1\":{\"82\":4}}],[\"observer角色负责接收来自subject角色的状态变化的通知\",{\"1\":{\"81\":1}}],[\"observer\",{\"1\":{\"81\":1,\"82\":9}}],[\"observer本来的意思是\",{\"1\":{\"80\":1}}],[\"observer模式也被称为publish\",{\"1\":{\"80\":1}}],[\"observer模式适用于根据对象状态进行相应处理的场景\",{\"1\":{\"80\":1}}],[\"observer模式篇\",{\"1\":{\"79\":1}}],[\"objenesiscglibaopproxy\",{\"1\":{\"531\":1}}],[\"objectmapper\",{\"1\":{\"934\":4,\"1042\":2}}],[\"objectutil\",{\"1\":{\"799\":1,\"983\":1,\"985\":1,\"988\":1,\"990\":1}}],[\"objectutils\",{\"1\":{\"368\":1}}],[\"object的缩写\",{\"1\":{\"735\":1}}],[\"objectprovider\",{\"1\":{\"688\":1}}],[\"objectfactory\",{\"1\":{\"496\":1,\"503\":1,\"688\":1,\"695\":3}}],[\"object>\",{\"1\":{\"268\":2,\"368\":1,\"783\":1,\"790\":5,\"793\":1,\"909\":1,\"968\":1,\"972\":1,\"1040\":1,\"1041\":2,\"1043\":1}}],[\"object类中的方法\",{\"1\":{\"215\":1}}],[\"objectinputstream类\",{\"1\":{\"104\":1}}],[\"objectinputstream\",{\"1\":{\"89\":2,\"103\":2,\"770\":2,\"771\":2,\"773\":4}}],[\"objectoutputstream\",{\"1\":{\"89\":2,\"103\":2,\"770\":2,\"771\":2,\"773\":2}}],[\"object\",{\"1\":{\"77\":1,\"94\":16,\"95\":2,\"104\":8,\"105\":3,\"211\":2,\"221\":4,\"224\":2,\"225\":4,\"237\":1,\"249\":1,\"325\":3,\"463\":4,\"510\":1,\"512\":2,\"515\":10,\"523\":4,\"711\":8,\"727\":1,\"758\":2,\"759\":1,\"764\":2,\"767\":1,\"768\":1,\"773\":8,\"783\":3,\"784\":1,\"785\":1,\"787\":3,\"788\":1,\"793\":1,\"798\":3,\"799\":2,\"816\":6,\"825\":4,\"844\":2,\"909\":2,\"924\":1,\"960\":1,\"961\":2,\"972\":3,\"1040\":1,\"1042\":1}}],[\"obj2\",{\"1\":{\"325\":1}}],[\"obj1\",{\"1\":{\"325\":1}}],[\"obj\",{\"1\":{\"26\":2,\"77\":2,\"95\":2,\"104\":5,\"211\":2,\"325\":1}}],[\"origin\",{\"1\":{\"826\":8,\"849\":3}}],[\"original\",{\"1\":{\"285\":2,\"928\":1}}],[\"ordinal\",{\"1\":{\"773\":1}}],[\"orders\",{\"1\":{\"1005\":1}}],[\"orderid\",{\"1\":{\"995\":3,\"998\":9}}],[\"order这张表中\",{\"1\":{\"992\":1}}],[\"orderedeventexecutor\",{\"1\":{\"796\":1}}],[\"orderedcharacterencodingfilter\",{\"1\":{\"668\":1}}],[\"ordered\",{\"1\":{\"466\":1}}],[\"order\",{\"1\":{\"266\":3,\"383\":2,\"466\":1,\"961\":2,\"993\":1,\"995\":1,\"998\":3}}],[\"ordercoffee\",{\"1\":{\"69\":1}}],[\"orm\",{\"1\":{\"705\":2}}],[\"orm映射\",{\"0\":{\"268\":1}}],[\"oracle\",{\"1\":{\"660\":1}}],[\"or\",{\"1\":{\"98\":1,\"790\":1,\"793\":1,\"1024\":1}}],[\"org\",{\"1\":{\"3\":1,\"11\":2,\"17\":1,\"30\":1,\"372\":1,\"538\":1,\"541\":1,\"544\":1,\"548\":1,\"551\":1,\"555\":1,\"634\":1,\"651\":5,\"659\":1,\"660\":1,\"661\":1,\"662\":2,\"667\":1,\"668\":1,\"1038\":4}}],[\"override\",{\"1\":{\"49\":6,\"52\":2,\"58\":3,\"69\":1,\"82\":4,\"86\":1,\"87\":1,\"89\":1,\"108\":1,\"116\":6,\"120\":4,\"206\":1,\"224\":6,\"225\":6,\"515\":4,\"622\":1,\"655\":1,\"657\":1,\"711\":6,\"731\":1,\"743\":4,\"744\":8,\"749\":5,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"759\":5,\"760\":2,\"761\":5,\"762\":2,\"764\":2,\"767\":3,\"768\":3,\"770\":2,\"771\":2,\"773\":6,\"775\":2,\"783\":4,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"790\":6,\"791\":2,\"793\":2,\"798\":6,\"799\":1,\"803\":5,\"804\":2,\"807\":1,\"808\":2,\"816\":9,\"834\":1,\"835\":1,\"844\":4,\"872\":5,\"896\":2,\"907\":2,\"909\":6,\"949\":1,\"960\":2,\"961\":2,\"968\":1,\"972\":3,\"983\":2,\"990\":1,\"994\":1,\"995\":1,\"998\":1}}],[\"outputstream\",{\"1\":{\"889\":1}}],[\"outputstreamwriter\",{\"1\":{\"845\":2}}],[\"outbound\",{\"1\":{\"837\":1}}],[\"outlist\",{\"1\":{\"771\":2,\"773\":2}}],[\"outerhandle\",{\"1\":{\"104\":1}}],[\"out\",{\"1\":{\"41\":7,\"42\":5,\"49\":2,\"52\":2,\"58\":3,\"69\":2,\"78\":1,\"82\":4,\"86\":3,\"87\":1,\"89\":3,\"93\":2,\"94\":3,\"95\":2,\"103\":2,\"105\":3,\"108\":2,\"109\":7,\"110\":5,\"111\":2,\"116\":6,\"120\":7,\"191\":1,\"194\":2,\"206\":2,\"232\":10,\"235\":1,\"282\":2,\"336\":2,\"338\":1,\"339\":3,\"340\":1,\"341\":2,\"342\":3,\"343\":9,\"441\":3,\"450\":3,\"463\":5,\"500\":2,\"510\":3,\"512\":3,\"515\":4,\"523\":2,\"622\":1,\"647\":1,\"732\":1,\"743\":2,\"744\":4,\"759\":12,\"767\":1,\"770\":11,\"771\":12,\"773\":18,\"775\":1,\"776\":5,\"787\":3,\"796\":4,\"798\":1,\"815\":4,\"818\":1,\"824\":5,\"826\":8,\"829\":3,\"830\":3,\"834\":1,\"844\":2,\"845\":2,\"849\":6,\"855\":2,\"859\":1,\"870\":2,\"871\":2,\"872\":6,\"873\":1,\"876\":1,\"884\":2,\"886\":1,\"889\":5,\"893\":4,\"898\":1,\"909\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":3,\"993\":2,\"1032\":3,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"ofpattern\",{\"1\":{\"993\":1}}],[\"off\",{\"1\":{\"123\":6}}],[\"offset\",{\"1\":{\"44\":2,\"849\":7,\"905\":1}}],[\"ofobuilder\",{\"1\":{\"49\":2}}],[\"ofo单车builder类\",{\"1\":{\"49\":1}}],[\"of\",{\"1\":{\"14\":1,\"104\":1,\"105\":2,\"635\":2,\"638\":2,\"743\":1,\"744\":1,\"825\":1,\"839\":1,\"950\":2,\"1025\":1}}],[\"gz\",{\"1\":{\"1012\":1}}],[\"gt\",{\"1\":{\"997\":1,\"998\":2}}],[\"gte\",{\"1\":{\"942\":1}}],[\"gson\",{\"1\":{\"773\":3}}],[\"gsend\",{\"1\":{\"759\":2}}],[\"gquit\",{\"1\":{\"759\":2}}],[\"gjoin\",{\"1\":{\"759\":2}}],[\"gmembers\",{\"1\":{\"759\":2}}],[\"gmt\",{\"1\":{\"265\":4}}],[\"gg\",{\"1\":{\"756\":1}}],[\"ggggg|\",{\"1\":{\"755\":1}}],[\"globaleventexecutor\",{\"1\":{\"790\":1}}],[\"globalexceptionhandler\",{\"1\":{\"732\":2}}],[\"globalsession\",{\"1\":{\"496\":1}}],[\"g1\",{\"1\":{\"360\":3}}],[\"g1回收器讲下回收过程gc是什么\",{\"1\":{\"355\":1}}],[\"gcc\",{\"1\":{\"1011\":1}}],[\"gcreate\",{\"1\":{\"759\":2}}],[\"gc这三个gc有什么不同呢\",{\"1\":{\"361\":1}}],[\"gc组合\",{\"1\":{\"360\":1}}],[\"gc机制\",{\"1\":{\"355\":1}}],[\"gc原理\",{\"1\":{\"355\":1}}],[\"gc的两种判定方法\",{\"1\":{\"355\":1}}],[\"gc算法有哪些\",{\"1\":{\"355\":1}}],[\"gc大厂面试题\",{\"0\":{\"355\":1}}],[\"gc分代年龄\",{\"1\":{\"353\":1}}],[\"gc混淆使用\",{\"1\":{\"350\":1}}],[\"gc会有这种行为\",{\"1\":{\"350\":1}}],[\"gc会有单独收集老年代的行为\",{\"1\":{\"350\":1}}],[\"gc会和full\",{\"1\":{\"350\":1}}],[\"gc\",{\"0\":{\"350\":3,\"357\":1},\"1\":{\"350\":8,\"355\":3,\"357\":3,\"361\":5,\"819\":1,\"820\":1,\"825\":2}}],[\"g\",{\"1\":{\"267\":4,\"572\":1,\"646\":1,\"826\":1}}],[\"guard\",{\"1\":{\"790\":1}}],[\"guide\",{\"0\":{\"1050\":1}}],[\"guide哥\",{\"1\":{\"731\":1}}],[\"gui\",{\"1\":{\"126\":1}}],[\"guu\",{\"1\":{\"116\":2}}],[\"gbk\",{\"1\":{\"105\":1}}],[\"grpc\",{\"1\":{\"841\":1}}],[\"graph要求数据库保存一下两种信息\",{\"1\":{\"403\":1}}],[\"graph\",{\"1\":{\"403\":1}}],[\"graphobserver\",{\"1\":{\"82\":7}}],[\"groupquitresponsemessage\",{\"1\":{\"773\":3}}],[\"groupquitrequestmessagehandler\",{\"1\":{\"761\":1}}],[\"groupquitrequestmessage\",{\"1\":{\"759\":1,\"761\":1,\"773\":3}}],[\"groupmembersresponsemessage\",{\"1\":{\"761\":1,\"773\":3}}],[\"groupmembersrequestmessagehandler\",{\"1\":{\"761\":1}}],[\"groupmembersrequestmessage\",{\"1\":{\"759\":1,\"761\":1,\"773\":3}}],[\"groupjoinresponsemessage\",{\"1\":{\"761\":4,\"773\":3}}],[\"groupjoinrequestmessagehandler\",{\"1\":{\"761\":1}}],[\"groupjoinrequestmessage\",{\"1\":{\"759\":1,\"761\":1,\"773\":3}}],[\"groupname\",{\"1\":{\"761\":6}}],[\"groupchatresponsemessage\",{\"1\":{\"761\":1,\"773\":3}}],[\"groupchatrequestmessagehandler\",{\"1\":{\"761\":1}}],[\"groupchatrequestmessage\",{\"1\":{\"759\":1,\"761\":1,\"773\":3}}],[\"groupcreateresponsemessage\",{\"1\":{\"761\":3,\"773\":3}}],[\"groupcreaterequestmessagehandler\",{\"1\":{\"761\":1}}],[\"groupcreaterequestmessage\",{\"1\":{\"759\":1,\"761\":1,\"773\":3}}],[\"groupsessionfactory\",{\"1\":{\"761\":5}}],[\"groupsession\",{\"1\":{\"758\":1,\"761\":4}}],[\"group\",{\"1\":{\"383\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"758\":4,\"759\":10,\"761\":9,\"767\":1,\"768\":1,\"775\":4,\"783\":5,\"785\":4,\"787\":4,\"790\":1,\"796\":6,\"798\":5,\"803\":4,\"804\":4,\"808\":2,\"816\":2,\"834\":1,\"835\":1,\"844\":5,\"1024\":2,\"1025\":1}}],[\"groupingby\",{\"1\":{\"343\":1}}],[\"groupid>\",{\"1\":{\"95\":1,\"372\":2,\"648\":1,\"672\":1,\"679\":1,\"833\":1,\"931\":9,\"948\":7,\"998\":1,\"1032\":2,\"1038\":9}}],[\"genericjackson2jsonredisserializer\",{\"1\":{\"1041\":2}}],[\"generic\",{\"1\":{\"1024\":2}}],[\"genericfuturelistener<future<\",{\"1\":{\"808\":1}}],[\"genericapplicationlistener\",{\"1\":{\"703\":2}}],[\"genericapplicationcontext\",{\"1\":{\"450\":2}}],[\"genericconverter\",{\"1\":{\"574\":1}}],[\"generate\",{\"1\":{\"849\":5}}],[\"generator生成的代码中\",{\"1\":{\"268\":1}}],[\"generator\",{\"1\":{\"82\":9}}],[\"generative\",{\"1\":{\"6\":1,\"10\":1,\"13\":1,\"14\":1,\"19\":1}}],[\"ge\",{\"1\":{\"371\":2}}],[\"getjedis\",{\"1\":{\"1032\":1,\"1034\":1,\"1035\":1}}],[\"getendtime\",{\"1\":{\"994\":1,\"995\":1,\"998\":1}}],[\"getexpiretime\",{\"1\":{\"989\":1,\"990\":1}}],[\"getexceptionvalue\",{\"1\":{\"788\":1}}],[\"getdata\",{\"1\":{\"989\":1,\"990\":1}}],[\"getdeclaredfield\",{\"1\":{\"235\":1}}],[\"getdeclaredconstructor\",{\"1\":{\"103\":1}}],[\"getid\",{\"1\":{\"983\":1,\"994\":4,\"995\":1,\"998\":4}}],[\"getintvolatile\",{\"1\":{\"996\":1}}],[\"getinterfacename\",{\"1\":{\"784\":1}}],[\"getinterfaces\",{\"1\":{\"94\":2}}],[\"getinterceptorsanddynamicinterceptionadvice\",{\"1\":{\"549\":1,\"556\":1}}],[\"getindexresponse\",{\"1\":{\"933\":1}}],[\"getindexrequest\",{\"1\":{\"933\":2}}],[\"getinputstream\",{\"1\":{\"105\":1,\"845\":2,\"889\":1}}],[\"getinstance\",{\"1\":{\"57\":4,\"101\":8,\"103\":3,\"104\":2,\"932\":1,\"933\":3,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"getheader\",{\"1\":{\"972\":1}}],[\"gethits\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"gethand\",{\"1\":{\"116\":3}}],[\"getharddisk\",{\"1\":{\"109\":2}}],[\"getlocaladdress\",{\"1\":{\"890\":1}}],[\"getlogger\",{\"1\":{\"491\":1,\"500\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1}}],[\"getunsignedbyte\",{\"1\":{\"849\":5}}],[\"getuser\",{\"1\":{\"962\":1,\"972\":1,\"995\":1,\"998\":4}}],[\"getuserservice\",{\"1\":{\"759\":1,\"760\":1}}],[\"getusername\",{\"1\":{\"759\":1,\"760\":1,\"761\":2}}],[\"getuserandrole\",{\"1\":{\"366\":3}}],[\"getoption\",{\"1\":{\"790\":1}}],[\"getoutputstream\",{\"1\":{\"776\":1,\"845\":2,\"884\":1,\"889\":1,\"904\":1}}],[\"getkey\",{\"1\":{\"790\":1,\"793\":1}}],[\"getklassrelatedteachers\",{\"1\":{\"731\":1,\"737\":1}}],[\"getbegintime\",{\"1\":{\"994\":1,\"995\":1,\"998\":1}}],[\"getbeansoftype\",{\"1\":{\"635\":1,\"657\":1}}],[\"getbean\",{\"1\":{\"446\":1,\"449\":1,\"463\":2,\"496\":1,\"500\":1}}],[\"getbacklog\",{\"1\":{\"790\":2}}],[\"getbyid\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":2,\"995\":1,\"998\":1}}],[\"getbyidwithredis\",{\"1\":{\"983\":1,\"990\":1}}],[\"getbyint\",{\"1\":{\"773\":1}}],[\"getbytes\",{\"1\":{\"767\":12,\"768\":1,\"773\":1,\"798\":2,\"816\":3,\"859\":2,\"884\":1,\"889\":3}}],[\"getgroupsession\",{\"1\":{\"761\":5}}],[\"getgroupname\",{\"1\":{\"761\":9}}],[\"getto\",{\"1\":{\"760\":1}}],[\"getter\",{\"1\":{\"731\":1,\"783\":1}}],[\"getphone\",{\"1\":{\"960\":1,\"968\":1}}],[\"getparametervalue\",{\"1\":{\"784\":1}}],[\"getparametertypes\",{\"1\":{\"784\":1,\"787\":1}}],[\"getpassword\",{\"1\":{\"759\":1,\"760\":1}}],[\"getprime\",{\"1\":{\"192\":2}}],[\"getproxyservice\",{\"1\":{\"787\":2}}],[\"getproxy\",{\"1\":{\"528\":1}}],[\"getproxyobject\",{\"1\":{\"94\":4,\"95\":2}}],[\"getproperty\",{\"1\":{\"77\":1,\"773\":2,\"783\":1}}],[\"getwriter\",{\"1\":{\"622\":1,\"626\":1}}],[\"getfrom\",{\"1\":{\"760\":1,\"761\":1}}],[\"getframe\",{\"1\":{\"49\":2}}],[\"getf\",{\"1\":{\"500\":3}}],[\"getvalue\",{\"1\":{\"336\":3,\"790\":1,\"793\":1}}],[\"get流程\",{\"1\":{\"249\":1}}],[\"get到了forwardingnode\",{\"1\":{\"249\":1}}],[\"get弱一致性\",{\"1\":{\"248\":1}}],[\"getaliases\",{\"1\":{\"933\":1}}],[\"getallocator\",{\"1\":{\"794\":1}}],[\"getattribute\",{\"1\":{\"758\":1,\"960\":1,\"961\":1}}],[\"getapplicationcontext\",{\"1\":{\"657\":1}}],[\"getabsolutepath\",{\"1\":{\"655\":1}}],[\"getage\",{\"1\":{\"336\":4,\"338\":1,\"340\":1,\"341\":1,\"370\":1,\"371\":3}}],[\"getandset\",{\"1\":{\"791\":1}}],[\"getandaccumulate\",{\"1\":{\"232\":2}}],[\"getandadd\",{\"1\":{\"232\":1}}],[\"getandupdate\",{\"1\":{\"232\":2}}],[\"getanddecrement\",{\"1\":{\"232\":1}}],[\"getandincrement\",{\"1\":{\"232\":1,\"896\":1}}],[\"getaddress\",{\"1\":{\"89\":1,\"790\":1}}],[\"get和post的区别\",{\"0\":{\"197\":1},\"1\":{\"740\":1}}],[\"getresponse\",{\"1\":{\"934\":1}}],[\"getresource\",{\"1\":{\"641\":1,\"1034\":1}}],[\"getresourceasstream\",{\"1\":{\"77\":1,\"773\":1,\"783\":1}}],[\"getrequest\",{\"1\":{\"934\":2}}],[\"getrequestdata\",{\"1\":{\"368\":1}}],[\"getremoteaddress\",{\"1\":{\"896\":2,\"909\":3}}],[\"getreturnvalue\",{\"1\":{\"788\":1}}],[\"getreturntype\",{\"1\":{\"787\":1}}],[\"getrole\",{\"1\":{\"366\":2}}],[\"getruntime\",{\"1\":{\"105\":2,\"357\":1,\"896\":1,\"897\":1}}],[\"getnow\",{\"1\":{\"787\":1,\"806\":1,\"808\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":2,\"814\":1}}],[\"getnumber\",{\"1\":{\"82\":4}}],[\"getname\",{\"1\":{\"69\":2,\"87\":1,\"89\":2,\"111\":7,\"336\":2,\"343\":3,\"370\":1,\"371\":3,\"787\":2,\"872\":1,\"909\":3}}],[\"get\",{\"1\":{\"77\":1,\"109\":2,\"197\":1,\"235\":1,\"249\":1,\"285\":3,\"290\":1,\"314\":1,\"336\":1,\"341\":1,\"343\":2,\"368\":2,\"422\":1,\"630\":1,\"759\":1,\"767\":3,\"773\":1,\"783\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":1,\"806\":1,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"812\":4,\"813\":1,\"824\":1,\"846\":1,\"847\":1,\"849\":1,\"853\":4,\"859\":1,\"871\":5,\"872\":12,\"873\":3,\"890\":2,\"907\":1,\"933\":1,\"934\":1,\"950\":1,\"962\":1,\"968\":1,\"983\":1,\"985\":1,\"988\":1,\"989\":1,\"990\":3,\"1025\":8,\"1032\":1,\"1040\":1,\"1042\":2}}],[\"getcode\",{\"1\":{\"960\":1,\"968\":1}}],[\"getconnecttimeoutmillis\",{\"1\":{\"775\":1}}],[\"getcontent\",{\"1\":{\"760\":1,\"761\":1}}],[\"getchannel\",{\"1\":{\"758\":1,\"760\":1,\"787\":3,\"846\":1,\"857\":1,\"858\":1,\"863\":1,\"870\":4}}],[\"getclass\",{\"1\":{\"94\":4,\"95\":1,\"500\":2,\"768\":1,\"784\":1,\"830\":1,\"855\":1}}],[\"getclassloader\",{\"1\":{\"77\":1,\"94\":2,\"510\":1,\"787\":1}}],[\"getcpu\",{\"1\":{\"52\":1,\"109\":2}}],[\"getmappings\",{\"1\":{\"933\":1}}],[\"getmapping\",{\"1\":{\"731\":1,\"737\":1,\"977\":1}}],[\"getmainboard\",{\"1\":{\"52\":1}}],[\"getmemberschannel\",{\"1\":{\"758\":1,\"761\":2}}],[\"getmembers\",{\"1\":{\"758\":1,\"761\":2}}],[\"getmemory\",{\"1\":{\"52\":1,\"109\":2}}],[\"getmessageclass\",{\"1\":{\"773\":2}}],[\"getmessagetype\",{\"1\":{\"770\":1,\"771\":1,\"773\":2,\"783\":2}}],[\"getmessage\",{\"1\":{\"94\":2,\"450\":3,\"515\":1,\"732\":1,\"762\":1}}],[\"getmethodname\",{\"1\":{\"784\":1}}],[\"getmethod\",{\"1\":{\"94\":5,\"515\":2,\"784\":1}}],[\"getsourceasstring\",{\"1\":{\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"getsettings\",{\"1\":{\"933\":1}}],[\"getservice\",{\"1\":{\"783\":1,\"784\":1}}],[\"getserverport\",{\"1\":{\"773\":1}}],[\"getserializeralgorithm\",{\"1\":{\"773\":3}}],[\"getsequenceid\",{\"1\":{\"770\":1,\"771\":1,\"773\":1,\"784\":1,\"788\":1}}],[\"getsession\",{\"1\":{\"760\":2,\"762\":2,\"961\":1}}],[\"getseat\",{\"1\":{\"49\":2}}],[\"getsignature\",{\"1\":{\"523\":2}}],[\"getsalary\",{\"1\":{\"342\":2,\"343\":2}}],[\"getstock\",{\"1\":{\"994\":2,\"995\":1,\"996\":1,\"997\":1,\"998\":1}}],[\"getstatus\",{\"1\":{\"341\":1,\"343\":1}}],[\"getstatic\",{\"1\":{\"230\":1}}],[\"getstu\",{\"1\":{\"89\":3}}],[\"getsum\",{\"1\":{\"116\":2,\"342\":1}}],[\"getshape\",{\"1\":{\"58\":2}}],[\"getscreen\",{\"1\":{\"52\":1}}],[\"google\",{\"1\":{\"19\":1}}],[\"goodfeli\",{\"1\":{\"14\":1}}],[\"goodfellow和图灵奖得主youshua\",{\"1\":{\"10\":1}}],[\"gathering\",{\"0\":{\"858\":1}}],[\"gap\",{\"1\":{\"401\":2}}],[\"games\",{\"1\":{\"116\":4}}],[\"gamecount++\",{\"1\":{\"116\":3}}],[\"gamecount\",{\"1\":{\"116\":2}}],[\"gaugan2\",{\"1\":{\"11\":1}}],[\"gaugan\",{\"1\":{\"11\":1}}],[\"gan的推导及keras手把手实现\",{\"1\":{\"14\":1}}],[\"ganlab\",{\"1\":{\"11\":1}}],[\"gan广泛应用于图像生成\",{\"1\":{\"10\":1}}],[\"gan近年来成为人工智能和深度学习的热门研究领域\",{\"1\":{\"10\":1}}],[\"gan\",{\"0\":{\"8\":1},\"1\":{\"6\":1,\"13\":1,\"14\":1}}],[\"gan动物园\",{\"1\":{\"6\":1,\"13\":1}}],[\"github上的大神编写了redis的图形化桌面客户端\",{\"1\":{\"1019\":1}}],[\"github\",{\"1\":{\"3\":1,\"6\":2,\"7\":2,\"10\":1,\"11\":3,\"13\":2,\"14\":4,\"17\":2,\"19\":2,\"30\":1,\"31\":1,\"32\":4,\"1019\":2}}],[\"0号库\",{\"1\":{\"1021\":1}}],[\"0号盘面是在1号盘面上面的\",{\"1\":{\"177\":1}}],[\"0则可以在任意ip访问\",{\"1\":{\"1015\":1}}],[\"0<\",{\"1\":{\"931\":2,\"1032\":2,\"1038\":1}}],[\"0<n<k\",{\"1\":{\"300\":1}}],[\"0e\",{\"1\":{\"749\":10,\"750\":10,\"756\":1}}],[\"0c\",{\"1\":{\"749\":10,\"750\":10}}],[\"0b\",{\"1\":{\"749\":10,\"750\":10}}],[\"0a\",{\"1\":{\"749\":10,\"750\":10,\"755\":10,\"829\":3,\"830\":1}}],[\"09\",{\"1\":{\"749\":10,\"750\":10,\"756\":3,\"798\":1,\"829\":3,\"830\":1}}],[\"07\",{\"1\":{\"749\":10,\"750\":10,\"754\":21,\"812\":2,\"829\":3,\"830\":1}}],[\"07004\",{\"1\":{\"17\":1}}],[\"06\",{\"1\":{\"749\":10,\"750\":10,\"754\":2,\"756\":1,\"798\":2,\"823\":1,\"824\":3,\"829\":3,\"830\":2}}],[\"0版本引入的新特性\",{\"1\":{\"731\":1}}],[\"0版本之前的单线程指的是其网络i\",{\"1\":{\"423\":1}}],[\"02\",{\"1\":{\"507\":1,\"749\":10,\"750\":10,\"756\":2,\"822\":4,\"823\":1,\"826\":4,\"829\":3,\"830\":2}}],[\"02767\",{\"1\":{\"30\":1}}],[\"08\",{\"1\":{\"441\":2,\"749\":17,\"750\":19,\"755\":19,\"756\":1,\"812\":1,\"829\":3,\"830\":1}}],[\"08589340b276ee29a357f080ed4012b\",{\"1\":{\"157\":1}}],[\"04\",{\"1\":{\"441\":2,\"749\":10,\"750\":10,\"814\":3,\"822\":2,\"823\":1,\"826\":4,\"829\":3,\"830\":2}}],[\"0之前的一个bug\",{\"1\":{\"436\":1}}],[\"0之后\",{\"1\":{\"429\":1}}],[\"0以前的版本要实现集群一般时借助哨兵sentinel工具来监控master节点的状态\",{\"1\":{\"433\":1}}],[\"0引入的多线程指的是网络i\",{\"1\":{\"423\":1}}],[\"0x0f\",{\"1\":{\"849\":2}}],[\"0x01\",{\"1\":{\"729\":2}}],[\"0x250\",{\"1\":{\"822\":2}}],[\"0x251562d5\",{\"1\":{\"798\":6}}],[\"0x2e1884dd\",{\"1\":{\"803\":2}}],[\"0x7f\",{\"1\":{\"849\":1}}],[\"0x749124ba\",{\"1\":{\"803\":2}}],[\"0x744f2b47\",{\"1\":{\"756\":14}}],[\"0x79a26af9\",{\"1\":{\"798\":6}}],[\"0x94b2a840\",{\"1\":{\"798\":6}}],[\"0x94132411\",{\"1\":{\"749\":5}}],[\"0xdff439d3\",{\"1\":{\"756\":2}}],[\"0xd739f137\",{\"1\":{\"754\":14}}],[\"0xf\",{\"1\":{\"849\":1}}],[\"0xf0f347b8\",{\"1\":{\"756\":5}}],[\"0xffffffffl\",{\"1\":{\"849\":2}}],[\"0xff\",{\"1\":{\"279\":1,\"770\":1,\"771\":1,\"773\":1,\"849\":1}}],[\"0xa4b3be43\",{\"1\":{\"755\":12}}],[\"0xe3d9713f\",{\"1\":{\"754\":2}}],[\"0x3c2ef3c2\",{\"1\":{\"754\":5}}],[\"0x1f\",{\"1\":{\"849\":1}}],[\"0x1282d755\",{\"1\":{\"755\":5}}],[\"0x1719abf7\",{\"1\":{\"750\":7}}],[\"0x100000000l\",{\"1\":{\"849\":2}}],[\"0x10\",{\"1\":{\"396\":2}}],[\"0x4d6c6a84\",{\"1\":{\"750\":2}}],[\"0x81e0fda5\",{\"1\":{\"749\":2}}],[\"0可以更换时间低位和时间高位的存储方式\",{\"1\":{\"392\":1}}],[\"0才解决\",{\"1\":{\"391\":1}}],[\"0d\",{\"1\":{\"342\":1,\"749\":10,\"750\":10,\"756\":1,\"907\":1}}],[\"0表示未删除\",{\"1\":{\"265\":1}}],[\"0表示否\",{\"1\":{\"265\":1}}],[\"0竞争成功\",{\"1\":{\"261\":1}}],[\"0和thread\",{\"1\":{\"261\":1}}],[\"0f下雨天留客06天留09我不留\",{\"1\":{\"766\":1}}],[\"0f\",{\"1\":{\"249\":1,\"749\":10,\"750\":10,\"756\":1}}],[\"0lin\",{\"1\":{\"276\":1}}],[\"0l\",{\"1\":{\"244\":2}}],[\"00代表true\",{\"1\":{\"822\":1}}],[\"00\",{\"1\":{\"749\":10,\"750\":10,\"754\":131,\"822\":7,\"823\":6,\"824\":15,\"867\":1,\"993\":3}}],[\"001\",{\"1\":{\"241\":1}}],[\"0000000000000000000000000000000000000000000000000000111111111111\",{\"1\":{\"441\":1}}],[\"0000000000000000000000000000000000000000000000000000000000011111\",{\"1\":{\"441\":2}}],[\"000001\",{\"1\":{\"385\":1}}],[\"000\",{\"1\":{\"241\":1,\"870\":1}}],[\"00表示轻量级锁\",{\"1\":{\"210\":1}}],[\"0123\",{\"1\":{\"890\":1}}],[\"0123456789abcdef3333\",{\"1\":{\"890\":2}}],[\"0123456789abcdef\",{\"1\":{\"849\":1,\"890\":1}}],[\"011\",{\"1\":{\"241\":1}}],[\"010\",{\"1\":{\"241\":1}}],[\"01\",{\"1\":{\"195\":1,\"505\":1,\"749\":10,\"750\":10,\"822\":3,\"823\":1,\"829\":3,\"830\":2}}],[\"01背包\",{\"0\":{\"194\":1}}],[\"0\",{\"1\":{\"82\":2,\"94\":4,\"105\":1,\"116\":12,\"123\":5,\"141\":1,\"163\":6,\"191\":3,\"192\":3,\"194\":10,\"195\":12,\"211\":2,\"225\":6,\"232\":16,\"234\":2,\"236\":3,\"237\":4,\"244\":1,\"249\":10,\"255\":3,\"258\":1,\"262\":2,\"263\":2,\"267\":2,\"272\":1,\"273\":1,\"276\":12,\"277\":6,\"281\":1,\"282\":9,\"283\":6,\"287\":3,\"320\":1,\"342\":1,\"420\":2,\"426\":8,\"429\":1,\"441\":6,\"506\":1,\"515\":2,\"527\":2,\"653\":1,\"670\":1,\"688\":1,\"705\":1,\"732\":1,\"744\":2,\"749\":33,\"750\":40,\"753\":2,\"754\":50,\"755\":44,\"756\":51,\"759\":1,\"764\":4,\"770\":6,\"771\":3,\"773\":6,\"775\":3,\"790\":4,\"791\":1,\"792\":9,\"793\":5,\"794\":3,\"798\":79,\"801\":1,\"803\":16,\"809\":1,\"816\":2,\"818\":4,\"821\":1,\"822\":4,\"823\":2,\"824\":3,\"825\":2,\"826\":8,\"829\":5,\"830\":2,\"835\":2,\"844\":2,\"845\":2,\"846\":1,\"849\":14,\"853\":1,\"855\":2,\"857\":3,\"858\":2,\"859\":2,\"870\":4,\"872\":2,\"876\":1,\"877\":4,\"884\":1,\"886\":19,\"889\":1,\"890\":5,\"893\":2,\"896\":3,\"898\":1,\"907\":2,\"938\":1,\"950\":4,\"961\":1,\"993\":2,\"995\":1,\"997\":2,\"998\":7,\"1015\":11,\"1018\":4,\"1021\":1,\"1024\":53,\"1025\":53,\"1027\":37,\"1028\":10,\"1029\":34,\"1032\":2,\"1034\":1,\"1035\":3,\"1038\":9,\"1039\":1}}],[\"05\",{\"1\":{\"6\":1,\"13\":1,\"749\":10,\"750\":10,\"798\":2,\"822\":1,\"823\":1,\"824\":2,\"826\":2,\"829\":3,\"830\":2}}],[\"03\",{\"1\":{\"6\":1,\"13\":1,\"749\":10,\"750\":10,\"798\":2,\"822\":2,\"823\":1,\"826\":6,\"829\":3,\"830\":2,\"846\":17}}],[\"博客园\",{\"1\":{\"324\":1}}],[\"博客\",{\"0\":{\"6\":1,\"13\":1,\"31\":1}}],[\"zunion\",{\"1\":{\"1030\":1}}],[\"zdiff\",{\"1\":{\"1030\":1}}],[\"zinter\",{\"1\":{\"1030\":1}}],[\"zincrby\",{\"1\":{\"1030\":1}}],[\"zipcode\",{\"1\":{\"385\":1}}],[\"zcount\",{\"1\":{\"1030\":1}}],[\"zcard\",{\"1\":{\"422\":1,\"1030\":1}}],[\"zoneoffset\",{\"1\":{\"993\":1}}],[\"zookeeper\",{\"1\":{\"841\":1}}],[\"zoo\",{\"1\":{\"6\":1,\"13\":1}}],[\"zero\",{\"1\":{\"732\":1}}],[\"zrank\",{\"1\":{\"1030\":2}}],[\"zrangebyscore\",{\"1\":{\"1030\":1}}],[\"zrange\",{\"1\":{\"422\":1,\"1030\":1}}],[\"zrevrank\",{\"1\":{\"1030\":1}}],[\"zrevrange\",{\"1\":{\"422\":1}}],[\"zrem\",{\"1\":{\"1030\":1}}],[\"zrem等\",{\"1\":{\"422\":1}}],[\"zs\",{\"1\":{\"1029\":8}}],[\"zscore\",{\"1\":{\"422\":1,\"1030\":1}}],[\"zset\",{\"1\":{\"278\":1}}],[\"zadd\",{\"1\":{\"422\":1,\"1030\":1}}],[\"zlend\",{\"1\":{\"279\":1}}],[\"zllen\",{\"1\":{\"279\":1}}],[\"zltail\",{\"1\":{\"279\":1}}],[\"zlbytes\",{\"1\":{\"279\":1}}],[\"zhaoliu\",{\"1\":{\"1029\":4}}],[\"zhangsan\",{\"1\":{\"770\":1,\"787\":1,\"798\":6,\"859\":3,\"934\":2,\"1029\":1}}],[\"zh\",{\"1\":{\"450\":1}}],[\"zhuanlan\",{\"1\":{\"12\":2,\"31\":3}}],[\"zhu主页\",{\"1\":{\"5\":1}}],[\"zhihu\",{\"1\":{\"4\":1,\"12\":2,\"31\":3}}],[\"zvideo\",{\"1\":{\"4\":1}}],[\"jedispoolconfig\",{\"1\":{\"1034\":2}}],[\"jedispool\",{\"1\":{\"1034\":5}}],[\"jedisconnectionfacotry\",{\"1\":{\"1034\":2,\"1035\":1}}],[\"jedisconnectionfactory\",{\"1\":{\"1032\":1}}],[\"jedis本身是线程不安全的\",{\"1\":{\"1033\":1}}],[\"jedis连接池\",{\"0\":{\"1033\":1}}],[\"jedis快速入门\",{\"0\":{\"1032\":1}}],[\"jedis和lettuce\",{\"1\":{\"1031\":1}}],[\"jedis\",{\"0\":{\"1031\":1},\"1\":{\"1032\":15,\"1034\":1,\"1035\":6}}],[\"jenkov\",{\"1\":{\"891\":1}}],[\"jemalloc\",{\"1\":{\"820\":1}}],[\"jep291\",{\"1\":{\"362\":1}}],[\"jep214\",{\"1\":{\"360\":1}}],[\"jep363\",{\"1\":{\"360\":1,\"362\":1}}],[\"jep366\",{\"1\":{\"360\":1}}],[\"jep173\",{\"1\":{\"360\":1}}],[\"jctools\",{\"1\":{\"791\":1}}],[\"jconsole有死锁检测功能\",{\"1\":{\"221\":1}}],[\"jjjjjjjj|\",{\"1\":{\"756\":1}}],[\"jjjj\",{\"1\":{\"754\":1}}],[\"jms\",{\"1\":{\"705\":1}}],[\"jsonuser\",{\"1\":{\"1042\":2}}],[\"jsonutil\",{\"1\":{\"983\":1,\"985\":2,\"988\":2,\"989\":3,\"990\":7}}],[\"jsonprocessingexception\",{\"1\":{\"1042\":1}}],[\"json序列化器会将类的class类型写入json结果中\",{\"1\":{\"1042\":1}}],[\"jsonredisserializer\",{\"1\":{\"1041\":3}}],[\"jsonobject\",{\"1\":{\"989\":1}}],[\"json格式的数据\",{\"1\":{\"731\":1,\"737\":1}}],[\"json\",{\"1\":{\"644\":1,\"650\":1,\"668\":1,\"769\":1,\"770\":1,\"771\":1,\"773\":4,\"934\":5,\"990\":7,\"1036\":1,\"1042\":2}}],[\"jsp\",{\"1\":{\"644\":1,\"647\":4,\"648\":1,\"649\":2}}],[\"jstack\",{\"1\":{\"221\":1}}],[\"jdbc\",{\"1\":{\"372\":3,\"660\":2,\"662\":1,\"705\":3}}],[\"jdk7\",{\"1\":{\"871\":1}}],[\"jdk7引入了asynchronous\",{\"1\":{\"333\":1}}],[\"jdkdynamicaopproxy\",{\"1\":{\"531\":2}}],[\"jdkproxydemo\",{\"1\":{\"510\":1}}],[\"jdk9新特性\",{\"1\":{\"362\":1}}],[\"jdk9废弃\",{\"1\":{\"360\":2}}],[\"jdk8新特性\",{\"0\":{\"335\":1}}],[\"jdk提供了四种实现\",{\"1\":{\"243\":1}}],[\"jdk中各种阻塞队列\",{\"1\":{\"218\":1}}],[\"jdk中\",{\"1\":{\"217\":1}}],[\"jdk中的实现类关系结构中可以看出\",{\"1\":{\"44\":1}}],[\"jdk代理效率高于cglib代理\",{\"1\":{\"96\":1}}],[\"jdk代理效率高于cglib代理效率\",{\"1\":{\"96\":1}}],[\"jdk代理和cglib代理\",{\"1\":{\"96\":1}}],[\"jdk14新特性\",{\"1\":{\"362\":1}}],[\"jdk14中\",{\"1\":{\"360\":2}}],[\"jdk1\",{\"1\":{\"96\":3,\"329\":1,\"334\":3,\"872\":2}}],[\"jdk\",{\"0\":{\"362\":1,\"510\":1,\"514\":1,\"515\":1,\"528\":1,\"807\":1},\"1\":{\"94\":3,\"322\":2,\"327\":3,\"449\":2,\"498\":1,\"502\":1,\"511\":1,\"512\":1,\"515\":1,\"519\":1,\"523\":2,\"531\":1,\"546\":1,\"769\":1,\"770\":1,\"771\":1,\"773\":1,\"806\":3,\"897\":1}}],[\"jdk动态代理方式\",{\"1\":{\"94\":2}}],[\"jdk动态代理\",{\"0\":{\"94\":1}}],[\"jdk给出的自身实现\",{\"1\":{\"44\":1}}],[\"jdk源码解析\",{\"0\":{\"44\":1,\"78\":1,\"105\":1,\"123\":1}}],[\"jupiter<\",{\"1\":{\"1032\":2}}],[\"junit\",{\"1\":{\"1032\":1}}],[\"junyanz\",{\"1\":{\"3\":1,\"7\":1,\"17\":1}}],[\"juejin\",{\"1\":{\"393\":1,\"738\":1}}],[\"juc\",{\"1\":{\"232\":1,\"806\":1}}],[\"joinmember\",{\"1\":{\"758\":1,\"761\":1}}],[\"join和future采用的就是该模式\",{\"1\":{\"217\":1}}],[\"join\",{\"1\":{\"204\":1,\"217\":1,\"366\":1,\"383\":1,\"743\":1,\"744\":1}}],[\"job\",{\"1\":{\"139\":1}}],[\"j−k∗v\",{\"1\":{\"195\":1}}],[\"j++\",{\"1\":{\"194\":1,\"195\":3,\"754\":1,\"755\":1,\"756\":1,\"849\":6,\"890\":1}}],[\"jvm会自动回退以默认gc方式启动jvm\",{\"1\":{\"362\":1}}],[\"jvm不会报错\",{\"1\":{\"362\":1}}],[\"jvm有哪三种垃圾回收器\",{\"1\":{\"355\":1}}],[\"jvm怎么回收内存\",{\"1\":{\"355\":1}}],[\"jvm在进行gc时\",{\"1\":{\"350\":1}}],[\"jvm的字节码解释器就需要通过改变pc寄存器的值来明确下一条应该执行什么样的字节码指令\",{\"1\":{\"347\":1}}],[\"jvm\",{\"0\":{\"344\":1},\"1\":{\"101\":1,\"355\":2,\"819\":1,\"825\":1,\"876\":2,\"897\":1,\"905\":3}}],[\"jack\",{\"1\":{\"1025\":6,\"1026\":1,\"1032\":1}}],[\"jackson依赖\",{\"1\":{\"1038\":1}}],[\"jackson\",{\"1\":{\"931\":1,\"1038\":1}}],[\"jar\",{\"1\":{\"649\":1,\"653\":1,\"682\":1,\"872\":2}}],[\"jar包中的string类\",{\"1\":{\"346\":1}}],[\"jar包中java\",{\"1\":{\"346\":1}}],[\"jasper<\",{\"1\":{\"648\":1}}],[\"jasper\",{\"1\":{\"648\":1,\"649\":1}}],[\"jad\",{\"1\":{\"516\":1,\"519\":1}}],[\"ja\",{\"1\":{\"450\":1}}],[\"japanese\",{\"1\":{\"450\":1}}],[\"java8\",{\"1\":{\"997\":1}}],[\"javascript\",{\"1\":{\"924\":1}}],[\"java堆内存\",{\"1\":{\"851\":1}}],[\"java堆区所占的内存大小\",{\"1\":{\"359\":1}}],[\"javaee\",{\"1\":{\"841\":1}}],[\"javachannel\",{\"1\":{\"790\":2}}],[\"javaversion\",{\"1\":{\"790\":1}}],[\"javaguide\",{\"1\":{\"738\":1}}],[\"javaagent实现\",{\"1\":{\"714\":1}}],[\"javatype=\",{\"1\":{\"366\":1}}],[\"java虚拟机的堆内存设置不够\",{\"1\":{\"358\":1}}],[\"java对象的回收方式\",{\"1\":{\"355\":1}}],[\"java对象头详细信息在jvm中有描述\",{\"1\":{\"210\":1}}],[\"java的全类名加上对应的方法名\",{\"1\":{\"366\":1}}],[\"java的垃圾回收器都有哪些\",{\"1\":{\"355\":1}}],[\"java的nio就是reactor\",{\"1\":{\"333\":1}}],[\"java的nio使用了非阻塞的i\",{\"1\":{\"332\":1}}],[\"java拥有四大内置函数式接口\",{\"1\":{\"336\":1}}],[\"java提供了一系列改进的i\",{\"1\":{\"332\":1}}],[\"java提供的动态代理相关类\",{\"1\":{\"94\":1}}],[\"java基础\",{\"0\":{\"316\":1}}],[\"java同步系列之aqs终篇改编\",{\"1\":{\"250\":1}}],[\"java进程才会结束\",{\"1\":{\"207\":1}}],[\"java并发\",{\"0\":{\"201\":1}}],[\"java中thread\",{\"1\":{\"208\":1}}],[\"java中优先级最大10\",{\"1\":{\"205\":1}}],[\"java中提供了一个动态代理类proxy\",{\"1\":{\"94\":1}}],[\"java中的fast\",{\"1\":{\"324\":1}}],[\"java中的代理按照代理类生成时机不同又分为静态代理和动态代理\",{\"1\":{\"91\":1}}],[\"java中的object类中提供了\",{\"1\":{\"86\":1}}],[\"java\",{\"1\":{\"58\":5,\"94\":10,\"99\":1,\"105\":4,\"194\":2,\"208\":1,\"237\":1,\"317\":1,\"331\":1,\"332\":2,\"345\":1,\"355\":1,\"441\":2,\"449\":2,\"451\":1,\"491\":3,\"498\":2,\"502\":2,\"506\":2,\"515\":2,\"519\":3,\"523\":2,\"585\":1,\"647\":1,\"705\":2,\"773\":8,\"776\":1,\"790\":1,\"806\":1,\"812\":13,\"813\":2,\"814\":2,\"815\":22,\"825\":3,\"841\":1,\"845\":1,\"855\":1,\"872\":2,\"886\":2,\"891\":1,\"904\":4,\"905\":8,\"1038\":1}}],[\"jantic\",{\"1\":{\"11\":1}}],[\"j\",{\"1\":{\"26\":3,\"191\":9,\"192\":4,\"194\":16,\"195\":18,\"386\":4,\"754\":3,\"755\":2,\"756\":2,\"796\":1,\"826\":1,\"849\":16,\"890\":2}}],[\"j=0\",{\"1\":{\"26\":3}}],[\"jpg\",{\"1\":{\"3\":1,\"950\":2}}],[\"hmget\",{\"1\":{\"1027\":2}}],[\"hmset和hmget\",{\"1\":{\"1027\":1}}],[\"hmset\",{\"1\":{\"422\":1,\"1027\":3}}],[\"h6\",{\"1\":{\"816\":3}}],[\"h5\",{\"1\":{\"816\":2}}],[\"h3\",{\"1\":{\"816\":3}}],[\"h3>\",{\"1\":{\"622\":1}}],[\"h4\",{\"1\":{\"816\":2}}],[\"h2\",{\"1\":{\"816\":3}}],[\"h1\",{\"1\":{\"816\":3}}],[\"h1>\",{\"1\":{\"768\":1}}],[\"hh\",{\"1\":{\"756\":1}}],[\"hhhh\",{\"1\":{\"755\":1}}],[\"hkeys和hvals\",{\"1\":{\"1027\":1}}],[\"hkeys\",{\"1\":{\"422\":1,\"1027\":2}}],[\"hgetall\",{\"1\":{\"422\":1,\"1027\":5,\"1032\":1}}],[\"hget\",{\"1\":{\"422\":1,\"1027\":3}}],[\"hset和hget\",{\"1\":{\"1027\":1}}],[\"hsetnx\",{\"1\":{\"1027\":4}}],[\"hset\",{\"1\":{\"422\":1,\"1027\":4,\"1032\":2}}],[\"hot\",{\"1\":{\"961\":1}}],[\"hotspot有这么多的垃圾回收器\",{\"1\":{\"361\":1}}],[\"host\",{\"1\":{\"949\":3,\"1039\":1}}],[\"how\",{\"1\":{\"859\":1}}],[\"hook\",{\"1\":{\"119\":1}}],[\"h>\",{\"1\":{\"192\":1,\"277\":2,\"283\":1}}],[\"hrrn\",{\"1\":{\"139\":1}}],[\"hvals\",{\"1\":{\"1027\":2}}],[\"hvals等\",{\"1\":{\"422\":1}}],[\"hv\",{\"1\":{\"116\":2}}],[\"hincrby\",{\"1\":{\"1027\":4}}],[\"hindupuravinash\",{\"1\":{\"6\":1,\"13\":1}}],[\"hit\",{\"1\":{\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"hits\",{\"1\":{\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"highlighter\",{\"1\":{\"944\":1}}],[\"highlightbuilder\",{\"1\":{\"944\":7}}],[\"high\",{\"1\":{\"839\":1,\"931\":1}}],[\"highest\",{\"1\":{\"139\":1}}],[\"hibernate\",{\"1\":{\"705\":1}}],[\"hikaridatasource\",{\"1\":{\"660\":1}}],[\"hikari\",{\"1\":{\"660\":1}}],[\"hi=你好\",{\"1\":{\"450\":1}}],[\"hi=こんにちは\",{\"1\":{\"450\":1}}],[\"hi=hello\",{\"1\":{\"450\":1}}],[\"hi\",{\"1\":{\"450\":3}}],[\"history\",{\"1\":{\"116\":7}}],[\"heima<\",{\"1\":{\"1038\":1}}],[\"heima\",{\"1\":{\"1026\":5,\"1027\":19}}],[\"heimasafetydoor\",{\"1\":{\"110\":2}}],[\"hex\",{\"1\":{\"849\":4}}],[\"hexpadding\",{\"1\":{\"849\":5}}],[\"hexdump\",{\"1\":{\"849\":8}}],[\"hexists\",{\"1\":{\"422\":1}}],[\"hessian\",{\"1\":{\"769\":1}}],[\"help\",{\"1\":{\"1024\":2,\"1025\":1}}],[\"helptransfer\",{\"1\":{\"249\":1}}],[\"hell\",{\"1\":{\"889\":1}}],[\"helloword\",{\"1\":{\"846\":1,\"857\":1,\"858\":1,\"870\":2,\"872\":9,\"904\":1}}],[\"helloworldclient\",{\"1\":{\"749\":2,\"753\":2,\"754\":4,\"755\":4,\"756\":4}}],[\"helloworldserver\",{\"1\":{\"749\":6,\"750\":3,\"754\":3,\"755\":1,\"756\":3}}],[\"helloworld\",{\"1\":{\"282\":1}}],[\"helloservice\",{\"1\":{\"784\":2,\"785\":1,\"787\":2}}],[\"helloserviceimpl\",{\"1\":{\"783\":1}}],[\"helloservice=cn\",{\"1\":{\"783\":1}}],[\"helloservlet\",{\"1\":{\"655\":4}}],[\"hello\",{\"0\":{\"832\":1},\"1\":{\"41\":2,\"282\":4,\"644\":3,\"647\":4,\"655\":1,\"803\":3,\"816\":1,\"833\":1,\"835\":1,\"859\":3,\"889\":1,\"890\":1,\"898\":1,\"909\":1}}],[\"heapbytebuffer\",{\"1\":{\"905\":1,\"911\":1}}],[\"heapbuffer\",{\"1\":{\"819\":1}}],[\"heapcharbuffer\",{\"1\":{\"855\":1}}],[\"heatoil\",{\"1\":{\"120\":2}}],[\"header\",{\"1\":{\"849\":1}}],[\"headers\",{\"1\":{\"768\":1}}],[\"headcontext\",{\"1\":{\"790\":1,\"793\":1,\"825\":1}}],[\"head\",{\"0\":{\"24\":1},\"1\":{\"255\":1,\"314\":1,\"752\":2,\"790\":2,\"793\":2,\"816\":1}}],[\"hefeijoe\",{\"1\":{\"57\":1}}],[\"h\",{\"1\":{\"26\":2,\"94\":10,\"116\":7,\"249\":5,\"255\":4,\"282\":1,\"515\":6,\"749\":4,\"750\":6,\"754\":19,\"755\":16,\"756\":18,\"798\":18,\"826\":1,\"1018\":1}}],[\"have\",{\"1\":{\"849\":1}}],[\"having子句中如果使用了分组字段作为过滤条件\",{\"1\":{\"394\":1}}],[\"having子句中不能使用除了分组字段和聚合函数之外的其他字段\",{\"1\":{\"394\":1}}],[\"having是一个过滤声明\",{\"1\":{\"394\":1}}],[\"hadoop\",{\"1\":{\"841\":1}}],[\"hanmeimei\",{\"1\":{\"1027\":1}}],[\"hana\",{\"1\":{\"116\":10}}],[\"handvalue\",{\"1\":{\"116\":21}}],[\"hand\",{\"1\":{\"116\":22}}],[\"handleloopexception\",{\"1\":{\"791\":3}}],[\"handlerinterceptor\",{\"1\":{\"961\":1,\"972\":2}}],[\"handlereadexception\",{\"1\":{\"794\":1}}],[\"handlerexecutionchain\",{\"1\":{\"644\":1}}],[\"handlerexceptionresolver\",{\"1\":{\"644\":1,\"665\":1}}],[\"handler2\",{\"1\":{\"635\":1,\"798\":1}}],[\"handler1\",{\"1\":{\"635\":1,\"638\":1,\"798\":1}}],[\"handlerfunction\",{\"1\":{\"631\":1,\"643\":2}}],[\"handlerfunctionadapter\",{\"0\":{\"628\":1},\"1\":{\"630\":3,\"631\":1,\"643\":1}}],[\"handlermethodreturnvaluehandlercomposite\",{\"1\":{\"587\":1,\"590\":1}}],[\"handlermethodreturnvaluehandler\",{\"1\":{\"561\":1,\"644\":1}}],[\"handlermethodargumentresolvercomposite\",{\"1\":{\"587\":1,\"590\":1}}],[\"handlermethodargumentresolver\",{\"1\":{\"561\":1,\"644\":1}}],[\"handlermethod\",{\"1\":{\"561\":3,\"568\":1,\"590\":1,\"644\":3}}],[\"handlermapping\",{\"1\":{\"561\":1,\"635\":3,\"643\":1,\"644\":1,\"665\":1}}],[\"handleradapter将controller执行结果modelandview返回给dispatcherservlet\",{\"1\":{\"736\":1}}],[\"handleradapter经过适配调用具体的处理器\",{\"1\":{\"736\":1}}],[\"handleradapter是一个适配器\",{\"1\":{\"736\":1}}],[\"handleradapter是spring\",{\"1\":{\"736\":1}}],[\"handleradapter\",{\"1\":{\"561\":1,\"587\":2,\"595\":1,\"607\":1,\"643\":1,\"644\":1,\"665\":1}}],[\"handler\",{\"0\":{\"784\":1,\"786\":1,\"788\":1,\"799\":1,\"816\":1},\"1\":{\"242\":2,\"627\":2,\"631\":2,\"635\":6,\"636\":2,\"638\":4,\"642\":2,\"643\":1,\"736\":2,\"749\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":6,\"760\":3,\"767\":1,\"771\":1,\"775\":1,\"783\":9,\"785\":5,\"787\":5,\"790\":5,\"793\":3,\"794\":2,\"798\":2,\"799\":3,\"803\":4,\"804\":1,\"816\":2,\"825\":1,\"835\":3,\"837\":5,\"844\":1,\"961\":1,\"972\":3}}],[\"handles\",{\"1\":{\"104\":1}}],[\"handle\",{\"1\":{\"104\":1,\"644\":1,\"793\":1,\"794\":1}}],[\"harddisk\",{\"1\":{\"109\":15}}],[\"haslock\",{\"1\":{\"988\":2}}],[\"has\",{\"1\":{\"849\":1}}],[\"hasremaining\",{\"1\":{\"846\":1,\"865\":1,\"893\":2,\"909\":1}}],[\"hasreadresolvemethod\",{\"1\":{\"104\":2}}],[\"hasscheduledtasks\",{\"1\":{\"792\":1}}],[\"hastasks\",{\"1\":{\"791\":1,\"792\":2}}],[\"hasnext\",{\"1\":{\"78\":1,\"793\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":2,\"896\":2}}],[\"hash结构操作\",{\"0\":{\"1043\":1}}],[\"hash结构可以将对象中的每个字段独立存储\",{\"1\":{\"1027\":1}}],[\"hash结构效率高\",{\"0\":{\"381\":1}}],[\"hash类型的常见命令\",{\"1\":{\"1027\":1}}],[\"hash类型\",{\"1\":{\"1027\":1}}],[\"hash命令\",{\"0\":{\"1027\":1}}],[\"hash值是将联合索引键合并起来一起计算的\",{\"1\":{\"381\":1}}],[\"hash索引数据存储是没有顺序的\",{\"1\":{\"381\":1}}],[\"hash索引仅能满足\",{\"1\":{\"381\":1}}],[\"hash的规则决定在扩容后需要对已有元素进行重新hash\",{\"1\":{\"327\":1}}],[\"hash判断当前元素的存放位置\",{\"1\":{\"327\":1}}],[\"hashset<>\",{\"1\":{\"759\":1}}],[\"hashset<string>\",{\"1\":{\"343\":1}}],[\"hashset用于不需要保证元素插入和取出顺序的场景\",{\"1\":{\"326\":1}}],[\"hashset底层采用的时哈希表\",{\"1\":{\"326\":1}}],[\"hashset\",{\"0\":{\"326\":1},\"1\":{\"326\":1,\"343\":1,\"792\":1}}],[\"hashset就不会让其加入操作成功\",{\"1\":{\"318\":1}}],[\"hashset会假设对象没有重复出现\",{\"1\":{\"318\":1}}],[\"hashset首先会根据对象的hashcode值来判断对象加入的位置\",{\"1\":{\"318\":1}}],[\"hashtable\",{\"1\":{\"268\":3}}],[\"hash为负数表示该bin在扩容中或是treebin\",{\"1\":{\"249\":1}}],[\"hash表就会加倍扩容\",{\"1\":{\"328\":1}}],[\"hash表数组的大小\",{\"1\":{\"328\":1}}],[\"hash表\",{\"1\":{\"249\":2,\"1030\":1}}],[\"hashcode是为了获取对象的哈希码\",{\"1\":{\"318\":1}}],[\"hashcode\",{\"1\":{\"94\":2,\"249\":2}}],[\"hashmap为什么会发生死链\",{\"1\":{\"329\":1}}],[\"hashmap在jdk\",{\"0\":{\"329\":1}}],[\"hashmap的扩容机制\",{\"0\":{\"328\":1}}],[\"hashmap的底层实现\",{\"0\":{\"327\":1}}],[\"hashmap通过key的hashcode经过扰动函数后得到hash值\",{\"1\":{\"327\":1}}],[\"hashmap<>\",{\"1\":{\"285\":1,\"773\":1,\"968\":1}}],[\"hashmap<string\",{\"1\":{\"268\":1}}],[\"hashmap\",{\"1\":{\"77\":1,\"974\":2}}],[\"hash\",{\"1\":{\"10\":1,\"249\":10,\"278\":1,\"290\":1,\"384\":1,\"422\":1,\"435\":1}}],[\"hat\",{\"1\":{\"26\":5}}],[\"httphost\",{\"1\":{\"932\":1,\"949\":1}}],[\"httpheaders\",{\"1\":{\"600\":1}}],[\"httpcontent\",{\"1\":{\"768\":1}}],[\"httpresponsestatus\",{\"1\":{\"768\":1}}],[\"httprequest\",{\"1\":{\"768\":2}}],[\"httprequesthandler\",{\"1\":{\"643\":1}}],[\"httprequesthandleradapter\",{\"0\":{\"632\":1},\"1\":{\"635\":3,\"636\":1,\"643\":1}}],[\"http方法\",{\"1\":{\"736\":1}}],[\"httpencodingautoconfiguration\",{\"0\":{\"668\":1}}],[\"http11nio2protocol\",{\"1\":{\"655\":1}}],[\"httpmessageconverter\",{\"1\":{\"644\":1}}],[\"http的幂等性\",{\"0\":{\"314\":1}}],[\"http\",{\"0\":{\"768\":1},\"1\":{\"11\":1,\"14\":1,\"18\":1,\"197\":1,\"498\":1,\"644\":1,\"890\":2,\"891\":1,\"932\":1,\"950\":2,\"1038\":3}}],[\"httpsession\",{\"1\":{\"960\":2,\"961\":1,\"968\":1}}],[\"httpservercodec\",{\"1\":{\"768\":1}}],[\"httpservletresponse\",{\"1\":{\"622\":1,\"961\":1,\"972\":3}}],[\"httpservletrequest\",{\"1\":{\"568\":1,\"622\":1,\"961\":1,\"972\":3}}],[\"https\",{\"1\":{\"3\":4,\"4\":1,\"5\":1,\"6\":3,\"7\":2,\"10\":3,\"11\":10,\"12\":2,\"13\":3,\"14\":3,\"17\":5,\"18\":2,\"19\":2,\"30\":4,\"31\":8,\"32\":4,\"169\":1,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"646\":2,\"1009\":1,\"1019\":2,\"1023\":1,\"1031\":1,\"1036\":1,\"1038\":1}}],[\"html\",{\"1\":{\"10\":1,\"617\":2,\"622\":2,\"641\":1,\"642\":3,\"653\":2,\"891\":1}}],[\"hd\",{\"1\":{\"3\":1}}],[\"pvs\",{\"1\":{\"711\":2}}],[\"pgsql\",{\"1\":{\"372\":1}}],[\"please\",{\"1\":{\"825\":1}}],[\"platformdependent\",{\"1\":{\"790\":3}}],[\"player\",{\"1\":{\"116\":7}}],[\"plugins>\",{\"1\":{\"1038\":1}}],[\"plugin>\",{\"1\":{\"1038\":1}}],[\"plugin<\",{\"1\":{\"1038\":1}}],[\"plugin\",{\"1\":{\"506\":1}}],[\"plusseconds\",{\"1\":{\"989\":1,\"990\":1}}],[\"plus多数据源\",{\"0\":{\"372\":1},\"1\":{\"372\":1}}],[\"plus包中的stringutils\",{\"1\":{\"370\":1}}],[\"plus的解决方案\",{\"0\":{\"370\":1}}],[\"plus\",{\"0\":{\"363\":1,\"369\":1},\"1\":{\"372\":2}}],[\"pc寄存器为什么要设定为线程私有\",{\"1\":{\"347\":1}}],[\"pc\",{\"1\":{\"305\":1}}],[\"pcb会常驻内存\",{\"1\":{\"153\":1}}],[\"pcb记录进程数据\",{\"1\":{\"136\":1}}],[\"pcb的组成\",{\"1\":{\"131\":1}}],[\"pcb\",{\"1\":{\"131\":2}}],[\"pk即primary\",{\"1\":{\"265\":1}}],[\"per\",{\"1\":{\"849\":1}}],[\"performance\",{\"1\":{\"839\":1,\"891\":1}}],[\"permits\",{\"1\":{\"261\":7}}],[\"pendingregistrationpromise\",{\"1\":{\"790\":2}}],[\"people\",{\"1\":{\"385\":2}}],[\"peterson算法\",{\"1\":{\"141\":1}}],[\"png\",{\"1\":{\"169\":1}}],[\"p2进程申请资源r1\",{\"1\":{\"147\":1}}],[\"p2分别申请并占有了资源r1\",{\"1\":{\"147\":1}}],[\"p操作\",{\"1\":{\"143\":1}}],[\"p0和p1都无法进入临界区\",{\"1\":{\"141\":1}}],[\"p0和p1将会同时访问临界区\",{\"1\":{\"141\":1}}],[\"psw\",{\"1\":{\"128\":1,\"129\":1}}],[\"pongmessage\",{\"1\":{\"773\":1}}],[\"port\",{\"1\":{\"773\":1,\"949\":3,\"1015\":1,\"1039\":1}}],[\"portlet\",{\"1\":{\"705\":1}}],[\"pom\",{\"1\":{\"646\":3,\"727\":1,\"1038\":2}}],[\"pointcutadvisor\",{\"1\":{\"528\":1}}],[\"pointcut\",{\"1\":{\"528\":2}}],[\"poll高很多\",{\"1\":{\"410\":1}}],[\"poll中\",{\"1\":{\"410\":1}}],[\"poll还有一个特点就是\",{\"1\":{\"410\":1}}],[\"poll本质上和select没有区别\",{\"1\":{\"410\":2}}],[\"poll和epoll时要根据具体的使用场合以及这三种方式的自身特点\",{\"1\":{\"410\":1}}],[\"poll和epoll都是io多路复用的机制\",{\"1\":{\"410\":1}}],[\"poll和epoll的区别\",{\"0\":{\"410\":1}}],[\"poll和epoll\",{\"1\":{\"409\":2}}],[\"poll\",{\"1\":{\"405\":1,\"410\":4,\"896\":1}}],[\"poloclub\",{\"1\":{\"11\":1}}],[\"pool2<\",{\"1\":{\"1038\":1}}],[\"poolconfig\",{\"1\":{\"1034\":6}}],[\"pooledbytebuf\",{\"1\":{\"825\":1}}],[\"pooleddatasource\",{\"1\":{\"660\":2}}],[\"pooldatasourceimpl\",{\"1\":{\"660\":1}}],[\"pool的使用大大提高了读写数据的效率\",{\"1\":{\"396\":1}}],[\"pool中的数据写入磁盘是以数据页为单位进行的\",{\"1\":{\"396\":1}}],[\"pool中的数据写入磁盘属于随机io\",{\"1\":{\"396\":1}}],[\"pool中的数据\",{\"1\":{\"396\":1}}],[\"pool中修改的数据写入磁盘要快呢\",{\"1\":{\"396\":1}}],[\"pool中修改的数据还没有刷新到磁盘\",{\"1\":{\"396\":1}}],[\"pool中修改的数据会定期刷新到磁盘中\",{\"1\":{\"396\":1}}],[\"pool中没有\",{\"1\":{\"396\":1}}],[\"pool中读取\",{\"1\":{\"396\":1}}],[\"pool中包含了磁盘中部分数据页的映射\",{\"1\":{\"396\":1}}],[\"pool\",{\"1\":{\"396\":4,\"672\":1,\"976\":1,\"1038\":1,\"1039\":1}}],[\"pos\",{\"1\":{\"867\":1}}],[\"position\",{\"1\":{\"332\":1,\"848\":3,\"849\":6,\"853\":2,\"854\":1,\"858\":1,\"859\":1,\"867\":3,\"870\":5,\"890\":3}}],[\"posttags\",{\"1\":{\"944\":1}}],[\"postvisitdirectory\",{\"1\":{\"872\":2}}],[\"postmapping\",{\"1\":{\"731\":1,\"732\":1,\"737\":1,\"994\":2}}],[\"postman\",{\"1\":{\"646\":1}}],[\"posthandle\",{\"1\":{\"644\":1,\"738\":1}}],[\"postconstruct修饰的发给发将在bean实例化后被调用\",{\"1\":{\"709\":1}}],[\"postconstruct\",{\"1\":{\"460\":1,\"470\":1,\"491\":1,\"495\":2,\"709\":1,\"711\":1}}],[\"postprocessbeforedestruction\",{\"1\":{\"460\":1,\"711\":1}}],[\"postprocessbeforeinitialization\",{\"1\":{\"460\":1,\"711\":1}}],[\"postprocessbeforeinstantiation\",{\"1\":{\"460\":1,\"711\":1}}],[\"postprocessproperties\",{\"1\":{\"460\":1,\"711\":1}}],[\"postprocessafterinstantiation\",{\"1\":{\"460\":1,\"711\":1}}],[\"postprocessafterinitialization\",{\"1\":{\"460\":2,\"711\":1}}],[\"postgres\",{\"1\":{\"372\":1}}],[\"postgresql\",{\"1\":{\"372\":2}}],[\"post\",{\"1\":{\"197\":1,\"314\":1,\"668\":1}}],[\"pop\",{\"1\":{\"283\":1}}],[\"pojo类的布尔属性不能加is\",{\"1\":{\"268\":1}}],[\"poursauce\",{\"1\":{\"120\":4}}],[\"pourvegetable\",{\"1\":{\"120\":4}}],[\"pouroil\",{\"1\":{\"120\":2}}],[\"pp\",{\"1\":{\"93\":2}}],[\"publisher<r>\",{\"1\":{\"742\":1}}],[\"publisher\",{\"1\":{\"742\":1,\"743\":4,\"744\":4}}],[\"public\",{\"1\":{\"41\":15,\"42\":6,\"44\":2,\"49\":27,\"52\":24,\"57\":10,\"58\":9,\"63\":2,\"65\":2,\"69\":14,\"74\":7,\"77\":2,\"78\":2,\"82\":16,\"86\":4,\"87\":7,\"89\":15,\"93\":7,\"94\":23,\"95\":7,\"101\":15,\"103\":9,\"104\":5,\"105\":4,\"108\":6,\"109\":25,\"110\":10,\"111\":15,\"116\":27,\"120\":15,\"123\":4,\"191\":3,\"194\":4,\"195\":2,\"206\":5,\"211\":1,\"221\":1,\"224\":12,\"225\":12,\"232\":1,\"236\":1,\"237\":1,\"242\":1,\"244\":3,\"249\":3,\"255\":6,\"260\":2,\"261\":1,\"262\":1,\"282\":7,\"285\":5,\"287\":3,\"336\":4,\"339\":2,\"366\":1,\"368\":2,\"370\":1,\"372\":1,\"441\":4,\"450\":2,\"463\":5,\"491\":4,\"500\":8,\"510\":3,\"512\":3,\"515\":12,\"523\":2,\"619\":2,\"622\":4,\"626\":3,\"630\":3,\"635\":4,\"638\":1,\"641\":2,\"647\":2,\"655\":2,\"657\":1,\"670\":3,\"672\":2,\"711\":7,\"721\":1,\"731\":5,\"732\":3,\"737\":2,\"742\":11,\"743\":6,\"744\":11,\"749\":7,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"758\":3,\"759\":6,\"760\":2,\"761\":5,\"762\":3,\"764\":2,\"767\":2,\"768\":1,\"770\":1,\"771\":1,\"773\":30,\"775\":4,\"776\":5,\"783\":14,\"784\":1,\"785\":2,\"786\":1,\"787\":4,\"788\":2,\"790\":9,\"791\":2,\"793\":6,\"794\":2,\"798\":4,\"799\":1,\"803\":1,\"804\":3,\"806\":2,\"807\":1,\"808\":2,\"816\":9,\"825\":1,\"826\":2,\"844\":2,\"845\":4,\"846\":2,\"849\":4,\"859\":1,\"870\":2,\"872\":6,\"884\":4,\"886\":2,\"889\":4,\"890\":1,\"893\":4,\"896\":8,\"898\":4,\"907\":4,\"909\":10,\"932\":3,\"934\":1,\"949\":2,\"950\":12,\"960\":2,\"961\":4,\"962\":4,\"968\":1,\"972\":6,\"977\":1,\"983\":2,\"989\":3,\"990\":8,\"993\":3,\"994\":3,\"995\":1,\"998\":3,\"1034\":2,\"1041\":2}}],[\"pull下来别人的代码\",{\"1\":{\"311\":1}}],[\"pushdown\",{\"1\":{\"385\":1}}],[\"push\",{\"1\":{\"283\":6}}],[\"putall\",{\"1\":{\"968\":1}}],[\"puttreeval\",{\"1\":{\"249\":1}}],[\"puttreeval会看key是否已经在树中\",{\"1\":{\"249\":1}}],[\"putifabsent\",{\"1\":{\"249\":1}}],[\"putval\",{\"1\":{\"249\":2}}],[\"put流程\",{\"1\":{\"249\":1}}],[\"put到了forwardingnode\",{\"1\":{\"249\":1}}],[\"putfield\",{\"1\":{\"237\":2}}],[\"putstatic\",{\"1\":{\"230\":1}}],[\"put\",{\"1\":{\"77\":1,\"249\":2,\"268\":2,\"285\":3,\"290\":2,\"314\":1,\"773\":14,\"783\":3,\"787\":1,\"852\":2,\"858\":2,\"859\":3,\"865\":1,\"890\":2,\"1043\":2}}],[\"padding\",{\"1\":{\"849\":6}}],[\"paddings\",{\"1\":{\"849\":2}}],[\"payloadapplicationevent\",{\"1\":{\"703\":1}}],[\"paths\",{\"1\":{\"871\":7,\"872\":12,\"873\":3,\"907\":1}}],[\"pathresourceresolver\",{\"1\":{\"638\":1}}],[\"path\",{\"0\":{\"871\":1},\"1\":{\"617\":1,\"871\":11,\"872\":29,\"873\":5}}],[\"pathvariable和\",{\"1\":{\"731\":1}}],[\"pathvariable\",{\"1\":{\"568\":1,\"731\":3,\"737\":2,\"977\":1}}],[\"pattern\",{\"1\":{\"77\":2,\"99\":1,\"463\":1,\"981\":3}}],[\"page<product>\",{\"1\":{\"950\":2}}],[\"pagerequest\",{\"1\":{\"950\":8}}],[\"pagesize\",{\"1\":{\"950\":4}}],[\"page\",{\"1\":{\"408\":1}}],[\"password\",{\"1\":{\"372\":2,\"731\":2,\"758\":2,\"759\":4,\"760\":2,\"1039\":1}}],[\"passhandle\",{\"1\":{\"104\":3}}],[\"packed\",{\"1\":{\"277\":6}}],[\"package\",{\"1\":{\"94\":1}}],[\"parent>\",{\"1\":{\"1038\":1}}],[\"parent<\",{\"1\":{\"1038\":1}}],[\"parent\",{\"1\":{\"796\":1,\"1038\":1}}],[\"parseint\",{\"1\":{\"773\":1}}],[\"parser\",{\"1\":{\"574\":3}}],[\"parallel\",{\"1\":{\"360\":7,\"361\":1}}],[\"parametervalue\",{\"1\":{\"783\":4}}],[\"parametertypes\",{\"1\":{\"783\":4}}],[\"parameterizableviewcontroller\",{\"1\":{\"642\":1}}],[\"parameternamediscoverer\",{\"1\":{\"590\":1}}],[\"parameters\",{\"1\":{\"572\":1}}],[\"parammap\",{\"1\":{\"368\":4}}],[\"param指定参数名称\",{\"1\":{\"365\":1}}],[\"param\",{\"0\":{\"365\":1},\"1\":{\"268\":1,\"441\":1,\"510\":1,\"512\":1,\"572\":1,\"758\":20,\"773\":1,\"849\":2,\"990\":24}}],[\"parnew+serial\",{\"1\":{\"360\":1}}],[\"parnew\",{\"1\":{\"360\":4}}],[\"partial\",{\"1\":{\"350\":1}}],[\"park和unpark是locksupport类中的方法\",{\"1\":{\"219\":1}}],[\"park\",{\"0\":{\"219\":1},\"1\":{\"219\":3,\"224\":2,\"225\":3}}],[\"paa\",{\"1\":{\"116\":2}}],[\"paper\",{\"1\":{\"10\":3}}],[\"phone\",{\"1\":{\"52\":16,\"960\":7,\"968\":7,\"1042\":1}}],[\"phillipi\",{\"1\":{\"17\":1}}],[\"pretags\",{\"1\":{\"944\":1}}],[\"prettyhexdump\",{\"1\":{\"826\":6,\"829\":3,\"830\":2}}],[\"premature\",{\"1\":{\"792\":1}}],[\"prepared\",{\"1\":{\"650\":1}}],[\"prehandle\",{\"1\":{\"644\":1,\"738\":1,\"961\":1,\"972\":2}}],[\"prehandvalue\",{\"1\":{\"116\":4}}],[\"preorder\",{\"1\":{\"283\":4}}],[\"prefix=\",{\"1\":{\"647\":1}}],[\"prefixsum\",{\"1\":{\"287\":3}}],[\"prefix++\",{\"1\":{\"282\":1}}],[\"prefix\",{\"1\":{\"282\":3,\"647\":1,\"731\":1,\"849\":1,\"949\":1}}],[\"prefix表示以该处节点之前的字符串为前缀的单词数量\",{\"1\":{\"282\":1}}],[\"previsitdirectory\",{\"1\":{\"872\":2}}],[\"prevlen\",{\"1\":{\"279\":7,\"280\":8}}],[\"prevhand\",{\"1\":{\"116\":3}}],[\"predestory修饰的方法将在容器销毁前调用\",{\"1\":{\"709\":1}}],[\"predestory用于声明bean的生命周期\",{\"1\":{\"709\":1}}],[\"predestroy\",{\"1\":{\"460\":1,\"470\":1,\"495\":1,\"711\":1}}],[\"predicate<\",{\"1\":{\"336\":1}}],[\"pred\",{\"1\":{\"249\":2}}],[\"price\",{\"1\":{\"950\":1,\"1005\":2,\"1026\":1}}],[\"priorityordered\",{\"1\":{\"466\":1}}],[\"priorityblockingqueue\",{\"1\":{\"242\":1}}],[\"primary\",{\"1\":{\"372\":1,\"688\":1,\"695\":1,\"928\":1}}],[\"printer\",{\"1\":{\"574\":3}}],[\"printf\",{\"1\":{\"277\":2,\"849\":2,\"909\":3}}],[\"print\",{\"1\":{\"82\":2,\"283\":1,\"622\":1,\"626\":1}}],[\"printstacktrace\",{\"1\":{\"77\":1,\"206\":1,\"221\":2,\"224\":2,\"225\":4,\"263\":4,\"743\":1,\"744\":2,\"759\":1,\"775\":1,\"776\":1,\"784\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":2,\"845\":4,\"846\":1,\"857\":1,\"858\":1,\"870\":2,\"873\":1,\"884\":2,\"886\":1,\"890\":1,\"896\":4,\"898\":2,\"907\":1,\"909\":6}}],[\"println\",{\"1\":{\"41\":7,\"42\":5,\"49\":2,\"52\":2,\"58\":3,\"69\":2,\"78\":1,\"82\":2,\"86\":3,\"87\":1,\"89\":3,\"93\":2,\"94\":3,\"95\":2,\"103\":2,\"105\":3,\"108\":2,\"109\":7,\"110\":5,\"111\":2,\"116\":6,\"120\":7,\"191\":1,\"194\":2,\"206\":2,\"232\":10,\"235\":1,\"282\":2,\"336\":2,\"338\":1,\"339\":3,\"340\":1,\"341\":2,\"342\":3,\"343\":9,\"441\":3,\"450\":3,\"463\":5,\"500\":2,\"510\":3,\"512\":3,\"515\":4,\"523\":2,\"622\":1,\"647\":1,\"732\":1,\"743\":2,\"744\":4,\"759\":12,\"767\":1,\"776\":4,\"787\":3,\"796\":4,\"798\":1,\"815\":4,\"818\":1,\"824\":5,\"826\":8,\"829\":3,\"830\":3,\"834\":1,\"844\":2,\"845\":2,\"849\":4,\"855\":2,\"859\":1,\"870\":2,\"871\":2,\"872\":6,\"873\":1,\"876\":1,\"884\":2,\"886\":1,\"889\":1,\"893\":4,\"898\":1,\"909\":1,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"950\":3,\"993\":2,\"1032\":3,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"privatetmp=true\",{\"1\":{\"1016\":1}}],[\"private\",{\"1\":{\"42\":1,\"49\":4,\"52\":13,\"57\":6,\"69\":1,\"77\":1,\"82\":3,\"87\":1,\"89\":3,\"93\":1,\"94\":7,\"95\":1,\"101\":15,\"103\":6,\"104\":8,\"105\":2,\"108\":1,\"109\":6,\"111\":6,\"116\":17,\"224\":2,\"249\":2,\"285\":1,\"287\":5,\"339\":1,\"366\":3,\"441\":15,\"463\":1,\"491\":1,\"500\":3,\"515\":1,\"686\":1,\"731\":6,\"743\":1,\"744\":3,\"753\":1,\"767\":2,\"773\":3,\"776\":1,\"783\":7,\"787\":3,\"790\":4,\"791\":1,\"792\":3,\"793\":1,\"816\":1,\"818\":1,\"849\":8,\"859\":1,\"890\":1,\"896\":7,\"909\":8,\"932\":4,\"934\":3,\"949\":2,\"950\":7,\"961\":1,\"962\":1,\"972\":1,\"985\":1,\"988\":3,\"989\":4,\"990\":4,\"993\":3,\"1032\":1,\"1034\":1,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"program\",{\"1\":{\"872\":2}}],[\"programming的通用api\",{\"1\":{\"742\":1}}],[\"promisetask$runnableadapter\",{\"1\":{\"815\":2}}],[\"promisetask\",{\"1\":{\"815\":7}}],[\"promise<v>\",{\"1\":{\"806\":1}}],[\"promise<object>\",{\"1\":{\"788\":1}}],[\"promise<object>>\",{\"1\":{\"788\":1}}],[\"promises\",{\"1\":{\"787\":1,\"788\":2}}],[\"promise\",{\"0\":{\"806\":1,\"809\":1},\"1\":{\"775\":1,\"785\":3,\"787\":10,\"788\":6,\"790\":25,\"793\":9,\"806\":3,\"809\":6,\"810\":4,\"811\":4,\"812\":4,\"813\":7,\"814\":6,\"815\":4,\"816\":8}}],[\"profile\",{\"1\":{\"731\":1}}],[\"propagation\",{\"1\":{\"720\":7}}],[\"propertyvalues\",{\"1\":{\"711\":2}}],[\"propertysource\",{\"1\":{\"652\":1}}],[\"property\",{\"1\":{\"576\":2,\"731\":2}}],[\"propertyeditorregistry\",{\"1\":{\"575\":1,\"576\":1}}],[\"propertyeditor\",{\"1\":{\"575\":2,\"576\":2}}],[\"property=\",{\"1\":{\"366\":2}}],[\"properties>\",{\"1\":{\"1038\":1}}],[\"properties=\",{\"1\":{\"366\":6}}],[\"properties\",{\"1\":{\"77\":4,\"450\":5,\"647\":1,\"650\":1,\"773\":8,\"783\":9}}],[\"procotolframedecoder\",{\"1\":{\"759\":2,\"783\":2,\"785\":1,\"787\":1}}],[\"proc\",{\"1\":{\"410\":1,\"776\":2}}],[\"proceed\",{\"1\":{\"546\":3,\"552\":2}}],[\"proceedings\",{\"1\":{\"10\":2}}],[\"processselectedkeysplain\",{\"1\":{\"792\":1}}],[\"processselectedkeysoptimized\",{\"1\":{\"792\":1}}],[\"processselectedkeys\",{\"1\":{\"791\":2,\"792\":2}}],[\"processselectedkey\",{\"1\":{\"776\":1,\"792\":2}}],[\"processor<integer\",{\"1\":{\"744\":1}}],[\"processor<t\",{\"1\":{\"742\":1}}],[\"processor1\",{\"1\":{\"491\":2}}],[\"processors\",{\"1\":{\"463\":3}}],[\"processor\",{\"1\":{\"463\":4,\"744\":3}}],[\"process\",{\"1\":{\"105\":3,\"139\":1}}],[\"province\",{\"1\":{\"368\":2}}],[\"province字段需要从前端传过来\",{\"1\":{\"368\":1}}],[\"province格式回调\",{\"1\":{\"368\":1}}],[\"proactor模式是和异步io相关的\",{\"1\":{\"333\":1}}],[\"project>\",{\"1\":{\"1038\":1}}],[\"projectlombok<\",{\"1\":{\"931\":1,\"948\":1,\"1038\":2}}],[\"projects\",{\"1\":{\"871\":7,\"1036\":1}}],[\"project\",{\"1\":{\"265\":1,\"727\":1,\"1038\":1}}],[\"probstrategy\",{\"1\":{\"116\":4}}],[\"proxy通过接口去创建代理对象\",{\"1\":{\"706\":1}}],[\"proxytargetclass\",{\"1\":{\"528\":1,\"531\":2}}],[\"proxyfastclass\",{\"1\":{\"526\":1,\"527\":2}}],[\"proxyfactory不是代理模式中所说的代理类\",{\"1\":{\"94\":1}}],[\"proxyfactory是代理类吗\",{\"1\":{\"94\":1}}],[\"proxyfactory\",{\"1\":{\"94\":6,\"95\":3,\"528\":2,\"531\":1,\"546\":1,\"549\":1,\"556\":1}}],[\"proxymode\",{\"1\":{\"496\":1,\"503\":1}}],[\"proxyobject\",{\"1\":{\"94\":6,\"95\":2}}],[\"proxy并不是我们上述所说的代理对象的类\",{\"1\":{\"94\":1}}],[\"proxypoint\",{\"1\":{\"93\":3}}],[\"proxy\",{\"0\":{\"509\":1},\"1\":{\"92\":2,\"94\":14,\"510\":7,\"512\":4,\"515\":5,\"523\":7,\"527\":2,\"528\":1,\"787\":2,\"998\":2}}],[\"protocol\",{\"1\":{\"839\":1}}],[\"protocolversion\",{\"1\":{\"768\":1}}],[\"protobuf\",{\"1\":{\"769\":1}}],[\"prototype\",{\"1\":{\"458\":1,\"496\":1,\"500\":1,\"503\":1,\"710\":1}}],[\"prototypetest\",{\"1\":{\"86\":2}}],[\"protect\",{\"1\":{\"98\":1}}],[\"protected\",{\"1\":{\"49\":2,\"86\":1,\"94\":2,\"255\":5,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":3,\"760\":2,\"761\":5,\"767\":1,\"768\":2,\"770\":2,\"771\":2,\"773\":1,\"783\":2,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"790\":2,\"791\":2,\"793\":1,\"798\":3,\"803\":4,\"804\":1,\"816\":2,\"825\":2,\"834\":2,\"835\":1,\"844\":2}}],[\"product相关的key\",{\"1\":{\"1026\":1}}],[\"products\",{\"1\":{\"950\":2}}],[\"productpage\",{\"1\":{\"950\":2}}],[\"productlist\",{\"1\":{\"950\":2}}],[\"productdao\",{\"1\":{\"950\":11}}],[\"product\",{\"1\":{\"48\":1,\"68\":1,\"73\":1,\"950\":15,\"1026\":2}}],[\"proof\",{\"1\":{\"14\":1}}],[\"py\",{\"1\":{\"32\":1}}],[\"pytorch\",{\"1\":{\"17\":1,\"32\":1}}],[\"pjreddie\",{\"1\":{\"30\":2}}],[\"ping\",{\"1\":{\"1018\":1}}],[\"pingmessage\",{\"1\":{\"764\":1,\"773\":1}}],[\"pipeline\",{\"0\":{\"816\":1},\"1\":{\"749\":3,\"753\":2,\"754\":3,\"755\":3,\"756\":3,\"759\":8,\"764\":4,\"767\":2,\"768\":4,\"783\":8,\"785\":4,\"787\":4,\"790\":13,\"793\":12,\"794\":9,\"798\":3,\"799\":1,\"802\":1,\"803\":4,\"804\":2,\"816\":13,\"825\":5,\"834\":2,\"835\":1,\"837\":4,\"844\":3}}],[\"pixsrv\",{\"1\":{\"17\":1}}],[\"pix2pix在语义标签图转真实照片\",{\"1\":{\"16\":1}}],[\"pix2pix\",{\"1\":{\"16\":1,\"17\":2,\"19\":2}}],[\"picture2\",{\"1\":{\"169\":1}}],[\"pic\",{\"1\":{\"3\":1}}],[\"p\",{\"1\":{\"12\":2,\"26\":2,\"31\":3,\"77\":4,\"232\":12,\"249\":7,\"510\":1,\"512\":2,\"523\":2,\"790\":2,\"1018\":1}}],[\"pdata\",{\"1\":{\"8\":1}}],[\"pdf\",{\"1\":{\"3\":2,\"10\":1}}],[\"街景转语义分割标签等图像转译应用上表现出色\",{\"1\":{\"3\":1}}],[\"夏天转冬天景色\",{\"1\":{\"3\":1}}],[\"在基础篇的最后\",{\"1\":{\"1043\":1}}],[\"在基本分页存储管理方式中\",{\"1\":{\"413\":1}}],[\"在application\",{\"1\":{\"1040\":1}}],[\"在生产环境下\",{\"1\":{\"1024\":1}}],[\"在官网\",{\"1\":{\"1023\":1}}],[\"在左侧菜单会出现这个链接\",{\"1\":{\"1021\":1}}],[\"在弹出的窗口中填写redis服务信息\",{\"1\":{\"1021\":1}}],[\"在安装目录下找到rdm\",{\"1\":{\"1020\":1}}],[\"在课前资料中可以找到redis的图形化桌面客户端\",{\"1\":{\"1020\":1}}],[\"在下面这个仓库可以找到安装包\",{\"1\":{\"1019\":1}}],[\"在存储value时\",{\"1\":{\"1042\":1}}],[\"在存储方式\",{\"1\":{\"1008\":1}}],[\"在存储器分配时\",{\"1\":{\"413\":1}}],[\"在方法上添加了一把synchronized\",{\"1\":{\"998\":1}}],[\"在扣减库存时\",{\"1\":{\"997\":1}}],[\"在测试类中\",{\"1\":{\"989\":1}}],[\"在测试类中通过代理对象调用sell\",{\"1\":{\"94\":1}}],[\"在数据库中查询出来这个数据后\",{\"1\":{\"984\":1}}],[\"在数据库中有一片空间是\",{\"1\":{\"976\":1}}],[\"在两个线程并发来访问时\",{\"1\":{\"982\":1}}],[\"在我们完成了使用工厂设计模式来完成代码的编写之后\",{\"1\":{\"1035\":1}}],[\"在我们原有代码中是这么写的\",{\"1\":{\"996\":1}}],[\"在我们查询商户信息时\",{\"1\":{\"977\":1}}],[\"在我们的服务部署到tomcat后\",{\"1\":{\"961\":1}}],[\"在酷似\",{\"1\":{\"974\":1}}],[\"在设计这个key的时候\",{\"1\":{\"966\":1}}],[\"在userholder处\",{\"1\":{\"962\":1}}],[\"在unix系统中\",{\"1\":{\"183\":1}}],[\"在拦截器处\",{\"1\":{\"962\":1}}],[\"在登录方法处修改\",{\"1\":{\"962\":1}}],[\"在用户执行完请求后\",{\"1\":{\"961\":1}}],[\"在用户看来是有多个线程\",{\"1\":{\"135\":1}}],[\"在资料中提供了一个项目源码\",{\"1\":{\"956\":1}}],[\"在优化和处理简单业务的加持下\",{\"1\":{\"955\":1}}],[\"在优化阶段即可读取到数据\",{\"1\":{\"266\":1}}],[\"在索引创建之后\",{\"1\":{\"928\":1}}],[\"在索引比较时需要转为ascii\",{\"1\":{\"384\":1}}],[\"在某个分片\",{\"1\":{\"928\":1}}],[\"在某一时刻给整个事务系统\",{\"1\":{\"393\":1}}],[\"在某一时间段内只能实现单向传输\",{\"1\":{\"134\":1}}],[\"在原来的逻辑中\",{\"1\":{\"985\":1}}],[\"在原来聊天项目的基础上新增\",{\"1\":{\"783\":1}}],[\"在原有关注事件的基础上\",{\"1\":{\"893\":1}}],[\"在处理时因为没有真正的\",{\"1\":{\"887\":1}}],[\"在事件未处理时\",{\"1\":{\"890\":1}}],[\"在事件发生后\",{\"1\":{\"887\":1}}],[\"在事务开始之前和事务结束以后\",{\"1\":{\"396\":1}}],[\"在任意目录输入redis\",{\"1\":{\"1014\":1}}],[\"在任意时刻\",{\"1\":{\"845\":1}}],[\"在任务完成的过程中遇到了困难\",{\"0\":{\"311\":1}}],[\"在切片过程中\",{\"1\":{\"826\":1}}],[\"在异步处理时\",{\"1\":{\"806\":1}}],[\"在连接建立后被调用\",{\"1\":{\"804\":1}}],[\"在连接建立后触发\",{\"1\":{\"759\":1}}],[\"在没有数据可读时\",{\"1\":{\"877\":1}}],[\"在没有连接建立时\",{\"1\":{\"877\":1}}],[\"在没有标点符号情况下\",{\"1\":{\"766\":1}}],[\"在没有加任何锁的情况下\",{\"1\":{\"101\":1}}],[\"在网络上传输\",{\"1\":{\"766\":1}}],[\"在线\",{\"1\":{\"760\":1}}],[\"在线程执行时\",{\"1\":{\"222\":1}}],[\"在线程使用锁对象时\",{\"1\":{\"221\":1}}],[\"在线程t1中如何优雅地终止另一个线程t2\",{\"1\":{\"206\":1}}],[\"在线程装入内存时\",{\"1\":{\"154\":1}}],[\"在发送消息前\",{\"1\":{\"756\":1}}],[\"在发现许多进程运行时经常发生缺页\",{\"1\":{\"153\":1}}],[\"在传递大量数据时\",{\"1\":{\"751\":1}}],[\"在传送一个或多个数据块的开始和结束时\",{\"1\":{\"181\":1}}],[\"在示例1的基础上\",{\"1\":{\"744\":1}}],[\"在接口的addinterceptors方法中\",{\"1\":{\"738\":1}}],[\"在接口方法数量比较多的时候\",{\"1\":{\"96\":1}}],[\"在项目中它通常作为独立的一层\",{\"1\":{\"735\":1}}],[\"在这种情况下\",{\"1\":{\"999\":1}}],[\"在这种模式下软件被分为三层\",{\"1\":{\"734\":1}}],[\"在这里提到了非常多的问题\",{\"1\":{\"998\":1}}],[\"在这个方案中\",{\"1\":{\"970\":1}}],[\"在这个执行过程中\",{\"1\":{\"132\":1}}],[\"在main方法中\",{\"1\":{\"728\":1}}],[\"在mybatis\",{\"1\":{\"268\":1}}],[\"在加入到这个事务中\",{\"1\":{\"720\":1}}],[\"在加载目标类时\",{\"1\":{\"504\":1}}],[\"在加载外部类的过程中\",{\"1\":{\"101\":1}}],[\"在xml配置文件中配置或者直接基于注解\",{\"1\":{\"719\":1}}],[\"在xml中也是可以直接用\",{\"1\":{\"365\":1}}],[\"在性能方面\",{\"1\":{\"718\":1}}],[\"在类中定义一个threadlocal成员变量\",{\"1\":{\"712\":1}}],[\"在类名上指定使用数据源\",{\"1\":{\"372\":1}}],[\"在bean中尽量避免定义可变的成员变量\",{\"1\":{\"712\":1}}],[\"在b中使用a中的方法\",{\"1\":{\"108\":1}}],[\"在那些系统资源充足\",{\"1\":{\"707\":1}}],[\"在很多时候我们简单地将ioc和di划等号\",{\"1\":{\"706\":1}}],[\"在很多地方还必须保护这种互斥性\",{\"1\":{\"148\":1}}],[\"在要导入的自动配置类上添加\",{\"1\":{\"672\":1}}],[\"在外置\",{\"1\":{\"648\":1}}],[\"在整个\",{\"1\":{\"587\":1,\"595\":1,\"607\":1}}],[\"在转换时\",{\"1\":{\"576\":1}}],[\"在初始化时会从\",{\"1\":{\"561\":1}}],[\"在合适的时机创建代理\",{\"1\":{\"539\":1}}],[\"在当前版本的\",{\"1\":{\"496\":1}}],[\"在容器中没有指定bean的时候才会加载\",{\"1\":{\"731\":1}}],[\"在容器中有指定bean的时候才会加载\",{\"1\":{\"731\":1}}],[\"在容器关闭时\",{\"1\":{\"458\":1}}],[\"在容量允许的情况下\",{\"1\":{\"195\":1}}],[\"在2014年开源\",{\"1\":{\"440\":1}}],[\"在2020学年第一学期中表现优秀\",{\"1\":{\"87\":1,\"89\":1}}],[\"在redis官网中提供了各种语言的客户端\",{\"1\":{\"1031\":1}}],[\"在redis\",{\"1\":{\"433\":1,\"434\":1}}],[\"在rom中存放了很小的\",{\"1\":{\"178\":1}}],[\"在键空间中移出最不经常使用的key\",{\"1\":{\"429\":1}}],[\"在键空间中\",{\"1\":{\"429\":1}}],[\"在4\",{\"1\":{\"429\":1}}],[\"在取出key的时候对数据进行过期检查\",{\"1\":{\"427\":1}}],[\"在载入程序的时候\",{\"1\":{\"419\":1}}],[\"在说操作系统虚拟内存之前有必要说一下局部性原理\",{\"1\":{\"416\":1}}],[\"在分片\",{\"1\":{\"928\":1}}],[\"在分段存储管理方式中\",{\"1\":{\"413\":1}}],[\"在分布式服务中往往都会有一个生成全局id的服务来保证id的唯一性\",{\"1\":{\"315\":1}}],[\"在引入快表的分页存储管理方式中\",{\"1\":{\"413\":1}}],[\"在引入虚拟存储技术以后\",{\"1\":{\"136\":1}}],[\"在为进程分配内存时\",{\"1\":{\"413\":1}}],[\"在选择select\",{\"1\":{\"410\":1}}],[\"在32位的机器上大小就是32\",{\"1\":{\"410\":1}}],[\"在io\",{\"1\":{\"409\":1}}],[\"在innodb中如果采用count\",{\"1\":{\"387\":1}}],[\"在inputstream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节\",{\"1\":{\"123\":1}}],[\"在inputstream类中定义了多个\",{\"1\":{\"123\":1}}],[\"在invoke方法中基本不用\",{\"1\":{\"94\":1}}],[\"在linux上一般为1024\",{\"1\":{\"410\":1}}],[\"在linux下\",{\"1\":{\"409\":1}}],[\"在linux中\",{\"1\":{\"409\":1}}],[\"在linux的缓存i\",{\"1\":{\"408\":1}}],[\"在访问一个表的时候会被自动加上\",{\"1\":{\"400\":1}}],[\"在访问高峰期\",{\"1\":{\"261\":1}}],[\"在该类型容器启动之后\",{\"1\":{\"707\":1}}],[\"在该类首次处理异常时\",{\"1\":{\"616\":1}}],[\"在该类首次使用时\",{\"1\":{\"588\":1,\"596\":1}}],[\"在该方式中\",{\"1\":{\"413\":1}}],[\"在该方法中第18行\",{\"1\":{\"123\":1}}],[\"在该语句执行结束后\",{\"1\":{\"400\":1}}],[\"在执行插入语句时就在表级别加一个auto\",{\"1\":{\"400\":1}}],[\"在表中设计一个版本号字段version\",{\"1\":{\"397\":1}}],[\"在表查询中\",{\"1\":{\"268\":1,\"388\":1}}],[\"在having中可以使用聚合函数\",{\"1\":{\"394\":1}}],[\"在where中使用不到的字段\",{\"1\":{\"384\":1}}],[\"在order\",{\"1\":{\"381\":1}}],[\"在observer模式中\",{\"1\":{\"80\":1}}],[\"在范围查询上\",{\"1\":{\"378\":1}}],[\"在实现\",{\"1\":{\"572\":1}}],[\"在实现数据的参考完整性方面\",{\"1\":{\"375\":1}}],[\"在实现上\",{\"1\":{\"142\":1}}],[\"在业务层实现类方法的类名或方法名上通过\",{\"1\":{\"372\":1}}],[\"在配置文件中进行配置\",{\"1\":{\"372\":1}}],[\"在默认情况下\",{\"1\":{\"357\":1}}],[\"在上面的工作都完成之后\",{\"1\":{\"352\":1}}],[\"在排序方面比较常用\",{\"1\":{\"336\":1}}],[\"在进行读写操作时\",{\"1\":{\"906\":2}}],[\"在进行i\",{\"1\":{\"333\":1}}],[\"在进程运行过程中\",{\"1\":{\"420\":1}}],[\"在进程运行期间\",{\"1\":{\"164\":1}}],[\"在进程运行期间不再改变\",{\"1\":{\"164\":1}}],[\"在缓冲区被创建的时候就被指定\",{\"1\":{\"332\":1}}],[\"在各个通道上切换\",{\"1\":{\"332\":1}}],[\"在第一个拦截器中拦截所有的路径\",{\"1\":{\"971\":1}}],[\"在第一次add时会默认赋值长度为10\",{\"1\":{\"323\":1}}],[\"在第二步中\",{\"1\":{\"290\":1}}],[\"在第二步中找出了每个文件出现频率最高的100个词之后\",{\"1\":{\"290\":1}}],[\"在往数据库中插入数据的时候\",{\"1\":{\"315\":1}}],[\"在什么事情来临的时候\",{\"0\":{\"308\":1}}],[\"在视频阶段也是一样的\",{\"1\":{\"300\":1}}],[\"在具体的实现技术栈或者实现方法上并没有创新点\",{\"1\":{\"298\":1}}],[\"在具体的工厂类中iterator\",{\"1\":{\"78\":1}}],[\"在后来的版本中\",{\"1\":{\"281\":1}}],[\"在后操作之前对相应的同步变量执行p操作\",{\"1\":{\"144\":1}}],[\"在后操作之前执行p\",{\"1\":{\"144\":1}}],[\"在压缩列表中\",{\"1\":{\"279\":1}}],[\"在保存小字符串时\",{\"1\":{\"277\":1}}],[\"在扩展\",{\"1\":{\"277\":1}}],[\"在\",{\"0\":{\"528\":1},\"1\":{\"276\":1,\"383\":1,\"499\":1,\"617\":1,\"644\":1,\"655\":1,\"688\":2,\"699\":1,\"721\":1,\"722\":1,\"776\":3,\"790\":2,\"793\":1,\"803\":1,\"825\":1,\"841\":1,\"865\":1,\"877\":1,\"883\":1,\"906\":1}}],[\"在位数组中把对应下标的值置为\",{\"1\":{\"273\":1}}],[\"在pojo类中增加映射\",{\"1\":{\"268\":1}}],[\"在pcb中存放段表始址和段表长度\",{\"1\":{\"159\":1}}],[\"在功能上与不带\",{\"1\":{\"267\":1}}],[\"在代码中写分页查询逻辑时\",{\"1\":{\"267\":1}}],[\"在建索引时\",{\"1\":{\"266\":1}}],[\"在建造者模式中\",{\"1\":{\"50\":1}}],[\"在建造者模式中具有很重要的作用\",{\"1\":{\"49\":1}}],[\"在varchar字段上建立索引时\",{\"1\":{\"266\":1}}],[\"在tomcat支撑起并发流量后\",{\"1\":{\"955\":1}}],[\"在tryacquire方法中\",{\"1\":{\"258\":1}}],[\"在thread\",{\"1\":{\"211\":1}}],[\"在互斥模式下唤醒的是下一个线程\",{\"1\":{\"253\":1}}],[\"在构造方法中仅仅计算了table的大小\",{\"1\":{\"249\":1}}],[\"在构造过程完成后\",{\"1\":{\"48\":1}}],[\"在完成写之前\",{\"1\":{\"248\":1}}],[\"在cpu给出有效地址后\",{\"1\":{\"413\":1}}],[\"在cpu中设置一对上\",{\"1\":{\"152\":1}}],[\"在cpu中运行不止一个程序\",{\"1\":{\"131\":1}}],[\"在cells创建或扩容时\",{\"1\":{\"234\":1}}],[\"在输出进程的控制下\",{\"1\":{\"184\":1}}],[\"在输入进程的控制下\",{\"1\":{\"184\":1}}],[\"在中断驱动方式中\",{\"1\":{\"181\":1}}],[\"在读已提交中\",{\"1\":{\"393\":1}}],[\"在读\",{\"1\":{\"176\":1,\"181\":1}}],[\"在操作系统看来\",{\"1\":{\"167\":1}}],[\"在操作系统内核看来\",{\"1\":{\"135\":1}}],[\"在其他条件都相同时\",{\"1\":{\"163\":1}}],[\"在请求分页系统中\",{\"1\":{\"162\":1}}],[\"在作业运行时无需一直常驻内存\",{\"1\":{\"161\":1}}],[\"在不久之后\",{\"1\":{\"161\":1,\"417\":1}}],[\"在每个分区中只装入一道作业\",{\"1\":{\"154\":1}}],[\"在每次调度时先计算各个作业\",{\"1\":{\"139\":1}}],[\"在程序中体现为主程序段\",{\"1\":{\"413\":1}}],[\"在程序中尽量多使用commit\",{\"1\":{\"389\":1}}],[\"在程序设计中\",{\"1\":{\"407\":1}}],[\"在程序上\",{\"1\":{\"397\":1}}],[\"在程序执行过程中\",{\"1\":{\"161\":1,\"162\":1}}],[\"在程序执行中需要改目标模块时\",{\"1\":{\"151\":1}}],[\"在程序装入时\",{\"1\":{\"161\":1}}],[\"在程序运行之前\",{\"1\":{\"151\":1}}],[\"在程序运行期间\",{\"1\":{\"151\":1}}],[\"在程序运行前只需要装入它的部分代码就可以运行\",{\"1\":{\"151\":1}}],[\"在程序需要进行拓展的时候\",{\"1\":{\"107\":1}}],[\"在运行期间不能再移动\",{\"1\":{\"151\":1}}],[\"在并发环境下\",{\"1\":{\"147\":1}}],[\"在前操作之后对相应的同步变量执行v操作\",{\"1\":{\"144\":1}}],[\"在前操作之后执行v\",{\"1\":{\"144\":1}}],[\"在临界区之后执行v\",{\"1\":{\"144\":1}}],[\"在临界区之前执行p\",{\"1\":{\"144\":1}}],[\"在一些关键点前后提供扩展\",{\"1\":{\"461\":1}}],[\"在一次事务中\",{\"1\":{\"393\":1}}],[\"在一段时间内\",{\"1\":{\"221\":1}}],[\"在一个网络\",{\"1\":{\"928\":1}}],[\"在一个index\",{\"1\":{\"924\":1}}],[\"在一个索引中\",{\"1\":{\"923\":1}}],[\"在一个集群中\",{\"1\":{\"922\":1}}],[\"在一个时间段内\",{\"1\":{\"161\":1}}],[\"在一个进程访问完临界资源以后会把使用临界区的权限转交给另一个进程\",{\"1\":{\"141\":1}}],[\"在一定程度上降低了系统的耦合度\",{\"1\":{\"97\":1}}],[\"在一定程度上增加了系统的复杂度\",{\"1\":{\"58\":1}}],[\"在k级队列的进程运行过程中\",{\"1\":{\"139\":1}}],[\"在等待io完成期间进程也是在被服务的\",{\"1\":{\"138\":1}}],[\"在允许过程中即便有更紧迫的任务到达\",{\"1\":{\"137\":1}}],[\"在内存中进行\",{\"1\":{\"442\":1}}],[\"在内存中找到后将该页表项存入快表的一个寄存器单元中\",{\"1\":{\"413\":1}}],[\"在内存中实际存放的位置\",{\"1\":{\"151\":1}}],[\"在内存中划出一块共享存储区\",{\"1\":{\"134\":1}}],[\"在内存中放入多个程序\",{\"1\":{\"131\":1}}],[\"在有了并发之后\",{\"1\":{\"131\":1}}],[\"在系统高并发的环境下\",{\"1\":{\"313\":1}}],[\"在系统函数之上\",{\"1\":{\"130\":1}}],[\"在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类\",{\"1\":{\"70\":1}}],[\"在多个字段需要创建索引的情况下\",{\"1\":{\"383\":1}}],[\"在多个线程一起执行的时候\",{\"1\":{\"226\":1}}],[\"在多cpu的计算机中\",{\"1\":{\"135\":1}}],[\"在多道程序环境下\",{\"1\":{\"127\":1}}],[\"在多线程的情况下\",{\"1\":{\"101\":1}}],[\"在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能\",{\"1\":{\"126\":1}}],[\"在抽象类中已经实现\",{\"1\":{\"119\":1}}],[\"在面向对象程序设计过程中\",{\"1\":{\"118\":1}}],[\"在编程上还使用了专门的编译优化来节省内存空间\",{\"1\":{\"277\":1}}],[\"在编程中\",{\"1\":{\"108\":1}}],[\"在编译期就找到\",{\"1\":{\"682\":1}}],[\"在编译时就根据\",{\"1\":{\"682\":1}}],[\"在编译时已经定义\",{\"1\":{\"112\":1}}],[\"在编译和加载时\",{\"1\":{\"504\":1}}],[\"在编译的时候就知道程序存放在内存的哪个位置\",{\"1\":{\"151\":1}}],[\"在编译生成的指令中一般使用的是逻辑地址\",{\"1\":{\"151\":1}}],[\"在适当的情况下\",{\"1\":{\"108\":1}}],[\"在子类中尽量不要重写父类的方\",{\"1\":{\"108\":1}}],[\"在使用锁过程中\",{\"1\":{\"998\":1}}],[\"在使用乐观锁过程中假设100个线程同时都拿到了100的库存\",{\"1\":{\"997\":1}}],[\"在使用\",{\"1\":{\"776\":1}}],[\"在使用分组和排序子句进行数据查询时\",{\"1\":{\"375\":1}}],[\"在使用顺序加锁时\",{\"1\":{\"223\":1}}],[\"在使用继承时\",{\"1\":{\"108\":1}}],[\"在使用建造者模式的场景中\",{\"1\":{\"50\":1}}],[\"在软件开发中\",{\"1\":{\"106\":1}}],[\"在反序列化时被反射调用\",{\"1\":{\"104\":1}}],[\"在seckillvoucher\",{\"1\":{\"998\":1}}],[\"在select\",{\"1\":{\"410\":1}}],[\"在shopserviceimpl\",{\"1\":{\"989\":1,\"990\":1}}],[\"在stringredistemplate返回false\",{\"1\":{\"988\":1}}],[\"在stringredistemplate中返回true\",{\"1\":{\"988\":1}}],[\"在student\",{\"1\":{\"383\":1}}],[\"在spring\",{\"1\":{\"721\":1}}],[\"在spring内部\",{\"1\":{\"716\":1}}],[\"在slave中执行randomkey时\",{\"1\":{\"436\":1}}],[\"在singleton类中添加\",{\"1\":{\"104\":1}}],[\"在singleton类中添加readresolve\",{\"1\":{\"104\":1}}],[\"在sun的jdk实现中\",{\"1\":{\"44\":1}}],[\"在静态代码块中创建该类对象\",{\"1\":{\"101\":1}}],[\"在成员位置创建该类的对象\",{\"1\":{\"101\":4}}],[\"在调用次数较少的情况下\",{\"1\":{\"96\":1}}],[\"在jdk9zhong发布者publisher的实现类submissionpublisher的submit方法是block方法\",{\"1\":{\"745\":1}}],[\"在jdk\",{\"1\":{\"360\":1}}],[\"在jdk1\",{\"1\":{\"96\":2}}],[\"在java程序员的视角看来\",{\"1\":{\"352\":1}}],[\"在java中无法区分运行状态和可运行状态\",{\"1\":{\"208\":1}}],[\"在java中\",{\"1\":{\"60\":1}}],[\"在工厂类中加载配置文件中的全类名\",{\"1\":{\"77\":1}}],[\"在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的\",{\"1\":{\"65\":1}}],[\"在开发中还有一个常用的使用方式\",{\"1\":{\"52\":1}}],[\"在本教程中会介绍三种工厂的使用\",{\"1\":{\"60\":1}}],[\"在指导者中不涉及具体产品的信息\",{\"1\":{\"48\":1}}],[\"在图中缩写为\",{\"1\":{\"587\":3}}],[\"在图块尺度提取纹理等高频信息\",{\"1\":{\"16\":1}}],[\"在图像迁移之后仍保留原始输入图像信息\",{\"1\":{\"3\":1}}],[\"在防止模式崩溃的同时\",{\"1\":{\"3\":1}}],[\"巧妙实现了两个非配对图像域的相互迁移\",{\"1\":{\"3\":1}}],[\"blpop和brpop\",{\"1\":{\"1028\":1}}],[\"bloom\",{\"1\":{\"272\":3}}],[\"blockingoperationexception\",{\"1\":{\"815\":3}}],[\"blocking的区别\",{\"1\":{\"409\":1}}],[\"blocking和non\",{\"1\":{\"409\":1}}],[\"blocking\",{\"1\":{\"331\":1,\"332\":1,\"409\":7}}],[\"blockingqueue<runnable>\",{\"1\":{\"242\":1}}],[\"blocked\",{\"1\":{\"132\":1,\"208\":1,\"211\":1}}],[\"blob\",{\"1\":{\"19\":2,\"32\":1}}],[\"blog\",{\"1\":{\"18\":1,\"31\":4,\"57\":1,\"213\":1,\"214\":1,\"215\":1,\"219\":1,\"961\":1}}],[\"bck\",{\"1\":{\"1015\":1}}],[\"bce\",{\"1\":{\"26\":1}}],[\"bd\",{\"1\":{\"855\":4}}],[\"bos\",{\"1\":{\"770\":3,\"771\":3}}],[\"bosseventloop\",{\"1\":{\"896\":2}}],[\"boss\",{\"1\":{\"749\":3,\"759\":3,\"768\":3,\"783\":3,\"790\":4,\"793\":1,\"798\":4,\"896\":8}}],[\"bound\",{\"1\":{\"749\":2,\"750\":1,\"754\":1,\"756\":1}}],[\"bodylength\",{\"1\":{\"773\":1}}],[\"body\",{\"1\":{\"630\":1,\"752\":2,\"773\":3}}],[\"boolquery\",{\"1\":{\"941\":1}}],[\"boolquerybuilder\",{\"1\":{\"941\":1}}],[\"booleanutil\",{\"1\":{\"988\":1,\"990\":1}}],[\"boolean直接返回true\",{\"1\":{\"320\":1}}],[\"boolean\",{\"1\":{\"94\":2,\"104\":2,\"116\":6,\"224\":2,\"225\":6,\"249\":1,\"255\":6,\"285\":1,\"336\":1,\"341\":1,\"672\":1,\"711\":1,\"758\":1,\"759\":1,\"760\":1,\"790\":4,\"791\":4,\"792\":1,\"793\":2,\"794\":2,\"796\":1,\"822\":2,\"825\":1,\"896\":2,\"933\":1,\"950\":1,\"961\":1,\"972\":2,\"988\":3,\"989\":1,\"990\":4,\"995\":1,\"996\":1,\"997\":2,\"998\":3}}],[\"book\",{\"1\":{\"731\":1}}],[\"books\",{\"1\":{\"731\":2}}],[\"boot<\",{\"1\":{\"931\":2,\"948\":4,\"1038\":5}}],[\"bootstrap\",{\"1\":{\"749\":7,\"753\":7,\"754\":7,\"755\":7,\"756\":7,\"759\":7,\"767\":7,\"775\":4,\"783\":7,\"785\":7,\"787\":7,\"790\":6,\"793\":2,\"798\":1,\"803\":4,\"804\":1,\"816\":1,\"835\":1,\"844\":1}}],[\"boot全局异常处理器\",{\"0\":{\"732\":1}}],[\"boot通过\",{\"1\":{\"730\":1}}],[\"boot启动时便会自动加载相关依赖\",{\"1\":{\"730\":1}}],[\"boot时\",{\"1\":{\"730\":1}}],[\"boot自动装配过程\",{\"0\":{\"730\":1}}],[\"boot项目之后会默认在主类加上\",{\"1\":{\"731\":1}}],[\"boot项目是如何导入包的\",{\"0\":{\"729\":1}}],[\"boot项目的基石\",{\"1\":{\"731\":1}}],[\"boot项目的\",{\"1\":{\"728\":1}}],[\"boot项目创建完成会默认生成一个名为\",{\"1\":{\"728\":1}}],[\"boot的自动装配机制\",{\"1\":{\"731\":1}}],[\"boot的自动配置功能\",{\"1\":{\"730\":1}}],[\"boot的注解的了解\",{\"0\":{\"731\":1}}],[\"boot的启动流程\",{\"0\":{\"728\":1}}],[\"boot的web起步依赖就好了\",{\"1\":{\"727\":1}}],[\"boot的理解\",{\"0\":{\"726\":1}}],[\"boot提供众多起步依赖\",{\"1\":{\"727\":1}}],[\"boot有如下优点\",{\"1\":{\"726\":1}}],[\"boot本身并不提供spring的核心功能\",{\"1\":{\"726\":1}}],[\"boot你可以不用或者只需要很少的spring配置\",{\"1\":{\"726\":1}}],[\"boot很容易创建一个能独立运行\",{\"1\":{\"726\":1}}],[\"boot使用\",{\"1\":{\"726\":1}}],[\"boot就是spring\",{\"1\":{\"726\":1}}],[\"boot中\",{\"1\":{\"721\":1}}],[\"boot\",{\"0\":{\"645\":1,\"646\":1,\"647\":1,\"650\":1,\"658\":1,\"727\":1},\"1\":{\"372\":2,\"451\":3,\"496\":1,\"617\":2,\"623\":1,\"634\":1,\"643\":1,\"644\":1,\"646\":1,\"648\":1,\"651\":5,\"655\":1,\"659\":2,\"660\":2,\"661\":1,\"662\":2,\"668\":2,\"729\":2,\"731\":1,\"931\":2,\"948\":4,\"1038\":4,\"1040\":1}}],[\"b+树的关键字都出现在叶子节点中\",{\"1\":{\"378\":1}}],[\"b+树的效率也比b树高\",{\"1\":{\"378\":1}}],[\"b+树的查询效率更加稳定\",{\"1\":{\"378\":1}}],[\"b+树的内部节点并没有指向关键字具体信息的指针\",{\"1\":{\"378\":1}}],[\"b+树的磁盘读写代价更低\",{\"1\":{\"378\":1}}],[\"b+树的存储能力如何\",{\"0\":{\"377\":1}}],[\"b+tree中的一个节点\",{\"1\":{\"377\":1}}],[\"bbbbb|\",{\"1\":{\"756\":1}}],[\"bbb\",{\"1\":{\"339\":1,\"755\":1,\"767\":1}}],[\"b无法排序\",{\"1\":{\"266\":1}}],[\"b=\",{\"1\":{\"266\":3}}],[\"by的情况下\",{\"1\":{\"381\":1}}],[\"by的场景\",{\"1\":{\"266\":1}}],[\"by\",{\"1\":{\"266\":3,\"383\":4,\"732\":1,\"812\":1,\"950\":1}}],[\"bytetohexstringpadded\",{\"1\":{\"849\":1}}],[\"bytetomessagecodec\",{\"1\":{\"771\":1}}],[\"bytetomessagecodec<message>\",{\"1\":{\"770\":1}}],[\"bytepadding\",{\"1\":{\"849\":5}}],[\"byte2hex\",{\"1\":{\"849\":5}}],[\"byte2char\",{\"1\":{\"849\":6}}],[\"bytebyf\",{\"1\":{\"773\":1}}],[\"bytebufutil\",{\"1\":{\"826\":6,\"829\":3,\"830\":2}}],[\"bytebufallocator\",{\"1\":{\"770\":1,\"794\":1,\"798\":2,\"818\":1,\"819\":2,\"826\":2,\"829\":4,\"830\":2}}],[\"bytebuf\",{\"0\":{\"817\":1,\"831\":1},\"1\":{\"749\":1,\"750\":1,\"751\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"767\":4,\"770\":5,\"771\":3,\"773\":3,\"780\":1,\"794\":10,\"798\":14,\"816\":3,\"818\":4,\"819\":4,\"820\":3,\"821\":1,\"822\":3,\"825\":19,\"826\":15,\"827\":2,\"828\":1,\"829\":12,\"830\":7,\"831\":1,\"834\":1,\"835\":1,\"837\":2,\"842\":1,\"844\":6}}],[\"bytebuffer>\",{\"1\":{\"907\":1,\"909\":2}}],[\"bytebufferutil\",{\"1\":{\"849\":1}}],[\"bytebuffer\",{\"0\":{\"846\":1,\"847\":1,\"848\":1,\"850\":1,\"855\":1,\"891\":1},\"1\":{\"332\":1,\"822\":2,\"831\":1,\"842\":1,\"846\":2,\"848\":1,\"849\":4,\"851\":5,\"855\":2,\"857\":7,\"858\":5,\"859\":6,\"864\":1,\"865\":1,\"876\":3,\"877\":3,\"886\":2,\"890\":11,\"891\":5,\"893\":5,\"896\":2,\"898\":3,\"905\":2,\"907\":4,\"909\":7,\"911\":1}}],[\"bytearrayinputstream\",{\"1\":{\"770\":1,\"771\":1,\"773\":2}}],[\"bytearrayoutputstream\",{\"1\":{\"770\":2,\"771\":2,\"773\":4}}],[\"bytes\",{\"1\":{\"751\":8,\"754\":3,\"768\":3,\"770\":6,\"771\":6,\"773\":12,\"849\":2}}],[\"byte\",{\"1\":{\"105\":2,\"123\":6,\"272\":1,\"320\":1,\"749\":1,\"750\":1,\"753\":1,\"754\":3,\"755\":1,\"756\":3,\"767\":1,\"768\":1,\"770\":7,\"771\":7,\"773\":18,\"798\":2,\"822\":4,\"826\":2,\"829\":2,\"830\":4,\"849\":3,\"852\":1,\"853\":1,\"858\":2,\"889\":2,\"898\":1,\"904\":4}}],[\"broadcast\",{\"1\":{\"790\":1}}],[\"brokenbarrierexception\",{\"1\":{\"263\":4}}],[\"break\",{\"1\":{\"123\":1,\"195\":1,\"206\":1,\"249\":4,\"759\":6,\"792\":6,\"793\":2,\"794\":1,\"804\":1,\"844\":1,\"846\":1,\"889\":1}}],[\"b属于不同的页面\",{\"1\":{\"162\":1}}],[\"b分别使用资源1\",{\"1\":{\"148\":1}}],[\"big\",{\"1\":{\"822\":2}}],[\"bigint\",{\"1\":{\"265\":2}}],[\"bio基于字节流和字符流进行操作\",{\"1\":{\"334\":1}}],[\"bio基本介绍\",{\"1\":{\"331\":1}}],[\"bio是阻塞的\",{\"1\":{\"334\":1}}],[\"bio是以流的形式处理数据\",{\"1\":{\"334\":1}}],[\"bio对比\",{\"1\":{\"334\":1}}],[\"bio方式适用于连接数较小且固定的架构\",{\"1\":{\"334\":1}}],[\"bio问题分析\",{\"1\":{\"331\":1}}],[\"bio模型\",{\"1\":{\"331\":1,\"332\":1}}],[\"bio就是传统的java\",{\"1\":{\"331\":1}}],[\"bio\",{\"0\":{\"330\":1,\"331\":1,\"899\":1},\"1\":{\"331\":1,\"334\":1,\"889\":1}}],[\"bits\",{\"1\":{\"441\":12,\"993\":2}}],[\"bit\",{\"1\":{\"272\":1}}],[\"bipush\",{\"1\":{\"237\":1}}],[\"bin目录下\",{\"1\":{\"1012\":1}}],[\"binding\",{\"1\":{\"749\":2,\"750\":1,\"754\":1,\"756\":1}}],[\"bind\",{\"1\":{\"749\":1,\"758\":1,\"759\":1,\"760\":1,\"768\":1,\"783\":1,\"790\":7,\"798\":2,\"816\":1,\"834\":1,\"844\":1,\"876\":1,\"877\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":1,\"896\":1,\"898\":1,\"909\":1,\"1015\":1}}],[\"binaryoperator\",{\"1\":{\"342\":2}}],[\"binary\",{\"1\":{\"286\":1}}],[\"bincount\",{\"1\":{\"249\":6}}],[\"bins\",{\"1\":{\"249\":1}}],[\"bin的头节点\",{\"1\":{\"249\":1}}],[\"bin\",{\"1\":{\"104\":1,\"249\":1,\"1016\":1}}],[\"bike\",{\"1\":{\"49\":15}}],[\"bilibili\",{\"1\":{\"3\":2,\"6\":1,\"11\":1,\"13\":1,\"17\":1}}],[\"bulk\",{\"1\":{\"934\":1}}],[\"bulkresponse\",{\"1\":{\"934\":1}}],[\"bulkrequest\",{\"1\":{\"934\":2}}],[\"bug\",{\"1\":{\"792\":3,\"842\":1,\"883\":1}}],[\"busy\",{\"1\":{\"337\":6,\"791\":1}}],[\"business\",{\"1\":{\"111\":1}}],[\"buf4\",{\"1\":{\"830\":3}}],[\"buf3\",{\"1\":{\"829\":6,\"830\":2}}],[\"buf2\",{\"1\":{\"829\":6,\"830\":3,\"851\":1}}],[\"buf1\",{\"1\":{\"829\":7,\"830\":3}}],[\"buffer3\",{\"1\":{\"855\":3}}],[\"buffer2\",{\"1\":{\"855\":2}}],[\"buffer1\",{\"1\":{\"855\":3}}],[\"bufferedwriter\",{\"1\":{\"845\":4}}],[\"bufferedreader\",{\"1\":{\"845\":4}}],[\"buffer中的空间\",{\"1\":{\"389\":1}}],[\"buffer常用子类\",{\"1\":{\"332\":1}}],[\"buffer的子类中通过一个对应类型的数组用来存放数据\",{\"1\":{\"332\":1}}],[\"buffer就是一个内存块\",{\"1\":{\"332\":1}}],[\"buffer\",{\"0\":{\"852\":1,\"853\":1,\"856\":1,\"911\":1},\"1\":{\"332\":2,\"334\":1,\"396\":4,\"749\":4,\"750\":4,\"753\":4,\"754\":4,\"755\":5,\"756\":5,\"767\":2,\"770\":1,\"771\":1,\"773\":1,\"798\":2,\"816\":3,\"818\":9,\"819\":2,\"822\":4,\"823\":2,\"824\":10,\"826\":2,\"829\":3,\"830\":3,\"844\":8,\"846\":9,\"847\":4,\"849\":19,\"851\":1,\"852\":1,\"853\":1,\"856\":1,\"857\":1,\"858\":1,\"864\":1,\"865\":6,\"876\":5,\"877\":5,\"883\":1,\"886\":4,\"890\":12,\"891\":5,\"893\":13,\"896\":4,\"898\":8,\"907\":4,\"909\":4,\"911\":4,\"976\":1}}],[\"buf\",{\"1\":{\"277\":4,\"767\":30,\"770\":5,\"798\":7,\"816\":2,\"818\":3,\"825\":2,\"826\":8,\"849\":21,\"851\":1,\"852\":2,\"853\":2,\"904\":5}}],[\"build>\",{\"1\":{\"1038\":1}}],[\"build\",{\"1\":{\"52\":2,\"731\":1,\"974\":1}}],[\"buildseat\",{\"1\":{\"49\":6}}],[\"buildframe\",{\"1\":{\"49\":6}}],[\"builder模式的常规用法\",{\"1\":{\"49\":1}}],[\"builder是抽象建造者\",{\"1\":{\"49\":1}}],[\"builder\",{\"1\":{\"48\":3,\"49\":13,\"51\":1,\"52\":13,\"849\":3,\"932\":1,\"938\":4,\"939\":3,\"940\":3,\"941\":2,\"942\":3,\"943\":3,\"944\":4,\"945\":3,\"946\":3,\"949\":3}}],[\"bubbliiiing\",{\"1\":{\"32\":1}}],[\"banner\",{\"1\":{\"650\":1,\"652\":1}}],[\"basics\",{\"0\":{\"1056\":1}}],[\"basicfileattributes\",{\"1\":{\"872\":4}}],[\"basicdatasource\",{\"1\":{\"660\":1}}],[\"basicerrorcontroller\",{\"0\":{\"621\":1},\"1\":{\"617\":3,\"622\":4,\"623\":1,\"666\":1}}],[\"base\",{\"1\":{\"108\":3,\"234\":1,\"449\":1,\"498\":1,\"502\":1,\"519\":2,\"523\":1}}],[\"basedetection\",{\"1\":{\"32\":1}}],[\"baomidou<\",{\"1\":{\"372\":2}}],[\"baocai\",{\"1\":{\"120\":5}}],[\"backlog\",{\"0\":{\"776\":1},\"1\":{\"776\":5}}],[\"back\",{\"1\":{\"283\":3}}],[\"backbone\",{\"0\":{\"22\":1}}],[\"bar\",{\"1\":{\"263\":6,\"515\":9}}],[\"b站工程师algernon博客\",{\"1\":{\"31\":1}}],[\"b站工程师algernon鉴黄yolo\",{\"1\":{\"31\":1}}],[\"b\",{\"1\":{\"26\":11,\"89\":2,\"105\":2,\"108\":13,\"123\":10,\"133\":1,\"148\":1,\"162\":1,\"221\":3,\"266\":3,\"277\":2,\"339\":6,\"341\":2,\"386\":5,\"749\":1,\"750\":2,\"754\":12,\"755\":11,\"756\":11,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":9,\"829\":4,\"830\":2,\"845\":2,\"846\":1,\"849\":1,\"853\":1,\"855\":2,\"857\":7,\"858\":2,\"871\":4,\"886\":2,\"898\":1,\"907\":1,\"950\":1,\"1029\":3}}],[\"behind\",{\"1\":{\"981\":1}}],[\"beforeeach\",{\"1\":{\"1032\":1,\"1035\":1}}],[\"before\",{\"0\":{\"543\":1},\"1\":{\"510\":2,\"512\":1,\"515\":1,\"523\":1,\"545\":1,\"549\":1,\"876\":1}}],[\"belady异常\",{\"1\":{\"163\":1}}],[\"bet\",{\"1\":{\"116\":3}}],[\"be\",{\"1\":{\"105\":1}}],[\"beantomap\",{\"1\":{\"968\":1,\"983\":1}}],[\"beanutil\",{\"1\":{\"968\":2,\"972\":1,\"983\":1}}],[\"beanutils\",{\"1\":{\"962\":1}}],[\"bean实修方法注册额外的bean或导入其他配置类\",{\"1\":{\"731\":1}}],[\"bean来实现\",{\"1\":{\"713\":1}}],[\"bean注解来注册bean\",{\"1\":{\"713\":1}}],[\"bean注解比\",{\"1\":{\"713\":1}}],[\"bean注解作用于方法\",{\"1\":{\"713\":1}}],[\"bean是线程安全的\",{\"1\":{\"712\":1}}],[\"beansexception\",{\"1\":{\"711\":6}}],[\"beanclass\",{\"1\":{\"711\":1}}],[\"bean的区别是什么\",{\"0\":{\"713\":1}}],[\"bean的生命周期\",{\"0\":{\"711\":1}}],[\"bean的作用域\",{\"0\":{\"710\":1}}],[\"bean在spring容器中是单例的\",{\"1\":{\"710\":1}}],[\"bean2\",{\"1\":{\"670\":3}}],[\"bean1\",{\"1\":{\"670\":3,\"672\":4}}],[\"beanname\",{\"1\":{\"711\":12}}],[\"beannameurlhandlermapping\",{\"0\":{\"624\":1},\"1\":{\"626\":3,\"627\":1,\"643\":1}}],[\"beannameviewresolver\",{\"1\":{\"617\":1,\"622\":1}}],[\"beannameaware\",{\"1\":{\"490\":1}}],[\"beanwrapperimpl\",{\"1\":{\"576\":1,\"579\":1}}],[\"beandefinition\",{\"1\":{\"486\":1,\"650\":1}}],[\"beanpostprocessor\",{\"1\":{\"458\":1,\"463\":3,\"491\":1}}],[\"beanfactory本身并不会自动解析像\",{\"1\":{\"708\":1}}],[\"beanfactory是spring容器的顶层接口\",{\"1\":{\"708\":1}}],[\"beanfactory是类的通用工厂\",{\"1\":{\"708\":1}}],[\"beanfactory是一个类工厂\",{\"1\":{\"708\":1}}],[\"beanfactory是比较合适的ioc容器选择\",{\"1\":{\"707\":1}}],[\"beanfactory和applicationcontext\",{\"1\":{\"707\":1}}],[\"beanfactorytransactionattributesourceadvisor\",{\"1\":{\"662\":1}}],[\"beanfactorypostprocessor\",{\"1\":{\"491\":4}}],[\"beanfactoryaware中setbeanfactory\",{\"1\":{\"711\":1}}],[\"beanfactoryaware\",{\"1\":{\"490\":1}}],[\"beanfactory\",{\"0\":{\"447\":1,\"474\":1,\"475\":1},\"1\":{\"446\":4,\"449\":5,\"451\":1,\"454\":7,\"463\":4,\"473\":1,\"477\":2,\"490\":1,\"491\":2,\"678\":1,\"688\":2,\"695\":1,\"707\":1}}],[\"bean\",{\"0\":{\"445\":1,\"458\":1,\"459\":1,\"464\":1,\"467\":1,\"471\":1,\"481\":1},\"1\":{\"77\":1,\"368\":1,\"449\":2,\"450\":1,\"454\":10,\"458\":6,\"460\":3,\"461\":2,\"463\":9,\"470\":2,\"473\":1,\"476\":1,\"477\":2,\"480\":1,\"486\":1,\"490\":1,\"491\":1,\"495\":4,\"496\":4,\"499\":1,\"503\":1,\"576\":3,\"590\":1,\"619\":2,\"622\":4,\"626\":3,\"627\":2,\"630\":3,\"635\":4,\"638\":1,\"641\":2,\"643\":1,\"644\":1,\"650\":1,\"652\":2,\"659\":2,\"660\":2,\"661\":2,\"662\":1,\"665\":1,\"666\":1,\"667\":1,\"670\":2,\"672\":2,\"678\":1,\"682\":1,\"688\":1,\"695\":9,\"699\":1,\"708\":1,\"711\":7,\"1041\":1}}],[\"beginread\",{\"1\":{\"790\":1,\"793\":1}}],[\"beginindex\",{\"1\":{\"236\":6}}],[\"begin\",{\"1\":{\"26\":1,\"263\":4,\"907\":2,\"993\":4}}],[\"bengio大神\",{\"1\":{\"12\":1}}],[\"bengio\",{\"1\":{\"10\":1}}],[\"bv1wy4y1k7tc\",{\"1\":{\"17\":1}}],[\"bv1wv4y1t71f\",{\"1\":{\"3\":1}}],[\"bv1r44y1377t\",{\"1\":{\"11\":1}}],[\"bv1ya411a78p\",{\"1\":{\"3\":1}}],[\"1个完全拷贝\",{\"1\":{\"928\":1}}],[\"1个记录\",{\"1\":{\"167\":1}}],[\"1tb\",{\"1\":{\"891\":1}}],[\"1~4\",{\"1\":{\"847\":1}}],[\"1~3\",{\"1\":{\"644\":1}}],[\"1s\",{\"1\":{\"792\":1}}],[\"1bit\",{\"1\":{\"992\":1}}],[\"1b\",{\"1\":{\"755\":1}}],[\"1−a\",{\"1\":{\"413\":1}}],[\"1<\",{\"1\":{\"372\":1}}],[\"1还需要手动设置mybatis\",{\"1\":{\"366\":1}}],[\"1指的是手机\",{\"1\":{\"305\":1}}],[\"1表示删除\",{\"1\":{\"265\":1}}],[\"1表示是\",{\"1\":{\"265\":1}}],[\"1表示核心态\",{\"1\":{\"128\":1}}],[\"1l\",{\"1\":{\"249\":1,\"441\":4,\"989\":1}}],[\"1分钟后释放线程\",{\"1\":{\"244\":1}}],[\"1是之前获得过锁\",{\"1\":{\"211\":1}}],[\"1次读磁盘操作\",{\"1\":{\"169\":1}}],[\"1g内存的机器上可以打开10万左右的连接\",{\"1\":{\"410\":1}}],[\"1g的内存大约能监听10万个端口\",{\"1\":{\"410\":1}}],[\"1g\",{\"1\":{\"151\":1}}],[\"1mb\",{\"1\":{\"277\":3,\"891\":1}}],[\"1m\",{\"1\":{\"151\":1}}],[\"1k\",{\"1\":{\"151\":1}}],[\"192\",{\"1\":{\"754\":37,\"755\":32,\"756\":37,\"1032\":1,\"1034\":1,\"1039\":1}}],[\"1970\",{\"1\":{\"272\":1}}],[\"19fda1f5ff23a13b9e546eba14effc6\",{\"1\":{\"159\":1}}],[\"19\",{\"0\":{\"143\":1,\"184\":1,\"553\":1},\"1\":{\"798\":8,\"801\":1}}],[\"18\",{\"0\":{\"142\":1,\"164\":1,\"183\":1,\"546\":1},\"1\":{\"755\":19,\"801\":1,\"813\":4,\"934\":2}}],[\"1804\",{\"1\":{\"30\":1}}],[\"1652976773295\",{\"1\":{\"1036\":1}}],[\"1652943604992\",{\"1\":{\"1028\":1}}],[\"1652942027719\",{\"1\":{\"1027\":1}}],[\"1652941995945\",{\"1\":{\"1027\":1}}],[\"1652941883537\",{\"1\":{\"1026\":1}}],[\"1652941631682\",{\"1\":{\"1026\":1}}],[\"1652890121291\",{\"1\":{\"1025\":1}}],[\"1652887865189\",{\"1\":{\"1024\":1}}],[\"1652887748279\",{\"1\":{\"1023\":1}}],[\"1652887648826\",{\"1\":{\"1023\":1}}],[\"1652887393157\",{\"1\":{\"1023\":1}}],[\"1652882668159\",{\"1\":{\"1001\":1}}],[\"1653374044740\",{\"1\":{\"999\":1}}],[\"1653373908620\",{\"1\":{\"999\":1}}],[\"1653373887844\",{\"1\":{\"999\":1}}],[\"1653371854389\",{\"1\":{\"998\":1}}],[\"1653370271627\",{\"1\":{\"997\":1}}],[\"1653369268550\",{\"1\":{\"996\":1}}],[\"1653368562591\",{\"1\":{\"996\":1}}],[\"1653368335155\",{\"1\":{\"996\":1}}],[\"1653366238564\",{\"1\":{\"995\":1}}],[\"1653365839526\",{\"1\":{\"995\":1}}],[\"1653365145124\",{\"1\":{\"994\":1}}],[\"1653363100502\",{\"1\":{\"992\":1}}],[\"1653362612286\",{\"1\":{\"992\":1}}],[\"1653360308731\",{\"1\":{\"989\":1}}],[\"1653357860001\",{\"1\":{\"988\":1}}],[\"1653357522914\",{\"1\":{\"987\":1}}],[\"1653328663897\",{\"1\":{\"987\":1}}],[\"1653328288627\",{\"1\":{\"987\":1}}],[\"1653328022622\",{\"1\":{\"987\":1}}],[\"1653327884526\",{\"1\":{\"986\":1}}],[\"1653327124561\",{\"1\":{\"985\":1}}],[\"1653326156516\",{\"1\":{\"984\":1}}],[\"1653323595206\",{\"1\":{\"982\":1}}],[\"1653322857620\",{\"1\":{\"981\":1}}],[\"1653322506393\",{\"1\":{\"980\":1}}],[\"1653322190155\",{\"1\":{\"979\":1}}],[\"1653322097736\",{\"1\":{\"978\":1}}],[\"1653320764547\",{\"1\":{\"971\":1}}],[\"1653320822964\",{\"1\":{\"970\":1}}],[\"1653319474181\",{\"1\":{\"967\":1}}],[\"1653319261433\",{\"1\":{\"965\":1}}],[\"1653069893050\",{\"1\":{\"963\":1}}],[\"1653068874258\",{\"1\":{\"961\":1}}],[\"1653068196656\",{\"1\":{\"961\":1}}],[\"1653067054461\",{\"1\":{\"960\":1}}],[\"1653066208144\",{\"1\":{\"959\":1}}],[\"1653060588190\",{\"1\":{\"958\":1}}],[\"1653060337562\",{\"1\":{\"957\":1}}],[\"1653060237073\",{\"1\":{\"956\":1}}],[\"1653054945211\",{\"1\":{\"1042\":1}}],[\"1653054744832\",{\"1\":{\"1042\":1}}],[\"1653054602930\",{\"1\":{\"1042\":1}}],[\"1653059409865\",{\"1\":{\"955\":1}}],[\"1653057872536\",{\"1\":{\"954\":1}}],[\"1640995200l\",{\"1\":{\"993\":1}}],[\"1649059688068l\",{\"1\":{\"441\":1}}],[\"1649059688068\",{\"1\":{\"441\":1}}],[\"16年\",{\"1\":{\"842\":1}}],[\"168\",{\"1\":{\"754\":37,\"755\":32,\"756\":37,\"1032\":1,\"1034\":1,\"1039\":1}}],[\"160b\",{\"1\":{\"749\":1}}],[\"160\",{\"1\":{\"749\":1,\"750\":1}}],[\"163\",{\"1\":{\"731\":1,\"825\":1}}],[\"16384\",{\"1\":{\"435\":1}}],[\"16行出现异常时\",{\"1\":{\"211\":1}}],[\"16\",{\"0\":{\"140\":1,\"162\":1,\"181\":1,\"532\":1},\"1\":{\"277\":1,\"441\":1,\"506\":1,\"519\":1,\"749\":1,\"755\":1,\"756\":1,\"790\":1,\"794\":1,\"798\":1,\"818\":1,\"823\":3,\"824\":3,\"849\":5,\"851\":2,\"873\":2,\"876\":1,\"877\":1,\"886\":6,\"890\":3,\"909\":2}}],[\"1611\",{\"1\":{\"17\":1}}],[\"1级队头的进程分配时间片\",{\"1\":{\"139\":1}}],[\"1479\",{\"1\":{\"872\":1}}],[\"14b\",{\"1\":{\"756\":1}}],[\"1460\",{\"1\":{\"751\":1}}],[\"140b\",{\"1\":{\"750\":1}}],[\"140\",{\"1\":{\"750\":1}}],[\"14行是synchronized中执行的部分\",{\"1\":{\"211\":1}}],[\"14\",{\"0\":{\"138\":1,\"160\":1,\"179\":1,\"524\":1},\"1\":{\"506\":1,\"749\":1,\"750\":1,\"753\":1,\"755\":19,\"756\":23,\"773\":1,\"1025\":1}}],[\"143747206\",{\"1\":{\"31\":1}}],[\"13600527634\",{\"1\":{\"1042\":1}}],[\"133\",{\"1\":{\"872\":1}}],[\"1327497219\",{\"1\":{\"870\":1}}],[\"13b\",{\"1\":{\"756\":1}}],[\"1310712259\",{\"1\":{\"169\":1}}],[\"13\",{\"0\":{\"137\":1,\"159\":1,\"178\":1,\"520\":1,\"830\":1},\"1\":{\"749\":1,\"750\":1,\"753\":1,\"767\":1,\"773\":1,\"907\":3,\"1025\":1}}],[\"124143\",{\"1\":{\"1042\":1}}],[\"12<\",{\"1\":{\"931\":1,\"948\":1}}],[\"123321\",{\"1\":{\"1015\":2,\"1018\":1,\"1032\":1,\"1034\":1,\"1039\":1}}],[\"123\",{\"1\":{\"770\":1}}],[\"1234567890abcd\",{\"1\":{\"846\":1}}],[\"123456\",{\"1\":{\"372\":2,\"731\":2}}],[\"12+5+5\",{\"1\":{\"441\":1}}],[\"12+5\",{\"1\":{\"441\":1}}],[\"12l\",{\"1\":{\"441\":1}}],[\"120\",{\"1\":{\"426\":1}}],[\"12king\",{\"1\":{\"324\":1}}],[\"127\",{\"1\":{\"320\":2,\"426\":4,\"749\":11,\"750\":14,\"775\":1,\"798\":36,\"803\":8,\"816\":1,\"835\":1,\"844\":1,\"852\":1,\"886\":4,\"1018\":1,\"1024\":24,\"1025\":25,\"1027\":18,\"1028\":5,\"1029\":16,\"1035\":1}}],[\"128\",{\"1\":{\"320\":1,\"751\":2,\"886\":1,\"896\":1}}],[\"1284840958643646464\",{\"1\":{\"4\":1}}],[\"122kb\",{\"1\":{\"272\":1}}],[\"125000\",{\"1\":{\"272\":2}}],[\"12\",{\"0\":{\"136\":1,\"158\":1,\"177\":1,\"514\":1,\"829\":1},\"1\":{\"441\":1,\"749\":1,\"750\":1,\"753\":1,\"754\":23,\"770\":1,\"773\":1,\"805\":1,\"812\":3,\"813\":4,\"814\":3,\"823\":2,\"824\":3,\"849\":1,\"1025\":1}}],[\"1只能一气呵成\",{\"1\":{\"133\":1}}],[\"15b\",{\"1\":{\"756\":1}}],[\"150\",{\"1\":{\"1032\":1,\"1034\":1,\"1039\":1}}],[\"1500\",{\"1\":{\"751\":2}}],[\"150岁之内\",{\"1\":{\"265\":1}}],[\"15\",{\"0\":{\"139\":1,\"161\":1,\"180\":1,\"528\":1},\"1\":{\"116\":1,\"749\":1,\"750\":1,\"753\":1,\"773\":1,\"801\":1,\"805\":1,\"818\":1,\"1025\":1}}],[\"11b\",{\"1\":{\"755\":1}}],[\"119\",{\"1\":{\"426\":1}}],[\"111\",{\"1\":{\"241\":1}}],[\"111412907\",{\"1\":{\"215\":1,\"219\":1}}],[\"111408759\",{\"1\":{\"213\":1,\"214\":1}}],[\"11表示标记gc\",{\"1\":{\"210\":1}}],[\"11\",{\"0\":{\"135\":1,\"157\":1,\"176\":1,\"509\":1,\"828\":1,\"946\":1,\"990\":1},\"1\":{\"108\":4,\"135\":1,\"383\":1,\"749\":1,\"750\":1,\"753\":1,\"773\":1,\"798\":1,\"810\":4,\"811\":3,\"812\":3,\"858\":1,\"859\":1,\"946\":1,\"1025\":4}}],[\"17<\",{\"1\":{\"672\":1}}],[\"17\",{\"0\":{\"141\":1,\"163\":1,\"182\":1,\"536\":1},\"1\":{\"82\":1,\"519\":2,\"801\":1,\"1027\":4}}],[\"1703\",{\"1\":{\"3\":1}}],[\"10l\",{\"1\":{\"989\":1}}],[\"102\",{\"1\":{\"783\":1}}],[\"1024k\",{\"1\":{\"876\":1}}],[\"1024\",{\"1\":{\"105\":2,\"272\":1,\"751\":1,\"755\":1,\"756\":1,\"770\":1,\"893\":2}}],[\"101\",{\"1\":{\"783\":1,\"1032\":1,\"1034\":1,\"1039\":1}}],[\"101表示偏向锁\",{\"1\":{\"210\":1}}],[\"10b\",{\"1\":{\"755\":1}}],[\"103\",{\"1\":{\"754\":37,\"755\":32,\"756\":37}}],[\"10表示重量级锁\",{\"1\":{\"210\":1}}],[\"10\",{\"0\":{\"134\":1,\"156\":1,\"175\":1,\"507\":1,\"827\":1,\"945\":1,\"989\":1},\"1\":{\"135\":1,\"225\":6,\"232\":4,\"237\":1,\"321\":1,\"749\":4,\"750\":4,\"753\":3,\"754\":1,\"755\":2,\"756\":22,\"767\":1,\"773\":1,\"805\":1,\"810\":4,\"811\":4,\"818\":3,\"819\":2,\"822\":2,\"823\":1,\"826\":2,\"829\":1,\"830\":1,\"846\":19,\"897\":1,\"905\":2,\"945\":1,\"988\":1,\"989\":1,\"990\":1,\"1005\":1,\"1024\":2,\"1025\":3}}],[\"100ms\",{\"1\":{\"1039\":1}}],[\"1003\",{\"1\":{\"934\":1}}],[\"1002\",{\"1\":{\"934\":1}}],[\"1001\",{\"1\":{\"934\":4}}],[\"1001~2000\",{\"1\":{\"751\":1}}],[\"100w\",{\"1\":{\"272\":1}}],[\"100\",{\"1\":{\"105\":1,\"170\":2,\"192\":1,\"515\":1,\"770\":3,\"791\":3,\"792\":1,\"842\":1,\"845\":2,\"993\":1}}],[\"1000∗60∗60∗24∗365\",{\"1\":{\"440\":1}}],[\"1000=10亿条数据\",{\"1\":{\"377\":1}}],[\"1000000l\",{\"1\":{\"792\":1}}],[\"1000000\",{\"1\":{\"441\":1}}],[\"1000000bit\",{\"1\":{\"272\":1}}],[\"100000\",{\"1\":{\"266\":1}}],[\"100005\",{\"1\":{\"191\":1}}],[\"10000\",{\"1\":{\"116\":3}}],[\"1000\",{\"1\":{\"82\":2,\"206\":1,\"221\":1,\"263\":1,\"377\":1,\"743\":2,\"744\":2,\"776\":1,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"811\":2,\"812\":1,\"813\":1,\"814\":1,\"870\":1,\"1034\":2}}],[\"106246355\",{\"1\":{\"31\":1}}],[\"10593\",{\"1\":{\"3\":1}}],[\"1\",{\"0\":{\"35\":1,\"125\":1,\"147\":1,\"166\":1,\"329\":1,\"387\":1,\"446\":1,\"775\":1,\"783\":1,\"818\":1,\"921\":1,\"922\":2,\"923\":1,\"924\":1,\"925\":1,\"926\":1,\"927\":1,\"928\":1,\"929\":1,\"931\":1,\"936\":1,\"948\":1,\"952\":1,\"953\":2,\"954\":3,\"955\":2,\"956\":2,\"957\":2,\"958\":2,\"959\":1,\"960\":1,\"961\":1,\"962\":1,\"963\":1,\"964\":1,\"965\":2,\"966\":1,\"967\":1,\"968\":1,\"969\":1,\"970\":2,\"971\":1,\"972\":1,\"974\":1,\"975\":2,\"976\":1,\"978\":1,\"979\":1,\"981\":1,\"992\":1,\"1001\":1,\"1003\":1,\"1004\":2,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1011\":1,\"1018\":1,\"1023\":1,\"1032\":1,\"1034\":1,\"1037\":1,\"1038\":2,\"1039\":1,\"1040\":1},\"1\":{\"26\":4,\"58\":1,\"78\":1,\"116\":20,\"123\":4,\"132\":1,\"133\":1,\"134\":3,\"135\":4,\"137\":1,\"139\":1,\"140\":2,\"147\":3,\"148\":2,\"150\":2,\"151\":2,\"154\":1,\"156\":2,\"158\":1,\"163\":4,\"164\":1,\"176\":3,\"191\":5,\"192\":2,\"194\":10,\"195\":7,\"224\":3,\"225\":3,\"230\":1,\"232\":6,\"234\":2,\"237\":2,\"244\":6,\"246\":1,\"249\":8,\"261\":1,\"263\":6,\"265\":2,\"266\":2,\"267\":1,\"268\":1,\"272\":2,\"273\":9,\"277\":4,\"279\":4,\"280\":5,\"282\":6,\"283\":2,\"287\":4,\"290\":1,\"322\":2,\"327\":6,\"328\":2,\"336\":1,\"342\":1,\"366\":2,\"387\":4,\"391\":1,\"420\":3,\"426\":5,\"430\":1,\"441\":4,\"506\":1,\"527\":2,\"541\":1,\"551\":1,\"600\":1,\"651\":1,\"655\":1,\"672\":1,\"688\":3,\"732\":1,\"743\":4,\"744\":7,\"749\":19,\"750\":25,\"753\":1,\"754\":32,\"755\":19,\"756\":36,\"759\":7,\"770\":8,\"771\":7,\"773\":11,\"775\":1,\"776\":2,\"785\":1,\"787\":1,\"790\":14,\"792\":7,\"793\":2,\"794\":1,\"798\":64,\"800\":1,\"801\":5,\"803\":14,\"804\":1,\"807\":1,\"809\":2,\"810\":2,\"811\":4,\"812\":2,\"813\":2,\"814\":4,\"815\":2,\"816\":10,\"818\":1,\"820\":2,\"822\":3,\"823\":1,\"824\":4,\"825\":3,\"826\":7,\"829\":5,\"830\":4,\"833\":1,\"834\":2,\"835\":3,\"844\":1,\"846\":3,\"849\":4,\"855\":2,\"857\":3,\"858\":2,\"859\":2,\"864\":1,\"867\":1,\"871\":6,\"873\":2,\"876\":1,\"877\":1,\"886\":11,\"889\":1,\"890\":6,\"893\":2,\"896\":1,\"898\":1,\"905\":1,\"907\":2,\"909\":1,\"933\":1,\"934\":1,\"936\":1,\"950\":2,\"960\":2,\"961\":2,\"963\":1,\"966\":1,\"968\":2,\"972\":2,\"983\":3,\"985\":2,\"988\":3,\"989\":4,\"990\":8,\"993\":5,\"995\":3,\"996\":2,\"997\":3,\"998\":13,\"999\":1,\"1005\":2,\"1015\":2,\"1018\":2,\"1024\":36,\"1025\":29,\"1026\":6,\"1027\":29,\"1028\":9,\"1029\":25,\"1032\":5,\"1034\":1,\"1035\":2,\"1038\":2}}],[\"a5\",{\"1\":{\"855\":2}}],[\"availableprocessors\",{\"1\":{\"896\":1,\"897\":1}}],[\"avoid\",{\"1\":{\"790\":1}}],[\"av24011528\",{\"1\":{\"6\":1,\"13\":1}}],[\"a49\",{\"1\":{\"702\":1}}],[\"a48\",{\"1\":{\"698\":1}}],[\"a47\",{\"1\":{\"694\":1}}],[\"a46\",{\"1\":{\"690\":1}}],[\"a45\",{\"1\":{\"685\":1}}],[\"a44\",{\"1\":{\"681\":1}}],[\"a43\",{\"1\":{\"677\":1}}],[\"a39\",{\"1\":{\"651\":6}}],[\"a35\",{\"1\":{\"634\":1}}],[\"a31\",{\"1\":{\"615\":1}}],[\"a30\",{\"1\":{\"611\":2}}],[\"a29\",{\"1\":{\"607\":1}}],[\"a28\",{\"1\":{\"603\":2}}],[\"a27\",{\"1\":{\"599\":1}}],[\"a26\",{\"1\":{\"595\":1}}],[\"a23\",{\"1\":{\"578\":1,\"581\":1,\"584\":1}}],[\"a22\",{\"1\":{\"571\":2}}],[\"a21\",{\"1\":{\"567\":1}}],[\"a20\",{\"1\":{\"560\":1,\"563\":2}}],[\"a19\",{\"1\":{\"555\":1}}],[\"a18\",{\"1\":{\"548\":1,\"551\":1}}],[\"a17\",{\"1\":{\"539\":1,\"541\":1,\"544\":1}}],[\"a16\",{\"1\":{\"534\":2}}],[\"a15\",{\"1\":{\"530\":2}}],[\"a14application\",{\"1\":{\"523\":1}}],[\"a13\",{\"1\":{\"522\":1,\"526\":2}}],[\"a12\",{\"1\":{\"515\":2,\"518\":1}}],[\"aftereach\",{\"1\":{\"1032\":1,\"1035\":1}}],[\"after=network\",{\"1\":{\"1016\":1}}],[\"aftercompletion\",{\"1\":{\"644\":1,\"738\":1,\"972\":1}}],[\"afterreturningadviceinterceptor\",{\"1\":{\"549\":1}}],[\"afterreturningadviceadapter\",{\"1\":{\"549\":1}}],[\"afterreturning\",{\"1\":{\"549\":1}}],[\"after\",{\"1\":{\"510\":2,\"512\":1,\"515\":1,\"523\":1,\"876\":1,\"877\":1}}],[\"affinelayer\",{\"1\":{\"17\":1}}],[\"ajc\",{\"0\":{\"505\":1},\"1\":{\"504\":1,\"506\":1}}],[\"aware\",{\"0\":{\"487\":1,\"488\":1},\"1\":{\"458\":1,\"490\":1,\"678\":1}}],[\"await\",{\"1\":{\"224\":2,\"225\":3,\"263\":4,\"759\":1,\"787\":1,\"806\":1,\"813\":2,\"815\":5,\"993\":3}}],[\"a0\",{\"1\":{\"855\":2}}],[\"a08\",{\"1\":{\"498\":1,\"502\":1}}],[\"a07\",{\"1\":{\"494\":1}}],[\"a06\",{\"1\":{\"489\":1}}],[\"a05\",{\"1\":{\"476\":1,\"479\":1,\"482\":1,\"485\":1}}],[\"a04\",{\"1\":{\"469\":1,\"472\":1}}],[\"a03\",{\"1\":{\"460\":1,\"465\":1}}],[\"a02\",{\"1\":{\"453\":1,\"456\":2}}],[\"a01\",{\"1\":{\"448\":1}}],[\"aopcontext\",{\"1\":{\"998\":1}}],[\"aop只能对ioc容器中的bean进行增强\",{\"1\":{\"717\":1}}],[\"aop不能对哪些类进行增强\",{\"0\":{\"717\":1}}],[\"aop为ioc的使用提供了更多的便利\",{\"1\":{\"716\":1}}],[\"aop基于代理\",{\"1\":{\"715\":1}}],[\"aop输入运行时增强\",{\"1\":{\"715\":1}}],[\"aop的区别\",{\"0\":{\"715\":1}}],[\"aop和aspectj\",{\"0\":{\"715\":1}}],[\"aop和cglib实现aop是有所不同的\",{\"1\":{\"714\":1}}],[\"aop会使用cglib生成一个被代理对象的子类来作为代理\",{\"1\":{\"706\":1}}],[\"aop会使用jdk\",{\"1\":{\"706\":1}}],[\"aop是基于动态代理的\",{\"1\":{\"706\":1}}],[\"aop是面向切面编程的意思\",{\"1\":{\"706\":1}}],[\"aopautoconfiguration\",{\"0\":{\"659\":1},\"1\":{\"659\":1}}],[\"aopproxy\",{\"1\":{\"528\":2}}],[\"aopproxyfactory\",{\"1\":{\"528\":1}}],[\"aop\",{\"0\":{\"504\":1,\"505\":1,\"507\":1,\"509\":1},\"1\":{\"449\":1,\"504\":2,\"538\":1,\"541\":1,\"544\":1,\"548\":1,\"551\":1,\"555\":1,\"659\":6,\"705\":1}}],[\"a为快表的命中率\",{\"1\":{\"413\":1}}],[\"auth\",{\"1\":{\"1032\":1}}],[\"authorization\",{\"1\":{\"972\":1}}],[\"author\",{\"1\":{\"194\":2}}],[\"autoconfigurationpackage\",{\"1\":{\"731\":1}}],[\"autoconfigurationpackages\",{\"1\":{\"661\":1}}],[\"autoconfigurationimportselector\",{\"1\":{\"731\":2}}],[\"autoconfiguration2\",{\"1\":{\"670\":3}}],[\"autoconfiguration1\",{\"1\":{\"670\":3,\"672\":1}}],[\"autoconfigure\",{\"1\":{\"634\":1,\"659\":1,\"660\":1,\"661\":1,\"662\":2}}],[\"auto=false\",{\"1\":{\"659\":1}}],[\"autoproxy\",{\"1\":{\"538\":1,\"541\":1,\"544\":1,\"555\":1}}],[\"autowired或者相关注解对对象进行依赖注入\",{\"1\":{\"711\":1}}],[\"autowired一起使用\",{\"1\":{\"709\":1}}],[\"autowired用于按类型注入\",{\"1\":{\"709\":1}}],[\"autowiredannotationbeanpostprocessor\",{\"1\":{\"470\":1,\"473\":1}}],[\"autowired\",{\"0\":{\"471\":1,\"491\":1,\"692\":1,\"693\":1},\"1\":{\"454\":2,\"458\":1,\"460\":1,\"463\":2,\"470\":2,\"473\":1,\"491\":2,\"500\":3,\"695\":1,\"708\":1,\"709\":1,\"711\":1,\"731\":1,\"950\":2,\"1040\":1,\"1042\":1,\"1043\":1}}],[\"auto\",{\"1\":{\"400\":1,\"792\":2}}],[\"ahead\",{\"1\":{\"396\":1}}],[\"aggregation\",{\"1\":{\"945\":1,\"946\":1}}],[\"aggregationbuilders\",{\"1\":{\"945\":1,\"946\":1}}],[\"aggregationbuilder\",{\"1\":{\"945\":3,\"946\":3}}],[\"aggressivelazyloading=false\",{\"1\":{\"366\":1}}],[\"against\",{\"1\":{\"790\":1}}],[\"agegroup\",{\"1\":{\"946\":1}}],[\"age\",{\"1\":{\"370\":3,\"371\":3,\"934\":2,\"937\":1,\"939\":1,\"941\":1,\"942\":1,\"945\":1,\"946\":1,\"1024\":13,\"1025\":10,\"1026\":1,\"1027\":11,\"1032\":1,\"1043\":1}}],[\"agent\",{\"0\":{\"507\":1},\"1\":{\"111\":2,\"504\":1,\"508\":1}}],[\"a+b\",{\"1\":{\"359\":1}}],[\"aaaaaaaaa\",{\"1\":{\"756\":1}}],[\"aaa\",{\"1\":{\"339\":1,\"655\":1,\"767\":2}}],[\"a>\",{\"1\":{\"266\":1}}],[\"a>10\",{\"1\":{\"266\":1}}],[\"a索引即可\",{\"1\":{\"266\":1}}],[\"a列的几乎接近于唯一值\",{\"1\":{\"266\":1}}],[\"a=\",{\"1\":{\"266\":2}}],[\"algorithm=json\",{\"1\":{\"773\":1,\"783\":1}}],[\"algorithm\",{\"1\":{\"773\":9}}],[\"alert\",{\"1\":{\"385\":1}}],[\"all<\",{\"1\":{\"833\":1}}],[\"allargsconstructor\",{\"1\":{\"731\":1,\"816\":1,\"950\":1}}],[\"allkeys\",{\"1\":{\"429\":3}}],[\"allsalary\",{\"1\":{\"342\":2}}],[\"allmatch\",{\"1\":{\"341\":1}}],[\"all\",{\"1\":{\"305\":2,\"849\":1,\"950\":2}}],[\"allocation\",{\"0\":{\"929\":1}}],[\"allocatedirect\",{\"1\":{\"851\":1,\"905\":1}}],[\"allocate\",{\"1\":{\"794\":1,\"846\":1,\"851\":2,\"857\":3,\"858\":2,\"859\":2,\"876\":1,\"877\":1,\"886\":1,\"890\":3,\"893\":1,\"896\":1,\"898\":1,\"905\":1,\"907\":1,\"909\":2}}],[\"allocator\",{\"0\":{\"780\":1,\"781\":1},\"1\":{\"781\":1,\"794\":4,\"820\":1}}],[\"allochandle\",{\"1\":{\"793\":5,\"794\":10}}],[\"alloc\",{\"1\":{\"277\":9,\"749\":1,\"750\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"767\":2,\"771\":1,\"773\":1,\"780\":1,\"816\":3,\"844\":2}}],[\"ali\",{\"1\":{\"841\":1}}],[\"alibaba<\",{\"1\":{\"672\":1}}],[\"alibaba\",{\"1\":{\"672\":1}}],[\"alipay\",{\"1\":{\"265\":1}}],[\"aliyunadmin\",{\"1\":{\"265\":1}}],[\"aliyun\",{\"1\":{\"265\":1}}],[\"aload\",{\"1\":{\"237\":2}}],[\"acknowledgedresponse\",{\"1\":{\"933\":1}}],[\"acknowledged\",{\"1\":{\"933\":2}}],[\"ack\",{\"1\":{\"751\":4,\"776\":3}}],[\"active\",{\"1\":{\"749\":1,\"750\":1,\"754\":2,\"755\":1,\"756\":2,\"759\":1,\"767\":1,\"790\":2,\"793\":1,\"798\":3,\"1039\":1}}],[\"acquiresharedinterruptibly\",{\"1\":{\"255\":1}}],[\"acquireshared\",{\"1\":{\"255\":1}}],[\"acquireinterruptibly\",{\"1\":{\"255\":1}}],[\"acquirequeued\",{\"1\":{\"255\":1}}],[\"acquire\",{\"1\":{\"255\":1}}],[\"accpet\",{\"1\":{\"776\":2,\"909\":1}}],[\"accepthandler\",{\"1\":{\"909\":3}}],[\"acceptor\",{\"1\":{\"790\":1}}],[\"accept\",{\"0\":{\"793\":1,\"884\":1},\"1\":{\"336\":1,\"604\":1,\"617\":1,\"775\":1,\"776\":6,\"790\":3,\"792\":1,\"793\":5,\"798\":2,\"845\":1,\"876\":3,\"877\":4,\"881\":1,\"883\":1,\"884\":2,\"886\":2,\"887\":1,\"889\":1,\"890\":5,\"893\":2,\"896\":3,\"909\":4}}],[\"access\",{\"1\":{\"98\":1,\"413\":1,\"705\":1,\"735\":1,\"904\":1}}],[\"accumulateandget\",{\"1\":{\"232\":1}}],[\"aqs这个抽象类把模板方法运用地炉火纯青\",{\"1\":{\"255\":1}}],[\"aqs中还有一个非常重要的内部类conditionobject\",{\"1\":{\"254\":1}}],[\"aqs中维护了一个队列\",{\"1\":{\"253\":1}}],[\"aqs中定义了一个状态变量state\",{\"1\":{\"252\":1}}],[\"aqs队列\",{\"0\":{\"253\":1}}],[\"aqs的全称是abstractqueuedsynchronizer\",{\"1\":{\"251\":1}}],[\"aqs是什么\",{\"0\":{\"251\":1}}],[\"aqs\",{\"0\":{\"250\":1}}],[\"aside\",{\"1\":{\"981\":1}}],[\"asc\",{\"1\":{\"939\":1}}],[\"ascii\",{\"1\":{\"849\":2}}],[\"assert\",{\"1\":{\"791\":1,\"793\":1}}],[\"asserteventloop\",{\"1\":{\"790\":1}}],[\"association>\",{\"1\":{\"366\":2}}],[\"associated\",{\"1\":{\"105\":2}}],[\"aspects\",{\"1\":{\"705\":1}}],[\"aspect\",{\"0\":{\"536\":1},\"1\":{\"539\":2,\"545\":1}}],[\"aspectj<\",{\"1\":{\"998\":1}}],[\"aspectj相当于在被增强方法的class文件的对应位置调用增强方法实现aop\",{\"1\":{\"714\":1}}],[\"aspectj是在字节码的层面上实现的\",{\"1\":{\"714\":1}}],[\"aspectj与spring\",{\"1\":{\"714\":1}}],[\"aspectjafteradvice\",{\"1\":{\"545\":1}}],[\"aspectjafterthrowingadvice\",{\"1\":{\"545\":1}}],[\"aspectjafterreturningadvice\",{\"1\":{\"545\":1,\"549\":1}}],[\"aspectjaroundadvice\",{\"1\":{\"545\":1}}],[\"aspectjmethodbeforeadvice\",{\"1\":{\"545\":1,\"549\":1}}],[\"aspectjexpressionpointcut\",{\"1\":{\"528\":1}}],[\"aspectj\",{\"0\":{\"714\":1},\"1\":{\"504\":5,\"505\":1,\"506\":1,\"507\":1,\"535\":2}}],[\"asm\",{\"1\":{\"480\":1,\"572\":1}}],[\"async\",{\"1\":{\"449\":1}}],[\"asynchronoussocketchannel\",{\"1\":{\"909\":6}}],[\"asynchronousserversocketchannel\",{\"1\":{\"909\":4}}],[\"asynchronousfilechannel\",{\"1\":{\"907\":3}}],[\"asynchronous\",{\"1\":{\"409\":1,\"839\":1}}],[\"aslist\",{\"1\":{\"337\":1,\"339\":1,\"342\":1,\"759\":1}}],[\"as\",{\"1\":{\"249\":2,\"305\":2}}],[\"attach\",{\"1\":{\"890\":1,\"893\":2}}],[\"attachment\",{\"1\":{\"790\":2,\"890\":2,\"893\":1,\"907\":2,\"909\":13}}],[\"attr\",{\"1\":{\"790\":1,\"793\":1}}],[\"attrs0\",{\"1\":{\"790\":1}}],[\"attrs\",{\"1\":{\"790\":3,\"872\":8}}],[\"attributekey<object>\",{\"1\":{\"790\":2,\"793\":1}}],[\"attribute\",{\"1\":{\"277\":6}}],[\"atbeanpostprocessor\",{\"1\":{\"482\":1}}],[\"at\",{\"1\":{\"249\":1,\"812\":8,\"815\":20,\"825\":1}}],[\"atomicmarkablereference\",{\"1\":{\"232\":1}}],[\"atomicstampedreference\",{\"1\":{\"232\":1}}],[\"atomicreferencefieldupdater\",{\"1\":{\"232\":1}}],[\"atomicreferencearray\",{\"1\":{\"232\":1}}],[\"atomicreference\",{\"1\":{\"232\":1}}],[\"atomicboolean\",{\"1\":{\"232\":1,\"759\":2}}],[\"atomiclongfieldupdater\",{\"1\":{\"232\":1}}],[\"atomiclongarray\",{\"1\":{\"232\":1}}],[\"atomiclong\",{\"1\":{\"232\":1}}],[\"atomicintegerfieldupdater\",{\"1\":{\"232\":1}}],[\"atomicintegerarray\",{\"1\":{\"232\":1}}],[\"atomicinteger\",{\"1\":{\"232\":3,\"872\":6,\"896\":2}}],[\"atomic\",{\"1\":{\"232\":1,\"872\":2}}],[\"atomic原子类\",{\"0\":{\"232\":1}}],[\"abcdef\",{\"1\":{\"751\":2}}],[\"abcdefg\",{\"1\":{\"336\":1}}],[\"abc\",{\"1\":{\"395\":1,\"647\":1,\"751\":2}}],[\"abortpolicy终止策略\",{\"1\":{\"243\":1}}],[\"abs\",{\"1\":{\"17\":1,\"30\":1}}],[\"abstractelasticsearchconfiguration\",{\"1\":{\"949\":1}}],[\"abstractfuture\",{\"1\":{\"812\":2}}],[\"abstractunsafe\",{\"1\":{\"790\":3,\"793\":2}}],[\"abstractchannelhandlercontext\",{\"1\":{\"799\":2}}],[\"abstractchannel\",{\"1\":{\"790\":4,\"793\":3}}],[\"abstractclass\",{\"1\":{\"120\":3}}],[\"abstractbootstrap\",{\"1\":{\"790\":4}}],[\"abstractniobytechannel\",{\"1\":{\"792\":1,\"794\":1,\"825\":1}}],[\"abstractniomessagechannel\",{\"1\":{\"792\":1,\"793\":1}}],[\"abstractniounsafe\",{\"1\":{\"775\":1}}],[\"abstractniochannel\",{\"1\":{\"775\":2,\"790\":1,\"792\":2,\"793\":1}}],[\"abstractskin\",{\"1\":{\"107\":1}}],[\"abstract\",{\"1\":{\"10\":1,\"49\":8,\"68\":1,\"69\":2,\"73\":1,\"82\":3,\"119\":2,\"120\":3,\"123\":2,\"773\":3,\"783\":1,\"825\":1}}],[\"amd等\",{\"1\":{\"109\":1}}],[\"american=com\",{\"1\":{\"77\":1}}],[\"americandessertfactory\",{\"1\":{\"74\":1}}],[\"americanocoffee\",{\"1\":{\"63\":1,\"65\":1}}],[\"americano\",{\"1\":{\"63\":1,\"65\":1}}],[\"americancoffeefactory\",{\"1\":{\"69\":1}}],[\"americancoffee\",{\"1\":{\"60\":1,\"69\":1,\"74\":1,\"77\":1}}],[\"apr\",{\"1\":{\"776\":4}}],[\"apache\",{\"1\":{\"648\":1,\"842\":1,\"931\":2,\"1038\":4}}],[\"appendhexdumprowprefix\",{\"1\":{\"849\":3}}],[\"appendprettyhexdump\",{\"1\":{\"818\":1,\"849\":3}}],[\"append\",{\"1\":{\"368\":2,\"818\":7,\"849\":21,\"893\":1}}],[\"apply\",{\"1\":{\"336\":1,\"990\":3}}],[\"application在run方法中重点做了以下操作\",{\"1\":{\"728\":1}}],[\"application调用run方法的大致流程如下图\",{\"1\":{\"728\":1}}],[\"application类的初始化和启动\",{\"1\":{\"728\":1}}],[\"application的入口类\",{\"1\":{\"728\":1}}],[\"applicationevent\",{\"1\":{\"703\":1}}],[\"applicationlistener\",{\"1\":{\"699\":1}}],[\"applicationrunner\",{\"1\":{\"652\":1}}],[\"applicationcontext类型的容器是比较合适的选择\",{\"1\":{\"707\":1}}],[\"applicationcontext要求更多的系统资源\",{\"1\":{\"707\":1}}],[\"applicationcontext所管理的对象\",{\"1\":{\"707\":1}}],[\"applicationcontextaware\",{\"1\":{\"490\":1}}],[\"applicationcontext\",{\"0\":{\"447\":1,\"455\":1},\"1\":{\"446\":2,\"449\":6,\"450\":1,\"451\":2,\"457\":1,\"490\":1,\"491\":3,\"496\":1,\"503\":1,\"635\":1,\"641\":1,\"650\":1,\"695\":1,\"707\":1}}],[\"application\",{\"0\":{\"497\":1},\"1\":{\"105\":2,\"496\":1,\"647\":1,\"650\":9,\"710\":1,\"773\":1,\"783\":2,\"839\":1}}],[\"ap\",{\"1\":{\"169\":1}}],[\"api<\",{\"1\":{\"931\":1}}],[\"api中仅仅包含了如下四个接口\",{\"1\":{\"742\":1}}],[\"api中的内容\",{\"1\":{\"44\":1}}],[\"api层面对\",{\"1\":{\"208\":1}}],[\"api\",{\"1\":{\"114\":1,\"115\":2,\"277\":5,\"585\":2,\"705\":3,\"841\":1,\"842\":3,\"900\":2}}],[\"a\",{\"1\":{\"41\":2,\"103\":2,\"108\":17,\"133\":1,\"162\":1,\"221\":3,\"237\":2,\"266\":4,\"277\":2,\"282\":7,\"283\":3,\"339\":6,\"359\":1,\"386\":5,\"523\":4,\"749\":2,\"750\":2,\"754\":12,\"755\":12,\"756\":12,\"798\":6,\"822\":2,\"823\":1,\"824\":3,\"826\":8,\"829\":4,\"830\":2,\"845\":1,\"846\":1,\"849\":1,\"855\":2,\"857\":7,\"858\":2,\"871\":3,\"872\":1,\"886\":2,\"893\":1,\"898\":1,\"907\":1,\"1018\":1,\"1024\":3,\"1025\":1,\"1029\":4}}],[\"advance\",{\"0\":{\"1053\":1}}],[\"advanced\",{\"1\":{\"505\":1,\"507\":1}}],[\"advised\",{\"1\":{\"528\":1}}],[\"advisor3\",{\"1\":{\"539\":1}}],[\"advisors\",{\"1\":{\"539\":1}}],[\"advisor\",{\"0\":{\"536\":1},\"1\":{\"528\":1,\"539\":3}}],[\"advice\",{\"1\":{\"528\":2}}],[\"adversarial\",{\"1\":{\"3\":1,\"6\":1,\"10\":1,\"13\":1,\"14\":2,\"16\":1}}],[\"adouble\",{\"1\":{\"343\":2}}],[\"admin\",{\"1\":{\"265\":1}}],[\"addvoucher\",{\"1\":{\"994\":1}}],[\"addpathpatterns\",{\"1\":{\"961\":1}}],[\"addtaskwakesup\",{\"1\":{\"791\":1}}],[\"addtask\",{\"1\":{\"791\":1}}],[\"addlinstener\",{\"1\":{\"806\":1}}],[\"addlistener\",{\"1\":{\"785\":1,\"787\":2,\"790\":2,\"793\":1,\"802\":1,\"803\":2,\"804\":1,\"808\":1,\"811\":1,\"814\":1,\"816\":1,\"844\":1}}],[\"addlast\",{\"1\":{\"749\":3,\"753\":2,\"754\":3,\"755\":3,\"756\":3,\"759\":8,\"764\":4,\"767\":2,\"768\":4,\"783\":8,\"785\":4,\"787\":4,\"790\":3,\"793\":1,\"798\":4,\"803\":4,\"804\":2,\"816\":9,\"834\":2,\"835\":1,\"844\":3}}],[\"addapplicationlistenerbean\",{\"1\":{\"703\":1}}],[\"addandget\",{\"1\":{\"232\":1}}],[\"addmapping\",{\"1\":{\"655\":1}}],[\"addmilk\",{\"1\":{\"69\":2}}],[\"addseckillvoucher\",{\"1\":{\"994\":3}}],[\"addservlet\",{\"1\":{\"655\":1}}],[\"addservletcontainerinitializer\",{\"1\":{\"655\":1,\"657\":1}}],[\"addsugar\",{\"1\":{\"69\":2}}],[\"addcomponents\",{\"1\":{\"829\":1}}],[\"addcontext\",{\"1\":{\"655\":1}}],[\"addcount\",{\"1\":{\"249\":1}}],[\"adderrorpages\",{\"1\":{\"619\":1}}],[\"addbeanpostprocessor\",{\"1\":{\"463\":3}}],[\"addinterceptor\",{\"1\":{\"961\":2}}],[\"addinterceptors\",{\"1\":{\"961\":1}}],[\"addinnerinterceptor\",{\"1\":{\"368\":1}}],[\"adding\",{\"1\":{\"249\":1}}],[\"addwaiter\",{\"1\":{\"255\":1}}],[\"address\",{\"1\":{\"89\":8,\"385\":1,\"890\":1,\"898\":2}}],[\"addobserver\",{\"1\":{\"82\":3}}],[\"add\",{\"1\":{\"69\":2,\"78\":3,\"82\":1,\"285\":1,\"287\":3,\"339\":1,\"385\":1,\"441\":1,\"449\":1,\"463\":1,\"498\":1,\"502\":1,\"519\":2,\"523\":1,\"759\":1,\"770\":1,\"771\":2,\"773\":2,\"790\":1,\"876\":1,\"877\":1,\"896\":1,\"934\":4}}],[\"adaptee\",{\"1\":{\"40\":1}}],[\"adapter\",{\"1\":{\"40\":2,\"41\":4,\"42\":4}}],[\"ar\",{\"1\":{\"305\":1}}],[\"argumentresolvers\",{\"1\":{\"587\":1}}],[\"arg\",{\"1\":{\"255\":26}}],[\"args\",{\"1\":{\"41\":1,\"42\":1,\"49\":1,\"52\":2,\"78\":1,\"82\":1,\"86\":1,\"87\":1,\"89\":2,\"93\":1,\"94\":7,\"95\":4,\"103\":2,\"105\":1,\"108\":1,\"109\":1,\"116\":1,\"120\":1,\"191\":1,\"194\":2,\"206\":1,\"211\":1,\"221\":1,\"224\":3,\"225\":3,\"232\":1,\"282\":1,\"336\":1,\"339\":1,\"441\":1,\"450\":1,\"463\":1,\"510\":2,\"512\":3,\"515\":4,\"523\":1,\"650\":1,\"655\":1,\"743\":1,\"744\":1,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"775\":1,\"776\":2,\"783\":2,\"785\":1,\"787\":3,\"798\":1,\"804\":1,\"816\":1,\"826\":1,\"845\":2,\"846\":1,\"859\":1,\"870\":1,\"872\":1,\"884\":2,\"886\":1,\"889\":2,\"890\":1,\"893\":2,\"896\":1,\"898\":2,\"907\":1,\"909\":1}}],[\"array\",{\"1\":{\"688\":1,\"773\":3,\"891\":1}}],[\"arrays\",{\"1\":{\"337\":1,\"339\":1,\"342\":1,\"759\":1}}],[\"arrayblockingqueue\",{\"1\":{\"242\":1}}],[\"arraylist\",{\"1\":{\"793\":1}}],[\"arraylist的扩容机制\",{\"0\":{\"323\":1}}],[\"arraylist底层采用的是object数组\",{\"1\":{\"322\":1}}],[\"arraylist和linkedlist都是不同步的\",{\"1\":{\"322\":1}}],[\"arraylist和linkedlist的区别\",{\"0\":{\"322\":1}}],[\"arraylist类中的iter内部类是具体的商品类\",{\"1\":{\"78\":1}}],[\"arraylist是具体的工厂类\",{\"1\":{\"78\":1}}],[\"arraylist<>\",{\"1\":{\"78\":1,\"82\":1,\"339\":1,\"463\":1,\"876\":1,\"877\":1,\"950\":1}}],[\"arr\",{\"1\":{\"105\":3,\"889\":3}}],[\"are\",{\"1\":{\"105\":1,\"859\":3}}],[\"artifactid>\",{\"1\":{\"95\":1,\"372\":2,\"648\":1,\"672\":1,\"679\":1,\"833\":1,\"931\":9,\"948\":7,\"998\":1,\"1032\":2,\"1038\":9}}],[\"article\",{\"1\":{\"31\":4,\"213\":1,\"214\":1,\"215\":1,\"219\":1}}],[\"arthas\",{\"1\":{\"94\":1,\"516\":1,\"519\":1}}],[\"arch\",{\"1\":{\"32\":1}}],[\"arxiv\",{\"1\":{\"3\":1,\"17\":1,\"30\":1}}],[\"antirez\",{\"1\":{\"1009\":1}}],[\"antitheft\",{\"1\":{\"110\":7}}],[\"annotationtransactionattributesource\",{\"1\":{\"662\":1}}],[\"annotationawareaspectjautoproxycreator\",{\"1\":{\"539\":1,\"659\":1}}],[\"annotationbeannamegenerator\",{\"1\":{\"480\":1}}],[\"annotationmetadata\",{\"1\":{\"480\":1,\"483\":1,\"670\":1}}],[\"annotationconfigreactivewebserverapplicationcontext\",{\"1\":{\"451\":1}}],[\"annotationconfigservletwebserverapplicationcontext\",{\"1\":{\"451\":1}}],[\"annotationconfigapplicationcontext\",{\"1\":{\"451\":1}}],[\"annotationconfigwebapplicationcontext\",{\"1\":{\"451\":1}}],[\"annotatedtypemetadata\",{\"1\":{\"672\":1}}],[\"annotated\",{\"1\":{\"14\":1}}],[\"anymatch\",{\"1\":{\"341\":1}}],[\"anyone\",{\"1\":{\"105\":1}}],[\"android\",{\"1\":{\"820\":2}}],[\"and\",{\"1\":{\"17\":1,\"105\":1,\"111\":1,\"142\":1,\"249\":1,\"266\":3,\"385\":2,\"997\":2,\"998\":2}}],[\"an\",{\"1\":{\"14\":1,\"791\":1,\"839\":1}}],[\"animegan\",{\"1\":{\"11\":1}}],[\"aioserver\",{\"1\":{\"909\":1}}],[\"aiodemo1\",{\"1\":{\"907\":4}}],[\"aio方式适用于连接数目多且连接比较长的架构\",{\"1\":{\"334\":1}}],[\"aio使用场景分析\",{\"1\":{\"334\":1}}],[\"aio叫做异步非阻塞io\",{\"1\":{\"333\":1}}],[\"aio\",{\"0\":{\"330\":1,\"333\":1,\"906\":1,\"907\":1,\"909\":1},\"1\":{\"330\":1,\"877\":1,\"906\":1,\"907\":3,\"908\":1}}],[\"ai大咖\",{\"1\":{\"12\":1}}],[\"ai\",{\"1\":{\"11\":1}}],[\"ai艺术\",{\"1\":{\"10\":1}}],[\"ivoucherorderservice\",{\"1\":{\"998\":2}}],[\"ignored\",{\"1\":{\"792\":1}}],[\"iiiiiii|\",{\"1\":{\"756\":1}}],[\"iiiiiii\",{\"1\":{\"755\":1}}],[\"illegalaccessexception\",{\"1\":{\"515\":1,\"783\":1}}],[\"illegalargumentexception\",{\"1\":{\"249\":1,\"262\":1,\"441\":2,\"773\":1}}],[\"ix\",{\"1\":{\"400\":3}}],[\"ibatis自带的queryforlist\",{\"1\":{\"268\":1}}],[\"id的组成部分\",{\"1\":{\"992\":1}}],[\"id的规律性太明显\",{\"1\":{\"992\":1}}],[\"id数据类型\",{\"1\":{\"990\":2}}],[\"idle\",{\"1\":{\"764\":4,\"1039\":2}}],[\"idlestateevent\",{\"1\":{\"764\":4}}],[\"idlestatehandler\",{\"1\":{\"764\":2}}],[\"idlestate\",{\"1\":{\"764\":4}}],[\"idea\",{\"1\":{\"506\":1,\"648\":1}}],[\"identity\",{\"1\":{\"342\":1,\"343\":1}}],[\"id>\",{\"1\":{\"366\":6,\"990\":3}}],[\"id=\",{\"1\":{\"366\":6}}],[\"id=b\",{\"1\":{\"266\":1}}],[\"id查询出role的完整信息\",{\"1\":{\"366\":1}}],[\"id查询出user完整信息以及role\",{\"1\":{\"366\":1}}],[\"ids\",{\"1\":{\"366\":3}}],[\"id更新\",{\"1\":{\"267\":1}}],[\"id则为外键\",{\"1\":{\"267\":1}}],[\"id是主键\",{\"1\":{\"267\":1}}],[\"id\",{\"1\":{\"265\":1,\"266\":2,\"267\":1,\"366\":21,\"383\":1,\"391\":1,\"439\":6,\"440\":6,\"441\":17,\"442\":7,\"749\":7,\"750\":9,\"754\":21,\"755\":17,\"756\":21,\"798\":18,\"803\":4,\"934\":6,\"950\":3,\"977\":4,\"983\":7,\"985\":5,\"988\":8,\"989\":7,\"990\":25,\"993\":3,\"995\":1,\"996\":1,\"997\":4,\"998\":11,\"1005\":5,\"1026\":2}}],[\"idx即index\",{\"1\":{\"265\":1}}],[\"i是链表在table中的下标\",{\"1\":{\"249\":1}}],[\"iadd\",{\"1\":{\"230\":1}}],[\"ian\",{\"1\":{\"10\":1}}],[\"icr\",{\"1\":{\"993\":1}}],[\"icp\",{\"1\":{\"385\":1}}],[\"iconst\",{\"1\":{\"230\":1}}],[\"iccv\",{\"1\":{\"3\":1}}],[\"i−1\",{\"1\":{\"194\":1,\"195\":2}}],[\"ipad2018\",{\"1\":{\"950\":1}}],[\"ipv4\",{\"1\":{\"751\":1,\"776\":1}}],[\"ip\",{\"1\":{\"443\":1,\"751\":3,\"766\":1}}],[\"ipconfig\",{\"1\":{\"105\":1}}],[\"ipynb\",{\"1\":{\"19\":2}}],[\"i++是否线程安全\",{\"0\":{\"230\":1}}],[\"i++\",{\"1\":{\"82\":2,\"116\":2,\"123\":1,\"191\":3,\"192\":2,\"194\":5,\"195\":2,\"225\":6,\"230\":1,\"232\":1,\"263\":2,\"282\":3,\"283\":4,\"287\":1,\"441\":2,\"749\":1,\"750\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"845\":2,\"849\":6,\"859\":1,\"890\":1,\"893\":1,\"896\":1,\"993\":2}}],[\"isbefore\",{\"1\":{\"995\":1,\"998\":1}}],[\"isblank\",{\"1\":{\"972\":1,\"989\":1,\"990\":1}}],[\"islock\",{\"1\":{\"989\":2,\"990\":4}}],[\"istrue\",{\"1\":{\"988\":1,\"990\":1}}],[\"isempty\",{\"1\":{\"972\":1,\"983\":1,\"985\":1,\"988\":1,\"990\":1}}],[\"isphoneinvalid\",{\"1\":{\"960\":2,\"968\":1}}],[\"ispresent\",{\"1\":{\"672\":1}}],[\"isprime\",{\"1\":{\"192\":7}}],[\"isreadable\",{\"1\":{\"886\":1,\"890\":1,\"893\":1,\"896\":1}}],[\"isregularfile\",{\"1\":{\"873\":1}}],[\"isdirectory\",{\"1\":{\"873\":1}}],[\"isdone\",{\"1\":{\"790\":1,\"806\":1}}],[\"isoutofbounds\",{\"1\":{\"849\":1}}],[\"isopen\",{\"1\":{\"793\":1}}],[\"isconnectable\",{\"1\":{\"893\":1}}],[\"isconnected\",{\"1\":{\"285\":1}}],[\"iscanceled\",{\"1\":{\"806\":1}}],[\"isvalid\",{\"1\":{\"790\":1,\"792\":1,\"793\":1}}],[\"iswritable\",{\"1\":{\"893\":1}}],[\"iswindows\",{\"1\":{\"790\":1}}],[\"isweakerthan\",{\"1\":{\"116\":1}}],[\"isafter\",{\"1\":{\"989\":1,\"990\":1,\"995\":1,\"998\":1}}],[\"isacknowledged\",{\"1\":{\"933\":2}}],[\"isacceptable\",{\"1\":{\"793\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":1,\"896\":1}}],[\"isactive\",{\"1\":{\"790\":4,\"793\":1}}],[\"isanylocaladdress\",{\"1\":{\"790\":1}}],[\"isautoread\",{\"1\":{\"790\":1,\"793\":2,\"794\":2}}],[\"isassignablefrom\",{\"1\":{\"695\":1}}],[\"isshuttingdown\",{\"1\":{\"791\":1}}],[\"isshutdown\",{\"1\":{\"791\":1}}],[\"issuccess\",{\"1\":{\"759\":1,\"785\":1,\"787\":1,\"790\":1,\"793\":1,\"806\":2,\"813\":1,\"814\":1}}],[\"isstrongerthan\",{\"1\":{\"116\":3}}],[\"isnotblank\",{\"1\":{\"370\":1,\"371\":2,\"983\":1,\"985\":1,\"988\":1,\"990\":2}}],[\"isnotempty\",{\"1\":{\"368\":2}}],[\"isnull\",{\"1\":{\"267\":2}}],[\"isheldexclusively\",{\"1\":{\"255\":1}}],[\"isinterrupted\",{\"1\":{\"204\":1,\"206\":1}}],[\"isinstantiable\",{\"1\":{\"104\":2}}],[\"is\",{\"1\":{\"77\":2,\"400\":3,\"626\":1,\"630\":1,\"839\":1}}],[\"itcast\",{\"1\":{\"783\":2,\"785\":1,\"812\":2,\"815\":2}}],[\"itcastsafetydoor\",{\"1\":{\"110\":2}}],[\"iterable<product>\",{\"1\":{\"950\":1}}],[\"iterable\",{\"1\":{\"796\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"793\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":2,\"896\":2}}],[\"iterator<string>\",{\"1\":{\"78\":1}}],[\"iterator接口是抽象商品类\",{\"1\":{\"78\":1}}],[\"iterator\",{\"1\":{\"78\":1,\"793\":1,\"884\":1,\"886\":1,\"890\":1,\"893\":2,\"896\":2}}],[\"iterator方法\",{\"0\":{\"78\":1}}],[\"iter\",{\"0\":{\"887\":1},\"1\":{\"793\":3,\"884\":4,\"886\":4,\"890\":4,\"893\":8,\"896\":8}}],[\"item\",{\"1\":{\"743\":2,\"744\":6,\"1005\":2}}],[\"it\",{\"1\":{\"78\":3}}],[\"itheima\",{\"1\":{\"77\":2,\"94\":3,\"448\":1,\"453\":1,\"456\":1,\"460\":1,\"465\":1,\"469\":1,\"472\":1,\"476\":1,\"479\":1,\"482\":1,\"485\":1,\"489\":1,\"494\":1,\"498\":1,\"500\":5,\"502\":1,\"518\":1,\"522\":1,\"526\":2,\"530\":1,\"534\":1,\"560\":1,\"563\":2,\"567\":1,\"571\":1,\"578\":1,\"581\":1,\"584\":1,\"595\":1,\"599\":1,\"603\":1,\"607\":1,\"611\":1,\"615\":1,\"651\":3,\"677\":1,\"681\":1,\"685\":1,\"690\":1,\"694\":1,\"698\":1,\"702\":1}}],[\"italydessertfactory\",{\"1\":{\"74\":1}}],[\"if\",{\"1\":{\"41\":1,\"57\":4,\"58\":4,\"63\":2,\"65\":2,\"101\":6,\"103\":2,\"104\":5,\"116\":8,\"123\":5,\"191\":2,\"192\":2,\"194\":1,\"195\":1,\"206\":1,\"225\":2,\"236\":3,\"249\":23,\"255\":9,\"260\":2,\"262\":1,\"267\":2,\"282\":7,\"283\":7,\"285\":2,\"336\":1,\"368\":2,\"386\":2,\"441\":5,\"527\":2,\"673\":1,\"711\":6,\"744\":1,\"759\":4,\"760\":2,\"761\":3,\"764\":2,\"768\":2,\"773\":3,\"775\":2,\"783\":1,\"785\":1,\"787\":3,\"788\":2,\"790\":19,\"791\":10,\"792\":13,\"793\":15,\"794\":5,\"798\":1,\"799\":1,\"804\":1,\"825\":1,\"844\":1,\"846\":1,\"849\":5,\"859\":1,\"872\":1,\"873\":2,\"877\":2,\"884\":2,\"886\":4,\"889\":1,\"890\":5,\"893\":6,\"896\":6,\"909\":2,\"960\":4,\"961\":1,\"968\":3,\"972\":3,\"983\":3,\"985\":3,\"988\":4,\"989\":3,\"990\":11,\"995\":4,\"996\":2,\"998\":9,\"1024\":1,\"1025\":1,\"1032\":1,\"1035\":1}}],[\"indices\",{\"1\":{\"933\":3,\"936\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1}}],[\"index=false\",{\"1\":{\"950\":1}}],[\"index=false表示不做索引关联\",{\"1\":{\"950\":1}}],[\"indexname\",{\"1\":{\"950\":2}}],[\"indexresponse\",{\"1\":{\"934\":1}}],[\"indexrequest\",{\"1\":{\"934\":5}}],[\"indexer<\",{\"1\":{\"679\":1}}],[\"indexed\",{\"0\":{\"679\":1,\"680\":1},\"1\":{\"286\":1,\"682\":1}}],[\"index位置增加val\",{\"1\":{\"287\":1}}],[\"index\",{\"0\":{\"922\":1},\"1\":{\"266\":2,\"287\":14,\"385\":2,\"641\":1,\"642\":3,\"653\":2,\"818\":4,\"822\":4,\"823\":2,\"824\":7,\"826\":2,\"829\":2,\"849\":2,\"896\":7,\"934\":7}}],[\"indexoutofboundsexception\",{\"1\":{\"123\":1,\"826\":1,\"849\":1}}],[\"inbound\",{\"1\":{\"825\":1,\"837\":1}}],[\"input\",{\"1\":{\"804\":1}}],[\"inputshutdown\",{\"1\":{\"793\":1}}],[\"inputstream类就使用了模板方法模式\",{\"1\":{\"123\":1}}],[\"inputstreamreader\",{\"1\":{\"845\":2}}],[\"inputstreamreader做了inputstream字节流类到reader字符流之间的转换\",{\"1\":{\"44\":1}}],[\"inputstreamreader是对同样实现了reader的streamdecoder的封装\",{\"1\":{\"44\":1}}],[\"inputstreamreader继承自java\",{\"1\":{\"44\":1}}],[\"inputstream\",{\"1\":{\"44\":2,\"77\":1,\"105\":3,\"123\":1,\"773\":1,\"783\":1,\"889\":1}}],[\"ineventloop\",{\"1\":{\"790\":1,\"791\":7,\"793\":2,\"796\":1,\"799\":1}}],[\"inetsocketaddress\",{\"1\":{\"776\":1,\"790\":3,\"804\":1,\"876\":2,\"877\":1,\"884\":1,\"886\":1,\"890\":2,\"893\":2,\"896\":1,\"898\":3,\"909\":1}}],[\"inactive\",{\"1\":{\"762\":1,\"876\":1}}],[\"inherited\",{\"1\":{\"731\":1}}],[\"inf\",{\"1\":{\"649\":1,\"653\":2,\"670\":2,\"671\":1,\"682\":2}}],[\"info\",{\"1\":{\"383\":1,\"500\":4,\"933\":5,\"950\":2}}],[\"injectionmetadata\",{\"1\":{\"473\":3}}],[\"inject\",{\"1\":{\"463\":2}}],[\"in的逻辑\",{\"1\":{\"386\":1}}],[\"innodb引擎也采用这种方法\",{\"1\":{\"403\":1}}],[\"innodb行级锁是通过给索引上的索引项加锁来实现的\",{\"1\":{\"402\":1}}],[\"innodb中行级锁是怎么实现的\",{\"0\":{\"402\":1}}],[\"innodb中每行数据都有隐藏列\",{\"1\":{\"393\":1}}],[\"innodb通过锁机制来保证这一点\",{\"1\":{\"396\":1}}],[\"innodb提供了缓存\",{\"1\":{\"396\":1}}],[\"innodb作为mysql的存储引擎\",{\"1\":{\"396\":1}}],[\"innodb会根据undo\",{\"1\":{\"396\":1}}],[\"innodb会生成对应的undo\",{\"1\":{\"396\":1}}],[\"innodb实现回滚靠的是undo\",{\"1\":{\"396\":1}}],[\"innodb实现mvcc\",{\"1\":{\"393\":1}}],[\"innodb的默认隔离级别是repeatable\",{\"1\":{\"393\":1}}],[\"innodb数据文件本身是一颗b+树\",{\"1\":{\"380\":1}}],[\"innodb为什么使用自增主键是一个很好的选择\",{\"0\":{\"380\":1}}],[\"innodb为什么不建议用过长的字段作为主键\",{\"0\":{\"379\":1}}],[\"innodb存储引擎中页的大小为16\",{\"1\":{\"377\":1}}],[\"in操作能避免则避免\",{\"1\":{\"267\":1}}],[\"initeventloops\",{\"1\":{\"896\":2}}],[\"initmap\",{\"1\":{\"790\":1}}],[\"initmethod\",{\"1\":{\"495\":2}}],[\"initandregister\",{\"1\":{\"790\":5}}],[\"initchannel\",{\"1\":{\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"783\":2,\"785\":1,\"787\":3,\"790\":5,\"798\":3,\"803\":4,\"804\":1,\"816\":2,\"834\":2,\"835\":2,\"844\":2}}],[\"initbinder\",{\"0\":{\"586\":1,\"587\":1},\"1\":{\"576\":1,\"582\":3,\"587\":1,\"588\":5}}],[\"init\",{\"1\":{\"441\":2,\"491\":1,\"790\":3,\"798\":1}}],[\"initializingbean\",{\"0\":{\"488\":1},\"1\":{\"490\":1,\"495\":2}}],[\"initial\",{\"1\":{\"328\":1}}],[\"initialcapacity\",{\"1\":{\"249\":5}}],[\"inittable\",{\"1\":{\"249\":1}}],[\"incomplete\",{\"1\":{\"815\":2}}],[\"incolor\",{\"1\":{\"11\":1}}],[\"incmessagesread\",{\"1\":{\"793\":1,\"794\":1}}],[\"incr和incrby和decy\",{\"1\":{\"1025\":1}}],[\"incrbyfloat\",{\"1\":{\"1025\":1}}],[\"incrby\",{\"1\":{\"1025\":6}}],[\"incr\",{\"1\":{\"422\":1,\"1025\":3}}],[\"increment\",{\"1\":{\"993\":1,\"1030\":1}}],[\"increment修饰的列分配递增的值\",{\"1\":{\"400\":1}}],[\"increment列的表中插入数据时需要获取的一种特殊的表级锁\",{\"1\":{\"400\":1}}],[\"incrementandget\",{\"1\":{\"232\":1,\"872\":3}}],[\"inc锁释放掉\",{\"1\":{\"400\":1}}],[\"inc锁\",{\"1\":{\"400\":1}}],[\"inc锁是当想使用含有auto\",{\"1\":{\"400\":1}}],[\"include\",{\"1\":{\"277\":2,\"940\":2}}],[\"include<bits\",{\"1\":{\"192\":1,\"283\":1}}],[\"in\",{\"1\":{\"191\":1,\"194\":2,\"249\":1,\"366\":3,\"381\":1,\"386\":5,\"759\":3,\"770\":9,\"771\":9,\"773\":15,\"776\":2,\"783\":2,\"804\":1,\"812\":1,\"844\":1,\"849\":1,\"884\":1,\"889\":2,\"890\":1,\"907\":1,\"908\":1,\"909\":1}}],[\"invocationtargetexception\",{\"1\":{\"515\":1,\"523\":1}}],[\"invocationhandler接口\",{\"1\":{\"515\":1}}],[\"invocationhandler中invoke方法参数说明\",{\"1\":{\"94\":1}}],[\"invocationhandler\",{\"1\":{\"94\":12,\"96\":1,\"515\":5,\"523\":1}}],[\"invokechannelread\",{\"1\":{\"799\":4}}],[\"invokelater\",{\"1\":{\"790\":1}}],[\"invokehandleraddedifneeded\",{\"1\":{\"790\":1,\"793\":1}}],[\"invokejoinpoint\",{\"1\":{\"546\":1}}],[\"invokespecial\",{\"1\":{\"237\":1}}],[\"invokesuper\",{\"1\":{\"95\":1,\"512\":1,\"523\":2,\"527\":1,\"686\":1}}],[\"invoked\",{\"1\":{\"105\":1}}],[\"invokereadresolve\",{\"1\":{\"104\":1}}],[\"invoke方法通过反射执行了真实对象所属类\",{\"1\":{\"94\":1}}],[\"invoke\",{\"1\":{\"94\":9,\"96\":1,\"510\":1,\"512\":1,\"515\":5,\"523\":4,\"527\":1,\"546\":2,\"784\":3}}],[\"install\",{\"1\":{\"1011\":1,\"1012\":1,\"1016\":1}}],[\"instantiationexception\",{\"1\":{\"783\":1}}],[\"instantiationawarebeanpostprocessor\",{\"1\":{\"711\":1}}],[\"instantiate\",{\"1\":{\"105\":1}}],[\"instanceclass\",{\"1\":{\"783\":2}}],[\"instanceof\",{\"1\":{\"249\":1,\"759\":1,\"768\":2,\"790\":1,\"798\":1,\"825\":1}}],[\"instance对象是随着类的加载而创建的\",{\"1\":{\"101\":1}}],[\"instanceb\",{\"1\":{\"57\":1}}],[\"instance\",{\"1\":{\"57\":15,\"101\":26,\"103\":13,\"104\":11,\"105\":1,\"790\":1,\"932\":3,\"1038\":1}}],[\"insert\",{\"1\":{\"282\":5,\"391\":1}}],[\"inside\",{\"1\":{\"58\":3}}],[\"intbuffer\",{\"1\":{\"332\":1,\"911\":1}}],[\"integration\",{\"1\":{\"705\":1}}],[\"integer>>\",{\"1\":{\"808\":1}}],[\"integer>\",{\"1\":{\"285\":1,\"808\":1}}],[\"integer\",{\"1\":{\"94\":1,\"244\":1,\"320\":1,\"321\":1,\"336\":1,\"342\":2,\"370\":1,\"426\":2,\"743\":1,\"744\":1,\"773\":1,\"807\":1,\"808\":1,\"823\":1,\"907\":1,\"909\":2,\"934\":1,\"949\":1,\"1024\":10,\"1025\":11,\"1027\":7,\"1028\":2,\"1029\":11}}],[\"intern\",{\"1\":{\"998\":4}}],[\"internal\",{\"1\":{\"519\":1,\"812\":1,\"815\":2}}],[\"interestops\",{\"1\":{\"790\":6,\"792\":2,\"793\":6,\"890\":2,\"893\":4,\"896\":2}}],[\"interrupted\",{\"1\":{\"255\":2,\"791\":1,\"792\":1}}],[\"interruptedexception\",{\"1\":{\"82\":2,\"206\":2,\"221\":2,\"224\":2,\"225\":4,\"255\":4,\"263\":4,\"743\":2,\"744\":2,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"783\":1,\"798\":1,\"804\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":1,\"988\":1,\"990\":1,\"993\":1}}],[\"interrupt\",{\"0\":{\"204\":1},\"1\":{\"206\":2,\"791\":1,\"883\":1}}],[\"interview\",{\"0\":{\"1049\":1},\"2\":{\"199\":1,\"200\":1}}],[\"interceptorregistry\",{\"1\":{\"961\":1}}],[\"interceptors\",{\"1\":{\"549\":1}}],[\"interceptor\",{\"1\":{\"368\":3}}],[\"intercept\",{\"1\":{\"95\":1}}],[\"intercept方法参数说明\",{\"1\":{\"95\":1}}],[\"interfaceclass\",{\"1\":{\"783\":4}}],[\"interfacename\",{\"1\":{\"783\":4}}],[\"interfaces\",{\"1\":{\"94\":1,\"787\":2}}],[\"interface\",{\"1\":{\"41\":2,\"58\":1,\"69\":1,\"74\":1,\"82\":1,\"93\":1,\"94\":1,\"110\":3,\"116\":1,\"336\":1,\"463\":1,\"510\":1,\"515\":2,\"731\":1,\"742\":4,\"758\":3,\"773\":1,\"806\":2,\"950\":1}}],[\"intelcpu\",{\"1\":{\"109\":6}}],[\"intel处理器\",{\"1\":{\"109\":1}}],[\"intel\",{\"1\":{\"52\":2}}],[\"int\",{\"1\":{\"44\":4,\"82\":6,\"94\":1,\"104\":1,\"105\":1,\"108\":12,\"116\":24,\"123\":9,\"191\":10,\"192\":6,\"194\":23,\"195\":25,\"211\":1,\"225\":6,\"234\":1,\"236\":3,\"237\":1,\"241\":1,\"242\":2,\"244\":1,\"249\":9,\"255\":11,\"260\":2,\"261\":3,\"262\":1,\"263\":2,\"265\":1,\"268\":2,\"277\":8,\"282\":7,\"283\":10,\"285\":11,\"287\":17,\"321\":1,\"383\":2,\"406\":1,\"441\":2,\"515\":4,\"527\":3,\"732\":1,\"749\":1,\"750\":1,\"753\":1,\"754\":2,\"755\":2,\"756\":2,\"770\":3,\"771\":3,\"773\":25,\"775\":1,\"776\":1,\"783\":5,\"787\":1,\"790\":1,\"791\":1,\"792\":4,\"793\":4,\"809\":1,\"818\":2,\"822\":9,\"823\":1,\"824\":1,\"845\":2,\"846\":1,\"849\":24,\"852\":1,\"853\":2,\"859\":2,\"864\":1,\"877\":1,\"882\":3,\"884\":2,\"886\":3,\"889\":1,\"890\":4,\"893\":4,\"896\":4,\"904\":1,\"950\":4,\"993\":3,\"996\":1,\"998\":3,\"1025\":1}}],[\"i=1\",{\"1\":{\"26\":1}}],[\"i=0\",{\"1\":{\"26\":3}}],[\"i\",{\"0\":{\"179\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"408\":1,\"409\":1},\"1\":{\"26\":5,\"82\":4,\"116\":5,\"123\":4,\"130\":1,\"179\":2,\"180\":4,\"181\":8,\"183\":3,\"191\":12,\"192\":11,\"194\":33,\"195\":22,\"225\":12,\"230\":2,\"232\":37,\"237\":1,\"246\":1,\"249\":5,\"263\":4,\"282\":13,\"283\":16,\"287\":4,\"290\":1,\"321\":2,\"331\":1,\"333\":1,\"386\":4,\"409\":2,\"429\":1,\"441\":4,\"732\":1,\"743\":2,\"744\":2,\"749\":9,\"750\":11,\"753\":2,\"754\":25,\"755\":21,\"756\":25,\"793\":4,\"798\":30,\"800\":2,\"801\":5,\"809\":1,\"810\":4,\"811\":3,\"812\":3,\"813\":4,\"814\":3,\"826\":1,\"845\":6,\"846\":17,\"849\":30,\"853\":2,\"858\":1,\"859\":7,\"886\":6,\"890\":4,\"893\":2,\"896\":4,\"902\":1,\"907\":3,\"993\":4}}],[\"imsi\",{\"1\":{\"296\":1}}],[\"img\",{\"1\":{\"169\":1,\"188\":1,\"270\":1,\"276\":3,\"277\":3,\"279\":2,\"280\":3,\"635\":1,\"643\":1}}],[\"imgflip\",{\"1\":{\"11\":1}}],[\"immediate\",{\"1\":{\"111\":1}}],[\"import注解导入的importselector来完成的\",{\"1\":{\"731\":1}}],[\"importingclassmetadata\",{\"1\":{\"670\":1}}],[\"importbeandefinitionregistrar\",{\"1\":{\"661\":1}}],[\"importresource\",{\"1\":{\"476\":1}}],[\"import\",{\"1\":{\"94\":5,\"194\":2,\"441\":2,\"476\":1,\"670\":1,\"671\":2,\"731\":3}}],[\"implements\",{\"1\":{\"41\":3,\"42\":1,\"58\":3,\"69\":2,\"74\":2,\"82\":2,\"86\":1,\"87\":1,\"89\":1,\"93\":2,\"94\":4,\"95\":1,\"103\":1,\"104\":1,\"109\":3,\"110\":2,\"116\":2,\"123\":1,\"249\":1,\"372\":1,\"510\":1,\"515\":2,\"670\":1,\"672\":1,\"711\":1,\"744\":1,\"773\":2,\"776\":1,\"783\":1,\"896\":2,\"909\":3,\"961\":2,\"972\":2}}],[\"implementation\",{\"1\":{\"14\":1,\"249\":1}}],[\"images\",{\"1\":{\"635\":1,\"950\":3}}],[\"image\",{\"1\":{\"3\":2,\"16\":2,\"21\":1,\"27\":1,\"28\":1,\"155\":1,\"160\":4,\"161\":2,\"162\":3,\"163\":5,\"164\":3,\"166\":4,\"167\":11,\"168\":11,\"169\":14,\"170\":13,\"171\":8,\"172\":4,\"173\":5,\"174\":2,\"175\":5,\"176\":7,\"177\":7,\"178\":3,\"179\":4,\"180\":4,\"181\":6,\"182\":6,\"183\":1,\"184\":7,\"185\":8,\"186\":13,\"992\":1,\"1012\":1,\"1015\":1,\"1031\":1}}],[\"iotime\",{\"1\":{\"791\":2}}],[\"iostarttime\",{\"1\":{\"791\":2}}],[\"ioratio\",{\"1\":{\"791\":7}}],[\"iocp\",{\"1\":{\"906\":1}}],[\"ioc容器销毁时销毁\",{\"1\":{\"710\":1}}],[\"ioc容器启动时创建\",{\"1\":{\"710\":1}}],[\"ioc是通过di来实现的\",{\"1\":{\"706\":1}}],[\"ioc可以帮助我们维护对象与对象之间的依赖关系\",{\"1\":{\"706\":1}}],[\"ioc叫反转控制\",{\"1\":{\"706\":1}}],[\"ioc\",{\"1\":{\"705\":1}}],[\"io对比\",{\"1\":{\"409\":1}}],[\"io在kernel准备数据的情况下会立刻返回\",{\"1\":{\"409\":1}}],[\"io会一直block住对应的进程知道操作完成\",{\"1\":{\"409\":1}}],[\"io其实用的很少\",{\"1\":{\"409\":1}}],[\"io给block\",{\"1\":{\"409\":1}}],[\"io只调用了一个system\",{\"1\":{\"409\":1}}],[\"io的web\",{\"1\":{\"409\":1}}],[\"io的图其实并没有太大的不同\",{\"1\":{\"409\":1}}],[\"io的特点是用户进程需要不断地主动询问kernel数据好了没有\",{\"1\":{\"409\":1}}],[\"io的特点就是io执行的两个阶段都会被block\",{\"1\":{\"409\":1}}],[\"io多路复用就是通过一种机制使得一个进程可以监视多个文件描述符\",{\"1\":{\"410\":1}}],[\"io多路复用的特点是通过一种机制使得一个进程能够同时等待多个文件描述符\",{\"1\":{\"409\":1}}],[\"io多路复用\",{\"1\":{\"405\":1,\"409\":1,\"1009\":1}}],[\"io包中很多类进行了改写\",{\"1\":{\"332\":1}}],[\"io包中的reader\",{\"1\":{\"44\":1}}],[\"io包下\",{\"1\":{\"331\":1}}],[\"io编程\",{\"1\":{\"331\":1}}],[\"io密集型\",{\"1\":{\"246\":1}}],[\"ioexception\",{\"1\":{\"44\":2,\"104\":3,\"105\":1,\"123\":4,\"655\":1,\"773\":3,\"776\":3,\"783\":1,\"791\":1,\"792\":1,\"845\":6,\"846\":1,\"857\":1,\"858\":1,\"870\":2,\"872\":7,\"873\":1,\"884\":2,\"886\":1,\"889\":2,\"890\":2,\"893\":2,\"896\":7,\"898\":1,\"907\":2,\"909\":4,\"932\":1}}],[\"io\",{\"0\":{\"798\":1,\"901\":1,\"904\":1},\"1\":{\"3\":1,\"6\":1,\"11\":1,\"13\":1,\"14\":1,\"17\":1,\"18\":1,\"94\":1,\"332\":1,\"409\":7,\"646\":2,\"775\":3,\"776\":1,\"790\":13,\"791\":11,\"792\":7,\"793\":7,\"794\":4,\"796\":8,\"799\":1,\"800\":1,\"812\":5,\"815\":18,\"825\":3,\"830\":1,\"837\":2,\"845\":2,\"878\":2,\"901\":4,\"904\":4,\"905\":1,\"906\":3,\"907\":1,\"1009\":1,\"1023\":1,\"1031\":1,\"1036\":1}}],[\"cp\",{\"1\":{\"1015\":1}}],[\"cpu性能提升了\",{\"1\":{\"976\":1}}],[\"cpu缓存\",{\"1\":{\"976\":1}}],[\"cpu中的内存管理单元就是用于将逻辑地址翻译成物理地址\",{\"1\":{\"414\":1}}],[\"cpu密集型\",{\"1\":{\"246\":1}}],[\"cpu空闲时\",{\"1\":{\"205\":1}}],[\"cpu要分别发出多条i\",{\"1\":{\"181\":1}}],[\"cpu每发出一条i\",{\"1\":{\"181\":1}}],[\"cpu介入频率进一步降低\",{\"1\":{\"181\":1}}],[\"cpu与i\",{\"1\":{\"181\":1}}],[\"cpu不再需要不停的轮询\",{\"1\":{\"181\":1}}],[\"cpu需要一直轮询检查\",{\"1\":{\"181\":1}}],[\"cpu和i\",{\"1\":{\"181\":2}}],[\"cpu干预的频率\",{\"1\":{\"181\":3}}],[\"cpu检查是否越界\",{\"1\":{\"152\":1}}],[\"cpu利用率得到明显的提升\",{\"1\":{\"181\":1}}],[\"cpu利用率低\",{\"1\":{\"181\":1}}],[\"cpu利用率\",{\"1\":{\"138\":1}}],[\"cpu最昂贵的部件\",{\"1\":{\"132\":1}}],[\"cpu都要检查当前是否有外部中断的信号\",{\"1\":{\"129\":1}}],[\"cpu立即进入核心态\",{\"1\":{\"129\":1}}],[\"cpu有两种处理器状态\",{\"1\":{\"128\":1}}],[\"cpu如何判断当前是否可以执行特权指令\",{\"1\":{\"128\":1}}],[\"cpu=\",{\"1\":{\"52\":2}}],[\"cpu\",{\"0\":{\"897\":1},\"1\":{\"52\":17,\"109\":15,\"181\":4,\"246\":6,\"278\":1,\"792\":1,\"805\":1,\"842\":1,\"876\":1,\"877\":1,\"896\":4,\"897\":1,\"904\":5,\"905\":7}}],[\"c则redis停止\",{\"1\":{\"1014\":1}}],[\"cd\",{\"1\":{\"1012\":1,\"1015\":1}}],[\"cdot\",{\"1\":{\"26\":3}}],[\"c++\",{\"1\":{\"754\":1,\"755\":1,\"756\":1}}],[\"c+m\",{\"1\":{\"186\":1}}],[\"ctx\",{\"1\":{\"655\":2,\"657\":2,\"749\":9,\"750\":2,\"753\":4,\"754\":3,\"755\":3,\"756\":3,\"759\":13,\"760\":5,\"761\":12,\"762\":6,\"764\":4,\"767\":10,\"768\":3,\"770\":2,\"771\":3,\"773\":3,\"780\":1,\"784\":2,\"786\":1,\"788\":1,\"790\":7,\"793\":3,\"798\":4,\"816\":28,\"825\":2,\"834\":1,\"844\":5}}],[\"ctl\",{\"1\":{\"410\":1}}],[\"ctl注册fd\",{\"1\":{\"410\":1}}],[\"curl\",{\"1\":{\"646\":2}}],[\"currentproxy\",{\"1\":{\"998\":1}}],[\"currentpage\",{\"1\":{\"950\":4}}],[\"currentchildattrs\",{\"1\":{\"790\":3}}],[\"currentchildoptions\",{\"1\":{\"790\":3}}],[\"currentchildhandler\",{\"1\":{\"790\":2}}],[\"currentchildgroup\",{\"1\":{\"790\":2}}],[\"currenttimenanos\",{\"1\":{\"792\":6}}],[\"currenttimemillis\",{\"1\":{\"441\":16,\"873\":2,\"993\":2}}],[\"currentthread\",{\"1\":{\"206\":2,\"743\":1,\"744\":1,\"791\":1,\"909\":3}}],[\"currenthandvalue\",{\"1\":{\"116\":9}}],[\"current\",{\"1\":{\"105\":3}}],[\"currentruntime\",{\"1\":{\"105\":2}}],[\"c3\",{\"1\":{\"626\":2}}],[\"c3=value3\",{\"1\":{\"268\":1}}],[\"crc16\",{\"1\":{\"435\":1}}],[\"createvoucherorder\",{\"1\":{\"998\":4}}],[\"createuserwithphone\",{\"1\":{\"960\":1,\"968\":1}}],[\"createindex\",{\"1\":{\"950\":1}}],[\"createindexresponse\",{\"1\":{\"933\":1}}],[\"createindexrequest\",{\"1\":{\"933\":2}}],[\"createdirectories\",{\"1\":{\"872\":1}}],[\"createdirectory\",{\"1\":{\"872\":1,\"873\":1}}],[\"createdessert\",{\"1\":{\"74\":3}}],[\"creategroup\",{\"1\":{\"758\":1,\"761\":1}}],[\"createtempdirectory\",{\"1\":{\"655\":1}}],[\"createtree\",{\"1\":{\"283\":2}}],[\"create\",{\"1\":{\"95\":1,\"265\":2,\"512\":1,\"933\":1,\"968\":1}}],[\"createcoffee\",{\"1\":{\"63\":1,\"65\":1,\"69\":4,\"74\":3,\"77\":1}}],[\"createbike\",{\"1\":{\"49\":6}}],[\"cn\",{\"1\":{\"393\":1,\"738\":1,\"783\":1,\"785\":1}}],[\"cnblogs\",{\"1\":{\"324\":1}}],[\"cj\",{\"1\":{\"372\":1}}],[\"cms被标记为deprecate了\",{\"1\":{\"362\":1}}],[\"cms\",{\"0\":{\"362\":1},\"1\":{\"360\":4}}],[\"cms回收停顿了几次\",{\"1\":{\"355\":1}}],[\"cms解决什么问题\",{\"1\":{\"355\":1}}],[\"cms和g1了解么\",{\"1\":{\"355\":1}}],[\"cms特点\",{\"1\":{\"355\":1}}],[\"cms收集器与g1收集器的特点\",{\"1\":{\"355\":1}}],[\"cmu\",{\"1\":{\"5\":1}}],[\"cyclicbarrier\",{\"0\":{\"263\":1},\"1\":{\"263\":4}}],[\"cycle\",{\"1\":{\"3\":1,\"500\":5}}],[\"cyclegan在照片转莫奈油画\",{\"1\":{\"3\":1}}],[\"cyclegan是image\",{\"1\":{\"3\":1}}],[\"cyclegan照片转梵高莫奈油画\",{\"1\":{\"3\":1}}],[\"cyclegan\",{\"0\":{\"2\":1,\"15\":1},\"1\":{\"3\":1,\"7\":1,\"17\":1}}],[\"center\",{\"1\":{\"441\":8}}],[\"cellsbusy\",{\"1\":{\"234\":1}}],[\"cells\",{\"1\":{\"234\":1}}],[\"cell\",{\"1\":{\"234\":3}}],[\"ceil都会生成3个anchor\",{\"1\":{\"24\":1}}],[\"ceil对应更大的感受野\",{\"1\":{\"24\":1}}],[\"c−v\",{\"1\":{\"194\":1}}],[\"check来解决这样的问题\",{\"1\":{\"987\":1}}],[\"check\",{\"1\":{\"825\":1}}],[\"checkdeadlock\",{\"1\":{\"815\":2}}],[\"checknotnull\",{\"1\":{\"799\":1}}],[\"checkresolve\",{\"1\":{\"104\":1}}],[\"ch\",{\"1\":{\"749\":5,\"753\":3,\"754\":4,\"755\":4,\"756\":4,\"759\":10,\"764\":4,\"767\":3,\"768\":5,\"783\":10,\"785\":5,\"787\":5,\"790\":4,\"792\":3,\"798\":6,\"803\":8,\"804\":3,\"816\":6,\"834\":3,\"835\":2,\"844\":5,\"886\":1}}],[\"child\",{\"1\":{\"793\":7}}],[\"childattrs\",{\"1\":{\"790\":2,\"793\":1}}],[\"childoptions\",{\"1\":{\"790\":2,\"793\":1}}],[\"childgroup\",{\"1\":{\"790\":1,\"793\":1}}],[\"childhandler\",{\"1\":{\"749\":1,\"759\":1,\"768\":1,\"783\":1,\"790\":1,\"793\":2,\"798\":2,\"816\":1,\"834\":2,\"844\":1}}],[\"chinese\",{\"1\":{\"450\":1,\"744\":2}}],[\"chatresponsemessage\",{\"1\":{\"760\":2,\"773\":3}}],[\"chatrequestmessagehandler\",{\"1\":{\"760\":1}}],[\"chatrequestmessage\",{\"1\":{\"759\":1,\"760\":1,\"773\":3}}],[\"chatclient\",{\"1\":{\"759\":1}}],[\"chatserver\",{\"1\":{\"759\":1}}],[\"channeldemo7\",{\"1\":{\"896\":1}}],[\"channeldemo6\",{\"1\":{\"884\":1,\"886\":7}}],[\"channeldemo1\",{\"1\":{\"846\":18}}],[\"channelduplexhandler\",{\"1\":{\"764\":4}}],[\"channeloutboundhandleradapter\",{\"1\":{\"816\":5}}],[\"channeloption\",{\"1\":{\"750\":2,\"775\":1,\"776\":1,\"790\":1}}],[\"channelconfig\",{\"1\":{\"793\":1,\"794\":1}}],[\"channelpipeline\",{\"1\":{\"790\":3,\"793\":1,\"794\":1,\"816\":2}}],[\"channelpromise\",{\"1\":{\"775\":2,\"790\":5,\"793\":2,\"816\":3}}],[\"channelfactory\",{\"1\":{\"790\":1}}],[\"channelfuturelistener\",{\"1\":{\"790\":2,\"793\":1,\"803\":2,\"804\":1,\"816\":1}}],[\"channelfuture\",{\"0\":{\"803\":1},\"1\":{\"749\":9,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"767\":3,\"768\":3,\"775\":1,\"785\":1,\"790\":6,\"793\":1,\"803\":15,\"804\":5}}],[\"channels\",{\"1\":{\"761\":4,\"876\":3,\"877\":3,\"886\":2}}],[\"channelhandler\",{\"1\":{\"760\":2,\"761\":5,\"762\":1,\"771\":1,\"784\":1,\"786\":1,\"788\":1,\"790\":2,\"816\":4,\"825\":3}}],[\"channelhandlercontext\",{\"1\":{\"749\":3,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":3,\"760\":2,\"761\":5,\"762\":2,\"764\":2,\"767\":4,\"768\":2,\"770\":2,\"771\":2,\"773\":2,\"784\":1,\"786\":1,\"788\":1,\"790\":3,\"793\":3,\"798\":3,\"816\":7,\"834\":1,\"844\":2}}],[\"channelread\",{\"1\":{\"759\":1,\"767\":1,\"768\":1,\"793\":3,\"798\":3,\"816\":7,\"844\":2}}],[\"channelread0\",{\"1\":{\"759\":1,\"760\":2,\"761\":5,\"768\":1,\"784\":1,\"786\":1,\"788\":1,\"834\":1}}],[\"channelactive\",{\"1\":{\"749\":3,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":1,\"767\":1,\"790\":2,\"793\":2}}],[\"channelinitializer<niosocketchannel>\",{\"1\":{\"798\":3,\"804\":1,\"816\":1,\"834\":1,\"844\":2}}],[\"channelinitializer<channel>\",{\"1\":{\"790\":1,\"803\":4,\"816\":1,\"835\":1}}],[\"channelinitializer<socketchannel>\",{\"1\":{\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"783\":2,\"785\":1,\"787\":1}}],[\"channelinitializer\",{\"1\":{\"790\":2,\"834\":1,\"835\":1}}],[\"channelinactive\",{\"1\":{\"749\":2,\"762\":1}}],[\"channelinboundhandleradapter\",{\"1\":{\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"767\":1,\"768\":1,\"798\":3,\"816\":5,\"844\":2}}],[\"channel读取或者写入数据必须通过buffer\",{\"1\":{\"332\":1}}],[\"channel\",{\"0\":{\"802\":1,\"870\":1,\"881\":1,\"882\":1,\"900\":1,\"911\":1},\"1\":{\"332\":2,\"749\":8,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"758\":22,\"759\":12,\"760\":5,\"761\":6,\"762\":4,\"764\":2,\"767\":3,\"768\":2,\"770\":4,\"775\":3,\"776\":1,\"783\":10,\"785\":6,\"787\":15,\"790\":38,\"791\":2,\"792\":5,\"793\":12,\"794\":2,\"796\":8,\"798\":11,\"799\":1,\"802\":5,\"803\":21,\"804\":8,\"805\":1,\"812\":1,\"815\":2,\"816\":12,\"825\":2,\"834\":1,\"835\":4,\"837\":4,\"844\":8,\"846\":2,\"847\":1,\"852\":2,\"853\":2,\"857\":2,\"858\":4,\"863\":2,\"864\":2,\"865\":3,\"866\":2,\"867\":2,\"876\":4,\"877\":5,\"878\":3,\"879\":1,\"881\":3,\"882\":1,\"883\":1,\"884\":6,\"886\":7,\"888\":1,\"890\":8,\"891\":3,\"893\":7,\"894\":1,\"896\":2,\"898\":5,\"900\":3,\"901\":1,\"905\":1,\"911\":5,\"917\":5}}],[\"charsequence\",{\"1\":{\"822\":1}}],[\"charset\",{\"1\":{\"767\":1,\"798\":2,\"816\":1,\"822\":2,\"844\":2,\"855\":1,\"890\":3,\"893\":1,\"909\":2}}],[\"charset=utf\",{\"1\":{\"622\":1,\"668\":1}}],[\"charbuffer\",{\"1\":{\"332\":1,\"855\":1,\"911\":1}}],[\"characterencoding=utf\",{\"1\":{\"372\":1}}],[\"characterstream\",{\"1\":{\"339\":2}}],[\"character创建了数值在\",{\"1\":{\"320\":1}}],[\"character\",{\"1\":{\"267\":1,\"339\":1}}],[\"char\",{\"1\":{\"44\":1,\"236\":2,\"275\":3,\"276\":5,\"277\":11,\"282\":3,\"749\":1,\"754\":1,\"755\":1,\"756\":1,\"822\":1,\"846\":1,\"849\":7}}],[\"cho\",{\"1\":{\"116\":2}}],[\"cglib在创建代理对象时所花费的时间比jdk动态代理多很多\",{\"1\":{\"718\":1}}],[\"cglib创建的代理对象比jdk动态代理创建的代理对象高很多\",{\"1\":{\"718\":1}}],[\"cglibproxydemo\",{\"1\":{\"512\":1}}],[\"cglib\",{\"0\":{\"512\":1,\"520\":1,\"521\":1,\"524\":1,\"525\":1,\"528\":1},\"1\":{\"513\":2,\"531\":1,\"686\":1}}],[\"cglib不能对声明为final的类或者方法进行代理\",{\"1\":{\"96\":1}}],[\"cglib底层采用asm字节码生成框架\",{\"1\":{\"96\":1}}],[\"cglib是第三方提供的包\",{\"1\":{\"95\":1}}],[\"cglib是一个功能强大\",{\"1\":{\"95\":1}}],[\"cglib动态代理方式\",{\"1\":{\"95\":1}}],[\"cglib动态代理\",{\"0\":{\"95\":1}}],[\"c2=value2\",{\"1\":{\"268\":1}}],[\"c2\",{\"1\":{\"87\":3,\"89\":6}}],[\"c1=value1\",{\"1\":{\"268\":1}}],[\"c1\",{\"1\":{\"87\":4,\"89\":8}}],[\"cin\",{\"1\":{\"283\":2}}],[\"citation类和student类必须实现serializable接口\",{\"1\":{\"89\":1}}],[\"citationtest1\",{\"1\":{\"89\":1}}],[\"citationtest\",{\"1\":{\"87\":1,\"89\":1}}],[\"citation\",{\"1\":{\"87\":6,\"89\":11}}],[\"circle\",{\"1\":{\"58\":5}}],[\"category\",{\"1\":{\"950\":2}}],[\"catch\",{\"1\":{\"77\":1,\"82\":2,\"94\":10,\"123\":1,\"206\":1,\"221\":2,\"224\":2,\"225\":4,\"263\":4,\"515\":5,\"743\":1,\"744\":1,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":3,\"767\":1,\"768\":1,\"773\":3,\"775\":1,\"776\":1,\"783\":3,\"784\":1,\"785\":1,\"787\":1,\"790\":5,\"791\":4,\"792\":2,\"793\":4,\"794\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":3,\"845\":4,\"846\":1,\"857\":1,\"858\":1,\"870\":2,\"873\":1,\"884\":2,\"886\":1,\"890\":1,\"896\":4,\"898\":2,\"907\":1,\"909\":3,\"932\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"caused\",{\"1\":{\"812\":1}}],[\"cause\",{\"1\":{\"762\":2,\"775\":2,\"785\":3,\"787\":1,\"790\":9,\"793\":1,\"806\":1,\"813\":1,\"814\":1}}],[\"cancelledkeyexception\",{\"1\":{\"792\":2}}],[\"cancelledkeys\",{\"1\":{\"791\":1}}],[\"cancel\",{\"0\":{\"888\":1},\"1\":{\"742\":1,\"743\":2,\"744\":3,\"806\":1,\"885\":1,\"886\":1,\"888\":1,\"890\":2,\"896\":2}}],[\"caching\",{\"1\":{\"981\":1}}],[\"cachingresourceresolver\",{\"1\":{\"638\":1}}],[\"cachingmetadatareaderfactory\",{\"1\":{\"480\":1}}],[\"cacheclient\",{\"1\":{\"990\":5}}],[\"cachecode\",{\"1\":{\"960\":3,\"968\":3}}],[\"cachebuilder\",{\"1\":{\"974\":1}}],[\"cache<k\",{\"1\":{\"974\":1}}],[\"cache1\",{\"1\":{\"638\":1}}],[\"cache\",{\"1\":{\"408\":1,\"974\":2,\"981\":1,\"983\":4,\"985\":5,\"988\":5,\"989\":4,\"990\":8}}],[\"capacity\",{\"1\":{\"249\":2,\"328\":3,\"332\":1,\"818\":3,\"822\":2,\"823\":4,\"824\":3,\"826\":1,\"827\":1,\"848\":1,\"849\":5,\"890\":1}}],[\"cap\",{\"1\":{\"249\":2}}],[\"calculatestrategy\",{\"1\":{\"791\":2}}],[\"callable<integer>\",{\"1\":{\"807\":1,\"808\":1}}],[\"called\",{\"1\":{\"790\":1,\"793\":1}}],[\"callerrunspolicy调用者运行策略\",{\"1\":{\"243\":1}}],[\"callsuper\",{\"1\":{\"783\":2}}],[\"callback\",{\"1\":{\"523\":1}}],[\"call\",{\"1\":{\"409\":3,\"807\":1,\"808\":1,\"815\":2}}],[\"calendar类中的getinstance\",{\"1\":{\"78\":1}}],[\"cassandra\",{\"1\":{\"841\":1}}],[\"castor\",{\"1\":{\"705\":1}}],[\"castabat\",{\"1\":{\"249\":1}}],[\"cas是乐观锁的一种实现方式\",{\"1\":{\"352\":1}}],[\"cas是基于乐观锁的思想~~\",{\"1\":{\"231\":1}}],[\"cas\",{\"1\":{\"234\":1,\"261\":1,\"397\":1}}],[\"cas体现的是无锁并发\",{\"1\":{\"231\":1}}],[\"cas的特点\",{\"0\":{\"231\":1}}],[\"case\",{\"1\":{\"104\":1,\"759\":7,\"791\":3}}],[\"caixin\",{\"1\":{\"120\":5}}],[\"card\",{\"1\":{\"41\":8,\"42\":2}}],[\"cbuf\",{\"1\":{\"44\":2}}],[\"cli连接redis服务\",{\"1\":{\"1021\":1}}],[\"cli的交互控制台\",{\"1\":{\"1018\":1}}],[\"cli来执行\",{\"1\":{\"1015\":1}}],[\"cli\",{\"1\":{\"1012\":1,\"1015\":1,\"1018\":2}}],[\"client<\",{\"1\":{\"931\":2}}],[\"clients<\",{\"1\":{\"1032\":1}}],[\"clients\",{\"1\":{\"839\":1,\"1031\":1}}],[\"client\",{\"1\":{\"41\":1,\"42\":1,\"49\":1,\"52\":2,\"93\":1,\"94\":2,\"95\":1,\"108\":1,\"120\":1,\"515\":1,\"749\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"776\":5,\"783\":1,\"785\":1,\"787\":1,\"844\":1,\"884\":1,\"889\":1,\"898\":1,\"933\":6,\"934\":8,\"936\":2,\"937\":2,\"938\":2,\"939\":2,\"940\":2,\"941\":2,\"942\":2,\"943\":2,\"944\":2,\"945\":2,\"946\":2}}],[\"clearreadpending\",{\"1\":{\"794\":1}}],[\"clear\",{\"1\":{\"793\":1,\"846\":1,\"847\":1,\"848\":1,\"876\":1,\"877\":1,\"893\":1,\"909\":1}}],[\"cluster默认会对key使用crc16算法进行hash得到一个整数值\",{\"1\":{\"435\":1}}],[\"cluster的客户端来连接集群时\",{\"1\":{\"435\":1}}],[\"cluster将所有数据划分为16384个槽位\",{\"1\":{\"435\":1}}],[\"cluster架构下\",{\"1\":{\"434\":1}}],[\"clock\",{\"1\":{\"163\":2}}],[\"closechannel\",{\"1\":{\"909\":4}}],[\"closeonread\",{\"1\":{\"794\":1}}],[\"closeonreaderror\",{\"1\":{\"793\":1}}],[\"closed\",{\"1\":{\"793\":4}}],[\"closeall\",{\"1\":{\"791\":1}}],[\"closeable\",{\"1\":{\"123\":1}}],[\"closeifclosed\",{\"1\":{\"790\":1}}],[\"closeforcibly\",{\"1\":{\"790\":2,\"793\":2}}],[\"closefutureclient\",{\"1\":{\"804\":1}}],[\"closefuture\",{\"0\":{\"804\":1},\"1\":{\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":2,\"767\":1,\"768\":1,\"775\":1,\"783\":2,\"785\":1,\"787\":1,\"790\":2,\"793\":2,\"802\":1,\"804\":5,\"844\":1}}],[\"close\",{\"1\":{\"89\":1,\"743\":1,\"744\":1,\"753\":1,\"759\":2,\"764\":1,\"775\":1,\"790\":2,\"792\":1,\"793\":1,\"794\":5,\"802\":1,\"804\":2,\"844\":1,\"866\":2,\"883\":1,\"886\":1,\"889\":1,\"896\":2,\"909\":2,\"932\":4,\"933\":3,\"934\":4,\"936\":1,\"937\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"1032\":1,\"1035\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"86\":2,\"87\":2,\"89\":2}}],[\"cloneable\",{\"1\":{\"86\":2,\"87\":1,\"89\":1}}],[\"clone\",{\"1\":{\"85\":3,\"86\":4,\"87\":3,\"89\":3}}],[\"clazz\",{\"1\":{\"77\":2,\"103\":2,\"773\":4}}],[\"classutils\",{\"1\":{\"672\":1}}],[\"classpath\",{\"1\":{\"641\":1}}],[\"classpathresource\",{\"1\":{\"635\":2,\"638\":1}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"451\":1}}],[\"classmetadata\",{\"1\":{\"480\":1}}],[\"class文件\",{\"1\":{\"352\":1}}],[\"class的newinstance\",{\"1\":{\"351\":1}}],[\"classnotfoundexception\",{\"1\":{\"94\":3,\"104\":1,\"773\":1,\"783\":1}}],[\"classname\",{\"1\":{\"77\":2}}],[\"class<r>\",{\"1\":{\"990\":3}}],[\"class<t>\",{\"1\":{\"773\":3,\"783\":1,\"787\":1}}],[\"class<\",{\"1\":{\"94\":1,\"711\":1,\"731\":1,\"773\":3,\"783\":4,\"787\":1}}],[\"classloader\",{\"1\":{\"94\":1,\"787\":1}}],[\"class\",{\"0\":{\"722\":1},\"1\":{\"41\":5,\"42\":2,\"49\":7,\"52\":5,\"57\":5,\"58\":4,\"63\":1,\"65\":1,\"69\":5,\"74\":2,\"77\":4,\"78\":1,\"82\":5,\"86\":2,\"87\":2,\"89\":4,\"93\":3,\"94\":18,\"95\":3,\"101\":10,\"103\":8,\"104\":4,\"105\":4,\"108\":4,\"109\":6,\"110\":2,\"111\":4,\"116\":5,\"119\":2,\"120\":4,\"123\":1,\"191\":1,\"194\":2,\"195\":2,\"206\":2,\"224\":3,\"225\":3,\"235\":1,\"237\":1,\"249\":5,\"282\":2,\"285\":1,\"287\":1,\"336\":1,\"339\":1,\"346\":1,\"366\":1,\"368\":1,\"372\":3,\"441\":1,\"450\":2,\"463\":2,\"491\":2,\"496\":1,\"500\":7,\"503\":1,\"504\":1,\"506\":1,\"508\":1,\"510\":5,\"512\":3,\"515\":5,\"523\":1,\"635\":1,\"647\":1,\"657\":1,\"660\":1,\"670\":6,\"672\":4,\"682\":1,\"711\":1,\"722\":1,\"731\":5,\"732\":2,\"743\":1,\"744\":2,\"749\":6,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"759\":4,\"760\":2,\"761\":5,\"762\":1,\"767\":1,\"768\":1,\"770\":1,\"771\":1,\"773\":21,\"775\":2,\"776\":3,\"783\":15,\"784\":2,\"785\":5,\"786\":1,\"787\":4,\"788\":1,\"798\":3,\"803\":4,\"804\":2,\"816\":4,\"826\":1,\"830\":1,\"834\":1,\"835\":1,\"844\":2,\"845\":2,\"846\":1,\"849\":1,\"855\":1,\"870\":1,\"884\":2,\"886\":1,\"889\":2,\"893\":2,\"896\":3,\"898\":2,\"907\":1,\"909\":4,\"932\":2,\"934\":1,\"949\":1,\"950\":3,\"961\":2,\"962\":2,\"968\":1,\"972\":2,\"983\":1,\"985\":1,\"988\":1,\"989\":3,\"990\":4,\"993\":1,\"1034\":1,\"1040\":1,\"1041\":1,\"1042\":2,\"1043\":1}}],[\"cvpods\",{\"1\":{\"32\":3}}],[\"cvpr\",{\"1\":{\"16\":1}}],[\"c\",{\"0\":{\"276\":1},\"1\":{\"26\":4,\"89\":2,\"103\":2,\"123\":6,\"133\":1,\"148\":1,\"176\":2,\"178\":1,\"186\":1,\"194\":5,\"195\":9,\"266\":2,\"275\":3,\"276\":11,\"277\":5,\"282\":10,\"339\":2,\"655\":1,\"657\":1,\"749\":5,\"750\":5,\"754\":18,\"755\":16,\"756\":18,\"790\":1,\"796\":1,\"798\":18,\"800\":2,\"801\":5,\"810\":4,\"811\":3,\"812\":3,\"813\":4,\"814\":3,\"822\":2,\"823\":1,\"824\":3,\"826\":8,\"829\":4,\"830\":2,\"846\":18,\"849\":1,\"855\":2,\"857\":7,\"858\":2,\"872\":2,\"884\":2,\"886\":10,\"896\":2,\"898\":1,\"907\":4,\"1029\":2}}],[\"cccccc\",{\"1\":{\"756\":1}}],[\"ccc\",{\"1\":{\"339\":1,\"755\":1}}],[\"cc\",{\"1\":{\"10\":2,\"386\":9}}],[\"cst\",{\"1\":{\"776\":4}}],[\"csdn博客\",{\"1\":{\"324\":1}}],[\"csdn\",{\"1\":{\"31\":4,\"213\":1,\"214\":1,\"215\":1,\"219\":1}}],[\"cs\",{\"1\":{\"5\":1,\"44\":1}}],[\"code\",{\"1\":{\"960\":7,\"961\":1,\"968\":3}}],[\"codec\",{\"1\":{\"759\":4,\"783\":4,\"785\":2,\"787\":2}}],[\"coder\",{\"1\":{\"731\":1}}],[\"code>\",{\"1\":{\"105\":2}}],[\"core<\",{\"1\":{\"931\":2,\"1038\":1}}],[\"core\",{\"1\":{\"705\":1,\"776\":1}}],[\"corepoolsize\",{\"1\":{\"242\":3}}],[\"copyoptions\",{\"1\":{\"968\":1}}],[\"copyonwrite并发容器适用于对于绝大部分访问都是读\",{\"1\":{\"248\":1}}],[\"copyonwritearraylist是java\",{\"1\":{\"248\":1}}],[\"copyonwritearraylist\",{\"0\":{\"248\":1}}],[\"copyproperties\",{\"1\":{\"962\":1,\"968\":1}}],[\"copy\",{\"0\":{\"828\":1},\"1\":{\"236\":1,\"872\":2,\"873\":1}}],[\"course\",{\"1\":{\"383\":2}}],[\"coucurrenthashmap和hashmap的实现方式都是一样的\",{\"1\":{\"249\":1}}],[\"cout\",{\"1\":{\"192\":1,\"283\":3}}],[\"countdown\",{\"1\":{\"759\":1,\"993\":2}}],[\"countdownlatch名为信号枪\",{\"1\":{\"993\":1}}],[\"countdownlatch要想恢复设定值只能重新创建新的countdownlatch对象\",{\"1\":{\"263\":1}}],[\"countdownlatch就不如future了\",{\"1\":{\"262\":1}}],[\"countdownlatch\",{\"0\":{\"262\":1},\"1\":{\"262\":1,\"759\":2,\"993\":4}}],[\"countdownlatch都继承了该抽象类\",{\"1\":{\"251\":1}}],[\"count变量\",{\"1\":{\"387\":1}}],[\"count的值\",{\"1\":{\"387\":1}}],[\"count++\",{\"1\":{\"282\":1}}],[\"count表示以当前单词结尾的单词数量\",{\"1\":{\"282\":1}}],[\"countercells初始有两个cell\",{\"1\":{\"249\":1}}],[\"counter++\",{\"1\":{\"211\":1}}],[\"counter\",{\"1\":{\"211\":1,\"219\":1}}],[\"count\",{\"0\":{\"387\":2},\"1\":{\"82\":2,\"262\":4,\"266\":1,\"267\":6,\"282\":4,\"341\":1,\"383\":2,\"387\":2,\"882\":3,\"884\":5,\"886\":9,\"893\":3,\"993\":4,\"998\":9}}],[\"cos\",{\"1\":{\"169\":1}}],[\"cookie等\",{\"1\":{\"736\":1}}],[\"cookievalue\",{\"1\":{\"568\":2}}],[\"cookie会被自动发送给服务器端\",{\"1\":{\"296\":1}}],[\"cookprocess\",{\"1\":{\"120\":3}}],[\"coord\",{\"1\":{\"26\":1}}],[\"coffe\",{\"1\":{\"65\":1}}],[\"coffee>\",{\"1\":{\"77\":1}}],[\"coffeefactory\",{\"1\":{\"69\":5,\"77\":2}}],[\"coffeestore对象和simplecoffeefactory工厂对象的耦合\",{\"1\":{\"63\":1}}],[\"coffeestore类中的ordercoffee\",{\"1\":{\"63\":1}}],[\"coffeestore\",{\"1\":{\"60\":1,\"69\":2}}],[\"coffee\",{\"1\":{\"60\":1,\"63\":6,\"65\":5,\"69\":12,\"74\":3,\"77\":3}}],[\"coco目标检测数据集80个类别\",{\"0\":{\"33\":1}}],[\"column是分步查询的条件\",{\"1\":{\"366\":1}}],[\"column=\",{\"1\":{\"366\":7}}],[\"collect1\",{\"1\":{\"343\":2}}],[\"collectors\",{\"1\":{\"342\":1,\"343\":4}}],[\"collect\",{\"1\":{\"342\":1,\"343\":6}}],[\"collectionutils\",{\"1\":{\"368\":1}}],[\"collections\",{\"1\":{\"336\":1,\"655\":1,\"657\":1}}],[\"collection接口是抽象工厂类\",{\"1\":{\"78\":1}}],[\"collection\",{\"0\":{\"78\":1},\"1\":{\"324\":1,\"688\":1,\"695\":2}}],[\"col2\",{\"1\":{\"267\":1}}],[\"col1\",{\"1\":{\"267\":1}}],[\"col\",{\"1\":{\"267\":3}}],[\"colab\",{\"1\":{\"19\":1}}],[\"color=\",{\"1\":{\"944\":1}}],[\"colormind\",{\"1\":{\"18\":1}}],[\"colorizer\",{\"1\":{\"11\":1}}],[\"conf\",{\"1\":{\"1015\":4,\"1016\":1}}],[\"conf文件中的一些配置\",{\"1\":{\"1015\":1}}],[\"conf文件\",{\"1\":{\"999\":1}}],[\"confirmshutdown\",{\"1\":{\"791\":1}}],[\"configureblocking\",{\"1\":{\"790\":1,\"793\":1,\"877\":2,\"881\":1,\"884\":1,\"886\":2,\"890\":2,\"893\":3,\"896\":2}}],[\"configurablewebbindinginitializer\",{\"1\":{\"582\":1}}],[\"configuration>\",{\"1\":{\"1038\":1}}],[\"configuration注解声明配置类更加语义化\",{\"1\":{\"731\":1}}],[\"configuration的不同语义的版本\",{\"1\":{\"731\":1}}],[\"configurationpropertysources\",{\"1\":{\"650\":1,\"652\":1}}],[\"configurationproperties读取配置信息并于bean绑定\",{\"1\":{\"731\":1}}],[\"configurationpropertiesbindingpostprocessor\",{\"1\":{\"470\":1}}],[\"configurationproperties\",{\"1\":{\"460\":1,\"470\":1,\"711\":1,\"731\":2,\"949\":1}}],[\"configurationclasspostprocessor\",{\"1\":{\"476\":1}}],[\"configuration\",{\"1\":{\"366\":2,\"368\":1,\"491\":1,\"670\":3,\"672\":1,\"731\":1,\"825\":1,\"949\":1,\"961\":1,\"1041\":1}}],[\"config\",{\"1\":{\"77\":2,\"265\":2,\"670\":1,\"773\":4,\"775\":1,\"783\":1,\"790\":7,\"793\":5,\"794\":7}}],[\"conneted\",{\"1\":{\"753\":1}}],[\"connetted\",{\"1\":{\"749\":1,\"754\":2,\"755\":2,\"756\":2}}],[\"connecting\",{\"1\":{\"776\":5,\"876\":1}}],[\"connectionfactory\",{\"1\":{\"1041\":2}}],[\"connection\",{\"1\":{\"775\":1}}],[\"connectpromise\",{\"1\":{\"775\":4}}],[\"connecttimeoutexception\",{\"1\":{\"775\":2}}],[\"connecttimeoutfuture\",{\"1\":{\"775\":1}}],[\"connecttimeoutmillis\",{\"1\":{\"775\":3}}],[\"connect\",{\"0\":{\"775\":1},\"1\":{\"749\":1,\"753\":1,\"754\":2,\"755\":2,\"756\":2,\"759\":1,\"767\":1,\"775\":5,\"776\":2,\"783\":1,\"785\":1,\"787\":1,\"792\":2,\"798\":1,\"803\":5,\"804\":1,\"816\":1,\"835\":3,\"844\":1,\"876\":1,\"881\":1,\"890\":1,\"893\":2}}],[\"connected\",{\"1\":{\"749\":2,\"750\":1,\"754\":1,\"755\":1,\"756\":1,\"776\":2,\"876\":1,\"877\":1,\"886\":2,\"896\":1,\"909\":1}}],[\"connector\",{\"1\":{\"655\":5}}],[\"conversion\",{\"1\":{\"849\":2}}],[\"conversionservice\",{\"1\":{\"576\":1,\"582\":3}}],[\"converters\",{\"1\":{\"574\":1}}],[\"converter\",{\"1\":{\"574\":2}}],[\"concat\",{\"1\":{\"366\":1}}],[\"concurrencylevel\",{\"1\":{\"249\":4}}],[\"concurrentlinkedqueue<>\",{\"1\":{\"896\":1}}],[\"concurrentlinkedqueue<runnable>\",{\"1\":{\"896\":1}}],[\"concurrentmapcache\",{\"1\":{\"638\":1}}],[\"concurrent\",{\"1\":{\"360\":1,\"361\":1,\"791\":2,\"806\":1,\"812\":4,\"815\":14}}],[\"concurrenthashmap<k\",{\"1\":{\"974\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"783\":1,\"788\":1,\"974\":1}}],[\"concurrenthashmap的线程安全是基于segment加锁的基础上\",{\"1\":{\"249\":1}}],[\"concurrenthashmap和hashmap都是基于数组和链表实现的\",{\"1\":{\"249\":1}}],[\"concurrenthashmap\",{\"0\":{\"249\":1},\"1\":{\"249\":1}}],[\"concurrent包提供的方法\",{\"1\":{\"248\":1}}],[\"concreteclass\",{\"1\":{\"120\":6}}],[\"concretestrategy角色负责实现strategy角色的接口\",{\"1\":{\"115\":1}}],[\"concretestrategy\",{\"1\":{\"115\":1}}],[\"concretesubject角色表示具体的被观察对象\",{\"1\":{\"81\":1}}],[\"concretesubject\",{\"1\":{\"81\":1,\"82\":1}}],[\"concreteobserver角色表示具体的observer\",{\"1\":{\"81\":1}}],[\"concreteobserver\",{\"1\":{\"81\":1,\"82\":2}}],[\"concrete\",{\"1\":{\"73\":1,\"119\":2}}],[\"concreteproduct\",{\"1\":{\"68\":1,\"73\":1}}],[\"concretefactory\",{\"1\":{\"68\":1}}],[\"concretebuilder\",{\"1\":{\"48\":1}}],[\"conditiaononmissingbean\",{\"1\":{\"731\":1}}],[\"conditioncontext\",{\"1\":{\"672\":1}}],[\"condition典型的运用场景是在blockingqueue中的实现\",{\"1\":{\"254\":1}}],[\"conditionobject中也维护了一个队列\",{\"1\":{\"254\":1}}],[\"condition队列\",{\"0\":{\"254\":1}}],[\"condition1\",{\"1\":{\"224\":3}}],[\"condition\",{\"1\":{\"224\":1,\"225\":6,\"385\":1,\"672\":3}}],[\"conditionalonbean\",{\"1\":{\"731\":1}}],[\"conditional衍生注解\",{\"1\":{\"731\":1}}],[\"conditional注解是由spring\",{\"1\":{\"731\":1}}],[\"conditional指定的生效条件\",{\"1\":{\"730\":1}}],[\"conditional\",{\"1\":{\"16\":1,\"672\":3,\"731\":1}}],[\"cond\",{\"1\":{\"219\":1}}],[\"continuereading\",{\"1\":{\"793\":1,\"794\":3}}],[\"continue\",{\"1\":{\"791\":3,\"884\":1,\"886\":1}}],[\"content\",{\"1\":{\"759\":2,\"768\":2}}],[\"contextannotationautowirecandidateresolver\",{\"1\":{\"470\":1,\"691\":1,\"695\":2}}],[\"context角色保存了concretestrategy角色的实例\",{\"1\":{\"115\":1}}],[\"context\",{\"1\":{\"115\":1,\"450\":6,\"500\":1,\"635\":2,\"641\":3,\"650\":1,\"655\":4,\"657\":1,\"672\":1,\"679\":1,\"790\":1}}],[\"controller执行完成后返回modelandview\",{\"1\":{\"736\":1}}],[\"controller代表的是数据的处理逻辑\",{\"1\":{\"734\":1}}],[\"controller中进行测试\",{\"1\":{\"732\":1}}],[\"controller和\",{\"1\":{\"731\":1}}],[\"controller用于声明视图层的控制器bean\",{\"1\":{\"709\":1}}],[\"controller用于类上声明bean\",{\"1\":{\"709\":1}}],[\"controller3\",{\"1\":{\"626\":1}}],[\"controller\",{\"1\":{\"590\":2,\"617\":1,\"626\":1,\"627\":1,\"643\":1,\"647\":1,\"653\":1,\"734\":1,\"736\":1}}],[\"controlleradvice开启全局异常处理\",{\"1\":{\"732\":1}}],[\"controlleradvice\",{\"0\":{\"586\":1,\"593\":1,\"605\":1,\"613\":1},\"1\":{\"588\":2,\"596\":2,\"616\":1,\"644\":5,\"732\":1}}],[\"containskey\",{\"1\":{\"285\":1}}],[\"contains\",{\"1\":{\"104\":1}}],[\"consumer<\",{\"1\":{\"336\":1}}],[\"consts\",{\"1\":{\"266\":1}}],[\"const\",{\"1\":{\"192\":1,\"276\":1}}],[\"constructor的newinstance\",{\"1\":{\"351\":1}}],[\"constructor\",{\"1\":{\"103\":5}}],[\"construct\",{\"1\":{\"49\":3}}],[\"consistency自监督损失函数\",{\"1\":{\"3\":1}}],[\"consistent\",{\"1\":{\"3\":1}}],[\"combinedchannelduplexhandler\",{\"1\":{\"771\":1}}],[\"commons<\",{\"1\":{\"1038\":1}}],[\"common\",{\"1\":{\"1038\":1}}],[\"commonds\",{\"1\":{\"1018\":1}}],[\"commonannotationbeanpostprocessor\",{\"1\":{\"470\":1}}],[\"commands\",{\"1\":{\"1023\":1}}],[\"command\",{\"1\":{\"759\":2,\"1024\":1}}],[\"commandlinerunner\",{\"1\":{\"652\":1}}],[\"commit所释放的资源\",{\"1\":{\"389\":1}}],[\"come\",{\"1\":{\"139\":1}}],[\"completionhandler<asynchronoussocketchannel\",{\"1\":{\"909\":1}}],[\"completionhandler<integer\",{\"1\":{\"907\":1,\"909\":2}}],[\"completed\",{\"1\":{\"756\":1,\"907\":3,\"909\":3}}],[\"complete\",{\"1\":{\"749\":1,\"750\":2,\"754\":1,\"755\":1,\"794\":2,\"798\":6}}],[\"compositebuffer\",{\"1\":{\"829\":1}}],[\"compositebytebuf\",{\"0\":{\"829\":1},\"1\":{\"829\":2,\"830\":2,\"831\":1}}],[\"component注解替代\",{\"1\":{\"731\":1}}],[\"component注解修饰的bean\",{\"1\":{\"731\":1}}],[\"component注解的自定义性更强\",{\"1\":{\"713\":1}}],[\"component注解作用于类\",{\"1\":{\"713\":1}}],[\"component和\",{\"0\":{\"713\":1}}],[\"component用于声明通用的bean\",{\"1\":{\"709\":1}}],[\"components\",{\"1\":{\"682\":2}}],[\"componentscan注解的集合\",{\"1\":{\"731\":1}}],[\"componentscanpostprocessor\",{\"1\":{\"479\":1}}],[\"componentscan\",{\"0\":{\"478\":1},\"1\":{\"454\":1,\"476\":1,\"477\":1,\"709\":1,\"713\":1,\"731\":1}}],[\"component\",{\"1\":{\"500\":3,\"682\":2,\"695\":1,\"709\":1,\"711\":1,\"731\":1,\"829\":2,\"990\":1,\"993\":1}}],[\"compile\",{\"1\":{\"506\":1}}],[\"compact\",{\"1\":{\"847\":1,\"848\":1,\"859\":1,\"890\":1}}],[\"comparingdouble\",{\"1\":{\"343\":1}}],[\"comparingint\",{\"1\":{\"340\":1,\"341\":1}}],[\"compareandswapint\",{\"1\":{\"996\":1}}],[\"compareandset\",{\"1\":{\"791\":1,\"792\":2}}],[\"compare\",{\"1\":{\"336\":1,\"343\":1}}],[\"compareto\",{\"1\":{\"336\":1}}],[\"comparator\",{\"1\":{\"340\":2,\"341\":1,\"343\":1}}],[\"comparator接口出自java\",{\"1\":{\"325\":1}}],[\"comparable接口出自java\",{\"1\":{\"325\":1}}],[\"comparable和comparator的区别\",{\"0\":{\"325\":1}}],[\"company\",{\"1\":{\"111\":10}}],[\"computer\",{\"1\":{\"41\":6,\"42\":5,\"109\":11}}],[\"com\",{\"1\":{\"3\":2,\"4\":1,\"6\":2,\"7\":2,\"10\":1,\"11\":8,\"12\":2,\"13\":2,\"14\":3,\"17\":3,\"18\":2,\"19\":2,\"30\":3,\"31\":4,\"32\":4,\"94\":4,\"169\":1,\"194\":1,\"195\":1,\"232\":1,\"275\":1,\"278\":1,\"324\":1,\"340\":1,\"366\":1,\"368\":1,\"372\":1,\"448\":1,\"453\":1,\"456\":1,\"460\":1,\"465\":1,\"469\":1,\"472\":1,\"476\":1,\"479\":1,\"482\":1,\"485\":1,\"489\":1,\"494\":1,\"498\":1,\"500\":5,\"502\":1,\"518\":1,\"522\":1,\"526\":2,\"530\":1,\"534\":1,\"560\":1,\"563\":2,\"567\":1,\"571\":1,\"578\":1,\"581\":1,\"584\":1,\"595\":1,\"599\":1,\"603\":1,\"607\":1,\"611\":1,\"615\":1,\"651\":3,\"672\":1,\"677\":1,\"681\":1,\"685\":1,\"690\":1,\"694\":1,\"698\":1,\"702\":1,\"731\":1,\"812\":2,\"815\":2,\"891\":1,\"949\":1,\"950\":2,\"1019\":2}}],[\"uglide\",{\"1\":{\"1019\":1}}],[\"udpclient\",{\"1\":{\"898\":1}}],[\"udpserver\",{\"1\":{\"898\":1}}],[\"udp\",{\"0\":{\"898\":1},\"1\":{\"898\":1}}],[\"u\",{\"1\":{\"796\":1,\"858\":1,\"974\":1,\"1015\":2}}],[\"ulimit\",{\"0\":{\"777\":1}}],[\"ultralytics\",{\"1\":{\"32\":1}}],[\"ultralytics公司\",{\"1\":{\"32\":1}}],[\"uri\",{\"1\":{\"768\":1}}],[\"url\",{\"1\":{\"274\":1,\"372\":2,\"644\":1,\"653\":1}}],[\"upload\",{\"1\":{\"961\":1}}],[\"up\",{\"1\":{\"731\":1,\"732\":1,\"737\":1,\"849\":1}}],[\"updatebyid\",{\"1\":{\"983\":1}}],[\"updatesave\",{\"1\":{\"950\":1}}],[\"updateresponse\",{\"1\":{\"934\":1}}],[\"updaterequest\",{\"1\":{\"934\":2}}],[\"updatelastexecutiontime\",{\"1\":{\"791\":1}}],[\"updateandget\",{\"1\":{\"232\":1}}],[\"update\",{\"1\":{\"82\":4,\"287\":1,\"383\":2,\"934\":1,\"983\":1,\"995\":2,\"996\":2,\"997\":4,\"998\":6}}],[\"utc\",{\"1\":{\"993\":1}}],[\"utf\",{\"1\":{\"450\":1,\"668\":1,\"773\":2,\"855\":3,\"898\":1,\"1038\":1}}],[\"util\",{\"1\":{\"194\":2,\"248\":1,\"325\":1,\"441\":2,\"791\":2,\"794\":1,\"806\":1,\"812\":5,\"815\":16,\"825\":1}}],[\"uuid如下图所示\",{\"1\":{\"392\":1}}],[\"uuid的特点\",{\"1\":{\"392\":1}}],[\"uuid的数据量相对有些大\",{\"1\":{\"315\":1}}],[\"uuid\",{\"1\":{\"384\":1,\"439\":2,\"968\":1}}],[\"ui\",{\"1\":{\"293\":1}}],[\"uint32\",{\"1\":{\"277\":3}}],[\"uint16\",{\"1\":{\"277\":3}}],[\"uk即unique\",{\"1\":{\"265\":1}}],[\"ufd\",{\"1\":{\"168\":1}}],[\"usr\",{\"1\":{\"1012\":2,\"1015\":2,\"1016\":2}}],[\"usecontainersupport\",{\"1\":{\"897\":1}}],[\"used\",{\"1\":{\"429\":4}}],[\"usessl=false\",{\"1\":{\"372\":1}}],[\"user4\",{\"1\":{\"1027\":1}}],[\"user相关的key\",{\"1\":{\"1026\":1}}],[\"usermap\",{\"1\":{\"968\":2,\"972\":3}}],[\"usermapper\",{\"1\":{\"366\":1,\"370\":1}}],[\"userdto\",{\"1\":{\"962\":4,\"968\":4,\"972\":4}}],[\"userholder\",{\"1\":{\"961\":1,\"962\":2,\"972\":3,\"995\":1,\"998\":4}}],[\"user3\",{\"1\":{\"934\":2}}],[\"user2\",{\"1\":{\"934\":2}}],[\"user1\",{\"1\":{\"934\":2,\"1042\":3}}],[\"userjson\",{\"1\":{\"934\":2}}],[\"usereventtriggered\",{\"1\":{\"764\":2}}],[\"userregisterrequest对象\",{\"1\":{\"731\":1}}],[\"userregisterrequest\",{\"1\":{\"731\":4,\"732\":4,\"737\":4}}],[\"user>\",{\"1\":{\"372\":1}}],[\"user进行拼接\",{\"1\":{\"368\":1}}],[\"username\",{\"1\":{\"366\":3,\"372\":2,\"731\":2,\"758\":6,\"759\":10,\"760\":3}}],[\"userid\",{\"1\":{\"366\":3,\"995\":2,\"998\":15}}],[\"user表\",{\"1\":{\"366\":1}}],[\"user\",{\"1\":{\"366\":24,\"368\":1,\"370\":4,\"371\":6,\"372\":1,\"391\":1,\"871\":1,\"933\":3,\"934\":17,\"936\":1,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":1,\"946\":1,\"960\":6,\"961\":7,\"962\":5,\"968\":8,\"972\":2,\"974\":1,\"998\":3,\"1016\":1,\"1026\":2,\"1027\":18,\"1032\":3,\"1042\":8,\"1043\":3}}],[\"userservicefactory\",{\"1\":{\"759\":1,\"760\":1}}],[\"userservice\",{\"1\":{\"372\":1,\"731\":1,\"758\":1}}],[\"userserviceimpl代码\",{\"1\":{\"968\":1}}],[\"userserviceimpl\",{\"1\":{\"372\":1}}],[\"users\",{\"1\":{\"89\":2,\"103\":2,\"370\":1,\"1028\":5}}],[\"use\",{\"1\":{\"249\":1}}],[\"using\",{\"1\":{\"3\":1,\"192\":1,\"266\":1,\"283\":1}}],[\"unpooled\",{\"0\":{\"830\":1},\"1\":{\"830\":3}}],[\"unpooleddirectbytebuf\",{\"1\":{\"825\":1}}],[\"unpooledheapbytebuf\",{\"1\":{\"825\":1}}],[\"unpooled|pooled\",{\"1\":{\"820\":1}}],[\"unpark接下来的thread\",{\"1\":{\"261\":1}}],[\"unparksuccessor\",{\"1\":{\"255\":1}}],[\"unpark可以先unpark\",{\"1\":{\"219\":1}}],[\"unpark是以线程为单位来\",{\"1\":{\"219\":1}}],[\"unpark\",{\"1\":{\"219\":1,\"224\":2,\"225\":3}}],[\"unpaired\",{\"1\":{\"3\":1}}],[\"unexpected\",{\"1\":{\"791\":1}}],[\"uncheckedbooleansupplier\",{\"1\":{\"794\":2}}],[\"unchecked\",{\"1\":{\"790\":1}}],[\"unbind\",{\"1\":{\"758\":1,\"762\":2}}],[\"unnamed\",{\"1\":{\"449\":1,\"498\":1,\"502\":1,\"519\":2,\"523\":1}}],[\"undo\",{\"1\":{\"389\":1,\"396\":1}}],[\"undeclaredthrowableexception\",{\"1\":{\"94\":5,\"515\":2}}],[\"understanding\",{\"1\":{\"6\":1,\"13\":1}}],[\"unix\",{\"1\":{\"902\":1}}],[\"unionfind\",{\"1\":{\"285\":2}}],[\"unit\",{\"1\":{\"242\":2,\"751\":1,\"990\":3,\"1016\":1}}],[\"unsigned\",{\"1\":{\"265\":4,\"277\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"255\":5}}],[\"unsafe对象不能直接调用\",{\"1\":{\"235\":1}}],[\"unsafe对象提供了非常底层的\",{\"1\":{\"235\":1}}],[\"unsafe并不是表示线程不安全\",{\"1\":{\"235\":1}}],[\"unsafe\",{\"0\":{\"235\":1},\"1\":{\"235\":5,\"792\":7,\"793\":1}}],[\"unshared\",{\"1\":{\"104\":3}}],[\"unlockwrite\",{\"1\":{\"260\":2}}],[\"unlockread\",{\"1\":{\"260\":2}}],[\"unlock\",{\"1\":{\"224\":2,\"225\":2,\"988\":2,\"989\":1,\"990\":3}}],[\"tl\",{\"1\":{\"962\":4}}],[\"tlv\",{\"1\":{\"890\":2}}],[\"tlab是每个线程独享的\",{\"1\":{\"352\":1}}],[\"tdd\",{\"1\":{\"705\":1}}],[\"tx\",{\"1\":{\"705\":1}}],[\"txt文件\",{\"1\":{\"167\":1}}],[\"txt\",{\"1\":{\"89\":2,\"103\":2,\"846\":2,\"857\":2,\"858\":1,\"870\":4,\"871\":6,\"872\":6,\"904\":1,\"907\":1}}],[\"ttl的返回值就是\",{\"1\":{\"1024\":1}}],[\"ttl\",{\"1\":{\"426\":2,\"429\":1,\"968\":1,\"972\":1,\"983\":1,\"985\":2,\"988\":3,\"989\":1,\"990\":5,\"1024\":6,\"1025\":3}}],[\"t为访问一次内存所需时间\",{\"1\":{\"413\":1}}],[\"t+λ\",{\"1\":{\"413\":1}}],[\"tb\",{\"1\":{\"385\":1,\"968\":1,\"994\":2}}],[\"t2\",{\"1\":{\"224\":9,\"225\":11,\"787\":1}}],[\"t2runned\",{\"1\":{\"224\":6,\"225\":12}}],[\"t1runned\",{\"1\":{\"225\":12}}],[\"t1\",{\"1\":{\"224\":10,\"225\":11,\"787\":1}}],[\"t0\",{\"1\":{\"215\":1}}],[\"t8\",{\"1\":{\"214\":1,\"219\":1}}],[\"t5\",{\"1\":{\"213\":1}}],[\"tmp\",{\"1\":{\"191\":2}}],[\"ts​=s+m∗n\",{\"1\":{\"176\":1}}],[\"ts​\",{\"1\":{\"176\":1}}],[\"tsl指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作\",{\"1\":{\"142\":1}}],[\"tue\",{\"1\":{\"776\":4}}],[\"turn表示当前允许进入临界区的进程号\",{\"1\":{\"141\":1}}],[\"tutorials\",{\"1\":{\"19\":2,\"891\":1}}],[\"tutorial\",{\"1\":{\"12\":1}}],[\"title\",{\"1\":{\"950\":1,\"1005\":2}}],[\"tilnextmillis\",{\"1\":{\"441\":2}}],[\"tinyint\",{\"1\":{\"265\":2}}],[\"tidying\",{\"1\":{\"241\":1}}],[\"timeoutmillis\",{\"1\":{\"792\":4}}],[\"timeout\",{\"0\":{\"775\":1},\"1\":{\"775\":5,\"776\":2,\"882\":1}}],[\"timeout=30s\",{\"1\":{\"499\":1}}],[\"timeout指定等待时间\",{\"1\":{\"410\":1}}],[\"timestamp\",{\"1\":{\"441\":2,\"993\":4}}],[\"timeunit\",{\"1\":{\"242\":1,\"244\":3,\"775\":1,\"792\":1,\"801\":1,\"968\":1,\"972\":1,\"983\":1,\"985\":2,\"988\":3,\"990\":22}}],[\"timed\",{\"1\":{\"208\":1,\"775\":1,\"776\":1}}],[\"time\",{\"1\":{\"139\":1,\"413\":1,\"792\":3,\"990\":6,\"993\":1}}],[\"tiramisu\",{\"1\":{\"74\":1}}],[\"t\",{\"1\":{\"105\":1,\"186\":2,\"277\":6,\"336\":13,\"338\":2,\"342\":1,\"372\":1,\"574\":1,\"742\":6,\"773\":7,\"783\":2,\"787\":2,\"790\":8,\"791\":6,\"793\":8,\"794\":2,\"989\":1,\"990\":2}}],[\"tcl\",{\"1\":{\"1011\":1}}],[\"tcp\",{\"0\":{\"778\":1},\"1\":{\"751\":8,\"764\":1,\"766\":1,\"776\":1,\"842\":1}}],[\"tcp连接\",{\"1\":{\"198\":1}}],[\"tcb\",{\"1\":{\"135\":1}}],[\"tc\",{\"1\":{\"104\":2}}],[\"teardown\",{\"1\":{\"1032\":1,\"1035\":1}}],[\"teachers\",{\"1\":{\"731\":2,\"737\":1}}],[\"terms\",{\"1\":{\"946\":1}}],[\"termsquery\",{\"1\":{\"944\":3}}],[\"termsquerybuilder\",{\"1\":{\"944\":1}}],[\"termquerybuilder\",{\"1\":{\"950\":1}}],[\"termquerybypage\",{\"1\":{\"950\":1}}],[\"termquery\",{\"1\":{\"937\":1,\"950\":3}}],[\"terminated\",{\"1\":{\"208\":1,\"241\":1}}],[\"terminate\",{\"1\":{\"132\":1}}],[\"text\",{\"1\":{\"617\":2,\"622\":2,\"950\":1}}],[\"template\",{\"1\":{\"119\":1,\"463\":1,\"1041\":7}}],[\"testhash\",{\"1\":{\"1032\":1,\"1043\":1}}],[\"testidworker\",{\"1\":{\"993\":1}}],[\"test<\",{\"1\":{\"931\":1,\"948\":3,\"1038\":1}}],[\"testfilechanneltransferto\",{\"1\":{\"870\":1}}],[\"testfinal\",{\"1\":{\"237\":1}}],[\"testclient\",{\"1\":{\"845\":1}}],[\"testconnectiontimeout\",{\"1\":{\"775\":1}}],[\"testcomputer\",{\"1\":{\"109\":2}}],[\"testsaveuser\",{\"1\":{\"1042\":1}}],[\"testsaveshop\",{\"1\":{\"989\":1}}],[\"teststring\",{\"1\":{\"1032\":1,\"1040\":1,\"1042\":1}}],[\"testslice\",{\"1\":{\"826\":1}}],[\"testserver\",{\"1\":{\"845\":1}}],[\"testservice\",{\"1\":{\"732\":1,\"737\":1}}],[\"testservletdatabinderfactory\",{\"1\":{\"581\":1}}],[\"testpipeline\",{\"1\":{\"816\":1}}],[\"testprocessorder\",{\"1\":{\"465\":1}}],[\"testmethodinvoke\",{\"1\":{\"518\":1}}],[\"testmethodtemplate\",{\"1\":{\"463\":1}}],[\"testmessagesource\",{\"1\":{\"450\":1}}],[\"testbeanfactory\",{\"1\":{\"453\":1}}],[\"test2\",{\"1\":{\"277\":3,\"339\":3}}],[\"test1\",{\"1\":{\"277\":3}}],[\"testandset指令\",{\"1\":{\"142\":1}}],[\"test\",{\"1\":{\"103\":2,\"206\":1,\"224\":3,\"225\":3,\"336\":3,\"366\":4,\"372\":1,\"498\":1,\"705\":1,\"950\":10,\"989\":1,\"993\":1,\"1032\":2,\"1040\":1,\"1042\":2,\"1043\":1}}],[\"test类\",{\"1\":{\"103\":2}}],[\"tensorflow\",{\"1\":{\"19\":1}}],[\"type里面\",{\"1\":{\"924\":1}}],[\"type为application\",{\"1\":{\"731\":1,\"737\":1}}],[\"typeconvert\",{\"1\":{\"691\":1}}],[\"typeconverter\",{\"1\":{\"576\":2,\"688\":1}}],[\"type=forking\",{\"1\":{\"1016\":1}}],[\"type=web\",{\"1\":{\"731\":2}}],[\"type=\",{\"1\":{\"366\":2,\"820\":1}}],[\"type=index\",{\"1\":{\"266\":1}}],[\"type\",{\"0\":{\"923\":1},\"1\":{\"63\":3,\"65\":3,\"660\":1,\"731\":3,\"737\":2,\"773\":4,\"783\":6,\"794\":1,\"890\":1,\"923\":1,\"950\":4,\"961\":1,\"990\":9}}],[\"tf\",{\"1\":{\"41\":5,\"42\":2}}],[\"tf卡实现类\",{\"1\":{\"41\":1}}],[\"tf卡接口\",{\"1\":{\"41\":1}}],[\"tfcardimpl\",{\"1\":{\"41\":2,\"42\":1}}],[\"tfcard\",{\"1\":{\"41\":2,\"42\":11}}],[\"tailcontext\",{\"1\":{\"825\":2}}],[\"tail\",{\"1\":{\"790\":1,\"793\":2,\"816\":1,\"825\":1}}],[\"tasks\",{\"1\":{\"896\":3}}],[\"task\",{\"1\":{\"265\":1,\"791\":6,\"792\":1,\"800\":2,\"896\":3,\"993\":2}}],[\"task2\",{\"1\":{\"263\":4}}],[\"task1会优先运行2次\",{\"1\":{\"263\":1}}],[\"task1\",{\"1\":{\"263\":4}}],[\"tabat\",{\"1\":{\"249\":3}}],[\"tab\",{\"1\":{\"249\":14}}],[\"tablenamesuffix\",{\"1\":{\"368\":3}}],[\"tablename\",{\"1\":{\"366\":2,\"368\":3}}],[\"tablesizefor\",{\"1\":{\"249\":1}}],[\"tablesizefor是为了保证计算的大小是2^n\",{\"1\":{\"249\":1}}],[\"table\",{\"1\":{\"249\":3,\"267\":4,\"268\":1,\"385\":1,\"849\":8}}],[\"tar\",{\"1\":{\"1012\":2}}],[\"tara\",{\"1\":{\"116\":9}}],[\"targetname\",{\"1\":{\"873\":3}}],[\"targetfastclass\",{\"1\":{\"526\":1,\"527\":3}}],[\"target\",{\"1\":{\"40\":1,\"95\":2,\"496\":1,\"503\":1,\"510\":8,\"512\":9,\"515\":2,\"523\":5,\"527\":1,\"546\":1,\"731\":1,\"859\":4,\"872\":12,\"873\":2,\"890\":4,\"1016\":2}}],[\"talk\",{\"1\":{\"111\":1}}],[\"tachibanayoshino\",{\"1\":{\"11\":1}}],[\"trigger\",{\"1\":{\"410\":4}}],[\"trienode\",{\"1\":{\"282\":10}}],[\"trie\",{\"1\":{\"282\":1}}],[\"trx\",{\"1\":{\"393\":1}}],[\"treeset<>\",{\"1\":{\"441\":1}}],[\"treeset\",{\"1\":{\"441\":1}}],[\"treeset用于支持元素的自定义排序场景\",{\"1\":{\"326\":1}}],[\"treeset底层采用红黑树\",{\"1\":{\"326\":1}}],[\"tree下标从1开始\",{\"1\":{\"287\":1}}],[\"treearray\",{\"1\":{\"287\":2}}],[\"tree\",{\"1\":{\"286\":1,\"287\":5}}],[\"treenode\",{\"1\":{\"283\":12}}],[\"treenode<k\",{\"1\":{\"249\":1}}],[\"tree的最左前缀匹配特性\",{\"1\":{\"266\":1}}],[\"treeifybin\",{\"1\":{\"249\":1}}],[\"treeify\",{\"1\":{\"249\":1}}],[\"treebin\",{\"1\":{\"249\":1}}],[\"treebin<k\",{\"1\":{\"249\":2}}],[\"truncate\",{\"1\":{\"267\":2}}],[\"true未匹配到指定数据源时抛异常\",{\"1\":{\"372\":1}}],[\"true\",{\"1\":{\"103\":1,\"116\":1,\"141\":1,\"206\":1,\"224\":2,\"225\":9,\"234\":1,\"235\":1,\"255\":2,\"531\":1,\"600\":3,\"622\":1,\"711\":1,\"751\":1,\"758\":1,\"759\":3,\"760\":1,\"761\":6,\"778\":1,\"783\":2,\"790\":4,\"791\":5,\"792\":2,\"793\":4,\"794\":3,\"804\":1,\"825\":1,\"829\":2,\"844\":1,\"845\":2,\"846\":1,\"869\":1,\"876\":1,\"877\":1,\"884\":1,\"886\":1,\"889\":2,\"890\":1,\"893\":2,\"896\":4,\"961\":1,\"968\":2,\"972\":4,\"998\":1}}],[\"truth的iou不是最大的anchor既不是正样本也不是负样本\",{\"1\":{\"25\":1}}],[\"truth的iou最大的anchor为正样本\",{\"1\":{\"25\":1}}],[\"truth的iou最大的anchor负责预测这个ground\",{\"1\":{\"24\":1}}],[\"truth的iou小于阈值的anchor为负样本\",{\"1\":{\"25\":1}}],[\"truth\",{\"1\":{\"24\":1}}],[\"traffic\",{\"1\":{\"917\":1}}],[\"trade\",{\"1\":{\"265\":1}}],[\"transferfrom\",{\"1\":{\"905\":1}}],[\"transferto\",{\"1\":{\"870\":4,\"905\":3}}],[\"transmission\",{\"1\":{\"751\":1}}],[\"transaction注解属性propagation设置错误\",{\"1\":{\"723\":1}}],[\"transaction应用再非public修饰的方法上\",{\"1\":{\"723\":1}}],[\"transactioninterceptor\",{\"1\":{\"662\":1}}],[\"transaction\",{\"1\":{\"662\":1}}],[\"transactionautoconfiguration\",{\"0\":{\"662\":1},\"1\":{\"662\":1}}],[\"transactional失效场景\",{\"0\":{\"723\":1}}],[\"transactional注解属性rollbackfor设置错误\",{\"1\":{\"723\":1}}],[\"transactional注解中如果不配置rollbackfor属性\",{\"1\":{\"722\":1}}],[\"transactional注解上\",{\"1\":{\"721\":1}}],[\"transactional注解就是通过aop实现的\",{\"1\":{\"706\":1}}],[\"transactional进行标注的\",{\"1\":{\"721\":1}}],[\"transactional的默认选项\",{\"1\":{\"720\":1}}],[\"transactional的全注解方式使用最多\",{\"1\":{\"719\":1}}],[\"transactional\",{\"0\":{\"722\":1},\"1\":{\"535\":1,\"662\":1,\"983\":1,\"994\":1,\"998\":2}}],[\"transactional事务不要滥用\",{\"1\":{\"268\":1}}],[\"transient\",{\"1\":{\"234\":3,\"249\":3}}],[\"translation\",{\"1\":{\"3\":2,\"16\":1}}],[\"trainstation\",{\"1\":{\"93\":3,\"94\":6,\"95\":10}}],[\"trylock\",{\"1\":{\"988\":2,\"989\":1,\"990\":3}}],[\"tryfailure\",{\"1\":{\"775\":1}}],[\"tryoptimisticread\",{\"1\":{\"260\":2}}],[\"tryreleaseshared\",{\"1\":{\"255\":3}}],[\"tryrelease\",{\"1\":{\"255\":3}}],[\"tryacquireshared\",{\"1\":{\"255\":5}}],[\"tryacquire\",{\"1\":{\"255\":5}}],[\"try\",{\"1\":{\"77\":1,\"82\":2,\"94\":5,\"104\":2,\"123\":1,\"206\":1,\"221\":2,\"224\":4,\"225\":4,\"260\":2,\"263\":4,\"515\":3,\"743\":1,\"744\":1,\"749\":2,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"759\":3,\"767\":1,\"768\":1,\"773\":3,\"775\":1,\"776\":1,\"783\":3,\"784\":1,\"785\":1,\"787\":1,\"790\":5,\"791\":6,\"792\":2,\"793\":5,\"794\":1,\"809\":1,\"810\":1,\"811\":1,\"812\":1,\"813\":1,\"814\":1,\"815\":2,\"825\":2,\"845\":4,\"846\":1,\"857\":1,\"858\":1,\"870\":2,\"873\":1,\"884\":2,\"886\":1,\"890\":1,\"896\":4,\"898\":2,\"907\":1,\"909\":3,\"932\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"twitter\",{\"1\":{\"18\":1,\"440\":1}}],[\"than\",{\"1\":{\"849\":1}}],[\"that\",{\"1\":{\"825\":1}}],[\"things\",{\"1\":{\"907\":2}}],[\"think\",{\"1\":{\"89\":2,\"103\":2}}],[\"this\",{\"1\":{\"42\":1,\"49\":5,\"52\":13,\"69\":1,\"82\":1,\"87\":2,\"89\":5,\"94\":11,\"95\":1,\"105\":1,\"109\":6,\"111\":6,\"116\":5,\"120\":5,\"236\":1,\"249\":1,\"260\":1,\"262\":1,\"287\":2,\"441\":2,\"500\":2,\"515\":3,\"626\":1,\"630\":1,\"743\":5,\"744\":10,\"775\":1,\"783\":5,\"790\":4,\"791\":2,\"792\":1,\"793\":2,\"896\":3,\"909\":5,\"972\":1,\"983\":2,\"985\":1,\"988\":1,\"989\":2,\"990\":6,\"993\":1,\"995\":1,\"996\":2,\"998\":1}}],[\"thisiszhou\",{\"1\":{\"31\":1}}],[\"thisvesseldoesnotexist\",{\"1\":{\"11\":1}}],[\"thispersondoesnotexist\",{\"1\":{\"11\":1}}],[\"through\",{\"1\":{\"981\":1}}],[\"throwable\",{\"1\":{\"94\":22,\"95\":1,\"515\":2,\"742\":1,\"743\":3,\"744\":6,\"762\":1,\"785\":1,\"790\":6,\"791\":3,\"793\":5,\"794\":1,\"907\":1,\"909\":3}}],[\"throws\",{\"1\":{\"44\":2,\"86\":2,\"87\":2,\"89\":3,\"94\":2,\"95\":1,\"103\":4,\"104\":3,\"105\":1,\"123\":3,\"206\":1,\"255\":2,\"515\":2,\"523\":1,\"622\":1,\"655\":2,\"657\":1,\"711\":6,\"743\":1,\"744\":1,\"749\":5,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"759\":5,\"760\":2,\"761\":5,\"762\":2,\"764\":2,\"767\":1,\"768\":3,\"770\":2,\"771\":2,\"773\":2,\"776\":2,\"783\":2,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"790\":6,\"792\":1,\"793\":2,\"798\":5,\"803\":1,\"804\":3,\"807\":1,\"808\":2,\"816\":7,\"844\":1,\"845\":2,\"872\":6,\"889\":2,\"890\":1,\"893\":2,\"896\":3,\"907\":1,\"909\":1,\"961\":1,\"972\":3,\"993\":1,\"1042\":1}}],[\"throw\",{\"1\":{\"41\":1,\"63\":1,\"82\":2,\"94\":10,\"104\":1,\"123\":2,\"236\":3,\"249\":2,\"255\":7,\"262\":1,\"441\":3,\"515\":5,\"743\":1,\"744\":1,\"773\":4,\"783\":1,\"787\":1,\"791\":1,\"849\":1,\"932\":1,\"988\":1,\"989\":1,\"990\":2}}],[\"threshold\",{\"1\":{\"249\":1,\"792\":2}}],[\"threadexecutormap\",{\"1\":{\"812\":1,\"815\":2}}],[\"threadexecutormap$2\",{\"1\":{\"812\":1,\"815\":2}}],[\"threading\",{\"1\":{\"409\":1}}],[\"threads\",{\"1\":{\"249\":1}}],[\"threadlocal中是否有用户\",{\"1\":{\"972\":1}}],[\"threadlocal<>\",{\"1\":{\"962\":1}}],[\"threadlocal<userdto>\",{\"1\":{\"962\":1}}],[\"threadlocalmap也是通过强引用指向entry对象\",{\"1\":{\"247\":1}}],[\"threadlocal底层是通过threadlocalmap来实现的\",{\"1\":{\"247\":1}}],[\"threadlocal是java所提供的线程本地存储机制\",{\"1\":{\"247\":1}}],[\"threadlocal\",{\"0\":{\"247\":1},\"1\":{\"842\":1,\"972\":1}}],[\"threadfactory\",{\"1\":{\"242\":3,\"244\":3}}],[\"threadpoolexecutor参数\",{\"0\":{\"242\":1}}],[\"threadpoolexecutor\",{\"1\":{\"241\":1,\"242\":1,\"244\":5}}],[\"thread中的方法\",{\"1\":{\"204\":1}}],[\"thread\",{\"1\":{\"82\":2,\"206\":6,\"211\":4,\"221\":4,\"224\":12,\"225\":12,\"234\":1,\"255\":2,\"261\":2,\"263\":2,\"743\":2,\"744\":2,\"759\":1,\"791\":4,\"792\":1,\"796\":2,\"798\":1,\"800\":1,\"801\":1,\"804\":1,\"807\":1,\"808\":1,\"809\":2,\"810\":1,\"811\":1,\"812\":4,\"813\":1,\"814\":1,\"815\":4,\"844\":1,\"845\":5,\"896\":2,\"907\":2,\"909\":3,\"917\":1,\"988\":2,\"990\":1}}],[\"then\",{\"1\":{\"386\":2}}],[\"theunsafe\",{\"1\":{\"235\":4}}],[\"therad\",{\"1\":{\"234\":1}}],[\"the\",{\"1\":{\"6\":1,\"13\":1,\"105\":6,\"790\":1,\"825\":2,\"849\":8,\"1025\":2}}],[\"toepochsecond\",{\"1\":{\"993\":1}}],[\"toseconds\",{\"1\":{\"990\":1}}],[\"tostring\",{\"1\":{\"52\":2,\"94\":2,\"116\":2,\"731\":2,\"767\":1,\"783\":2,\"798\":2,\"812\":1,\"813\":2,\"814\":2,\"816\":5,\"818\":1,\"844\":2,\"849\":3,\"855\":1,\"873\":1,\"893\":1,\"950\":1,\"960\":1,\"968\":2,\"994\":1,\"998\":4}}],[\"tobean\",{\"1\":{\"983\":1,\"985\":1,\"988\":1,\"989\":2,\"990\":4}}],[\"tobytearray\",{\"1\":{\"770\":1,\"771\":1,\"773\":2}}],[\"tohexstring\",{\"1\":{\"849\":2}}],[\"touch\",{\"1\":{\"799\":1}}],[\"touppercase\",{\"1\":{\"336\":1}}],[\"tonanos\",{\"1\":{\"792\":1}}],[\"tojsonstr\",{\"1\":{\"985\":1,\"988\":1,\"989\":1,\"990\":3}}],[\"tojson\",{\"1\":{\"773\":1}}],[\"toarray\",{\"1\":{\"670\":1,\"790\":2}}],[\"tofile\",{\"1\":{\"655\":1,\"872\":1}}],[\"tomcat也不例外\",{\"1\":{\"961\":1}}],[\"tomcat的运行原理\",{\"1\":{\"961\":1}}],[\"tomcat\",{\"0\":{\"617\":1,\"653\":1,\"654\":1},\"1\":{\"561\":1,\"617\":5,\"619\":1,\"620\":1,\"648\":7,\"653\":1,\"655\":12,\"660\":1,\"841\":1}}],[\"tomap\",{\"1\":{\"343\":1}}],[\"tommyzihao\",{\"1\":{\"19\":1}}],[\"tocollection\",{\"1\":{\"343\":1}}],[\"tochararray\",{\"1\":{\"282\":3,\"339\":1,\"849\":1}}],[\"tolist\",{\"1\":{\"343\":1}}],[\"tokenkey\",{\"1\":{\"968\":3}}],[\"token刷新的拦截器\",{\"1\":{\"961\":1}}],[\"tokenargumentresolver\",{\"1\":{\"563\":1}}],[\"token\",{\"1\":{\"315\":1,\"968\":3,\"972\":3}}],[\"token机制实现接口幂等性\",{\"1\":{\"315\":1}}],[\"token机制如何实现\",{\"1\":{\"315\":1}}],[\"token机制\",{\"1\":{\"315\":1}}],[\"totalbytesread\",{\"1\":{\"794\":1}}],[\"totalmessages\",{\"1\":{\"794\":1}}],[\"totalmemory\",{\"1\":{\"105\":1}}],[\"total\",{\"1\":{\"116\":2}}],[\"to\",{\"1\":{\"3\":1,\"16\":1,\"105\":1,\"111\":2,\"162\":1,\"249\":1,\"744\":2,\"760\":2,\"790\":1,\"849\":3,\"870\":8}}],[\"todo\",{\"0\":{\"747\":1,\"919\":1},\"1\":{\"0\":1,\"724\":1}}],[\"幻灯片页\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}";